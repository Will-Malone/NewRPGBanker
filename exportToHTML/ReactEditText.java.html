<html>
<head>
<title>ReactEditText.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #77b767; font-style: italic;}
.s5 { color: #629755; font-weight: bold; font-style: italic;}
.s6 { color: #6897bb;}
.s7 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactEditText.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.views.textinput</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.react.uimanager.UIManagerHelper.getReactContext</span><span class="s2">;</span>
<span class="s2">import static </span><span class="s1">com.facebook.react.views.text.TextAttributeProps.UNSET</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Color</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Paint</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Rect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Typeface</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.Drawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Build</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Bundle</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.Editable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.InputType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.Spannable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.SpannableStringBuilder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.Spanned</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.TextUtils</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.TextWatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.method.KeyListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.text.method.QwertyKeyListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.util.TypedValue</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.Gravity</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.KeyEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.MotionEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.accessibility.AccessibilityNodeInfo</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.inputmethod.EditorInfo</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.inputmethod.InputConnection</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.inputmethod.InputMethodManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.appcompat.widget.AppCompatEditText</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.core.view.ViewCompat</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactSoftExceptionLogger</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.build.ReactBuildConfig</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.FabricViewStateManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.ReactAccessibilityDelegate</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIManagerModule</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.EventDispatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.CustomLetterSpacingSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.CustomLineHeightSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.CustomStyleSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.ReactAbsoluteSizeSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.ReactBackgroundColorSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.ReactForegroundColorSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.ReactSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.ReactStrikethroughSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.ReactTextUpdate</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.ReactTypefaceUtils</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.ReactUnderlineSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.TextAttributes</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.TextInlineImageSpan</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.text.TextLayoutManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.view.ReactViewBackgroundManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Objects</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* A wrapper around the EditText that lets us better control what happens when an EditText gets</span>
 <span class="s3">* focused or blurred, and when to display the soft keyboard and when not to.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">ReactEditTexts have setFocusableInTouchMode set to false automatically because touches on the</span>
 <span class="s3">* EditText are managed on the JS side. This also removes the nasty side effect that EditTexts have,</span>
 <span class="s3">* which is that focus is always maintained on one of the EditTexts.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">&lt;p&gt;</span><span class="s3">The wrapper stops the EditText from triggering *TextChanged events, in the case where JS has</span>
 <span class="s3">* called this explicitly. This is the default behavior on other platforms as well.</span>
 <span class="s3">* VisibleForTesting from {</span><span class="s5">@link </span><span class="s3">TextInputEventsTestCase}.</span>
 <span class="s3">*/</span>
<span class="s2">public class </span><span class="s1">ReactEditText </span><span class="s2">extends </span><span class="s1">AppCompatEditText</span>
    <span class="s2">implements </span><span class="s1">FabricViewStateManager.HasFabricViewStateManager {</span>
  <span class="s2">private final </span><span class="s1">InputMethodManager mInputMethodManager</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">String TAG = ReactEditText.</span><span class="s2">class</span><span class="s1">.getSimpleName()</span><span class="s2">;</span>
  <span class="s2">public static final boolean </span><span class="s1">DEBUG_MODE = ReactBuildConfig.DEBUG &amp;&amp; </span><span class="s2">false;</span>

  <span class="s0">// This flag is set to true when we set the text of the EditText explicitly. In that case, no</span>
  <span class="s0">// *TextChanged events should be triggered. This is less expensive than removing the text</span>
  <span class="s0">// listeners and adding them back again after the text change is completed.</span>
  <span class="s2">protected boolean </span><span class="s1">mIsSettingTextFromJS</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mDefaultGravityHorizontal</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mDefaultGravityVertical</span><span class="s2">;</span>

  <span class="s3">/** A count of events sent to JS or C++. */</span>
  <span class="s2">protected int </span><span class="s1">mNativeEventCount</span><span class="s2">;</span>

  <span class="s2">private static final int </span><span class="s1">UNSET = -</span><span class="s6">1</span><span class="s2">;</span>

  <span class="s2">private </span><span class="s1">@Nullable ArrayList&lt;TextWatcher&gt; mListeners</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable TextWatcherDelegator mTextWatcherDelegator</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mStagedInputType</span><span class="s2">;</span>
  <span class="s2">protected boolean </span><span class="s1">mContainsImages</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mSubmitBehavior = </span><span class="s2">null;</span>
  <span class="s2">private boolean </span><span class="s1">mDisableFullscreen</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mReturnKeyType</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable SelectionWatcher mSelectionWatcher</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ContentSizeWatcher mContentSizeWatcher</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ScrollWatcher mScrollWatcher</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">InternalKeyListener mKeyListener</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mDetectScrollMovement = </span><span class="s2">false;</span>
  <span class="s2">private boolean </span><span class="s1">mOnKeyPress = </span><span class="s2">false;</span>
  <span class="s2">private </span><span class="s1">TextAttributes mTextAttributes</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mTypefaceDirty = </span><span class="s2">false;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mFontFamily = </span><span class="s2">null;</span>
  <span class="s2">private int </span><span class="s1">mFontWeight = UNSET</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mFontStyle = UNSET</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mAutoFocus = </span><span class="s2">false;</span>
  <span class="s2">private boolean </span><span class="s1">mDidAttachToWindow = </span><span class="s2">false;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mPlaceholder = </span><span class="s2">null;</span>

  <span class="s2">private </span><span class="s1">ReactViewBackgroundManager mReactBackgroundManager</span><span class="s2">;</span>

  <span class="s2">private final </span><span class="s1">FabricViewStateManager mFabricViewStateManager = </span><span class="s2">new </span><span class="s1">FabricViewStateManager()</span><span class="s2">;</span>
  <span class="s2">protected boolean </span><span class="s1">mDisableTextDiffing = </span><span class="s2">false;</span>

  <span class="s2">protected boolean </span><span class="s1">mIsSettingTextFromState = </span><span class="s2">false;</span>

  <span class="s2">private static final </span><span class="s1">KeyListener sKeyListener = QwertyKeyListener.getInstanceForFullKeyboard()</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable EventDispatcher mEventDispatcher</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">ReactEditText(Context context) {</span>
    <span class="s2">super</span><span class="s1">(context)</span><span class="s2">;</span>
    <span class="s1">setFocusableInTouchMode(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">mReactBackgroundManager = </span><span class="s2">new </span><span class="s1">ReactViewBackgroundManager(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">mInputMethodManager =</span>
        <span class="s1">(InputMethodManager)</span>
            <span class="s1">Assertions.assertNotNull(context.getSystemService(Context.INPUT_METHOD_SERVICE))</span><span class="s2">;</span>
    <span class="s1">mDefaultGravityHorizontal =</span>
        <span class="s1">getGravity() &amp; (Gravity.HORIZONTAL_GRAVITY_MASK | Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK)</span><span class="s2">;</span>
    <span class="s1">mDefaultGravityVertical = getGravity() &amp; Gravity.VERTICAL_GRAVITY_MASK</span><span class="s2">;</span>
    <span class="s1">mNativeEventCount = </span><span class="s6">0</span><span class="s2">;</span>
    <span class="s1">mIsSettingTextFromJS = </span><span class="s2">false;</span>
    <span class="s1">mDisableFullscreen = </span><span class="s2">false;</span>
    <span class="s1">mListeners = </span><span class="s2">null;</span>
    <span class="s1">mTextWatcherDelegator = </span><span class="s2">null;</span>
    <span class="s1">mStagedInputType = getInputType()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mKeyListener == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mKeyListener = </span><span class="s2">new </span><span class="s1">InternalKeyListener()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mScrollWatcher = </span><span class="s2">null;</span>
    <span class="s1">mTextAttributes = </span><span class="s2">new </span><span class="s1">TextAttributes()</span><span class="s2">;</span>

    <span class="s1">applyTextAttributes()</span><span class="s2">;</span>

    <span class="s0">// Turn off hardware acceleration for Oreo (T40484798)</span>
    <span class="s0">// see https://issuetracker.google.com/issues/67102093</span>
    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O</span>
        <span class="s1">&amp;&amp; Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.O_MR1) {</span>
      <span class="s1">setLayerType(View.LAYER_TYPE_SOFTWARE</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ReactAccessibilityDelegate editTextAccessibilityDelegate =</span>
        <span class="s2">new </span><span class="s1">ReactAccessibilityDelegate(</span>
            <span class="s2">this, this</span><span class="s1">.isFocusable()</span><span class="s2">, this</span><span class="s1">.getImportantForAccessibility()) {</span>
          <span class="s1">@Override</span>
          <span class="s2">public boolean </span><span class="s1">performAccessibilityAction(View host</span><span class="s2">, int </span><span class="s1">action</span><span class="s2">, </span><span class="s1">Bundle args) {</span>
            <span class="s2">if </span><span class="s1">(action == AccessibilityNodeInfo.ACTION_CLICK) {</span>
              <span class="s2">int </span><span class="s1">length = getText().length()</span><span class="s2">;</span>
              <span class="s2">if </span><span class="s1">(length &gt; </span><span class="s6">0</span><span class="s1">) {</span>
                <span class="s0">// For some reason, when you swipe to focus on a text input that already has text in</span>
                <span class="s0">// it, it clears the selection and resets the cursor to the beginning of the input.</span>
                <span class="s0">// Since this is not typically (ever?) what you want, let's just explicitly set the</span>
                <span class="s0">// selection on accessibility click to undo that.</span>
                <span class="s1">setSelection(length)</span><span class="s2">;</span>
              <span class="s1">}</span>
              <span class="s2">return </span><span class="s1">requestFocusInternal()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return super</span><span class="s1">.performAccessibilityAction(host</span><span class="s2">, </span><span class="s1">action</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">ViewCompat.setAccessibilityDelegate(</span><span class="s2">this, </span><span class="s1">editTextAccessibilityDelegate)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">finalize() {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s7">&quot;finalize[&quot; </span><span class="s1">+ getId() + </span><span class="s7">&quot;] delete cached spannable&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">TextLayoutManager.deleteCachedSpannableForTag(getId())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// After the text changes inside an EditText, TextView checks if a layout() has been requested.</span>
  <span class="s0">// If it has, it will not scroll the text to the end of the new text inserted, but wait for the</span>
  <span class="s0">// next layout() to be called. However, we do not perform a layout() after a requestLayout(), so</span>
  <span class="s0">// we need to override isLayoutRequested to force EditText to scroll to the end of the new text</span>
  <span class="s0">// immediately.</span>
  <span class="s0">// TODO: t6408636 verify if we should schedule a layout after a View does a requestLayout()</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">isLayoutRequested() {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onLayout(</span><span class="s2">boolean </span><span class="s1">changed</span><span class="s2">, int </span><span class="s1">left</span><span class="s2">, int </span><span class="s1">top</span><span class="s2">, int </span><span class="s1">right</span><span class="s2">, int </span><span class="s1">bottom) {</span>
    <span class="s1">onContentSizeChange()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onTouchEvent(MotionEvent ev) {</span>
    <span class="s2">switch </span><span class="s1">(ev.getAction()) {</span>
      <span class="s2">case </span><span class="s1">MotionEvent.ACTION_DOWN:</span>
        <span class="s1">mDetectScrollMovement = </span><span class="s2">true;</span>
        <span class="s0">// Disallow parent views to intercept touch events, until we can detect if we should be</span>
        <span class="s0">// capturing these touches or not.</span>
        <span class="s2">this</span><span class="s1">.getParent().requestDisallowInterceptTouchEvent(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">MotionEvent.ACTION_MOVE:</span>
        <span class="s2">if </span><span class="s1">(mDetectScrollMovement) {</span>
          <span class="s2">if </span><span class="s1">(!canScrollVertically(-</span><span class="s6">1</span><span class="s1">)</span>
              <span class="s1">&amp;&amp; !canScrollVertically(</span><span class="s6">1</span><span class="s1">)</span>
              <span class="s1">&amp;&amp; !canScrollHorizontally(-</span><span class="s6">1</span><span class="s1">)</span>
              <span class="s1">&amp;&amp; !canScrollHorizontally(</span><span class="s6">1</span><span class="s1">)) {</span>
            <span class="s0">// We cannot scroll, let parent views take care of these touches.</span>
            <span class="s2">this</span><span class="s1">.getParent().requestDisallowInterceptTouchEvent(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">mDetectScrollMovement = </span><span class="s2">false;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
    <span class="s1">}</span>
    <span class="s2">return super</span><span class="s1">.onTouchEvent(ev)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Consume 'Enter' key events: TextView tries to give focus to the next TextInput, but it can't</span>
  <span class="s0">// since we only allow JS to change focus, which in turn causes TextView to crash.</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">onKeyUp(</span><span class="s2">int </span><span class="s1">keyCode</span><span class="s2">, </span><span class="s1">KeyEvent event) {</span>
    <span class="s2">if </span><span class="s1">(keyCode == KeyEvent.KEYCODE_ENTER &amp;&amp; !isMultiline()) {</span>
      <span class="s1">hideSoftKeyboard()</span><span class="s2">;</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">return super</span><span class="s1">.onKeyUp(keyCode</span><span class="s2">, </span><span class="s1">event)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onScrollChanged(</span><span class="s2">int </span><span class="s1">horiz</span><span class="s2">, int </span><span class="s1">vert</span><span class="s2">, int </span><span class="s1">oldHoriz</span><span class="s2">, int </span><span class="s1">oldVert) {</span>
    <span class="s2">super</span><span class="s1">.onScrollChanged(horiz</span><span class="s2">, </span><span class="s1">vert</span><span class="s2">, </span><span class="s1">oldHoriz</span><span class="s2">, </span><span class="s1">oldVert)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mScrollWatcher != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mScrollWatcher.onScrollChanged(horiz</span><span class="s2">, </span><span class="s1">vert</span><span class="s2">, </span><span class="s1">oldHoriz</span><span class="s2">, </span><span class="s1">oldVert)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">InputConnection onCreateInputConnection(EditorInfo outAttrs) {</span>
    <span class="s1">ReactContext reactContext = getReactContext(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">InputConnection inputConnection = </span><span class="s2">super</span><span class="s1">.onCreateInputConnection(outAttrs)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(inputConnection != </span><span class="s2">null </span><span class="s1">&amp;&amp; mOnKeyPress) {</span>
      <span class="s1">inputConnection =</span>
          <span class="s2">new </span><span class="s1">ReactEditTextInputConnectionWrapper(</span>
              <span class="s1">inputConnection</span><span class="s2">, </span><span class="s1">reactContext</span><span class="s2">, this, </span><span class="s1">mEventDispatcher)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isMultiline() &amp;&amp; (shouldBlurOnReturn() || shouldSubmitOnReturn())) {</span>
      <span class="s0">// Remove IME_FLAG_NO_ENTER_ACTION to keep the original IME_OPTION</span>
      <span class="s1">outAttrs.imeOptions &amp;= ~EditorInfo.IME_FLAG_NO_ENTER_ACTION</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">inputConnection</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">clearFocus() {</span>
    <span class="s1">setFocusableInTouchMode(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">super</span><span class="s1">.clearFocus()</span><span class="s2">;</span>
    <span class="s1">hideSoftKeyboard()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">requestFocus(</span><span class="s2">int </span><span class="s1">direction</span><span class="s2">, </span><span class="s1">Rect previouslyFocusedRect) {</span>
    <span class="s0">// This is a no-op so that when the OS calls requestFocus(), nothing will happen. ReactEditText</span>
    <span class="s0">// is a controlled component, which means its focus is controlled by JS, with two exceptions:</span>
    <span class="s0">// autofocus when it's attached to the window, and responding to accessibility events. In both</span>
    <span class="s0">// of these cases, we call requestFocusInternal() directly.</span>
    <span class="s2">return </span><span class="s1">isFocused()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">requestFocusInternal() {</span>
    <span class="s1">setFocusableInTouchMode(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s0">// We must explicitly call this method on the super class; if we call requestFocus() without</span>
    <span class="s0">// any arguments, it will call into the overridden requestFocus(int, Rect) above, which no-ops.</span>
    <span class="s2">boolean </span><span class="s1">focused = </span><span class="s2">super</span><span class="s1">.requestFocus(View.FOCUS_DOWN</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(getShowSoftInputOnFocus()) {</span>
      <span class="s1">showSoftKeyboard()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">focused</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">addTextChangedListener(TextWatcher watcher) {</span>
    <span class="s2">if </span><span class="s1">(mListeners == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mListeners = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
      <span class="s2">super</span><span class="s1">.addTextChangedListener(getTextWatcherDelegator())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mListeners.add(watcher)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">removeTextChangedListener(TextWatcher watcher) {</span>
    <span class="s2">if </span><span class="s1">(mListeners != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mListeners.remove(watcher)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(mListeners.isEmpty()) {</span>
        <span class="s1">mListeners = </span><span class="s2">null;</span>
        <span class="s2">super</span><span class="s1">.removeTextChangedListener(getTextWatcherDelegator())</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setContentSizeWatcher(ContentSizeWatcher contentSizeWatcher) {</span>
    <span class="s1">mContentSizeWatcher = contentSizeWatcher</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setScrollWatcher(ScrollWatcher scrollWatcher) {</span>
    <span class="s1">mScrollWatcher = scrollWatcher</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Attempt to set a selection or fail silently. Intentionally meant to handle bad inputs.</span>
   <span class="s3">* EventCounter is the same one used as with text.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">eventCounter</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">start</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">end</span>
   <span class="s3">*/</span>
  <span class="s2">public void </span><span class="s1">maybeSetSelection(</span><span class="s2">int </span><span class="s1">eventCounter</span><span class="s2">, int </span><span class="s1">start</span><span class="s2">, int </span><span class="s1">end) {</span>
    <span class="s2">if </span><span class="s1">(!canUpdateWithEventCount(eventCounter)) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(start != UNSET &amp;&amp; end != UNSET) {</span>
      <span class="s0">// clamp selection values for safety</span>
      <span class="s1">start = clampToTextLength(start)</span><span class="s2">;</span>
      <span class="s1">end = clampToTextLength(end)</span><span class="s2">;</span>

      <span class="s1">setSelection(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private int </span><span class="s1">clampToTextLength(</span><span class="s2">int </span><span class="s1">value) {</span>
    <span class="s2">int </span><span class="s1">textLength = getText() == </span><span class="s2">null </span><span class="s1">? </span><span class="s6">0 </span><span class="s1">: getText().length()</span><span class="s2">;</span>

    <span class="s2">return </span><span class="s1">Math.max(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">Math.min(value</span><span class="s2">, </span><span class="s1">textLength))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setSelection(</span><span class="s2">int </span><span class="s1">start</span><span class="s2">, int </span><span class="s1">end) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s7">&quot;setSelection[&quot; </span><span class="s1">+ getId() + </span><span class="s7">&quot;]: &quot; </span><span class="s1">+ start + </span><span class="s7">&quot; &quot; </span><span class="s1">+ end)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">super</span><span class="s1">.setSelection(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onSelectionChanged(</span><span class="s2">int </span><span class="s1">selStart</span><span class="s2">, int </span><span class="s1">selEnd) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.e(TAG</span><span class="s2">, </span><span class="s7">&quot;onSelectionChanged[&quot; </span><span class="s1">+ getId() + </span><span class="s7">&quot;]: &quot; </span><span class="s1">+ selStart + </span><span class="s7">&quot; &quot; </span><span class="s1">+ selEnd)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">super</span><span class="s1">.onSelectionChanged(selStart</span><span class="s2">, </span><span class="s1">selEnd)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mSelectionWatcher != </span><span class="s2">null </span><span class="s1">&amp;&amp; hasFocus()) {</span>
      <span class="s1">mSelectionWatcher.onSelectionChanged(selStart</span><span class="s2">, </span><span class="s1">selEnd)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onFocusChanged(</span><span class="s2">boolean </span><span class="s1">focused</span><span class="s2">, int </span><span class="s1">direction</span><span class="s2">, </span><span class="s1">Rect previouslyFocusedRect) {</span>
    <span class="s2">super</span><span class="s1">.onFocusChanged(focused</span><span class="s2">, </span><span class="s1">direction</span><span class="s2">, </span><span class="s1">previouslyFocusedRect)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(focused &amp;&amp; mSelectionWatcher != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mSelectionWatcher.onSelectionChanged(getSelectionStart()</span><span class="s2">, </span><span class="s1">getSelectionEnd())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSelectionWatcher(SelectionWatcher selectionWatcher) {</span>
    <span class="s1">mSelectionWatcher = selectionWatcher</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setOnKeyPress(</span><span class="s2">boolean </span><span class="s1">onKeyPress) {</span>
    <span class="s1">mOnKeyPress = onKeyPress</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">shouldBlurOnReturn() {</span>
    <span class="s1">String submitBehavior = getSubmitBehavior()</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">shouldBlur</span><span class="s2">;</span>

    <span class="s0">// Default shouldBlur</span>
    <span class="s2">if </span><span class="s1">(submitBehavior == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!isMultiline()) {</span>
        <span class="s1">shouldBlur = </span><span class="s2">true;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">shouldBlur = </span><span class="s2">false;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">shouldBlur = submitBehavior.equals(</span><span class="s7">&quot;blurAndSubmit&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">shouldBlur</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">shouldSubmitOnReturn() {</span>
    <span class="s1">String submitBehavior = getSubmitBehavior()</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">shouldSubmit</span><span class="s2">;</span>

    <span class="s0">// Default shouldSubmit</span>
    <span class="s2">if </span><span class="s1">(submitBehavior == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!isMultiline()) {</span>
        <span class="s1">shouldSubmit = </span><span class="s2">true;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">shouldSubmit = </span><span class="s2">false;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">shouldSubmit = submitBehavior.equals(</span><span class="s7">&quot;submit&quot;</span><span class="s1">) || submitBehavior.equals(</span><span class="s7">&quot;blurAndSubmit&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">shouldSubmit</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">String getSubmitBehavior() {</span>
    <span class="s2">return </span><span class="s1">mSubmitBehavior</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSubmitBehavior(String submitBehavior) {</span>
    <span class="s1">mSubmitBehavior = submitBehavior</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setDisableFullscreenUI(</span><span class="s2">boolean </span><span class="s1">disableFullscreenUI) {</span>
    <span class="s1">mDisableFullscreen = disableFullscreenUI</span><span class="s2">;</span>
    <span class="s1">updateImeOptions()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">getDisableFullscreenUI() {</span>
    <span class="s2">return </span><span class="s1">mDisableFullscreen</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setReturnKeyType(String returnKeyType) {</span>
    <span class="s1">mReturnKeyType = returnKeyType</span><span class="s2">;</span>
    <span class="s1">updateImeOptions()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">String getReturnKeyType() {</span>
    <span class="s2">return </span><span class="s1">mReturnKeyType</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*protected*/ </span><span class="s2">int </span><span class="s1">getStagedInputType() {</span>
    <span class="s2">return </span><span class="s1">mStagedInputType</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">void </span><span class="s1">setStagedInputType(</span><span class="s2">int </span><span class="s1">stagedInputType) {</span>
    <span class="s1">mStagedInputType = stagedInputType</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/*package*/ </span><span class="s2">void </span><span class="s1">commitStagedInputType() {</span>
    <span class="s2">if </span><span class="s1">(getInputType() != mStagedInputType) {</span>
      <span class="s2">int </span><span class="s1">selectionStart = getSelectionStart()</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">selectionEnd = getSelectionEnd()</span><span class="s2">;</span>
      <span class="s1">setInputType(mStagedInputType)</span><span class="s2">;</span>
      <span class="s1">setSelection(selectionStart</span><span class="s2">, </span><span class="s1">selectionEnd)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setInputType(</span><span class="s2">int </span><span class="s1">type) {</span>
    <span class="s1">Typeface tf = </span><span class="s2">super</span><span class="s1">.getTypeface()</span><span class="s2">;</span>
    <span class="s2">super</span><span class="s1">.setInputType(type)</span><span class="s2">;</span>
    <span class="s1">mStagedInputType = type</span><span class="s2">;</span>
    <span class="s0">// Input type password defaults to monospace font, so we need to re-apply the font</span>
    <span class="s2">super</span><span class="s1">.setTypeface(tf)</span><span class="s2">;</span>

    <span class="s3">/**</span>
     <span class="s3">* If set forces multiline on input, because of a restriction on Android source that enables</span>
     <span class="s3">* multiline only for inputs of type Text and Multiline on method {</span><span class="s5">@link</span>
     <span class="s3">* android.widget.TextView#isMultilineInputType(int)}} Source: {</span><span class="s5">@Link </span><span class="s4">&lt;a</span>
     <span class="s3">* href='https://android.googlesource.com/platform/frameworks/base/+/jb-release/core/java/android/widget/TextView.java'&gt;TextView.java</span><span class="s4">&lt;/a&gt;</span><span class="s3">}</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(isMultiline()) {</span>
      <span class="s1">setSingleLine(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// We override the KeyListener so that all keys on the soft input keyboard as well as hardware</span>
    <span class="s0">// keyboards work. Some KeyListeners like DigitsKeyListener will display the keyboard but not</span>
    <span class="s0">// accept all input from it</span>
    <span class="s2">if </span><span class="s1">(mKeyListener == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mKeyListener = </span><span class="s2">new </span><span class="s1">InternalKeyListener()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mKeyListener.setInputType(type)</span><span class="s2">;</span>
    <span class="s1">setKeyListener(mKeyListener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setPlaceholder(@Nullable String placeholder) {</span>
    <span class="s2">if </span><span class="s1">(!Objects.equals(placeholder</span><span class="s2">, </span><span class="s1">mPlaceholder)) {</span>
      <span class="s1">mPlaceholder = placeholder</span><span class="s2">;</span>
      <span class="s1">setHint(placeholder)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setFontFamily(String fontFamily) {</span>
    <span class="s1">mFontFamily = fontFamily</span><span class="s2">;</span>
    <span class="s1">mTypefaceDirty = </span><span class="s2">true;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setFontWeight(String fontWeightString) {</span>
    <span class="s2">int </span><span class="s1">fontWeight = ReactTypefaceUtils.parseFontWeight(fontWeightString)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(fontWeight != mFontWeight) {</span>
      <span class="s1">mFontWeight = fontWeight</span><span class="s2">;</span>
      <span class="s1">mTypefaceDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setFontStyle(String fontStyleString) {</span>
    <span class="s2">int </span><span class="s1">fontStyle = ReactTypefaceUtils.parseFontStyle(fontStyleString)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(fontStyle != mFontStyle) {</span>
      <span class="s1">mFontStyle = fontStyle</span><span class="s2">;</span>
      <span class="s1">mTypefaceDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFontFeatureSettings(String fontFeatureSettings) {</span>
    <span class="s2">if </span><span class="s1">(!Objects.equals(fontFeatureSettings</span><span class="s2">, </span><span class="s1">getFontFeatureSettings())) {</span>
      <span class="s2">super</span><span class="s1">.setFontFeatureSettings(fontFeatureSettings)</span><span class="s2">;</span>
      <span class="s1">mTypefaceDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">maybeUpdateTypeface() {</span>
    <span class="s2">if </span><span class="s1">(!mTypefaceDirty) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mTypefaceDirty = </span><span class="s2">false;</span>

    <span class="s1">Typeface newTypeface =</span>
        <span class="s1">ReactTypefaceUtils.applyStyles(</span>
            <span class="s1">getTypeface()</span><span class="s2">, </span><span class="s1">mFontStyle</span><span class="s2">, </span><span class="s1">mFontWeight</span><span class="s2">, </span><span class="s1">mFontFamily</span><span class="s2">, </span><span class="s1">getContext().getAssets())</span><span class="s2">;</span>
    <span class="s1">setTypeface(newTypeface)</span><span class="s2">;</span>

    <span class="s0">// Match behavior of CustomStyleSpan and enable SUBPIXEL_TEXT_FLAG when setting anything</span>
    <span class="s0">// nonstandard</span>
    <span class="s2">if </span><span class="s1">(mFontStyle != UNSET</span>
        <span class="s1">|| mFontWeight != UNSET</span>
        <span class="s1">|| mFontFamily != </span><span class="s2">null</span>
        <span class="s1">|| getFontFeatureSettings() != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">setPaintFlags(getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">setPaintFlags(getPaintFlags() &amp; (~Paint.SUBPIXEL_TEXT_FLAG))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// VisibleForTesting from {@link TextInputEventsTestCase}.</span>
  <span class="s2">public void </span><span class="s1">requestFocusFromJS() {</span>
    <span class="s1">requestFocusInternal()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">clearFocusFromJS() {</span>
    <span class="s1">clearFocus()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// VisibleForTesting from {@link TextInputEventsTestCase}.</span>
  <span class="s2">public int </span><span class="s1">incrementAndGetEventCounter() {</span>
    <span class="s2">return </span><span class="s1">++mNativeEventCount</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">maybeSetTextFromJS(ReactTextUpdate reactTextUpdate) {</span>
    <span class="s1">mIsSettingTextFromJS = </span><span class="s2">true;</span>
    <span class="s1">maybeSetText(reactTextUpdate)</span><span class="s2">;</span>
    <span class="s1">mIsSettingTextFromJS = </span><span class="s2">false;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">maybeSetTextFromState(ReactTextUpdate reactTextUpdate) {</span>
    <span class="s1">mIsSettingTextFromState = </span><span class="s2">true;</span>
    <span class="s1">maybeSetText(reactTextUpdate)</span><span class="s2">;</span>
    <span class="s1">mIsSettingTextFromState = </span><span class="s2">false;</span>
  <span class="s1">}</span>

  <span class="s2">public boolean </span><span class="s1">canUpdateWithEventCount(</span><span class="s2">int </span><span class="s1">eventCounter) {</span>
    <span class="s2">return </span><span class="s1">eventCounter &gt;= mNativeEventCount</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// VisibleForTesting from {@link TextInputEventsTestCase}.</span>
  <span class="s2">public void </span><span class="s1">maybeSetText(ReactTextUpdate reactTextUpdate) {</span>
    <span class="s2">if </span><span class="s1">(isSecureText() &amp;&amp; TextUtils.equals(getText()</span><span class="s2">, </span><span class="s1">reactTextUpdate.getText())) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s0">// Only set the text if it is up to date.</span>
    <span class="s2">if </span><span class="s1">(!canUpdateWithEventCount(reactTextUpdate.getJsEventCounter())) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.e(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s7">&quot;maybeSetText[&quot;</span>
              <span class="s1">+ getId()</span>
              <span class="s1">+ </span><span class="s7">&quot;]: current text: &quot;</span>
              <span class="s1">+ getText()</span>
              <span class="s1">+ </span><span class="s7">&quot; update: &quot;</span>
              <span class="s1">+ reactTextUpdate.getText())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// The current text gets replaced with the text received from JS. However, the spans on the</span>
    <span class="s0">// current text need to be adapted to the new text. Since TextView#setText() will remove or</span>
    <span class="s0">// reset some of these spans even if they are set directly, SpannableStringBuilder#replace() is</span>
    <span class="s0">// used instead (this is also used by the keyboard implementation underneath the covers).</span>
    <span class="s1">SpannableStringBuilder spannableStringBuilder =</span>
        <span class="s2">new </span><span class="s1">SpannableStringBuilder(reactTextUpdate.getText())</span><span class="s2">;</span>

    <span class="s1">manageSpans(spannableStringBuilder)</span><span class="s2">;</span>
    <span class="s1">stripStyleEquivalentSpans(spannableStringBuilder)</span><span class="s2">;</span>

    <span class="s1">mContainsImages = reactTextUpdate.containsImages()</span><span class="s2">;</span>

    <span class="s0">// When we update text, we trigger onChangeText code that will</span>
    <span class="s0">// try to update state if the wrapper is available. Temporarily disable</span>
    <span class="s0">// to prevent an (asynchronous) infinite loop.</span>
    <span class="s1">mDisableTextDiffing = </span><span class="s2">true;</span>

    <span class="s0">// On some devices, when the text is cleared, buggy keyboards will not clear the composing</span>
    <span class="s0">// text so, we have to set text to null, which will clear the currently composing text.</span>
    <span class="s2">if </span><span class="s1">(reactTextUpdate.getText().length() == </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">setText(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// When we update text, we trigger onChangeText code that will</span>
      <span class="s0">// try to update state if the wrapper is available. Temporarily disable</span>
      <span class="s0">// to prevent an infinite loop.</span>
      <span class="s1">getText().replace(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">length()</span><span class="s2">, </span><span class="s1">spannableStringBuilder)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mDisableTextDiffing = </span><span class="s2">false;</span>

    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {</span>
      <span class="s2">if </span><span class="s1">(getBreakStrategy() != reactTextUpdate.getTextBreakStrategy()) {</span>
        <span class="s1">setBreakStrategy(reactTextUpdate.getTextBreakStrategy())</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Update cached spans (in Fabric only).</span>
    <span class="s1">updateCachedSpannable()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Remove and/or add {</span><span class="s5">@link </span><span class="s3">Spanned.SPAN_EXCLUSIVE_EXCLUSIVE} spans, since they should only exist</span>
   <span class="s3">* as long as the text they cover is the same. All other spans will remain the same, since they</span>
   <span class="s3">* will adapt to the new text, hence why {</span><span class="s5">@link </span><span class="s3">SpannableStringBuilder#replace} never removes</span>
   <span class="s3">* them.</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">manageSpans(SpannableStringBuilder spannableStringBuilder) {</span>
    <span class="s1">Object[] spans = getText().getSpans(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">length()</span><span class="s2">, </span><span class="s1">Object.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">spanIdx = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">spanIdx &lt; spans.length</span><span class="s2">; </span><span class="s1">spanIdx++) {</span>
      <span class="s1">Object span = spans[spanIdx]</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">spanFlags = getText().getSpanFlags(span)</span><span class="s2">;</span>
      <span class="s2">boolean </span><span class="s1">isExclusiveExclusive =</span>
          <span class="s1">(spanFlags &amp; Spanned.SPAN_EXCLUSIVE_EXCLUSIVE) == Spanned.SPAN_EXCLUSIVE_EXCLUSIVE</span><span class="s2">;</span>

      <span class="s0">// Remove all styling spans we might have previously set</span>
      <span class="s2">if </span><span class="s1">(span </span><span class="s2">instanceof </span><span class="s1">ReactSpan) {</span>
        <span class="s1">getText().removeSpan(span)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">// We only add spans back for EXCLUSIVE_EXCLUSIVE spans</span>
      <span class="s2">if </span><span class="s1">(!isExclusiveExclusive) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">final int </span><span class="s1">spanStart = getText().getSpanStart(span)</span><span class="s2">;</span>
      <span class="s2">final int </span><span class="s1">spanEnd = getText().getSpanEnd(span)</span><span class="s2">;</span>

      <span class="s0">// Make sure the span is removed from existing text, otherwise the spans we set will be</span>
      <span class="s0">// ignored or it will cover text that has changed.</span>
      <span class="s1">getText().removeSpan(span)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(sameTextForSpan(getText()</span><span class="s2">, </span><span class="s1">spannableStringBuilder</span><span class="s2">, </span><span class="s1">spanStart</span><span class="s2">, </span><span class="s1">spanEnd)) {</span>
        <span class="s1">spannableStringBuilder.setSpan(span</span><span class="s2">, </span><span class="s1">spanStart</span><span class="s2">, </span><span class="s1">spanEnd</span><span class="s2">, </span><span class="s1">spanFlags)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// TODO: Replace with Predicate&lt;T&gt; and lambdas once Java 8 builds in OSS</span>
  <span class="s2">interface </span><span class="s1">SpanPredicate&lt;T&gt; {</span>
    <span class="s2">boolean </span><span class="s1">test(T span)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Remove spans from the SpannableStringBuilder which can be represented by TextAppearance</span>
   <span class="s3">* attributes on the underlying EditText. This works around instability on Samsung devices with</span>
   <span class="s3">* the presence of spans https://github.com/facebook/react-native/issues/35936 (S318090)</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">stripStyleEquivalentSpans(SpannableStringBuilder sb) {</span>
    <span class="s1">stripSpansOfKind(</span>
        <span class="s1">sb</span><span class="s2">,</span>
        <span class="s1">ReactAbsoluteSizeSpan.</span><span class="s2">class,</span>
        <span class="s2">new </span><span class="s1">SpanPredicate&lt;ReactAbsoluteSizeSpan&gt;() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public boolean </span><span class="s1">test(ReactAbsoluteSizeSpan span) {</span>
            <span class="s2">return </span><span class="s1">span.getSize() == mTextAttributes.getEffectiveFontSize()</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>

    <span class="s1">stripSpansOfKind(</span>
        <span class="s1">sb</span><span class="s2">,</span>
        <span class="s1">ReactBackgroundColorSpan.</span><span class="s2">class,</span>
        <span class="s2">new </span><span class="s1">SpanPredicate&lt;ReactBackgroundColorSpan&gt;() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public boolean </span><span class="s1">test(ReactBackgroundColorSpan span) {</span>
            <span class="s2">return </span><span class="s1">span.getBackgroundColor() == mReactBackgroundManager.getBackgroundColor()</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>

    <span class="s1">stripSpansOfKind(</span>
        <span class="s1">sb</span><span class="s2">,</span>
        <span class="s1">ReactForegroundColorSpan.</span><span class="s2">class,</span>
        <span class="s2">new </span><span class="s1">SpanPredicate&lt;ReactForegroundColorSpan&gt;() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public boolean </span><span class="s1">test(ReactForegroundColorSpan span) {</span>
            <span class="s2">return </span><span class="s1">span.getForegroundColor() == getCurrentTextColor()</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>

    <span class="s1">stripSpansOfKind(</span>
        <span class="s1">sb</span><span class="s2">,</span>
        <span class="s1">ReactStrikethroughSpan.</span><span class="s2">class,</span>
        <span class="s2">new </span><span class="s1">SpanPredicate&lt;ReactStrikethroughSpan&gt;() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public boolean </span><span class="s1">test(ReactStrikethroughSpan span) {</span>
            <span class="s2">return </span><span class="s1">(getPaintFlags() &amp; Paint.STRIKE_THRU_TEXT_FLAG) != </span><span class="s6">0</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>

    <span class="s1">stripSpansOfKind(</span>
        <span class="s1">sb</span><span class="s2">,</span>
        <span class="s1">ReactUnderlineSpan.</span><span class="s2">class,</span>
        <span class="s2">new </span><span class="s1">SpanPredicate&lt;ReactUnderlineSpan&gt;() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public boolean </span><span class="s1">test(ReactUnderlineSpan span) {</span>
            <span class="s2">return </span><span class="s1">(getPaintFlags() &amp; Paint.UNDERLINE_TEXT_FLAG) != </span><span class="s6">0</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {</span>
      <span class="s1">stripSpansOfKind(</span>
          <span class="s1">sb</span><span class="s2">,</span>
          <span class="s1">CustomLetterSpacingSpan.</span><span class="s2">class,</span>
          <span class="s2">new </span><span class="s1">SpanPredicate&lt;CustomLetterSpacingSpan&gt;() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public boolean </span><span class="s1">test(CustomLetterSpacingSpan span) {</span>
              <span class="s2">return </span><span class="s1">span.getSpacing() == mTextAttributes.getEffectiveLetterSpacing()</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">stripSpansOfKind(</span>
        <span class="s1">sb</span><span class="s2">,</span>
        <span class="s1">CustomStyleSpan.</span><span class="s2">class,</span>
        <span class="s2">new </span><span class="s1">SpanPredicate&lt;CustomStyleSpan&gt;() {</span>
          <span class="s1">@Override</span>
          <span class="s2">public boolean </span><span class="s1">test(CustomStyleSpan span) {</span>
            <span class="s2">return </span><span class="s1">span.getStyle() == mFontStyle</span>
                <span class="s1">&amp;&amp; Objects.equals(span.getFontFamily()</span><span class="s2">, </span><span class="s1">mFontFamily)</span>
                <span class="s1">&amp;&amp; span.getWeight() == mFontWeight</span>
                <span class="s1">&amp;&amp; Objects.equals(span.getFontFeatureSettings()</span><span class="s2">, </span><span class="s1">getFontFeatureSettings())</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">&lt;T&gt; </span><span class="s2">void </span><span class="s1">stripSpansOfKind(</span>
      <span class="s1">SpannableStringBuilder sb</span><span class="s2">, </span><span class="s1">Class&lt;T&gt; clazz</span><span class="s2">, </span><span class="s1">SpanPredicate&lt;T&gt; shouldStrip) {</span>
    <span class="s1">T[] spans = sb.getSpans(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">sb.length()</span><span class="s2">, </span><span class="s1">clazz)</span><span class="s2">;</span>

    <span class="s2">for </span><span class="s1">(T span : spans) {</span>
      <span class="s2">if </span><span class="s1">(shouldStrip.test(span)) {</span>
        <span class="s1">sb.removeSpan(span)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Copy styles represented as attributes to the underlying span, for later measurement or other</span>
   <span class="s3">* usage outside the ReactEditText.</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">addSpansFromStyleAttributes(SpannableStringBuilder workingText) {</span>
    <span class="s2">int </span><span class="s1">spanFlags = Spannable.SPAN_INCLUSIVE_INCLUSIVE</span><span class="s2">;</span>

    <span class="s0">// Set all bits for SPAN_PRIORITY so that this span has the highest possible priority</span>
    <span class="s0">// (least precedence). This ensures the span is behind any overlapping spans.</span>
    <span class="s1">spanFlags |= Spannable.SPAN_PRIORITY</span><span class="s2">;</span>

    <span class="s1">workingText.setSpan(</span>
        <span class="s2">new </span><span class="s1">ReactAbsoluteSizeSpan(mTextAttributes.getEffectiveFontSize())</span><span class="s2">,</span>
        <span class="s6">0</span><span class="s2">,</span>
        <span class="s1">workingText.length()</span><span class="s2">,</span>
        <span class="s1">spanFlags)</span><span class="s2">;</span>

    <span class="s1">workingText.setSpan(</span>
        <span class="s2">new </span><span class="s1">ReactForegroundColorSpan(getCurrentTextColor())</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">workingText.length()</span><span class="s2">, </span><span class="s1">spanFlags)</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">backgroundColor = mReactBackgroundManager.getBackgroundColor()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(backgroundColor != Color.TRANSPARENT) {</span>
      <span class="s1">workingText.setSpan(</span>
          <span class="s2">new </span><span class="s1">ReactBackgroundColorSpan(backgroundColor)</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">workingText.length()</span><span class="s2">, </span><span class="s1">spanFlags)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">((getPaintFlags() &amp; Paint.STRIKE_THRU_TEXT_FLAG) != </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">workingText.setSpan(</span><span class="s2">new </span><span class="s1">ReactStrikethroughSpan()</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">workingText.length()</span><span class="s2">, </span><span class="s1">spanFlags)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">((getPaintFlags() &amp; Paint.UNDERLINE_TEXT_FLAG) != </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">workingText.setSpan(</span><span class="s2">new </span><span class="s1">ReactUnderlineSpan()</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">workingText.length()</span><span class="s2">, </span><span class="s1">spanFlags)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {</span>
      <span class="s2">float </span><span class="s1">effectiveLetterSpacing = mTextAttributes.getEffectiveLetterSpacing()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!Float.isNaN(effectiveLetterSpacing)) {</span>
        <span class="s1">workingText.setSpan(</span>
            <span class="s2">new </span><span class="s1">CustomLetterSpacingSpan(effectiveLetterSpacing)</span><span class="s2">,</span>
            <span class="s6">0</span><span class="s2">,</span>
            <span class="s1">workingText.length()</span><span class="s2">,</span>
            <span class="s1">spanFlags)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mFontStyle != UNSET</span>
        <span class="s1">|| mFontWeight != UNSET</span>
        <span class="s1">|| mFontFamily != </span><span class="s2">null</span>
        <span class="s1">|| getFontFeatureSettings() != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">workingText.setSpan(</span>
          <span class="s2">new </span><span class="s1">CustomStyleSpan(</span>
              <span class="s1">mFontStyle</span><span class="s2">,</span>
              <span class="s1">mFontWeight</span><span class="s2">,</span>
              <span class="s1">getFontFeatureSettings()</span><span class="s2">,</span>
              <span class="s1">mFontFamily</span><span class="s2">,</span>
              <span class="s1">getContext().getAssets())</span><span class="s2">,</span>
          <span class="s6">0</span><span class="s2">,</span>
          <span class="s1">workingText.length()</span><span class="s2">,</span>
          <span class="s1">spanFlags)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">float </span><span class="s1">lineHeight = mTextAttributes.getEffectiveLineHeight()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!Float.isNaN(lineHeight)) {</span>
      <span class="s1">workingText.setSpan(</span><span class="s2">new </span><span class="s1">CustomLineHeightSpan(lineHeight)</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">workingText.length()</span><span class="s2">, </span><span class="s1">spanFlags)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private static boolean </span><span class="s1">sameTextForSpan(</span>
      <span class="s2">final </span><span class="s1">Editable oldText</span><span class="s2">,</span>
      <span class="s2">final </span><span class="s1">SpannableStringBuilder newText</span><span class="s2">,</span>
      <span class="s2">final int </span><span class="s1">start</span><span class="s2">,</span>
      <span class="s2">final int </span><span class="s1">end) {</span>
    <span class="s2">if </span><span class="s1">(start &gt; newText.length() || end &gt; newText.length()) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">charIdx = start</span><span class="s2">; </span><span class="s1">charIdx &lt; end</span><span class="s2">; </span><span class="s1">charIdx++) {</span>
      <span class="s2">if </span><span class="s1">(oldText.charAt(charIdx) != newText.charAt(charIdx)) {</span>
        <span class="s2">return false;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>

  <span class="s2">protected boolean </span><span class="s1">showSoftKeyboard() {</span>
    <span class="s2">return </span><span class="s1">mInputMethodManager.showSoftInput(</span><span class="s2">this, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">hideSoftKeyboard() {</span>
    <span class="s1">mInputMethodManager.hideSoftInputFromWindow(getWindowToken()</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private </span><span class="s1">TextWatcherDelegator getTextWatcherDelegator() {</span>
    <span class="s2">if </span><span class="s1">(mTextWatcherDelegator == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mTextWatcherDelegator = </span><span class="s2">new </span><span class="s1">TextWatcherDelegator()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mTextWatcherDelegator</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">boolean </span><span class="s1">isMultiline() {</span>
    <span class="s2">return </span><span class="s1">(getInputType() &amp; InputType.TYPE_TEXT_FLAG_MULTI_LINE) != </span><span class="s6">0</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">isSecureText() {</span>
    <span class="s2">return </span><span class="s1">(getInputType()</span>
            <span class="s1">&amp; (InputType.TYPE_NUMBER_VARIATION_PASSWORD | InputType.TYPE_TEXT_VARIATION_PASSWORD))</span>
        <span class="s1">!= </span><span class="s6">0</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">onContentSizeChange() {</span>
    <span class="s2">if </span><span class="s1">(mContentSizeWatcher != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mContentSizeWatcher.onLayout()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">setIntrinsicContentSize()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// TODO T58784068: delete this method</span>
  <span class="s2">private void </span><span class="s1">setIntrinsicContentSize() {</span>
    <span class="s0">// This serves as a check for whether we're running under Paper or Fabric.</span>
    <span class="s0">// By the time this is called, in Fabric we will have a state</span>
    <span class="s0">// wrapper 100% of the time.</span>
    <span class="s0">// Since the LocalData object is constructed by getting values from the underlying EditText</span>
    <span class="s0">// view, we don't need to construct one or apply it at all - it provides no use in Fabric.</span>
    <span class="s1">ReactContext reactContext = getReactContext(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mFabricViewStateManager != </span><span class="s2">null</span>
        <span class="s1">&amp;&amp; !mFabricViewStateManager.hasStateWrapper()</span>
        <span class="s1">&amp;&amp; !reactContext.isBridgeless()) {</span>

      <span class="s2">final </span><span class="s1">ReactTextInputLocalData localData = </span><span class="s2">new </span><span class="s1">ReactTextInputLocalData(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">UIManagerModule uiManager = reactContext.getNativeModule(UIManagerModule.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(uiManager != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">uiManager.setViewLocalData(getId()</span><span class="s2">, </span><span class="s1">localData)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">int </span><span class="s1">getGravityHorizontal() {</span>
    <span class="s2">return </span><span class="s1">getGravity()</span>
        <span class="s1">&amp; (Gravity.HORIZONTAL_GRAVITY_MASK | Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">setGravityHorizontal(</span><span class="s2">int </span><span class="s1">gravityHorizontal) {</span>
    <span class="s2">if </span><span class="s1">(gravityHorizontal == </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">gravityHorizontal = mDefaultGravityHorizontal</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setGravity(</span>
        <span class="s1">(getGravity()</span>
                <span class="s1">&amp; ~Gravity.HORIZONTAL_GRAVITY_MASK</span>
                <span class="s1">&amp; ~Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK)</span>
            <span class="s1">| gravityHorizontal)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* package */ </span><span class="s2">void </span><span class="s1">setGravityVertical(</span><span class="s2">int </span><span class="s1">gravityVertical) {</span>
    <span class="s2">if </span><span class="s1">(gravityVertical == </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s1">gravityVertical = mDefaultGravityVertical</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setGravity((getGravity() &amp; ~Gravity.VERTICAL_GRAVITY_MASK) | gravityVertical)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updateImeOptions() {</span>
    <span class="s0">// Default to IME_ACTION_DONE</span>
    <span class="s2">int </span><span class="s1">returnKeyFlag = EditorInfo.IME_ACTION_DONE</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mReturnKeyType != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">switch </span><span class="s1">(mReturnKeyType) {</span>
        <span class="s2">case </span><span class="s7">&quot;go&quot;</span><span class="s1">:</span>
          <span class="s1">returnKeyFlag = EditorInfo.IME_ACTION_GO</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s7">&quot;next&quot;</span><span class="s1">:</span>
          <span class="s1">returnKeyFlag = EditorInfo.IME_ACTION_NEXT</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s7">&quot;none&quot;</span><span class="s1">:</span>
          <span class="s1">returnKeyFlag = EditorInfo.IME_ACTION_NONE</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s7">&quot;previous&quot;</span><span class="s1">:</span>
          <span class="s1">returnKeyFlag = EditorInfo.IME_ACTION_PREVIOUS</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s7">&quot;search&quot;</span><span class="s1">:</span>
          <span class="s1">returnKeyFlag = EditorInfo.IME_ACTION_SEARCH</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s7">&quot;send&quot;</span><span class="s1">:</span>
          <span class="s1">returnKeyFlag = EditorInfo.IME_ACTION_SEND</span><span class="s2">;</span>
          <span class="s2">break;</span>
        <span class="s2">case </span><span class="s7">&quot;done&quot;</span><span class="s1">:</span>
          <span class="s1">returnKeyFlag = EditorInfo.IME_ACTION_DONE</span><span class="s2">;</span>
          <span class="s2">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mDisableFullscreen) {</span>
      <span class="s1">setImeOptions(returnKeyFlag | EditorInfo.IME_FLAG_NO_FULLSCREEN)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">setImeOptions(returnKeyFlag)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected boolean </span><span class="s1">verifyDrawable(Drawable drawable) {</span>
    <span class="s2">if </span><span class="s1">(mContainsImages) {</span>
      <span class="s1">Spanned text = getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s2">if </span><span class="s1">(span.getDrawable() == drawable) {</span>
          <span class="s2">return true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return super</span><span class="s1">.verifyDrawable(drawable)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">invalidateDrawable(Drawable drawable) {</span>
    <span class="s2">if </span><span class="s1">(mContainsImages) {</span>
      <span class="s1">Spanned text = getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s2">if </span><span class="s1">(span.getDrawable() == drawable) {</span>
          <span class="s1">invalidate()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">super</span><span class="s1">.invalidateDrawable(drawable)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onDetachedFromWindow() {</span>
    <span class="s2">super</span><span class="s1">.onDetachedFromWindow()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mContainsImages) {</span>
      <span class="s1">Spanned text = getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s1">span.onDetachedFromWindow()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onStartTemporaryDetach() {</span>
    <span class="s2">super</span><span class="s1">.onStartTemporaryDetach()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mContainsImages) {</span>
      <span class="s1">Spanned text = getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s1">span.onStartTemporaryDetach()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onAttachedToWindow() {</span>
    <span class="s2">super</span><span class="s1">.onAttachedToWindow()</span><span class="s2">;</span>

    <span class="s0">// Used to ensure that text is selectable inside of removeClippedSubviews</span>
    <span class="s0">// See https://github.com/facebook/react-native/issues/6805 for original</span>
    <span class="s0">// fix that was ported to here.</span>

    <span class="s2">super</span><span class="s1">.setTextIsSelectable(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mContainsImages) {</span>
      <span class="s1">Spanned text = getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s1">span.onAttachedToWindow()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mAutoFocus &amp;&amp; !mDidAttachToWindow) {</span>
      <span class="s1">requestFocusInternal()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mDidAttachToWindow = </span><span class="s2">true;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onFinishTemporaryDetach() {</span>
    <span class="s2">super</span><span class="s1">.onFinishTemporaryDetach()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mContainsImages) {</span>
      <span class="s1">Spanned text = getText()</span><span class="s2">;</span>
      <span class="s1">TextInlineImageSpan[] spans = text.getSpans(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">text.length()</span><span class="s2">, </span><span class="s1">TextInlineImageSpan.</span><span class="s2">class</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(TextInlineImageSpan span : spans) {</span>
        <span class="s1">span.onFinishTemporaryDetach()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setBackgroundColor(</span><span class="s2">int </span><span class="s1">color) {</span>
    <span class="s1">mReactBackgroundManager.setBackgroundColor(color)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderWidth(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">width) {</span>
    <span class="s1">mReactBackgroundManager.setBorderWidth(position</span><span class="s2">, </span><span class="s1">width)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderColor(</span><span class="s2">int </span><span class="s1">position</span><span class="s2">, float </span><span class="s1">color</span><span class="s2">, float </span><span class="s1">alpha) {</span>
    <span class="s1">mReactBackgroundManager.setBorderColor(position</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">alpha)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public int </span><span class="s1">getBorderColor(</span><span class="s2">int </span><span class="s1">position) {</span>
    <span class="s2">return </span><span class="s1">mReactBackgroundManager.getBorderColor(position)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius) {</span>
    <span class="s1">mReactBackgroundManager.setBorderRadius(borderRadius)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius</span><span class="s2">, int </span><span class="s1">position) {</span>
    <span class="s1">mReactBackgroundManager.setBorderRadius(borderRadius</span><span class="s2">, </span><span class="s1">position)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderStyle(@Nullable String style) {</span>
    <span class="s1">mReactBackgroundManager.setBorderStyle(style)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setLetterSpacingPt(</span><span class="s2">float </span><span class="s1">letterSpacingPt) {</span>
    <span class="s1">mTextAttributes.setLetterSpacing(letterSpacingPt)</span><span class="s2">;</span>
    <span class="s1">applyTextAttributes()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setAllowFontScaling(</span><span class="s2">boolean </span><span class="s1">allowFontScaling) {</span>
    <span class="s2">if </span><span class="s1">(mTextAttributes.getAllowFontScaling() != allowFontScaling) {</span>
      <span class="s1">mTextAttributes.setAllowFontScaling(allowFontScaling)</span><span class="s2">;</span>
      <span class="s1">applyTextAttributes()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setFontSize(</span><span class="s2">float </span><span class="s1">fontSize) {</span>
    <span class="s1">mTextAttributes.setFontSize(fontSize)</span><span class="s2">;</span>
    <span class="s1">applyTextAttributes()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setMaxFontSizeMultiplier(</span><span class="s2">float </span><span class="s1">maxFontSizeMultiplier) {</span>
    <span class="s2">if </span><span class="s1">(maxFontSizeMultiplier != mTextAttributes.getMaxFontSizeMultiplier()) {</span>
      <span class="s1">mTextAttributes.setMaxFontSizeMultiplier(maxFontSizeMultiplier)</span><span class="s2">;</span>
      <span class="s1">applyTextAttributes()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setAutoFocus(</span><span class="s2">boolean </span><span class="s1">autoFocus) {</span>
    <span class="s1">mAutoFocus = autoFocus</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">protected void </span><span class="s1">applyTextAttributes() {</span>
    <span class="s0">// In general, the `getEffective*` functions return `Float.NaN` if the</span>
    <span class="s0">// property hasn't been set.</span>

    <span class="s0">// `getEffectiveFontSize` always returns a value so don't need to check for anything like</span>
    <span class="s0">// `Float.NaN`.</span>
    <span class="s1">setTextSize(TypedValue.COMPLEX_UNIT_PX</span><span class="s2">, </span><span class="s1">mTextAttributes.getEffectiveFontSize())</span><span class="s2">;</span>

    <span class="s2">float </span><span class="s1">effectiveLetterSpacing = mTextAttributes.getEffectiveLetterSpacing()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!Float.isNaN(effectiveLetterSpacing)) {</span>
      <span class="s2">if </span><span class="s1">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {</span>
        <span class="s1">setLetterSpacing(effectiveLetterSpacing)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">FabricViewStateManager getFabricViewStateManager() {</span>
    <span class="s2">return </span><span class="s1">mFabricViewStateManager</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Update the cached Spannable used in TextLayoutManager to measure the text in Fabric. This is</span>
   <span class="s3">* mostly copied from ReactTextInputShadowNode.java (the non-Fabric version) and</span>
   <span class="s3">* TextLayoutManager.java with some very minor modifications. There's some duplication between</span>
   <span class="s3">* here and TextLayoutManager, so there might be an opportunity for refactor.</span>
   <span class="s3">*/</span>
  <span class="s2">private void </span><span class="s1">updateCachedSpannable() {</span>
    <span class="s0">// Noops in non-Fabric</span>
    <span class="s2">if </span><span class="s1">(mFabricViewStateManager == </span><span class="s2">null </span><span class="s1">|| !mFabricViewStateManager.hasStateWrapper()) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s0">// If this view doesn't have an ID yet, we don't have a cache key, so bail here</span>
    <span class="s2">if </span><span class="s1">(getId() == -</span><span class="s6">1</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">Editable currentText = getText()</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">haveText = currentText != </span><span class="s2">null </span><span class="s1">&amp;&amp; currentText.length() &gt; </span><span class="s6">0</span><span class="s2">;</span>

    <span class="s1">SpannableStringBuilder sb = </span><span class="s2">new </span><span class="s1">SpannableStringBuilder()</span><span class="s2">;</span>

    <span class="s0">// A note of caution: appending currentText to sb appends all the spans of currentText - not</span>
    <span class="s0">// copies of the Spans, but the actual span objects. Any modifications to sb after that point</span>
    <span class="s0">// can modify the spans of sb/currentText, impact the text or spans visible on screen, and</span>
    <span class="s0">// also call the TextChangeWatcher methods.</span>
    <span class="s2">if </span><span class="s1">(haveText) {</span>
      <span class="s0">// This is here as a workaround for T76236115, which looks like this:</span>
      <span class="s0">// Hopefully we can delete all this stuff if we can get rid of the soft errors.</span>
      <span class="s0">// - android.text.SpannableStringBuilder.charAt (SpannableStringBuilder.java:123)</span>
      <span class="s0">// - android.text.CharSequenceCharacterIterator.current</span>
      <span class="s0">// (CharSequenceCharacterIterator.java:58)</span>
      <span class="s0">// - android.text.CharSequenceCharacterIterator.setIndex</span>
      <span class="s0">// (CharSequenceCharacterIterator.java:83)</span>
      <span class="s0">// - android.icu.text.RuleBasedBreakIterator.CISetIndex32 (RuleBasedBreakIterator.java:1126)</span>
      <span class="s0">// - android.icu.text.RuleBasedBreakIterator.isBoundary (RuleBasedBreakIterator.java:503)</span>
      <span class="s0">// - android.text.method.WordIterator.isBoundary (WordIterator.java:95)</span>
      <span class="s0">// - android.widget.Editor$SelectionHandleView.positionAtCursorOffset (Editor.java:6666)</span>
      <span class="s0">// - android.widget.Editor$HandleView.invalidate (Editor.java:5241)</span>
      <span class="s0">// - android.widget.Editor$SelectionModifierCursorController.invalidateHandles</span>
      <span class="s0">// (Editor.java:7442)</span>
      <span class="s0">// - android.widget.Editor.invalidateHandlesAndActionMode (Editor.java:2112)</span>
      <span class="s0">// - android.widget.TextView.spanChange (TextView.java:11189)</span>
      <span class="s0">// - android.widget.TextView$ChangeWatcher.onSpanAdded (TextView.java:14189)</span>
      <span class="s0">// - android.text.SpannableStringBuilder.sendSpanAdded (SpannableStringBuilder.java:1283)</span>
      <span class="s0">// - android.text.SpannableStringBuilder.sendToSpanWatchers (SpannableStringBuilder.java:663)</span>
      <span class="s0">// - android.text.SpannableStringBuilder.replace (SpannableStringBuilder.java:579)</span>
      <span class="s0">// - android.text.SpannableStringBuilder.append (SpannableStringBuilder.java:269)</span>
      <span class="s0">// - ReactEditText.updateCachedSpannable (ReactEditText.java:995)</span>
      <span class="s0">// - ReactEditText$TextWatcherDelegator.onTextChanged (ReactEditText.java:1044)</span>
      <span class="s0">// - android.widget.TextView.sendOnTextChanged (TextView.java:10972)</span>
      <span class="s0">// ...</span>
      <span class="s0">// - android.text.method.BaseKeyListener.onKeyDown (BaseKeyListener.java:479)</span>
      <span class="s0">// - android.text.method.QwertyKeyListener.onKeyDown (QwertyKeyListener.java:362)</span>
      <span class="s0">// - ReactEditText$InternalKeyListener.onKeyDown (ReactEditText.java:1094)</span>
      <span class="s0">// ...</span>
      <span class="s0">// - android.app.Activity.dispatchKeyEvent (Activity.java:3447)</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">sb.append(currentText.subSequence(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">currentText.length()))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(IndexOutOfBoundsException e) {</span>
        <span class="s1">ReactSoftExceptionLogger.logSoftException(TAG</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// If we don't have text, make sure we have *something* to measure.</span>
    <span class="s0">// Hint has the same dimensions - the only thing that's different is background or foreground</span>
    <span class="s0">// color</span>
    <span class="s2">if </span><span class="s1">(!haveText) {</span>
      <span class="s2">if </span><span class="s1">(getHint() != </span><span class="s2">null </span><span class="s1">&amp;&amp; getHint().length() &gt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s1">sb.append(getHint())</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Measure something so we have correct height, even if there's no string.</span>
        <span class="s1">sb.append(</span><span class="s7">&quot;I&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">addSpansFromStyleAttributes(sb)</span><span class="s2">;</span>
    <span class="s1">TextLayoutManager.setCachedSpannabledForTag(getId()</span><span class="s2">, </span><span class="s1">sb)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">void </span><span class="s1">setEventDispatcher(@Nullable EventDispatcher eventDispatcher) {</span>
    <span class="s1">mEventDispatcher = eventDispatcher</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This class will redirect *TextChanged calls to the listeners only in the case where the text is</span>
   <span class="s3">* changed by the user, and not explicitly set by JS.</span>
   <span class="s3">*/</span>
  <span class="s2">private class </span><span class="s1">TextWatcherDelegator </span><span class="s2">implements </span><span class="s1">TextWatcher {</span>
    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">beforeTextChanged(CharSequence s</span><span class="s2">, int </span><span class="s1">start</span><span class="s2">, int </span><span class="s1">count</span><span class="s2">, int </span><span class="s1">after) {</span>
      <span class="s2">if </span><span class="s1">(!mIsSettingTextFromJS &amp;&amp; mListeners != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(TextWatcher listener : mListeners) {</span>
          <span class="s1">listener.beforeTextChanged(s</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">after)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">onTextChanged(CharSequence s</span><span class="s2">, int </span><span class="s1">start</span><span class="s2">, int </span><span class="s1">before</span><span class="s2">, int </span><span class="s1">count) {</span>
      <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
        <span class="s1">FLog.e(</span>
            <span class="s1">TAG</span><span class="s2">, </span><span class="s7">&quot;onTextChanged[&quot; </span><span class="s1">+ getId() + </span><span class="s7">&quot;]: &quot; </span><span class="s1">+ s + </span><span class="s7">&quot; &quot; </span><span class="s1">+ start + </span><span class="s7">&quot; &quot; </span><span class="s1">+ before + </span><span class="s7">&quot; &quot; </span><span class="s1">+ count)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!mIsSettingTextFromJS &amp;&amp; mListeners != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(TextWatcher listener : mListeners) {</span>
          <span class="s1">listener.onTextChanged(s</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">before</span><span class="s2">, </span><span class="s1">count)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">updateCachedSpannable()</span><span class="s2">;</span>

      <span class="s1">onContentSizeChange()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">afterTextChanged(Editable s) {</span>
      <span class="s2">if </span><span class="s1">(!mIsSettingTextFromJS &amp;&amp; mListeners != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(TextWatcher listener : mListeners) {</span>
          <span class="s1">listener.afterTextChanged(s)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/* 
   * This class is set as the KeyListener for the underlying TextView 
   * It does two things 
   *  1) Provides the same answer to getInputType() as the real KeyListener would have which allows 
   *     the proper keyboard to pop up on screen 
   *  2) Permits all keyboard input through 
   */</span>
  <span class="s2">private static class </span><span class="s1">InternalKeyListener </span><span class="s2">implements </span><span class="s1">KeyListener {</span>

    <span class="s2">private int </span><span class="s1">mInputType = </span><span class="s6">0</span><span class="s2">;</span>

    <span class="s2">public </span><span class="s1">InternalKeyListener() {}</span>

    <span class="s2">public void </span><span class="s1">setInputType(</span><span class="s2">int </span><span class="s1">inputType) {</span>
      <span class="s1">mInputType = inputType</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">/* 
     * getInputType will return whatever value is passed in.  This will allow the proper keyboard 
     * to be shown on screen but without the actual filtering done by other KeyListeners 
     */</span>
    <span class="s1">@Override</span>
    <span class="s2">public int </span><span class="s1">getInputType() {</span>
      <span class="s2">return </span><span class="s1">mInputType</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">/* 
     * All overrides of key handling defer to the underlying KeyListener which is shared by all 
     * ReactEditText instances.  It will basically allow any/all keyboard input whether from 
     * physical keyboard or from soft input. 
     */</span>
    <span class="s1">@Override</span>
    <span class="s2">public boolean </span><span class="s1">onKeyDown(View view</span><span class="s2">, </span><span class="s1">Editable text</span><span class="s2">, int </span><span class="s1">keyCode</span><span class="s2">, </span><span class="s1">KeyEvent event) {</span>
      <span class="s2">return </span><span class="s1">sKeyListener.onKeyDown(view</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">keyCode</span><span class="s2">, </span><span class="s1">event)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public boolean </span><span class="s1">onKeyUp(View view</span><span class="s2">, </span><span class="s1">Editable text</span><span class="s2">, int </span><span class="s1">keyCode</span><span class="s2">, </span><span class="s1">KeyEvent event) {</span>
      <span class="s2">return </span><span class="s1">sKeyListener.onKeyUp(view</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">keyCode</span><span class="s2">, </span><span class="s1">event)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public boolean </span><span class="s1">onKeyOther(View view</span><span class="s2">, </span><span class="s1">Editable text</span><span class="s2">, </span><span class="s1">KeyEvent event) {</span>
      <span class="s2">return </span><span class="s1">sKeyListener.onKeyOther(view</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">event)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">clearMetaKeyState(View view</span><span class="s2">, </span><span class="s1">Editable content</span><span class="s2">, int </span><span class="s1">states) {</span>
      <span class="s1">sKeyListener.clearMetaKeyState(view</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">states)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
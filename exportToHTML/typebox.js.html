<html>
<head>
<title>typebox.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typebox.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">/*-------------------------------------------------------------------------- 
 
@sinclair/typebox 
 
The MIT License (MIT) 
 
Copyright (c) 2017-2023 Haydn Paterson (sinclair) &lt;haydn.developer@gmail.com&gt; 
 
Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the &quot;Software&quot;), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions: 
 
The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software. 
 
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE. 
 
---------------------------------------------------------------------------*/</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s3">true </span><span class="s1">});</span>
<span class="s1">exports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.KeyResolver = exports.ObjectMap = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// Symbols</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s1">exports.Modifier = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s0">'TypeBox.Modifier'</span><span class="s1">);</span>
<span class="s1">exports.Hint = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s0">'TypeBox.Hint'</span><span class="s1">);</span>
<span class="s1">exports.Kind = Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s0">'TypeBox.Kind'</span><span class="s1">);</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// Patterns</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s1">exports.PatternBoolean = </span><span class="s0">'(true|false)'</span><span class="s1">;</span>
<span class="s1">exports.PatternNumber = </span><span class="s0">'(0|[1-9][0-9]*)'</span><span class="s1">;</span>
<span class="s1">exports.PatternString = </span><span class="s0">'(.*)'</span><span class="s1">;</span>
<span class="s1">exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;</span>
<span class="s1">exports.PatternNumberExact = `^${exports.PatternNumber}$`;</span>
<span class="s1">exports.PatternStringExact = `^${exports.PatternString}$`;</span>
<span class="s2">/** A registry for user defined types */</span>
<span class="s3">var </span><span class="s1">TypeRegistry;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TypeRegistry) {</span>
    <span class="s1">const map = </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s2">/** Returns the entries in this registry */</span>
    <span class="s3">function </span><span class="s1">Entries() {</span>
        <span class="s3">return new </span><span class="s1">Map(map);</span>
    <span class="s1">}</span>
    <span class="s1">TypeRegistry.Entries = Entries;</span>
    <span class="s2">/** Clears all user defined types */</span>
    <span class="s3">function </span><span class="s1">Clear() {</span>
        <span class="s3">return </span><span class="s1">map.clear();</span>
    <span class="s1">}</span>
    <span class="s1">TypeRegistry.Clear = Clear;</span>
    <span class="s2">/** Returns true if this registry contains this kind */</span>
    <span class="s3">function </span><span class="s1">Has(kind) {</span>
        <span class="s3">return </span><span class="s1">map.has(kind);</span>
    <span class="s1">}</span>
    <span class="s1">TypeRegistry.Has = Has;</span>
    <span class="s2">/** Sets a validation function for a user defined type */</span>
    <span class="s3">function </span><span class="s1">Set(kind, func) {</span>
        <span class="s1">map.set(kind, func);</span>
    <span class="s1">}</span>
    <span class="s1">TypeRegistry.Set = Set;</span>
    <span class="s2">/** Gets a custom validation function for a user defined type */</span>
    <span class="s3">function </span><span class="s1">Get(kind) {</span>
        <span class="s3">return </span><span class="s1">map.get(kind);</span>
    <span class="s1">}</span>
    <span class="s1">TypeRegistry.Get = Get;</span>
<span class="s1">})(TypeRegistry = exports.TypeRegistry || (exports.TypeRegistry = {}));</span>
<span class="s2">/** A registry for user defined string formats */</span>
<span class="s3">var </span><span class="s1">FormatRegistry;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(FormatRegistry) {</span>
    <span class="s1">const map = </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s2">/** Returns the entries in this registry */</span>
    <span class="s3">function </span><span class="s1">Entries() {</span>
        <span class="s3">return new </span><span class="s1">Map(map);</span>
    <span class="s1">}</span>
    <span class="s1">FormatRegistry.Entries = Entries;</span>
    <span class="s2">/** Clears all user defined string formats */</span>
    <span class="s3">function </span><span class="s1">Clear() {</span>
        <span class="s3">return </span><span class="s1">map.clear();</span>
    <span class="s1">}</span>
    <span class="s1">FormatRegistry.Clear = Clear;</span>
    <span class="s2">/** Returns true if the user defined string format exists */</span>
    <span class="s3">function </span><span class="s1">Has(format) {</span>
        <span class="s3">return </span><span class="s1">map.has(format);</span>
    <span class="s1">}</span>
    <span class="s1">FormatRegistry.Has = Has;</span>
    <span class="s2">/** Sets a validation function for a user defined string format */</span>
    <span class="s3">function </span><span class="s1">Set(format, func) {</span>
        <span class="s1">map.set(format, func);</span>
    <span class="s1">}</span>
    <span class="s1">FormatRegistry.Set = Set;</span>
    <span class="s2">/** Gets a validation function for a user defined string format */</span>
    <span class="s3">function </span><span class="s1">Get(format) {</span>
        <span class="s3">return </span><span class="s1">map.get(format);</span>
    <span class="s1">}</span>
    <span class="s1">FormatRegistry.Get = Get;</span>
<span class="s1">})(FormatRegistry = exports.FormatRegistry || (exports.FormatRegistry = {}));</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// TypeGuard</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s1">class TypeGuardUnknownTypeError extends Error {</span>
    <span class="s1">constructor(schema) {</span>
        <span class="s1">super(</span><span class="s0">'TypeGuard: Unknown type'</span><span class="s1">);</span>
        <span class="s3">this</span><span class="s1">.schema = schema;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;</span>
<span class="s2">/** Provides functions to test if JavaScript values are TypeBox types */</span>
<span class="s3">var </span><span class="s1">TypeGuard;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TypeGuard) {</span>
    <span class="s3">function </span><span class="s1">IsObject(value) {</span>
        <span class="s3">return typeof </span><span class="s1">value === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; value !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !Array.isArray(value);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsArray(value) {</span>
        <span class="s3">return typeof </span><span class="s1">value === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; value !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Array.isArray(value);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsPattern(value) {</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">new </span><span class="s1">RegExp(value);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">catch </span><span class="s1">{</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsControlCharacterFree(value) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value !== </span><span class="s0">'string'</span><span class="s1">)</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; value.length; i++) {</span>
            <span class="s1">const code = value.charCodeAt(i);</span>
            <span class="s3">if </span><span class="s1">((code &gt;= </span><span class="s4">7 </span><span class="s1">&amp;&amp; code &lt;= </span><span class="s4">13</span><span class="s1">) || code === </span><span class="s4">27 </span><span class="s1">|| code === </span><span class="s4">127</span><span class="s1">) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsBigInt(value) {</span>
        <span class="s3">return typeof </span><span class="s1">value === </span><span class="s0">'bigint'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsString(value) {</span>
        <span class="s3">return typeof </span><span class="s1">value === </span><span class="s0">'string'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsNumber(value) {</span>
        <span class="s3">return typeof </span><span class="s1">value === </span><span class="s0">'number' </span><span class="s1">&amp;&amp; globalThis.Number.isFinite(value);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsBoolean(value) {</span>
        <span class="s3">return typeof </span><span class="s1">value === </span><span class="s0">'boolean'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsOptionalBigInt(value) {</span>
        <span class="s3">return </span><span class="s1">value === undefined || (value !== undefined &amp;&amp; IsBigInt(value));</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsOptionalNumber(value) {</span>
        <span class="s3">return </span><span class="s1">value === undefined || (value !== undefined &amp;&amp; IsNumber(value));</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsOptionalBoolean(value) {</span>
        <span class="s3">return </span><span class="s1">value === undefined || (value !== undefined &amp;&amp; IsBoolean(value));</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsOptionalString(value) {</span>
        <span class="s3">return </span><span class="s1">value === undefined || (value !== undefined &amp;&amp; IsString(value));</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsOptionalPattern(value) {</span>
        <span class="s3">return </span><span class="s1">value === undefined || (value !== undefined &amp;&amp; IsString(value) &amp;&amp; IsControlCharacterFree(value) &amp;&amp; IsPattern(value));</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsOptionalFormat(value) {</span>
        <span class="s3">return </span><span class="s1">value === undefined || (value !== undefined &amp;&amp; IsString(value) &amp;&amp; IsControlCharacterFree(value));</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsOptionalSchema(value) {</span>
        <span class="s3">return </span><span class="s1">value === undefined || TSchema(value);</span>
    <span class="s1">}</span>
    <span class="s2">/** Returns true if the given schema is TAny */</span>
    <span class="s3">function </span><span class="s1">TAny(schema) {</span>
        <span class="s3">return </span><span class="s1">TKind(schema) &amp;&amp; schema[exports.Kind] === </span><span class="s0">'Any' </span><span class="s1">&amp;&amp; IsOptionalString(schema.$id);</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TAny = TAny;</span>
    <span class="s2">/** Returns true if the given schema is TArray */</span>
    <span class="s3">function </span><span class="s1">TArray(schema) {</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Array' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'array' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">TSchema(schema.items) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.minItems) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.maxItems) &amp;&amp;</span>
            <span class="s1">IsOptionalBoolean(schema.uniqueItems));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TArray = TArray;</span>
    <span class="s2">/** Returns true if the given schema is TBigInt */</span>
    <span class="s3">function </span><span class="s1">TBigInt(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'BigInt' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'null' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.typeOf === </span><span class="s0">'BigInt' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsOptionalBigInt(schema.multipleOf) &amp;&amp;</span>
            <span class="s1">IsOptionalBigInt(schema.minimum) &amp;&amp;</span>
            <span class="s1">IsOptionalBigInt(schema.maximum) &amp;&amp;</span>
            <span class="s1">IsOptionalBigInt(schema.exclusiveMinimum) &amp;&amp;</span>
            <span class="s1">IsOptionalBigInt(schema.exclusiveMaximum));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TBigInt = TBigInt;</span>
    <span class="s2">/** Returns true if the given schema is TBoolean */</span>
    <span class="s3">function </span><span class="s1">TBoolean(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Boolean' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'boolean' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TBoolean = TBoolean;</span>
    <span class="s2">/** Returns true if the given schema is TConstructor */</span>
    <span class="s3">function </span><span class="s1">TConstructor(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">if </span><span class="s1">(!(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Constructor' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.instanceOf === </span><span class="s0">'Constructor' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsArray(schema.parameters) &amp;&amp;</span>
            <span class="s1">TSchema(schema.returns))) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(const parameter of schema.parameters) {</span>
            <span class="s3">if </span><span class="s1">(!TSchema(parameter))</span>
                <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TConstructor = TConstructor;</span>
    <span class="s2">/** Returns true if the given schema is TDate */</span>
    <span class="s3">function </span><span class="s1">TDate(schema) {</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Date' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.instanceOf === </span><span class="s0">'Date' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.minimumTimestamp) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.maximumTimestamp) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.exclusiveMinimumTimestamp) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.exclusiveMaximumTimestamp));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TDate = TDate;</span>
    <span class="s2">/** Returns true if the given schema is TFunction */</span>
    <span class="s3">function </span><span class="s1">TFunction(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">if </span><span class="s1">(!(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Function' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.instanceOf === </span><span class="s0">'Function' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsArray(schema.parameters) &amp;&amp;</span>
            <span class="s1">TSchema(schema.returns))) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(const parameter of schema.parameters) {</span>
            <span class="s3">if </span><span class="s1">(!TSchema(parameter))</span>
                <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TFunction = TFunction;</span>
    <span class="s2">/** Returns true if the given schema is TInteger */</span>
    <span class="s3">function </span><span class="s1">TInteger(schema) {</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Integer' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'integer' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.multipleOf) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.minimum) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.maximum) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.exclusiveMinimum) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.exclusiveMaximum));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TInteger = TInteger;</span>
    <span class="s2">/** Returns true if the given schema is TIntersect */</span>
    <span class="s3">function </span><span class="s1">TIntersect(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">if </span><span class="s1">(!(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Intersect' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsArray(schema.allOf) &amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.type) &amp;&amp;</span>
            <span class="s1">(IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id))) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'type' </span><span class="s3">in </span><span class="s1">schema &amp;&amp; schema.type !== </span><span class="s0">'object'</span><span class="s1">) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(const inner of schema.allOf) {</span>
            <span class="s3">if </span><span class="s1">(!TSchema(inner))</span>
                <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TIntersect = TIntersect;</span>
    <span class="s2">/** Returns true if the given schema is TKind */</span>
    <span class="s3">function </span><span class="s1">TKind(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObject(schema) &amp;&amp; exports.Kind </span><span class="s3">in </span><span class="s1">schema &amp;&amp; </span><span class="s3">typeof </span><span class="s1">schema[exports.Kind] === </span><span class="s0">'string'</span><span class="s1">; </span><span class="s2">// TS 4.1.5: any required for symbol indexer</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TKind = TKind;</span>
    <span class="s2">/** Returns true if the given schema is TLiteral */</span>
    <span class="s3">function </span><span class="s1">TLiteral(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Literal' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">(IsString(schema.const) ||</span>
                <span class="s1">IsNumber(schema.const) ||</span>
                <span class="s1">IsBoolean(schema.const) ||</span>
                <span class="s1">IsBigInt(schema.const)));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TLiteral = TLiteral;</span>
    <span class="s2">/** Returns true if the given schema is TNever */</span>
    <span class="s3">function </span><span class="s1">TNever(schema) {</span>
        <span class="s3">return </span><span class="s1">TKind(schema) &amp;&amp; schema[exports.Kind] === </span><span class="s0">'Never' </span><span class="s1">&amp;&amp; IsObject(schema.not) &amp;&amp; globalThis.Object.getOwnPropertyNames(schema.not).length === </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TNever = TNever;</span>
    <span class="s2">/** Returns true if the given schema is TNot */</span>
    <span class="s3">function </span><span class="s1">TNot(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Not' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsArray(schema.allOf) &amp;&amp;</span>
            <span class="s1">schema.allOf.length === </span><span class="s4">2 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsObject(schema.allOf[</span><span class="s4">0</span><span class="s1">]) &amp;&amp;</span>
            <span class="s1">TSchema(schema.allOf[</span><span class="s4">0</span><span class="s1">].not) &amp;&amp;</span>
            <span class="s1">TSchema(schema.allOf[</span><span class="s4">1</span><span class="s1">]));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TNot = TNot;</span>
    <span class="s2">/** Returns true if the given schema is TNull */</span>
    <span class="s3">function </span><span class="s1">TNull(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Null' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'null' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TNull = TNull;</span>
    <span class="s2">/** Returns true if the given schema is TNumber */</span>
    <span class="s3">function </span><span class="s1">TNumber(schema) {</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Number' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'number' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.multipleOf) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.minimum) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.maximum) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.exclusiveMinimum) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.exclusiveMaximum));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TNumber = TNumber;</span>
    <span class="s2">/** Returns true if the given schema is TObject */</span>
    <span class="s3">function </span><span class="s1">TObject(schema) {</span>
        <span class="s3">if </span><span class="s1">(!(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Object' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsObject(schema.properties) &amp;&amp;</span>
            <span class="s1">(IsOptionalBoolean(schema.additionalProperties) || IsOptionalSchema(schema.additionalProperties)) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.minProperties) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.maxProperties))) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(const [key, value] of Object.entries(schema.properties)) {</span>
            <span class="s3">if </span><span class="s1">(!IsControlCharacterFree(key))</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!TSchema(value))</span>
                <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TObject = TObject;</span>
    <span class="s2">/** Returns true if the given schema is TPromise */</span>
    <span class="s3">function </span><span class="s1">TPromise(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Promise' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.instanceOf === </span><span class="s0">'Promise' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">TSchema(schema.item));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TPromise = TPromise;</span>
    <span class="s2">/** Returns true if the given schema is TRecord */</span>
    <span class="s3">function </span><span class="s1">TRecord(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">if </span><span class="s1">(!(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Record' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">schema.additionalProperties === </span><span class="s3">false </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsObject(schema.patternProperties))) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const keys = Object.keys(schema.patternProperties);</span>
        <span class="s3">if </span><span class="s1">(keys.length !== </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!IsPattern(keys[</span><span class="s4">0</span><span class="s1">])) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!TSchema(schema.patternProperties[keys[</span><span class="s4">0</span><span class="s1">]])) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TRecord = TRecord;</span>
    <span class="s2">/** Returns true if the given schema is TRef */</span>
    <span class="s3">function </span><span class="s1">TRef(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Ref' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsString(schema.$ref));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TRef = TRef;</span>
    <span class="s2">/** Returns true if the given schema is TString */</span>
    <span class="s3">function </span><span class="s1">TString(schema) {</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'String' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.minLength) &amp;&amp;</span>
            <span class="s1">IsOptionalNumber(schema.maxLength) &amp;&amp;</span>
            <span class="s1">IsOptionalPattern(schema.pattern) &amp;&amp;</span>
            <span class="s1">IsOptionalFormat(schema.format));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TString = TString;</span>
    <span class="s2">/** Returns true if the given schema is TSymbol */</span>
    <span class="s3">function </span><span class="s1">TSymbol(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Symbol' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'null' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.typeOf === </span><span class="s0">'Symbol' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TSymbol = TSymbol;</span>
    <span class="s2">/** Returns true if the given schema is TTemplateLiteral */</span>
    <span class="s3">function </span><span class="s1">TTemplateLiteral(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'TemplateLiteral' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsString(schema.pattern) &amp;&amp;</span>
            <span class="s1">schema.pattern[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'^' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.pattern[schema.pattern.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">'$'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TTemplateLiteral = TTemplateLiteral;</span>
    <span class="s2">/** Returns true if the given schema is TThis */</span>
    <span class="s3">function </span><span class="s1">TThis(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'This' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsString(schema.$ref));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TThis = TThis;</span>
    <span class="s2">/** Returns true if the given schema is TTuple */</span>
    <span class="s3">function </span><span class="s1">TTuple(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">if </span><span class="s1">(!(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Tuple' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'array' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id) &amp;&amp;</span>
            <span class="s1">IsNumber(schema.minItems) &amp;&amp;</span>
            <span class="s1">IsNumber(schema.maxItems) &amp;&amp;</span>
            <span class="s1">schema.minItems === schema.maxItems)) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(schema.items === undefined &amp;&amp; schema.additionalItems === undefined &amp;&amp; schema.minItems === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!IsArray(schema.items)) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(const inner of schema.items) {</span>
            <span class="s3">if </span><span class="s1">(!TSchema(inner))</span>
                <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TTuple = TTuple;</span>
    <span class="s2">/** Returns true if the given schema is TUndefined */</span>
    <span class="s3">function </span><span class="s1">TUndefined(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Undefined' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'null' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.typeOf === </span><span class="s0">'Undefined' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TUndefined = TUndefined;</span>
    <span class="s2">/** Returns true if the given schema is TUnion */</span>
    <span class="s3">function </span><span class="s1">TUnion(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">if </span><span class="s1">(!(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Union' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsArray(schema.anyOf) &amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id))) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(const inner of schema.anyOf) {</span>
            <span class="s3">if </span><span class="s1">(!TSchema(inner))</span>
                <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TUnion = TUnion;</span>
    <span class="s2">/** Returns true if the given schema is TUnion&lt;Literal&lt;string&gt;[]&gt; */</span>
    <span class="s3">function </span><span class="s1">TUnionLiteral(schema) {</span>
        <span class="s3">return </span><span class="s1">TUnion(schema) &amp;&amp; schema.anyOf.every((schema) =&gt; TLiteral(schema) &amp;&amp; </span><span class="s3">typeof </span><span class="s1">schema.const === </span><span class="s0">'string'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TUnionLiteral = TUnionLiteral;</span>
    <span class="s2">/** Returns true if the given schema is TUint8Array */</span>
    <span class="s3">function </span><span class="s1">TUint8Array(schema) {</span>
        <span class="s3">return </span><span class="s1">TKind(schema) &amp;&amp; schema[exports.Kind] === </span><span class="s0">'Uint8Array' </span><span class="s1">&amp;&amp; schema.type === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; IsOptionalString(schema.$id) &amp;&amp; schema.instanceOf === </span><span class="s0">'Uint8Array' </span><span class="s1">&amp;&amp; IsOptionalNumber(schema.minByteLength) &amp;&amp; IsOptionalNumber(schema.maxByteLength);</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TUint8Array = TUint8Array;</span>
    <span class="s2">/** Returns true if the given schema is TUnknown */</span>
    <span class="s3">function </span><span class="s1">TUnknown(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Unknown' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TUnknown = TUnknown;</span>
    <span class="s2">/** Returns true if the given schema is a raw TUnsafe */</span>
    <span class="s3">function </span><span class="s1">TUnsafe(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Unsafe'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TUnsafe = TUnsafe;</span>
    <span class="s2">/** Returns true if the given schema is TVoid */</span>
    <span class="s3">function </span><span class="s1">TVoid(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(TKind(schema) &amp;&amp;</span>
            <span class="s1">schema[exports.Kind] === </span><span class="s0">'Void' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.type === </span><span class="s0">'null' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">schema.typeOf === </span><span class="s0">'Void' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">IsOptionalString(schema.$id));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TVoid = TVoid;</span>
    <span class="s2">/** Returns true if this schema has the ReadonlyOptional modifier */</span>
    <span class="s3">function </span><span class="s1">TReadonlyOptional(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObject(schema) &amp;&amp; schema[exports.Modifier] === </span><span class="s0">'ReadonlyOptional'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TReadonlyOptional = TReadonlyOptional;</span>
    <span class="s2">/** Returns true if this schema has the Readonly modifier */</span>
    <span class="s3">function </span><span class="s1">TReadonly(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObject(schema) &amp;&amp; schema[exports.Modifier] === </span><span class="s0">'Readonly'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TReadonly = TReadonly;</span>
    <span class="s2">/** Returns true if this schema has the Optional modifier */</span>
    <span class="s3">function </span><span class="s1">TOptional(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObject(schema) &amp;&amp; schema[exports.Modifier] === </span><span class="s0">'Optional'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TOptional = TOptional;</span>
    <span class="s2">/** Returns true if the given schema is TSchema */</span>
    <span class="s3">function </span><span class="s1">TSchema(schema) {</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">schema === </span><span class="s0">'object' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(TAny(schema) ||</span>
                <span class="s1">TArray(schema) ||</span>
                <span class="s1">TBoolean(schema) ||</span>
                <span class="s1">TBigInt(schema) ||</span>
                <span class="s1">TConstructor(schema) ||</span>
                <span class="s1">TDate(schema) ||</span>
                <span class="s1">TFunction(schema) ||</span>
                <span class="s1">TInteger(schema) ||</span>
                <span class="s1">TIntersect(schema) ||</span>
                <span class="s1">TLiteral(schema) ||</span>
                <span class="s1">TNever(schema) ||</span>
                <span class="s1">TNot(schema) ||</span>
                <span class="s1">TNull(schema) ||</span>
                <span class="s1">TNumber(schema) ||</span>
                <span class="s1">TObject(schema) ||</span>
                <span class="s1">TPromise(schema) ||</span>
                <span class="s1">TRecord(schema) ||</span>
                <span class="s1">TRef(schema) ||</span>
                <span class="s1">TString(schema) ||</span>
                <span class="s1">TSymbol(schema) ||</span>
                <span class="s1">TTemplateLiteral(schema) ||</span>
                <span class="s1">TThis(schema) ||</span>
                <span class="s1">TTuple(schema) ||</span>
                <span class="s1">TUndefined(schema) ||</span>
                <span class="s1">TUnion(schema) ||</span>
                <span class="s1">TUint8Array(schema) ||</span>
                <span class="s1">TUnknown(schema) ||</span>
                <span class="s1">TUnsafe(schema) ||</span>
                <span class="s1">TVoid(schema) ||</span>
                <span class="s1">(TKind(schema) &amp;&amp; TypeRegistry.Has(schema[exports.Kind]))));</span>
    <span class="s1">}</span>
    <span class="s1">TypeGuard.TSchema = TSchema;</span>
<span class="s1">})(TypeGuard = exports.TypeGuard || (exports.TypeGuard = {}));</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// ExtendsUndefined</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">/** Fast undefined check used for properties of type undefined */</span>
<span class="s3">var </span><span class="s1">ExtendsUndefined;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(ExtendsUndefined) {</span>
    <span class="s3">function </span><span class="s1">Check(schema) {</span>
        <span class="s3">if </span><span class="s1">(schema[exports.Kind] === </span><span class="s0">'Undefined'</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(schema[exports.Kind] === </span><span class="s0">'Union'</span><span class="s1">) {</span>
            <span class="s1">const union = schema;</span>
            <span class="s3">return </span><span class="s1">union.anyOf.some((schema) =&gt; Check(schema));</span>
        <span class="s1">}</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">ExtendsUndefined.Check = Check;</span>
<span class="s1">})(ExtendsUndefined = exports.ExtendsUndefined || (exports.ExtendsUndefined = {}));</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// TypeExtends</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s3">var </span><span class="s1">TypeExtendsResult;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TypeExtendsResult) {</span>
    <span class="s1">TypeExtendsResult[TypeExtendsResult[</span><span class="s0">&quot;Union&quot;</span><span class="s1">] = </span><span class="s4">0</span><span class="s1">] = </span><span class="s0">&quot;Union&quot;</span><span class="s1">;</span>
    <span class="s1">TypeExtendsResult[TypeExtendsResult[</span><span class="s0">&quot;True&quot;</span><span class="s1">] = </span><span class="s4">1</span><span class="s1">] = </span><span class="s0">&quot;True&quot;</span><span class="s1">;</span>
    <span class="s1">TypeExtendsResult[TypeExtendsResult[</span><span class="s0">&quot;False&quot;</span><span class="s1">] = </span><span class="s4">2</span><span class="s1">] = </span><span class="s0">&quot;False&quot;</span><span class="s1">;</span>
<span class="s1">})(TypeExtendsResult = exports.TypeExtendsResult || (exports.TypeExtendsResult = {}));</span>
<span class="s3">var </span><span class="s1">TypeExtends;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TypeExtends) {</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// IntoBooleanResult</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">IntoBooleanResult(result) {</span>
        <span class="s3">return </span><span class="s1">result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Any</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">AnyRight(left, right) {</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Any(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right) &amp;&amp; right.anyOf.some((schema) =&gt; TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.Union;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.Union;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Array</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">ArrayRight(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.Union;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Array(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right) &amp;&amp; IsObjectArrayLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(!TypeGuard.TArray(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">return </span><span class="s1">IntoBooleanResult(Visit(left.items, right.items));</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// BigInt</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">BigInt(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Boolean</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">BooleanRight(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left) &amp;&amp; </span><span class="s3">typeof </span><span class="s1">left.const === </span><span class="s0">'boolean'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Boolean(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Constructor</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Constructor(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(!TypeGuard.TConstructor(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(left.parameters.length &gt; right.parameters.length)</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(!left.parameters.every((schema, index) =&gt; IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">IntoBooleanResult(Visit(left.returns, right.returns));</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Date</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Date(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Function</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Function(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(!TypeGuard.TFunction(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(left.parameters.length &gt; right.parameters.length)</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(!left.parameters.every((schema, index) =&gt; IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">IntoBooleanResult(Visit(left.returns, right.returns));</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Integer</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">IntegerRight(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left) &amp;&amp; </span><span class="s3">typeof </span><span class="s1">left.const === </span><span class="s0">'number'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Integer(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Intersect</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">IntersectRight(left, right) {</span>
        <span class="s3">return </span><span class="s1">right.allOf.every((schema) =&gt; Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Intersect(left, right) {</span>
        <span class="s3">return </span><span class="s1">left.allOf.some((schema) =&gt; Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Literal</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">IsLiteralString(schema) {</span>
        <span class="s3">return typeof </span><span class="s1">schema.const === </span><span class="s0">'string'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsLiteralNumber(schema) {</span>
        <span class="s3">return typeof </span><span class="s1">schema.const === </span><span class="s0">'number'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsLiteralBoolean(schema) {</span>
        <span class="s3">return typeof </span><span class="s1">schema.const === </span><span class="s0">'boolean'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Literal(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TString(right))</span>
            <span class="s3">return </span><span class="s1">StringRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNumber(right))</span>
            <span class="s3">return </span><span class="s1">NumberRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TInteger(right))</span>
            <span class="s3">return </span><span class="s1">IntegerRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TBoolean(right))</span>
            <span class="s3">return </span><span class="s1">BooleanRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TLiteral(right) &amp;&amp; right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Never</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">NeverRight(left, right) {</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Never(left, right) {</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Null</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Null(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Number</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">NumberRight(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left) &amp;&amp; IsLiteralNumber(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Number(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Object</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">IsObjectPropertyCount(schema, count) {</span>
        <span class="s3">return </span><span class="s1">globalThis.Object.keys(schema.properties).length === count;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectStringLike(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObjectArrayLike(schema);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectSymbolLike(schema) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">) || (IsObjectPropertyCount(schema, </span><span class="s4">1</span><span class="s1">) &amp;&amp; </span><span class="s0">'description' </span><span class="s3">in </span><span class="s1">schema.properties &amp;&amp; TypeGuard.TUnion(schema.properties.description) &amp;&amp; schema.properties.description.anyOf.length === </span><span class="s4">2 </span><span class="s1">&amp;&amp; ((TypeGuard.TString(schema.properties.description.anyOf[</span><span class="s4">0</span><span class="s1">]) &amp;&amp;</span>
            <span class="s1">TypeGuard.TUndefined(schema.properties.description.anyOf[</span><span class="s4">1</span><span class="s1">])) || (TypeGuard.TString(schema.properties.description.anyOf[</span><span class="s4">1</span><span class="s1">]) &amp;&amp;</span>
            <span class="s1">TypeGuard.TUndefined(schema.properties.description.anyOf[</span><span class="s4">0</span><span class="s1">]))));</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectNumberLike(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectBooleanLike(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectBigIntLike(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectDateLike(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectUint8ArrayLike(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObjectArrayLike(schema);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectFunctionLike(schema) {</span>
        <span class="s1">const length = exports.Type.Number();</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">) || (IsObjectPropertyCount(schema, </span><span class="s4">1</span><span class="s1">) &amp;&amp; </span><span class="s0">'length' </span><span class="s3">in </span><span class="s1">schema.properties &amp;&amp; IntoBooleanResult(Visit(schema.properties[</span><span class="s0">'length'</span><span class="s1">], length)) === TypeExtendsResult.True);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectConstructorLike(schema) {</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectArrayLike(schema) {</span>
        <span class="s1">const length = exports.Type.Number();</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">) || (IsObjectPropertyCount(schema, </span><span class="s4">1</span><span class="s1">) &amp;&amp; </span><span class="s0">'length' </span><span class="s3">in </span><span class="s1">schema.properties &amp;&amp; IntoBooleanResult(Visit(schema.properties[</span><span class="s0">'length'</span><span class="s1">], length)) === TypeExtendsResult.True);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsObjectPromiseLike(schema) {</span>
        <span class="s1">const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());</span>
        <span class="s3">return </span><span class="s1">IsObjectPropertyCount(schema, </span><span class="s4">0</span><span class="s1">) || (IsObjectPropertyCount(schema, </span><span class="s4">1</span><span class="s1">) &amp;&amp; </span><span class="s0">'then' </span><span class="s3">in </span><span class="s1">schema.properties &amp;&amp; IntoBooleanResult(Visit(schema.properties[</span><span class="s0">'then'</span><span class="s1">], then)) === TypeExtendsResult.True);</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Property</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Property(left, right) {</span>
        <span class="s3">if </span><span class="s1">(Visit(left, right) === TypeExtendsResult.False)</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TOptional(left) &amp;&amp; !TypeGuard.TOptional(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">ObjectRight(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.Union;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left) &amp;&amp; IsLiteralString(left) &amp;&amp; IsObjectStringLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left) &amp;&amp; IsLiteralNumber(left) &amp;&amp; IsObjectNumberLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left) &amp;&amp; IsLiteralBoolean(left) &amp;&amp; IsObjectBooleanLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TSymbol(left) &amp;&amp; IsObjectSymbolLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TBigInt(left) &amp;&amp; IsObjectBigIntLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TString(left) &amp;&amp; IsObjectStringLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TSymbol(left) &amp;&amp; IsObjectSymbolLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNumber(left) &amp;&amp; IsObjectNumberLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TInteger(left) &amp;&amp; IsObjectNumberLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TBoolean(left) &amp;&amp; IsObjectBooleanLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUint8Array(left) &amp;&amp; IsObjectUint8ArrayLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TDate(left) &amp;&amp; IsObjectDateLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TConstructor(left) &amp;&amp; IsObjectConstructorLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TFunction(left) &amp;&amp; IsObjectFunctionLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(left) &amp;&amp; TypeGuard.TString(RecordKey(left))) {</span>
            <span class="s2">// When expressing a Record with literal key values, the Record is converted into a Object with</span>
            <span class="s2">// the Hint assigned as `Record`. This is used to invert the extends logic.</span>
            <span class="s3">return </span><span class="s1">right[exports.Hint] === </span><span class="s0">'Record' </span><span class="s1">? TypeExtendsResult.True : TypeExtendsResult.False;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(left) &amp;&amp; TypeGuard.TNumber(RecordKey(left))) {</span>
            <span class="s3">return </span><span class="s1">IsObjectPropertyCount(right, </span><span class="s4">0</span><span class="s1">) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Object(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(!TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">for </span><span class="s1">(const key of globalThis.Object.keys(right.properties)) {</span>
            <span class="s3">if </span><span class="s1">(!(key </span><span class="s3">in </span><span class="s1">left.properties))</span>
                <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
            <span class="s3">if </span><span class="s1">(Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {</span>
                <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Promise</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Promise(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right) &amp;&amp; IsObjectPromiseLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(!TypeGuard.TPromise(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">return </span><span class="s1">IntoBooleanResult(Visit(left.item, right.item));</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Record</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">RecordKey(schema) {</span>
        <span class="s3">if </span><span class="s1">(exports.PatternNumberExact </span><span class="s3">in </span><span class="s1">schema.patternProperties)</span>
            <span class="s3">return </span><span class="s1">exports.Type.Number();</span>
        <span class="s3">if </span><span class="s1">(exports.PatternStringExact </span><span class="s3">in </span><span class="s1">schema.patternProperties)</span>
            <span class="s3">return </span><span class="s1">exports.Type.String();</span>
        <span class="s3">throw </span><span class="s1">Error(</span><span class="s0">'TypeExtends: Cannot get record key'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">RecordValue(schema) {</span>
        <span class="s3">if </span><span class="s1">(exports.PatternNumberExact </span><span class="s3">in </span><span class="s1">schema.patternProperties)</span>
            <span class="s3">return </span><span class="s1">schema.patternProperties[exports.PatternNumberExact];</span>
        <span class="s3">if </span><span class="s1">(exports.PatternStringExact </span><span class="s3">in </span><span class="s1">schema.patternProperties)</span>
            <span class="s3">return </span><span class="s1">schema.patternProperties[exports.PatternStringExact];</span>
        <span class="s3">throw </span><span class="s1">Error(</span><span class="s0">'TypeExtends: Cannot get record value'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">RecordRight(left, right) {</span>
        <span class="s1">const Key = RecordKey(right);</span>
        <span class="s1">const Value = RecordValue(right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left) &amp;&amp; IsLiteralString(left) &amp;&amp; TypeGuard.TNumber(Key) &amp;&amp; IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUint8Array(left) &amp;&amp; TypeGuard.TNumber(Key))</span>
            <span class="s3">return </span><span class="s1">Visit(left, Value);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TString(left) &amp;&amp; TypeGuard.TNumber(Key))</span>
            <span class="s3">return </span><span class="s1">Visit(left, Value);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TArray(left) &amp;&amp; TypeGuard.TNumber(Key))</span>
            <span class="s3">return </span><span class="s1">Visit(left, Value);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(left)) {</span>
            <span class="s3">for </span><span class="s1">(const key of globalThis.Object.keys(left.properties)) {</span>
                <span class="s3">if </span><span class="s1">(Property(Value, left.properties[key]) === TypeExtendsResult.False) {</span>
                    <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Record(left, right) {</span>
        <span class="s1">const Value = RecordValue(left);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(!TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">return </span><span class="s1">Visit(Value, RecordValue(right));</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// String</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">StringRight(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left) &amp;&amp; </span><span class="s3">typeof </span><span class="s1">left.const === </span><span class="s0">'string'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">String(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Symbol</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Symbol(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Tuple</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">TupleRight(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.Union;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsArrayOfTuple(left, right) {</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TArray(right) &amp;&amp; left.items !== undefined &amp;&amp; left.items.every((schema) =&gt; Visit(schema, right.items) === TypeExtendsResult.True);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Tuple(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right) &amp;&amp; IsObjectArrayLike(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TArray(right) &amp;&amp; IsArrayOfTuple(left, right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">if </span><span class="s1">(!TypeGuard.TTuple(right))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">((left.items === undefined &amp;&amp; right.items !== undefined) || (left.items !== undefined &amp;&amp; right.items === undefined))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.False;</span>
        <span class="s3">if </span><span class="s1">(left.items === undefined &amp;&amp; right.items === undefined)</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">left.items.every((schema, index) =&gt; Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Uint8Array</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Uint8Array(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Undefined</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Undefined(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(right))</span>
            <span class="s3">return </span><span class="s1">NeverRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(right))</span>
            <span class="s3">return </span><span class="s1">RecordRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TVoid(right))</span>
            <span class="s3">return </span><span class="s1">VoidRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Union</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">UnionRight(left, right) {</span>
        <span class="s3">return </span><span class="s1">right.anyOf.some((schema) =&gt; Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Union(left, right) {</span>
        <span class="s3">return </span><span class="s1">left.anyOf.every((schema) =&gt; Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Unknown</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">UnknownRight(left, right) {</span>
        <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Unknown(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TString(right))</span>
            <span class="s3">return </span><span class="s1">StringRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNumber(right))</span>
            <span class="s3">return </span><span class="s1">NumberRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TInteger(right))</span>
            <span class="s3">return </span><span class="s1">IntegerRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TBoolean(right))</span>
            <span class="s3">return </span><span class="s1">BooleanRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TArray(right))</span>
            <span class="s3">return </span><span class="s1">ArrayRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTuple(right))</span>
            <span class="s3">return </span><span class="s1">TupleRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s2">// Void</span>
    <span class="s2">// --------------------------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">VoidRight(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUndefined(left))</span>
            <span class="s3">return </span><span class="s1">TypeExtendsResult.True;</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Void(left, right) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(right))</span>
            <span class="s3">return </span><span class="s1">IntersectRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(right))</span>
            <span class="s3">return </span><span class="s1">UnionRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(right))</span>
            <span class="s3">return </span><span class="s1">UnknownRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(right))</span>
            <span class="s3">return </span><span class="s1">AnyRight(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(right))</span>
            <span class="s3">return </span><span class="s1">ObjectRight(left, right);</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Visit(left, right) {</span>
        <span class="s2">// template union remap</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(left))</span>
            <span class="s3">return </span><span class="s1">Visit(TemplateLiteralResolver.Resolve(left), right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(right))</span>
            <span class="s3">return </span><span class="s1">Visit(left, TemplateLiteralResolver.Resolve(right));</span>
        <span class="s2">// standard extends</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TAny(left))</span>
            <span class="s3">return </span><span class="s1">Any(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TArray(left))</span>
            <span class="s3">return </span><span class="s1">Array(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TBigInt(left))</span>
            <span class="s3">return </span><span class="s1">BigInt(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TBoolean(left))</span>
            <span class="s3">return </span><span class="s1">Boolean(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TConstructor(left))</span>
            <span class="s3">return </span><span class="s1">Constructor(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TDate(left))</span>
            <span class="s3">return </span><span class="s1">Date(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TFunction(left))</span>
            <span class="s3">return </span><span class="s1">Function(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TInteger(left))</span>
            <span class="s3">return </span><span class="s1">Integer(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(left))</span>
            <span class="s3">return </span><span class="s1">Intersect(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TLiteral(left))</span>
            <span class="s3">return </span><span class="s1">Literal(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNever(left))</span>
            <span class="s3">return </span><span class="s1">Never(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNull(left))</span>
            <span class="s3">return </span><span class="s1">Null(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TNumber(left))</span>
            <span class="s3">return </span><span class="s1">Number(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(left))</span>
            <span class="s3">return </span><span class="s1">Object(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(left))</span>
            <span class="s3">return </span><span class="s1">Record(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TString(left))</span>
            <span class="s3">return </span><span class="s1">String(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TSymbol(left))</span>
            <span class="s3">return </span><span class="s1">Symbol(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTuple(left))</span>
            <span class="s3">return </span><span class="s1">Tuple(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TPromise(left))</span>
            <span class="s3">return </span><span class="s1">Promise(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUint8Array(left))</span>
            <span class="s3">return </span><span class="s1">Uint8Array(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUndefined(left))</span>
            <span class="s3">return </span><span class="s1">Undefined(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(left))</span>
            <span class="s3">return </span><span class="s1">Union(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnknown(left))</span>
            <span class="s3">return </span><span class="s1">Unknown(left, right);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TVoid(left))</span>
            <span class="s3">return </span><span class="s1">Void(left, right);</span>
        <span class="s3">throw </span><span class="s1">Error(`TypeExtends: Unknown left type operand </span><span class="s0">'${left[exports.Kind]}'</span><span class="s1">`);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Extends(left, right) {</span>
        <span class="s3">return </span><span class="s1">Visit(left, right);</span>
    <span class="s1">}</span>
    <span class="s1">TypeExtends.Extends = Extends;</span>
<span class="s1">})(TypeExtends = exports.TypeExtends || (exports.TypeExtends = {}));</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// TypeClone</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">/** Specialized Clone for Types */</span>
<span class="s3">var </span><span class="s1">TypeClone;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TypeClone) {</span>
    <span class="s3">function </span><span class="s1">IsObject(value) {</span>
        <span class="s3">return typeof </span><span class="s1">value === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; value !== </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsArray(value) {</span>
        <span class="s3">return </span><span class="s1">globalThis.Array.isArray(value);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Array(value) {</span>
        <span class="s3">return </span><span class="s1">value.map((value) =&gt; Visit(value));</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Object(value) {</span>
        <span class="s1">const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) =&gt; {</span>
            <span class="s3">return </span><span class="s1">{ ...acc, [key]: Visit(value[key]) };</span>
        <span class="s1">}, {});</span>
        <span class="s1">const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) =&gt; {</span>
            <span class="s3">return </span><span class="s1">{ ...acc, [key]: Visit(value[key]) };</span>
        <span class="s1">}, {});</span>
        <span class="s3">return </span><span class="s1">{ ...clonedProperties, ...clonedSymbols };</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Visit(value) {</span>
        <span class="s3">if </span><span class="s1">(IsArray(value))</span>
            <span class="s3">return </span><span class="s1">Array(value);</span>
        <span class="s3">if </span><span class="s1">(IsObject(value))</span>
            <span class="s3">return </span><span class="s1">Object(value);</span>
        <span class="s3">return </span><span class="s1">value;</span>
    <span class="s1">}</span>
    <span class="s2">/** Clones a type. */</span>
    <span class="s3">function </span><span class="s1">Clone(schema, options) {</span>
        <span class="s3">return </span><span class="s1">{ ...Visit(schema), ...options };</span>
    <span class="s1">}</span>
    <span class="s1">TypeClone.Clone = Clone;</span>
<span class="s1">})(TypeClone = exports.TypeClone || (exports.TypeClone = {}));</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// ObjectMap</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s3">var </span><span class="s1">ObjectMap;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(ObjectMap) {</span>
    <span class="s3">function </span><span class="s1">Intersect(schema, callback) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">exports.Type.Intersect(schema.allOf.map((inner) =&gt; Visit(inner, callback)), { ...schema });</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Union(schema, callback) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">exports.Type.Union(schema.anyOf.map((inner) =&gt; Visit(inner, callback)), { ...schema });</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Object(schema, callback) {</span>
        <span class="s3">return </span><span class="s1">callback(schema);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Visit(schema, callback) {</span>
        <span class="s2">// There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would</span>
        <span class="s2">// prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the</span>
        <span class="s2">// case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only</span>
        <span class="s2">// used for composition, we use explicit checks instead.</span>
        <span class="s3">if </span><span class="s1">(schema[exports.Kind] === </span><span class="s0">'Intersect'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">Intersect(schema, callback);</span>
        <span class="s3">if </span><span class="s1">(schema[exports.Kind] === </span><span class="s0">'Union'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">Union(schema, callback);</span>
        <span class="s3">if </span><span class="s1">(schema[exports.Kind] === </span><span class="s0">'Object'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">Object(schema, callback);</span>
        <span class="s3">return </span><span class="s1">schema;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Map(schema, callback, options) {</span>
        <span class="s3">return </span><span class="s1">{ ...Visit(TypeClone.Clone(schema, {}), callback), ...options };</span>
    <span class="s1">}</span>
    <span class="s1">ObjectMap.Map = Map;</span>
<span class="s1">})(ObjectMap = exports.ObjectMap || (exports.ObjectMap = {}));</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// KeyResolver</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s3">var </span><span class="s1">KeyResolver;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(KeyResolver) {</span>
    <span class="s3">function </span><span class="s1">IsKeyable(schema) {</span>
        <span class="s3">return </span><span class="s1">TypeGuard.TIntersect(schema) || TypeGuard.TUnion(schema) || (TypeGuard.TObject(schema) &amp;&amp; globalThis.Object.getOwnPropertyNames(schema.properties).length &gt; </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Intersect(schema) {</span>
        <span class="s3">return </span><span class="s1">[...schema.allOf.filter((schema) =&gt; IsKeyable(schema)).reduce((set, schema) =&gt; Visit(schema).map((key) =&gt; set.add(key))[</span><span class="s4">0</span><span class="s1">], </span><span class="s3">new </span><span class="s1">Set())];</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Union(schema) {</span>
        <span class="s1">const sets = schema.anyOf.filter((schema) =&gt; IsKeyable(schema)).map((inner) =&gt; Visit(inner));</span>
        <span class="s3">return </span><span class="s1">[...sets.reduce((set, outer) =&gt; outer.map((key) =&gt; (sets.every((inner) =&gt; inner.includes(key)) ? set.add(key) : set))[</span><span class="s4">0</span><span class="s1">], </span><span class="s3">new </span><span class="s1">Set())];</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Object(schema) {</span>
        <span class="s3">return </span><span class="s1">globalThis.Object.keys(schema.properties);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Visit(schema) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TIntersect(schema))</span>
            <span class="s3">return </span><span class="s1">Intersect(schema);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(schema))</span>
            <span class="s3">return </span><span class="s1">Union(schema);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TObject(schema))</span>
            <span class="s3">return </span><span class="s1">Object(schema);</span>
        <span class="s3">return </span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Resolve(schema) {</span>
        <span class="s3">return </span><span class="s1">Visit(schema);</span>
    <span class="s1">}</span>
    <span class="s1">KeyResolver.Resolve = Resolve;</span>
<span class="s1">})(KeyResolver = exports.KeyResolver || (exports.KeyResolver = {}));</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// TemplateLiteralPattern</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s3">var </span><span class="s1">TemplateLiteralPattern;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TemplateLiteralPattern) {</span>
    <span class="s3">function </span><span class="s1">Escape(value) {</span>
        <span class="s3">return </span><span class="s1">value.replace(/[.*+?^${}()|[\]\\]/g, </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">$&amp;'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Visit(schema, acc) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(schema)) {</span>
            <span class="s1">const pattern = schema.pattern.slice(</span><span class="s4">1</span><span class="s1">, schema.pattern.length - </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">pattern;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TUnion(schema)) {</span>
            <span class="s1">const tokens = schema.anyOf.map((schema) =&gt; Visit(schema, acc)).join(</span><span class="s0">'|'</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">`(${tokens})`;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TNumber(schema)) {</span>
            <span class="s3">return </span><span class="s1">`${acc}${exports.PatternNumber}`;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TInteger(schema)) {</span>
            <span class="s3">return </span><span class="s1">`${acc}${exports.PatternNumber}`;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TBigInt(schema)) {</span>
            <span class="s3">return </span><span class="s1">`${acc}${exports.PatternNumber}`;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TString(schema)) {</span>
            <span class="s3">return </span><span class="s1">`${acc}${exports.PatternString}`;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TLiteral(schema)) {</span>
            <span class="s3">return </span><span class="s1">`${acc}${Escape(schema.const.toString())}`;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TBoolean(schema)) {</span>
            <span class="s3">return </span><span class="s1">`${acc}${exports.PatternBoolean}`;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TNever(schema)) {</span>
            <span class="s3">throw </span><span class="s1">Error(</span><span class="s0">'TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error(`TemplateLiteralPattern: Unexpected Kind </span><span class="s0">'${schema[exports.Kind]}'</span><span class="s1">`);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Create(kinds) {</span>
        <span class="s3">return </span><span class="s1">`^${kinds.map((schema) =&gt; Visit(schema, </span><span class="s0">''</span><span class="s1">)).join(</span><span class="s0">''</span><span class="s1">)}\$`;</span>
    <span class="s1">}</span>
    <span class="s1">TemplateLiteralPattern.Create = Create;</span>
<span class="s1">})(TemplateLiteralPattern = exports.TemplateLiteralPattern || (exports.TemplateLiteralPattern = {}));</span>
<span class="s2">// --------------------------------------------------------------------------------------</span>
<span class="s2">// TemplateLiteralResolver</span>
<span class="s2">// --------------------------------------------------------------------------------------</span>
<span class="s3">var </span><span class="s1">TemplateLiteralResolver;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TemplateLiteralResolver) {</span>
    <span class="s3">function </span><span class="s1">Resolve(template) {</span>
        <span class="s1">const expression = TemplateLiteralParser.ParseExact(template.pattern);</span>
        <span class="s3">if </span><span class="s1">(!TemplateLiteralFinite.Check(expression))</span>
            <span class="s3">return </span><span class="s1">exports.Type.String();</span>
        <span class="s1">const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) =&gt; exports.Type.Literal(value));</span>
        <span class="s3">return </span><span class="s1">exports.Type.Union(literals);</span>
    <span class="s1">}</span>
    <span class="s1">TemplateLiteralResolver.Resolve = Resolve;</span>
<span class="s1">})(TemplateLiteralResolver = exports.TemplateLiteralResolver || (exports.TemplateLiteralResolver = {}));</span>
<span class="s2">// --------------------------------------------------------------------------------------</span>
<span class="s2">// TemplateLiteralParser</span>
<span class="s2">// --------------------------------------------------------------------------------------</span>
<span class="s1">class TemplateLiteralParserError extends Error {</span>
    <span class="s1">constructor(message) {</span>
        <span class="s1">super(message);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.TemplateLiteralParserError = TemplateLiteralParserError;</span>
<span class="s3">var </span><span class="s1">TemplateLiteralParser;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TemplateLiteralParser) {</span>
    <span class="s3">function </span><span class="s1">IsNonEscaped(pattern, index, char) {</span>
        <span class="s3">return </span><span class="s1">pattern[index] === char &amp;&amp; pattern.charCodeAt(index - </span><span class="s4">1</span><span class="s1">) !== </span><span class="s4">92</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsOpenParen(pattern, index) {</span>
        <span class="s3">return </span><span class="s1">IsNonEscaped(pattern, index, </span><span class="s0">'('</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsCloseParen(pattern, index) {</span>
        <span class="s3">return </span><span class="s1">IsNonEscaped(pattern, index, </span><span class="s0">')'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsSeparator(pattern, index) {</span>
        <span class="s3">return </span><span class="s1">IsNonEscaped(pattern, index, </span><span class="s0">'|'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsGroup(pattern) {</span>
        <span class="s3">if </span><span class="s1">(!(IsOpenParen(pattern, </span><span class="s4">0</span><span class="s1">) &amp;&amp; IsCloseParen(pattern, pattern.length - </span><span class="s4">1</span><span class="s1">)))</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">let count = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(let index = </span><span class="s4">0</span><span class="s1">; index &lt; pattern.length; index++) {</span>
            <span class="s3">if </span><span class="s1">(IsOpenParen(pattern, index))</span>
                <span class="s1">count += </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(IsCloseParen(pattern, index))</span>
                <span class="s1">count -= </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(count === </span><span class="s4">0 </span><span class="s1">&amp;&amp; index !== pattern.length - </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">InGroup(pattern) {</span>
        <span class="s3">return </span><span class="s1">pattern.slice(</span><span class="s4">1</span><span class="s1">, pattern.length - </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsPrecedenceOr(pattern) {</span>
        <span class="s1">let count = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(let index = </span><span class="s4">0</span><span class="s1">; index &lt; pattern.length; index++) {</span>
            <span class="s3">if </span><span class="s1">(IsOpenParen(pattern, index))</span>
                <span class="s1">count += </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(IsCloseParen(pattern, index))</span>
                <span class="s1">count -= </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(IsSeparator(pattern, index) &amp;&amp; count === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsPrecedenceAnd(pattern) {</span>
        <span class="s3">for </span><span class="s1">(let index = </span><span class="s4">0</span><span class="s1">; index &lt; pattern.length; index++) {</span>
            <span class="s3">if </span><span class="s1">(IsOpenParen(pattern, index))</span>
                <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Or(pattern) {</span>
        <span class="s1">let [count, start] = [</span><span class="s4">0</span><span class="s1">, </span><span class="s4">0</span><span class="s1">];</span>
        <span class="s1">const expressions = [];</span>
        <span class="s3">for </span><span class="s1">(let index = </span><span class="s4">0</span><span class="s1">; index &lt; pattern.length; index++) {</span>
            <span class="s3">if </span><span class="s1">(IsOpenParen(pattern, index))</span>
                <span class="s1">count += </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(IsCloseParen(pattern, index))</span>
                <span class="s1">count -= </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(IsSeparator(pattern, index) &amp;&amp; count === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">const range = pattern.slice(start, index);</span>
                <span class="s3">if </span><span class="s1">(range.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s1">expressions.push(Parse(range));</span>
                <span class="s1">start = index + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">const range = pattern.slice(start);</span>
        <span class="s3">if </span><span class="s1">(range.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">expressions.push(Parse(range));</span>
        <span class="s3">if </span><span class="s1">(expressions.length === </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">{ type: </span><span class="s0">'const'</span><span class="s1">, const: </span><span class="s0">'' </span><span class="s1">};</span>
        <span class="s3">if </span><span class="s1">(expressions.length === </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">expressions[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s3">return </span><span class="s1">{ type: </span><span class="s0">'or'</span><span class="s1">, expr: expressions };</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">And(pattern) {</span>
        <span class="s3">function </span><span class="s1">Group(value, index) {</span>
            <span class="s3">if </span><span class="s1">(!IsOpenParen(value, index))</span>
                <span class="s3">throw new </span><span class="s1">TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);</span>
            <span class="s1">let count = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(let scan = index; scan &lt; value.length; scan++) {</span>
                <span class="s3">if </span><span class="s1">(IsOpenParen(value, scan))</span>
                    <span class="s1">count += </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(IsCloseParen(value, scan))</span>
                    <span class="s1">count -= </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(count === </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s3">return </span><span class="s1">[index, scan];</span>
            <span class="s1">}</span>
            <span class="s3">throw new </span><span class="s1">TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens </span><span class="s3">in </span><span class="s1">expression`);</span>
        <span class="s1">}</span>
        <span class="s3">function </span><span class="s1">Range(pattern, index) {</span>
            <span class="s3">for </span><span class="s1">(let scan = index; scan &lt; pattern.length; scan++) {</span>
                <span class="s3">if </span><span class="s1">(IsOpenParen(pattern, scan))</span>
                    <span class="s3">return </span><span class="s1">[index, scan];</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">[index, pattern.length];</span>
        <span class="s1">}</span>
        <span class="s1">const expressions = [];</span>
        <span class="s3">for </span><span class="s1">(let index = </span><span class="s4">0</span><span class="s1">; index &lt; pattern.length; index++) {</span>
            <span class="s3">if </span><span class="s1">(IsOpenParen(pattern, index)) {</span>
                <span class="s1">const [start, end] = Group(pattern, index);</span>
                <span class="s1">const range = pattern.slice(start, end + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">expressions.push(Parse(range));</span>
                <span class="s1">index = end;</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s1">const [start, end] = Range(pattern, index);</span>
                <span class="s1">const range = pattern.slice(start, end);</span>
                <span class="s3">if </span><span class="s1">(range.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s1">expressions.push(Parse(range));</span>
                <span class="s1">index = end - </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(expressions.length === </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">{ type: </span><span class="s0">'const'</span><span class="s1">, const: </span><span class="s0">'' </span><span class="s1">};</span>
        <span class="s3">if </span><span class="s1">(expressions.length === </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">expressions[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s3">return </span><span class="s1">{ type: </span><span class="s0">'and'</span><span class="s1">, expr: expressions };</span>
    <span class="s1">}</span>
    <span class="s2">/** Parses a pattern and returns an expression tree */</span>
    <span class="s3">function </span><span class="s1">Parse(pattern) {</span>
        <span class="s3">if </span><span class="s1">(IsGroup(pattern))</span>
            <span class="s3">return </span><span class="s1">Parse(InGroup(pattern));</span>
        <span class="s3">if </span><span class="s1">(IsPrecedenceOr(pattern))</span>
            <span class="s3">return </span><span class="s1">Or(pattern);</span>
        <span class="s3">if </span><span class="s1">(IsPrecedenceAnd(pattern))</span>
            <span class="s3">return </span><span class="s1">And(pattern);</span>
        <span class="s3">return </span><span class="s1">{ type: </span><span class="s0">'const'</span><span class="s1">, const: pattern };</span>
    <span class="s1">}</span>
    <span class="s1">TemplateLiteralParser.Parse = Parse;</span>
    <span class="s2">/** Parses a pattern and strips forward and trailing ^ and $ */</span>
    <span class="s3">function </span><span class="s1">ParseExact(pattern) {</span>
        <span class="s3">return </span><span class="s1">Parse(pattern.slice(</span><span class="s4">1</span><span class="s1">, pattern.length - </span><span class="s4">1</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s1">TemplateLiteralParser.ParseExact = ParseExact;</span>
<span class="s1">})(TemplateLiteralParser = exports.TemplateLiteralParser || (exports.TemplateLiteralParser = {}));</span>
<span class="s2">// --------------------------------------------------------------------------------------</span>
<span class="s2">// TemplateLiteralFinite</span>
<span class="s2">// --------------------------------------------------------------------------------------</span>
<span class="s3">var </span><span class="s1">TemplateLiteralFinite;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TemplateLiteralFinite) {</span>
    <span class="s3">function </span><span class="s1">IsNumber(expression) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(expression.type === </span><span class="s0">'or' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr.length === </span><span class="s4">2 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr[</span><span class="s4">0</span><span class="s1">].type === </span><span class="s0">'const' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr[</span><span class="s4">0</span><span class="s1">].const === </span><span class="s0">'0' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr[</span><span class="s4">1</span><span class="s1">].type === </span><span class="s0">'const' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr[</span><span class="s4">1</span><span class="s1">].const === </span><span class="s0">'[1-9][0-9]*'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsBoolean(expression) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">(expression.type === </span><span class="s0">'or' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr.length === </span><span class="s4">2 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr[</span><span class="s4">0</span><span class="s1">].type === </span><span class="s0">'const' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr[</span><span class="s4">0</span><span class="s1">].const === </span><span class="s0">'true' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr[</span><span class="s4">1</span><span class="s1">].type === </span><span class="s0">'const' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">expression.expr[</span><span class="s4">1</span><span class="s1">].const === </span><span class="s0">'false'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">IsString(expression) {</span>
        <span class="s3">return </span><span class="s1">expression.type === </span><span class="s0">'const' </span><span class="s1">&amp;&amp; expression.const === </span><span class="s0">'.*'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Check(expression) {</span>
        <span class="s3">if </span><span class="s1">(IsBoolean(expression))</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(IsNumber(expression) || IsString(expression))</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(expression.type === </span><span class="s0">'and'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">expression.expr.every((expr) =&gt; Check(expr));</span>
        <span class="s3">if </span><span class="s1">(expression.type === </span><span class="s0">'or'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">expression.expr.every((expr) =&gt; Check(expr));</span>
        <span class="s3">if </span><span class="s1">(expression.type === </span><span class="s0">'const'</span><span class="s1">)</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">throw </span><span class="s1">Error(`TemplateLiteralFinite: Unknown expression type`);</span>
    <span class="s1">}</span>
    <span class="s1">TemplateLiteralFinite.Check = Check;</span>
<span class="s1">})(TemplateLiteralFinite = exports.TemplateLiteralFinite || (exports.TemplateLiteralFinite = {}));</span>
<span class="s2">// --------------------------------------------------------------------------------------</span>
<span class="s2">// TemplateLiteralGenerator</span>
<span class="s2">// --------------------------------------------------------------------------------------</span>
<span class="s3">var </span><span class="s1">TemplateLiteralGenerator;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(TemplateLiteralGenerator) {</span>
    <span class="s3">function</span><span class="s1">* Reduce(buffer) {</span>
        <span class="s3">if </span><span class="s1">(buffer.length === </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">yield* buffer[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s3">for </span><span class="s1">(const left of buffer[</span><span class="s4">0</span><span class="s1">]) {</span>
            <span class="s3">for </span><span class="s1">(const right of Reduce(buffer.slice(</span><span class="s4">1</span><span class="s1">))) {</span>
                <span class="s1">yield `${left}${right}`;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function</span><span class="s1">* And(expression) {</span>
        <span class="s3">return </span><span class="s1">yield* Reduce(expression.expr.map((expr) =&gt; [...Generate(expr)]));</span>
    <span class="s1">}</span>
    <span class="s3">function</span><span class="s1">* Or(expression) {</span>
        <span class="s3">for </span><span class="s1">(const expr of expression.expr)</span>
            <span class="s1">yield* Generate(expr);</span>
    <span class="s1">}</span>
    <span class="s3">function</span><span class="s1">* Const(expression) {</span>
        <span class="s3">return </span><span class="s1">yield expression.const;</span>
    <span class="s1">}</span>
    <span class="s3">function</span><span class="s1">* Generate(expression) {</span>
        <span class="s3">if </span><span class="s1">(expression.type === </span><span class="s0">'and'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">yield* And(expression);</span>
        <span class="s3">if </span><span class="s1">(expression.type === </span><span class="s0">'or'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">yield* Or(expression);</span>
        <span class="s3">if </span><span class="s1">(expression.type === </span><span class="s0">'const'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">yield* Const(expression);</span>
        <span class="s3">throw </span><span class="s1">Error(</span><span class="s0">'TemplateLiteralGenerator: Unknown expression'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">TemplateLiteralGenerator.Generate = Generate;</span>
<span class="s1">})(TemplateLiteralGenerator = exports.TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = {}));</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// TypeOrdinal: Used for auto $id generation</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s1">let TypeOrdinal = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// TypeBuilder</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s1">class TypeBuilder {</span>
    <span class="s2">/** `[Utility]` Creates a schema without `static` and `params` types */</span>
    <span class="s1">Create(schema) {</span>
        <span class="s3">return </span><span class="s1">schema;</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Omits compositing symbols from this schema */</span>
    <span class="s1">Strict(schema) {</span>
        <span class="s3">return </span><span class="s1">JSON.parse(JSON.stringify(schema));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.TypeBuilder = TypeBuilder;</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// StandardTypeBuilder</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s1">class StandardTypeBuilder extends TypeBuilder {</span>
    <span class="s2">// ------------------------------------------------------------------------</span>
    <span class="s2">// Modifiers</span>
    <span class="s2">// ------------------------------------------------------------------------</span>
    <span class="s2">/** `[Modifier]` Creates a Optional property */</span>
    <span class="s1">Optional(schema) {</span>
        <span class="s3">return </span><span class="s1">{ [exports.Modifier]: </span><span class="s0">'Optional'</span><span class="s1">, ...TypeClone.Clone(schema, {}) };</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Modifier]` Creates a ReadonlyOptional property */</span>
    <span class="s1">ReadonlyOptional(schema) {</span>
        <span class="s3">return </span><span class="s1">{ [exports.Modifier]: </span><span class="s0">'ReadonlyOptional'</span><span class="s1">, ...TypeClone.Clone(schema, {}) };</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Modifier]` Creates a Readonly object or property */</span>
    <span class="s1">Readonly(schema) {</span>
        <span class="s3">return </span><span class="s1">{ [exports.Modifier]: </span><span class="s0">'Readonly'</span><span class="s1">, ...schema };</span>
    <span class="s1">}</span>
    <span class="s2">// ------------------------------------------------------------------------</span>
    <span class="s2">// Types</span>
    <span class="s2">// ------------------------------------------------------------------------</span>
    <span class="s2">/** `[Standard]` Creates an Any type */</span>
    <span class="s1">Any(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Any' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates an Array type */</span>
    <span class="s1">Array(items, options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Array'</span><span class="s1">, type: </span><span class="s0">'array'</span><span class="s1">, items: TypeClone.Clone(items, {}) });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Boolean type */</span>
    <span class="s1">Boolean(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Boolean'</span><span class="s1">, type: </span><span class="s0">'boolean' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Composite object type. */</span>
    <span class="s1">Composite(objects, options) {</span>
        <span class="s1">const isOptionalAll = (objects, key) =&gt; objects.every((object) =&gt; !(key </span><span class="s3">in </span><span class="s1">object.properties) || IsOptional(object.properties[key]));</span>
        <span class="s1">const IsOptional = (schema) =&gt; TypeGuard.TOptional(schema) || TypeGuard.TReadonlyOptional(schema);</span>
        <span class="s1">const [required, optional] = [</span><span class="s3">new </span><span class="s1">Set(), </span><span class="s3">new </span><span class="s1">Set()];</span>
        <span class="s3">for </span><span class="s1">(const object of objects) {</span>
            <span class="s3">for </span><span class="s1">(const key of globalThis.Object.getOwnPropertyNames(object.properties)) {</span>
                <span class="s3">if </span><span class="s1">(isOptionalAll(objects, key))</span>
                    <span class="s1">optional.add(key);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(const object of objects) {</span>
            <span class="s3">for </span><span class="s1">(const key of globalThis.Object.getOwnPropertyNames(object.properties)) {</span>
                <span class="s3">if </span><span class="s1">(!optional.has(key))</span>
                    <span class="s1">required.add(key);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">const properties = {};</span>
        <span class="s3">for </span><span class="s1">(const object of objects) {</span>
            <span class="s3">for </span><span class="s1">(const [key, schema] of Object.entries(object.properties)) {</span>
                <span class="s1">const property = TypeClone.Clone(schema, {});</span>
                <span class="s3">if </span><span class="s1">(!optional.has(key))</span>
                    <span class="s3">delete </span><span class="s1">property[exports.Modifier];</span>
                <span class="s3">if </span><span class="s1">(key </span><span class="s3">in </span><span class="s1">properties) {</span>
                    <span class="s1">const left = TypeExtends.Extends(properties[key], property) !== TypeExtendsResult.False;</span>
                    <span class="s1">const right = TypeExtends.Extends(property, properties[key]) !== TypeExtendsResult.False;</span>
                    <span class="s3">if </span><span class="s1">(!left &amp;&amp; !right)</span>
                        <span class="s1">properties[key] = exports.Type.Never();</span>
                    <span class="s3">if </span><span class="s1">(!left &amp;&amp; right)</span>
                        <span class="s1">properties[key] = property;</span>
                <span class="s1">}</span>
                <span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">properties[key] = property;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(required.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Object'</span><span class="s1">, [exports.Hint]: </span><span class="s0">'Composite'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, properties, required: [...required] });</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Object'</span><span class="s1">, [exports.Hint]: </span><span class="s0">'Composite'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, properties });</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Enum type */</span>
    <span class="s1">Enum(item, options = {}) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s1">const values = globalThis.Object.keys(item).filter((key) =&gt; isNaN(key)).map((key) =&gt; item[key]);</span>
        <span class="s1">const anyOf = values.map((value) =&gt; (</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s0">'string' </span><span class="s1">? { [exports.Kind]: </span><span class="s0">'Literal'</span><span class="s1">, type: </span><span class="s0">'string'</span><span class="s1">, const: value } : { [exports.Kind]: </span><span class="s0">'Literal'</span><span class="s1">, type: </span><span class="s0">'number'</span><span class="s1">, const: value }));</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Union'</span><span class="s1">, anyOf });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */</span>
    <span class="s1">Extends(left, right, trueType, falseType, options = {}) {</span>
        <span class="s3">switch </span><span class="s1">(TypeExtends.Extends(left, right)) {</span>
            <span class="s3">case </span><span class="s1">TypeExtendsResult.Union:</span>
                <span class="s3">return this</span><span class="s1">.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);</span>
            <span class="s3">case </span><span class="s1">TypeExtendsResult.True:</span>
                <span class="s3">return </span><span class="s1">TypeClone.Clone(trueType, options);</span>
            <span class="s3">case </span><span class="s1">TypeExtendsResult.False:</span>
                <span class="s3">return </span><span class="s1">TypeClone.Clone(falseType, options);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Excludes from the left type any type that is not assignable to the right */</span>
    <span class="s1">Exclude(left, right, options = {}) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(left))</span>
            <span class="s3">return this</span><span class="s1">.Exclude(TemplateLiteralResolver.Resolve(left), right, options);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(right))</span>
            <span class="s3">return this</span><span class="s1">.Exclude(left, TemplateLiteralResolver.Resolve(right), options);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(left)) {</span>
            <span class="s1">const narrowed = left.anyOf.filter((inner) =&gt; TypeExtends.Extends(inner, right) === TypeExtendsResult.False);</span>
            <span class="s3">return </span><span class="s1">(narrowed.length === </span><span class="s4">1 </span><span class="s1">? TypeClone.Clone(narrowed[</span><span class="s4">0</span><span class="s1">], options) : </span><span class="s3">this</span><span class="s1">.Union(narrowed, options));</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">(TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? </span><span class="s3">this</span><span class="s1">.Never(options) : TypeClone.Clone(left, options));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Extracts from the left type any type that is assignable to the right */</span>
    <span class="s1">Extract(left, right, options = {}) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(left))</span>
            <span class="s3">return this</span><span class="s1">.Extract(TemplateLiteralResolver.Resolve(left), right, options);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(right))</span>
            <span class="s3">return this</span><span class="s1">.Extract(left, TemplateLiteralResolver.Resolve(right), options);</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TUnion(left)) {</span>
            <span class="s1">const narrowed = left.anyOf.filter((inner) =&gt; TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);</span>
            <span class="s3">return </span><span class="s1">(narrowed.length === </span><span class="s4">1 </span><span class="s1">? TypeClone.Clone(narrowed[</span><span class="s4">0</span><span class="s1">], options) : </span><span class="s3">this</span><span class="s1">.Union(narrowed, options));</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">(TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : </span><span class="s3">this</span><span class="s1">.Never(options));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates an Integer type */</span>
    <span class="s1">Integer(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Integer'</span><span class="s1">, type: </span><span class="s0">'integer' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">Intersect(allOf, options = {}) {</span>
        <span class="s3">if </span><span class="s1">(allOf.length === </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">exports.Type.Never();</span>
        <span class="s3">if </span><span class="s1">(allOf.length === </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">TypeClone.Clone(allOf[</span><span class="s4">0</span><span class="s1">], options);</span>
        <span class="s1">const objects = allOf.every((schema) =&gt; TypeGuard.TObject(schema));</span>
        <span class="s1">const cloned = allOf.map((schema) =&gt; TypeClone.Clone(schema, {}));</span>
        <span class="s1">const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};</span>
        <span class="s3">if </span><span class="s1">(options.unevaluatedProperties === </span><span class="s3">false </span><span class="s1">|| TypeGuard.TSchema(options.unevaluatedProperties) || objects) {</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: </span><span class="s0">'Intersect'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, allOf: cloned });</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: </span><span class="s0">'Intersect'</span><span class="s1">, allOf: cloned });</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a KeyOf type */</span>
    <span class="s1">KeyOf(schema, options = {}) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TRecord(schema)) {</span>
            <span class="s1">const pattern = Object.getOwnPropertyNames(schema.patternProperties)[</span><span class="s4">0</span><span class="s1">];</span>
            <span class="s3">if </span><span class="s1">(pattern === exports.PatternNumberExact)</span>
                <span class="s3">return this</span><span class="s1">.Number(options);</span>
            <span class="s3">if </span><span class="s1">(pattern === exports.PatternStringExact)</span>
                <span class="s3">return this</span><span class="s1">.String(options);</span>
            <span class="s3">throw </span><span class="s1">Error(</span><span class="s0">'StandardTypeBuilder: Unable to resolve key type from Record key pattern'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s1">const resolved = KeyResolver.Resolve(schema);</span>
            <span class="s3">if </span><span class="s1">(resolved.length === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s3">return this</span><span class="s1">.Never(options);</span>
            <span class="s1">const literals = resolved.map((key) =&gt; </span><span class="s3">this</span><span class="s1">.Literal(key));</span>
            <span class="s3">return this</span><span class="s1">.Union(literals, options);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Literal type */</span>
    <span class="s1">Literal(value, options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Literal'</span><span class="s1">, const: value, type: </span><span class="s3">typeof </span><span class="s1">value });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Never type */</span>
    <span class="s1">Never(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Never'</span><span class="s1">, not: {} });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Not type. The first argument is the disallowed type, the second is the allowed. */</span>
    <span class="s1">Not(not, schema, options) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Not'</span><span class="s1">, allOf: [{ not: TypeClone.Clone(not, {}) }, TypeClone.Clone(schema, {})] });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Null type */</span>
    <span class="s1">Null(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Null'</span><span class="s1">, type: </span><span class="s0">'null' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Number type */</span>
    <span class="s1">Number(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Number'</span><span class="s1">, type: </span><span class="s0">'number' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates an Object type */</span>
    <span class="s1">Object(properties, options = {}) {</span>
        <span class="s1">const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);</span>
        <span class="s1">const optionalKeys = propertyKeys.filter((key) =&gt; TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));</span>
        <span class="s1">const requiredKeys = propertyKeys.filter((name) =&gt; !optionalKeys.includes(name));</span>
        <span class="s1">const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};</span>
        <span class="s1">const clonedProperties = propertyKeys.reduce((acc, key) =&gt; ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});</span>
        <span class="s3">if </span><span class="s1">(requiredKeys.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: </span><span class="s0">'Object'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, properties: clonedProperties, required: requiredKeys });</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: </span><span class="s0">'Object'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, properties: clonedProperties });</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">Omit(schema, unresolved, options = {}) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s1">const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map((schema) =&gt; schema.const) :</span>
            <span class="s1">TypeGuard.TLiteral(unresolved) ? [unresolved.const] :</span>
                <span class="s1">TypeGuard.TNever(unresolved) ? [] :</span>
                    <span class="s1">unresolved;</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) =&gt; {</span>
            <span class="s3">if </span><span class="s1">(schema.required) {</span>
                <span class="s1">schema.required = schema.required.filter((key) =&gt; !keys.includes(key));</span>
                <span class="s3">if </span><span class="s1">(schema.required.length === </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s3">delete </span><span class="s1">schema.required;</span>
            <span class="s1">}</span>
            <span class="s3">for </span><span class="s1">(const key of globalThis.Object.keys(schema.properties)) {</span>
                <span class="s3">if </span><span class="s1">(keys.includes(key))</span>
                    <span class="s3">delete </span><span class="s1">schema.properties[key];</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">.Create(schema);</span>
        <span class="s1">}, options);</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a mapped type where all properties are Optional */</span>
    <span class="s1">Partial(schema, options = {}) {</span>
        <span class="s3">function </span><span class="s1">Apply(schema) {</span>
            <span class="s2">// prettier-ignore</span>
            <span class="s3">switch </span><span class="s1">(schema[exports.Modifier]) {</span>
                <span class="s3">case </span><span class="s0">'ReadonlyOptional'</span><span class="s1">:</span>
                    <span class="s1">schema[exports.Modifier] = </span><span class="s0">'ReadonlyOptional'</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s0">'Readonly'</span><span class="s1">:</span>
                    <span class="s1">schema[exports.Modifier] = </span><span class="s0">'ReadonlyOptional'</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s0">'Optional'</span><span class="s1">:</span>
                    <span class="s1">schema[exports.Modifier] = </span><span class="s0">'Optional'</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">default</span><span class="s1">:</span>
                    <span class="s1">schema[exports.Modifier] = </span><span class="s0">'Optional'</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) =&gt; {</span>
            <span class="s3">delete </span><span class="s1">schema.required;</span>
            <span class="s1">globalThis.Object.keys(schema.properties).forEach(key =&gt; Apply(schema.properties[key]));</span>
            <span class="s3">return </span><span class="s1">schema;</span>
        <span class="s1">}, options);</span>
    <span class="s1">}</span>
    <span class="s1">Pick(schema, unresolved, options = {}) {</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s1">const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map((schema) =&gt; schema.const) :</span>
            <span class="s1">TypeGuard.TLiteral(unresolved) ? [unresolved.const] :</span>
                <span class="s1">TypeGuard.TNever(unresolved) ? [] :</span>
                    <span class="s1">unresolved;</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) =&gt; {</span>
            <span class="s3">if </span><span class="s1">(schema.required) {</span>
                <span class="s1">schema.required = schema.required.filter((key) =&gt; keys.includes(key));</span>
                <span class="s3">if </span><span class="s1">(schema.required.length === </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s3">delete </span><span class="s1">schema.required;</span>
            <span class="s1">}</span>
            <span class="s3">for </span><span class="s1">(const key of globalThis.Object.keys(schema.properties)) {</span>
                <span class="s3">if </span><span class="s1">(!keys.includes(key))</span>
                    <span class="s3">delete </span><span class="s1">schema.properties[key];</span>
            <span class="s1">}</span>
            <span class="s3">return this</span><span class="s1">.Create(schema);</span>
        <span class="s1">}, options);</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Record type */</span>
    <span class="s1">Record(key, schema, options = {}) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(key)) {</span>
            <span class="s1">const expression = TemplateLiteralParser.ParseExact(key.pattern);</span>
            <span class="s2">// prettier-ignore</span>
            <span class="s3">return </span><span class="s1">TemplateLiteralFinite.Check(expression)</span>
                <span class="s1">? (</span><span class="s3">this</span><span class="s1">.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) =&gt; ({ ...acc, [key]: TypeClone.Clone(schema, {}) }), {}), options))</span>
                <span class="s1">: </span><span class="s3">this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Record'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: </span><span class="s3">false </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TUnionLiteral(key)) {</span>
            <span class="s3">if </span><span class="s1">(key.anyOf.every((schema) =&gt; TypeGuard.TLiteral(schema) &amp;&amp; (</span><span class="s3">typeof </span><span class="s1">schema.const === </span><span class="s0">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">schema.const === </span><span class="s0">'number'</span><span class="s1">))) {</span>
                <span class="s1">const properties = key.anyOf.reduce((acc, literal) =&gt; ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});</span>
                <span class="s3">return this</span><span class="s1">.Object(properties, { ...options, [exports.Hint]: </span><span class="s0">'Record' </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">else</span>
                <span class="s3">throw </span><span class="s1">Error(</span><span class="s0">'TypeBuilder: Record key can only be derived from union literal of number or string'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TLiteral(key)) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">key.const === </span><span class="s0">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">key.const === </span><span class="s0">'number'</span><span class="s1">) {</span>
                <span class="s3">return this</span><span class="s1">.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);</span>
            <span class="s1">}</span>
            <span class="s3">else</span>
                <span class="s3">throw </span><span class="s1">Error(</span><span class="s0">'TypeBuilder: Record key can only be derived from literals of number or string'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {</span>
            <span class="s1">const pattern = exports.PatternNumberExact;</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Record'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, patternProperties: { [pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: </span><span class="s3">false </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(TypeGuard.TString(key)) {</span>
            <span class="s1">const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Record'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, patternProperties: { [pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: </span><span class="s3">false </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error(`StandardTypeBuilder: Invalid Record Key`);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Recursive type */</span>
    <span class="s1">Recursive(callback, options = {}) {</span>
        <span class="s3">if </span><span class="s1">(options.$id === undefined)</span>
            <span class="s1">options.$id = `T${TypeOrdinal++}`;</span>
        <span class="s1">const thisType = callback({ [exports.Kind]: </span><span class="s0">'This'</span><span class="s1">, $ref: `${options.$id}` });</span>
        <span class="s1">thisType.$id = options.$id;</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Hint]: </span><span class="s0">'Recursive'</span><span class="s1">, ...thisType });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Ref type. The referenced type must contain a $id */</span>
    <span class="s1">Ref(schema, options = {}) {</span>
        <span class="s3">if </span><span class="s1">(schema.$id === undefined)</span>
            <span class="s3">throw </span><span class="s1">Error(</span><span class="s0">'StandardTypeBuilder.Ref: Target type must specify an $id'</span><span class="s1">);</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Ref'</span><span class="s1">, $ref: schema.$id });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a mapped type where all properties are Required */</span>
    <span class="s1">Required(schema, options = {}) {</span>
        <span class="s3">function </span><span class="s1">Apply(schema) {</span>
            <span class="s2">// prettier-ignore</span>
            <span class="s3">switch </span><span class="s1">(schema[exports.Modifier]) {</span>
                <span class="s3">case </span><span class="s0">'ReadonlyOptional'</span><span class="s1">:</span>
                    <span class="s1">schema[exports.Modifier] = </span><span class="s0">'Readonly'</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s0">'Readonly'</span><span class="s1">:</span>
                    <span class="s1">schema[exports.Modifier] = </span><span class="s0">'Readonly'</span><span class="s1">;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s0">'Optional'</span><span class="s1">:</span>
                    <span class="s3">delete </span><span class="s1">schema[exports.Modifier];</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">default</span><span class="s1">:</span>
                    <span class="s3">delete </span><span class="s1">schema[exports.Modifier];</span>
                    <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s3">return </span><span class="s1">ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) =&gt; {</span>
            <span class="s1">schema.required = globalThis.Object.keys(schema.properties);</span>
            <span class="s1">globalThis.Object.keys(schema.properties).forEach(key =&gt; Apply(schema.properties[key]));</span>
            <span class="s3">return </span><span class="s1">schema;</span>
        <span class="s1">}, options);</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a String type */</span>
    <span class="s1">String(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'String'</span><span class="s1">, type: </span><span class="s0">'string' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a template literal type */</span>
    <span class="s1">TemplateLiteral(kinds, options = {}) {</span>
        <span class="s1">const pattern = TemplateLiteralPattern.Create(kinds);</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'TemplateLiteral'</span><span class="s1">, type: </span><span class="s0">'string'</span><span class="s1">, pattern });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Tuple type */</span>
    <span class="s1">Tuple(items, options = {}) {</span>
        <span class="s1">const [additionalItems, minItems, maxItems] = [</span><span class="s3">false</span><span class="s1">, items.length, items.length];</span>
        <span class="s1">const clonedItems = items.map((item) =&gt; TypeClone.Clone(item, {}));</span>
        <span class="s2">// prettier-ignore</span>
        <span class="s1">const schema = (items.length &gt; </span><span class="s4">0 </span><span class="s1">?</span>
            <span class="s1">{ ...options, [exports.Kind]: </span><span class="s0">'Tuple'</span><span class="s1">, type: </span><span class="s0">'array'</span><span class="s1">, items: clonedItems, additionalItems, minItems, maxItems } :</span>
            <span class="s1">{ ...options, [exports.Kind]: </span><span class="s0">'Tuple'</span><span class="s1">, type: </span><span class="s0">'array'</span><span class="s1">, minItems, maxItems });</span>
        <span class="s3">return this</span><span class="s1">.Create(schema);</span>
    <span class="s1">}</span>
    <span class="s1">Union(union, options = {}) {</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTemplateLiteral(union)) {</span>
            <span class="s3">return </span><span class="s1">TemplateLiteralResolver.Resolve(union);</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s1">const anyOf = union;</span>
            <span class="s3">if </span><span class="s1">(anyOf.length === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s3">return this</span><span class="s1">.Never(options);</span>
            <span class="s3">if </span><span class="s1">(anyOf.length === </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s3">return this</span><span class="s1">.Create(TypeClone.Clone(anyOf[</span><span class="s4">0</span><span class="s1">], options));</span>
            <span class="s1">const clonedAnyOf = anyOf.map((schema) =&gt; TypeClone.Clone(schema, {}));</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Union'</span><span class="s1">, anyOf: clonedAnyOf });</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates an Unknown type */</span>
    <span class="s1">Unknown(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Unknown' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Standard]` Creates a Unsafe type that infers for the generic argument */</span>
    <span class="s1">Unsafe(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: options[exports.Kind] || </span><span class="s0">'Unsafe' </span><span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.StandardTypeBuilder = StandardTypeBuilder;</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// ExtendedTypeBuilder</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s1">class ExtendedTypeBuilder extends StandardTypeBuilder {</span>
    <span class="s2">/** `[Extended]` Creates a BigInt type */</span>
    <span class="s1">BigInt(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'BigInt'</span><span class="s1">, type: </span><span class="s0">'null'</span><span class="s1">, typeOf: </span><span class="s0">'BigInt' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */</span>
    <span class="s1">ConstructorParameters(schema, options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Tuple([...schema.parameters], { ...options });</span>
    <span class="s1">}</span>
    <span class="s1">Constructor(parameters, returns, options = {}) {</span>
        <span class="s1">const clonedReturns = TypeClone.Clone(returns, {});</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTuple(parameters)) {</span>
            <span class="s1">const clonedParameters = parameters.items === undefined ? [] : parameters.items.map((parameter) =&gt; TypeClone.Clone(parameter, {}));</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Constructor'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, instanceOf: </span><span class="s0">'Constructor'</span><span class="s1">, parameters: clonedParameters, returns: clonedReturns });</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(globalThis.Array.isArray(parameters)) {</span>
            <span class="s1">const clonedParameters = parameters.map((parameter) =&gt; TypeClone.Clone(parameter, {}));</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Constructor'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, instanceOf: </span><span class="s0">'Constructor'</span><span class="s1">, parameters: clonedParameters, returns: clonedReturns });</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'ExtendedTypeBuilder.Constructor: Invalid parameters'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Creates a Date type */</span>
    <span class="s1">Date(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Date'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, instanceOf: </span><span class="s0">'Date' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">Function(parameters, returns, options = {}) {</span>
        <span class="s1">const clonedReturns = TypeClone.Clone(returns, {});</span>
        <span class="s3">if </span><span class="s1">(TypeGuard.TTuple(parameters)) {</span>
            <span class="s1">const clonedParameters = parameters.items === undefined ? [] : parameters.items.map((parameter) =&gt; TypeClone.Clone(parameter, {}));</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Function'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, instanceOf: </span><span class="s0">'Function'</span><span class="s1">, parameters: clonedParameters, returns: clonedReturns });</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(globalThis.Array.isArray(parameters)) {</span>
            <span class="s1">const clonedParameters = parameters.map((parameter) =&gt; TypeClone.Clone(parameter, {}));</span>
            <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Function'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, instanceOf: </span><span class="s0">'Function'</span><span class="s1">, parameters: clonedParameters, returns: clonedReturns });</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'ExtendedTypeBuilder.Function: Invalid parameters'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Extracts the InstanceType from the given Constructor */</span>
    <span class="s1">InstanceType(schema, options = {}) {</span>
        <span class="s3">return </span><span class="s1">TypeClone.Clone(schema.returns, options);</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Extracts the Parameters from the given Function type */</span>
    <span class="s1">Parameters(schema, options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Tuple(schema.parameters, { ...options });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Creates a Promise type */</span>
    <span class="s1">Promise(item, options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Promise'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, instanceOf: </span><span class="s0">'Promise'</span><span class="s1">, item: TypeClone.Clone(item, {}) });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Creates a regular expression type */</span>
    <span class="s1">RegEx(regex, options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'String'</span><span class="s1">, type: </span><span class="s0">'string'</span><span class="s1">, pattern: regex.source });</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Extracts the ReturnType from the given Function */</span>
    <span class="s1">ReturnType(schema, options = {}) {</span>
        <span class="s3">return </span><span class="s1">TypeClone.Clone(schema.returns, options);</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Creates a Symbol type */</span>
    <span class="s1">Symbol(options) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Symbol'</span><span class="s1">, type: </span><span class="s0">'null'</span><span class="s1">, typeOf: </span><span class="s0">'Symbol' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Creates a Undefined type */</span>
    <span class="s1">Undefined(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Undefined'</span><span class="s1">, type: </span><span class="s0">'null'</span><span class="s1">, typeOf: </span><span class="s0">'Undefined' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Creates a Uint8Array type */</span>
    <span class="s1">Uint8Array(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Uint8Array'</span><span class="s1">, type: </span><span class="s0">'object'</span><span class="s1">, instanceOf: </span><span class="s0">'Uint8Array' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">/** `[Extended]` Creates a Void type */</span>
    <span class="s1">Void(options = {}) {</span>
        <span class="s3">return this</span><span class="s1">.Create({ ...options, [exports.Kind]: </span><span class="s0">'Void'</span><span class="s1">, type: </span><span class="s0">'null'</span><span class="s1">, typeOf: </span><span class="s0">'Void' </span><span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.ExtendedTypeBuilder = ExtendedTypeBuilder;</span>
<span class="s2">/** JSON Schema TypeBuilder with Static Resolution for TypeScript */</span>
<span class="s1">exports.StandardType = </span><span class="s3">new </span><span class="s1">StandardTypeBuilder();</span>
<span class="s2">/** JSON Schema TypeBuilder with Static Resolution for TypeScript */</span>
<span class="s1">exports.Type = </span><span class="s3">new </span><span class="s1">ExtendedTypeBuilder();</span>
</pre>
</body>
</html>
<html>
<head>
<title>YGNode.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
YGNode.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#include </span><span class="s3">&quot;YGNode.h&quot;</span>
<span class="s2">#include </span><span class="s3">&lt;algorithm&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;iostream&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;CompactValue.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;Utils.h&quot;</span>

<span class="s4">using namespace </span><span class="s1">facebook</span><span class="s4">;</span>
<span class="s4">using </span><span class="s1">facebook::yoga::detail::CompactValue</span><span class="s4">;</span>

<span class="s1">YGNode::YGNode(YGNode&amp;&amp; node) {</span>
  <span class="s1">context_ = node.context_</span><span class="s4">;</span>
  <span class="s1">flags = node.flags</span><span class="s4">;</span>
  <span class="s1">measure_ = node.measure_</span><span class="s4">;</span>
  <span class="s1">baseline_ = node.baseline_</span><span class="s4">;</span>
  <span class="s1">print_ = node.print_</span><span class="s4">;</span>
  <span class="s1">dirtied_ = node.dirtied_</span><span class="s4">;</span>
  <span class="s1">style_ = node.style_</span><span class="s4">;</span>
  <span class="s1">layout_ = node.layout_</span><span class="s4">;</span>
  <span class="s1">lineIndex_ = node.lineIndex_</span><span class="s4">;</span>
  <span class="s1">owner_ = node.owner_</span><span class="s4">;</span>
  <span class="s1">children_ = std::move(node.children_)</span><span class="s4">;</span>
  <span class="s1">config_ = node.config_</span><span class="s4">;</span>
  <span class="s1">resolvedDimensions_ = node.resolvedDimensions_</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">c : children_) {</span>
    <span class="s1">c-&gt;setOwner(</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YGNode::YGNode(</span><span class="s4">const </span><span class="s1">YGNode&amp; node</span><span class="s4">, </span><span class="s1">YGConfigRef config) : YGNode{node} {</span>
  <span class="s1">config_ = config</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(config-&gt;useWebDefaults) {</span>
    <span class="s1">useWebDefaults()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::print(</span><span class="s4">void</span><span class="s1">* printContext) {</span>
  <span class="s4">if </span><span class="s1">(print_.noContext != </span><span class="s4">nullptr</span><span class="s1">) {</span>
    <span class="s4">if </span><span class="s1">(facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">printUsesContext_)) {</span>
      <span class="s1">print_.withContext(</span><span class="s4">this, </span><span class="s1">printContext)</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">print_.noContext(</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">CompactValue YGNode::computeEdgeValueForRow(</span>
    <span class="s4">const </span><span class="s1">YGStyle::Edges&amp; edges</span><span class="s4">,</span>
    <span class="s1">YGEdge rowEdge</span><span class="s4">,</span>
    <span class="s1">YGEdge edge</span><span class="s4">,</span>
    <span class="s1">CompactValue defaultValue) {</span>
  <span class="s4">if </span><span class="s1">(!edges[rowEdge].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">edges[rowEdge]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!edges[edge].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">edges[edge]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!edges[YGEdgeHorizontal].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">edges[YGEdgeHorizontal]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!edges[YGEdgeAll].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">edges[YGEdgeAll]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">defaultValue</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">CompactValue YGNode::computeEdgeValueForColumn(</span>
    <span class="s4">const </span><span class="s1">YGStyle::Edges&amp; edges</span><span class="s4">,</span>
    <span class="s1">YGEdge edge</span><span class="s4">,</span>
    <span class="s1">CompactValue defaultValue) {</span>
  <span class="s4">if </span><span class="s1">(!edges[edge].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">edges[edge]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!edges[YGEdgeVertical].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">edges[YGEdgeVertical]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!edges[YGEdgeAll].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">edges[YGEdgeAll]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">defaultValue</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">CompactValue YGNode::computeRowGap(</span>
    <span class="s4">const </span><span class="s1">YGStyle::Gutters&amp; gutters</span><span class="s4">,</span>
    <span class="s1">CompactValue defaultValue) {</span>
  <span class="s4">if </span><span class="s1">(!gutters[YGGutterRow].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">gutters[YGGutterRow]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!gutters[YGGutterAll].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">gutters[YGGutterAll]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">defaultValue</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">CompactValue YGNode::computeColumnGap(</span>
    <span class="s4">const </span><span class="s1">YGStyle::Gutters&amp; gutters</span><span class="s4">,</span>
    <span class="s1">CompactValue defaultValue) {</span>
  <span class="s4">if </span><span class="s1">(!gutters[YGGutterColumn].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">gutters[YGGutterColumn]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!gutters[YGGutterAll].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">gutters[YGGutterAll]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">defaultValue</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getLeadingPosition(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">axisSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">leadingPosition = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.position()</span><span class="s4">,</span>
            <span class="s1">YGEdgeStart</span><span class="s4">,</span>
            <span class="s1">leading[axis]</span><span class="s4">,</span>
            <span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.position()</span><span class="s4">, </span><span class="s1">leading[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YGResolveValue(leadingPosition</span><span class="s4">, </span><span class="s1">axisSize)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getTrailingPosition(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">axisSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">trailingPosition = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.position()</span><span class="s4">,</span>
            <span class="s1">YGEdgeEnd</span><span class="s4">,</span>
            <span class="s1">trailing[axis]</span><span class="s4">,</span>
            <span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.position()</span><span class="s4">, </span><span class="s1">trailing[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YGResolveValue(trailingPosition</span><span class="s4">, </span><span class="s1">axisSize)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">YGNode::isLeadingPositionDefined(</span><span class="s4">const </span><span class="s1">YGFlexDirection axis) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">leadingPosition = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.position()</span><span class="s4">,</span>
            <span class="s1">YGEdgeStart</span><span class="s4">,</span>
            <span class="s1">leading[axis]</span><span class="s4">,</span>
            <span class="s1">CompactValue::ofUndefined())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.position()</span><span class="s4">, </span><span class="s1">leading[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofUndefined())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">!leadingPosition.isUndefined()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">YGNode::isTrailingPosDefined(</span><span class="s4">const </span><span class="s1">YGFlexDirection axis) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">trailingPosition = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.position()</span><span class="s4">,</span>
            <span class="s1">YGEdgeEnd</span><span class="s4">,</span>
            <span class="s1">trailing[axis]</span><span class="s4">,</span>
            <span class="s1">CompactValue::ofUndefined())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.position()</span><span class="s4">, </span><span class="s1">trailing[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofUndefined())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">!trailingPosition.isUndefined()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getLeadingMargin(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">widthSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">leadingMargin = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.margin()</span><span class="s4">, </span><span class="s1">YGEdgeStart</span><span class="s4">, </span><span class="s1">leading[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.margin()</span><span class="s4">, </span><span class="s1">leading[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YGResolveValueMargin(leadingMargin</span><span class="s4">, </span><span class="s1">widthSize)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getTrailingMargin(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">widthSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">trailingMargin = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.margin()</span><span class="s4">, </span><span class="s1">YGEdgeEnd</span><span class="s4">, </span><span class="s1">trailing[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.margin()</span><span class="s4">, </span><span class="s1">trailing[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YGResolveValueMargin(trailingMargin</span><span class="s4">, </span><span class="s1">widthSize)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getMarginForAxis(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">widthSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">return </span><span class="s1">getLeadingMargin(axis</span><span class="s4">, </span><span class="s1">widthSize) + getTrailingMargin(axis</span><span class="s4">, </span><span class="s1">widthSize)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getGapForAxis(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">widthSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">gap = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeColumnGap(style_.gap()</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeRowGap(style_.gap()</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YGResolveValue(gap</span><span class="s4">, </span><span class="s1">widthSize)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGSize YGNode::measure(</span>
    <span class="s4">float </span><span class="s1">width</span><span class="s4">,</span>
    <span class="s1">YGMeasureMode widthMode</span><span class="s4">,</span>
    <span class="s4">float </span><span class="s1">height</span><span class="s4">,</span>
    <span class="s1">YGMeasureMode heightMode</span><span class="s4">,</span>
    <span class="s4">void</span><span class="s1">* layoutContext) {</span>
  <span class="s4">return </span><span class="s1">facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">measureUsesContext_)</span>
      <span class="s1">? measure_.withContext(</span>
            <span class="s4">this, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">widthMode</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">heightMode</span><span class="s4">, </span><span class="s1">layoutContext)</span>
      <span class="s1">: measure_.noContext(</span><span class="s4">this, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">widthMode</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">heightMode)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">float </span><span class="s1">YGNode::baseline(</span><span class="s4">float </span><span class="s1">width</span><span class="s4">, float </span><span class="s1">height</span><span class="s4">, void</span><span class="s1">* layoutContext) {</span>
  <span class="s4">return </span><span class="s1">facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">baselineUsesContext_)</span>
      <span class="s1">? baseline_.withContext(</span><span class="s4">this, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">layoutContext)</span>
      <span class="s1">: baseline_.noContext(</span><span class="s4">this, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">// Setters</span>

<span class="s4">void </span><span class="s1">YGNode::setMeasureFunc(</span><span class="s4">decltype</span><span class="s1">(YGNode::measure_) measureFunc) {</span>
  <span class="s4">if </span><span class="s1">(measureFunc.noContext == </span><span class="s4">nullptr</span><span class="s1">) {</span>
    <span class="s0">// TODO: t18095186 Move nodeType to opt-in function and mark appropriate</span>
    <span class="s0">// places in Litho</span>
    <span class="s1">setNodeType(YGNodeTypeDefault)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">YGAssertWithNode(</span>
        <span class="s4">this,</span>
        <span class="s1">children_.size() == </span><span class="s5">0</span><span class="s4">,</span>
        <span class="s3">&quot;Cannot set measure function: Nodes with measure functions cannot have &quot;</span>
        <span class="s3">&quot;children.&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s0">// TODO: t18095186 Move nodeType to opt-in function and mark appropriate</span>
    <span class="s0">// places in Litho</span>
    <span class="s1">setNodeType(YGNodeTypeText)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">measure_ = measureFunc</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setMeasureFunc(YGMeasureFunc measureFunc) {</span>
  <span class="s1">facebook::yoga::detail::setBooleanData(flags</span><span class="s4">, </span><span class="s1">measureUsesContext_</span><span class="s4">, false</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">decltype</span><span class="s1">(YGNode::measure_) m</span><span class="s4">;</span>
  <span class="s1">m.noContext = measureFunc</span><span class="s4">;</span>
  <span class="s1">setMeasureFunc(m)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s4">void </span><span class="s1">YGNode::setMeasureFunc(MeasureWithContextFn measureFunc) {</span>
  <span class="s1">facebook::yoga::detail::setBooleanData(flags</span><span class="s4">, </span><span class="s1">measureUsesContext_</span><span class="s4">, true</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">decltype</span><span class="s1">(YGNode::measure_) m</span><span class="s4">;</span>
  <span class="s1">m.withContext = measureFunc</span><span class="s4">;</span>
  <span class="s1">setMeasureFunc(m)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::replaceChild(YGNodeRef child</span><span class="s4">, </span><span class="s1">uint32_t index) {</span>
  <span class="s1">children_[index] = child</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::replaceChild(YGNodeRef oldChild</span><span class="s4">, </span><span class="s1">YGNodeRef newChild) {</span>
  <span class="s1">std::replace(children_.begin()</span><span class="s4">, </span><span class="s1">children_.end()</span><span class="s4">, </span><span class="s1">oldChild</span><span class="s4">, </span><span class="s1">newChild)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::insertChild(YGNodeRef child</span><span class="s4">, </span><span class="s1">uint32_t index) {</span>
  <span class="s1">children_.insert(children_.begin() + index</span><span class="s4">, </span><span class="s1">child)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setDirty(</span><span class="s4">bool </span><span class="s1">isDirty) {</span>
  <span class="s4">if </span><span class="s1">(isDirty == facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">isDirty_)) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">facebook::yoga::detail::setBooleanData(flags</span><span class="s4">, </span><span class="s1">isDirty_</span><span class="s4">, </span><span class="s1">isDirty)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(isDirty &amp;&amp; dirtied_) {</span>
    <span class="s1">dirtied_(</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">YGNode::removeChild(YGNodeRef child) {</span>
  <span class="s1">std::vector&lt;YGNodeRef&gt;::iterator p =</span>
      <span class="s1">std::find(children_.begin()</span><span class="s4">, </span><span class="s1">children_.end()</span><span class="s4">, </span><span class="s1">child)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(p != children_.end()) {</span>
    <span class="s1">children_.erase(p)</span><span class="s4">;</span>
    <span class="s4">return true;</span>
  <span class="s1">}</span>
  <span class="s4">return false;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::removeChild(uint32_t index) {</span>
  <span class="s1">children_.erase(children_.begin() + index)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutDirection(YGDirection direction) {</span>
  <span class="s1">layout_.setDirection(direction)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutMargin(</span><span class="s4">float </span><span class="s1">margin</span><span class="s4">, int </span><span class="s1">index) {</span>
  <span class="s1">layout_.margin[index] = margin</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutBorder(</span><span class="s4">float </span><span class="s1">border</span><span class="s4">, int </span><span class="s1">index) {</span>
  <span class="s1">layout_.border[index] = border</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutPadding(</span><span class="s4">float </span><span class="s1">padding</span><span class="s4">, int </span><span class="s1">index) {</span>
  <span class="s1">layout_.padding[index] = padding</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutLastOwnerDirection(YGDirection direction) {</span>
  <span class="s1">layout_.lastOwnerDirection = direction</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutComputedFlexBasis(</span>
    <span class="s4">const </span><span class="s1">YGFloatOptional computedFlexBasis) {</span>
  <span class="s1">layout_.computedFlexBasis = computedFlexBasis</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutPosition(</span><span class="s4">float </span><span class="s1">position</span><span class="s4">, int </span><span class="s1">index) {</span>
  <span class="s1">layout_.position[index] = position</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutComputedFlexBasisGeneration(</span>
    <span class="s1">uint32_t computedFlexBasisGeneration) {</span>
  <span class="s1">layout_.computedFlexBasisGeneration = computedFlexBasisGeneration</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutMeasuredDimension(</span><span class="s4">float </span><span class="s1">measuredDimension</span><span class="s4">, int </span><span class="s1">index) {</span>
  <span class="s1">layout_.measuredDimensions[index] = measuredDimension</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutHadOverflow(</span><span class="s4">bool </span><span class="s1">hadOverflow) {</span>
  <span class="s1">layout_.setHadOverflow(hadOverflow)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setLayoutDimension(</span><span class="s4">float </span><span class="s1">dimension</span><span class="s4">, int </span><span class="s1">index) {</span>
  <span class="s1">layout_.dimensions[index] = dimension</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">// If both left and right are defined, then use left. Otherwise return +left or</span>
<span class="s0">// -right depending on which is defined.</span>
<span class="s1">YGFloatOptional YGNode::relativePosition(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">axisSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(isLeadingPositionDefined(axis)) {</span>
    <span class="s4">return </span><span class="s1">getLeadingPosition(axis</span><span class="s4">, </span><span class="s1">axisSize)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">YGFloatOptional trailingPosition = getTrailingPosition(axis</span><span class="s4">, </span><span class="s1">axisSize)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!trailingPosition.isUndefined()) {</span>
    <span class="s1">trailingPosition = YGFloatOptional{-</span><span class="s5">1 </span><span class="s1">* trailingPosition.unwrap()}</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">trailingPosition</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::setPosition(</span>
    <span class="s4">const </span><span class="s1">YGDirection direction</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">mainSize</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">crossSize</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">ownerWidth) {</span>
  <span class="s0">/* Root nodes should be always layouted as LTR, so we don't return negative 
   * values. */</span>
  <span class="s4">const </span><span class="s1">YGDirection directionRespectingRoot =</span>
      <span class="s1">owner_ != </span><span class="s4">nullptr </span><span class="s1">? direction : YGDirectionLTR</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">YGFlexDirection mainAxis =</span>
      <span class="s1">YGResolveFlexDirection(style_.flexDirection()</span><span class="s4">, </span><span class="s1">directionRespectingRoot)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">YGFlexDirection crossAxis =</span>
      <span class="s1">YGFlexDirectionCross(mainAxis</span><span class="s4">, </span><span class="s1">directionRespectingRoot)</span><span class="s4">;</span>

  <span class="s0">// Here we should check for `YGPositionTypeStatic` and in this case zero inset</span>
  <span class="s0">// properties (left, right, top, bottom, begin, end).</span>
  <span class="s0">// https://www.w3.org/TR/css-position-3/#valdef-position-static</span>
  <span class="s4">const </span><span class="s1">YGFloatOptional relativePositionMain =</span>
      <span class="s1">relativePosition(mainAxis</span><span class="s4">, </span><span class="s1">mainSize)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">YGFloatOptional relativePositionCross =</span>
      <span class="s1">relativePosition(crossAxis</span><span class="s4">, </span><span class="s1">crossSize)</span><span class="s4">;</span>

  <span class="s1">setLayoutPosition(</span>
      <span class="s1">(getLeadingMargin(mainAxis</span><span class="s4">, </span><span class="s1">ownerWidth) + relativePositionMain).unwrap()</span><span class="s4">,</span>
      <span class="s1">leading[mainAxis])</span><span class="s4">;</span>
  <span class="s1">setLayoutPosition(</span>
      <span class="s1">(getTrailingMargin(mainAxis</span><span class="s4">, </span><span class="s1">ownerWidth) + relativePositionMain).unwrap()</span><span class="s4">,</span>
      <span class="s1">trailing[mainAxis])</span><span class="s4">;</span>
  <span class="s1">setLayoutPosition(</span>
      <span class="s1">(getLeadingMargin(crossAxis</span><span class="s4">, </span><span class="s1">ownerWidth) + relativePositionCross)</span>
          <span class="s1">.unwrap()</span><span class="s4">,</span>
      <span class="s1">leading[crossAxis])</span><span class="s4">;</span>
  <span class="s1">setLayoutPosition(</span>
      <span class="s1">(getTrailingMargin(crossAxis</span><span class="s4">, </span><span class="s1">ownerWidth) + relativePositionCross)</span>
          <span class="s1">.unwrap()</span><span class="s4">,</span>
      <span class="s1">trailing[crossAxis])</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGValue YGNode::marginLeadingValue(</span><span class="s4">const </span><span class="s1">YGFlexDirection axis) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(YGFlexDirectionIsRow(axis) &amp;&amp;</span>
      <span class="s1">!style_.margin()[YGEdgeStart].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">style_.margin()[YGEdgeStart]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">style_.margin()[leading[axis]]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YGValue YGNode::marginTrailingValue(</span><span class="s4">const </span><span class="s1">YGFlexDirection axis) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(YGFlexDirectionIsRow(axis) &amp;&amp; !style_.margin()[YGEdgeEnd].isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">style_.margin()[YGEdgeEnd]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">style_.margin()[trailing[axis]]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YGValue YGNode::resolveFlexBasisPtr() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">YGValue flexBasis = style_.flexBasis()</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(flexBasis.unit != YGUnitAuto &amp;&amp; flexBasis.unit != YGUnitUndefined) {</span>
    <span class="s4">return </span><span class="s1">flexBasis</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!style_.flex().isUndefined() &amp;&amp; style_.flex().unwrap() &gt; </span><span class="s5">0.0f</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">useWebDefaults_)</span>
        <span class="s1">? YGValueAuto</span>
        <span class="s1">: YGValueZero</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">YGValueAuto</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::resolveDimension() {</span>
  <span class="s4">using namespace </span><span class="s1">yoga</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">YGStyle&amp; style = getStyle()</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto </span><span class="s1">dim : {YGDimensionWidth</span><span class="s4">, </span><span class="s1">YGDimensionHeight}) {</span>
    <span class="s4">if </span><span class="s1">(!style.maxDimensions()[dim].isUndefined() &amp;&amp;</span>
        <span class="s1">YGValueEqual(style.maxDimensions()[dim]</span><span class="s4">, </span><span class="s1">style.minDimensions()[dim])) {</span>
      <span class="s1">resolvedDimensions_[dim] = style.maxDimensions()[dim]</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">resolvedDimensions_[dim] = style.dimensions()[dim]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YGDirection YGNode::resolveDirection(</span><span class="s4">const </span><span class="s1">YGDirection ownerDirection) {</span>
  <span class="s4">if </span><span class="s1">(style_.direction() == YGDirectionInherit) {</span>
    <span class="s4">return </span><span class="s1">ownerDirection &gt; YGDirectionInherit ? ownerDirection</span>
                                               <span class="s1">: YGDirectionLTR</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">style_.direction()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s4">void </span><span class="s1">YGNode::clearChildren() {</span>
  <span class="s1">children_.clear()</span><span class="s4">;</span>
  <span class="s1">children_.shrink_to_fit()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">// Other Methods</span>

<span class="s4">void </span><span class="s1">YGNode::cloneChildrenIfNeeded(</span><span class="s4">void</span><span class="s1">* cloneContext) {</span>
  <span class="s1">iterChildrenAfterCloningIfNeeded([](YGNodeRef</span><span class="s4">, void</span><span class="s1">*) {}</span><span class="s4">, </span><span class="s1">cloneContext)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::markDirtyAndPropogate() {</span>
  <span class="s4">if </span><span class="s1">(!facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">isDirty_)) {</span>
    <span class="s1">setDirty(</span><span class="s4">true</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">setLayoutComputedFlexBasis(YGFloatOptional())</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(owner_) {</span>
      <span class="s1">owner_-&gt;markDirtyAndPropogate()</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::markDirtyAndPropogateDownwards() {</span>
  <span class="s1">facebook::yoga::detail::setBooleanData(flags</span><span class="s4">, </span><span class="s1">isDirty_</span><span class="s4">, true</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">for_each(children_.begin()</span><span class="s4">, </span><span class="s1">children_.end()</span><span class="s4">, </span><span class="s1">[](YGNodeRef childNode) {</span>
    <span class="s1">childNode-&gt;markDirtyAndPropogateDownwards()</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">float </span><span class="s1">YGNode::resolveFlexGrow() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s0">// Root nodes flexGrow should always be 0</span>
  <span class="s4">if </span><span class="s1">(owner_ == </span><span class="s4">nullptr</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s5">0.0</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!style_.flexGrow().isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">style_.flexGrow().unwrap()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!style_.flex().isUndefined() &amp;&amp; style_.flex().unwrap() &gt; </span><span class="s5">0.0f</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">style_.flex().unwrap()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">kDefaultFlexGrow</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">float </span><span class="s1">YGNode::resolveFlexShrink() </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(owner_ == </span><span class="s4">nullptr</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s5">0.0</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!style_.flexShrink().isUndefined()) {</span>
    <span class="s4">return </span><span class="s1">style_.flexShrink().unwrap()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(!facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">useWebDefaults_) &amp;&amp;</span>
      <span class="s1">!style_.flex().isUndefined() &amp;&amp; style_.flex().unwrap() &lt; </span><span class="s5">0.0f</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">-style_.flex().unwrap()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">useWebDefaults_)</span>
      <span class="s1">? kWebDefaultFlexShrink</span>
      <span class="s1">: kDefaultFlexShrink</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">bool </span><span class="s1">YGNode::isNodeFlexible() {</span>
  <span class="s4">return </span><span class="s1">(</span>
      <span class="s1">(style_.positionType() != YGPositionTypeAbsolute) &amp;&amp;</span>
      <span class="s1">(resolveFlexGrow() != </span><span class="s5">0 </span><span class="s1">|| resolveFlexShrink() != </span><span class="s5">0</span><span class="s1">))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">float </span><span class="s1">YGNode::getLeadingBorder(</span><span class="s4">const </span><span class="s1">YGFlexDirection axis) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">YGValue leadingBorder = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.border()</span><span class="s4">, </span><span class="s1">YGEdgeStart</span><span class="s4">, </span><span class="s1">leading[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.border()</span><span class="s4">, </span><span class="s1">leading[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">fmaxf(leadingBorder.value</span><span class="s4">, </span><span class="s5">0.0f</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">float </span><span class="s1">YGNode::getTrailingBorder(</span><span class="s4">const </span><span class="s1">YGFlexDirection axis) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s1">YGValue trailingBorder = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.border()</span><span class="s4">, </span><span class="s1">YGEdgeEnd</span><span class="s4">, </span><span class="s1">trailing[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.border()</span><span class="s4">, </span><span class="s1">trailing[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">fmaxf(trailingBorder.value</span><span class="s4">, </span><span class="s5">0.0f</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getLeadingPadding(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">widthSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">leadingPadding = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.padding()</span><span class="s4">,</span>
            <span class="s1">YGEdgeStart</span><span class="s4">,</span>
            <span class="s1">leading[axis]</span><span class="s4">,</span>
            <span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.padding()</span><span class="s4">, </span><span class="s1">leading[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YGFloatOptionalMax(</span>
      <span class="s1">YGResolveValue(leadingPadding</span><span class="s4">, </span><span class="s1">widthSize)</span><span class="s4">, </span><span class="s1">YGFloatOptional(</span><span class="s5">0.0f</span><span class="s1">))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getTrailingPadding(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">widthSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">auto </span><span class="s1">trailingPadding = YGFlexDirectionIsRow(axis)</span>
      <span class="s1">? computeEdgeValueForRow(</span>
            <span class="s1">style_.padding()</span><span class="s4">, </span><span class="s1">YGEdgeEnd</span><span class="s4">, </span><span class="s1">trailing[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span>
      <span class="s1">: computeEdgeValueForColumn(</span>
            <span class="s1">style_.padding()</span><span class="s4">, </span><span class="s1">trailing[axis]</span><span class="s4">, </span><span class="s1">CompactValue::ofZero())</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">YGFloatOptionalMax(</span>
      <span class="s1">YGResolveValue(trailingPadding</span><span class="s4">, </span><span class="s1">widthSize)</span><span class="s4">, </span><span class="s1">YGFloatOptional(</span><span class="s5">0.0f</span><span class="s1">))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getLeadingPaddingAndBorder(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">widthSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">return </span><span class="s1">getLeadingPadding(axis</span><span class="s4">, </span><span class="s1">widthSize) +</span>
      <span class="s1">YGFloatOptional(getLeadingBorder(axis))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">YGFloatOptional YGNode::getTrailingPaddingAndBorder(</span>
    <span class="s4">const </span><span class="s1">YGFlexDirection axis</span><span class="s4">,</span>
    <span class="s4">const float </span><span class="s1">widthSize) </span><span class="s4">const </span><span class="s1">{</span>
  <span class="s4">return </span><span class="s1">getTrailingPadding(axis</span><span class="s4">, </span><span class="s1">widthSize) +</span>
      <span class="s1">YGFloatOptional(getTrailingBorder(axis))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">void </span><span class="s1">YGNode::reset() {</span>
  <span class="s1">YGAssertWithNode(</span>
      <span class="s4">this,</span>
      <span class="s1">children_.size() == </span><span class="s5">0</span><span class="s4">,</span>
      <span class="s3">&quot;Cannot reset a node which still has children attached&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">YGAssertWithNode(</span>
      <span class="s4">this, </span><span class="s1">owner_ == </span><span class="s4">nullptr, </span><span class="s3">&quot;Cannot reset a node still attached to a owner&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">clearChildren()</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">webDefaults =</span>
      <span class="s1">facebook::yoga::detail::getBooleanData(flags</span><span class="s4">, </span><span class="s1">useWebDefaults_)</span><span class="s4">;</span>
  <span class="s1">*</span><span class="s4">this </span><span class="s1">= YGNode{getConfig()}</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(webDefaults) {</span>
    <span class="s1">useWebDefaults()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
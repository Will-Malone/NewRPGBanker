<html>
<head>
<title>TestScheduler.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
TestScheduler.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.createTestScheduler = createTestScheduler;</span>
<span class="s2">function </span><span class="s1">_chalk() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'chalk'</span><span class="s1">));</span>
  <span class="s1">_chalk = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_ciInfo() {</span>
  <span class="s1">const data = require(</span><span class="s0">'ci-info'</span><span class="s1">);</span>
  <span class="s1">_ciInfo = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_exit() {</span>
  <span class="s1">const data = _interopRequireDefault(require(</span><span class="s0">'exit'</span><span class="s1">));</span>
  <span class="s1">_exit = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_reporters() {</span>
  <span class="s1">const data = require(</span><span class="s0">'@jest/reporters'</span><span class="s1">);</span>
  <span class="s1">_reporters = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_testResult() {</span>
  <span class="s1">const data = require(</span><span class="s0">'@jest/test-result'</span><span class="s1">);</span>
  <span class="s1">_testResult = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_transform() {</span>
  <span class="s1">const data = require(</span><span class="s0">'@jest/transform'</span><span class="s1">);</span>
  <span class="s1">_transform = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestMessageUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-message-util'</span><span class="s1">);</span>
  <span class="s1">_jestMessageUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestSnapshot() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-snapshot'</span><span class="s1">);</span>
  <span class="s1">_jestSnapshot = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-util'</span><span class="s1">);</span>
  <span class="s1">_jestUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">_ReporterDispatcher = _interopRequireDefault(</span>
  <span class="s1">require(</span><span class="s0">'./ReporterDispatcher'</span><span class="s1">)</span>
<span class="s1">);</span>
<span class="s2">var </span><span class="s1">_testSchedulerHelper = require(</span><span class="s0">'./testSchedulerHelper'</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) {</span>
  <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span><span class="s2">default</span><span class="s1">: obj};</span>
<span class="s1">}</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s1">async </span><span class="s2">function </span><span class="s1">createTestScheduler(globalConfig, context) {</span>
  <span class="s1">const scheduler = </span><span class="s2">new </span><span class="s1">TestScheduler(globalConfig, context);</span>
  <span class="s1">await scheduler._setupReporters();</span>
  <span class="s2">return </span><span class="s1">scheduler;</span>
<span class="s1">}</span>
<span class="s1">class TestScheduler {</span>
  <span class="s1">_context;</span>
  <span class="s1">_dispatcher;</span>
  <span class="s1">_globalConfig;</span>
  <span class="s1">constructor(globalConfig, context) {</span>
    <span class="s2">this</span><span class="s1">._context = context;</span>
    <span class="s2">this</span><span class="s1">._dispatcher = </span><span class="s2">new </span><span class="s1">_ReporterDispatcher.</span><span class="s2">default</span><span class="s1">();</span>
    <span class="s2">this</span><span class="s1">._globalConfig = globalConfig;</span>
  <span class="s1">}</span>
  <span class="s1">addReporter(reporter) {</span>
    <span class="s2">this</span><span class="s1">._dispatcher.register(reporter);</span>
  <span class="s1">}</span>
  <span class="s1">removeReporter(reporterConstructor) {</span>
    <span class="s2">this</span><span class="s1">._dispatcher.unregister(reporterConstructor);</span>
  <span class="s1">}</span>
  <span class="s1">async scheduleTests(tests, watcher) {</span>
    <span class="s1">const onTestFileStart = </span><span class="s2">this</span><span class="s1">._dispatcher.onTestFileStart.bind(</span>
      <span class="s2">this</span><span class="s1">._dispatcher</span>
    <span class="s1">);</span>
    <span class="s1">const timings = [];</span>
    <span class="s1">const testContexts = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s1">tests.forEach(test =&gt; {</span>
      <span class="s1">testContexts.add(test.context);</span>
      <span class="s2">if </span><span class="s1">(test.duration) {</span>
        <span class="s1">timings.push(test.duration);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">const aggregatedResults = createAggregatedResults(tests.length);</span>
    <span class="s1">const estimatedTime = Math.ceil(</span>
      <span class="s1">getEstimatedTime(timings, </span><span class="s2">this</span><span class="s1">._globalConfig.maxWorkers) / </span><span class="s4">1000</span>
    <span class="s1">);</span>
    <span class="s1">const runInBand = (</span><span class="s4">0</span><span class="s1">, _testSchedulerHelper.shouldRunInBand)(</span>
      <span class="s1">tests,</span>
      <span class="s1">timings,</span>
      <span class="s2">this</span><span class="s1">._globalConfig</span>
    <span class="s1">);</span>
    <span class="s1">const onResult = async (test, testResult) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(watcher.isInterrupted()) {</span>
        <span class="s2">return </span><span class="s1">Promise.resolve();</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(testResult.testResults.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">const message = </span><span class="s0">'Your test suite must contain at least one test.'</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">onFailure(test, {</span>
          <span class="s1">message,</span>
          <span class="s1">stack: </span><span class="s2">new </span><span class="s1">Error(message).stack</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s3">// Throws when the context is leaked after executing a test.</span>
      <span class="s2">if </span><span class="s1">(testResult.leaks) {</span>
        <span class="s1">const message =</span>
          <span class="s1">`${_chalk().</span><span class="s2">default</span><span class="s1">.red.bold(</span>
            <span class="s0">'EXPERIMENTAL FEATURE!</span><span class="s5">\n</span><span class="s0">'</span>
          <span class="s1">)}Your test suite is leaking memory. Please ensure all references are cleaned.\n` +</span>
          <span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s0">'There is a number of things that can leak memory:</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s0">'  - Async operations that have not finished (e.g. fs.readFile).</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s0">'  - Timers not properly mocked (e.g. setInterval, setTimeout).</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+</span>
          <span class="s0">'  - Keeping references to the global scope.'</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">onFailure(test, {</span>
          <span class="s1">message,</span>
          <span class="s1">stack: </span><span class="s2">new </span><span class="s1">Error(message).stack</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
      <span class="s1">(</span><span class="s4">0</span><span class="s1">, _testResult().addResult)(aggregatedResults, testResult);</span>
      <span class="s1">await </span><span class="s2">this</span><span class="s1">._dispatcher.onTestFileResult(</span>
        <span class="s1">test,</span>
        <span class="s1">testResult,</span>
        <span class="s1">aggregatedResults</span>
      <span class="s1">);</span>
      <span class="s2">return this</span><span class="s1">._bailIfNeeded(testContexts, aggregatedResults, watcher);</span>
    <span class="s1">};</span>
    <span class="s1">const onFailure = async (test, error) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(watcher.isInterrupted()) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const testResult = (</span><span class="s4">0</span><span class="s1">, _testResult().buildFailureTestResult)(</span>
        <span class="s1">test.path,</span>
        <span class="s1">error</span>
      <span class="s1">);</span>
      <span class="s1">testResult.failureMessage = (</span><span class="s4">0</span><span class="s1">, _jestMessageUtil().formatExecError)(</span>
        <span class="s1">testResult.testExecError,</span>
        <span class="s1">test.context.config,</span>
        <span class="s2">this</span><span class="s1">._globalConfig,</span>
        <span class="s1">test.path</span>
      <span class="s1">);</span>
      <span class="s1">(</span><span class="s4">0</span><span class="s1">, _testResult().addResult)(aggregatedResults, testResult);</span>
      <span class="s1">await </span><span class="s2">this</span><span class="s1">._dispatcher.onTestFileResult(</span>
        <span class="s1">test,</span>
        <span class="s1">testResult,</span>
        <span class="s1">aggregatedResults</span>
      <span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">const updateSnapshotState = async () =&gt; {</span>
      <span class="s1">const contextsWithSnapshotResolvers = await Promise.all(</span>
        <span class="s1">Array.from(testContexts).map(async context =&gt; [</span>
          <span class="s1">context,</span>
          <span class="s1">await (</span><span class="s4">0</span><span class="s1">, _jestSnapshot().buildSnapshotResolver)(context.config)</span>
        <span class="s1">])</span>
      <span class="s1">);</span>
      <span class="s1">contextsWithSnapshotResolvers.forEach(([context, snapshotResolver]) =&gt; {</span>
        <span class="s1">const status = (</span><span class="s4">0</span><span class="s1">, _jestSnapshot().cleanup)(</span>
          <span class="s1">context.hasteFS,</span>
          <span class="s2">this</span><span class="s1">._globalConfig.updateSnapshot,</span>
          <span class="s1">snapshotResolver,</span>
          <span class="s1">context.config.testPathIgnorePatterns</span>
        <span class="s1">);</span>
        <span class="s1">aggregatedResults.snapshot.filesRemoved += status.filesRemoved;</span>
        <span class="s1">aggregatedResults.snapshot.filesRemovedList = (</span>
          <span class="s1">aggregatedResults.snapshot.filesRemovedList || []</span>
        <span class="s1">).concat(status.filesRemovedList);</span>
      <span class="s1">});</span>
      <span class="s1">const updateAll = </span><span class="s2">this</span><span class="s1">._globalConfig.updateSnapshot === </span><span class="s0">'all'</span><span class="s1">;</span>
      <span class="s1">aggregatedResults.snapshot.didUpdate = updateAll;</span>
      <span class="s1">aggregatedResults.snapshot.failure = !!(</span>
        <span class="s1">!updateAll &amp;&amp;</span>
        <span class="s1">(aggregatedResults.snapshot.unchecked ||</span>
          <span class="s1">aggregatedResults.snapshot.unmatched ||</span>
          <span class="s1">aggregatedResults.snapshot.filesRemoved)</span>
      <span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">await </span><span class="s2">this</span><span class="s1">._dispatcher.onRunStart(aggregatedResults, {</span>
      <span class="s1">estimatedTime,</span>
      <span class="s1">showStatus: !runInBand</span>
    <span class="s1">});</span>
    <span class="s1">const testRunners = Object.create(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">const contextsByTestRunner = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">await Promise.all(</span>
        <span class="s1">Array.from(testContexts).map(async context =&gt; {</span>
          <span class="s1">const {config} = context;</span>
          <span class="s2">if </span><span class="s1">(!testRunners[config.runner]) {</span>
            <span class="s1">const transformer = await (</span><span class="s4">0</span><span class="s1">, _transform().createScriptTransformer)(</span>
              <span class="s1">config</span>
            <span class="s1">);</span>
            <span class="s1">const Runner = await transformer.requireAndTranspileModule(</span>
              <span class="s1">config.runner</span>
            <span class="s1">);</span>
            <span class="s1">const runner = </span><span class="s2">new </span><span class="s1">Runner(</span><span class="s2">this</span><span class="s1">._globalConfig, {</span>
              <span class="s1">changedFiles: </span><span class="s2">this</span><span class="s1">._context.changedFiles,</span>
              <span class="s1">sourcesRelatedToTestsInChangedFiles:</span>
                <span class="s2">this</span><span class="s1">._context.sourcesRelatedToTestsInChangedFiles</span>
            <span class="s1">});</span>
            <span class="s1">testRunners[config.runner] = runner;</span>
            <span class="s1">contextsByTestRunner.set(runner, context);</span>
          <span class="s1">}</span>
        <span class="s1">})</span>
      <span class="s1">);</span>
      <span class="s1">const testsByRunner = </span><span class="s2">this</span><span class="s1">._partitionTests(testRunners, tests);</span>
      <span class="s2">if </span><span class="s1">(testsByRunner) {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s2">for </span><span class="s1">(const runner of Object.keys(testRunners)) {</span>
            <span class="s1">const testRunner = testRunners[runner];</span>
            <span class="s1">const context = contextsByTestRunner.get(testRunner);</span>
            <span class="s1">invariant(context);</span>
            <span class="s1">const tests = testsByRunner[runner];</span>
            <span class="s1">const testRunnerOptions = {</span>
              <span class="s1">serial: runInBand || Boolean(testRunner.isSerial)</span>
            <span class="s1">};</span>
            <span class="s2">if </span><span class="s1">(testRunner.supportsEventEmitters) {</span>
              <span class="s1">const unsubscribes = [</span>
                <span class="s1">testRunner.on(</span><span class="s0">'test-file-start'</span><span class="s1">, ([test]) =&gt;</span>
                  <span class="s1">onTestFileStart(test)</span>
                <span class="s1">),</span>
                <span class="s1">testRunner.on(</span><span class="s0">'test-file-success'</span><span class="s1">, ([test, testResult]) =&gt;</span>
                  <span class="s1">onResult(test, testResult)</span>
                <span class="s1">),</span>
                <span class="s1">testRunner.on(</span><span class="s0">'test-file-failure'</span><span class="s1">, ([test, error]) =&gt;</span>
                  <span class="s1">onFailure(test, error)</span>
                <span class="s1">),</span>
                <span class="s1">testRunner.on(</span>
                  <span class="s0">'test-case-start'</span><span class="s1">,</span>
                  <span class="s1">([testPath, testCaseStartInfo]) =&gt; {</span>
                    <span class="s1">const test = {</span>
                      <span class="s1">context,</span>
                      <span class="s1">path: testPath</span>
                    <span class="s1">};</span>
                    <span class="s2">this</span><span class="s1">._dispatcher.onTestCaseStart(test, testCaseStartInfo);</span>
                  <span class="s1">}</span>
                <span class="s1">),</span>
                <span class="s1">testRunner.on(</span>
                  <span class="s0">'test-case-result'</span><span class="s1">,</span>
                  <span class="s1">([testPath, testCaseResult]) =&gt; {</span>
                    <span class="s1">const test = {</span>
                      <span class="s1">context,</span>
                      <span class="s1">path: testPath</span>
                    <span class="s1">};</span>
                    <span class="s2">this</span><span class="s1">._dispatcher.onTestCaseResult(test, testCaseResult);</span>
                  <span class="s1">}</span>
                <span class="s1">)</span>
              <span class="s1">];</span>
              <span class="s1">await testRunner.runTests(tests, watcher, testRunnerOptions);</span>
              <span class="s1">unsubscribes.forEach(sub =&gt; sub());</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">await testRunner.runTests(</span>
                <span class="s1">tests,</span>
                <span class="s1">watcher,</span>
                <span class="s1">onTestFileStart,</span>
                <span class="s1">onResult,</span>
                <span class="s1">onFailure,</span>
                <span class="s1">testRunnerOptions</span>
              <span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
          <span class="s2">if </span><span class="s1">(!watcher.isInterrupted()) {</span>
            <span class="s2">throw </span><span class="s1">error;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
      <span class="s1">aggregatedResults.runExecError = buildExecError(error);</span>
      <span class="s1">await </span><span class="s2">this</span><span class="s1">._dispatcher.onRunComplete(testContexts, aggregatedResults);</span>
      <span class="s2">throw </span><span class="s1">error;</span>
    <span class="s1">}</span>
    <span class="s1">await updateSnapshotState();</span>
    <span class="s1">aggregatedResults.wasInterrupted = watcher.isInterrupted();</span>
    <span class="s1">await </span><span class="s2">this</span><span class="s1">._dispatcher.onRunComplete(testContexts, aggregatedResults);</span>
    <span class="s1">const anyTestFailures = !(</span>
      <span class="s1">aggregatedResults.numFailedTests === </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
      <span class="s1">aggregatedResults.numRuntimeErrorTestSuites === </span><span class="s4">0</span>
    <span class="s1">);</span>
    <span class="s1">const anyReporterErrors = </span><span class="s2">this</span><span class="s1">._dispatcher.hasErrors();</span>
    <span class="s1">aggregatedResults.success = !(</span>
      <span class="s1">anyTestFailures ||</span>
      <span class="s1">aggregatedResults.snapshot.failure ||</span>
      <span class="s1">anyReporterErrors</span>
    <span class="s1">);</span>
    <span class="s2">return </span><span class="s1">aggregatedResults;</span>
  <span class="s1">}</span>
  <span class="s1">_partitionTests(testRunners, tests) {</span>
    <span class="s2">if </span><span class="s1">(Object.keys(testRunners).length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">tests.reduce((testRuns, test) =&gt; {</span>
        <span class="s1">const runner = test.context.config.runner;</span>
        <span class="s2">if </span><span class="s1">(!testRuns[runner]) {</span>
          <span class="s1">testRuns[runner] = [];</span>
        <span class="s1">}</span>
        <span class="s1">testRuns[runner].push(test);</span>
        <span class="s2">return </span><span class="s1">testRuns;</span>
      <span class="s1">}, Object.create(</span><span class="s2">null</span><span class="s1">));</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tests.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; tests[</span><span class="s4">0</span><span class="s1">] != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s3">// If there is only one runner, don't partition the tests.</span>
      <span class="s2">return </span><span class="s1">Object.assign(Object.create(</span><span class="s2">null</span><span class="s1">), {</span>
        <span class="s1">[tests[</span><span class="s4">0</span><span class="s1">].context.config.runner]: tests</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">async _setupReporters() {</span>
    <span class="s1">const {collectCoverage: coverage, notify, verbose} = </span><span class="s2">this</span><span class="s1">._globalConfig;</span>
    <span class="s1">const reporters = </span><span class="s2">this</span><span class="s1">._globalConfig.reporters || [[</span><span class="s0">'default'</span><span class="s1">, {}]];</span>
    <span class="s1">let summaryOptions = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(const [reporter, options] of reporters) {</span>
      <span class="s2">switch </span><span class="s1">(reporter) {</span>
        <span class="s2">case </span><span class="s0">'default'</span><span class="s1">:</span>
          <span class="s1">summaryOptions = options;</span>
          <span class="s1">verbose</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.addReporter(</span>
                <span class="s2">new </span><span class="s1">(_reporters().VerboseReporter)(</span><span class="s2">this</span><span class="s1">._globalConfig)</span>
              <span class="s1">)</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.addReporter(</span>
                <span class="s2">new </span><span class="s1">(_reporters().DefaultReporter)(</span><span class="s2">this</span><span class="s1">._globalConfig)</span>
              <span class="s1">);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s0">'github-actions'</span><span class="s1">:</span>
          <span class="s1">_ciInfo().GITHUB_ACTIONS &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.addReporter(</span>
              <span class="s2">new </span><span class="s1">(_reporters().GitHubActionsReporter)(</span>
                <span class="s2">this</span><span class="s1">._globalConfig,</span>
                <span class="s1">options</span>
              <span class="s1">)</span>
            <span class="s1">);</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s0">'summary'</span><span class="s1">:</span>
          <span class="s1">summaryOptions = options;</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
          <span class="s1">await </span><span class="s2">this</span><span class="s1">._addCustomReporter(reporter, options);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(notify) {</span>
      <span class="s2">this</span><span class="s1">.addReporter(</span>
        <span class="s2">new </span><span class="s1">(_reporters().NotifyReporter)(</span><span class="s2">this</span><span class="s1">._globalConfig, </span><span class="s2">this</span><span class="s1">._context)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(coverage) {</span>
      <span class="s2">this</span><span class="s1">.addReporter(</span>
        <span class="s2">new </span><span class="s1">(_reporters().CoverageReporter)(</span><span class="s2">this</span><span class="s1">._globalConfig, </span><span class="s2">this</span><span class="s1">._context)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(summaryOptions != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.addReporter(</span>
        <span class="s2">new </span><span class="s1">(_reporters().SummaryReporter)(</span><span class="s2">this</span><span class="s1">._globalConfig, summaryOptions)</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">async _addCustomReporter(reporter, options) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">const Reporter = await (</span><span class="s4">0</span><span class="s1">, _jestUtil().requireOrImportModule)(reporter);</span>
      <span class="s2">this</span><span class="s1">.addReporter(</span>
        <span class="s2">new </span><span class="s1">Reporter(</span><span class="s2">this</span><span class="s1">._globalConfig, options, </span><span class="s2">this</span><span class="s1">._context)</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
      <span class="s1">error.message = `An error occurred </span><span class="s2">while </span><span class="s1">adding the reporter at path </span><span class="s0">&quot;${_chalk().default.bold(</span>
        <span class="s1">reporter</span>
      <span class="s1">)}</span><span class="s0">&quot;.</span><span class="s5">\n</span><span class="s0">${error instanceof Error ? error.message : ''}`;</span>
      <span class="s2">throw </span><span class="s1">error;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">async _bailIfNeeded(testContexts, aggregatedResults, watcher) {</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s2">this</span><span class="s1">._globalConfig.bail !== </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
      <span class="s1">aggregatedResults.numFailedTests &gt;= </span><span class="s2">this</span><span class="s1">._globalConfig.bail</span>
    <span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(watcher.isWatchMode()) {</span>
        <span class="s1">await watcher.setState({</span>
          <span class="s1">interrupted: </span><span class="s2">true</span>
        <span class="s1">});</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">await </span><span class="s2">this</span><span class="s1">._dispatcher.onRunComplete(testContexts, aggregatedResults);</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">const exitCode = </span><span class="s2">this</span><span class="s1">._globalConfig.testFailureExitCode;</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _exit().</span><span class="s2">default</span><span class="s1">)(exitCode);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">invariant(condition, message) {</span>
  <span class="s2">if </span><span class="s1">(!condition) {</span>
    <span class="s2">throw new </span><span class="s1">Error(message);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">const createAggregatedResults = numTotalTestSuites =&gt; {</span>
  <span class="s1">const result = (</span><span class="s4">0</span><span class="s1">, _testResult().makeEmptyAggregatedTestResult)();</span>
  <span class="s1">result.numTotalTestSuites = numTotalTestSuites;</span>
  <span class="s1">result.startTime = Date.now();</span>
  <span class="s1">result.success = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">const getEstimatedTime = (timings, workers) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(timings.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">const max = Math.max(...timings);</span>
  <span class="s2">return </span><span class="s1">timings.length &lt;= workers</span>
    <span class="s1">? max</span>
    <span class="s1">: Math.max(timings.reduce((sum, time) =&gt; sum + time) / workers, max);</span>
<span class="s1">};</span>
<span class="s1">const strToError = errString =&gt; {</span>
  <span class="s1">const {message, stack} = (</span><span class="s4">0</span><span class="s1">, _jestMessageUtil().separateMessageFromStack)(</span>
    <span class="s1">errString</span>
  <span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(stack.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">message,</span>
      <span class="s1">stack</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">const error = </span><span class="s2">new </span><span class="s1">(_jestUtil().ErrorWithStack)(message, buildExecError);</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">message,</span>
    <span class="s1">stack: error.stack || </span><span class="s0">''</span>
  <span class="s1">};</span>
<span class="s1">};</span>
<span class="s1">const buildExecError = err =&gt; {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">err === </span><span class="s0">'string' </span><span class="s1">|| err == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">strToError(err || </span><span class="s0">'Error'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">const anyErr = err;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">anyErr.message === </span><span class="s0">'string'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">anyErr.stack === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; anyErr.stack.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">anyErr;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">strToError(anyErr.message);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">strToError(JSON.stringify(err));</span>
<span class="s1">};</span>
</pre>
</body>
</html>
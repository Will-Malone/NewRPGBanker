<html>
<head>
<title>FlatList.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
FlatList.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @flow 
 * @format 
 */</span>

<span class="s1">import </span><span class="s2">typeof </span><span class="s1">ScrollViewNativeComponent from </span><span class="s3">'../Components/ScrollView/ScrollViewNativeComponent'</span><span class="s1">;</span>
<span class="s1">import type {ViewStyleProp} from </span><span class="s3">'../StyleSheet/StyleSheet'</span><span class="s1">;</span>
<span class="s1">import type {</span>
  <span class="s1">RenderItemProps,</span>
  <span class="s1">RenderItemType,</span>
  <span class="s1">ViewabilityConfigCallbackPair,</span>
  <span class="s1">ViewToken,</span>
<span class="s1">} from </span><span class="s3">'@react-native/virtualized-lists'</span><span class="s1">;</span>

<span class="s1">import {type ScrollResponderType} from </span><span class="s3">'../Components/ScrollView/ScrollView'</span><span class="s1">;</span>
<span class="s1">import {</span>
  <span class="s1">VirtualizedList,</span>
  <span class="s1">keyExtractor as defaultKeyExtractor,</span>
<span class="s1">} from </span><span class="s3">'@react-native/virtualized-lists'</span><span class="s1">;</span>
<span class="s1">import memoizeOne from </span><span class="s3">'memoize-one'</span><span class="s1">;</span>

<span class="s1">const View = require(</span><span class="s3">'../Components/View/View'</span><span class="s1">);</span>
<span class="s1">const StyleSheet = require(</span><span class="s3">'../StyleSheet/StyleSheet'</span><span class="s1">);</span>
<span class="s1">const deepDiffer = require(</span><span class="s3">'../Utilities/differ/deepDiffer'</span><span class="s1">);</span>
<span class="s1">const Platform = require(</span><span class="s3">'../Utilities/Platform'</span><span class="s1">);</span>
<span class="s1">const invariant = require(</span><span class="s3">'invariant'</span><span class="s1">);</span>
<span class="s1">const React = require(</span><span class="s3">'react'</span><span class="s1">);</span>

<span class="s1">type RequiredProps&lt;ItemT&gt; = {|</span>
  <span class="s0">/** 
   * An array (or array-like list) of items to render. Other data types can be 
   * used by targeting VirtualizedList directly. 
   */</span>
  <span class="s1">data: ?$ArrayLike&lt;ItemT&gt;,</span>
<span class="s1">|};</span>
<span class="s1">type OptionalProps&lt;ItemT&gt; = {|</span>
  <span class="s0">/** 
   * Takes an item from `data` and renders it into the list. Example usage: 
   * 
   *     &lt;FlatList 
   *       ItemSeparatorComponent={Platform.OS !== 'android' &amp;&amp; ({highlighted}) =&gt; ( 
   *         &lt;View style={[style.separator, highlighted &amp;&amp; {marginLeft: 0}]} /&gt; 
   *       )} 
   *       data={[{title: 'Title Text', key: 'item1'}]} 
   *       renderItem={({item, separators}) =&gt; ( 
   *         &lt;TouchableHighlight 
   *           onPress={() =&gt; this._onPress(item)} 
   *           onShowUnderlay={separators.highlight} 
   *           onHideUnderlay={separators.unhighlight}&gt; 
   *           &lt;View style={{backgroundColor: 'white'}}&gt; 
   *             &lt;Text&gt;{item.title}&lt;/Text&gt; 
   *           &lt;/View&gt; 
   *         &lt;/TouchableHighlight&gt; 
   *       )} 
   *     /&gt; 
   * 
   * Provides additional metadata like `index` if you need it, as well as a more generic 
   * `separators.updateProps` function which let's you set whatever props you want to change the 
   * rendering of either the leading separator or trailing separator in case the more common 
   * `highlight` and `unhighlight` (which set the `highlighted: boolean` prop) are insufficient for 
   * your use-case. 
   */</span>
  <span class="s1">renderItem?: ?RenderItemType&lt;ItemT&gt;,</span>

  <span class="s0">/** 
   * Optional custom style for multi-item rows generated when numColumns &gt; 1. 
   */</span>
  <span class="s1">columnWrapperStyle?: ViewStyleProp,</span>
  <span class="s0">/** 
   * A marker property for telling the list to re-render (since it implements `PureComponent`). If 
   * any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the 
   * `data` prop, stick it here and treat it immutably. 
   */</span>
  <span class="s1">extraData?: any,</span>
  <span class="s0">/** 
   * `getItemLayout` is an optional optimizations that let us skip measurement of dynamic content if 
   * you know the height of items a priori. `getItemLayout` is the most efficient, and is easy to 
   * use if you have fixed height items, for example: 
   * 
   *     getItemLayout={(data, index) =&gt; ( 
   *       {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index} 
   *     )} 
   * 
   * Adding `getItemLayout` can be a great performance boost for lists of several hundred items. 
   * Remember to include separator length (height or width) in your offset calculation if you 
   * specify `ItemSeparatorComponent`. 
   */</span>
  <span class="s1">getItemLayout?: (</span>
    <span class="s1">data: ?$ArrayLike&lt;ItemT&gt;,</span>
    <span class="s1">index: number,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s1">length: number,</span>
    <span class="s1">offset: number,</span>
    <span class="s1">index: number,</span>
    <span class="s1">...</span>
  <span class="s1">},</span>
  <span class="s0">/** 
   * If true, renders items next to each other horizontally instead of stacked vertically. 
   */</span>
  <span class="s1">horizontal?: ?boolean,</span>
  <span class="s0">/** 
   * How many items to render in the initial batch. This should be enough to fill the screen but not 
   * much more. Note these items will never be unmounted as part of the windowed rendering in order 
   * to improve perceived performance of scroll-to-top actions. 
   */</span>
  <span class="s1">initialNumToRender?: ?number,</span>
  <span class="s0">/** 
   * Instead of starting at the top with the first item, start at `initialScrollIndex`. This 
   * disables the &quot;scroll to top&quot; optimization that keeps the first `initialNumToRender` items 
   * always rendered and immediately renders the items starting at this initial index. Requires 
   * `getItemLayout` to be implemented. 
   */</span>
  <span class="s1">initialScrollIndex?: ?number,</span>
  <span class="s0">/** 
   * Reverses the direction of scroll. Uses scale transforms of -1. 
   */</span>
  <span class="s1">inverted?: ?boolean,</span>
  <span class="s0">/** 
   * Used to extract a unique key for a given item at the specified index. Key is used for caching 
   * and as the react key to track item re-ordering. The default extractor checks `item.key`, then 
   * falls back to using the index, like React does. 
   */</span>
  <span class="s1">keyExtractor?: ?(item: ItemT, index: number) =&gt; string,</span>
  <span class="s0">/** 
   * Multiple columns can only be rendered with `horizontal={false}` and will zig-zag like a 
   * `flexWrap` layout. Items should all be the same height - masonry layouts are not supported. 
   * 
   * The default value is 1. 
   */</span>
  <span class="s1">numColumns?: number,</span>
  <span class="s0">/** 
   * Note: may have bugs (missing content) in some circumstances - use at your own risk. 
   * 
   * This may improve scroll performance for large lists. 
   * 
   * The default value is true for Android. 
   */</span>
  <span class="s1">removeClippedSubviews?: boolean,</span>
  <span class="s0">/** 
   * See `ScrollView` for flow type and further documentation. 
   */</span>
  <span class="s1">fadingEdgeLength?: ?number,</span>
  <span class="s0">/** 
   * Enable an optimization to memoize the item renderer to prevent unnecessary rerenders. 
   */</span>
  <span class="s1">strictMode?: boolean,</span>
<span class="s1">|};</span>

<span class="s0">/** 
 * Default Props Helper Functions 
 * Use the following helper functions for default values 
 */</span>

<span class="s0">// removeClippedSubviewsOrDefault(this.props.removeClippedSubviews)</span>
<span class="s2">function </span><span class="s1">removeClippedSubviewsOrDefault(removeClippedSubviews: ?boolean) {</span>
  <span class="s2">return </span><span class="s1">removeClippedSubviews ?? Platform.OS === </span><span class="s3">'android'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// numColumnsOrDefault(this.props.numColumns)</span>
<span class="s2">function </span><span class="s1">numColumnsOrDefault(numColumns: ?number) {</span>
  <span class="s2">return </span><span class="s1">numColumns ?? </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isArrayLike(data: mixed): boolean {</span>
  <span class="s0">// $FlowExpectedError[incompatible-use]</span>
  <span class="s2">return typeof </span><span class="s1">Object(data).length === </span><span class="s3">'number'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">type FlatListProps&lt;ItemT&gt; = {|</span>
  <span class="s1">...RequiredProps&lt;ItemT&gt;,</span>
  <span class="s1">...OptionalProps&lt;ItemT&gt;,</span>
<span class="s1">|};</span>

<span class="s1">type VirtualizedListProps = React.ElementConfig&lt;</span><span class="s2">typeof </span><span class="s1">VirtualizedList&gt;;</span>

<span class="s1">export type Props&lt;ItemT&gt; = {</span>
  <span class="s1">...$Diff&lt;</span>
    <span class="s1">VirtualizedListProps,</span>
    <span class="s1">{</span>
      <span class="s1">getItem: $PropertyType&lt;VirtualizedListProps, </span><span class="s3">'getItem'</span><span class="s1">&gt;,</span>
      <span class="s1">getItemCount: $PropertyType&lt;VirtualizedListProps, </span><span class="s3">'getItemCount'</span><span class="s1">&gt;,</span>
      <span class="s1">getItemLayout: $PropertyType&lt;VirtualizedListProps, </span><span class="s3">'getItemLayout'</span><span class="s1">&gt;,</span>
      <span class="s1">renderItem: $PropertyType&lt;VirtualizedListProps, </span><span class="s3">'renderItem'</span><span class="s1">&gt;,</span>
      <span class="s1">keyExtractor: $PropertyType&lt;VirtualizedListProps, </span><span class="s3">'keyExtractor'</span><span class="s1">&gt;,</span>
      <span class="s1">...</span>
    <span class="s1">},</span>
  <span class="s1">&gt;,</span>
  <span class="s1">...FlatListProps&lt;ItemT&gt;,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">/** 
 * A performant interface for rendering simple, flat lists, supporting the most handy features: 
 * 
 *  - Fully cross-platform. 
 *  - Optional horizontal mode. 
 *  - Configurable viewability callbacks. 
 *  - Header support. 
 *  - Footer support. 
 *  - Separator support. 
 *  - Pull to Refresh. 
 *  - Scroll loading. 
 *  - ScrollToIndex support. 
 * 
 * If you need section support, use [`&lt;SectionList&gt;`](docs/sectionlist.html). 
 * 
 * Minimal Example: 
 * 
 *     &lt;FlatList 
 *       data={[{key: 'a'}, {key: 'b'}]} 
 *       renderItem={({item}) =&gt; &lt;Text&gt;{item.key}&lt;/Text&gt;} 
 *     /&gt; 
 * 
 * More complex, multi-select example demonstrating `PureComponent` usage for perf optimization and avoiding bugs. 
 * 
 * - By binding the `onPressItem` handler, the props will remain `===` and `PureComponent` will 
 *   prevent wasteful re-renders unless the actual `id`, `selected`, or `title` props change, even 
 *   if the components rendered in `MyListItem` did not have such optimizations. 
 * - By passing `extraData={this.state}` to `FlatList` we make sure `FlatList` itself will re-render 
 *   when the `state.selected` changes. Without setting this prop, `FlatList` would not know it 
 *   needs to re-render any items because it is also a `PureComponent` and the prop comparison will 
 *   not show any changes. 
 * - `keyExtractor` tells the list to use the `id`s for the react keys instead of the default `key` property. 
 * 
 * 
 *     class MyListItem extends React.PureComponent { 
 *       _onPress = () =&gt; { 
 *         this.props.onPressItem(this.props.id); 
 *       }; 
 * 
 *       render() { 
 *         const textColor = this.props.selected ? &quot;red&quot; : &quot;black&quot;; 
 *         return ( 
 *           &lt;TouchableOpacity onPress={this._onPress}&gt; 
 *             &lt;View&gt; 
 *               &lt;Text style={{ color: textColor }}&gt; 
 *                 {this.props.title} 
 *               &lt;/Text&gt; 
 *             &lt;/View&gt; 
 *           &lt;/TouchableOpacity&gt; 
 *         ); 
 *       } 
 *     } 
 * 
 *     class MultiSelectList extends React.PureComponent { 
 *       state = {selected: (new Map(): Map&lt;string, boolean&gt;)}; 
 * 
 *       _keyExtractor = (item, index) =&gt; item.id; 
 * 
 *       _onPressItem = (id: string) =&gt; { 
 *         // updater functions are preferred for transactional updates 
 *         this.setState((state) =&gt; { 
 *           // copy the map rather than modifying state. 
 *           const selected = new Map(state.selected); 
 *           selected.set(id, !selected.get(id)); // toggle 
 *           return {selected}; 
 *         }); 
 *       }; 
 * 
 *       _renderItem = ({item}) =&gt; ( 
 *         &lt;MyListItem 
 *           id={item.id} 
 *           onPressItem={this._onPressItem} 
 *           selected={!!this.state.selected.get(item.id)} 
 *           title={item.title} 
 *         /&gt; 
 *       ); 
 * 
 *       render() { 
 *         return ( 
 *           &lt;FlatList 
 *             data={this.props.data} 
 *             extraData={this.state} 
 *             keyExtractor={this._keyExtractor} 
 *             renderItem={this._renderItem} 
 *           /&gt; 
 *         ); 
 *       } 
 *     } 
 * 
 * This is a convenience wrapper around [`&lt;VirtualizedList&gt;`](docs/virtualizedlist.html), 
 * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed 
 * here, along with the following caveats: 
 * 
 * - Internal state is not preserved when content scrolls out of the render window. Make sure all 
 *   your data is captured in the item data or external stores like Flux, Redux, or Relay. 
 * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow- 
 *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop 
 *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on 
 *   changes. This includes the `data` prop and parent component state. 
 * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously 
 *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see 
 *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application, 
 *   and we are working on improving it behind the scenes. 
 * - By default, the list looks for a `key` prop on each item and uses that for the React key. 
 *   Alternatively, you can provide a custom `keyExtractor` prop. 
 * 
 * Also inherits [ScrollView Props](docs/scrollview.html#props), unless it is nested in another FlatList of same orientation. 
 */</span>
<span class="s1">class FlatList&lt;ItemT&gt; extends React.PureComponent&lt;Props&lt;ItemT&gt;, </span><span class="s2">void</span><span class="s1">&gt; {</span>
  <span class="s1">props: Props&lt;ItemT&gt;;</span>
  <span class="s0">/** 
   * Scrolls to the end of the content. May be janky without `getItemLayout` prop. 
   */</span>
  <span class="s1">scrollToEnd(params?: ?{animated?: ?boolean, ...}) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">this</span><span class="s1">._listRef.scrollToEnd(params);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Scrolls to the item at the specified index such that it is positioned in the viewable area 
   * such that `viewPosition` 0 places it at the top, 1 at the bottom, and 0.5 centered in the 
   * middle. `viewOffset` is a fixed number of pixels to offset the final target position. 
   * 
   * Note: cannot scroll to locations outside the render window without specifying the 
   * `getItemLayout` prop. 
   */</span>
  <span class="s1">scrollToIndex(params: {</span>
    <span class="s1">animated?: ?boolean,</span>
    <span class="s1">index: number,</span>
    <span class="s1">viewOffset?: number,</span>
    <span class="s1">viewPosition?: number,</span>
    <span class="s1">...</span>
  <span class="s1">}) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">this</span><span class="s1">._listRef.scrollToIndex(params);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Requires linear scan through data - use `scrollToIndex` instead if possible. 
   * 
   * Note: cannot scroll to locations outside the render window without specifying the 
   * `getItemLayout` prop. 
   */</span>
  <span class="s1">scrollToItem(params: {</span>
    <span class="s1">animated?: ?boolean,</span>
    <span class="s1">item: ItemT,</span>
    <span class="s1">viewOffset?: number,</span>
    <span class="s1">viewPosition?: number,</span>
    <span class="s1">...</span>
  <span class="s1">}) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">this</span><span class="s1">._listRef.scrollToItem(params);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Scroll to a specific content pixel offset in the list. 
   * 
   * Check out [scrollToOffset](docs/virtualizedlist.html#scrolltooffset) of VirtualizedList 
   */</span>
  <span class="s1">scrollToOffset(params: {animated?: ?boolean, offset: number, ...}) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">this</span><span class="s1">._listRef.scrollToOffset(params);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g. 
   * if `waitForInteractions` is true and the user has not scrolled. This is typically called by 
   * taps on items or by navigation actions. 
   */</span>
  <span class="s1">recordInteraction() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">this</span><span class="s1">._listRef.recordInteraction();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Displays the scroll indicators momentarily. 
   * 
   * @platform ios 
   */</span>
  <span class="s1">flashScrollIndicators() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">this</span><span class="s1">._listRef.flashScrollIndicators();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Provides a handle to the underlying scroll responder. 
   */</span>
  <span class="s1">getScrollResponder(): ?ScrollResponderType {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">return this</span><span class="s1">._listRef.getScrollResponder();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Provides a reference to the underlying host component 
   */</span>
  <span class="s1">getNativeScrollRef():</span>
    <span class="s1">| ?React.ElementRef&lt;</span><span class="s2">typeof </span><span class="s1">View&gt;</span>
    <span class="s1">| ?React.ElementRef&lt;ScrollViewNativeComponent&gt; {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s0">/* $FlowFixMe[incompatible-return] Suppresses errors found when fixing 
       * TextInput typing */</span>
      <span class="s2">return this</span><span class="s1">._listRef.getScrollRef();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">getScrollableNode(): any {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">return this</span><span class="s1">._listRef.getScrollableNode();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">setNativeProps(props: {[string]: mixed, ...}) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._listRef) {</span>
      <span class="s2">this</span><span class="s1">._listRef.setNativeProps(props);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">constructor(props: Props&lt;ItemT&gt;) {</span>
    <span class="s1">super(props);</span>
    <span class="s2">this</span><span class="s1">._checkProps(</span><span class="s2">this</span><span class="s1">.props);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.viewabilityConfigCallbackPairs) {</span>
      <span class="s2">this</span><span class="s1">._virtualizedListPairs =</span>
        <span class="s2">this</span><span class="s1">.props.viewabilityConfigCallbackPairs.map(pair =&gt; ({</span>
          <span class="s1">viewabilityConfig: pair.viewabilityConfig,</span>
          <span class="s1">onViewableItemsChanged: </span><span class="s2">this</span><span class="s1">._createOnViewableItemsChanged(</span>
            <span class="s1">pair.onViewableItemsChanged,</span>
          <span class="s1">),</span>
        <span class="s1">}));</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.onViewableItemsChanged) {</span>
      <span class="s2">this</span><span class="s1">._virtualizedListPairs.push({</span>
        <span class="s0">/* $FlowFixMe[incompatible-call] (&gt;=0.63.0 site=react_native_fb) This 
         * comment suppresses an error found when Flow v0.63 was deployed. To 
         * see the error delete this comment and run Flow. */</span>
        <span class="s1">viewabilityConfig: </span><span class="s2">this</span><span class="s1">.props.viewabilityConfig,</span>
        <span class="s1">onViewableItemsChanged: </span><span class="s2">this</span><span class="s1">._createOnViewableItemsChanged(</span>
          <span class="s2">this</span><span class="s1">.props.onViewableItemsChanged,</span>
        <span class="s1">),</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// $FlowFixMe[missing-local-annot]</span>
  <span class="s1">componentDidUpdate(prevProps: Props&lt;ItemT&gt;) {</span>
    <span class="s1">invariant(</span>
      <span class="s1">prevProps.numColumns === </span><span class="s2">this</span><span class="s1">.props.numColumns,</span>
      <span class="s3">'Changing numColumns on the fly is not supported. Change the key prop on FlatList when ' </span><span class="s1">+</span>
        <span class="s3">'changing the number of columns to force a fresh render of the component.'</span><span class="s1">,</span>
    <span class="s1">);</span>
    <span class="s1">invariant(</span>
      <span class="s1">prevProps.onViewableItemsChanged === </span><span class="s2">this</span><span class="s1">.props.onViewableItemsChanged,</span>
      <span class="s3">'Changing onViewableItemsChanged on the fly is not supported'</span><span class="s1">,</span>
    <span class="s1">);</span>
    <span class="s1">invariant(</span>
      <span class="s1">!deepDiffer(prevProps.viewabilityConfig, </span><span class="s2">this</span><span class="s1">.props.viewabilityConfig),</span>
      <span class="s3">'Changing viewabilityConfig on the fly is not supported'</span><span class="s1">,</span>
    <span class="s1">);</span>
    <span class="s1">invariant(</span>
      <span class="s1">prevProps.viewabilityConfigCallbackPairs ===</span>
        <span class="s2">this</span><span class="s1">.props.viewabilityConfigCallbackPairs,</span>
      <span class="s3">'Changing viewabilityConfigCallbackPairs on the fly is not supported'</span><span class="s1">,</span>
    <span class="s1">);</span>

    <span class="s2">this</span><span class="s1">._checkProps(</span><span class="s2">this</span><span class="s1">.props);</span>
  <span class="s1">}</span>

  <span class="s1">_listRef: ?React.ElementRef&lt;</span><span class="s2">typeof </span><span class="s1">VirtualizedList&gt;;</span>
  <span class="s1">_virtualizedListPairs: Array&lt;ViewabilityConfigCallbackPair&gt; = [];</span>

  <span class="s1">_captureRef = (ref: ?React.ElementRef&lt;</span><span class="s2">typeof </span><span class="s1">VirtualizedList&gt;) =&gt; {</span>
    <span class="s2">this</span><span class="s1">._listRef = ref;</span>
  <span class="s1">};</span>

  <span class="s0">// $FlowFixMe[missing-local-annot]</span>
  <span class="s1">_checkProps(props: Props&lt;ItemT&gt;) {</span>
    <span class="s1">const {</span>
      <span class="s0">// $FlowFixMe[prop-missing] this prop doesn't exist, is only used for an invariant</span>
      <span class="s1">getItem,</span>
      <span class="s0">// $FlowFixMe[prop-missing] this prop doesn't exist, is only used for an invariant</span>
      <span class="s1">getItemCount,</span>
      <span class="s1">horizontal,</span>
      <span class="s1">columnWrapperStyle,</span>
      <span class="s1">onViewableItemsChanged,</span>
      <span class="s1">viewabilityConfigCallbackPairs,</span>
    <span class="s1">} = props;</span>
    <span class="s1">const numColumns = numColumnsOrDefault(</span><span class="s2">this</span><span class="s1">.props.numColumns);</span>
    <span class="s1">invariant(</span>
      <span class="s1">!getItem &amp;&amp; !getItemCount,</span>
      <span class="s3">'FlatList does not support custom data formats.'</span><span class="s1">,</span>
    <span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(numColumns &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">invariant(!horizontal, </span><span class="s3">'numColumns does not support horizontal.'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">invariant(</span>
        <span class="s1">!columnWrapperStyle,</span>
        <span class="s3">'columnWrapperStyle not supported for single column lists'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">invariant(</span>
      <span class="s1">!(onViewableItemsChanged &amp;&amp; viewabilityConfigCallbackPairs),</span>
      <span class="s3">'FlatList does not support setting both onViewableItemsChanged and ' </span><span class="s1">+</span>
        <span class="s3">'viewabilityConfigCallbackPairs.'</span><span class="s1">,</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">_getItem = (</span>
    <span class="s1">data: $ArrayLike&lt;ItemT&gt;,</span>
    <span class="s1">index: number,</span>
  <span class="s1">): ?(ItemT | $ReadOnlyArray&lt;ItemT&gt;) =&gt; {</span>
    <span class="s1">const numColumns = numColumnsOrDefault(</span><span class="s2">this</span><span class="s1">.props.numColumns);</span>
    <span class="s2">if </span><span class="s1">(numColumns &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">const ret = [];</span>
      <span class="s2">for </span><span class="s1">(let kk = </span><span class="s4">0</span><span class="s1">; kk &lt; numColumns; kk++) {</span>
        <span class="s1">const itemIndex = index * numColumns + kk;</span>
        <span class="s2">if </span><span class="s1">(itemIndex &lt; data.length) {</span>
          <span class="s1">const item = data[itemIndex];</span>
          <span class="s1">ret.push(item);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">ret;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">data[index];</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_getItemCount = (data: ?$ArrayLike&lt;ItemT&gt;): number =&gt; {</span>
    <span class="s0">// Legacy behavior of FlatList was to forward &quot;undefined&quot; length if invalid</span>
    <span class="s0">// data like a non-arraylike object is passed. VirtualizedList would then</span>
    <span class="s0">// coerce this, and the math would work out to no-op. For compatibility, if</span>
    <span class="s0">// invalid data is passed, we tell VirtualizedList there are zero items</span>
    <span class="s0">// available to prevent it from trying to read from the invalid data</span>
    <span class="s0">// (without propagating invalidly typed data).</span>
    <span class="s2">if </span><span class="s1">(data != </span><span class="s2">null </span><span class="s1">&amp;&amp; isArrayLike(data)) {</span>
      <span class="s1">const numColumns = numColumnsOrDefault(</span><span class="s2">this</span><span class="s1">.props.numColumns);</span>
      <span class="s2">return </span><span class="s1">numColumns &gt; </span><span class="s4">1 </span><span class="s1">? Math.ceil(data.length / numColumns) : data.length;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_keyExtractor = (items: ItemT | Array&lt;ItemT&gt;, index: number): string =&gt; {</span>
    <span class="s1">const numColumns = numColumnsOrDefault(</span><span class="s2">this</span><span class="s1">.props.numColumns);</span>
    <span class="s1">const keyExtractor = </span><span class="s2">this</span><span class="s1">.props.keyExtractor ?? defaultKeyExtractor;</span>

    <span class="s2">if </span><span class="s1">(numColumns &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">invariant(</span>
        <span class="s1">Array.isArray(items),</span>
        <span class="s3">'FlatList: Encountered internal consistency error, expected each item to consist of an ' </span><span class="s1">+</span>
          <span class="s3">'array with 1-%s columns; instead, received a single item.'</span><span class="s1">,</span>
        <span class="s1">numColumns,</span>
      <span class="s1">);</span>
      <span class="s2">return </span><span class="s1">items</span>
        <span class="s1">.map((item, kk) =&gt;</span>
          <span class="s1">keyExtractor(((item: $FlowFixMe): ItemT), index * numColumns + kk),</span>
        <span class="s1">)</span>
        <span class="s1">.join(</span><span class="s3">':'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">// $FlowFixMe[incompatible-call] Can't call keyExtractor with an array</span>
    <span class="s2">return </span><span class="s1">keyExtractor(items, index);</span>
  <span class="s1">};</span>

  <span class="s1">_pushMultiColumnViewable(arr: Array&lt;ViewToken&gt;, v: ViewToken): </span><span class="s2">void </span><span class="s1">{</span>
    <span class="s1">const numColumns = numColumnsOrDefault(</span><span class="s2">this</span><span class="s1">.props.numColumns);</span>
    <span class="s1">const keyExtractor = </span><span class="s2">this</span><span class="s1">.props.keyExtractor ?? defaultKeyExtractor;</span>
    <span class="s1">v.item.forEach((item, ii) =&gt; {</span>
      <span class="s1">invariant(v.index != </span><span class="s2">null</span><span class="s1">, </span><span class="s3">'Missing index!'</span><span class="s1">);</span>
      <span class="s1">const index = v.index * numColumns + ii;</span>
      <span class="s1">arr.push({...v, item, key: keyExtractor(item, index), index});</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s1">_createOnViewableItemsChanged(</span>
    <span class="s1">onViewableItemsChanged: ?(info: {</span>
      <span class="s1">viewableItems: Array&lt;ViewToken&gt;,</span>
      <span class="s1">changed: Array&lt;ViewToken&gt;,</span>
      <span class="s1">...</span>
    <span class="s1">}) =&gt; </span><span class="s2">void</span><span class="s1">,</span>
    <span class="s0">// $FlowFixMe[missing-local-annot]</span>
  <span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">(info: {</span>
      <span class="s1">viewableItems: Array&lt;ViewToken&gt;,</span>
      <span class="s1">changed: Array&lt;ViewToken&gt;,</span>
      <span class="s1">...</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s1">const numColumns = numColumnsOrDefault(</span><span class="s2">this</span><span class="s1">.props.numColumns);</span>
      <span class="s2">if </span><span class="s1">(onViewableItemsChanged) {</span>
        <span class="s2">if </span><span class="s1">(numColumns &gt; </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">const changed: Array&lt;ViewToken&gt; = [];</span>
          <span class="s1">const viewableItems: Array&lt;ViewToken&gt; = [];</span>
          <span class="s1">info.viewableItems.forEach(v =&gt;</span>
            <span class="s2">this</span><span class="s1">._pushMultiColumnViewable(viewableItems, v),</span>
          <span class="s1">);</span>
          <span class="s1">info.changed.forEach(v =&gt; </span><span class="s2">this</span><span class="s1">._pushMultiColumnViewable(changed, v));</span>
          <span class="s1">onViewableItemsChanged({viewableItems, changed});</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">onViewableItemsChanged(info);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">_renderer = (</span>
    <span class="s1">ListItemComponent: ?(React.ComponentType&lt;any&gt; | React.Element&lt;any&gt;),</span>
    <span class="s1">renderItem: ?RenderItemType&lt;ItemT&gt;,</span>
    <span class="s1">columnWrapperStyle: ?ViewStyleProp,</span>
    <span class="s1">numColumns: ?number,</span>
    <span class="s1">extraData: ?any,</span>
    <span class="s0">// $FlowFixMe[missing-local-annot]</span>
  <span class="s1">) =&gt; {</span>
    <span class="s1">const cols = numColumnsOrDefault(numColumns);</span>

    <span class="s1">const render = (props: RenderItemProps&lt;ItemT&gt;): React.Node =&gt; {</span>
      <span class="s2">if </span><span class="s1">(ListItemComponent) {</span>
        <span class="s0">// $FlowFixMe[not-a-component] Component isn't valid</span>
        <span class="s0">// $FlowFixMe[incompatible-type-arg] Component isn't valid</span>
        <span class="s0">// $FlowFixMe[incompatible-return] Component isn't valid</span>
        <span class="s2">return </span><span class="s1">&lt;ListItemComponent {...props} /&gt;;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(renderItem) {</span>
        <span class="s0">// $FlowFixMe[incompatible-call]</span>
        <span class="s2">return </span><span class="s1">renderItem(props);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">const renderProp = (info: RenderItemProps&lt;ItemT&gt;) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(cols &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">const {item, index} = info;</span>
        <span class="s1">invariant(</span>
          <span class="s1">Array.isArray(item),</span>
          <span class="s3">'Expected array of items with numColumns &gt; 1'</span><span class="s1">,</span>
        <span class="s1">);</span>
        <span class="s2">return </span><span class="s1">(</span>
          <span class="s1">&lt;View style={StyleSheet.compose(styles.row, columnWrapperStyle)}&gt;</span>
            <span class="s1">{item.map((it, kk) =&gt; {</span>
              <span class="s1">const element = render({</span>
                <span class="s0">// $FlowFixMe[incompatible-call]</span>
                <span class="s1">item: it,</span>
                <span class="s1">index: index * cols + kk,</span>
                <span class="s1">separators: info.separators,</span>
              <span class="s1">});</span>
              <span class="s2">return </span><span class="s1">element != </span><span class="s2">null </span><span class="s1">? (</span>
                <span class="s1">&lt;React.Fragment key={kk}&gt;{element}&lt;/React.Fragment&gt;</span>
              <span class="s1">) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">})}</span>
          <span class="s1">&lt;/View&gt;</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">render(info);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">ListItemComponent</span>
      <span class="s1">? {ListItemComponent: renderProp}</span>
      <span class="s1">: {renderItem: renderProp};</span>
  <span class="s1">};</span>

  <span class="s0">// $FlowFixMe[missing-local-annot]</span>
  <span class="s1">_memoizedRenderer = memoizeOne(</span><span class="s2">this</span><span class="s1">._renderer);</span>

  <span class="s1">render(): React.Node {</span>
    <span class="s1">const {</span>
      <span class="s1">numColumns,</span>
      <span class="s1">columnWrapperStyle,</span>
      <span class="s1">removeClippedSubviews: _removeClippedSubviews,</span>
      <span class="s1">strictMode = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">...restProps</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>

    <span class="s1">const renderer = strictMode ? </span><span class="s2">this</span><span class="s1">._memoizedRenderer : </span><span class="s2">this</span><span class="s1">._renderer;</span>

    <span class="s2">return </span><span class="s1">(</span>
      <span class="s0">// $FlowFixMe[incompatible-exact] - `restProps` (`Props`) is inexact.</span>
      <span class="s1">&lt;VirtualizedList</span>
        <span class="s1">{...restProps}</span>
        <span class="s1">getItem={</span><span class="s2">this</span><span class="s1">._getItem}</span>
        <span class="s1">getItemCount={</span><span class="s2">this</span><span class="s1">._getItemCount}</span>
        <span class="s1">keyExtractor={</span><span class="s2">this</span><span class="s1">._keyExtractor}</span>
        <span class="s1">ref={</span><span class="s2">this</span><span class="s1">._captureRef}</span>
        <span class="s1">viewabilityConfigCallbackPairs={</span><span class="s2">this</span><span class="s1">._virtualizedListPairs}</span>
        <span class="s1">removeClippedSubviews={removeClippedSubviewsOrDefault(</span>
          <span class="s1">_removeClippedSubviews,</span>
        <span class="s1">)}</span>
        <span class="s1">{...renderer(</span>
          <span class="s2">this</span><span class="s1">.props.ListItemComponent,</span>
          <span class="s2">this</span><span class="s1">.props.renderItem,</span>
          <span class="s1">columnWrapperStyle,</span>
          <span class="s1">numColumns,</span>
          <span class="s2">this</span><span class="s1">.props.extraData,</span>
        <span class="s1">)}</span>
      <span class="s1">/&gt;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">const styles = StyleSheet.create({</span>
  <span class="s1">row: {flexDirection: </span><span class="s3">'row'</span><span class="s1">},</span>
<span class="s1">});</span>

<span class="s1">module.exports = FlatList;</span>
</pre>
</body>
</html>
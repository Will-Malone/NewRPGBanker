<html>
<head>
<title>test.html</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #e8bf6a;}
.s1 { color: #a9b7c6;}
.s2 { color: #bababa;}
.s3 { color: #a5c261;}
.s4 { color: #6d9cbe;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test.html</font>
</center></td></tr></table>
<pre><span class="s0">&lt;!doctype </span><span class="s2">html</span><span class="s0">&gt;&lt;html&gt;&lt;head&gt;&lt;meta </span><span class="s2">charset</span><span class="s3">=&quot;utf-8&quot;</span><span class="s0">&gt;&lt;/head&gt;&lt;body&gt;&lt;pre </span><span class="s2">id</span><span class="s3">=&quot;__testling_output&quot;</span><span class="s0">&gt;&lt;/pre&gt;&lt;script&gt;</span><span class="s1">(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;</span><span class="s4">&amp;require;</span><span class="s1">if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);throw new Error(&quot;Cannot find module '&quot;+o+&quot;'&quot;)}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;</span><span class="s4">&amp;require;</span><span class="s1">for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){</span>
<span class="s1">(function (process){</span>
<span class="s1">var xws = require('xhr-write-stream');</span>
<span class="s1">var Stream = require('stream');</span>
<span class="s1">var inspect = require('object-inspect');</span>

<span class="s1">process.on = function () {};</span>
<span class="s1">var ws = xws('/__testling/sock');</span>
<span class="s1">ws.write(window.location.hash + '\n');</span>

<span class="s1">function createChannel (writeListen) {</span>
    <span class="s1">var c = new Stream;</span>
    <span class="s1">c.writable = true;</span>
    <span class="s1">c.write = function (buf) {</span>
        <span class="s1">if (writeListen) writeListen(buf);</span>
        <span class="s1">return ws.write(String(buf));</span>
    <span class="s1">};</span>
    <span class="s1">c.destroy = function () {};</span>
    <span class="s1">c.end = function (buf) {</span>
        <span class="s1">c.emit('close');</span>
    <span class="s1">};</span>
    
    <span class="s1">return c;</span>
<span class="s1">}</span>

<span class="s1">var lastTestId = 0;</span>
<span class="s1">process.stdout = createChannel(function (buf) {</span>
    <span class="s1">var m = /^(?:not )? ok (\d+)/.exec(String(buf));</span>
    <span class="s1">if (m) lastTestId = m[1];</span>
<span class="s1">});</span>
<span class="s1">process.stderr = createChannel();</span>
<span class="s1">process.stdout.on('close', function () { ws.end() });</span>
<span class="s1">process.exit = function () { ws.end() };</span>

<span class="s1">var oldError = window.onerror;</span>
<span class="s1">window.onerror = function (err, url, lineNum) {</span>
    <span class="s1">var type = err &amp;&amp; err.name || 'Error';</span>
    <span class="s1">process.stdout.write(</span>
        <span class="s1">'not ok ' + (lastTestId + 1) + ' ' + type + ': '</span>
        <span class="s1">+ (err &amp;&amp; err.message || String(err))</span>
        <span class="s1">+ (lineNum ? ' on line ' + lineNum : '')</span>
        <span class="s1">+ '\n'</span>
    <span class="s1">);</span>
    <span class="s1">if (err &amp;&amp; err.stack) {</span>
        <span class="s1">var lines = String(err.stack).split('\n');</span>
        <span class="s1">var xs = [];</span>
        <span class="s1">for (var i = 0; i &lt; lines.length; i++) {</span>
            <span class="s1">xs.push('      ' + lines[i]);</span>
        <span class="s1">}</span>
        
        <span class="s1">process.stdout.write([</span>
            <span class="s1">'  ---',</span>
            <span class="s1">'    stack:',</span>
            <span class="s1">xs.join('\n'),</span>
            <span class="s1">'  ...'</span>
        <span class="s1">].join('\n') + '\n');</span>
    <span class="s1">}</span>
    <span class="s1">ws.end();</span>
    
    <span class="s1">if (typeof oldError === 'function') {</span>
        <span class="s1">return oldError.apply(this, arguments);</span>
    <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">window.__testlingErrorHandler = onerror;</span>

<span class="s1">if (typeof console === 'undefined') {</span>
    <span class="s1">console = {};</span>
<span class="s1">}</span>

<span class="s1">var params = (function () {</span>
    <span class="s1">var unesc = typeof decodeURIComponent !== 'undefined'</span>
        <span class="s1">? decodeURIComponent : unescape</span>
    <span class="s1">;</span>
    <span class="s1">var parts = (window.location.search || '').replace(/^\?/, '').split('&amp;');</span>
    <span class="s1">var opts = {};</span>
    <span class="s1">for (var i = 0; i &lt; parts.length; i++) {</span>
        <span class="s1">var x = parts[i].split('=');</span>
        <span class="s1">opts[unesc(x[0])] = unesc(x[1]);</span>
    <span class="s1">}</span>
    <span class="s1">return opts;</span>
<span class="s1">})();</span>

<span class="s1">var originalLog = console.log;</span>
<span class="s1">console.log = function (msg) {</span>
    <span class="s1">var index = 1;</span>
    <span class="s1">var args = arguments;</span>
    
    <span class="s1">if (typeof msg === 'string') {</span>
        <span class="s1">msg = msg.replace(/(^|[^%])%[sd]/g, function (_, s) {</span>
            <span class="s1">return s + args[index++];</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">else msg = inspect(msg);</span>
    
    <span class="s1">for (var i = index; i &lt; args.length; i++) {</span>
        <span class="s1">msg += ' ' + inspect(args[i]);</span>
    <span class="s1">}</span>
    
    <span class="s1">if (params.show === undefined || parseBoolean(params.show)) {</span>
        <span class="s1">var elem = document.getElementById('__testling_output');</span>
        <span class="s1">if (elem) {</span>
            <span class="s1">var txt = document.createTextNode(msg + '\n');</span>
            <span class="s1">elem.appendChild(txt);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">process.stdout.write(msg + '\n');</span>
    
    <span class="s1">if (typeof originalLog === 'function') {</span>
        <span class="s1">return originalLog.apply(this, arguments);</span>
    <span class="s1">}</span>
    <span class="s1">else if (originalLog) return originalLog(arguments[0]);</span>
<span class="s1">};</span>

<span class="s1">window.__testlingConsole = console;</span>

<span class="s1">function parseBoolean (x) {</span>
    <span class="s1">if (x === 'false' || x === '0') return false;</span>
    <span class="s1">return true;</span>
<span class="s1">}</span>

<span class="s1">}).call(this,require(&quot;g5I+bs&quot;))</span>
<span class="s1">},{&quot;g5I+bs&quot;:13,&quot;object-inspect&quot;:11,&quot;stream&quot;:19,&quot;xhr-write-stream&quot;:30}],2:[function(require,module,exports){</span>
<span class="s1">;(function () {</span>

  <span class="s1">var object = typeof exports != 'undefined' ? exports : this; // #8: web workers</span>
  <span class="s1">var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';</span>

  <span class="s1">function InvalidCharacterError(message) {</span>
    <span class="s1">this.message = message;</span>
  <span class="s1">}</span>
  <span class="s1">InvalidCharacterError.prototype = new Error;</span>
  <span class="s1">InvalidCharacterError.prototype.name = 'InvalidCharacterError';</span>

  <span class="s1">// encoder</span>
  <span class="s1">// [https://gist.github.com/999166] by [https://github.com/nignag]</span>
  <span class="s1">object.btoa || (</span>
  <span class="s1">object.btoa = function (input) {</span>
    <span class="s1">for (</span>
      <span class="s1">// initialize result and counter</span>
      <span class="s1">var block, charCode, idx = 0, map = chars, output = '';</span>
      <span class="s1">// if the next input index does not exist:</span>
      <span class="s1">//   change the mapping table to &quot;=&quot;</span>
      <span class="s1">//   check if d has no fractional digits</span>
      <span class="s1">input.charAt(idx | 0) || (map = '=', idx % 1);</span>
      <span class="s1">// &quot;8 - idx % 1 * 8&quot; generates the sequence 2, 4, 6, 8</span>
      <span class="s1">output += map.charAt(63 &amp; block &gt;&gt; 8 - idx % 1 * 8)</span>
    <span class="s1">) {</span>
      <span class="s1">charCode = input.charCodeAt(idx += 3/4);</span>
      <span class="s1">if (charCode &gt; 0xFF) {</span>
        <span class="s1">throw new InvalidCharacterError(&quot;'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.&quot;);</span>
      <span class="s1">}</span>
      <span class="s1">block = block &lt;&lt; 8 | charCode;</span>
    <span class="s1">}</span>
    <span class="s1">return output;</span>
  <span class="s1">});</span>

  <span class="s1">// decoder</span>
  <span class="s1">// [https://gist.github.com/1020396] by [https://github.com/atk]</span>
  <span class="s1">object.atob || (</span>
  <span class="s1">object.atob = function (input) {</span>
    <span class="s1">input = input.replace(/=+$/, '');</span>
    <span class="s1">if (input.length % 4 == 1) {</span>
      <span class="s1">throw new InvalidCharacterError(&quot;'atob' failed: The string to be decoded is not correctly encoded.&quot;);</span>
    <span class="s1">}</span>
    <span class="s1">for (</span>
      <span class="s1">// initialize result and counters</span>
      <span class="s1">var bc = 0, bs, buffer, idx = 0, output = '';</span>
      <span class="s1">// get next character</span>
      <span class="s1">buffer = input.charAt(idx++);</span>
      <span class="s1">// character found in table? initialize bit storage and add its ascii value;</span>
      <span class="s1">~buffer &amp;&amp; (bs = bc % 4 ? bs * 64 + buffer : buffer,</span>
        <span class="s1">// and if not first of each 4 characters,</span>
        <span class="s1">// convert the first 8 bits to one ascii character</span>
        <span class="s1">bc++ % 4) ? output += String.fromCharCode(255 &amp; bs &gt;&gt; (-2 * bc &amp; 6)) : 0</span>
    <span class="s1">) {</span>
      <span class="s1">// try to find character in table (0-63, not found =&gt; -1)</span>
      <span class="s1">buffer = chars.indexOf(buffer);</span>
    <span class="s1">}</span>
    <span class="s1">return output;</span>
  <span class="s1">});</span>

<span class="s1">}());</span>

<span class="s1">},{}],3:[function(require,module,exports){</span>
<span class="s1">/*!</span>
 <span class="s1">* The buffer module from node.js, for the browser.</span>
 <span class="s1">*</span>
 <span class="s1">* @author   Feross Aboukhadijeh &lt;feross@feross.org&gt; &lt;http://feross.org&gt;</span>
 <span class="s1">* @license  MIT</span>
 <span class="s1">*/</span>

<span class="s1">var base64 = require('base64-js')</span>
<span class="s1">var ieee754 = require('ieee754')</span>

<span class="s1">exports.Buffer = Buffer</span>
<span class="s1">exports.SlowBuffer = Buffer</span>
<span class="s1">exports.INSPECT_MAX_BYTES = 50</span>
<span class="s1">Buffer.poolSize = 8192</span>

<span class="s1">/**</span>
 <span class="s1">* If `Buffer._useTypedArrays`:</span>
 <span class="s1">*   === true    Use Uint8Array implementation (fastest)</span>
 <span class="s1">*   === false   Use Object implementation (compatible down to IE6)</span>
 <span class="s1">*/</span>
<span class="s1">Buffer._useTypedArrays = (function () {</span>
  <span class="s1">// Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,</span>
  <span class="s1">// Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding</span>
  <span class="s1">// properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support</span>
  <span class="s1">// because we need to be able to add all the node Buffer API methods. This is an issue</span>
  <span class="s1">// in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438</span>
  <span class="s1">try {</span>
    <span class="s1">var buf = new ArrayBuffer(0)</span>
    <span class="s1">var arr = new Uint8Array(buf)</span>
    <span class="s1">arr.foo = function () { return 42 }</span>
    <span class="s1">return 42 === arr.foo() &amp;&amp;</span>
        <span class="s1">typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`</span>
  <span class="s1">} catch (e) {</span>
    <span class="s1">return false</span>
  <span class="s1">}</span>
<span class="s1">})()</span>

<span class="s1">/**</span>
 <span class="s1">* Class: Buffer</span>
 <span class="s1">* =============</span>
 <span class="s1">*</span>
 <span class="s1">* The Buffer constructor returns instances of `Uint8Array` that are augmented</span>
 <span class="s1">* with function properties for all the node `Buffer` API functions. We use</span>
 <span class="s1">* `Uint8Array` so that square bracket notation works as expected -- it returns</span>
 <span class="s1">* a single octet.</span>
 <span class="s1">*</span>
 <span class="s1">* By augmenting the instances, we can avoid modifying the `Uint8Array`</span>
 <span class="s1">* prototype.</span>
 <span class="s1">*/</span>
<span class="s1">function Buffer (subject, encoding, noZero) {</span>
  <span class="s1">if (!(this instanceof Buffer))</span>
    <span class="s1">return new Buffer(subject, encoding, noZero)</span>

  <span class="s1">var type = typeof subject</span>

  <span class="s1">// Workaround: node's base64 implementation allows for non-padded strings</span>
  <span class="s1">// while base64-js does not.</span>
  <span class="s1">if (encoding === 'base64' &amp;&amp; type === 'string') {</span>
    <span class="s1">subject = stringtrim(subject)</span>
    <span class="s1">while (subject.length % 4 !== 0) {</span>
      <span class="s1">subject = subject + '='</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">// Find the length</span>
  <span class="s1">var length</span>
  <span class="s1">if (type === 'number')</span>
    <span class="s1">length = coerce(subject)</span>
  <span class="s1">else if (type === 'string')</span>
    <span class="s1">length = Buffer.byteLength(subject, encoding)</span>
  <span class="s1">else if (type === 'object')</span>
    <span class="s1">length = coerce(subject.length) // assume that object is array-like</span>
  <span class="s1">else</span>
    <span class="s1">throw new Error('First argument needs to be a number, array or string.')</span>

  <span class="s1">var buf</span>
  <span class="s1">if (Buffer._useTypedArrays) {</span>
    <span class="s1">// Preferred: Return an augmented `Uint8Array` instance for best performance</span>
    <span class="s1">buf = Buffer._augment(new Uint8Array(length))</span>
  <span class="s1">} else {</span>
    <span class="s1">// Fallback: Return THIS instance of Buffer (created by `new`)</span>
    <span class="s1">buf = this</span>
    <span class="s1">buf.length = length</span>
    <span class="s1">buf._isBuffer = true</span>
  <span class="s1">}</span>

  <span class="s1">var i</span>
  <span class="s1">if (Buffer._useTypedArrays &amp;&amp; typeof subject.byteLength === 'number') {</span>
    <span class="s1">// Speed optimization -- use set if we're copying from a typed array</span>
    <span class="s1">buf._set(subject)</span>
  <span class="s1">} else if (isArrayish(subject)) {</span>
    <span class="s1">// Treat array-ish objects as a byte array</span>
    <span class="s1">for (i = 0; i &lt; length; i++) {</span>
      <span class="s1">if (Buffer.isBuffer(subject))</span>
        <span class="s1">buf[i] = subject.readUInt8(i)</span>
      <span class="s1">else</span>
        <span class="s1">buf[i] = subject[i]</span>
    <span class="s1">}</span>
  <span class="s1">} else if (type === 'string') {</span>
    <span class="s1">buf.write(subject, 0, encoding)</span>
  <span class="s1">} else if (type === 'number' &amp;&amp; !Buffer._useTypedArrays &amp;&amp; !noZero) {</span>
    <span class="s1">for (i = 0; i &lt; length; i++) {</span>
      <span class="s1">buf[i] = 0</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return buf</span>
<span class="s1">}</span>

<span class="s1">// STATIC METHODS</span>
<span class="s1">// ==============</span>

<span class="s1">Buffer.isEncoding = function (encoding) {</span>
  <span class="s1">switch (String(encoding).toLowerCase()) {</span>
    <span class="s1">case 'hex':</span>
    <span class="s1">case 'utf8':</span>
    <span class="s1">case 'utf-8':</span>
    <span class="s1">case 'ascii':</span>
    <span class="s1">case 'binary':</span>
    <span class="s1">case 'base64':</span>
    <span class="s1">case 'raw':</span>
    <span class="s1">case 'ucs2':</span>
    <span class="s1">case 'ucs-2':</span>
    <span class="s1">case 'utf16le':</span>
    <span class="s1">case 'utf-16le':</span>
      <span class="s1">return true</span>
    <span class="s1">default:</span>
      <span class="s1">return false</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Buffer.isBuffer = function (b) {</span>
  <span class="s1">return !!(b !== null &amp;&amp; b !== undefined &amp;&amp; b._isBuffer)</span>
<span class="s1">}</span>

<span class="s1">Buffer.byteLength = function (str, encoding) {</span>
  <span class="s1">var ret</span>
  <span class="s1">str = str + ''</span>
  <span class="s1">switch (encoding || 'utf8') {</span>
    <span class="s1">case 'hex':</span>
      <span class="s1">ret = str.length / 2</span>
      <span class="s1">break</span>
    <span class="s1">case 'utf8':</span>
    <span class="s1">case 'utf-8':</span>
      <span class="s1">ret = utf8ToBytes(str).length</span>
      <span class="s1">break</span>
    <span class="s1">case 'ascii':</span>
    <span class="s1">case 'binary':</span>
    <span class="s1">case 'raw':</span>
      <span class="s1">ret = str.length</span>
      <span class="s1">break</span>
    <span class="s1">case 'base64':</span>
      <span class="s1">ret = base64ToBytes(str).length</span>
      <span class="s1">break</span>
    <span class="s1">case 'ucs2':</span>
    <span class="s1">case 'ucs-2':</span>
    <span class="s1">case 'utf16le':</span>
    <span class="s1">case 'utf-16le':</span>
      <span class="s1">ret = str.length * 2</span>
      <span class="s1">break</span>
    <span class="s1">default:</span>
      <span class="s1">throw new Error('Unknown encoding')</span>
  <span class="s1">}</span>
  <span class="s1">return ret</span>
<span class="s1">}</span>

<span class="s1">Buffer.concat = function (list, totalLength) {</span>
  <span class="s1">assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +</span>
      <span class="s1">'list should be an Array.')</span>

  <span class="s1">if (list.length === 0) {</span>
    <span class="s1">return new Buffer(0)</span>
  <span class="s1">} else if (list.length === 1) {</span>
    <span class="s1">return list[0]</span>
  <span class="s1">}</span>

  <span class="s1">var i</span>
  <span class="s1">if (typeof totalLength !== 'number') {</span>
    <span class="s1">totalLength = 0</span>
    <span class="s1">for (i = 0; i &lt; list.length; i++) {</span>
      <span class="s1">totalLength += list[i].length</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">var buf = new Buffer(totalLength)</span>
  <span class="s1">var pos = 0</span>
  <span class="s1">for (i = 0; i &lt; list.length; i++) {</span>
    <span class="s1">var item = list[i]</span>
    <span class="s1">item.copy(buf, pos)</span>
    <span class="s1">pos += item.length</span>
  <span class="s1">}</span>
  <span class="s1">return buf</span>
<span class="s1">}</span>

<span class="s1">// BUFFER INSTANCE METHODS</span>
<span class="s1">// =======================</span>

<span class="s1">function _hexWrite (buf, string, offset, length) {</span>
  <span class="s1">offset = Number(offset) || 0</span>
  <span class="s1">var remaining = buf.length - offset</span>
  <span class="s1">if (!length) {</span>
    <span class="s1">length = remaining</span>
  <span class="s1">} else {</span>
    <span class="s1">length = Number(length)</span>
    <span class="s1">if (length &gt; remaining) {</span>
      <span class="s1">length = remaining</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">// must be an even number of digits</span>
  <span class="s1">var strLen = string.length</span>
  <span class="s1">assert(strLen % 2 === 0, 'Invalid hex string')</span>

  <span class="s1">if (length &gt; strLen / 2) {</span>
    <span class="s1">length = strLen / 2</span>
  <span class="s1">}</span>
  <span class="s1">for (var i = 0; i &lt; length; i++) {</span>
    <span class="s1">var byte = parseInt(string.substr(i * 2, 2), 16)</span>
    <span class="s1">assert(!isNaN(byte), 'Invalid hex string')</span>
    <span class="s1">buf[offset + i] = byte</span>
  <span class="s1">}</span>
  <span class="s1">Buffer._charsWritten = i * 2</span>
  <span class="s1">return i</span>
<span class="s1">}</span>

<span class="s1">function _utf8Write (buf, string, offset, length) {</span>
  <span class="s1">var charsWritten = Buffer._charsWritten =</span>
    <span class="s1">blitBuffer(utf8ToBytes(string), buf, offset, length)</span>
  <span class="s1">return charsWritten</span>
<span class="s1">}</span>

<span class="s1">function _asciiWrite (buf, string, offset, length) {</span>
  <span class="s1">var charsWritten = Buffer._charsWritten =</span>
    <span class="s1">blitBuffer(asciiToBytes(string), buf, offset, length)</span>
  <span class="s1">return charsWritten</span>
<span class="s1">}</span>

<span class="s1">function _binaryWrite (buf, string, offset, length) {</span>
  <span class="s1">return _asciiWrite(buf, string, offset, length)</span>
<span class="s1">}</span>

<span class="s1">function _base64Write (buf, string, offset, length) {</span>
  <span class="s1">var charsWritten = Buffer._charsWritten =</span>
    <span class="s1">blitBuffer(base64ToBytes(string), buf, offset, length)</span>
  <span class="s1">return charsWritten</span>
<span class="s1">}</span>

<span class="s1">function _utf16leWrite (buf, string, offset, length) {</span>
  <span class="s1">var charsWritten = Buffer._charsWritten =</span>
    <span class="s1">blitBuffer(utf16leToBytes(string), buf, offset, length)</span>
  <span class="s1">return charsWritten</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.write = function (string, offset, length, encoding) {</span>
  <span class="s1">// Support both (string, offset, length, encoding)</span>
  <span class="s1">// and the legacy (string, encoding, offset, length)</span>
  <span class="s1">if (isFinite(offset)) {</span>
    <span class="s1">if (!isFinite(length)) {</span>
      <span class="s1">encoding = length</span>
      <span class="s1">length = undefined</span>
    <span class="s1">}</span>
  <span class="s1">} else {  // legacy</span>
    <span class="s1">var swap = encoding</span>
    <span class="s1">encoding = offset</span>
    <span class="s1">offset = length</span>
    <span class="s1">length = swap</span>
  <span class="s1">}</span>

  <span class="s1">offset = Number(offset) || 0</span>
  <span class="s1">var remaining = this.length - offset</span>
  <span class="s1">if (!length) {</span>
    <span class="s1">length = remaining</span>
  <span class="s1">} else {</span>
    <span class="s1">length = Number(length)</span>
    <span class="s1">if (length &gt; remaining) {</span>
      <span class="s1">length = remaining</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">encoding = String(encoding || 'utf8').toLowerCase()</span>

  <span class="s1">var ret</span>
  <span class="s1">switch (encoding) {</span>
    <span class="s1">case 'hex':</span>
      <span class="s1">ret = _hexWrite(this, string, offset, length)</span>
      <span class="s1">break</span>
    <span class="s1">case 'utf8':</span>
    <span class="s1">case 'utf-8':</span>
      <span class="s1">ret = _utf8Write(this, string, offset, length)</span>
      <span class="s1">break</span>
    <span class="s1">case 'ascii':</span>
      <span class="s1">ret = _asciiWrite(this, string, offset, length)</span>
      <span class="s1">break</span>
    <span class="s1">case 'binary':</span>
      <span class="s1">ret = _binaryWrite(this, string, offset, length)</span>
      <span class="s1">break</span>
    <span class="s1">case 'base64':</span>
      <span class="s1">ret = _base64Write(this, string, offset, length)</span>
      <span class="s1">break</span>
    <span class="s1">case 'ucs2':</span>
    <span class="s1">case 'ucs-2':</span>
    <span class="s1">case 'utf16le':</span>
    <span class="s1">case 'utf-16le':</span>
      <span class="s1">ret = _utf16leWrite(this, string, offset, length)</span>
      <span class="s1">break</span>
    <span class="s1">default:</span>
      <span class="s1">throw new Error('Unknown encoding')</span>
  <span class="s1">}</span>
  <span class="s1">return ret</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.toString = function (encoding, start, end) {</span>
  <span class="s1">var self = this</span>

  <span class="s1">encoding = String(encoding || 'utf8').toLowerCase()</span>
  <span class="s1">start = Number(start) || 0</span>
  <span class="s1">end = (end !== undefined)</span>
    <span class="s1">? Number(end)</span>
    <span class="s1">: end = self.length</span>

  <span class="s1">// Fastpath empty strings</span>
  <span class="s1">if (end === start)</span>
    <span class="s1">return ''</span>

  <span class="s1">var ret</span>
  <span class="s1">switch (encoding) {</span>
    <span class="s1">case 'hex':</span>
      <span class="s1">ret = _hexSlice(self, start, end)</span>
      <span class="s1">break</span>
    <span class="s1">case 'utf8':</span>
    <span class="s1">case 'utf-8':</span>
      <span class="s1">ret = _utf8Slice(self, start, end)</span>
      <span class="s1">break</span>
    <span class="s1">case 'ascii':</span>
      <span class="s1">ret = _asciiSlice(self, start, end)</span>
      <span class="s1">break</span>
    <span class="s1">case 'binary':</span>
      <span class="s1">ret = _binarySlice(self, start, end)</span>
      <span class="s1">break</span>
    <span class="s1">case 'base64':</span>
      <span class="s1">ret = _base64Slice(self, start, end)</span>
      <span class="s1">break</span>
    <span class="s1">case 'ucs2':</span>
    <span class="s1">case 'ucs-2':</span>
    <span class="s1">case 'utf16le':</span>
    <span class="s1">case 'utf-16le':</span>
      <span class="s1">ret = _utf16leSlice(self, start, end)</span>
      <span class="s1">break</span>
    <span class="s1">default:</span>
      <span class="s1">throw new Error('Unknown encoding')</span>
  <span class="s1">}</span>
  <span class="s1">return ret</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.toJSON = function () {</span>
  <span class="s1">return {</span>
    <span class="s1">type: 'Buffer',</span>
    <span class="s1">data: Array.prototype.slice.call(this._arr || this, 0)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</span>
<span class="s1">Buffer.prototype.copy = function (target, target_start, start, end) {</span>
  <span class="s1">var source = this</span>

  <span class="s1">if (!start) start = 0</span>
  <span class="s1">if (!end &amp;&amp; end !== 0) end = this.length</span>
  <span class="s1">if (!target_start) target_start = 0</span>

  <span class="s1">// Copy 0 bytes; we're done</span>
  <span class="s1">if (end === start) return</span>
  <span class="s1">if (target.length === 0 || source.length === 0) return</span>

  <span class="s1">// Fatal error conditions</span>
  <span class="s1">assert(end &gt;= start, 'sourceEnd &lt; sourceStart')</span>
  <span class="s1">assert(target_start &gt;= 0 &amp;&amp; target_start &lt; target.length,</span>
      <span class="s1">'targetStart out of bounds')</span>
  <span class="s1">assert(start &gt;= 0 &amp;&amp; start &lt; source.length, 'sourceStart out of bounds')</span>
  <span class="s1">assert(end &gt;= 0 &amp;&amp; end &lt;= source.length, 'sourceEnd out of bounds')</span>

  <span class="s1">// Are we oob?</span>
  <span class="s1">if (end &gt; this.length)</span>
    <span class="s1">end = this.length</span>
  <span class="s1">if (target.length - target_start &lt; end - start)</span>
    <span class="s1">end = target.length - target_start + start</span>

  <span class="s1">var len = end - start</span>

  <span class="s1">if (len &lt; 100 || !Buffer._useTypedArrays) {</span>
    <span class="s1">for (var i = 0; i &lt; len; i++)</span>
      <span class="s1">target[i + target_start] = this[i + start]</span>
  <span class="s1">} else {</span>
    <span class="s1">target._set(this.subarray(start, start + len), target_start)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function _base64Slice (buf, start, end) {</span>
  <span class="s1">if (start === 0 &amp;&amp; end === buf.length) {</span>
    <span class="s1">return base64.fromByteArray(buf)</span>
  <span class="s1">} else {</span>
    <span class="s1">return base64.fromByteArray(buf.slice(start, end))</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function _utf8Slice (buf, start, end) {</span>
  <span class="s1">var res = ''</span>
  <span class="s1">var tmp = ''</span>
  <span class="s1">end = Math.min(buf.length, end)</span>

  <span class="s1">for (var i = start; i &lt; end; i++) {</span>
    <span class="s1">if (buf[i] &lt;= 0x7F) {</span>
      <span class="s1">res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])</span>
      <span class="s1">tmp = ''</span>
    <span class="s1">} else {</span>
      <span class="s1">tmp += '%' + buf[i].toString(16)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return res + decodeUtf8Char(tmp)</span>
<span class="s1">}</span>

<span class="s1">function _asciiSlice (buf, start, end) {</span>
  <span class="s1">var ret = ''</span>
  <span class="s1">end = Math.min(buf.length, end)</span>

  <span class="s1">for (var i = start; i &lt; end; i++)</span>
    <span class="s1">ret += String.fromCharCode(buf[i])</span>
  <span class="s1">return ret</span>
<span class="s1">}</span>

<span class="s1">function _binarySlice (buf, start, end) {</span>
  <span class="s1">return _asciiSlice(buf, start, end)</span>
<span class="s1">}</span>

<span class="s1">function _hexSlice (buf, start, end) {</span>
  <span class="s1">var len = buf.length</span>

  <span class="s1">if (!start || start &lt; 0) start = 0</span>
  <span class="s1">if (!end || end &lt; 0 || end &gt; len) end = len</span>

  <span class="s1">var out = ''</span>
  <span class="s1">for (var i = start; i &lt; end; i++) {</span>
    <span class="s1">out += toHex(buf[i])</span>
  <span class="s1">}</span>
  <span class="s1">return out</span>
<span class="s1">}</span>

<span class="s1">function _utf16leSlice (buf, start, end) {</span>
  <span class="s1">var bytes = buf.slice(start, end)</span>
  <span class="s1">var res = ''</span>
  <span class="s1">for (var i = 0; i &lt; bytes.length; i += 2) {</span>
    <span class="s1">res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)</span>
  <span class="s1">}</span>
  <span class="s1">return res</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.slice = function (start, end) {</span>
  <span class="s1">var len = this.length</span>
  <span class="s1">start = clamp(start, len, 0)</span>
  <span class="s1">end = clamp(end, len, len)</span>

  <span class="s1">if (Buffer._useTypedArrays) {</span>
    <span class="s1">return Buffer._augment(this.subarray(start, end))</span>
  <span class="s1">} else {</span>
    <span class="s1">var sliceLen = end - start</span>
    <span class="s1">var newBuf = new Buffer(sliceLen, undefined, true)</span>
    <span class="s1">for (var i = 0; i &lt; sliceLen; i++) {</span>
      <span class="s1">newBuf[i] = this[i + start]</span>
    <span class="s1">}</span>
    <span class="s1">return newBuf</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">// `get` will be removed in Node 0.13+</span>
<span class="s1">Buffer.prototype.get = function (offset) {</span>
  <span class="s1">console.log('.get() is deprecated. Access using array indexes instead.')</span>
  <span class="s1">return this.readUInt8(offset)</span>
<span class="s1">}</span>

<span class="s1">// `set` will be removed in Node 0.13+</span>
<span class="s1">Buffer.prototype.set = function (v, offset) {</span>
  <span class="s1">console.log('.set() is deprecated. Access using array indexes instead.')</span>
  <span class="s1">return this.writeUInt8(v, offset)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt8 = function (offset, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset &lt; this.length, 'Trying to read beyond buffer length')</span>
  <span class="s1">}</span>

  <span class="s1">if (offset &gt;= this.length)</span>
    <span class="s1">return</span>

  <span class="s1">return this[offset]</span>
<span class="s1">}</span>

<span class="s1">function _readUInt16 (buf, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 1 &lt; buf.length, 'Trying to read beyond buffer length')</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">var val</span>
  <span class="s1">if (littleEndian) {</span>
    <span class="s1">val = buf[offset]</span>
    <span class="s1">if (offset + 1 &lt; len)</span>
      <span class="s1">val |= buf[offset + 1] &lt;&lt; 8</span>
  <span class="s1">} else {</span>
    <span class="s1">val = buf[offset] &lt;&lt; 8</span>
    <span class="s1">if (offset + 1 &lt; len)</span>
      <span class="s1">val |= buf[offset + 1]</span>
  <span class="s1">}</span>
  <span class="s1">return val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt16LE = function (offset, noAssert) {</span>
  <span class="s1">return _readUInt16(this, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt16BE = function (offset, noAssert) {</span>
  <span class="s1">return _readUInt16(this, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _readUInt32 (buf, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 3 &lt; buf.length, 'Trying to read beyond buffer length')</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">var val</span>
  <span class="s1">if (littleEndian) {</span>
    <span class="s1">if (offset + 2 &lt; len)</span>
      <span class="s1">val = buf[offset + 2] &lt;&lt; 16</span>
    <span class="s1">if (offset + 1 &lt; len)</span>
      <span class="s1">val |= buf[offset + 1] &lt;&lt; 8</span>
    <span class="s1">val |= buf[offset]</span>
    <span class="s1">if (offset + 3 &lt; len)</span>
      <span class="s1">val = val + (buf[offset + 3] &lt;&lt; 24 &gt;&gt;&gt; 0)</span>
  <span class="s1">} else {</span>
    <span class="s1">if (offset + 1 &lt; len)</span>
      <span class="s1">val = buf[offset + 1] &lt;&lt; 16</span>
    <span class="s1">if (offset + 2 &lt; len)</span>
      <span class="s1">val |= buf[offset + 2] &lt;&lt; 8</span>
    <span class="s1">if (offset + 3 &lt; len)</span>
      <span class="s1">val |= buf[offset + 3]</span>
    <span class="s1">val = val + (buf[offset] &lt;&lt; 24 &gt;&gt;&gt; 0)</span>
  <span class="s1">}</span>
  <span class="s1">return val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt32LE = function (offset, noAssert) {</span>
  <span class="s1">return _readUInt32(this, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt32BE = function (offset, noAssert) {</span>
  <span class="s1">return _readUInt32(this, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt8 = function (offset, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null,</span>
        <span class="s1">'missing offset')</span>
    <span class="s1">assert(offset &lt; this.length, 'Trying to read beyond buffer length')</span>
  <span class="s1">}</span>

  <span class="s1">if (offset &gt;= this.length)</span>
    <span class="s1">return</span>

  <span class="s1">var neg = this[offset] &amp; 0x80</span>
  <span class="s1">if (neg)</span>
    <span class="s1">return (0xff - this[offset] + 1) * -1</span>
  <span class="s1">else</span>
    <span class="s1">return this[offset]</span>
<span class="s1">}</span>

<span class="s1">function _readInt16 (buf, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 1 &lt; buf.length, 'Trying to read beyond buffer length')</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">var val = _readUInt16(buf, offset, littleEndian, true)</span>
  <span class="s1">var neg = val &amp; 0x8000</span>
  <span class="s1">if (neg)</span>
    <span class="s1">return (0xffff - val + 1) * -1</span>
  <span class="s1">else</span>
    <span class="s1">return val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt16LE = function (offset, noAssert) {</span>
  <span class="s1">return _readInt16(this, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt16BE = function (offset, noAssert) {</span>
  <span class="s1">return _readInt16(this, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _readInt32 (buf, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 3 &lt; buf.length, 'Trying to read beyond buffer length')</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">var val = _readUInt32(buf, offset, littleEndian, true)</span>
  <span class="s1">var neg = val &amp; 0x80000000</span>
  <span class="s1">if (neg)</span>
    <span class="s1">return (0xffffffff - val + 1) * -1</span>
  <span class="s1">else</span>
    <span class="s1">return val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt32LE = function (offset, noAssert) {</span>
  <span class="s1">return _readInt32(this, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt32BE = function (offset, noAssert) {</span>
  <span class="s1">return _readInt32(this, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _readFloat (buf, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset + 3 &lt; buf.length, 'Trying to read beyond buffer length')</span>
  <span class="s1">}</span>

  <span class="s1">return ieee754.read(buf, offset, littleEndian, 23, 4)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readFloatLE = function (offset, noAssert) {</span>
  <span class="s1">return _readFloat(this, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readFloatBE = function (offset, noAssert) {</span>
  <span class="s1">return _readFloat(this, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _readDouble (buf, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset + 7 &lt; buf.length, 'Trying to read beyond buffer length')</span>
  <span class="s1">}</span>

  <span class="s1">return ieee754.read(buf, offset, littleEndian, 52, 8)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readDoubleLE = function (offset, noAssert) {</span>
  <span class="s1">return _readDouble(this, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readDoubleBE = function (offset, noAssert) {</span>
  <span class="s1">return _readDouble(this, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(value !== undefined &amp;&amp; value !== null, 'missing value')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset &lt; this.length, 'trying to write beyond buffer length')</span>
    <span class="s1">verifuint(value, 0xff)</span>
  <span class="s1">}</span>

  <span class="s1">if (offset &gt;= this.length) return</span>

  <span class="s1">this[offset] = value</span>
<span class="s1">}</span>

<span class="s1">function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(value !== undefined &amp;&amp; value !== null, 'missing value')</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 1 &lt; buf.length, 'trying to write beyond buffer length')</span>
    <span class="s1">verifuint(value, 0xffff)</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">for (var i = 0, j = Math.min(len - offset, 2); i &lt; j; i++) {</span>
    <span class="s1">buf[offset + i] =</span>
        <span class="s1">(value &amp; (0xff &lt;&lt; (8 * (littleEndian ? i : 1 - i)))) &gt;&gt;&gt;</span>
            <span class="s1">(littleEndian ? i : 1 - i) * 8</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeUInt16(this, value, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeUInt16(this, value, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(value !== undefined &amp;&amp; value !== null, 'missing value')</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 3 &lt; buf.length, 'trying to write beyond buffer length')</span>
    <span class="s1">verifuint(value, 0xffffffff)</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">for (var i = 0, j = Math.min(len - offset, 4); i &lt; j; i++) {</span>
    <span class="s1">buf[offset + i] =</span>
        <span class="s1">(value &gt;&gt;&gt; (littleEndian ? i : 3 - i) * 8) &amp; 0xff</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeUInt32(this, value, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeUInt32(this, value, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt8 = function (value, offset, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(value !== undefined &amp;&amp; value !== null, 'missing value')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset &lt; this.length, 'Trying to write beyond buffer length')</span>
    <span class="s1">verifsint(value, 0x7f, -0x80)</span>
  <span class="s1">}</span>

  <span class="s1">if (offset &gt;= this.length)</span>
    <span class="s1">return</span>

  <span class="s1">if (value &gt;= 0)</span>
    <span class="s1">this.writeUInt8(value, offset, noAssert)</span>
  <span class="s1">else</span>
    <span class="s1">this.writeUInt8(0xff + value + 1, offset, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _writeInt16 (buf, value, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(value !== undefined &amp;&amp; value !== null, 'missing value')</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 1 &lt; buf.length, 'Trying to write beyond buffer length')</span>
    <span class="s1">verifsint(value, 0x7fff, -0x8000)</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">if (value &gt;= 0)</span>
    <span class="s1">_writeUInt16(buf, value, offset, littleEndian, noAssert)</span>
  <span class="s1">else</span>
    <span class="s1">_writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeInt16(this, value, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeInt16(this, value, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _writeInt32 (buf, value, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(value !== undefined &amp;&amp; value !== null, 'missing value')</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 3 &lt; buf.length, 'Trying to write beyond buffer length')</span>
    <span class="s1">verifsint(value, 0x7fffffff, -0x80000000)</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">if (value &gt;= 0)</span>
    <span class="s1">_writeUInt32(buf, value, offset, littleEndian, noAssert)</span>
  <span class="s1">else</span>
    <span class="s1">_writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeInt32(this, value, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeInt32(this, value, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _writeFloat (buf, value, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(value !== undefined &amp;&amp; value !== null, 'missing value')</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 3 &lt; buf.length, 'Trying to write beyond buffer length')</span>
    <span class="s1">verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">ieee754.write(buf, value, offset, littleEndian, 23, 4)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeFloat(this, value, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeFloat(this, value, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function _writeDouble (buf, value, offset, littleEndian, noAssert) {</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">assert(value !== undefined &amp;&amp; value !== null, 'missing value')</span>
    <span class="s1">assert(typeof littleEndian === 'boolean', 'missing or invalid endian')</span>
    <span class="s1">assert(offset !== undefined &amp;&amp; offset !== null, 'missing offset')</span>
    <span class="s1">assert(offset + 7 &lt; buf.length,</span>
        <span class="s1">'Trying to write beyond buffer length')</span>
    <span class="s1">verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)</span>
  <span class="s1">}</span>

  <span class="s1">var len = buf.length</span>
  <span class="s1">if (offset &gt;= len)</span>
    <span class="s1">return</span>

  <span class="s1">ieee754.write(buf, value, offset, littleEndian, 52, 8)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeDouble(this, value, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {</span>
  <span class="s1">_writeDouble(this, value, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">// fill(value, start=0, end=buffer.length)</span>
<span class="s1">Buffer.prototype.fill = function (value, start, end) {</span>
  <span class="s1">if (!value) value = 0</span>
  <span class="s1">if (!start) start = 0</span>
  <span class="s1">if (!end) end = this.length</span>

  <span class="s1">if (typeof value === 'string') {</span>
    <span class="s1">value = value.charCodeAt(0)</span>
  <span class="s1">}</span>

  <span class="s1">assert(typeof value === 'number' &amp;&amp; !isNaN(value), 'value is not a number')</span>
  <span class="s1">assert(end &gt;= start, 'end &lt; start')</span>

  <span class="s1">// Fill 0 bytes; we're done</span>
  <span class="s1">if (end === start) return</span>
  <span class="s1">if (this.length === 0) return</span>

  <span class="s1">assert(start &gt;= 0 &amp;&amp; start &lt; this.length, 'start out of bounds')</span>
  <span class="s1">assert(end &gt;= 0 &amp;&amp; end &lt;= this.length, 'end out of bounds')</span>

  <span class="s1">for (var i = start; i &lt; end; i++) {</span>
    <span class="s1">this[i] = value</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.inspect = function () {</span>
  <span class="s1">var out = []</span>
  <span class="s1">var len = this.length</span>
  <span class="s1">for (var i = 0; i &lt; len; i++) {</span>
    <span class="s1">out[i] = toHex(this[i])</span>
    <span class="s1">if (i === exports.INSPECT_MAX_BYTES) {</span>
      <span class="s1">out[i + 1] = '...'</span>
      <span class="s1">break</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">return '&lt;Buffer ' + out.join(' ') + '&gt;'</span>
<span class="s1">}</span>

<span class="s1">/**</span>
 <span class="s1">* Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.</span>
 <span class="s1">* Added in Node 0.12. Only available in browsers that support ArrayBuffer.</span>
 <span class="s1">*/</span>
<span class="s1">Buffer.prototype.toArrayBuffer = function () {</span>
  <span class="s1">if (typeof Uint8Array !== 'undefined') {</span>
    <span class="s1">if (Buffer._useTypedArrays) {</span>
      <span class="s1">return (new Buffer(this)).buffer</span>
    <span class="s1">} else {</span>
      <span class="s1">var buf = new Uint8Array(this.length)</span>
      <span class="s1">for (var i = 0, len = buf.length; i &lt; len; i += 1)</span>
        <span class="s1">buf[i] = this[i]</span>
      <span class="s1">return buf.buffer</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">throw new Error('Buffer.toArrayBuffer not supported in this browser')</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">// HELPER FUNCTIONS</span>
<span class="s1">// ================</span>

<span class="s1">function stringtrim (str) {</span>
  <span class="s1">if (str.trim) return str.trim()</span>
  <span class="s1">return str.replace(/^\s+|\s+$/g, '')</span>
<span class="s1">}</span>

<span class="s1">var BP = Buffer.prototype</span>

<span class="s1">/**</span>
 <span class="s1">* Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods</span>
 <span class="s1">*/</span>
<span class="s1">Buffer._augment = function (arr) {</span>
  <span class="s1">arr._isBuffer = true</span>

  <span class="s1">// save reference to original Uint8Array get/set methods before overwriting</span>
  <span class="s1">arr._get = arr.get</span>
  <span class="s1">arr._set = arr.set</span>

  <span class="s1">// deprecated, will be removed in node 0.13+</span>
  <span class="s1">arr.get = BP.get</span>
  <span class="s1">arr.set = BP.set</span>

  <span class="s1">arr.write = BP.write</span>
  <span class="s1">arr.toString = BP.toString</span>
  <span class="s1">arr.toLocaleString = BP.toString</span>
  <span class="s1">arr.toJSON = BP.toJSON</span>
  <span class="s1">arr.copy = BP.copy</span>
  <span class="s1">arr.slice = BP.slice</span>
  <span class="s1">arr.readUInt8 = BP.readUInt8</span>
  <span class="s1">arr.readUInt16LE = BP.readUInt16LE</span>
  <span class="s1">arr.readUInt16BE = BP.readUInt16BE</span>
  <span class="s1">arr.readUInt32LE = BP.readUInt32LE</span>
  <span class="s1">arr.readUInt32BE = BP.readUInt32BE</span>
  <span class="s1">arr.readInt8 = BP.readInt8</span>
  <span class="s1">arr.readInt16LE = BP.readInt16LE</span>
  <span class="s1">arr.readInt16BE = BP.readInt16BE</span>
  <span class="s1">arr.readInt32LE = BP.readInt32LE</span>
  <span class="s1">arr.readInt32BE = BP.readInt32BE</span>
  <span class="s1">arr.readFloatLE = BP.readFloatLE</span>
  <span class="s1">arr.readFloatBE = BP.readFloatBE</span>
  <span class="s1">arr.readDoubleLE = BP.readDoubleLE</span>
  <span class="s1">arr.readDoubleBE = BP.readDoubleBE</span>
  <span class="s1">arr.writeUInt8 = BP.writeUInt8</span>
  <span class="s1">arr.writeUInt16LE = BP.writeUInt16LE</span>
  <span class="s1">arr.writeUInt16BE = BP.writeUInt16BE</span>
  <span class="s1">arr.writeUInt32LE = BP.writeUInt32LE</span>
  <span class="s1">arr.writeUInt32BE = BP.writeUInt32BE</span>
  <span class="s1">arr.writeInt8 = BP.writeInt8</span>
  <span class="s1">arr.writeInt16LE = BP.writeInt16LE</span>
  <span class="s1">arr.writeInt16BE = BP.writeInt16BE</span>
  <span class="s1">arr.writeInt32LE = BP.writeInt32LE</span>
  <span class="s1">arr.writeInt32BE = BP.writeInt32BE</span>
  <span class="s1">arr.writeFloatLE = BP.writeFloatLE</span>
  <span class="s1">arr.writeFloatBE = BP.writeFloatBE</span>
  <span class="s1">arr.writeDoubleLE = BP.writeDoubleLE</span>
  <span class="s1">arr.writeDoubleBE = BP.writeDoubleBE</span>
  <span class="s1">arr.fill = BP.fill</span>
  <span class="s1">arr.inspect = BP.inspect</span>
  <span class="s1">arr.toArrayBuffer = BP.toArrayBuffer</span>

  <span class="s1">return arr</span>
<span class="s1">}</span>

<span class="s1">// slice(start, end)</span>
<span class="s1">function clamp (index, len, defaultValue) {</span>
  <span class="s1">if (typeof index !== 'number') return defaultValue</span>
  <span class="s1">index = ~~index;  // Coerce to integer.</span>
  <span class="s1">if (index &gt;= len) return len</span>
  <span class="s1">if (index &gt;= 0) return index</span>
  <span class="s1">index += len</span>
  <span class="s1">if (index &gt;= 0) return index</span>
  <span class="s1">return 0</span>
<span class="s1">}</span>

<span class="s1">function coerce (length) {</span>
  <span class="s1">// Coerce length to a number (possibly NaN), round up</span>
  <span class="s1">// in case it's fractional (e.g. 123.456) then do a</span>
  <span class="s1">// double negate to coerce a NaN to 0. Easy, right?</span>
  <span class="s1">length = ~~Math.ceil(+length)</span>
  <span class="s1">return length &lt; 0 ? 0 : length</span>
<span class="s1">}</span>

<span class="s1">function isArray (subject) {</span>
  <span class="s1">return (Array.isArray || function (subject) {</span>
    <span class="s1">return Object.prototype.toString.call(subject) === '[object Array]'</span>
  <span class="s1">})(subject)</span>
<span class="s1">}</span>

<span class="s1">function isArrayish (subject) {</span>
  <span class="s1">return isArray(subject) || Buffer.isBuffer(subject) ||</span>
      <span class="s1">subject &amp;&amp; typeof subject === 'object' &amp;&amp;</span>
      <span class="s1">typeof subject.length === 'number'</span>
<span class="s1">}</span>

<span class="s1">function toHex (n) {</span>
  <span class="s1">if (n &lt; 16) return '0' + n.toString(16)</span>
  <span class="s1">return n.toString(16)</span>
<span class="s1">}</span>

<span class="s1">function utf8ToBytes (str) {</span>
  <span class="s1">var byteArray = []</span>
  <span class="s1">for (var i = 0; i &lt; str.length; i++) {</span>
    <span class="s1">var b = str.charCodeAt(i)</span>
    <span class="s1">if (b &lt;= 0x7F)</span>
      <span class="s1">byteArray.push(str.charCodeAt(i))</span>
    <span class="s1">else {</span>
      <span class="s1">var start = i</span>
      <span class="s1">if (b &gt;= 0xD800 &amp;&amp; b &lt;= 0xDFFF) i++</span>
      <span class="s1">var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')</span>
      <span class="s1">for (var j = 0; j &lt; h.length; j++)</span>
        <span class="s1">byteArray.push(parseInt(h[j], 16))</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">return byteArray</span>
<span class="s1">}</span>

<span class="s1">function asciiToBytes (str) {</span>
  <span class="s1">var byteArray = []</span>
  <span class="s1">for (var i = 0; i &lt; str.length; i++) {</span>
    <span class="s1">// Node's code seems to be doing this and not &amp; 0x7F..</span>
    <span class="s1">byteArray.push(str.charCodeAt(i) &amp; 0xFF)</span>
  <span class="s1">}</span>
  <span class="s1">return byteArray</span>
<span class="s1">}</span>

<span class="s1">function utf16leToBytes (str) {</span>
  <span class="s1">var c, hi, lo</span>
  <span class="s1">var byteArray = []</span>
  <span class="s1">for (var i = 0; i &lt; str.length; i++) {</span>
    <span class="s1">c = str.charCodeAt(i)</span>
    <span class="s1">hi = c &gt;&gt; 8</span>
    <span class="s1">lo = c % 256</span>
    <span class="s1">byteArray.push(lo)</span>
    <span class="s1">byteArray.push(hi)</span>
  <span class="s1">}</span>

  <span class="s1">return byteArray</span>
<span class="s1">}</span>

<span class="s1">function base64ToBytes (str) {</span>
  <span class="s1">return base64.toByteArray(str)</span>
<span class="s1">}</span>

<span class="s1">function blitBuffer (src, dst, offset, length) {</span>
  <span class="s1">var pos</span>
  <span class="s1">for (var i = 0; i &lt; length; i++) {</span>
    <span class="s1">if ((i + offset &gt;= dst.length) || (i &gt;= src.length))</span>
      <span class="s1">break</span>
    <span class="s1">dst[i + offset] = src[i]</span>
  <span class="s1">}</span>
  <span class="s1">return i</span>
<span class="s1">}</span>

<span class="s1">function decodeUtf8Char (str) {</span>
  <span class="s1">try {</span>
    <span class="s1">return decodeURIComponent(str)</span>
  <span class="s1">} catch (err) {</span>
    <span class="s1">return String.fromCharCode(0xFFFD) // UTF 8 invalid char</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">/*</span>
 <span class="s1">* We have to make sure that the value is a valid integer. This means that it</span>
 <span class="s1">* is non-negative. It has no fractional component and that it does not</span>
 <span class="s1">* exceed the maximum allowed value.</span>
 <span class="s1">*/</span>
<span class="s1">function verifuint (value, max) {</span>
  <span class="s1">assert(typeof value === 'number', 'cannot write a non-number as a number')</span>
  <span class="s1">assert(value &gt;= 0, 'specified a negative value for writing an unsigned value')</span>
  <span class="s1">assert(value &lt;= max, 'value is larger than maximum value for type')</span>
  <span class="s1">assert(Math.floor(value) === value, 'value has a fractional component')</span>
<span class="s1">}</span>

<span class="s1">function verifsint (value, max, min) {</span>
  <span class="s1">assert(typeof value === 'number', 'cannot write a non-number as a number')</span>
  <span class="s1">assert(value &lt;= max, 'value larger than maximum allowed value')</span>
  <span class="s1">assert(value &gt;= min, 'value smaller than minimum allowed value')</span>
  <span class="s1">assert(Math.floor(value) === value, 'value has a fractional component')</span>
<span class="s1">}</span>

<span class="s1">function verifIEEE754 (value, max, min) {</span>
  <span class="s1">assert(typeof value === 'number', 'cannot write a non-number as a number')</span>
  <span class="s1">assert(value &lt;= max, 'value larger than maximum allowed value')</span>
  <span class="s1">assert(value &gt;= min, 'value smaller than minimum allowed value')</span>
<span class="s1">}</span>

<span class="s1">function assert (test, message) {</span>
  <span class="s1">if (!test) throw new Error(message || 'Failed assertion')</span>
<span class="s1">}</span>

<span class="s1">},{&quot;base64-js&quot;:4,&quot;ieee754&quot;:9}],4:[function(require,module,exports){</span>
<span class="s1">var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';</span>

<span class="s1">;(function (exports) {</span>
	<span class="s1">'use strict';</span>

  <span class="s1">var Arr = (typeof Uint8Array !== 'undefined')</span>
    <span class="s1">? Uint8Array</span>
    <span class="s1">: Array</span>

	<span class="s1">var PLUS   = '+'.charCodeAt(0)</span>
	<span class="s1">var SLASH  = '/'.charCodeAt(0)</span>
	<span class="s1">var NUMBER = '0'.charCodeAt(0)</span>
	<span class="s1">var LOWER  = 'a'.charCodeAt(0)</span>
	<span class="s1">var UPPER  = 'A'.charCodeAt(0)</span>
	<span class="s1">var PLUS_URL_SAFE = '-'.charCodeAt(0)</span>
	<span class="s1">var SLASH_URL_SAFE = '_'.charCodeAt(0)</span>

	<span class="s1">function decode (elt) {</span>
		<span class="s1">var code = elt.charCodeAt(0)</span>
		<span class="s1">if (code === PLUS ||</span>
		    <span class="s1">code === PLUS_URL_SAFE)</span>
			<span class="s1">return 62 // '+'</span>
		<span class="s1">if (code === SLASH ||</span>
		    <span class="s1">code === SLASH_URL_SAFE)</span>
			<span class="s1">return 63 // '/'</span>
		<span class="s1">if (code &lt; NUMBER)</span>
			<span class="s1">return -1 //no match</span>
		<span class="s1">if (code &lt; NUMBER + 10)</span>
			<span class="s1">return code - NUMBER + 26 + 26</span>
		<span class="s1">if (code &lt; UPPER + 26)</span>
			<span class="s1">return code - UPPER</span>
		<span class="s1">if (code &lt; LOWER + 26)</span>
			<span class="s1">return code - LOWER + 26</span>
	<span class="s1">}</span>

	<span class="s1">function b64ToByteArray (b64) {</span>
		<span class="s1">var i, j, l, tmp, placeHolders, arr</span>

		<span class="s1">if (b64.length % 4 &gt; 0) {</span>
			<span class="s1">throw new Error('Invalid string. Length must be a multiple of 4')</span>
		<span class="s1">}</span>

		<span class="s1">// the number of equal signs (place holders)</span>
		<span class="s1">// if there are two placeholders, than the two characters before it</span>
		<span class="s1">// represent one byte</span>
		<span class="s1">// if there is only one, then the three characters before it represent 2 bytes</span>
		<span class="s1">// this is just a cheap hack to not do indexOf twice</span>
		<span class="s1">var len = b64.length</span>
		<span class="s1">placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0</span>

		<span class="s1">// base64 is 4/3 + up to two characters of the original data</span>
		<span class="s1">arr = new Arr(b64.length * 3 / 4 - placeHolders)</span>

		<span class="s1">// if there are placeholders, only get up to the last complete 4 chars</span>
		<span class="s1">l = placeHolders &gt; 0 ? b64.length - 4 : b64.length</span>

		<span class="s1">var L = 0</span>

		<span class="s1">function push (v) {</span>
			<span class="s1">arr[L++] = v</span>
		<span class="s1">}</span>

		<span class="s1">for (i = 0, j = 0; i &lt; l; i += 4, j += 3) {</span>
			<span class="s1">tmp = (decode(b64.charAt(i)) &lt;&lt; 18) | (decode(b64.charAt(i + 1)) &lt;&lt; 12) | (decode(b64.charAt(i + 2)) &lt;&lt; 6) | decode(b64.charAt(i + 3))</span>
			<span class="s1">push((tmp &amp; 0xFF0000) &gt;&gt; 16)</span>
			<span class="s1">push((tmp &amp; 0xFF00) &gt;&gt; 8)</span>
			<span class="s1">push(tmp &amp; 0xFF)</span>
		<span class="s1">}</span>

		<span class="s1">if (placeHolders === 2) {</span>
			<span class="s1">tmp = (decode(b64.charAt(i)) &lt;&lt; 2) | (decode(b64.charAt(i + 1)) &gt;&gt; 4)</span>
			<span class="s1">push(tmp &amp; 0xFF)</span>
		<span class="s1">} else if (placeHolders === 1) {</span>
			<span class="s1">tmp = (decode(b64.charAt(i)) &lt;&lt; 10) | (decode(b64.charAt(i + 1)) &lt;&lt; 4) | (decode(b64.charAt(i + 2)) &gt;&gt; 2)</span>
			<span class="s1">push((tmp &gt;&gt; 8) &amp; 0xFF)</span>
			<span class="s1">push(tmp &amp; 0xFF)</span>
		<span class="s1">}</span>

		<span class="s1">return arr</span>
	<span class="s1">}</span>

	<span class="s1">function uint8ToBase64 (uint8) {</span>
		<span class="s1">var i,</span>
			<span class="s1">extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes</span>
			<span class="s1">output = &quot;&quot;,</span>
			<span class="s1">temp, length</span>

		<span class="s1">function encode (num) {</span>
			<span class="s1">return lookup.charAt(num)</span>
		<span class="s1">}</span>

		<span class="s1">function tripletToBase64 (num) {</span>
			<span class="s1">return encode(num &gt;&gt; 18 &amp; 0x3F) + encode(num &gt;&gt; 12 &amp; 0x3F) + encode(num &gt;&gt; 6 &amp; 0x3F) + encode(num &amp; 0x3F)</span>
		<span class="s1">}</span>

		<span class="s1">// go through the array every three bytes, we'll deal with trailing stuff later</span>
		<span class="s1">for (i = 0, length = uint8.length - extraBytes; i &lt; length; i += 3) {</span>
			<span class="s1">temp = (uint8[i] &lt;&lt; 16) + (uint8[i + 1] &lt;&lt; 8) + (uint8[i + 2])</span>
			<span class="s1">output += tripletToBase64(temp)</span>
		<span class="s1">}</span>

		<span class="s1">// pad the end with zeros, but make sure to not forget the extra bytes</span>
		<span class="s1">switch (extraBytes) {</span>
			<span class="s1">case 1:</span>
				<span class="s1">temp = uint8[uint8.length - 1]</span>
				<span class="s1">output += encode(temp &gt;&gt; 2)</span>
				<span class="s1">output += encode((temp &lt;&lt; 4) &amp; 0x3F)</span>
				<span class="s1">output += '=='</span>
				<span class="s1">break</span>
			<span class="s1">case 2:</span>
				<span class="s1">temp = (uint8[uint8.length - 2] &lt;&lt; 8) + (uint8[uint8.length - 1])</span>
				<span class="s1">output += encode(temp &gt;&gt; 10)</span>
				<span class="s1">output += encode((temp &gt;&gt; 4) &amp; 0x3F)</span>
				<span class="s1">output += encode((temp &lt;&lt; 2) &amp; 0x3F)</span>
				<span class="s1">output += '='</span>
				<span class="s1">break</span>
		<span class="s1">}</span>

		<span class="s1">return output</span>
	<span class="s1">}</span>

	<span class="s1">exports.toByteArray = b64ToByteArray</span>
	<span class="s1">exports.fromByteArray = uint8ToBase64</span>
<span class="s1">}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))</span>

<span class="s1">},{}],5:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">function EventEmitter() {</span>
  <span class="s1">this._events = this._events || {};</span>
  <span class="s1">this._maxListeners = this._maxListeners || undefined;</span>
<span class="s1">}</span>
<span class="s1">module.exports = EventEmitter;</span>

<span class="s1">// Backwards-compat with node 0.10.x</span>
<span class="s1">EventEmitter.EventEmitter = EventEmitter;</span>

<span class="s1">EventEmitter.prototype._events = undefined;</span>
<span class="s1">EventEmitter.prototype._maxListeners = undefined;</span>

<span class="s1">// By default EventEmitters will print a warning if more than 10 listeners are</span>
<span class="s1">// added to it. This is a useful default which helps finding memory leaks.</span>
<span class="s1">EventEmitter.defaultMaxListeners = 10;</span>

<span class="s1">// Obviously not all Emitters should be limited to 10. This function allows</span>
<span class="s1">// that to be increased. Set to zero for unlimited.</span>
<span class="s1">EventEmitter.prototype.setMaxListeners = function(n) {</span>
  <span class="s1">if (!isNumber(n) || n &lt; 0 || isNaN(n))</span>
    <span class="s1">throw TypeError('n must be a positive number');</span>
  <span class="s1">this._maxListeners = n;</span>
  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.emit = function(type) {</span>
  <span class="s1">var er, handler, len, args, i, listeners;</span>

  <span class="s1">if (!this._events)</span>
    <span class="s1">this._events = {};</span>

  <span class="s1">// If there is no 'error' event listener then throw.</span>
  <span class="s1">if (type === 'error') {</span>
    <span class="s1">if (!this._events.error ||</span>
        <span class="s1">(isObject(this._events.error) &amp;&amp; !this._events.error.length)) {</span>
      <span class="s1">er = arguments[1];</span>
      <span class="s1">if (er instanceof Error) {</span>
        <span class="s1">throw er; // Unhandled 'error' event</span>
      <span class="s1">}</span>
      <span class="s1">throw TypeError('Uncaught, unspecified &quot;error&quot; event.');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">handler = this._events[type];</span>

  <span class="s1">if (isUndefined(handler))</span>
    <span class="s1">return false;</span>

  <span class="s1">if (isFunction(handler)) {</span>
    <span class="s1">switch (arguments.length) {</span>
      <span class="s1">// fast cases</span>
      <span class="s1">case 1:</span>
        <span class="s1">handler.call(this);</span>
        <span class="s1">break;</span>
      <span class="s1">case 2:</span>
        <span class="s1">handler.call(this, arguments[1]);</span>
        <span class="s1">break;</span>
      <span class="s1">case 3:</span>
        <span class="s1">handler.call(this, arguments[1], arguments[2]);</span>
        <span class="s1">break;</span>
      <span class="s1">// slower</span>
      <span class="s1">default:</span>
        <span class="s1">len = arguments.length;</span>
        <span class="s1">args = new Array(len - 1);</span>
        <span class="s1">for (i = 1; i &lt; len; i++)</span>
          <span class="s1">args[i - 1] = arguments[i];</span>
        <span class="s1">handler.apply(this, args);</span>
    <span class="s1">}</span>
  <span class="s1">} else if (isObject(handler)) {</span>
    <span class="s1">len = arguments.length;</span>
    <span class="s1">args = new Array(len - 1);</span>
    <span class="s1">for (i = 1; i &lt; len; i++)</span>
      <span class="s1">args[i - 1] = arguments[i];</span>

    <span class="s1">listeners = handler.slice();</span>
    <span class="s1">len = listeners.length;</span>
    <span class="s1">for (i = 0; i &lt; len; i++)</span>
      <span class="s1">listeners[i].apply(this, args);</span>
  <span class="s1">}</span>

  <span class="s1">return true;</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.addListener = function(type, listener) {</span>
  <span class="s1">var m;</span>

  <span class="s1">if (!isFunction(listener))</span>
    <span class="s1">throw TypeError('listener must be a function');</span>

  <span class="s1">if (!this._events)</span>
    <span class="s1">this._events = {};</span>

  <span class="s1">// To avoid recursion in the case that type === &quot;newListener&quot;! Before</span>
  <span class="s1">// adding it to the listeners, first emit &quot;newListener&quot;.</span>
  <span class="s1">if (this._events.newListener)</span>
    <span class="s1">this.emit('newListener', type,</span>
              <span class="s1">isFunction(listener.listener) ?</span>
              <span class="s1">listener.listener : listener);</span>

  <span class="s1">if (!this._events[type])</span>
    <span class="s1">// Optimize the case of one listener. Don't need the extra array object.</span>
    <span class="s1">this._events[type] = listener;</span>
  <span class="s1">else if (isObject(this._events[type]))</span>
    <span class="s1">// If we've already got an array, just append.</span>
    <span class="s1">this._events[type].push(listener);</span>
  <span class="s1">else</span>
    <span class="s1">// Adding the second element, need to change to array.</span>
    <span class="s1">this._events[type] = [this._events[type], listener];</span>

  <span class="s1">// Check for listener leak</span>
  <span class="s1">if (isObject(this._events[type]) &amp;&amp; !this._events[type].warned) {</span>
    <span class="s1">var m;</span>
    <span class="s1">if (!isUndefined(this._maxListeners)) {</span>
      <span class="s1">m = this._maxListeners;</span>
    <span class="s1">} else {</span>
      <span class="s1">m = EventEmitter.defaultMaxListeners;</span>
    <span class="s1">}</span>

    <span class="s1">if (m &amp;&amp; m &gt; 0 &amp;&amp; this._events[type].length &gt; m) {</span>
      <span class="s1">this._events[type].warned = true;</span>
      <span class="s1">console.error('(node) warning: possible EventEmitter memory ' +</span>
                    <span class="s1">'leak detected. %d listeners added. ' +</span>
                    <span class="s1">'Use emitter.setMaxListeners() to increase limit.',</span>
                    <span class="s1">this._events[type].length);</span>
      <span class="s1">if (typeof console.trace === 'function') {</span>
        <span class="s1">// not supported in IE 10</span>
        <span class="s1">console.trace();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.on = EventEmitter.prototype.addListener;</span>

<span class="s1">EventEmitter.prototype.once = function(type, listener) {</span>
  <span class="s1">if (!isFunction(listener))</span>
    <span class="s1">throw TypeError('listener must be a function');</span>

  <span class="s1">var fired = false;</span>

  <span class="s1">function g() {</span>
    <span class="s1">this.removeListener(type, g);</span>

    <span class="s1">if (!fired) {</span>
      <span class="s1">fired = true;</span>
      <span class="s1">listener.apply(this, arguments);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">g.listener = listener;</span>
  <span class="s1">this.on(type, g);</span>

  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">// emits a 'removeListener' event iff the listener was removed</span>
<span class="s1">EventEmitter.prototype.removeListener = function(type, listener) {</span>
  <span class="s1">var list, position, length, i;</span>

  <span class="s1">if (!isFunction(listener))</span>
    <span class="s1">throw TypeError('listener must be a function');</span>

  <span class="s1">if (!this._events || !this._events[type])</span>
    <span class="s1">return this;</span>

  <span class="s1">list = this._events[type];</span>
  <span class="s1">length = list.length;</span>
  <span class="s1">position = -1;</span>

  <span class="s1">if (list === listener ||</span>
      <span class="s1">(isFunction(list.listener) &amp;&amp; list.listener === listener)) {</span>
    <span class="s1">delete this._events[type];</span>
    <span class="s1">if (this._events.removeListener)</span>
      <span class="s1">this.emit('removeListener', type, listener);</span>

  <span class="s1">} else if (isObject(list)) {</span>
    <span class="s1">for (i = length; i-- &gt; 0;) {</span>
      <span class="s1">if (list[i] === listener ||</span>
          <span class="s1">(list[i].listener &amp;&amp; list[i].listener === listener)) {</span>
        <span class="s1">position = i;</span>
        <span class="s1">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">if (position &lt; 0)</span>
      <span class="s1">return this;</span>

    <span class="s1">if (list.length === 1) {</span>
      <span class="s1">list.length = 0;</span>
      <span class="s1">delete this._events[type];</span>
    <span class="s1">} else {</span>
      <span class="s1">list.splice(position, 1);</span>
    <span class="s1">}</span>

    <span class="s1">if (this._events.removeListener)</span>
      <span class="s1">this.emit('removeListener', type, listener);</span>
  <span class="s1">}</span>

  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.removeAllListeners = function(type) {</span>
  <span class="s1">var key, listeners;</span>

  <span class="s1">if (!this._events)</span>
    <span class="s1">return this;</span>

  <span class="s1">// not listening for removeListener, no need to emit</span>
  <span class="s1">if (!this._events.removeListener) {</span>
    <span class="s1">if (arguments.length === 0)</span>
      <span class="s1">this._events = {};</span>
    <span class="s1">else if (this._events[type])</span>
      <span class="s1">delete this._events[type];</span>
    <span class="s1">return this;</span>
  <span class="s1">}</span>

  <span class="s1">// emit removeListener for all listeners on all events</span>
  <span class="s1">if (arguments.length === 0) {</span>
    <span class="s1">for (key in this._events) {</span>
      <span class="s1">if (key === 'removeListener') continue;</span>
      <span class="s1">this.removeAllListeners(key);</span>
    <span class="s1">}</span>
    <span class="s1">this.removeAllListeners('removeListener');</span>
    <span class="s1">this._events = {};</span>
    <span class="s1">return this;</span>
  <span class="s1">}</span>

  <span class="s1">listeners = this._events[type];</span>

  <span class="s1">if (isFunction(listeners)) {</span>
    <span class="s1">this.removeListener(type, listeners);</span>
  <span class="s1">} else {</span>
    <span class="s1">// LIFO order</span>
    <span class="s1">while (listeners.length)</span>
      <span class="s1">this.removeListener(type, listeners[listeners.length - 1]);</span>
  <span class="s1">}</span>
  <span class="s1">delete this._events[type];</span>

  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.listeners = function(type) {</span>
  <span class="s1">var ret;</span>
  <span class="s1">if (!this._events || !this._events[type])</span>
    <span class="s1">ret = [];</span>
  <span class="s1">else if (isFunction(this._events[type]))</span>
    <span class="s1">ret = [this._events[type]];</span>
  <span class="s1">else</span>
    <span class="s1">ret = this._events[type].slice();</span>
  <span class="s1">return ret;</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.listenerCount = function(emitter, type) {</span>
  <span class="s1">var ret;</span>
  <span class="s1">if (!emitter._events || !emitter._events[type])</span>
    <span class="s1">ret = 0;</span>
  <span class="s1">else if (isFunction(emitter._events[type]))</span>
    <span class="s1">ret = 1;</span>
  <span class="s1">else</span>
    <span class="s1">ret = emitter._events[type].length;</span>
  <span class="s1">return ret;</span>
<span class="s1">};</span>

<span class="s1">function isFunction(arg) {</span>
  <span class="s1">return typeof arg === 'function';</span>
<span class="s1">}</span>

<span class="s1">function isNumber(arg) {</span>
  <span class="s1">return typeof arg === 'number';</span>
<span class="s1">}</span>

<span class="s1">function isObject(arg) {</span>
  <span class="s1">return typeof arg === 'object' &amp;&amp; arg !== null;</span>
<span class="s1">}</span>

<span class="s1">function isUndefined(arg) {</span>
  <span class="s1">return arg === void 0;</span>
<span class="s1">}</span>

<span class="s1">},{}],6:[function(require,module,exports){</span>
<span class="s1">var http = module.exports;</span>
<span class="s1">var EventEmitter = require('events').EventEmitter;</span>
<span class="s1">var Request = require('./lib/request');</span>
<span class="s1">var url = require('url')</span>

<span class="s1">http.request = function (params, cb) {</span>
    <span class="s1">if (typeof params === 'string') {</span>
        <span class="s1">params = url.parse(params)</span>
    <span class="s1">}</span>
    <span class="s1">if (!params) params = {};</span>
    <span class="s1">if (!params.host &amp;&amp; !params.port) {</span>
        <span class="s1">params.port = parseInt(window.location.port, 10);</span>
    <span class="s1">}</span>
    <span class="s1">if (!params.host &amp;&amp; params.hostname) {</span>
        <span class="s1">params.host = params.hostname;</span>
    <span class="s1">}</span>
    
    <span class="s1">if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];</span>
    <span class="s1">if (!params.host) {</span>
        <span class="s1">params.host = window.location.hostname || window.location.host;</span>
    <span class="s1">}</span>
    <span class="s1">if (/:/.test(params.host)) {</span>
        <span class="s1">if (!params.port) {</span>
            <span class="s1">params.port = params.host.split(':')[1];</span>
        <span class="s1">}</span>
        <span class="s1">params.host = params.host.split(':')[0];</span>
    <span class="s1">}</span>
    <span class="s1">if (!params.port) params.port = params.scheme == 'https' ? 443 : 80;</span>
    
    <span class="s1">var req = new Request(new xhrHttp, params);</span>
    <span class="s1">if (cb) req.on('response', cb);</span>
    <span class="s1">return req;</span>
<span class="s1">};</span>

<span class="s1">http.get = function (params, cb) {</span>
    <span class="s1">params.method = 'GET';</span>
    <span class="s1">var req = http.request(params, cb);</span>
    <span class="s1">req.end();</span>
    <span class="s1">return req;</span>
<span class="s1">};</span>

<span class="s1">http.Agent = function () {};</span>
<span class="s1">http.Agent.defaultMaxSockets = 4;</span>

<span class="s1">var xhrHttp = (function () {</span>
    <span class="s1">if (typeof window === 'undefined') {</span>
        <span class="s1">throw new Error('no window object present');</span>
    <span class="s1">}</span>
    <span class="s1">else if (window.XMLHttpRequest) {</span>
        <span class="s1">return window.XMLHttpRequest;</span>
    <span class="s1">}</span>
    <span class="s1">else if (window.ActiveXObject) {</span>
        <span class="s1">var axs = [</span>
            <span class="s1">'Msxml2.XMLHTTP.6.0',</span>
            <span class="s1">'Msxml2.XMLHTTP.3.0',</span>
            <span class="s1">'Microsoft.XMLHTTP'</span>
        <span class="s1">];</span>
        <span class="s1">for (var i = 0; i &lt; axs.length; i++) {</span>
            <span class="s1">try {</span>
                <span class="s1">var ax = new(window.ActiveXObject)(axs[i]);</span>
                <span class="s1">return function () {</span>
                    <span class="s1">if (ax) {</span>
                        <span class="s1">var ax_ = ax;</span>
                        <span class="s1">ax = null;</span>
                        <span class="s1">return ax_;</span>
                    <span class="s1">}</span>
                    <span class="s1">else {</span>
                        <span class="s1">return new(window.ActiveXObject)(axs[i]);</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s1">catch (e) {}</span>
        <span class="s1">}</span>
        <span class="s1">throw new Error('ajax not supported in this browser')</span>
    <span class="s1">}</span>
    <span class="s1">else {</span>
        <span class="s1">throw new Error('ajax not supported in this browser');</span>
    <span class="s1">}</span>
<span class="s1">})();</span>

<span class="s1">http.STATUS_CODES = {</span>
    <span class="s1">100 : 'Continue',</span>
    <span class="s1">101 : 'Switching Protocols',</span>
    <span class="s1">102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918</span>
    <span class="s1">200 : 'OK',</span>
    <span class="s1">201 : 'Created',</span>
    <span class="s1">202 : 'Accepted',</span>
    <span class="s1">203 : 'Non-Authoritative Information',</span>
    <span class="s1">204 : 'No Content',</span>
    <span class="s1">205 : 'Reset Content',</span>
    <span class="s1">206 : 'Partial Content',</span>
    <span class="s1">207 : 'Multi-Status',               // RFC 4918</span>
    <span class="s1">300 : 'Multiple Choices',</span>
    <span class="s1">301 : 'Moved Permanently',</span>
    <span class="s1">302 : 'Moved Temporarily',</span>
    <span class="s1">303 : 'See Other',</span>
    <span class="s1">304 : 'Not Modified',</span>
    <span class="s1">305 : 'Use Proxy',</span>
    <span class="s1">307 : 'Temporary Redirect',</span>
    <span class="s1">400 : 'Bad Request',</span>
    <span class="s1">401 : 'Unauthorized',</span>
    <span class="s1">402 : 'Payment Required',</span>
    <span class="s1">403 : 'Forbidden',</span>
    <span class="s1">404 : 'Not Found',</span>
    <span class="s1">405 : 'Method Not Allowed',</span>
    <span class="s1">406 : 'Not Acceptable',</span>
    <span class="s1">407 : 'Proxy Authentication Required',</span>
    <span class="s1">408 : 'Request Time-out',</span>
    <span class="s1">409 : 'Conflict',</span>
    <span class="s1">410 : 'Gone',</span>
    <span class="s1">411 : 'Length Required',</span>
    <span class="s1">412 : 'Precondition Failed',</span>
    <span class="s1">413 : 'Request Entity Too Large',</span>
    <span class="s1">414 : 'Request-URI Too Large',</span>
    <span class="s1">415 : 'Unsupported Media Type',</span>
    <span class="s1">416 : 'Requested Range Not Satisfiable',</span>
    <span class="s1">417 : 'Expectation Failed',</span>
    <span class="s1">418 : 'I\'m a teapot',              // RFC 2324</span>
    <span class="s1">422 : 'Unprocessable Entity',       // RFC 4918</span>
    <span class="s1">423 : 'Locked',                     // RFC 4918</span>
    <span class="s1">424 : 'Failed Dependency',          // RFC 4918</span>
    <span class="s1">425 : 'Unordered Collection',       // RFC 4918</span>
    <span class="s1">426 : 'Upgrade Required',           // RFC 2817</span>
    <span class="s1">428 : 'Precondition Required',      // RFC 6585</span>
    <span class="s1">429 : 'Too Many Requests',          // RFC 6585</span>
    <span class="s1">431 : 'Request Header Fields Too Large',// RFC 6585</span>
    <span class="s1">500 : 'Internal Server Error',</span>
    <span class="s1">501 : 'Not Implemented',</span>
    <span class="s1">502 : 'Bad Gateway',</span>
    <span class="s1">503 : 'Service Unavailable',</span>
    <span class="s1">504 : 'Gateway Time-out',</span>
    <span class="s1">505 : 'HTTP Version Not Supported',</span>
    <span class="s1">506 : 'Variant Also Negotiates',    // RFC 2295</span>
    <span class="s1">507 : 'Insufficient Storage',       // RFC 4918</span>
    <span class="s1">509 : 'Bandwidth Limit Exceeded',</span>
    <span class="s1">510 : 'Not Extended',               // RFC 2774</span>
    <span class="s1">511 : 'Network Authentication Required' // RFC 6585</span>
<span class="s1">};</span>
<span class="s1">},{&quot;./lib/request&quot;:7,&quot;events&quot;:5,&quot;url&quot;:26}],7:[function(require,module,exports){</span>
<span class="s1">var Stream = require('stream');</span>
<span class="s1">var Response = require('./response');</span>
<span class="s1">var Base64 = require('Base64');</span>
<span class="s1">var inherits = require('inherits');</span>

<span class="s1">var Request = module.exports = function (xhr, params) {</span>
    <span class="s1">var self = this;</span>
    <span class="s1">self.writable = true;</span>
    <span class="s1">self.xhr = xhr;</span>
    <span class="s1">self.body = [];</span>
    
    <span class="s1">self.uri = (params.scheme || 'http') + '://'</span>
        <span class="s1">+ params.host</span>
        <span class="s1">+ (params.port ? ':' + params.port : '')</span>
        <span class="s1">+ (params.path || '/')</span>
    <span class="s1">;</span>
    
    <span class="s1">if (typeof params.withCredentials === 'undefined') {</span>
        <span class="s1">params.withCredentials = true;</span>
    <span class="s1">}</span>

    <span class="s1">try { xhr.withCredentials = params.withCredentials }</span>
    <span class="s1">catch (e) {}</span>
    
    <span class="s1">xhr.open(</span>
        <span class="s1">params.method || 'GET',</span>
        <span class="s1">self.uri,</span>
        <span class="s1">true</span>
    <span class="s1">);</span>

    <span class="s1">self._headers = {};</span>
    
    <span class="s1">if (params.headers) {</span>
        <span class="s1">var keys = objectKeys(params.headers);</span>
        <span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span>
            <span class="s1">var key = keys[i];</span>
            <span class="s1">if (!self.isSafeRequestHeader(key)) continue;</span>
            <span class="s1">var value = params.headers[key];</span>
            <span class="s1">self.setHeader(key, value);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    
    <span class="s1">if (params.auth) {</span>
        <span class="s1">//basic auth</span>
        <span class="s1">this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));</span>
    <span class="s1">}</span>

    <span class="s1">var res = new Response;</span>
    <span class="s1">res.on('close', function () {</span>
        <span class="s1">self.emit('close');</span>
    <span class="s1">});</span>
    
    <span class="s1">res.on('ready', function () {</span>
        <span class="s1">self.emit('response', res);</span>
    <span class="s1">});</span>
    
    <span class="s1">xhr.onreadystatechange = function () {</span>
        <span class="s1">// Fix for IE9 bug</span>
        <span class="s1">// SCRIPT575: Could not complete the operation due to error c00c023f</span>
        <span class="s1">// It happens when a request is aborted, calling the success callback anyway with readyState === 4</span>
        <span class="s1">if (xhr.__aborted) return;</span>
        <span class="s1">res.handle(xhr);</span>
    <span class="s1">};</span>
<span class="s1">};</span>

<span class="s1">inherits(Request, Stream);</span>

<span class="s1">Request.prototype.setHeader = function (key, value) {</span>
    <span class="s1">this._headers[key.toLowerCase()] = value</span>
<span class="s1">};</span>

<span class="s1">Request.prototype.getHeader = function (key) {</span>
    <span class="s1">return this._headers[key.toLowerCase()]</span>
<span class="s1">};</span>

<span class="s1">Request.prototype.removeHeader = function (key) {</span>
    <span class="s1">delete this._headers[key.toLowerCase()]</span>
<span class="s1">};</span>

<span class="s1">Request.prototype.write = function (s) {</span>
    <span class="s1">this.body.push(s);</span>
<span class="s1">};</span>

<span class="s1">Request.prototype.destroy = function (s) {</span>
    <span class="s1">this.xhr.__aborted = true;</span>
    <span class="s1">this.xhr.abort();</span>
    <span class="s1">this.emit('close');</span>
<span class="s1">};</span>

<span class="s1">Request.prototype.end = function (s) {</span>
    <span class="s1">if (s !== undefined) this.body.push(s);</span>

    <span class="s1">var keys = objectKeys(this._headers);</span>
    <span class="s1">for (var i = 0; i &lt; keys.length; i++) {</span>
        <span class="s1">var key = keys[i];</span>
        <span class="s1">var value = this._headers[key];</span>
        <span class="s1">if (isArray(value)) {</span>
            <span class="s1">for (var j = 0; j &lt; value.length; j++) {</span>
                <span class="s1">this.xhr.setRequestHeader(key, value[j]);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">else this.xhr.setRequestHeader(key, value)</span>
    <span class="s1">}</span>

    <span class="s1">if (this.body.length === 0) {</span>
        <span class="s1">this.xhr.send('');</span>
    <span class="s1">}</span>
    <span class="s1">else if (typeof this.body[0] === 'string') {</span>
        <span class="s1">this.xhr.send(this.body.join(''));</span>
    <span class="s1">}</span>
    <span class="s1">else if (isArray(this.body[0])) {</span>
        <span class="s1">var body = [];</span>
        <span class="s1">for (var i = 0; i &lt; this.body.length; i++) {</span>
            <span class="s1">body.push.apply(body, this.body[i]);</span>
        <span class="s1">}</span>
        <span class="s1">this.xhr.send(body);</span>
    <span class="s1">}</span>
    <span class="s1">else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {</span>
        <span class="s1">var len = 0;</span>
        <span class="s1">for (var i = 0; i &lt; this.body.length; i++) {</span>
            <span class="s1">len += this.body[i].length;</span>
        <span class="s1">}</span>
        <span class="s1">var body = new(this.body[0].constructor)(len);</span>
        <span class="s1">var k = 0;</span>
        
        <span class="s1">for (var i = 0; i &lt; this.body.length; i++) {</span>
            <span class="s1">var b = this.body[i];</span>
            <span class="s1">for (var j = 0; j &lt; b.length; j++) {</span>
                <span class="s1">body[k++] = b[j];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">this.xhr.send(body);</span>
    <span class="s1">}</span>
    <span class="s1">else {</span>
        <span class="s1">var body = '';</span>
        <span class="s1">for (var i = 0; i &lt; this.body.length; i++) {</span>
            <span class="s1">body += this.body[i].toString();</span>
        <span class="s1">}</span>
        <span class="s1">this.xhr.send(body);</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html</span>
<span class="s1">Request.unsafeHeaders = [</span>
    <span class="s1">&quot;accept-charset&quot;,</span>
    <span class="s1">&quot;accept-encoding&quot;,</span>
    <span class="s1">&quot;access-control-request-headers&quot;,</span>
    <span class="s1">&quot;access-control-request-method&quot;,</span>
    <span class="s1">&quot;connection&quot;,</span>
    <span class="s1">&quot;content-length&quot;,</span>
    <span class="s1">&quot;cookie&quot;,</span>
    <span class="s1">&quot;cookie2&quot;,</span>
    <span class="s1">&quot;content-transfer-encoding&quot;,</span>
    <span class="s1">&quot;date&quot;,</span>
    <span class="s1">&quot;expect&quot;,</span>
    <span class="s1">&quot;host&quot;,</span>
    <span class="s1">&quot;keep-alive&quot;,</span>
    <span class="s1">&quot;origin&quot;,</span>
    <span class="s1">&quot;referer&quot;,</span>
    <span class="s1">&quot;te&quot;,</span>
    <span class="s1">&quot;trailer&quot;,</span>
    <span class="s1">&quot;transfer-encoding&quot;,</span>
    <span class="s1">&quot;upgrade&quot;,</span>
    <span class="s1">&quot;user-agent&quot;,</span>
    <span class="s1">&quot;via&quot;</span>
<span class="s1">];</span>

<span class="s1">Request.prototype.isSafeRequestHeader = function (headerName) {</span>
    <span class="s1">if (!headerName) return false;</span>
    <span class="s1">return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;</span>
<span class="s1">};</span>

<span class="s1">var objectKeys = Object.keys || function (obj) {</span>
    <span class="s1">var keys = [];</span>
    <span class="s1">for (var key in obj) keys.push(key);</span>
    <span class="s1">return keys;</span>
<span class="s1">};</span>

<span class="s1">var isArray = Array.isArray || function (xs) {</span>
    <span class="s1">return Object.prototype.toString.call(xs) === '[object Array]';</span>
<span class="s1">};</span>

<span class="s1">var indexOf = function (xs, x) {</span>
    <span class="s1">if (xs.indexOf) return xs.indexOf(x);</span>
    <span class="s1">for (var i = 0; i &lt; xs.length; i++) {</span>
        <span class="s1">if (xs[i] === x) return i;</span>
    <span class="s1">}</span>
    <span class="s1">return -1;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./response&quot;:8,&quot;Base64&quot;:2,&quot;inherits&quot;:10,&quot;stream&quot;:19}],8:[function(require,module,exports){</span>
<span class="s1">var Stream = require('stream');</span>
<span class="s1">var util = require('util');</span>

<span class="s1">var Response = module.exports = function (res) {</span>
    <span class="s1">this.offset = 0;</span>
    <span class="s1">this.readable = true;</span>
<span class="s1">};</span>

<span class="s1">util.inherits(Response, Stream);</span>

<span class="s1">var capable = {</span>
    <span class="s1">streaming : true,</span>
    <span class="s1">status2 : true</span>
<span class="s1">};</span>

<span class="s1">function parseHeaders (res) {</span>
    <span class="s1">var lines = res.getAllResponseHeaders().split(/\r?\n/);</span>
    <span class="s1">var headers = {};</span>
    <span class="s1">for (var i = 0; i &lt; lines.length; i++) {</span>
        <span class="s1">var line = lines[i];</span>
        <span class="s1">if (line === '') continue;</span>
        
        <span class="s1">var m = line.match(/^([^:]+):\s*(.*)/);</span>
        <span class="s1">if (m) {</span>
            <span class="s1">var key = m[1].toLowerCase(), value = m[2];</span>
            
            <span class="s1">if (headers[key] !== undefined) {</span>
            
                <span class="s1">if (isArray(headers[key])) {</span>
                    <span class="s1">headers[key].push(value);</span>
                <span class="s1">}</span>
                <span class="s1">else {</span>
                    <span class="s1">headers[key] = [ headers[key], value ];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">else {</span>
                <span class="s1">headers[key] = value;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">else {</span>
            <span class="s1">headers[line] = true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return headers;</span>
<span class="s1">}</span>

<span class="s1">Response.prototype.getResponse = function (xhr) {</span>
    <span class="s1">var respType = String(xhr.responseType).toLowerCase();</span>
    <span class="s1">if (respType === 'blob') return xhr.responseBlob || xhr.response;</span>
    <span class="s1">if (respType === 'arraybuffer') return xhr.response;</span>
    <span class="s1">return xhr.responseText;</span>
<span class="s1">}</span>

<span class="s1">Response.prototype.getHeader = function (key) {</span>
    <span class="s1">return this.headers[key.toLowerCase()];</span>
<span class="s1">};</span>

<span class="s1">Response.prototype.handle = function (res) {</span>
    <span class="s1">if (res.readyState === 2 &amp;&amp; capable.status2) {</span>
        <span class="s1">try {</span>
            <span class="s1">this.statusCode = res.status;</span>
            <span class="s1">this.headers = parseHeaders(res);</span>
        <span class="s1">}</span>
        <span class="s1">catch (err) {</span>
            <span class="s1">capable.status2 = false;</span>
        <span class="s1">}</span>
        
        <span class="s1">if (capable.status2) {</span>
            <span class="s1">this.emit('ready');</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">else if (capable.streaming &amp;&amp; res.readyState === 3) {</span>
        <span class="s1">try {</span>
            <span class="s1">if (!this.statusCode) {</span>
                <span class="s1">this.statusCode = res.status;</span>
                <span class="s1">this.headers = parseHeaders(res);</span>
                <span class="s1">this.emit('ready');</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">catch (err) {}</span>
        
        <span class="s1">try {</span>
            <span class="s1">this._emitData(res);</span>
        <span class="s1">}</span>
        <span class="s1">catch (err) {</span>
            <span class="s1">capable.streaming = false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">else if (res.readyState === 4) {</span>
        <span class="s1">if (!this.statusCode) {</span>
            <span class="s1">this.statusCode = res.status;</span>
            <span class="s1">this.emit('ready');</span>
        <span class="s1">}</span>
        <span class="s1">this._emitData(res);</span>
        
        <span class="s1">if (res.error) {</span>
            <span class="s1">this.emit('error', this.getResponse(res));</span>
        <span class="s1">}</span>
        <span class="s1">else this.emit('end');</span>
        
        <span class="s1">this.emit('close');</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Response.prototype._emitData = function (res) {</span>
    <span class="s1">var respBody = this.getResponse(res);</span>
    <span class="s1">if (respBody.toString().match(/ArrayBuffer/)) {</span>
        <span class="s1">this.emit('data', new Uint8Array(respBody, this.offset));</span>
        <span class="s1">this.offset = respBody.byteLength;</span>
        <span class="s1">return;</span>
    <span class="s1">}</span>
    <span class="s1">if (respBody.length &gt; this.offset) {</span>
        <span class="s1">this.emit('data', respBody.slice(this.offset));</span>
        <span class="s1">this.offset = respBody.length;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">var isArray = Array.isArray || function (xs) {</span>
    <span class="s1">return Object.prototype.toString.call(xs) === '[object Array]';</span>
<span class="s1">};</span>

<span class="s1">},{&quot;stream&quot;:19,&quot;util&quot;:29}],9:[function(require,module,exports){</span>
<span class="s1">exports.read = function (buffer, offset, isLE, mLen, nBytes) {</span>
  <span class="s1">var e, m</span>
  <span class="s1">var eLen = (nBytes * 8) - mLen - 1</span>
  <span class="s1">var eMax = (1 &lt;&lt; eLen) - 1</span>
  <span class="s1">var eBias = eMax &gt;&gt; 1</span>
  <span class="s1">var nBits = -7</span>
  <span class="s1">var i = isLE ? (nBytes - 1) : 0</span>
  <span class="s1">var d = isLE ? -1 : 1</span>
  <span class="s1">var s = buffer[offset + i]</span>

  <span class="s1">i += d</span>

  <span class="s1">e = s &amp; ((1 &lt;&lt; (-nBits)) - 1)</span>
  <span class="s1">s &gt;&gt;= (-nBits)</span>
  <span class="s1">nBits += eLen</span>
  <span class="s1">for (; nBits &gt; 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}</span>

  <span class="s1">m = e &amp; ((1 &lt;&lt; (-nBits)) - 1)</span>
  <span class="s1">e &gt;&gt;= (-nBits)</span>
  <span class="s1">nBits += mLen</span>
  <span class="s1">for (; nBits &gt; 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}</span>

  <span class="s1">if (e === 0) {</span>
    <span class="s1">e = 1 - eBias</span>
  <span class="s1">} else if (e === eMax) {</span>
    <span class="s1">return m ? NaN : ((s ? -1 : 1) * Infinity)</span>
  <span class="s1">} else {</span>
    <span class="s1">m = m + Math.pow(2, mLen)</span>
    <span class="s1">e = e - eBias</span>
  <span class="s1">}</span>
  <span class="s1">return (s ? -1 : 1) * m * Math.pow(2, e - mLen)</span>
<span class="s1">}</span>

<span class="s1">exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {</span>
  <span class="s1">var e, m, c</span>
  <span class="s1">var eLen = (nBytes * 8) - mLen - 1</span>
  <span class="s1">var eMax = (1 &lt;&lt; eLen) - 1</span>
  <span class="s1">var eBias = eMax &gt;&gt; 1</span>
  <span class="s1">var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)</span>
  <span class="s1">var i = isLE ? 0 : (nBytes - 1)</span>
  <span class="s1">var d = isLE ? 1 : -1</span>
  <span class="s1">var s = value &lt; 0 || (value === 0 &amp;&amp; 1 / value &lt; 0) ? 1 : 0</span>

  <span class="s1">value = Math.abs(value)</span>

  <span class="s1">if (isNaN(value) || value === Infinity) {</span>
    <span class="s1">m = isNaN(value) ? 1 : 0</span>
    <span class="s1">e = eMax</span>
  <span class="s1">} else {</span>
    <span class="s1">e = Math.floor(Math.log(value) / Math.LN2)</span>
    <span class="s1">if (value * (c = Math.pow(2, -e)) &lt; 1) {</span>
      <span class="s1">e--</span>
      <span class="s1">c *= 2</span>
    <span class="s1">}</span>
    <span class="s1">if (e + eBias &gt;= 1) {</span>
      <span class="s1">value += rt / c</span>
    <span class="s1">} else {</span>
      <span class="s1">value += rt * Math.pow(2, 1 - eBias)</span>
    <span class="s1">}</span>
    <span class="s1">if (value * c &gt;= 2) {</span>
      <span class="s1">e++</span>
      <span class="s1">c /= 2</span>
    <span class="s1">}</span>

    <span class="s1">if (e + eBias &gt;= eMax) {</span>
      <span class="s1">m = 0</span>
      <span class="s1">e = eMax</span>
    <span class="s1">} else if (e + eBias &gt;= 1) {</span>
      <span class="s1">m = ((value * c) - 1) * Math.pow(2, mLen)</span>
      <span class="s1">e = e + eBias</span>
    <span class="s1">} else {</span>
      <span class="s1">m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)</span>
      <span class="s1">e = 0</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">for (; mLen &gt;= 8; buffer[offset + i] = m &amp; 0xff, i += d, m /= 256, mLen -= 8) {}</span>

  <span class="s1">e = (e &lt;&lt; mLen) | m</span>
  <span class="s1">eLen += mLen</span>
  <span class="s1">for (; eLen &gt; 0; buffer[offset + i] = e &amp; 0xff, i += d, e /= 256, eLen -= 8) {}</span>

  <span class="s1">buffer[offset + i - d] |= s * 128</span>
<span class="s1">}</span>

<span class="s1">},{}],10:[function(require,module,exports){</span>
<span class="s1">if (typeof Object.create === 'function') {</span>
  <span class="s1">// implementation from standard node.js 'util' module</span>
  <span class="s1">module.exports = function inherits(ctor, superCtor) {</span>
    <span class="s1">if (superCtor) {</span>
      <span class="s1">ctor.super_ = superCtor</span>
      <span class="s1">ctor.prototype = Object.create(superCtor.prototype, {</span>
        <span class="s1">constructor: {</span>
          <span class="s1">value: ctor,</span>
          <span class="s1">enumerable: false,</span>
          <span class="s1">writable: true,</span>
          <span class="s1">configurable: true</span>
        <span class="s1">}</span>
      <span class="s1">})</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">} else {</span>
  <span class="s1">// old school shim for old browsers</span>
  <span class="s1">module.exports = function inherits(ctor, superCtor) {</span>
    <span class="s1">if (superCtor) {</span>
      <span class="s1">ctor.super_ = superCtor</span>
      <span class="s1">var TempCtor = function () {}</span>
      <span class="s1">TempCtor.prototype = superCtor.prototype</span>
      <span class="s1">ctor.prototype = new TempCtor()</span>
      <span class="s1">ctor.prototype.constructor = ctor</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">},{}],11:[function(require,module,exports){</span>
<span class="s1">var hasMap = typeof Map === 'function' &amp;&amp; Map.prototype;</span>
<span class="s1">var mapSizeDescriptor = Object.getOwnPropertyDescriptor &amp;&amp; hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;</span>
<span class="s1">var mapSize = hasMap &amp;&amp; mapSizeDescriptor &amp;&amp; typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;</span>
<span class="s1">var mapForEach = hasMap &amp;&amp; Map.prototype.forEach;</span>
<span class="s1">var hasSet = typeof Set === 'function' &amp;&amp; Set.prototype;</span>
<span class="s1">var setSizeDescriptor = Object.getOwnPropertyDescriptor &amp;&amp; hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;</span>
<span class="s1">var setSize = hasSet &amp;&amp; setSizeDescriptor &amp;&amp; typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;</span>
<span class="s1">var setForEach = hasSet &amp;&amp; Set.prototype.forEach;</span>
<span class="s1">var hasWeakMap = typeof WeakMap === 'function' &amp;&amp; WeakMap.prototype;</span>
<span class="s1">var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;</span>
<span class="s1">var hasWeakSet = typeof WeakSet === 'function' &amp;&amp; WeakSet.prototype;</span>
<span class="s1">var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;</span>
<span class="s1">var booleanValueOf = Boolean.prototype.valueOf;</span>
<span class="s1">var objectToString = Object.prototype.toString;</span>
<span class="s1">var match = String.prototype.match;</span>
<span class="s1">var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;</span>

<span class="s1">var inspectCustom = require('./util.inspect').custom;</span>
<span class="s1">var inspectSymbol = inspectCustom &amp;&amp; isSymbol(inspectCustom) ? inspectCustom : null;</span>

<span class="s1">module.exports = function inspect_(obj, options, depth, seen) {</span>
    <span class="s1">var opts = options || {};</span>

    <span class="s1">if (has(opts, 'quoteStyle') &amp;&amp; (opts.quoteStyle !== 'single' &amp;&amp; opts.quoteStyle !== 'double')) {</span>
        <span class="s1">throw new TypeError('option &quot;quoteStyle&quot; must be &quot;single&quot; or &quot;double&quot;');</span>
    <span class="s1">}</span>

    <span class="s1">if (typeof obj === 'undefined') {</span>
        <span class="s1">return 'undefined';</span>
    <span class="s1">}</span>
    <span class="s1">if (obj === null) {</span>
        <span class="s1">return 'null';</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'boolean') {</span>
        <span class="s1">return obj ? 'true' : 'false';</span>
    <span class="s1">}</span>

    <span class="s1">if (typeof obj === 'string') {</span>
        <span class="s1">return inspectString(obj, opts);</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'number') {</span>
        <span class="s1">if (obj === 0) {</span>
            <span class="s1">return Infinity / obj &gt; 0 ? '0' : '-0';</span>
        <span class="s1">}</span>
        <span class="s1">return String(obj);</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'bigint') { // eslint-disable-line valid-typeof</span>
        <span class="s1">return String(obj) + 'n';</span>
    <span class="s1">}</span>

    <span class="s1">var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;</span>
    <span class="s1">if (typeof depth === 'undefined') { depth = 0; }</span>
    <span class="s1">if (depth &gt;= maxDepth &amp;&amp; maxDepth &gt; 0 &amp;&amp; typeof obj === 'object') {</span>
        <span class="s1">return '[Object]';</span>
    <span class="s1">}</span>

    <span class="s1">if (typeof seen === 'undefined') {</span>
        <span class="s1">seen = [];</span>
    <span class="s1">} else if (indexOf(seen, obj) &gt;= 0) {</span>
        <span class="s1">return '[Circular]';</span>
    <span class="s1">}</span>

    <span class="s1">function inspect(value, from) {</span>
        <span class="s1">if (from) {</span>
            <span class="s1">seen = seen.slice();</span>
            <span class="s1">seen.push(from);</span>
        <span class="s1">}</span>
        <span class="s1">return inspect_(value, opts, depth + 1, seen);</span>
    <span class="s1">}</span>

    <span class="s1">if (typeof obj === 'function') {</span>
        <span class="s1">var name = nameOf(obj);</span>
        <span class="s1">return '[Function' + (name ? ': ' + name : '') + ']';</span>
    <span class="s1">}</span>
    <span class="s1">if (isSymbol(obj)) {</span>
        <span class="s1">var symString = Symbol.prototype.toString.call(obj);</span>
        <span class="s1">return typeof obj === 'object' ? markBoxed(symString) : symString;</span>
    <span class="s1">}</span>
    <span class="s1">if (isElement(obj)) {</span>
        <span class="s1">var s = '&lt;' + String(obj.nodeName).toLowerCase();</span>
        <span class="s1">var attrs = obj.attributes || [];</span>
        <span class="s1">for (var i = 0; i &lt; attrs.length; i++) {</span>
            <span class="s1">s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);</span>
        <span class="s1">}</span>
        <span class="s1">s += '&gt;';</span>
        <span class="s1">if (obj.childNodes &amp;&amp; obj.childNodes.length) { s += '...'; }</span>
        <span class="s1">s += '&lt;/' + String(obj.nodeName).toLowerCase() + '&gt;';</span>
        <span class="s1">return s;</span>
    <span class="s1">}</span>
    <span class="s1">if (isArray(obj)) {</span>
        <span class="s1">if (obj.length === 0) { return '[]'; }</span>
        <span class="s1">return '[ ' + arrObjKeys(obj, inspect).join(', ') + ' ]';</span>
    <span class="s1">}</span>
    <span class="s1">if (isError(obj)) {</span>
        <span class="s1">var parts = arrObjKeys(obj, inspect);</span>
        <span class="s1">if (parts.length === 0) { return '[' + String(obj) + ']'; }</span>
        <span class="s1">return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'object') {</span>
        <span class="s1">if (inspectSymbol &amp;&amp; typeof obj[inspectSymbol] === 'function') {</span>
            <span class="s1">return obj[inspectSymbol]();</span>
        <span class="s1">} else if (typeof obj.inspect === 'function') {</span>
            <span class="s1">return obj.inspect();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">if (isMap(obj)) {</span>
        <span class="s1">var mapParts = [];</span>
        <span class="s1">mapForEach.call(obj, function (value, key) {</span>
            <span class="s1">mapParts.push(inspect(key, obj) + ' =&gt; ' + inspect(value, obj));</span>
        <span class="s1">});</span>
        <span class="s1">return collectionOf('Map', mapSize.call(obj), mapParts);</span>
    <span class="s1">}</span>
    <span class="s1">if (isSet(obj)) {</span>
        <span class="s1">var setParts = [];</span>
        <span class="s1">setForEach.call(obj, function (value) {</span>
            <span class="s1">setParts.push(inspect(value, obj));</span>
        <span class="s1">});</span>
        <span class="s1">return collectionOf('Set', setSize.call(obj), setParts);</span>
    <span class="s1">}</span>
    <span class="s1">if (isWeakMap(obj)) {</span>
        <span class="s1">return weakCollectionOf('WeakMap');</span>
    <span class="s1">}</span>
    <span class="s1">if (isWeakSet(obj)) {</span>
        <span class="s1">return weakCollectionOf('WeakSet');</span>
    <span class="s1">}</span>
    <span class="s1">if (isNumber(obj)) {</span>
        <span class="s1">return markBoxed(inspect(Number(obj)));</span>
    <span class="s1">}</span>
    <span class="s1">if (isBigInt(obj)) {</span>
        <span class="s1">return markBoxed(inspect(bigIntValueOf.call(obj)));</span>
    <span class="s1">}</span>
    <span class="s1">if (isBoolean(obj)) {</span>
        <span class="s1">return markBoxed(booleanValueOf.call(obj));</span>
    <span class="s1">}</span>
    <span class="s1">if (isString(obj)) {</span>
        <span class="s1">return markBoxed(inspect(String(obj)));</span>
    <span class="s1">}</span>
    <span class="s1">if (!isDate(obj) &amp;&amp; !isRegExp(obj)) {</span>
        <span class="s1">var xs = arrObjKeys(obj, inspect);</span>
        <span class="s1">if (xs.length === 0) { return '{}'; }</span>
        <span class="s1">return '{ ' + xs.join(', ') + ' }';</span>
    <span class="s1">}</span>
    <span class="s1">return String(obj);</span>
<span class="s1">};</span>

<span class="s1">function wrapQuotes(s, defaultStyle, opts) {</span>
    <span class="s1">var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '&quot;' : &quot;'&quot;;</span>
    <span class="s1">return quoteChar + s + quoteChar;</span>
<span class="s1">}</span>

<span class="s1">function quote(s) {</span>
    <span class="s1">return String(s).replace(/&quot;/g, '</span><span class="s4">&amp;quot;</span><span class="s1">');</span>
<span class="s1">}</span>

<span class="s1">function isArray(obj) { return toStr(obj) === '[object Array]'; }</span>
<span class="s1">function isDate(obj) { return toStr(obj) === '[object Date]'; }</span>
<span class="s1">function isRegExp(obj) { return toStr(obj) === '[object RegExp]'; }</span>
<span class="s1">function isError(obj) { return toStr(obj) === '[object Error]'; }</span>
<span class="s1">function isSymbol(obj) { return toStr(obj) === '[object Symbol]'; }</span>
<span class="s1">function isString(obj) { return toStr(obj) === '[object String]'; }</span>
<span class="s1">function isNumber(obj) { return toStr(obj) === '[object Number]'; }</span>
<span class="s1">function isBigInt(obj) { return toStr(obj) === '[object BigInt]'; }</span>
<span class="s1">function isBoolean(obj) { return toStr(obj) === '[object Boolean]'; }</span>

<span class="s1">var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };</span>
<span class="s1">function has(obj, key) {</span>
    <span class="s1">return hasOwn.call(obj, key);</span>
<span class="s1">}</span>

<span class="s1">function toStr(obj) {</span>
    <span class="s1">return objectToString.call(obj);</span>
<span class="s1">}</span>

<span class="s1">function nameOf(f) {</span>
    <span class="s1">if (f.name) { return f.name; }</span>
    <span class="s1">var m = match.call(f, /^function\s*([\w$]+)/);</span>
    <span class="s1">if (m) { return m[1]; }</span>
    <span class="s1">return null;</span>
<span class="s1">}</span>

<span class="s1">function indexOf(xs, x) {</span>
    <span class="s1">if (xs.indexOf) { return xs.indexOf(x); }</span>
    <span class="s1">for (var i = 0, l = xs.length; i &lt; l; i++) {</span>
        <span class="s1">if (xs[i] === x) { return i; }</span>
    <span class="s1">}</span>
    <span class="s1">return -1;</span>
<span class="s1">}</span>

<span class="s1">function isMap(x) {</span>
    <span class="s1">if (!mapSize || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">mapSize.call(x);</span>
        <span class="s1">try {</span>
            <span class="s1">setSize.call(x);</span>
        <span class="s1">} catch (s) {</span>
            <span class="s1">return true;</span>
        <span class="s1">}</span>
        <span class="s1">return x instanceof Map; // core-js workaround, pre-v2.5.0</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isWeakMap(x) {</span>
    <span class="s1">if (!weakMapHas || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">weakMapHas.call(x, weakMapHas);</span>
        <span class="s1">try {</span>
            <span class="s1">weakSetHas.call(x, weakSetHas);</span>
        <span class="s1">} catch (s) {</span>
            <span class="s1">return true;</span>
        <span class="s1">}</span>
        <span class="s1">return x instanceof WeakMap; // core-js workaround, pre-v2.5.0</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isSet(x) {</span>
    <span class="s1">if (!setSize || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">setSize.call(x);</span>
        <span class="s1">try {</span>
            <span class="s1">mapSize.call(x);</span>
        <span class="s1">} catch (m) {</span>
            <span class="s1">return true;</span>
        <span class="s1">}</span>
        <span class="s1">return x instanceof Set; // core-js workaround, pre-v2.5.0</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isWeakSet(x) {</span>
    <span class="s1">if (!weakSetHas || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">weakSetHas.call(x, weakSetHas);</span>
        <span class="s1">try {</span>
            <span class="s1">weakMapHas.call(x, weakMapHas);</span>
        <span class="s1">} catch (s) {</span>
            <span class="s1">return true;</span>
        <span class="s1">}</span>
        <span class="s1">return x instanceof WeakSet; // core-js workaround, pre-v2.5.0</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isElement(x) {</span>
    <span class="s1">if (!x || typeof x !== 'object') { return false; }</span>
    <span class="s1">if (typeof HTMLElement !== 'undefined' &amp;&amp; x instanceof HTMLElement) {</span>
        <span class="s1">return true;</span>
    <span class="s1">}</span>
    <span class="s1">return typeof x.nodeName === 'string' &amp;&amp; typeof x.getAttribute === 'function';</span>
<span class="s1">}</span>

<span class="s1">function inspectString(str, opts) {</span>
    <span class="s1">// eslint-disable-next-line no-control-regex</span>
    <span class="s1">var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);</span>
    <span class="s1">return wrapQuotes(s, 'single', opts);</span>
<span class="s1">}</span>

<span class="s1">function lowbyte(c) {</span>
    <span class="s1">var n = c.charCodeAt(0);</span>
    <span class="s1">var x = {</span>
        <span class="s1">8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r'</span>
    <span class="s1">}[n];</span>
    <span class="s1">if (x) { return '\\' + x; }</span>
    <span class="s1">return '\\x' + (n &lt; 0x10 ? '0' : '') + n.toString(16);</span>
<span class="s1">}</span>

<span class="s1">function markBoxed(str) {</span>
    <span class="s1">return 'Object(' + str + ')';</span>
<span class="s1">}</span>

<span class="s1">function weakCollectionOf(type) {</span>
    <span class="s1">return type + ' { ? }';</span>
<span class="s1">}</span>

<span class="s1">function collectionOf(type, size, entries) {</span>
    <span class="s1">return type + ' (' + size + ') {' + entries.join(', ') + '}';</span>
<span class="s1">}</span>

<span class="s1">function arrObjKeys(obj, inspect) {</span>
    <span class="s1">var isArr = isArray(obj);</span>
    <span class="s1">var xs = [];</span>
    <span class="s1">if (isArr) {</span>
        <span class="s1">xs.length = obj.length;</span>
        <span class="s1">for (var i = 0; i &lt; obj.length; i++) {</span>
            <span class="s1">xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">for (var key in obj) { // eslint-disable-line no-restricted-syntax</span>
        <span class="s1">if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue</span>
        <span class="s1">if (isArr &amp;&amp; String(Number(key)) === key &amp;&amp; key &lt; obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue</span>
        <span class="s1">if ((/[^\w$]/).test(key)) {</span>
            <span class="s1">xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));</span>
        <span class="s1">} else {</span>
            <span class="s1">xs.push(key + ': ' + inspect(obj[key], obj));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return xs;</span>
<span class="s1">}</span>

<span class="s1">},{&quot;./util.inspect&quot;:12}],12:[function(require,module,exports){</span>
<span class="s1">module.exports = require('util').inspect;</span>

<span class="s1">},{&quot;util&quot;:29}],13:[function(require,module,exports){</span>
<span class="s1">// shim for using process in browser</span>

<span class="s1">var process = module.exports = {};</span>

<span class="s1">process.nextTick = (function () {</span>
    <span class="s1">var canSetImmediate = typeof window !== 'undefined'</span>
    <span class="s1">&amp;&amp; window.setImmediate;</span>
    <span class="s1">var canPost = typeof window !== 'undefined'</span>
    <span class="s1">&amp;&amp; window.postMessage &amp;&amp; window.addEventListener</span>
    <span class="s1">;</span>

    <span class="s1">if (canSetImmediate) {</span>
        <span class="s1">return function (f) { return window.setImmediate(f) };</span>
    <span class="s1">}</span>

    <span class="s1">if (canPost) {</span>
        <span class="s1">var queue = [];</span>
        <span class="s1">window.addEventListener('message', function (ev) {</span>
            <span class="s1">var source = ev.source;</span>
            <span class="s1">if ((source === window || source === null) &amp;&amp; ev.data === 'process-tick') {</span>
                <span class="s1">ev.stopPropagation();</span>
                <span class="s1">if (queue.length &gt; 0) {</span>
                    <span class="s1">var fn = queue.shift();</span>
                    <span class="s1">fn();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}, true);</span>

        <span class="s1">return function nextTick(fn) {</span>
            <span class="s1">queue.push(fn);</span>
            <span class="s1">window.postMessage('process-tick', '*');</span>
        <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s1">return function nextTick(fn) {</span>
        <span class="s1">setTimeout(fn, 0);</span>
    <span class="s1">};</span>
<span class="s1">})();</span>

<span class="s1">process.title = 'browser';</span>
<span class="s1">process.browser = true;</span>
<span class="s1">process.env = {};</span>
<span class="s1">process.argv = [];</span>

<span class="s1">function noop() {}</span>

<span class="s1">process.on = noop;</span>
<span class="s1">process.addListener = noop;</span>
<span class="s1">process.once = noop;</span>
<span class="s1">process.off = noop;</span>
<span class="s1">process.removeListener = noop;</span>
<span class="s1">process.removeAllListeners = noop;</span>
<span class="s1">process.emit = noop;</span>

<span class="s1">process.binding = function (name) {</span>
    <span class="s1">throw new Error('process.binding is not supported');</span>
<span class="s1">}</span>

<span class="s1">// TODO(shtylman)</span>
<span class="s1">process.cwd = function () { return '/' };</span>
<span class="s1">process.chdir = function (dir) {</span>
    <span class="s1">throw new Error('process.chdir is not supported');</span>
<span class="s1">};</span>

<span class="s1">},{}],14:[function(require,module,exports){</span>
<span class="s1">(function (global){</span>
<span class="s1">/*! http://mths.be/punycode v1.2.4 by @mathias */</span>
<span class="s1">;(function(root) {</span>

	<span class="s1">/** Detect free variables */</span>
	<span class="s1">var freeExports = typeof exports == 'object' &amp;&amp; exports;</span>
	<span class="s1">var freeModule = typeof module == 'object' &amp;&amp; module &amp;&amp;</span>
		<span class="s1">module.exports == freeExports &amp;&amp; module;</span>
	<span class="s1">var freeGlobal = typeof global == 'object' &amp;&amp; global;</span>
	<span class="s1">if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {</span>
		<span class="s1">root = freeGlobal;</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* The `punycode` object.</span>
	 <span class="s1">* @name punycode</span>
	 <span class="s1">* @type Object</span>
	 <span class="s1">*/</span>
	<span class="s1">var punycode,</span>

	<span class="s1">/** Highest positive signed 32-bit float value */</span>
	<span class="s1">maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1</span>

	<span class="s1">/** Bootstring parameters */</span>
	<span class="s1">base = 36,</span>
	<span class="s1">tMin = 1,</span>
	<span class="s1">tMax = 26,</span>
	<span class="s1">skew = 38,</span>
	<span class="s1">damp = 700,</span>
	<span class="s1">initialBias = 72,</span>
	<span class="s1">initialN = 128, // 0x80</span>
	<span class="s1">delimiter = '-', // '\x2D'</span>

	<span class="s1">/** Regular expressions */</span>
	<span class="s1">regexPunycode = /^xn--/,</span>
	<span class="s1">regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars</span>
	<span class="s1">regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators</span>

	<span class="s1">/** Error messages */</span>
	<span class="s1">errors = {</span>
		<span class="s1">'overflow': 'Overflow: input needs wider integers to process',</span>
		<span class="s1">'not-basic': 'Illegal input &gt;= 0x80 (not a basic code point)',</span>
		<span class="s1">'invalid-input': 'Invalid input'</span>
	<span class="s1">},</span>

	<span class="s1">/** Convenience shortcuts */</span>
	<span class="s1">baseMinusTMin = base - tMin,</span>
	<span class="s1">floor = Math.floor,</span>
	<span class="s1">stringFromCharCode = String.fromCharCode,</span>

	<span class="s1">/** Temporary variable */</span>
	<span class="s1">key;</span>

	<span class="s1">/*--------------------------------------------------------------------------*/</span>

	<span class="s1">/**</span>
	 <span class="s1">* A generic error utility function.</span>
	 <span class="s1">* @private</span>
	 <span class="s1">* @param {String} type The error type.</span>
	 <span class="s1">* @returns {Error} Throws a `RangeError` with the applicable error message.</span>
	 <span class="s1">*/</span>
	<span class="s1">function error(type) {</span>
		<span class="s1">throw RangeError(errors[type]);</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* A generic `Array#map` utility function.</span>
	 <span class="s1">* @private</span>
	 <span class="s1">* @param {Array} array The array to iterate over.</span>
	 <span class="s1">* @param {Function} callback The function that gets called for every array</span>
	 <span class="s1">* item.</span>
	 <span class="s1">* @returns {Array} A new array of values returned by the callback function.</span>
	 <span class="s1">*/</span>
	<span class="s1">function map(array, fn) {</span>
		<span class="s1">var length = array.length;</span>
		<span class="s1">while (length--) {</span>
			<span class="s1">array[length] = fn(array[length]);</span>
		<span class="s1">}</span>
		<span class="s1">return array;</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* A simple `Array#map`-like wrapper to work with domain name strings.</span>
	 <span class="s1">* @private</span>
	 <span class="s1">* @param {String} domain The domain name.</span>
	 <span class="s1">* @param {Function} callback The function that gets called for every</span>
	 <span class="s1">* character.</span>
	 <span class="s1">* @returns {Array} A new string of characters returned by the callback</span>
	 <span class="s1">* function.</span>
	 <span class="s1">*/</span>
	<span class="s1">function mapDomain(string, fn) {</span>
		<span class="s1">return map(string.split(regexSeparators), fn).join('.');</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Creates an array containing the numeric code points of each Unicode</span>
	 <span class="s1">* character in the string. While JavaScript uses UCS-2 internally,</span>
	 <span class="s1">* this function will convert a pair of surrogate halves (each of which</span>
	 <span class="s1">* UCS-2 exposes as separate characters) into a single code point,</span>
	 <span class="s1">* matching UTF-16.</span>
	 <span class="s1">* @see `punycode.ucs2.encode`</span>
	 <span class="s1">* @see &lt;http://mathiasbynens.be/notes/javascript-encoding&gt;</span>
	 <span class="s1">* @memberOf punycode.ucs2</span>
	 <span class="s1">* @name decode</span>
	 <span class="s1">* @param {String} string The Unicode input string (UCS-2).</span>
	 <span class="s1">* @returns {Array} The new array of code points.</span>
	 <span class="s1">*/</span>
	<span class="s1">function ucs2decode(string) {</span>
		<span class="s1">var output = [],</span>
		    <span class="s1">counter = 0,</span>
		    <span class="s1">length = string.length,</span>
		    <span class="s1">value,</span>
		    <span class="s1">extra;</span>
		<span class="s1">while (counter &lt; length) {</span>
			<span class="s1">value = string.charCodeAt(counter++);</span>
			<span class="s1">if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {</span>
				<span class="s1">// high surrogate, and there is a next character</span>
				<span class="s1">extra = string.charCodeAt(counter++);</span>
				<span class="s1">if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate</span>
					<span class="s1">output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);</span>
				<span class="s1">} else {</span>
					<span class="s1">// unmatched surrogate; only append this code unit, in case the next</span>
					<span class="s1">// code unit is the high surrogate of a surrogate pair</span>
					<span class="s1">output.push(value);</span>
					<span class="s1">counter--;</span>
				<span class="s1">}</span>
			<span class="s1">} else {</span>
				<span class="s1">output.push(value);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">return output;</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Creates a string based on an array of numeric code points.</span>
	 <span class="s1">* @see `punycode.ucs2.decode`</span>
	 <span class="s1">* @memberOf punycode.ucs2</span>
	 <span class="s1">* @name encode</span>
	 <span class="s1">* @param {Array} codePoints The array of numeric code points.</span>
	 <span class="s1">* @returns {String} The new Unicode string (UCS-2).</span>
	 <span class="s1">*/</span>
	<span class="s1">function ucs2encode(array) {</span>
		<span class="s1">return map(array, function(value) {</span>
			<span class="s1">var output = '';</span>
			<span class="s1">if (value &gt; 0xFFFF) {</span>
				<span class="s1">value -= 0x10000;</span>
				<span class="s1">output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);</span>
				<span class="s1">value = 0xDC00 | value &amp; 0x3FF;</span>
			<span class="s1">}</span>
			<span class="s1">output += stringFromCharCode(value);</span>
			<span class="s1">return output;</span>
		<span class="s1">}).join('');</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Converts a basic code point into a digit/integer.</span>
	 <span class="s1">* @see `digitToBasic()`</span>
	 <span class="s1">* @private</span>
	 <span class="s1">* @param {Number} codePoint The basic numeric code point value.</span>
	 <span class="s1">* @returns {Number} The numeric value of a basic code point (for use in</span>
	 <span class="s1">* representing integers) in the range `0` to `base - 1`, or `base` if</span>
	 <span class="s1">* the code point does not represent a value.</span>
	 <span class="s1">*/</span>
	<span class="s1">function basicToDigit(codePoint) {</span>
		<span class="s1">if (codePoint - 48 &lt; 10) {</span>
			<span class="s1">return codePoint - 22;</span>
		<span class="s1">}</span>
		<span class="s1">if (codePoint - 65 &lt; 26) {</span>
			<span class="s1">return codePoint - 65;</span>
		<span class="s1">}</span>
		<span class="s1">if (codePoint - 97 &lt; 26) {</span>
			<span class="s1">return codePoint - 97;</span>
		<span class="s1">}</span>
		<span class="s1">return base;</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Converts a digit/integer into a basic code point.</span>
	 <span class="s1">* @see `basicToDigit()`</span>
	 <span class="s1">* @private</span>
	 <span class="s1">* @param {Number} digit The numeric value of a basic code point.</span>
	 <span class="s1">* @returns {Number} The basic code point whose value (when used for</span>
	 <span class="s1">* representing integers) is `digit`, which needs to be in the range</span>
	 <span class="s1">* `0` to `base - 1`. If `flag` is non-zero, the uppercase form is</span>
	 <span class="s1">* used; else, the lowercase form is used. The behavior is undefined</span>
	 <span class="s1">* if `flag` is non-zero and `digit` has no uppercase form.</span>
	 <span class="s1">*/</span>
	<span class="s1">function digitToBasic(digit, flag) {</span>
		<span class="s1">//  0..25 map to ASCII a..z or A..Z</span>
		<span class="s1">// 26..35 map to ASCII 0..9</span>
		<span class="s1">return digit + 22 + 75 * (digit &lt; 26) - ((flag != 0) &lt;&lt; 5);</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Bias adaptation function as per section 3.4 of RFC 3492.</span>
	 <span class="s1">* http://tools.ietf.org/html/rfc3492#section-3.4</span>
	 <span class="s1">* @private</span>
	 <span class="s1">*/</span>
	<span class="s1">function adapt(delta, numPoints, firstTime) {</span>
		<span class="s1">var k = 0;</span>
		<span class="s1">delta = firstTime ? floor(delta / damp) : delta &gt;&gt; 1;</span>
		<span class="s1">delta += floor(delta / numPoints);</span>
		<span class="s1">for (/* no initialization */; delta &gt; baseMinusTMin * tMax &gt;&gt; 1; k += base) {</span>
			<span class="s1">delta = floor(delta / baseMinusTMin);</span>
		<span class="s1">}</span>
		<span class="s1">return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Converts a Punycode string of ASCII-only symbols to a string of Unicode</span>
	 <span class="s1">* symbols.</span>
	 <span class="s1">* @memberOf punycode</span>
	 <span class="s1">* @param {String} input The Punycode string of ASCII-only symbols.</span>
	 <span class="s1">* @returns {String} The resulting string of Unicode symbols.</span>
	 <span class="s1">*/</span>
	<span class="s1">function decode(input) {</span>
		<span class="s1">// Don't use UCS-2</span>
		<span class="s1">var output = [],</span>
		    <span class="s1">inputLength = input.length,</span>
		    <span class="s1">out,</span>
		    <span class="s1">i = 0,</span>
		    <span class="s1">n = initialN,</span>
		    <span class="s1">bias = initialBias,</span>
		    <span class="s1">basic,</span>
		    <span class="s1">j,</span>
		    <span class="s1">index,</span>
		    <span class="s1">oldi,</span>
		    <span class="s1">w,</span>
		    <span class="s1">k,</span>
		    <span class="s1">digit,</span>
		    <span class="s1">t,</span>
		    <span class="s1">/** Cached calculation results */</span>
		    <span class="s1">baseMinusT;</span>

		<span class="s1">// Handle the basic code points: let `basic` be the number of input code</span>
		<span class="s1">// points before the last delimiter, or `0` if there is none, then copy</span>
		<span class="s1">// the first basic code points to the output.</span>

		<span class="s1">basic = input.lastIndexOf(delimiter);</span>
		<span class="s1">if (basic &lt; 0) {</span>
			<span class="s1">basic = 0;</span>
		<span class="s1">}</span>

		<span class="s1">for (j = 0; j &lt; basic; ++j) {</span>
			<span class="s1">// if it's not a basic code point</span>
			<span class="s1">if (input.charCodeAt(j) &gt;= 0x80) {</span>
				<span class="s1">error('not-basic');</span>
			<span class="s1">}</span>
			<span class="s1">output.push(input.charCodeAt(j));</span>
		<span class="s1">}</span>

		<span class="s1">// Main decoding loop: start just after the last delimiter if any basic code</span>
		<span class="s1">// points were copied; start at the beginning otherwise.</span>

		<span class="s1">for (index = basic &gt; 0 ? basic + 1 : 0; index &lt; inputLength; /* no final expression */) {</span>

			<span class="s1">// `index` is the index of the next character to be consumed.</span>
			<span class="s1">// Decode a generalized variable-length integer into `delta`,</span>
			<span class="s1">// which gets added to `i`. The overflow checking is easier</span>
			<span class="s1">// if we increase `i` as we go, then subtract off its starting</span>
			<span class="s1">// value at the end to obtain `delta`.</span>
			<span class="s1">for (oldi = i, w = 1, k = base; /* no condition */; k += base) {</span>

				<span class="s1">if (index &gt;= inputLength) {</span>
					<span class="s1">error('invalid-input');</span>
				<span class="s1">}</span>

				<span class="s1">digit = basicToDigit(input.charCodeAt(index++));</span>

				<span class="s1">if (digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {</span>
					<span class="s1">error('overflow');</span>
				<span class="s1">}</span>

				<span class="s1">i += digit * w;</span>
				<span class="s1">t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);</span>

				<span class="s1">if (digit &lt; t) {</span>
					<span class="s1">break;</span>
				<span class="s1">}</span>

				<span class="s1">baseMinusT = base - t;</span>
				<span class="s1">if (w &gt; floor(maxInt / baseMinusT)) {</span>
					<span class="s1">error('overflow');</span>
				<span class="s1">}</span>

				<span class="s1">w *= baseMinusT;</span>

			<span class="s1">}</span>

			<span class="s1">out = output.length + 1;</span>
			<span class="s1">bias = adapt(i - oldi, out, oldi == 0);</span>

			<span class="s1">// `i` was supposed to wrap around from `out` to `0`,</span>
			<span class="s1">// incrementing `n` each time, so we'll fix that now:</span>
			<span class="s1">if (floor(i / out) &gt; maxInt - n) {</span>
				<span class="s1">error('overflow');</span>
			<span class="s1">}</span>

			<span class="s1">n += floor(i / out);</span>
			<span class="s1">i %= out;</span>

			<span class="s1">// Insert `n` at position `i` of the output</span>
			<span class="s1">output.splice(i++, 0, n);</span>

		<span class="s1">}</span>

		<span class="s1">return ucs2encode(output);</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Converts a string of Unicode symbols to a Punycode string of ASCII-only</span>
	 <span class="s1">* symbols.</span>
	 <span class="s1">* @memberOf punycode</span>
	 <span class="s1">* @param {String} input The string of Unicode symbols.</span>
	 <span class="s1">* @returns {String} The resulting Punycode string of ASCII-only symbols.</span>
	 <span class="s1">*/</span>
	<span class="s1">function encode(input) {</span>
		<span class="s1">var n,</span>
		    <span class="s1">delta,</span>
		    <span class="s1">handledCPCount,</span>
		    <span class="s1">basicLength,</span>
		    <span class="s1">bias,</span>
		    <span class="s1">j,</span>
		    <span class="s1">m,</span>
		    <span class="s1">q,</span>
		    <span class="s1">k,</span>
		    <span class="s1">t,</span>
		    <span class="s1">currentValue,</span>
		    <span class="s1">output = [],</span>
		    <span class="s1">/** `inputLength` will hold the number of code points in `input`. */</span>
		    <span class="s1">inputLength,</span>
		    <span class="s1">/** Cached calculation results */</span>
		    <span class="s1">handledCPCountPlusOne,</span>
		    <span class="s1">baseMinusT,</span>
		    <span class="s1">qMinusT;</span>

		<span class="s1">// Convert the input in UCS-2 to Unicode</span>
		<span class="s1">input = ucs2decode(input);</span>

		<span class="s1">// Cache the length</span>
		<span class="s1">inputLength = input.length;</span>

		<span class="s1">// Initialize the state</span>
		<span class="s1">n = initialN;</span>
		<span class="s1">delta = 0;</span>
		<span class="s1">bias = initialBias;</span>

		<span class="s1">// Handle the basic code points</span>
		<span class="s1">for (j = 0; j &lt; inputLength; ++j) {</span>
			<span class="s1">currentValue = input[j];</span>
			<span class="s1">if (currentValue &lt; 0x80) {</span>
				<span class="s1">output.push(stringFromCharCode(currentValue));</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">handledCPCount = basicLength = output.length;</span>

		<span class="s1">// `handledCPCount` is the number of code points that have been handled;</span>
		<span class="s1">// `basicLength` is the number of basic code points.</span>

		<span class="s1">// Finish the basic string - if it is not empty - with a delimiter</span>
		<span class="s1">if (basicLength) {</span>
			<span class="s1">output.push(delimiter);</span>
		<span class="s1">}</span>

		<span class="s1">// Main encoding loop:</span>
		<span class="s1">while (handledCPCount &lt; inputLength) {</span>

			<span class="s1">// All non-basic code points &lt; n have been handled already. Find the next</span>
			<span class="s1">// larger one:</span>
			<span class="s1">for (m = maxInt, j = 0; j &lt; inputLength; ++j) {</span>
				<span class="s1">currentValue = input[j];</span>
				<span class="s1">if (currentValue &gt;= n &amp;&amp; currentValue &lt; m) {</span>
					<span class="s1">m = currentValue;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s1">// Increase `delta` enough to advance the decoder's &lt;n,i&gt; state to &lt;m,0&gt;,</span>
			<span class="s1">// but guard against overflow</span>
			<span class="s1">handledCPCountPlusOne = handledCPCount + 1;</span>
			<span class="s1">if (m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {</span>
				<span class="s1">error('overflow');</span>
			<span class="s1">}</span>

			<span class="s1">delta += (m - n) * handledCPCountPlusOne;</span>
			<span class="s1">n = m;</span>

			<span class="s1">for (j = 0; j &lt; inputLength; ++j) {</span>
				<span class="s1">currentValue = input[j];</span>

				<span class="s1">if (currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {</span>
					<span class="s1">error('overflow');</span>
				<span class="s1">}</span>

				<span class="s1">if (currentValue == n) {</span>
					<span class="s1">// Represent delta as a generalized variable-length integer</span>
					<span class="s1">for (q = delta, k = base; /* no condition */; k += base) {</span>
						<span class="s1">t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);</span>
						<span class="s1">if (q &lt; t) {</span>
							<span class="s1">break;</span>
						<span class="s1">}</span>
						<span class="s1">qMinusT = q - t;</span>
						<span class="s1">baseMinusT = base - t;</span>
						<span class="s1">output.push(</span>
							<span class="s1">stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))</span>
						<span class="s1">);</span>
						<span class="s1">q = floor(qMinusT / baseMinusT);</span>
					<span class="s1">}</span>

					<span class="s1">output.push(stringFromCharCode(digitToBasic(q, 0)));</span>
					<span class="s1">bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);</span>
					<span class="s1">delta = 0;</span>
					<span class="s1">++handledCPCount;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s1">++delta;</span>
			<span class="s1">++n;</span>

		<span class="s1">}</span>
		<span class="s1">return output.join('');</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Converts a Punycode string representing a domain name to Unicode. Only the</span>
	 <span class="s1">* Punycoded parts of the domain name will be converted, i.e. it doesn't</span>
	 <span class="s1">* matter if you call it on a string that has already been converted to</span>
	 <span class="s1">* Unicode.</span>
	 <span class="s1">* @memberOf punycode</span>
	 <span class="s1">* @param {String} domain The Punycode domain name to convert to Unicode.</span>
	 <span class="s1">* @returns {String} The Unicode representation of the given Punycode</span>
	 <span class="s1">* string.</span>
	 <span class="s1">*/</span>
	<span class="s1">function toUnicode(domain) {</span>
		<span class="s1">return mapDomain(domain, function(string) {</span>
			<span class="s1">return regexPunycode.test(string)</span>
				<span class="s1">? decode(string.slice(4).toLowerCase())</span>
				<span class="s1">: string;</span>
		<span class="s1">});</span>
	<span class="s1">}</span>

	<span class="s1">/**</span>
	 <span class="s1">* Converts a Unicode string representing a domain name to Punycode. Only the</span>
	 <span class="s1">* non-ASCII parts of the domain name will be converted, i.e. it doesn't</span>
	 <span class="s1">* matter if you call it with a domain that's already in ASCII.</span>
	 <span class="s1">* @memberOf punycode</span>
	 <span class="s1">* @param {String} domain The domain name to convert, as a Unicode string.</span>
	 <span class="s1">* @returns {String} The Punycode representation of the given domain name.</span>
	 <span class="s1">*/</span>
	<span class="s1">function toASCII(domain) {</span>
		<span class="s1">return mapDomain(domain, function(string) {</span>
			<span class="s1">return regexNonASCII.test(string)</span>
				<span class="s1">? 'xn--' + encode(string)</span>
				<span class="s1">: string;</span>
		<span class="s1">});</span>
	<span class="s1">}</span>

	<span class="s1">/*--------------------------------------------------------------------------*/</span>

	<span class="s1">/** Define the public API */</span>
	<span class="s1">punycode = {</span>
		<span class="s1">/**</span>
		 <span class="s1">* A string representing the current Punycode.js version number.</span>
		 <span class="s1">* @memberOf punycode</span>
		 <span class="s1">* @type String</span>
		 <span class="s1">*/</span>
		<span class="s1">'version': '1.2.4',</span>
		<span class="s1">/**</span>
		 <span class="s1">* An object of methods to convert from JavaScript's internal character</span>
		 <span class="s1">* representation (UCS-2) to Unicode code points, and back.</span>
		 <span class="s1">* @see &lt;http://mathiasbynens.be/notes/javascript-encoding&gt;</span>
		 <span class="s1">* @memberOf punycode</span>
		 <span class="s1">* @type Object</span>
		 <span class="s1">*/</span>
		<span class="s1">'ucs2': {</span>
			<span class="s1">'decode': ucs2decode,</span>
			<span class="s1">'encode': ucs2encode</span>
		<span class="s1">},</span>
		<span class="s1">'decode': decode,</span>
		<span class="s1">'encode': encode,</span>
		<span class="s1">'toASCII': toASCII,</span>
		<span class="s1">'toUnicode': toUnicode</span>
	<span class="s1">};</span>

	<span class="s1">/** Expose `punycode` */</span>
	<span class="s1">// Some AMD build optimizers, like r.js, check for specific condition patterns</span>
	<span class="s1">// like the following:</span>
	<span class="s1">if (</span>
		<span class="s1">typeof define == 'function' &amp;&amp;</span>
		<span class="s1">typeof define.amd == 'object' &amp;&amp;</span>
		<span class="s1">define.amd</span>
	<span class="s1">) {</span>
		<span class="s1">define('punycode', function() {</span>
			<span class="s1">return punycode;</span>
		<span class="s1">});</span>
	<span class="s1">} else if (freeExports &amp;&amp; !freeExports.nodeType) {</span>
		<span class="s1">if (freeModule) { // in Node.js or RingoJS v0.8.0+</span>
			<span class="s1">freeModule.exports = punycode;</span>
		<span class="s1">} else { // in Narwhal or RingoJS v0.7.0-</span>
			<span class="s1">for (key in punycode) {</span>
				<span class="s1">punycode.hasOwnProperty(key) &amp;&amp; (freeExports[key] = punycode[key]);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">} else { // in Rhino or a web browser</span>
		<span class="s1">root.punycode = punycode;</span>
	<span class="s1">}</span>

<span class="s1">}(this));</span>

<span class="s1">}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})</span>
<span class="s1">},{}],15:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">'use strict';</span>

<span class="s1">// If obj.hasOwnProperty has been overridden, then calling</span>
<span class="s1">// obj.hasOwnProperty(prop) will break.</span>
<span class="s1">// See: https://github.com/joyent/node/issues/1707</span>
<span class="s1">function hasOwnProperty(obj, prop) {</span>
  <span class="s1">return Object.prototype.hasOwnProperty.call(obj, prop);</span>
<span class="s1">}</span>

<span class="s1">module.exports = function(qs, sep, eq, options) {</span>
  <span class="s1">sep = sep || '&amp;';</span>
  <span class="s1">eq = eq || '=';</span>
  <span class="s1">var obj = {};</span>

  <span class="s1">if (typeof qs !== 'string' || qs.length === 0) {</span>
    <span class="s1">return obj;</span>
  <span class="s1">}</span>

  <span class="s1">var regexp = /\+/g;</span>
  <span class="s1">qs = qs.split(sep);</span>

  <span class="s1">var maxKeys = 1000;</span>
  <span class="s1">if (options &amp;&amp; typeof options.maxKeys === 'number') {</span>
    <span class="s1">maxKeys = options.maxKeys;</span>
  <span class="s1">}</span>

  <span class="s1">var len = qs.length;</span>
  <span class="s1">// maxKeys &lt;= 0 means that we should not limit keys count</span>
  <span class="s1">if (maxKeys &gt; 0 &amp;&amp; len &gt; maxKeys) {</span>
    <span class="s1">len = maxKeys;</span>
  <span class="s1">}</span>

  <span class="s1">for (var i = 0; i &lt; len; ++i) {</span>
    <span class="s1">var x = qs[i].replace(regexp, '%20'),</span>
        <span class="s1">idx = x.indexOf(eq),</span>
        <span class="s1">kstr, vstr, k, v;</span>

    <span class="s1">if (idx &gt;= 0) {</span>
      <span class="s1">kstr = x.substr(0, idx);</span>
      <span class="s1">vstr = x.substr(idx + 1);</span>
    <span class="s1">} else {</span>
      <span class="s1">kstr = x;</span>
      <span class="s1">vstr = '';</span>
    <span class="s1">}</span>

    <span class="s1">k = decodeURIComponent(kstr);</span>
    <span class="s1">v = decodeURIComponent(vstr);</span>

    <span class="s1">if (!hasOwnProperty(obj, k)) {</span>
      <span class="s1">obj[k] = v;</span>
    <span class="s1">} else if (isArray(obj[k])) {</span>
      <span class="s1">obj[k].push(v);</span>
    <span class="s1">} else {</span>
      <span class="s1">obj[k] = [obj[k], v];</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return obj;</span>
<span class="s1">};</span>

<span class="s1">var isArray = Array.isArray || function (xs) {</span>
  <span class="s1">return Object.prototype.toString.call(xs) === '[object Array]';</span>
<span class="s1">};</span>

<span class="s1">},{}],16:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">'use strict';</span>

<span class="s1">var stringifyPrimitive = function(v) {</span>
  <span class="s1">switch (typeof v) {</span>
    <span class="s1">case 'string':</span>
      <span class="s1">return v;</span>

    <span class="s1">case 'boolean':</span>
      <span class="s1">return v ? 'true' : 'false';</span>

    <span class="s1">case 'number':</span>
      <span class="s1">return isFinite(v) ? v : '';</span>

    <span class="s1">default:</span>
      <span class="s1">return '';</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">module.exports = function(obj, sep, eq, name) {</span>
  <span class="s1">sep = sep || '&amp;';</span>
  <span class="s1">eq = eq || '=';</span>
  <span class="s1">if (obj === null) {</span>
    <span class="s1">obj = undefined;</span>
  <span class="s1">}</span>

  <span class="s1">if (typeof obj === 'object') {</span>
    <span class="s1">return map(objectKeys(obj), function(k) {</span>
      <span class="s1">var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;</span>
      <span class="s1">if (isArray(obj[k])) {</span>
        <span class="s1">return obj[k].map(function(v) {</span>
          <span class="s1">return ks + encodeURIComponent(stringifyPrimitive(v));</span>
        <span class="s1">}).join(sep);</span>
      <span class="s1">} else {</span>
        <span class="s1">return ks + encodeURIComponent(stringifyPrimitive(obj[k]));</span>
      <span class="s1">}</span>
    <span class="s1">}).join(sep);</span>

  <span class="s1">}</span>

  <span class="s1">if (!name) return '';</span>
  <span class="s1">return encodeURIComponent(stringifyPrimitive(name)) + eq +</span>
         <span class="s1">encodeURIComponent(stringifyPrimitive(obj));</span>
<span class="s1">};</span>

<span class="s1">var isArray = Array.isArray || function (xs) {</span>
  <span class="s1">return Object.prototype.toString.call(xs) === '[object Array]';</span>
<span class="s1">};</span>

<span class="s1">function map (xs, f) {</span>
  <span class="s1">if (xs.map) return xs.map(f);</span>
  <span class="s1">var res = [];</span>
  <span class="s1">for (var i = 0; i &lt; xs.length; i++) {</span>
    <span class="s1">res.push(f(xs[i], i));</span>
  <span class="s1">}</span>
  <span class="s1">return res;</span>
<span class="s1">}</span>

<span class="s1">var objectKeys = Object.keys || function (obj) {</span>
  <span class="s1">var res = [];</span>
  <span class="s1">for (var key in obj) {</span>
    <span class="s1">if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);</span>
  <span class="s1">}</span>
  <span class="s1">return res;</span>
<span class="s1">};</span>

<span class="s1">},{}],17:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">exports.decode = exports.parse = require('./decode');</span>
<span class="s1">exports.encode = exports.stringify = require('./encode');</span>

<span class="s1">},{&quot;./decode&quot;:15,&quot;./encode&quot;:16}],18:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// a duplex stream is just a stream that is both readable and writable.</span>
<span class="s1">// Since JS doesn't have multiple prototypal inheritance, this class</span>
<span class="s1">// prototypally inherits from Readable, and then parasitically from</span>
<span class="s1">// Writable.</span>

<span class="s1">module.exports = Duplex;</span>
<span class="s1">var inherits = require('inherits');</span>
<span class="s1">var setImmediate = require('process/browser.js').nextTick;</span>
<span class="s1">var Readable = require('./readable.js');</span>
<span class="s1">var Writable = require('./writable.js');</span>

<span class="s1">inherits(Duplex, Readable);</span>

<span class="s1">Duplex.prototype.write = Writable.prototype.write;</span>
<span class="s1">Duplex.prototype.end = Writable.prototype.end;</span>
<span class="s1">Duplex.prototype._write = Writable.prototype._write;</span>

<span class="s1">function Duplex(options) {</span>
  <span class="s1">if (!(this instanceof Duplex))</span>
    <span class="s1">return new Duplex(options);</span>

  <span class="s1">Readable.call(this, options);</span>
  <span class="s1">Writable.call(this, options);</span>

  <span class="s1">if (options &amp;&amp; options.readable === false)</span>
    <span class="s1">this.readable = false;</span>

  <span class="s1">if (options &amp;&amp; options.writable === false)</span>
    <span class="s1">this.writable = false;</span>

  <span class="s1">this.allowHalfOpen = true;</span>
  <span class="s1">if (options &amp;&amp; options.allowHalfOpen === false)</span>
    <span class="s1">this.allowHalfOpen = false;</span>

  <span class="s1">this.once('end', onend);</span>
<span class="s1">}</span>

<span class="s1">// the no-half-open enforcer</span>
<span class="s1">function onend() {</span>
  <span class="s1">// if we allow half-open state, or if the writable side ended,</span>
  <span class="s1">// then we're ok.</span>
  <span class="s1">if (this.allowHalfOpen || this._writableState.ended)</span>
    <span class="s1">return;</span>

  <span class="s1">// no more data can be written.</span>
  <span class="s1">// But allow more writes to happen in this tick.</span>
  <span class="s1">var self = this;</span>
  <span class="s1">setImmediate(function () {</span>
    <span class="s1">self.end();</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">},{&quot;./readable.js&quot;:22,&quot;./writable.js&quot;:24,&quot;inherits&quot;:10,&quot;process/browser.js&quot;:20}],19:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">module.exports = Stream;</span>

<span class="s1">var EE = require('events').EventEmitter;</span>
<span class="s1">var inherits = require('inherits');</span>

<span class="s1">inherits(Stream, EE);</span>
<span class="s1">Stream.Readable = require('./readable.js');</span>
<span class="s1">Stream.Writable = require('./writable.js');</span>
<span class="s1">Stream.Duplex = require('./duplex.js');</span>
<span class="s1">Stream.Transform = require('./transform.js');</span>
<span class="s1">Stream.PassThrough = require('./passthrough.js');</span>

<span class="s1">// Backwards-compat with node 0.4.x</span>
<span class="s1">Stream.Stream = Stream;</span>



<span class="s1">// old-style streams.  Note that the pipe method (the only relevant</span>
<span class="s1">// part of this class) is overridden in the Readable class.</span>

<span class="s1">function Stream() {</span>
  <span class="s1">EE.call(this);</span>
<span class="s1">}</span>

<span class="s1">Stream.prototype.pipe = function(dest, options) {</span>
  <span class="s1">var source = this;</span>

  <span class="s1">function ondata(chunk) {</span>
    <span class="s1">if (dest.writable) {</span>
      <span class="s1">if (false === dest.write(chunk) &amp;&amp; source.pause) {</span>
        <span class="s1">source.pause();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">source.on('data', ondata);</span>

  <span class="s1">function ondrain() {</span>
    <span class="s1">if (source.readable &amp;&amp; source.resume) {</span>
      <span class="s1">source.resume();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">dest.on('drain', ondrain);</span>

  <span class="s1">// If the 'end' option is not supplied, dest.end() will be called when</span>
  <span class="s1">// source gets the 'end' or 'close' events.  Only dest.end() once.</span>
  <span class="s1">if (!dest._isStdio &amp;&amp; (!options || options.end !== false)) {</span>
    <span class="s1">source.on('end', onend);</span>
    <span class="s1">source.on('close', onclose);</span>
  <span class="s1">}</span>

  <span class="s1">var didOnEnd = false;</span>
  <span class="s1">function onend() {</span>
    <span class="s1">if (didOnEnd) return;</span>
    <span class="s1">didOnEnd = true;</span>

    <span class="s1">dest.end();</span>
  <span class="s1">}</span>


  <span class="s1">function onclose() {</span>
    <span class="s1">if (didOnEnd) return;</span>
    <span class="s1">didOnEnd = true;</span>

    <span class="s1">if (typeof dest.destroy === 'function') dest.destroy();</span>
  <span class="s1">}</span>

  <span class="s1">// don't leave dangling pipes when there are errors.</span>
  <span class="s1">function onerror(er) {</span>
    <span class="s1">cleanup();</span>
    <span class="s1">if (EE.listenerCount(this, 'error') === 0) {</span>
      <span class="s1">throw er; // Unhandled stream error in pipe.</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">source.on('error', onerror);</span>
  <span class="s1">dest.on('error', onerror);</span>

  <span class="s1">// remove all the event listeners that were added.</span>
  <span class="s1">function cleanup() {</span>
    <span class="s1">source.removeListener('data', ondata);</span>
    <span class="s1">dest.removeListener('drain', ondrain);</span>

    <span class="s1">source.removeListener('end', onend);</span>
    <span class="s1">source.removeListener('close', onclose);</span>

    <span class="s1">source.removeListener('error', onerror);</span>
    <span class="s1">dest.removeListener('error', onerror);</span>

    <span class="s1">source.removeListener('end', cleanup);</span>
    <span class="s1">source.removeListener('close', cleanup);</span>

    <span class="s1">dest.removeListener('close', cleanup);</span>
  <span class="s1">}</span>

  <span class="s1">source.on('end', cleanup);</span>
  <span class="s1">source.on('close', cleanup);</span>

  <span class="s1">dest.on('close', cleanup);</span>

  <span class="s1">dest.emit('pipe', source);</span>

  <span class="s1">// Allow for unix-like usage: A.pipe(B).pipe(C)</span>
  <span class="s1">return dest;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./duplex.js&quot;:18,&quot;./passthrough.js&quot;:21,&quot;./readable.js&quot;:22,&quot;./transform.js&quot;:23,&quot;./writable.js&quot;:24,&quot;events&quot;:5,&quot;inherits&quot;:10}],20:[function(require,module,exports){</span>
<span class="s1">// shim for using process in browser</span>

<span class="s1">var process = module.exports = {};</span>

<span class="s1">process.nextTick = (function () {</span>
    <span class="s1">var canSetImmediate = typeof window !== 'undefined'</span>
    <span class="s1">&amp;&amp; window.setImmediate;</span>
    <span class="s1">var canPost = typeof window !== 'undefined'</span>
    <span class="s1">&amp;&amp; window.postMessage &amp;&amp; window.addEventListener</span>
    <span class="s1">;</span>

    <span class="s1">if (canSetImmediate) {</span>
        <span class="s1">return function (f) { return window.setImmediate(f) };</span>
    <span class="s1">}</span>

    <span class="s1">if (canPost) {</span>
        <span class="s1">var queue = [];</span>
        <span class="s1">window.addEventListener('message', function (ev) {</span>
            <span class="s1">var source = ev.source;</span>
            <span class="s1">if ((source === window || source === null) &amp;&amp; ev.data === 'process-tick') {</span>
                <span class="s1">ev.stopPropagation();</span>
                <span class="s1">if (queue.length &gt; 0) {</span>
                    <span class="s1">var fn = queue.shift();</span>
                    <span class="s1">fn();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}, true);</span>

        <span class="s1">return function nextTick(fn) {</span>
            <span class="s1">queue.push(fn);</span>
            <span class="s1">window.postMessage('process-tick', '*');</span>
        <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s1">return function nextTick(fn) {</span>
        <span class="s1">setTimeout(fn, 0);</span>
    <span class="s1">};</span>
<span class="s1">})();</span>

<span class="s1">process.title = 'browser';</span>
<span class="s1">process.browser = true;</span>
<span class="s1">process.env = {};</span>
<span class="s1">process.argv = [];</span>

<span class="s1">process.binding = function (name) {</span>
    <span class="s1">throw new Error('process.binding is not supported');</span>
<span class="s1">}</span>

<span class="s1">// TODO(shtylman)</span>
<span class="s1">process.cwd = function () { return '/' };</span>
<span class="s1">process.chdir = function (dir) {</span>
    <span class="s1">throw new Error('process.chdir is not supported');</span>
<span class="s1">};</span>

<span class="s1">},{}],21:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// a passthrough stream.</span>
<span class="s1">// basically just the most minimal sort of Transform stream.</span>
<span class="s1">// Every written chunk gets output as-is.</span>

<span class="s1">module.exports = PassThrough;</span>

<span class="s1">var Transform = require('./transform.js');</span>
<span class="s1">var inherits = require('inherits');</span>
<span class="s1">inherits(PassThrough, Transform);</span>

<span class="s1">function PassThrough(options) {</span>
  <span class="s1">if (!(this instanceof PassThrough))</span>
    <span class="s1">return new PassThrough(options);</span>

  <span class="s1">Transform.call(this, options);</span>
<span class="s1">}</span>

<span class="s1">PassThrough.prototype._transform = function(chunk, encoding, cb) {</span>
  <span class="s1">cb(null, chunk);</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./transform.js&quot;:23,&quot;inherits&quot;:10}],22:[function(require,module,exports){</span>
<span class="s1">(function (process){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">module.exports = Readable;</span>
<span class="s1">Readable.ReadableState = ReadableState;</span>

<span class="s1">var EE = require('events').EventEmitter;</span>
<span class="s1">var Stream = require('./index.js');</span>
<span class="s1">var Buffer = require('buffer').Buffer;</span>
<span class="s1">var setImmediate = require('process/browser.js').nextTick;</span>
<span class="s1">var StringDecoder;</span>

<span class="s1">var inherits = require('inherits');</span>
<span class="s1">inherits(Readable, Stream);</span>

<span class="s1">function ReadableState(options, stream) {</span>
  <span class="s1">options = options || {};</span>

  <span class="s1">// the point at which it stops calling _read() to fill the buffer</span>
  <span class="s1">// Note: 0 is a valid value, means &quot;don't call _read preemptively ever&quot;</span>
  <span class="s1">var hwm = options.highWaterMark;</span>
  <span class="s1">this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;</span>

  <span class="s1">// cast to ints.</span>
  <span class="s1">this.highWaterMark = ~~this.highWaterMark;</span>

  <span class="s1">this.buffer = [];</span>
  <span class="s1">this.length = 0;</span>
  <span class="s1">this.pipes = null;</span>
  <span class="s1">this.pipesCount = 0;</span>
  <span class="s1">this.flowing = false;</span>
  <span class="s1">this.ended = false;</span>
  <span class="s1">this.endEmitted = false;</span>
  <span class="s1">this.reading = false;</span>

  <span class="s1">// In streams that never have any data, and do push(null) right away,</span>
  <span class="s1">// the consumer can miss the 'end' event if they do some I/O before</span>
  <span class="s1">// consuming the stream.  So, we don't emit('end') until some reading</span>
  <span class="s1">// happens.</span>
  <span class="s1">this.calledRead = false;</span>

  <span class="s1">// a flag to be able to tell if the onwrite cb is called immediately,</span>
  <span class="s1">// or on a later tick.  We set this to true at first, becuase any</span>
  <span class="s1">// actions that shouldn't happen until &quot;later&quot; should generally also</span>
  <span class="s1">// not happen before the first write call.</span>
  <span class="s1">this.sync = true;</span>

  <span class="s1">// whenever we return null, then we set a flag to say</span>
  <span class="s1">// that we're awaiting a 'readable' event emission.</span>
  <span class="s1">this.needReadable = false;</span>
  <span class="s1">this.emittedReadable = false;</span>
  <span class="s1">this.readableListening = false;</span>


  <span class="s1">// object stream flag. Used to make read(n) ignore n and to</span>
  <span class="s1">// make all the buffer merging and length checks go away</span>
  <span class="s1">this.objectMode = !!options.objectMode;</span>

  <span class="s1">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="s1">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="s1">// Everything else in the universe uses 'utf8', though.</span>
  <span class="s1">this.defaultEncoding = options.defaultEncoding || 'utf8';</span>

  <span class="s1">// when piping, we only care about 'readable' events that happen</span>
  <span class="s1">// after read()ing all the bytes and not getting any pushback.</span>
  <span class="s1">this.ranOut = false;</span>

  <span class="s1">// the number of writers that are awaiting a drain event in .pipe()s</span>
  <span class="s1">this.awaitDrain = 0;</span>

  <span class="s1">// if true, a maybeReadMore has been scheduled</span>
  <span class="s1">this.readingMore = false;</span>

  <span class="s1">this.decoder = null;</span>
  <span class="s1">this.encoding = null;</span>
  <span class="s1">if (options.encoding) {</span>
    <span class="s1">if (!StringDecoder)</span>
      <span class="s1">StringDecoder = require('string_decoder').StringDecoder;</span>
    <span class="s1">this.decoder = new StringDecoder(options.encoding);</span>
    <span class="s1">this.encoding = options.encoding;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function Readable(options) {</span>
  <span class="s1">if (!(this instanceof Readable))</span>
    <span class="s1">return new Readable(options);</span>

  <span class="s1">this._readableState = new ReadableState(options, this);</span>

  <span class="s1">// legacy</span>
  <span class="s1">this.readable = true;</span>

  <span class="s1">Stream.call(this);</span>
<span class="s1">}</span>

<span class="s1">// Manually shove something into the read() buffer.</span>
<span class="s1">// This returns true if the highWaterMark has not been hit yet,</span>
<span class="s1">// similar to how Writable.write() returns true if you should</span>
<span class="s1">// write() some more.</span>
<span class="s1">Readable.prototype.push = function(chunk, encoding) {</span>
  <span class="s1">var state = this._readableState;</span>

  <span class="s1">if (typeof chunk === 'string' &amp;&amp; !state.objectMode) {</span>
    <span class="s1">encoding = encoding || state.defaultEncoding;</span>
    <span class="s1">if (encoding !== state.encoding) {</span>
      <span class="s1">chunk = new Buffer(chunk, encoding);</span>
      <span class="s1">encoding = '';</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return readableAddChunk(this, state, chunk, encoding, false);</span>
<span class="s1">};</span>

<span class="s1">// Unshift should *always* be something directly out of read()</span>
<span class="s1">Readable.prototype.unshift = function(chunk) {</span>
  <span class="s1">var state = this._readableState;</span>
  <span class="s1">return readableAddChunk(this, state, chunk, '', true);</span>
<span class="s1">};</span>

<span class="s1">function readableAddChunk(stream, state, chunk, encoding, addToFront) {</span>
  <span class="s1">var er = chunkInvalid(state, chunk);</span>
  <span class="s1">if (er) {</span>
    <span class="s1">stream.emit('error', er);</span>
  <span class="s1">} else if (chunk === null || chunk === undefined) {</span>
    <span class="s1">state.reading = false;</span>
    <span class="s1">if (!state.ended)</span>
      <span class="s1">onEofChunk(stream, state);</span>
  <span class="s1">} else if (state.objectMode || chunk &amp;&amp; chunk.length &gt; 0) {</span>
    <span class="s1">if (state.ended &amp;&amp; !addToFront) {</span>
      <span class="s1">var e = new Error('stream.push() after EOF');</span>
      <span class="s1">stream.emit('error', e);</span>
    <span class="s1">} else if (state.endEmitted &amp;&amp; addToFront) {</span>
      <span class="s1">var e = new Error('stream.unshift() after end event');</span>
      <span class="s1">stream.emit('error', e);</span>
    <span class="s1">} else {</span>
      <span class="s1">if (state.decoder &amp;&amp; !addToFront &amp;&amp; !encoding)</span>
        <span class="s1">chunk = state.decoder.write(chunk);</span>

      <span class="s1">// update the buffer info.</span>
      <span class="s1">state.length += state.objectMode ? 1 : chunk.length;</span>
      <span class="s1">if (addToFront) {</span>
        <span class="s1">state.buffer.unshift(chunk);</span>
      <span class="s1">} else {</span>
        <span class="s1">state.reading = false;</span>
        <span class="s1">state.buffer.push(chunk);</span>
      <span class="s1">}</span>

      <span class="s1">if (state.needReadable)</span>
        <span class="s1">emitReadable(stream);</span>

      <span class="s1">maybeReadMore(stream, state);</span>
    <span class="s1">}</span>
  <span class="s1">} else if (!addToFront) {</span>
    <span class="s1">state.reading = false;</span>
  <span class="s1">}</span>

  <span class="s1">return needMoreData(state);</span>
<span class="s1">}</span>



<span class="s1">// if it's past the high water mark, we can push in some more.</span>
<span class="s1">// Also, if we have no data yet, we can stand some</span>
<span class="s1">// more bytes.  This is to work around cases where hwm=0,</span>
<span class="s1">// such as the repl.  Also, if the push() triggered a</span>
<span class="s1">// readable event, and the user called read(largeNumber) such that</span>
<span class="s1">// needReadable was set, then we ought to push more, so that another</span>
<span class="s1">// 'readable' event will be triggered.</span>
<span class="s1">function needMoreData(state) {</span>
  <span class="s1">return !state.ended &amp;&amp;</span>
         <span class="s1">(state.needReadable ||</span>
          <span class="s1">state.length &lt; state.highWaterMark ||</span>
          <span class="s1">state.length === 0);</span>
<span class="s1">}</span>

<span class="s1">// backwards compatibility.</span>
<span class="s1">Readable.prototype.setEncoding = function(enc) {</span>
  <span class="s1">if (!StringDecoder)</span>
    <span class="s1">StringDecoder = require('string_decoder').StringDecoder;</span>
  <span class="s1">this._readableState.decoder = new StringDecoder(enc);</span>
  <span class="s1">this._readableState.encoding = enc;</span>
<span class="s1">};</span>

<span class="s1">// Don't raise the hwm &gt; 128MB</span>
<span class="s1">var MAX_HWM = 0x800000;</span>
<span class="s1">function roundUpToNextPowerOf2(n) {</span>
  <span class="s1">if (n &gt;= MAX_HWM) {</span>
    <span class="s1">n = MAX_HWM;</span>
  <span class="s1">} else {</span>
    <span class="s1">// Get the next highest power of 2</span>
    <span class="s1">n--;</span>
    <span class="s1">for (var p = 1; p &lt; 32; p &lt;&lt;= 1) n |= n &gt;&gt; p;</span>
    <span class="s1">n++;</span>
  <span class="s1">}</span>
  <span class="s1">return n;</span>
<span class="s1">}</span>

<span class="s1">function howMuchToRead(n, state) {</span>
  <span class="s1">if (state.length === 0 &amp;&amp; state.ended)</span>
    <span class="s1">return 0;</span>

  <span class="s1">if (state.objectMode)</span>
    <span class="s1">return n === 0 ? 0 : 1;</span>

  <span class="s1">if (isNaN(n) || n === null) {</span>
    <span class="s1">// only flow one buffer at a time</span>
    <span class="s1">if (state.flowing &amp;&amp; state.buffer.length)</span>
      <span class="s1">return state.buffer[0].length;</span>
    <span class="s1">else</span>
      <span class="s1">return state.length;</span>
  <span class="s1">}</span>

  <span class="s1">if (n &lt;= 0)</span>
    <span class="s1">return 0;</span>

  <span class="s1">// If we're asking for more than the target buffer level,</span>
  <span class="s1">// then raise the water mark.  Bump up to the next highest</span>
  <span class="s1">// power of 2, to prevent increasing it excessively in tiny</span>
  <span class="s1">// amounts.</span>
  <span class="s1">if (n &gt; state.highWaterMark)</span>
    <span class="s1">state.highWaterMark = roundUpToNextPowerOf2(n);</span>

  <span class="s1">// don't have that much.  return null, unless we've ended.</span>
  <span class="s1">if (n &gt; state.length) {</span>
    <span class="s1">if (!state.ended) {</span>
      <span class="s1">state.needReadable = true;</span>
      <span class="s1">return 0;</span>
    <span class="s1">} else</span>
      <span class="s1">return state.length;</span>
  <span class="s1">}</span>

  <span class="s1">return n;</span>
<span class="s1">}</span>

<span class="s1">// you can override either this method, or the async _read(n) below.</span>
<span class="s1">Readable.prototype.read = function(n) {</span>
  <span class="s1">var state = this._readableState;</span>
  <span class="s1">state.calledRead = true;</span>
  <span class="s1">var nOrig = n;</span>

  <span class="s1">if (typeof n !== 'number' || n &gt; 0)</span>
    <span class="s1">state.emittedReadable = false;</span>

  <span class="s1">// if we're doing read(0) to trigger a readable event, but we</span>
  <span class="s1">// already have a bunch of data in the buffer, then just trigger</span>
  <span class="s1">// the 'readable' event and move on.</span>
  <span class="s1">if (n === 0 &amp;&amp;</span>
      <span class="s1">state.needReadable &amp;&amp;</span>
      <span class="s1">(state.length &gt;= state.highWaterMark || state.ended)) {</span>
    <span class="s1">emitReadable(this);</span>
    <span class="s1">return null;</span>
  <span class="s1">}</span>

  <span class="s1">n = howMuchToRead(n, state);</span>

  <span class="s1">// if we've ended, and we're now clear, then finish it up.</span>
  <span class="s1">if (n === 0 &amp;&amp; state.ended) {</span>
    <span class="s1">if (state.length === 0)</span>
      <span class="s1">endReadable(this);</span>
    <span class="s1">return null;</span>
  <span class="s1">}</span>

  <span class="s1">// All the actual chunk generation logic needs to be</span>
  <span class="s1">// *below* the call to _read.  The reason is that in certain</span>
  <span class="s1">// synthetic stream cases, such as passthrough streams, _read</span>
  <span class="s1">// may be a completely synchronous operation which may change</span>
  <span class="s1">// the state of the read buffer, providing enough data when</span>
  <span class="s1">// before there was *not* enough.</span>
  <span class="s1">//</span>
  <span class="s1">// So, the steps are:</span>
  <span class="s1">// 1. Figure out what the state of things will be after we do</span>
  <span class="s1">// a read from the buffer.</span>
  <span class="s1">//</span>
  <span class="s1">// 2. If that resulting state will trigger a _read, then call _read.</span>
  <span class="s1">// Note that this may be asynchronous, or synchronous.  Yes, it is</span>
  <span class="s1">// deeply ugly to write APIs this way, but that still doesn't mean</span>
  <span class="s1">// that the Readable class should behave improperly, as streams are</span>
  <span class="s1">// designed to be sync/async agnostic.</span>
  <span class="s1">// Take note if the _read call is sync or async (ie, if the read call</span>
  <span class="s1">// has returned yet), so that we know whether or not it's safe to emit</span>
  <span class="s1">// 'readable' etc.</span>
  <span class="s1">//</span>
  <span class="s1">// 3. Actually pull the requested chunks out of the buffer and return.</span>

  <span class="s1">// if we need a readable event, then we need to do some reading.</span>
  <span class="s1">var doRead = state.needReadable;</span>

  <span class="s1">// if we currently have less than the highWaterMark, then also read some</span>
  <span class="s1">if (state.length - n &lt;= state.highWaterMark)</span>
    <span class="s1">doRead = true;</span>

  <span class="s1">// however, if we've ended, then there's no point, and if we're already</span>
  <span class="s1">// reading, then it's unnecessary.</span>
  <span class="s1">if (state.ended || state.reading)</span>
    <span class="s1">doRead = false;</span>

  <span class="s1">if (doRead) {</span>
    <span class="s1">state.reading = true;</span>
    <span class="s1">state.sync = true;</span>
    <span class="s1">// if the length is currently zero, then we *need* a readable event.</span>
    <span class="s1">if (state.length === 0)</span>
      <span class="s1">state.needReadable = true;</span>
    <span class="s1">// call internal read method</span>
    <span class="s1">this._read(state.highWaterMark);</span>
    <span class="s1">state.sync = false;</span>
  <span class="s1">}</span>

  <span class="s1">// If _read called its callback synchronously, then `reading`</span>
  <span class="s1">// will be false, and we need to re-evaluate how much data we</span>
  <span class="s1">// can return to the user.</span>
  <span class="s1">if (doRead &amp;&amp; !state.reading)</span>
    <span class="s1">n = howMuchToRead(nOrig, state);</span>

  <span class="s1">var ret;</span>
  <span class="s1">if (n &gt; 0)</span>
    <span class="s1">ret = fromList(n, state);</span>
  <span class="s1">else</span>
    <span class="s1">ret = null;</span>

  <span class="s1">if (ret === null) {</span>
    <span class="s1">state.needReadable = true;</span>
    <span class="s1">n = 0;</span>
  <span class="s1">}</span>

  <span class="s1">state.length -= n;</span>

  <span class="s1">// If we have nothing in the buffer, then we want to know</span>
  <span class="s1">// as soon as we *do* get something into the buffer.</span>
  <span class="s1">if (state.length === 0 &amp;&amp; !state.ended)</span>
    <span class="s1">state.needReadable = true;</span>

  <span class="s1">// If we happened to read() exactly the remaining amount in the</span>
  <span class="s1">// buffer, and the EOF has been seen at this point, then make sure</span>
  <span class="s1">// that we emit 'end' on the very next tick.</span>
  <span class="s1">if (state.ended &amp;&amp; !state.endEmitted &amp;&amp; state.length === 0)</span>
    <span class="s1">endReadable(this);</span>

  <span class="s1">return ret;</span>
<span class="s1">};</span>

<span class="s1">function chunkInvalid(state, chunk) {</span>
  <span class="s1">var er = null;</span>
  <span class="s1">if (!Buffer.isBuffer(chunk) &amp;&amp;</span>
      <span class="s1">'string' !== typeof chunk &amp;&amp;</span>
      <span class="s1">chunk !== null &amp;&amp;</span>
      <span class="s1">chunk !== undefined &amp;&amp;</span>
      <span class="s1">!state.objectMode &amp;&amp;</span>
      <span class="s1">!er) {</span>
    <span class="s1">er = new TypeError('Invalid non-string/buffer chunk');</span>
  <span class="s1">}</span>
  <span class="s1">return er;</span>
<span class="s1">}</span>


<span class="s1">function onEofChunk(stream, state) {</span>
  <span class="s1">if (state.decoder &amp;&amp; !state.ended) {</span>
    <span class="s1">var chunk = state.decoder.end();</span>
    <span class="s1">if (chunk &amp;&amp; chunk.length) {</span>
      <span class="s1">state.buffer.push(chunk);</span>
      <span class="s1">state.length += state.objectMode ? 1 : chunk.length;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">state.ended = true;</span>

  <span class="s1">// if we've ended and we have some data left, then emit</span>
  <span class="s1">// 'readable' now to make sure it gets picked up.</span>
  <span class="s1">if (state.length &gt; 0)</span>
    <span class="s1">emitReadable(stream);</span>
  <span class="s1">else</span>
    <span class="s1">endReadable(stream);</span>
<span class="s1">}</span>

<span class="s1">// Don't emit readable right away in sync mode, because this can trigger</span>
<span class="s1">// another read() call =&gt; stack overflow.  This way, it might trigger</span>
<span class="s1">// a nextTick recursion warning, but that's not so bad.</span>
<span class="s1">function emitReadable(stream) {</span>
  <span class="s1">var state = stream._readableState;</span>
  <span class="s1">state.needReadable = false;</span>
  <span class="s1">if (state.emittedReadable)</span>
    <span class="s1">return;</span>

  <span class="s1">state.emittedReadable = true;</span>
  <span class="s1">if (state.sync)</span>
    <span class="s1">setImmediate(function() {</span>
      <span class="s1">emitReadable_(stream);</span>
    <span class="s1">});</span>
  <span class="s1">else</span>
    <span class="s1">emitReadable_(stream);</span>
<span class="s1">}</span>

<span class="s1">function emitReadable_(stream) {</span>
  <span class="s1">stream.emit('readable');</span>
<span class="s1">}</span>


<span class="s1">// at this point, the user has presumably seen the 'readable' event,</span>
<span class="s1">// and called read() to consume some data.  that may have triggered</span>
<span class="s1">// in turn another _read(n) call, in which case reading = true if</span>
<span class="s1">// it's in progress.</span>
<span class="s1">// However, if we're not ended, or reading, and the length &lt; hwm,</span>
<span class="s1">// then go ahead and try to read some more preemptively.</span>
<span class="s1">function maybeReadMore(stream, state) {</span>
  <span class="s1">if (!state.readingMore) {</span>
    <span class="s1">state.readingMore = true;</span>
    <span class="s1">setImmediate(function() {</span>
      <span class="s1">maybeReadMore_(stream, state);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function maybeReadMore_(stream, state) {</span>
  <span class="s1">var len = state.length;</span>
  <span class="s1">while (!state.reading &amp;&amp; !state.flowing &amp;&amp; !state.ended &amp;&amp;</span>
         <span class="s1">state.length &lt; state.highWaterMark) {</span>
    <span class="s1">stream.read(0);</span>
    <span class="s1">if (len === state.length)</span>
      <span class="s1">// didn't get any data, stop spinning.</span>
      <span class="s1">break;</span>
    <span class="s1">else</span>
      <span class="s1">len = state.length;</span>
  <span class="s1">}</span>
  <span class="s1">state.readingMore = false;</span>
<span class="s1">}</span>

<span class="s1">// abstract method.  to be overridden in specific implementation classes.</span>
<span class="s1">// call cb(er, data) where data is &lt;= n in length.</span>
<span class="s1">// for virtual (non-string, non-buffer) streams, &quot;length&quot; is somewhat</span>
<span class="s1">// arbitrary, and perhaps not very meaningful.</span>
<span class="s1">Readable.prototype._read = function(n) {</span>
  <span class="s1">this.emit('error', new Error('not implemented'));</span>
<span class="s1">};</span>

<span class="s1">Readable.prototype.pipe = function(dest, pipeOpts) {</span>
  <span class="s1">var src = this;</span>
  <span class="s1">var state = this._readableState;</span>

  <span class="s1">switch (state.pipesCount) {</span>
    <span class="s1">case 0:</span>
      <span class="s1">state.pipes = dest;</span>
      <span class="s1">break;</span>
    <span class="s1">case 1:</span>
      <span class="s1">state.pipes = [state.pipes, dest];</span>
      <span class="s1">break;</span>
    <span class="s1">default:</span>
      <span class="s1">state.pipes.push(dest);</span>
      <span class="s1">break;</span>
  <span class="s1">}</span>
  <span class="s1">state.pipesCount += 1;</span>

  <span class="s1">var doEnd = (!pipeOpts || pipeOpts.end !== false) &amp;&amp;</span>
              <span class="s1">dest !== process.stdout &amp;&amp;</span>
              <span class="s1">dest !== process.stderr;</span>

  <span class="s1">var endFn = doEnd ? onend : cleanup;</span>
  <span class="s1">if (state.endEmitted)</span>
    <span class="s1">setImmediate(endFn);</span>
  <span class="s1">else</span>
    <span class="s1">src.once('end', endFn);</span>

  <span class="s1">dest.on('unpipe', onunpipe);</span>
  <span class="s1">function onunpipe(readable) {</span>
    <span class="s1">if (readable !== src) return;</span>
    <span class="s1">cleanup();</span>
  <span class="s1">}</span>

  <span class="s1">function onend() {</span>
    <span class="s1">dest.end();</span>
  <span class="s1">}</span>

  <span class="s1">// when the dest drains, it reduces the awaitDrain counter</span>
  <span class="s1">// on the source.  This would be more elegant with a .once()</span>
  <span class="s1">// handler in flow(), but adding and removing repeatedly is</span>
  <span class="s1">// too slow.</span>
  <span class="s1">var ondrain = pipeOnDrain(src);</span>
  <span class="s1">dest.on('drain', ondrain);</span>

  <span class="s1">function cleanup() {</span>
    <span class="s1">// cleanup event handlers once the pipe is broken</span>
    <span class="s1">dest.removeListener('close', onclose);</span>
    <span class="s1">dest.removeListener('finish', onfinish);</span>
    <span class="s1">dest.removeListener('drain', ondrain);</span>
    <span class="s1">dest.removeListener('error', onerror);</span>
    <span class="s1">dest.removeListener('unpipe', onunpipe);</span>
    <span class="s1">src.removeListener('end', onend);</span>
    <span class="s1">src.removeListener('end', cleanup);</span>

    <span class="s1">// if the reader is waiting for a drain event from this</span>
    <span class="s1">// specific writer, then it would cause it to never start</span>
    <span class="s1">// flowing again.</span>
    <span class="s1">// So, if this is awaiting a drain, then we just call it now.</span>
    <span class="s1">// If we don't know, then assume that we are waiting for one.</span>
    <span class="s1">if (!dest._writableState || dest._writableState.needDrain)</span>
      <span class="s1">ondrain();</span>
  <span class="s1">}</span>

  <span class="s1">// if the dest has an error, then stop piping into it.</span>
  <span class="s1">// however, don't suppress the throwing behavior for this.</span>
  <span class="s1">// check for listeners before emit removes one-time listeners.</span>
  <span class="s1">var errListeners = EE.listenerCount(dest, 'error');</span>
  <span class="s1">function onerror(er) {</span>
    <span class="s1">unpipe();</span>
    <span class="s1">if (errListeners === 0 &amp;&amp; EE.listenerCount(dest, 'error') === 0)</span>
      <span class="s1">dest.emit('error', er);</span>
  <span class="s1">}</span>
  <span class="s1">dest.once('error', onerror);</span>

  <span class="s1">// Both close and finish should trigger unpipe, but only once.</span>
  <span class="s1">function onclose() {</span>
    <span class="s1">dest.removeListener('finish', onfinish);</span>
    <span class="s1">unpipe();</span>
  <span class="s1">}</span>
  <span class="s1">dest.once('close', onclose);</span>
  <span class="s1">function onfinish() {</span>
    <span class="s1">dest.removeListener('close', onclose);</span>
    <span class="s1">unpipe();</span>
  <span class="s1">}</span>
  <span class="s1">dest.once('finish', onfinish);</span>

  <span class="s1">function unpipe() {</span>
    <span class="s1">src.unpipe(dest);</span>
  <span class="s1">}</span>

  <span class="s1">// tell the dest that it's being piped to</span>
  <span class="s1">dest.emit('pipe', src);</span>

  <span class="s1">// start the flow if it hasn't been started already.</span>
  <span class="s1">if (!state.flowing) {</span>
    <span class="s1">// the handler that waits for readable events after all</span>
    <span class="s1">// the data gets sucked out in flow.</span>
    <span class="s1">// This would be easier to follow with a .once() handler</span>
    <span class="s1">// in flow(), but that is too slow.</span>
    <span class="s1">this.on('readable', pipeOnReadable);</span>

    <span class="s1">state.flowing = true;</span>
    <span class="s1">setImmediate(function() {</span>
      <span class="s1">flow(src);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s1">return dest;</span>
<span class="s1">};</span>

<span class="s1">function pipeOnDrain(src) {</span>
  <span class="s1">return function() {</span>
    <span class="s1">var dest = this;</span>
    <span class="s1">var state = src._readableState;</span>
    <span class="s1">state.awaitDrain--;</span>
    <span class="s1">if (state.awaitDrain === 0)</span>
      <span class="s1">flow(src);</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">function flow(src) {</span>
  <span class="s1">var state = src._readableState;</span>
  <span class="s1">var chunk;</span>
  <span class="s1">state.awaitDrain = 0;</span>

  <span class="s1">function write(dest, i, list) {</span>
    <span class="s1">var written = dest.write(chunk);</span>
    <span class="s1">if (false === written) {</span>
      <span class="s1">state.awaitDrain++;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">while (state.pipesCount &amp;&amp; null !== (chunk = src.read())) {</span>

    <span class="s1">if (state.pipesCount === 1)</span>
      <span class="s1">write(state.pipes, 0, null);</span>
    <span class="s1">else</span>
      <span class="s1">forEach(state.pipes, write);</span>

    <span class="s1">src.emit('data', chunk);</span>

    <span class="s1">// if anyone needs a drain, then we have to wait for that.</span>
    <span class="s1">if (state.awaitDrain &gt; 0)</span>
      <span class="s1">return;</span>
  <span class="s1">}</span>

  <span class="s1">// if every destination was unpiped, either before entering this</span>
  <span class="s1">// function, or in the while loop, then stop flowing.</span>
  <span class="s1">//</span>
  <span class="s1">// NB: This is a pretty rare edge case.</span>
  <span class="s1">if (state.pipesCount === 0) {</span>
    <span class="s1">state.flowing = false;</span>

    <span class="s1">// if there were data event listeners added, then switch to old mode.</span>
    <span class="s1">if (EE.listenerCount(src, 'data') &gt; 0)</span>
      <span class="s1">emitDataEvents(src);</span>
    <span class="s1">return;</span>
  <span class="s1">}</span>

  <span class="s1">// at this point, no one needed a drain, so we just ran out of data</span>
  <span class="s1">// on the next readable event, start it over again.</span>
  <span class="s1">state.ranOut = true;</span>
<span class="s1">}</span>

<span class="s1">function pipeOnReadable() {</span>
  <span class="s1">if (this._readableState.ranOut) {</span>
    <span class="s1">this._readableState.ranOut = false;</span>
    <span class="s1">flow(this);</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s1">Readable.prototype.unpipe = function(dest) {</span>
  <span class="s1">var state = this._readableState;</span>

  <span class="s1">// if we're not piping anywhere, then do nothing.</span>
  <span class="s1">if (state.pipesCount === 0)</span>
    <span class="s1">return this;</span>

  <span class="s1">// just one destination.  most common case.</span>
  <span class="s1">if (state.pipesCount === 1) {</span>
    <span class="s1">// passed in one, but it's not the right one.</span>
    <span class="s1">if (dest &amp;&amp; dest !== state.pipes)</span>
      <span class="s1">return this;</span>

    <span class="s1">if (!dest)</span>
      <span class="s1">dest = state.pipes;</span>

    <span class="s1">// got a match.</span>
    <span class="s1">state.pipes = null;</span>
    <span class="s1">state.pipesCount = 0;</span>
    <span class="s1">this.removeListener('readable', pipeOnReadable);</span>
    <span class="s1">state.flowing = false;</span>
    <span class="s1">if (dest)</span>
      <span class="s1">dest.emit('unpipe', this);</span>
    <span class="s1">return this;</span>
  <span class="s1">}</span>

  <span class="s1">// slow case. multiple pipe destinations.</span>

  <span class="s1">if (!dest) {</span>
    <span class="s1">// remove all.</span>
    <span class="s1">var dests = state.pipes;</span>
    <span class="s1">var len = state.pipesCount;</span>
    <span class="s1">state.pipes = null;</span>
    <span class="s1">state.pipesCount = 0;</span>
    <span class="s1">this.removeListener('readable', pipeOnReadable);</span>
    <span class="s1">state.flowing = false;</span>

    <span class="s1">for (var i = 0; i &lt; len; i++)</span>
      <span class="s1">dests[i].emit('unpipe', this);</span>
    <span class="s1">return this;</span>
  <span class="s1">}</span>

  <span class="s1">// try to find the right one.</span>
  <span class="s1">var i = indexOf(state.pipes, dest);</span>
  <span class="s1">if (i === -1)</span>
    <span class="s1">return this;</span>

  <span class="s1">state.pipes.splice(i, 1);</span>
  <span class="s1">state.pipesCount -= 1;</span>
  <span class="s1">if (state.pipesCount === 1)</span>
    <span class="s1">state.pipes = state.pipes[0];</span>

  <span class="s1">dest.emit('unpipe', this);</span>

  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">// set up data events if they are asked for</span>
<span class="s1">// Ensure readable listeners eventually get something</span>
<span class="s1">Readable.prototype.on = function(ev, fn) {</span>
  <span class="s1">var res = Stream.prototype.on.call(this, ev, fn);</span>

  <span class="s1">if (ev === 'data' &amp;&amp; !this._readableState.flowing)</span>
    <span class="s1">emitDataEvents(this);</span>

  <span class="s1">if (ev === 'readable' &amp;&amp; this.readable) {</span>
    <span class="s1">var state = this._readableState;</span>
    <span class="s1">if (!state.readableListening) {</span>
      <span class="s1">state.readableListening = true;</span>
      <span class="s1">state.emittedReadable = false;</span>
      <span class="s1">state.needReadable = true;</span>
      <span class="s1">if (!state.reading) {</span>
        <span class="s1">this.read(0);</span>
      <span class="s1">} else if (state.length) {</span>
        <span class="s1">emitReadable(this, state);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return res;</span>
<span class="s1">};</span>
<span class="s1">Readable.prototype.addListener = Readable.prototype.on;</span>

<span class="s1">// pause() and resume() are remnants of the legacy readable stream API</span>
<span class="s1">// If the user uses them, then switch into old mode.</span>
<span class="s1">Readable.prototype.resume = function() {</span>
  <span class="s1">emitDataEvents(this);</span>
  <span class="s1">this.read(0);</span>
  <span class="s1">this.emit('resume');</span>
<span class="s1">};</span>

<span class="s1">Readable.prototype.pause = function() {</span>
  <span class="s1">emitDataEvents(this, true);</span>
  <span class="s1">this.emit('pause');</span>
<span class="s1">};</span>

<span class="s1">function emitDataEvents(stream, startPaused) {</span>
  <span class="s1">var state = stream._readableState;</span>

  <span class="s1">if (state.flowing) {</span>
    <span class="s1">// https://github.com/isaacs/readable-stream/issues/16</span>
    <span class="s1">throw new Error('Cannot switch to old mode now.');</span>
  <span class="s1">}</span>

  <span class="s1">var paused = startPaused || false;</span>
  <span class="s1">var readable = false;</span>

  <span class="s1">// convert to an old-style stream.</span>
  <span class="s1">stream.readable = true;</span>
  <span class="s1">stream.pipe = Stream.prototype.pipe;</span>
  <span class="s1">stream.on = stream.addListener = Stream.prototype.on;</span>

  <span class="s1">stream.on('readable', function() {</span>
    <span class="s1">readable = true;</span>

    <span class="s1">var c;</span>
    <span class="s1">while (!paused &amp;&amp; (null !== (c = stream.read())))</span>
      <span class="s1">stream.emit('data', c);</span>

    <span class="s1">if (c === null) {</span>
      <span class="s1">readable = false;</span>
      <span class="s1">stream._readableState.needReadable = true;</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s1">stream.pause = function() {</span>
    <span class="s1">paused = true;</span>
    <span class="s1">this.emit('pause');</span>
  <span class="s1">};</span>

  <span class="s1">stream.resume = function() {</span>
    <span class="s1">paused = false;</span>
    <span class="s1">if (readable)</span>
      <span class="s1">setImmediate(function() {</span>
        <span class="s1">stream.emit('readable');</span>
      <span class="s1">});</span>
    <span class="s1">else</span>
      <span class="s1">this.read(0);</span>
    <span class="s1">this.emit('resume');</span>
  <span class="s1">};</span>

  <span class="s1">// now make it start, just in case it hadn't already.</span>
  <span class="s1">stream.emit('readable');</span>
<span class="s1">}</span>

<span class="s1">// wrap an old-style stream as the async data source.</span>
<span class="s1">// This is *not* part of the readable stream interface.</span>
<span class="s1">// It is an ugly unfortunate mess of history.</span>
<span class="s1">Readable.prototype.wrap = function(stream) {</span>
  <span class="s1">var state = this._readableState;</span>
  <span class="s1">var paused = false;</span>

  <span class="s1">var self = this;</span>
  <span class="s1">stream.on('end', function() {</span>
    <span class="s1">if (state.decoder &amp;&amp; !state.ended) {</span>
      <span class="s1">var chunk = state.decoder.end();</span>
      <span class="s1">if (chunk &amp;&amp; chunk.length)</span>
        <span class="s1">self.push(chunk);</span>
    <span class="s1">}</span>

    <span class="s1">self.push(null);</span>
  <span class="s1">});</span>

  <span class="s1">stream.on('data', function(chunk) {</span>
    <span class="s1">if (state.decoder)</span>
      <span class="s1">chunk = state.decoder.write(chunk);</span>
    <span class="s1">if (!chunk || !state.objectMode &amp;&amp; !chunk.length)</span>
      <span class="s1">return;</span>

    <span class="s1">var ret = self.push(chunk);</span>
    <span class="s1">if (!ret) {</span>
      <span class="s1">paused = true;</span>
      <span class="s1">stream.pause();</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s1">// proxy all the other methods.</span>
  <span class="s1">// important when wrapping filters and duplexes.</span>
  <span class="s1">for (var i in stream) {</span>
    <span class="s1">if (typeof stream[i] === 'function' &amp;&amp;</span>
        <span class="s1">typeof this[i] === 'undefined') {</span>
      <span class="s1">this[i] = function(method) { return function() {</span>
        <span class="s1">return stream[method].apply(stream, arguments);</span>
      <span class="s1">}}(i);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">// proxy certain important events.</span>
  <span class="s1">var events = ['error', 'close', 'destroy', 'pause', 'resume'];</span>
  <span class="s1">forEach(events, function(ev) {</span>
    <span class="s1">stream.on(ev, function (x) {</span>
      <span class="s1">return self.emit.apply(self, ev, x);</span>
    <span class="s1">});</span>
  <span class="s1">});</span>

  <span class="s1">// when we try to consume some more bytes, simply unpause the</span>
  <span class="s1">// underlying stream.</span>
  <span class="s1">self._read = function(n) {</span>
    <span class="s1">if (paused) {</span>
      <span class="s1">paused = false;</span>
      <span class="s1">stream.resume();</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">return self;</span>
<span class="s1">};</span>



<span class="s1">// exposed for testing purposes only.</span>
<span class="s1">Readable._fromList = fromList;</span>

<span class="s1">// Pluck off n bytes from an array of buffers.</span>
<span class="s1">// Length is the combined lengths of all the buffers in the list.</span>
<span class="s1">function fromList(n, state) {</span>
  <span class="s1">var list = state.buffer;</span>
  <span class="s1">var length = state.length;</span>
  <span class="s1">var stringMode = !!state.decoder;</span>
  <span class="s1">var objectMode = !!state.objectMode;</span>
  <span class="s1">var ret;</span>

  <span class="s1">// nothing in the list, definitely empty.</span>
  <span class="s1">if (list.length === 0)</span>
    <span class="s1">return null;</span>

  <span class="s1">if (length === 0)</span>
    <span class="s1">ret = null;</span>
  <span class="s1">else if (objectMode)</span>
    <span class="s1">ret = list.shift();</span>
  <span class="s1">else if (!n || n &gt;= length) {</span>
    <span class="s1">// read it all, truncate the array.</span>
    <span class="s1">if (stringMode)</span>
      <span class="s1">ret = list.join('');</span>
    <span class="s1">else</span>
      <span class="s1">ret = Buffer.concat(list, length);</span>
    <span class="s1">list.length = 0;</span>
  <span class="s1">} else {</span>
    <span class="s1">// read just some of it.</span>
    <span class="s1">if (n &lt; list[0].length) {</span>
      <span class="s1">// just take a part of the first list item.</span>
      <span class="s1">// slice is the same for buffers and strings.</span>
      <span class="s1">var buf = list[0];</span>
      <span class="s1">ret = buf.slice(0, n);</span>
      <span class="s1">list[0] = buf.slice(n);</span>
    <span class="s1">} else if (n === list[0].length) {</span>
      <span class="s1">// first list is a perfect match</span>
      <span class="s1">ret = list.shift();</span>
    <span class="s1">} else {</span>
      <span class="s1">// complex case.</span>
      <span class="s1">// we have enough to cover it, but it spans past the first buffer.</span>
      <span class="s1">if (stringMode)</span>
        <span class="s1">ret = '';</span>
      <span class="s1">else</span>
        <span class="s1">ret = new Buffer(n);</span>

      <span class="s1">var c = 0;</span>
      <span class="s1">for (var i = 0, l = list.length; i &lt; l &amp;&amp; c &lt; n; i++) {</span>
        <span class="s1">var buf = list[0];</span>
        <span class="s1">var cpy = Math.min(n - c, buf.length);</span>

        <span class="s1">if (stringMode)</span>
          <span class="s1">ret += buf.slice(0, cpy);</span>
        <span class="s1">else</span>
          <span class="s1">buf.copy(ret, c, 0, cpy);</span>

        <span class="s1">if (cpy &lt; buf.length)</span>
          <span class="s1">list[0] = buf.slice(cpy);</span>
        <span class="s1">else</span>
          <span class="s1">list.shift();</span>

        <span class="s1">c += cpy;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return ret;</span>
<span class="s1">}</span>

<span class="s1">function endReadable(stream) {</span>
  <span class="s1">var state = stream._readableState;</span>

  <span class="s1">// If we get here before consuming all the bytes, then that is a</span>
  <span class="s1">// bug in node.  Should never happen.</span>
  <span class="s1">if (state.length &gt; 0)</span>
    <span class="s1">throw new Error('endReadable called on non-empty stream');</span>

  <span class="s1">if (!state.endEmitted &amp;&amp; state.calledRead) {</span>
    <span class="s1">state.ended = true;</span>
    <span class="s1">setImmediate(function() {</span>
      <span class="s1">// Check that we didn't get one last unshift.</span>
      <span class="s1">if (!state.endEmitted &amp;&amp; state.length === 0) {</span>
        <span class="s1">state.endEmitted = true;</span>
        <span class="s1">stream.readable = false;</span>
        <span class="s1">stream.emit('end');</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function forEach (xs, f) {</span>
  <span class="s1">for (var i = 0, l = xs.length; i &lt; l; i++) {</span>
    <span class="s1">f(xs[i], i);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function indexOf (xs, x) {</span>
  <span class="s1">for (var i = 0, l = xs.length; i &lt; l; i++) {</span>
    <span class="s1">if (xs[i] === x) return i;</span>
  <span class="s1">}</span>
  <span class="s1">return -1;</span>
<span class="s1">}</span>

<span class="s1">}).call(this,require(&quot;g5I+bs&quot;))</span>
<span class="s1">},{&quot;./index.js&quot;:19,&quot;buffer&quot;:3,&quot;events&quot;:5,&quot;g5I+bs&quot;:13,&quot;inherits&quot;:10,&quot;process/browser.js&quot;:20,&quot;string_decoder&quot;:25}],23:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// a transform stream is a readable/writable stream where you do</span>
<span class="s1">// something with the data.  Sometimes it's called a &quot;filter&quot;,</span>
<span class="s1">// but that's not a great name for it, since that implies a thing where</span>
<span class="s1">// some bits pass through, and others are simply ignored.  (That would</span>
<span class="s1">// be a valid example of a transform, of course.)</span>
<span class="s1">//</span>
<span class="s1">// While the output is causally related to the input, it's not a</span>
<span class="s1">// necessarily symmetric or synchronous transformation.  For example,</span>
<span class="s1">// a zlib stream might take multiple plain-text writes(), and then</span>
<span class="s1">// emit a single compressed chunk some time in the future.</span>
<span class="s1">//</span>
<span class="s1">// Here's how this works:</span>
<span class="s1">//</span>
<span class="s1">// The Transform stream has all the aspects of the readable and writable</span>
<span class="s1">// stream classes.  When you write(chunk), that calls _write(chunk,cb)</span>
<span class="s1">// internally, and returns false if there's a lot of pending writes</span>
<span class="s1">// buffered up.  When you call read(), that calls _read(n) until</span>
<span class="s1">// there's enough pending readable data buffered up.</span>
<span class="s1">//</span>
<span class="s1">// In a transform stream, the written data is placed in a buffer.  When</span>
<span class="s1">// _read(n) is called, it transforms the queued up data, calling the</span>
<span class="s1">// buffered _write cb's as it consumes chunks.  If consuming a single</span>
<span class="s1">// written chunk would result in multiple output chunks, then the first</span>
<span class="s1">// outputted bit calls the readcb, and subsequent chunks just go into</span>
<span class="s1">// the read buffer, and will cause it to emit 'readable' if necessary.</span>
<span class="s1">//</span>
<span class="s1">// This way, back-pressure is actually determined by the reading side,</span>
<span class="s1">// since _read has to be called to start processing a new chunk.  However,</span>
<span class="s1">// a pathological inflate type of transform can cause excessive buffering</span>
<span class="s1">// here.  For example, imagine a stream where every byte of input is</span>
<span class="s1">// interpreted as an integer from 0-255, and then results in that many</span>
<span class="s1">// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in</span>
<span class="s1">// 1kb of data being output.  In this case, you could write a very small</span>
<span class="s1">// amount of input, and end up with a very large amount of output.  In</span>
<span class="s1">// such a pathological inflating mechanism, there'd be no way to tell</span>
<span class="s1">// the system to stop doing the transform.  A single 4MB write could</span>
<span class="s1">// cause the system to run out of memory.</span>
<span class="s1">//</span>
<span class="s1">// However, even in such a pathological case, only a single written chunk</span>
<span class="s1">// would be consumed, and then the rest would wait (un-transformed) until</span>
<span class="s1">// the results of the previous transformed chunk were consumed.</span>

<span class="s1">module.exports = Transform;</span>

<span class="s1">var Duplex = require('./duplex.js');</span>
<span class="s1">var inherits = require('inherits');</span>
<span class="s1">inherits(Transform, Duplex);</span>


<span class="s1">function TransformState(options, stream) {</span>
  <span class="s1">this.afterTransform = function(er, data) {</span>
    <span class="s1">return afterTransform(stream, er, data);</span>
  <span class="s1">};</span>

  <span class="s1">this.needTransform = false;</span>
  <span class="s1">this.transforming = false;</span>
  <span class="s1">this.writecb = null;</span>
  <span class="s1">this.writechunk = null;</span>
<span class="s1">}</span>

<span class="s1">function afterTransform(stream, er, data) {</span>
  <span class="s1">var ts = stream._transformState;</span>
  <span class="s1">ts.transforming = false;</span>

  <span class="s1">var cb = ts.writecb;</span>

  <span class="s1">if (!cb)</span>
    <span class="s1">return stream.emit('error', new Error('no writecb in Transform class'));</span>

  <span class="s1">ts.writechunk = null;</span>
  <span class="s1">ts.writecb = null;</span>

  <span class="s1">if (data !== null &amp;&amp; data !== undefined)</span>
    <span class="s1">stream.push(data);</span>

  <span class="s1">if (cb)</span>
    <span class="s1">cb(er);</span>

  <span class="s1">var rs = stream._readableState;</span>
  <span class="s1">rs.reading = false;</span>
  <span class="s1">if (rs.needReadable || rs.length &lt; rs.highWaterMark) {</span>
    <span class="s1">stream._read(rs.highWaterMark);</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s1">function Transform(options) {</span>
  <span class="s1">if (!(this instanceof Transform))</span>
    <span class="s1">return new Transform(options);</span>

  <span class="s1">Duplex.call(this, options);</span>

  <span class="s1">var ts = this._transformState = new TransformState(options, this);</span>

  <span class="s1">// when the writable side finishes, then flush out anything remaining.</span>
  <span class="s1">var stream = this;</span>

  <span class="s1">// start out asking for a readable event once data is transformed.</span>
  <span class="s1">this._readableState.needReadable = true;</span>

  <span class="s1">// we have implemented the _read method, and done the other things</span>
  <span class="s1">// that Readable wants before the first _read call, so unset the</span>
  <span class="s1">// sync guard flag.</span>
  <span class="s1">this._readableState.sync = false;</span>

  <span class="s1">this.once('finish', function() {</span>
    <span class="s1">if ('function' === typeof this._flush)</span>
      <span class="s1">this._flush(function(er) {</span>
        <span class="s1">done(stream, er);</span>
      <span class="s1">});</span>
    <span class="s1">else</span>
      <span class="s1">done(stream);</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">Transform.prototype.push = function(chunk, encoding) {</span>
  <span class="s1">this._transformState.needTransform = false;</span>
  <span class="s1">return Duplex.prototype.push.call(this, chunk, encoding);</span>
<span class="s1">};</span>

<span class="s1">// This is the part where you do stuff!</span>
<span class="s1">// override this function in implementation classes.</span>
<span class="s1">// 'chunk' is an input chunk.</span>
<span class="s1">//</span>
<span class="s1">// Call `push(newChunk)` to pass along transformed output</span>
<span class="s1">// to the readable side.  You may call 'push' zero or more times.</span>
<span class="s1">//</span>
<span class="s1">// Call `cb(err)` when you are done with this chunk.  If you pass</span>
<span class="s1">// an error, then that'll put the hurt on the whole operation.  If you</span>
<span class="s1">// never call cb(), then you'll never get another chunk.</span>
<span class="s1">Transform.prototype._transform = function(chunk, encoding, cb) {</span>
  <span class="s1">throw new Error('not implemented');</span>
<span class="s1">};</span>

<span class="s1">Transform.prototype._write = function(chunk, encoding, cb) {</span>
  <span class="s1">var ts = this._transformState;</span>
  <span class="s1">ts.writecb = cb;</span>
  <span class="s1">ts.writechunk = chunk;</span>
  <span class="s1">ts.writeencoding = encoding;</span>
  <span class="s1">if (!ts.transforming) {</span>
    <span class="s1">var rs = this._readableState;</span>
    <span class="s1">if (ts.needTransform ||</span>
        <span class="s1">rs.needReadable ||</span>
        <span class="s1">rs.length &lt; rs.highWaterMark)</span>
      <span class="s1">this._read(rs.highWaterMark);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">// Doesn't matter what the args are here.</span>
<span class="s1">// _transform does all the work.</span>
<span class="s1">// That we got here means that the readable side wants more data.</span>
<span class="s1">Transform.prototype._read = function(n) {</span>
  <span class="s1">var ts = this._transformState;</span>

  <span class="s1">if (ts.writechunk &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {</span>
    <span class="s1">ts.transforming = true;</span>
    <span class="s1">this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);</span>
  <span class="s1">} else {</span>
    <span class="s1">// mark that we need a transform, so that any data that comes in</span>
    <span class="s1">// will get processed, now that we've asked for it.</span>
    <span class="s1">ts.needTransform = true;</span>
  <span class="s1">}</span>
<span class="s1">};</span>


<span class="s1">function done(stream, er) {</span>
  <span class="s1">if (er)</span>
    <span class="s1">return stream.emit('error', er);</span>

  <span class="s1">// if there's nothing in the write buffer, then that means</span>
  <span class="s1">// that nothing more will ever be provided</span>
  <span class="s1">var ws = stream._writableState;</span>
  <span class="s1">var rs = stream._readableState;</span>
  <span class="s1">var ts = stream._transformState;</span>

  <span class="s1">if (ws.length)</span>
    <span class="s1">throw new Error('calling transform done when ws.length != 0');</span>

  <span class="s1">if (ts.transforming)</span>
    <span class="s1">throw new Error('calling transform done when still transforming');</span>

  <span class="s1">return stream.push(null);</span>
<span class="s1">}</span>

<span class="s1">},{&quot;./duplex.js&quot;:18,&quot;inherits&quot;:10}],24:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// A bit simpler than readable streams.</span>
<span class="s1">// Implement an async ._write(chunk, cb), and it'll handle all</span>
<span class="s1">// the drain event emission and buffering.</span>

<span class="s1">module.exports = Writable;</span>
<span class="s1">Writable.WritableState = WritableState;</span>

<span class="s1">var isUint8Array = typeof Uint8Array !== 'undefined'</span>
  <span class="s1">? function (x) { return x instanceof Uint8Array }</span>
  <span class="s1">: function (x) {</span>
    <span class="s1">return x &amp;&amp; x.constructor &amp;&amp; x.constructor.name === 'Uint8Array'</span>
  <span class="s1">}</span>
<span class="s1">;</span>
<span class="s1">var isArrayBuffer = typeof ArrayBuffer !== 'undefined'</span>
  <span class="s1">? function (x) { return x instanceof ArrayBuffer }</span>
  <span class="s1">: function (x) {</span>
    <span class="s1">return x &amp;&amp; x.constructor &amp;&amp; x.constructor.name === 'ArrayBuffer'</span>
  <span class="s1">}</span>
<span class="s1">;</span>

<span class="s1">var inherits = require('inherits');</span>
<span class="s1">var Stream = require('./index.js');</span>
<span class="s1">var setImmediate = require('process/browser.js').nextTick;</span>
<span class="s1">var Buffer = require('buffer').Buffer;</span>

<span class="s1">inherits(Writable, Stream);</span>

<span class="s1">function WriteReq(chunk, encoding, cb) {</span>
  <span class="s1">this.chunk = chunk;</span>
  <span class="s1">this.encoding = encoding;</span>
  <span class="s1">this.callback = cb;</span>
<span class="s1">}</span>

<span class="s1">function WritableState(options, stream) {</span>
  <span class="s1">options = options || {};</span>

  <span class="s1">// the point at which write() starts returning false</span>
  <span class="s1">// Note: 0 is a valid value, means that we always return false if</span>
  <span class="s1">// the entire buffer is not flushed immediately on write()</span>
  <span class="s1">var hwm = options.highWaterMark;</span>
  <span class="s1">this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;</span>

  <span class="s1">// object stream flag to indicate whether or not this stream</span>
  <span class="s1">// contains buffers or objects.</span>
  <span class="s1">this.objectMode = !!options.objectMode;</span>

  <span class="s1">// cast to ints.</span>
  <span class="s1">this.highWaterMark = ~~this.highWaterMark;</span>

  <span class="s1">this.needDrain = false;</span>
  <span class="s1">// at the start of calling end()</span>
  <span class="s1">this.ending = false;</span>
  <span class="s1">// when end() has been called, and returned</span>
  <span class="s1">this.ended = false;</span>
  <span class="s1">// when 'finish' is emitted</span>
  <span class="s1">this.finished = false;</span>

  <span class="s1">// should we decode strings into buffers before passing to _write?</span>
  <span class="s1">// this is here so that some node-core streams can optimize string</span>
  <span class="s1">// handling at a lower level.</span>
  <span class="s1">var noDecode = options.decodeStrings === false;</span>
  <span class="s1">this.decodeStrings = !noDecode;</span>

  <span class="s1">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="s1">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="s1">// Everything else in the universe uses 'utf8', though.</span>
  <span class="s1">this.defaultEncoding = options.defaultEncoding || 'utf8';</span>

  <span class="s1">// not an actual buffer we keep track of, but a measurement</span>
  <span class="s1">// of how much we're waiting to get pushed to some underlying</span>
  <span class="s1">// socket or file.</span>
  <span class="s1">this.length = 0;</span>

  <span class="s1">// a flag to see when we're in the middle of a write.</span>
  <span class="s1">this.writing = false;</span>

  <span class="s1">// a flag to be able to tell if the onwrite cb is called immediately,</span>
  <span class="s1">// or on a later tick.  We set this to true at first, becuase any</span>
  <span class="s1">// actions that shouldn't happen until &quot;later&quot; should generally also</span>
  <span class="s1">// not happen before the first write call.</span>
  <span class="s1">this.sync = true;</span>

  <span class="s1">// a flag to know if we're processing previously buffered items, which</span>
  <span class="s1">// may call the _write() callback in the same tick, so that we don't</span>
  <span class="s1">// end up in an overlapped onwrite situation.</span>
  <span class="s1">this.bufferProcessing = false;</span>

  <span class="s1">// the callback that's passed to _write(chunk,cb)</span>
  <span class="s1">this.onwrite = function(er) {</span>
    <span class="s1">onwrite(stream, er);</span>
  <span class="s1">};</span>

  <span class="s1">// the callback that the user supplies to write(chunk,encoding,cb)</span>
  <span class="s1">this.writecb = null;</span>

  <span class="s1">// the amount that is being written when _write is called.</span>
  <span class="s1">this.writelen = 0;</span>

  <span class="s1">this.buffer = [];</span>
<span class="s1">}</span>

<span class="s1">function Writable(options) {</span>
  <span class="s1">// Writable ctor is applied to Duplexes, though they're not</span>
  <span class="s1">// instanceof Writable, they're instanceof Readable.</span>
  <span class="s1">if (!(this instanceof Writable) &amp;&amp; !(this instanceof Stream.Duplex))</span>
    <span class="s1">return new Writable(options);</span>

  <span class="s1">this._writableState = new WritableState(options, this);</span>

  <span class="s1">// legacy.</span>
  <span class="s1">this.writable = true;</span>

  <span class="s1">Stream.call(this);</span>
<span class="s1">}</span>

<span class="s1">// Otherwise people can pipe Writable streams, which is just wrong.</span>
<span class="s1">Writable.prototype.pipe = function() {</span>
  <span class="s1">this.emit('error', new Error('Cannot pipe. Not readable.'));</span>
<span class="s1">};</span>


<span class="s1">function writeAfterEnd(stream, state, cb) {</span>
  <span class="s1">var er = new Error('write after end');</span>
  <span class="s1">// TODO: defer error events consistently everywhere, not just the cb</span>
  <span class="s1">stream.emit('error', er);</span>
  <span class="s1">setImmediate(function() {</span>
    <span class="s1">cb(er);</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">// If we get something that is not a buffer, string, null, or undefined,</span>
<span class="s1">// and we're not in objectMode, then that's an error.</span>
<span class="s1">// Otherwise stream chunks are all considered to be of length=1, and the</span>
<span class="s1">// watermarks determine how many objects to keep in the buffer, rather than</span>
<span class="s1">// how many bytes or characters.</span>
<span class="s1">function validChunk(stream, state, chunk, cb) {</span>
  <span class="s1">var valid = true;</span>
  <span class="s1">if (!Buffer.isBuffer(chunk) &amp;&amp;</span>
      <span class="s1">'string' !== typeof chunk &amp;&amp;</span>
      <span class="s1">chunk !== null &amp;&amp;</span>
      <span class="s1">chunk !== undefined &amp;&amp;</span>
      <span class="s1">!state.objectMode) {</span>
    <span class="s1">var er = new TypeError('Invalid non-string/buffer chunk');</span>
    <span class="s1">stream.emit('error', er);</span>
    <span class="s1">setImmediate(function() {</span>
      <span class="s1">cb(er);</span>
    <span class="s1">});</span>
    <span class="s1">valid = false;</span>
  <span class="s1">}</span>
  <span class="s1">return valid;</span>
<span class="s1">}</span>

<span class="s1">Writable.prototype.write = function(chunk, encoding, cb) {</span>
  <span class="s1">var state = this._writableState;</span>
  <span class="s1">var ret = false;</span>

  <span class="s1">if (typeof encoding === 'function') {</span>
    <span class="s1">cb = encoding;</span>
    <span class="s1">encoding = null;</span>
  <span class="s1">}</span>

  <span class="s1">if (!Buffer.isBuffer(chunk) &amp;&amp; isUint8Array(chunk))</span>
    <span class="s1">chunk = new Buffer(chunk);</span>
  <span class="s1">if (isArrayBuffer(chunk) &amp;&amp; typeof Uint8Array !== 'undefined')</span>
    <span class="s1">chunk = new Buffer(new Uint8Array(chunk));</span>
  
  <span class="s1">if (Buffer.isBuffer(chunk))</span>
    <span class="s1">encoding = 'buffer';</span>
  <span class="s1">else if (!encoding)</span>
    <span class="s1">encoding = state.defaultEncoding;</span>

  <span class="s1">if (typeof cb !== 'function')</span>
    <span class="s1">cb = function() {};</span>

  <span class="s1">if (state.ended)</span>
    <span class="s1">writeAfterEnd(this, state, cb);</span>
  <span class="s1">else if (validChunk(this, state, chunk, cb))</span>
    <span class="s1">ret = writeOrBuffer(this, state, chunk, encoding, cb);</span>

  <span class="s1">return ret;</span>
<span class="s1">};</span>

<span class="s1">function decodeChunk(state, chunk, encoding) {</span>
  <span class="s1">if (!state.objectMode &amp;&amp;</span>
      <span class="s1">state.decodeStrings !== false &amp;&amp;</span>
      <span class="s1">typeof chunk === 'string') {</span>
    <span class="s1">chunk = new Buffer(chunk, encoding);</span>
  <span class="s1">}</span>
  <span class="s1">return chunk;</span>
<span class="s1">}</span>

<span class="s1">// if we're already writing something, then just put this</span>
<span class="s1">// in the queue, and wait our turn.  Otherwise, call _write</span>
<span class="s1">// If we return false, then we need a drain event, so set that flag.</span>
<span class="s1">function writeOrBuffer(stream, state, chunk, encoding, cb) {</span>
  <span class="s1">chunk = decodeChunk(state, chunk, encoding);</span>
  <span class="s1">var len = state.objectMode ? 1 : chunk.length;</span>

  <span class="s1">state.length += len;</span>

  <span class="s1">var ret = state.length &lt; state.highWaterMark;</span>
  <span class="s1">state.needDrain = !ret;</span>

  <span class="s1">if (state.writing)</span>
    <span class="s1">state.buffer.push(new WriteReq(chunk, encoding, cb));</span>
  <span class="s1">else</span>
    <span class="s1">doWrite(stream, state, len, chunk, encoding, cb);</span>

  <span class="s1">return ret;</span>
<span class="s1">}</span>

<span class="s1">function doWrite(stream, state, len, chunk, encoding, cb) {</span>
  <span class="s1">state.writelen = len;</span>
  <span class="s1">state.writecb = cb;</span>
  <span class="s1">state.writing = true;</span>
  <span class="s1">state.sync = true;</span>
  <span class="s1">stream._write(chunk, encoding, state.onwrite);</span>
  <span class="s1">state.sync = false;</span>
<span class="s1">}</span>

<span class="s1">function onwriteError(stream, state, sync, er, cb) {</span>
  <span class="s1">if (sync)</span>
    <span class="s1">setImmediate(function() {</span>
      <span class="s1">cb(er);</span>
    <span class="s1">});</span>
  <span class="s1">else</span>
    <span class="s1">cb(er);</span>

  <span class="s1">stream.emit('error', er);</span>
<span class="s1">}</span>

<span class="s1">function onwriteStateUpdate(state) {</span>
  <span class="s1">state.writing = false;</span>
  <span class="s1">state.writecb = null;</span>
  <span class="s1">state.length -= state.writelen;</span>
  <span class="s1">state.writelen = 0;</span>
<span class="s1">}</span>

<span class="s1">function onwrite(stream, er) {</span>
  <span class="s1">var state = stream._writableState;</span>
  <span class="s1">var sync = state.sync;</span>
  <span class="s1">var cb = state.writecb;</span>

  <span class="s1">onwriteStateUpdate(state);</span>

  <span class="s1">if (er)</span>
    <span class="s1">onwriteError(stream, state, sync, er, cb);</span>
  <span class="s1">else {</span>
    <span class="s1">// Check if we're actually ready to finish, but don't emit yet</span>
    <span class="s1">var finished = needFinish(stream, state);</span>

    <span class="s1">if (!finished &amp;&amp; !state.bufferProcessing &amp;&amp; state.buffer.length)</span>
      <span class="s1">clearBuffer(stream, state);</span>

    <span class="s1">if (sync) {</span>
      <span class="s1">setImmediate(function() {</span>
        <span class="s1">afterWrite(stream, state, finished, cb);</span>
      <span class="s1">});</span>
    <span class="s1">} else {</span>
      <span class="s1">afterWrite(stream, state, finished, cb);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function afterWrite(stream, state, finished, cb) {</span>
  <span class="s1">if (!finished)</span>
    <span class="s1">onwriteDrain(stream, state);</span>
  <span class="s1">cb();</span>
  <span class="s1">if (finished)</span>
    <span class="s1">finishMaybe(stream, state);</span>
<span class="s1">}</span>

<span class="s1">// Must force callback to be called on nextTick, so that we don't</span>
<span class="s1">// emit 'drain' before the write() consumer gets the 'false' return</span>
<span class="s1">// value, and has a chance to attach a 'drain' listener.</span>
<span class="s1">function onwriteDrain(stream, state) {</span>
  <span class="s1">if (state.length === 0 &amp;&amp; state.needDrain) {</span>
    <span class="s1">state.needDrain = false;</span>
    <span class="s1">stream.emit('drain');</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s1">// if there's something in the buffer waiting, then process it</span>
<span class="s1">function clearBuffer(stream, state) {</span>
  <span class="s1">state.bufferProcessing = true;</span>

  <span class="s1">for (var c = 0; c &lt; state.buffer.length; c++) {</span>
    <span class="s1">var entry = state.buffer[c];</span>
    <span class="s1">var chunk = entry.chunk;</span>
    <span class="s1">var encoding = entry.encoding;</span>
    <span class="s1">var cb = entry.callback;</span>
    <span class="s1">var len = state.objectMode ? 1 : chunk.length;</span>

    <span class="s1">doWrite(stream, state, len, chunk, encoding, cb);</span>

    <span class="s1">// if we didn't call the onwrite immediately, then</span>
    <span class="s1">// it means that we need to wait until it does.</span>
    <span class="s1">// also, that means that the chunk and cb are currently</span>
    <span class="s1">// being processed, so move the buffer counter past them.</span>
    <span class="s1">if (state.writing) {</span>
      <span class="s1">c++;</span>
      <span class="s1">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.bufferProcessing = false;</span>
  <span class="s1">if (c &lt; state.buffer.length)</span>
    <span class="s1">state.buffer = state.buffer.slice(c);</span>
  <span class="s1">else</span>
    <span class="s1">state.buffer.length = 0;</span>
<span class="s1">}</span>

<span class="s1">Writable.prototype._write = function(chunk, encoding, cb) {</span>
  <span class="s1">cb(new Error('not implemented'));</span>
<span class="s1">};</span>

<span class="s1">Writable.prototype.end = function(chunk, encoding, cb) {</span>
  <span class="s1">var state = this._writableState;</span>

  <span class="s1">if (typeof chunk === 'function') {</span>
    <span class="s1">cb = chunk;</span>
    <span class="s1">chunk = null;</span>
    <span class="s1">encoding = null;</span>
  <span class="s1">} else if (typeof encoding === 'function') {</span>
    <span class="s1">cb = encoding;</span>
    <span class="s1">encoding = null;</span>
  <span class="s1">}</span>

  <span class="s1">if (typeof chunk !== 'undefined' &amp;&amp; chunk !== null)</span>
    <span class="s1">this.write(chunk, encoding);</span>

  <span class="s1">// ignore unnecessary end() calls.</span>
  <span class="s1">if (!state.ending &amp;&amp; !state.finished)</span>
    <span class="s1">endWritable(this, state, cb);</span>
<span class="s1">};</span>


<span class="s1">function needFinish(stream, state) {</span>
  <span class="s1">return (state.ending &amp;&amp;</span>
          <span class="s1">state.length === 0 &amp;&amp;</span>
          <span class="s1">!state.finished &amp;&amp;</span>
          <span class="s1">!state.writing);</span>
<span class="s1">}</span>

<span class="s1">function finishMaybe(stream, state) {</span>
  <span class="s1">var need = needFinish(stream, state);</span>
  <span class="s1">if (need) {</span>
    <span class="s1">state.finished = true;</span>
    <span class="s1">stream.emit('finish');</span>
  <span class="s1">}</span>
  <span class="s1">return need;</span>
<span class="s1">}</span>

<span class="s1">function endWritable(stream, state, cb) {</span>
  <span class="s1">state.ending = true;</span>
  <span class="s1">finishMaybe(stream, state);</span>
  <span class="s1">if (cb) {</span>
    <span class="s1">if (state.finished)</span>
      <span class="s1">setImmediate(cb);</span>
    <span class="s1">else</span>
      <span class="s1">stream.once('finish', cb);</span>
  <span class="s1">}</span>
  <span class="s1">state.ended = true;</span>
<span class="s1">}</span>

<span class="s1">},{&quot;./index.js&quot;:19,&quot;buffer&quot;:3,&quot;inherits&quot;:10,&quot;process/browser.js&quot;:20}],25:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">var Buffer = require('buffer').Buffer;</span>

<span class="s1">function assertEncoding(encoding) {</span>
  <span class="s1">if (encoding &amp;&amp; !Buffer.isEncoding(encoding)) {</span>
    <span class="s1">throw new Error('Unknown encoding: ' + encoding);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">var StringDecoder = exports.StringDecoder = function(encoding) {</span>
  <span class="s1">this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');</span>
  <span class="s1">assertEncoding(encoding);</span>
  <span class="s1">switch (this.encoding) {</span>
    <span class="s1">case 'utf8':</span>
      <span class="s1">// CESU-8 represents each of Surrogate Pair by 3-bytes</span>
      <span class="s1">this.surrogateSize = 3;</span>
      <span class="s1">break;</span>
    <span class="s1">case 'ucs2':</span>
    <span class="s1">case 'utf16le':</span>
      <span class="s1">// UTF-16 represents each of Surrogate Pair by 2-bytes</span>
      <span class="s1">this.surrogateSize = 2;</span>
      <span class="s1">this.detectIncompleteChar = utf16DetectIncompleteChar;</span>
      <span class="s1">break;</span>
    <span class="s1">case 'base64':</span>
      <span class="s1">// Base-64 stores 3 bytes in 4 chars, and pads the remainder.</span>
      <span class="s1">this.surrogateSize = 3;</span>
      <span class="s1">this.detectIncompleteChar = base64DetectIncompleteChar;</span>
      <span class="s1">break;</span>
    <span class="s1">default:</span>
      <span class="s1">this.write = passThroughWrite;</span>
      <span class="s1">return;</span>
  <span class="s1">}</span>

  <span class="s1">this.charBuffer = new Buffer(6);</span>
  <span class="s1">this.charReceived = 0;</span>
  <span class="s1">this.charLength = 0;</span>
<span class="s1">};</span>


<span class="s1">StringDecoder.prototype.write = function(buffer) {</span>
  <span class="s1">var charStr = '';</span>
  <span class="s1">var offset = 0;</span>

  <span class="s1">// if our last write ended with an incomplete multibyte character</span>
  <span class="s1">while (this.charLength) {</span>
    <span class="s1">// determine how many remaining bytes this buffer has to offer for this char</span>
    <span class="s1">var i = (buffer.length &gt;= this.charLength - this.charReceived) ?</span>
                <span class="s1">this.charLength - this.charReceived :</span>
                <span class="s1">buffer.length;</span>

    <span class="s1">// add the new bytes to the char buffer</span>
    <span class="s1">buffer.copy(this.charBuffer, this.charReceived, offset, i);</span>
    <span class="s1">this.charReceived += (i - offset);</span>
    <span class="s1">offset = i;</span>

    <span class="s1">if (this.charReceived &lt; this.charLength) {</span>
      <span class="s1">// still not enough chars in this buffer? wait for more ...</span>
      <span class="s1">return '';</span>
    <span class="s1">}</span>

    <span class="s1">// get the character that was split</span>
    <span class="s1">charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);</span>

    <span class="s1">// lead surrogate (D800-DBFF) is also the incomplete character</span>
    <span class="s1">var charCode = charStr.charCodeAt(charStr.length - 1);</span>
    <span class="s1">if (charCode &gt;= 0xD800 &amp;&amp; charCode &lt;= 0xDBFF) {</span>
      <span class="s1">this.charLength += this.surrogateSize;</span>
      <span class="s1">charStr = '';</span>
      <span class="s1">continue;</span>
    <span class="s1">}</span>
    <span class="s1">this.charReceived = this.charLength = 0;</span>

    <span class="s1">// if there are no more bytes in this buffer, just emit our char</span>
    <span class="s1">if (i == buffer.length) return charStr;</span>

    <span class="s1">// otherwise cut off the characters end from the beginning of this buffer</span>
    <span class="s1">buffer = buffer.slice(i, buffer.length);</span>
    <span class="s1">break;</span>
  <span class="s1">}</span>

  <span class="s1">var lenIncomplete = this.detectIncompleteChar(buffer);</span>

  <span class="s1">var end = buffer.length;</span>
  <span class="s1">if (this.charLength) {</span>
    <span class="s1">// buffer the incomplete character bytes we got</span>
    <span class="s1">buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);</span>
    <span class="s1">this.charReceived = lenIncomplete;</span>
    <span class="s1">end -= lenIncomplete;</span>
  <span class="s1">}</span>

  <span class="s1">charStr += buffer.toString(this.encoding, 0, end);</span>

  <span class="s1">var end = charStr.length - 1;</span>
  <span class="s1">var charCode = charStr.charCodeAt(end);</span>
  <span class="s1">// lead surrogate (D800-DBFF) is also the incomplete character</span>
  <span class="s1">if (charCode &gt;= 0xD800 &amp;&amp; charCode &lt;= 0xDBFF) {</span>
    <span class="s1">var size = this.surrogateSize;</span>
    <span class="s1">this.charLength += size;</span>
    <span class="s1">this.charReceived += size;</span>
    <span class="s1">this.charBuffer.copy(this.charBuffer, size, 0, size);</span>
    <span class="s1">this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);</span>
    <span class="s1">return charStr.substring(0, end);</span>
  <span class="s1">}</span>

  <span class="s1">// or just emit the charStr</span>
  <span class="s1">return charStr;</span>
<span class="s1">};</span>

<span class="s1">StringDecoder.prototype.detectIncompleteChar = function(buffer) {</span>
  <span class="s1">// determine how many bytes we have to check at the end of this buffer</span>
  <span class="s1">var i = (buffer.length &gt;= 3) ? 3 : buffer.length;</span>

  <span class="s1">// Figure out if one of the last i bytes of our buffer announces an</span>
  <span class="s1">// incomplete char.</span>
  <span class="s1">for (; i &gt; 0; i--) {</span>
    <span class="s1">var c = buffer[buffer.length - i];</span>

    <span class="s1">// See http://en.wikipedia.org/wiki/UTF-8#Description</span>

    <span class="s1">// 110XXXXX</span>
    <span class="s1">if (i == 1 &amp;&amp; c &gt;&gt; 5 == 0x06) {</span>
      <span class="s1">this.charLength = 2;</span>
      <span class="s1">break;</span>
    <span class="s1">}</span>

    <span class="s1">// 1110XXXX</span>
    <span class="s1">if (i &lt;= 2 &amp;&amp; c &gt;&gt; 4 == 0x0E) {</span>
      <span class="s1">this.charLength = 3;</span>
      <span class="s1">break;</span>
    <span class="s1">}</span>

    <span class="s1">// 11110XXX</span>
    <span class="s1">if (i &lt;= 3 &amp;&amp; c &gt;&gt; 3 == 0x1E) {</span>
      <span class="s1">this.charLength = 4;</span>
      <span class="s1">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return i;</span>
<span class="s1">};</span>

<span class="s1">StringDecoder.prototype.end = function(buffer) {</span>
  <span class="s1">var res = '';</span>
  <span class="s1">if (buffer &amp;&amp; buffer.length)</span>
    <span class="s1">res = this.write(buffer);</span>

  <span class="s1">if (this.charReceived) {</span>
    <span class="s1">var cr = this.charReceived;</span>
    <span class="s1">var buf = this.charBuffer;</span>
    <span class="s1">var enc = this.encoding;</span>
    <span class="s1">res += buf.slice(0, cr).toString(enc);</span>
  <span class="s1">}</span>

  <span class="s1">return res;</span>
<span class="s1">};</span>

<span class="s1">function passThroughWrite(buffer) {</span>
  <span class="s1">return buffer.toString(this.encoding);</span>
<span class="s1">}</span>

<span class="s1">function utf16DetectIncompleteChar(buffer) {</span>
  <span class="s1">var incomplete = this.charReceived = buffer.length % 2;</span>
  <span class="s1">this.charLength = incomplete ? 2 : 0;</span>
  <span class="s1">return incomplete;</span>
<span class="s1">}</span>

<span class="s1">function base64DetectIncompleteChar(buffer) {</span>
  <span class="s1">var incomplete = this.charReceived = buffer.length % 3;</span>
  <span class="s1">this.charLength = incomplete ? 3 : 0;</span>
  <span class="s1">return incomplete;</span>
<span class="s1">}</span>

<span class="s1">},{&quot;buffer&quot;:3}],26:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">var punycode = require('punycode');</span>

<span class="s1">exports.parse = urlParse;</span>
<span class="s1">exports.resolve = urlResolve;</span>
<span class="s1">exports.resolveObject = urlResolveObject;</span>
<span class="s1">exports.format = urlFormat;</span>

<span class="s1">exports.Url = Url;</span>

<span class="s1">function Url() {</span>
  <span class="s1">this.protocol = null;</span>
  <span class="s1">this.slashes = null;</span>
  <span class="s1">this.auth = null;</span>
  <span class="s1">this.host = null;</span>
  <span class="s1">this.port = null;</span>
  <span class="s1">this.hostname = null;</span>
  <span class="s1">this.hash = null;</span>
  <span class="s1">this.search = null;</span>
  <span class="s1">this.query = null;</span>
  <span class="s1">this.pathname = null;</span>
  <span class="s1">this.path = null;</span>
  <span class="s1">this.href = null;</span>
<span class="s1">}</span>

<span class="s1">// Reference: RFC 3986, RFC 1808, RFC 2396</span>

<span class="s1">// define these here so at least they only have to be</span>
<span class="s1">// compiled once on the first module load.</span>
<span class="s1">var protocolPattern = /^([a-z0-9.+-]+:)/i,</span>
    <span class="s1">portPattern = /:[0-9]*$/,</span>

    <span class="s1">// RFC 2396: characters reserved for delimiting URLs.</span>
    <span class="s1">// We actually just auto-escape these.</span>
    <span class="s1">delims = ['&lt;', '&gt;', '&quot;', '`', ' ', '\r', '\n', '\t'],</span>

    <span class="s1">// RFC 2396: characters not allowed for various reasons.</span>
    <span class="s1">unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),</span>

    <span class="s1">// Allowed by RFCs, but cause of XSS attacks.  Always escape these.</span>
    <span class="s1">autoEscape = ['\''].concat(unwise),</span>
    <span class="s1">// Characters that are never ever allowed in a hostname.</span>
    <span class="s1">// Note that any invalid chars are also handled, but these</span>
    <span class="s1">// are the ones that are *expected* to be seen, so we fast-path</span>
    <span class="s1">// them.</span>
    <span class="s1">nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),</span>
    <span class="s1">hostEndingChars = ['/', '?', '#'],</span>
    <span class="s1">hostnameMaxLen = 255,</span>
    <span class="s1">hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,</span>
    <span class="s1">hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,</span>
    <span class="s1">// protocols that can allow &quot;unsafe&quot; and &quot;unwise&quot; chars.</span>
    <span class="s1">unsafeProtocol = {</span>
      <span class="s1">'javascript': true,</span>
      <span class="s1">'javascript:': true</span>
    <span class="s1">},</span>
    <span class="s1">// protocols that never have a hostname.</span>
    <span class="s1">hostlessProtocol = {</span>
      <span class="s1">'javascript': true,</span>
      <span class="s1">'javascript:': true</span>
    <span class="s1">},</span>
    <span class="s1">// protocols that always contain a // bit.</span>
    <span class="s1">slashedProtocol = {</span>
      <span class="s1">'http': true,</span>
      <span class="s1">'https': true,</span>
      <span class="s1">'ftp': true,</span>
      <span class="s1">'gopher': true,</span>
      <span class="s1">'file': true,</span>
      <span class="s1">'http:': true,</span>
      <span class="s1">'https:': true,</span>
      <span class="s1">'ftp:': true,</span>
      <span class="s1">'gopher:': true,</span>
      <span class="s1">'file:': true</span>
    <span class="s1">},</span>
    <span class="s1">querystring = require('querystring');</span>

<span class="s1">function urlParse(url, parseQueryString, slashesDenoteHost) {</span>
  <span class="s1">if (url &amp;&amp; isObject(url) &amp;&amp; url instanceof Url) return url;</span>

  <span class="s1">var u = new Url;</span>
  <span class="s1">u.parse(url, parseQueryString, slashesDenoteHost);</span>
  <span class="s1">return u;</span>
<span class="s1">}</span>

<span class="s1">Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {</span>
  <span class="s1">if (!isString(url)) {</span>
    <span class="s1">throw new TypeError(&quot;Parameter 'url' must be a string, not &quot; + typeof url);</span>
  <span class="s1">}</span>

  <span class="s1">var rest = url;</span>

  <span class="s1">// trim before proceeding.</span>
  <span class="s1">// This is to support parse stuff like &quot;  http://foo.com  \n&quot;</span>
  <span class="s1">rest = rest.trim();</span>

  <span class="s1">var proto = protocolPattern.exec(rest);</span>
  <span class="s1">if (proto) {</span>
    <span class="s1">proto = proto[0];</span>
    <span class="s1">var lowerProto = proto.toLowerCase();</span>
    <span class="s1">this.protocol = lowerProto;</span>
    <span class="s1">rest = rest.substr(proto.length);</span>
  <span class="s1">}</span>

  <span class="s1">// figure out if it's got a host</span>
  <span class="s1">// user@server is *always* interpreted as a hostname, and url</span>
  <span class="s1">// resolution will treat //foo/bar as host=foo,path=bar because that's</span>
  <span class="s1">// how the browser resolves relative URLs.</span>
  <span class="s1">if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {</span>
    <span class="s1">var slashes = rest.substr(0, 2) === '//';</span>
    <span class="s1">if (slashes &amp;&amp; !(proto &amp;&amp; hostlessProtocol[proto])) {</span>
      <span class="s1">rest = rest.substr(2);</span>
      <span class="s1">this.slashes = true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (!hostlessProtocol[proto] &amp;&amp;</span>
      <span class="s1">(slashes || (proto &amp;&amp; !slashedProtocol[proto]))) {</span>

    <span class="s1">// there's a hostname.</span>
    <span class="s1">// the first instance of /, ?, ;, or # ends the host.</span>
    <span class="s1">//</span>
    <span class="s1">// If there is an @ in the hostname, then non-host chars *are* allowed</span>
    <span class="s1">// to the left of the last @ sign, unless some host-ending character</span>
    <span class="s1">// comes *before* the @-sign.</span>
    <span class="s1">// URLs are obnoxious.</span>
    <span class="s1">//</span>
    <span class="s1">// ex:</span>
    <span class="s1">// http://a@b@c/ =&gt; user:a@b host:c</span>
    <span class="s1">// http://a@b?@c =&gt; user:a host:c path:/?@c</span>

    <span class="s1">// v0.12 TODO(isaacs): This is not quite how Chrome does things.</span>
    <span class="s1">// Review our test case against browsers more comprehensively.</span>

    <span class="s1">// find the first instance of any hostEndingChars</span>
    <span class="s1">var hostEnd = -1;</span>
    <span class="s1">for (var i = 0; i &lt; hostEndingChars.length; i++) {</span>
      <span class="s1">var hec = rest.indexOf(hostEndingChars[i]);</span>
      <span class="s1">if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd))</span>
        <span class="s1">hostEnd = hec;</span>
    <span class="s1">}</span>

    <span class="s1">// at this point, either we have an explicit point where the</span>
    <span class="s1">// auth portion cannot go past, or the last @ char is the decider.</span>
    <span class="s1">var auth, atSign;</span>
    <span class="s1">if (hostEnd === -1) {</span>
      <span class="s1">// atSign can be anywhere.</span>
      <span class="s1">atSign = rest.lastIndexOf('@');</span>
    <span class="s1">} else {</span>
      <span class="s1">// atSign must be in auth portion.</span>
      <span class="s1">// http://a@b/c@d =&gt; host:b auth:a path:/c@d</span>
      <span class="s1">atSign = rest.lastIndexOf('@', hostEnd);</span>
    <span class="s1">}</span>

    <span class="s1">// Now we have a portion which is definitely the auth.</span>
    <span class="s1">// Pull that off.</span>
    <span class="s1">if (atSign !== -1) {</span>
      <span class="s1">auth = rest.slice(0, atSign);</span>
      <span class="s1">rest = rest.slice(atSign + 1);</span>
      <span class="s1">this.auth = decodeURIComponent(auth);</span>
    <span class="s1">}</span>

    <span class="s1">// the host is the remaining to the left of the first non-host char</span>
    <span class="s1">hostEnd = -1;</span>
    <span class="s1">for (var i = 0; i &lt; nonHostChars.length; i++) {</span>
      <span class="s1">var hec = rest.indexOf(nonHostChars[i]);</span>
      <span class="s1">if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd))</span>
        <span class="s1">hostEnd = hec;</span>
    <span class="s1">}</span>
    <span class="s1">// if we still have not hit it, then the entire thing is a host.</span>
    <span class="s1">if (hostEnd === -1)</span>
      <span class="s1">hostEnd = rest.length;</span>

    <span class="s1">this.host = rest.slice(0, hostEnd);</span>
    <span class="s1">rest = rest.slice(hostEnd);</span>

    <span class="s1">// pull out port.</span>
    <span class="s1">this.parseHost();</span>

    <span class="s1">// we've indicated that there is a hostname,</span>
    <span class="s1">// so even if it's empty, it has to be present.</span>
    <span class="s1">this.hostname = this.hostname || '';</span>

    <span class="s1">// if hostname begins with [ and ends with ]</span>
    <span class="s1">// assume that it's an IPv6 address.</span>
    <span class="s1">var ipv6Hostname = this.hostname[0] === '[' &amp;&amp;</span>
        <span class="s1">this.hostname[this.hostname.length - 1] === ']';</span>

    <span class="s1">// validate a little.</span>
    <span class="s1">if (!ipv6Hostname) {</span>
      <span class="s1">var hostparts = this.hostname.split(/\./);</span>
      <span class="s1">for (var i = 0, l = hostparts.length; i &lt; l; i++) {</span>
        <span class="s1">var part = hostparts[i];</span>
        <span class="s1">if (!part) continue;</span>
        <span class="s1">if (!part.match(hostnamePartPattern)) {</span>
          <span class="s1">var newpart = '';</span>
          <span class="s1">for (var j = 0, k = part.length; j &lt; k; j++) {</span>
            <span class="s1">if (part.charCodeAt(j) &gt; 127) {</span>
              <span class="s1">// we replace non-ASCII char with a temporary placeholder</span>
              <span class="s1">// we need this to make sure size of hostname is not</span>
              <span class="s1">// broken by replacing non-ASCII by nothing</span>
              <span class="s1">newpart += 'x';</span>
            <span class="s1">} else {</span>
              <span class="s1">newpart += part[j];</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s1">// we test again with ASCII char only</span>
          <span class="s1">if (!newpart.match(hostnamePartPattern)) {</span>
            <span class="s1">var validParts = hostparts.slice(0, i);</span>
            <span class="s1">var notHost = hostparts.slice(i + 1);</span>
            <span class="s1">var bit = part.match(hostnamePartStart);</span>
            <span class="s1">if (bit) {</span>
              <span class="s1">validParts.push(bit[1]);</span>
              <span class="s1">notHost.unshift(bit[2]);</span>
            <span class="s1">}</span>
            <span class="s1">if (notHost.length) {</span>
              <span class="s1">rest = '/' + notHost.join('.') + rest;</span>
            <span class="s1">}</span>
            <span class="s1">this.hostname = validParts.join('.');</span>
            <span class="s1">break;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">if (this.hostname.length &gt; hostnameMaxLen) {</span>
      <span class="s1">this.hostname = '';</span>
    <span class="s1">} else {</span>
      <span class="s1">// hostnames are always lower case.</span>
      <span class="s1">this.hostname = this.hostname.toLowerCase();</span>
    <span class="s1">}</span>

    <span class="s1">if (!ipv6Hostname) {</span>
      <span class="s1">// IDNA Support: Returns a puny coded representation of &quot;domain&quot;.</span>
      <span class="s1">// It only converts the part of the domain name that</span>
      <span class="s1">// has non ASCII characters. I.e. it dosent matter if</span>
      <span class="s1">// you call it with a domain that already is in ASCII.</span>
      <span class="s1">var domainArray = this.hostname.split('.');</span>
      <span class="s1">var newOut = [];</span>
      <span class="s1">for (var i = 0; i &lt; domainArray.length; ++i) {</span>
        <span class="s1">var s = domainArray[i];</span>
        <span class="s1">newOut.push(s.match(/[^A-Za-z0-9_-]/) ?</span>
            <span class="s1">'xn--' + punycode.encode(s) : s);</span>
      <span class="s1">}</span>
      <span class="s1">this.hostname = newOut.join('.');</span>
    <span class="s1">}</span>

    <span class="s1">var p = this.port ? ':' + this.port : '';</span>
    <span class="s1">var h = this.hostname || '';</span>
    <span class="s1">this.host = h + p;</span>
    <span class="s1">this.href += this.host;</span>

    <span class="s1">// strip [ and ] from the hostname</span>
    <span class="s1">// the host field still retains them, though</span>
    <span class="s1">if (ipv6Hostname) {</span>
      <span class="s1">this.hostname = this.hostname.substr(1, this.hostname.length - 2);</span>
      <span class="s1">if (rest[0] !== '/') {</span>
        <span class="s1">rest = '/' + rest;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">// now rest is set to the post-host stuff.</span>
  <span class="s1">// chop off any delim chars.</span>
  <span class="s1">if (!unsafeProtocol[lowerProto]) {</span>

    <span class="s1">// First, make 100% sure that any &quot;autoEscape&quot; chars get</span>
    <span class="s1">// escaped, even if encodeURIComponent doesn't think they</span>
    <span class="s1">// need to be.</span>
    <span class="s1">for (var i = 0, l = autoEscape.length; i &lt; l; i++) {</span>
      <span class="s1">var ae = autoEscape[i];</span>
      <span class="s1">var esc = encodeURIComponent(ae);</span>
      <span class="s1">if (esc === ae) {</span>
        <span class="s1">esc = escape(ae);</span>
      <span class="s1">}</span>
      <span class="s1">rest = rest.split(ae).join(esc);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>


  <span class="s1">// chop off from the tail first.</span>
  <span class="s1">var hash = rest.indexOf('#');</span>
  <span class="s1">if (hash !== -1) {</span>
    <span class="s1">// got a fragment string.</span>
    <span class="s1">this.hash = rest.substr(hash);</span>
    <span class="s1">rest = rest.slice(0, hash);</span>
  <span class="s1">}</span>
  <span class="s1">var qm = rest.indexOf('?');</span>
  <span class="s1">if (qm !== -1) {</span>
    <span class="s1">this.search = rest.substr(qm);</span>
    <span class="s1">this.query = rest.substr(qm + 1);</span>
    <span class="s1">if (parseQueryString) {</span>
      <span class="s1">this.query = querystring.parse(this.query);</span>
    <span class="s1">}</span>
    <span class="s1">rest = rest.slice(0, qm);</span>
  <span class="s1">} else if (parseQueryString) {</span>
    <span class="s1">// no query string, but parseQueryString still requested</span>
    <span class="s1">this.search = '';</span>
    <span class="s1">this.query = {};</span>
  <span class="s1">}</span>
  <span class="s1">if (rest) this.pathname = rest;</span>
  <span class="s1">if (slashedProtocol[lowerProto] &amp;&amp;</span>
      <span class="s1">this.hostname &amp;&amp; !this.pathname) {</span>
    <span class="s1">this.pathname = '/';</span>
  <span class="s1">}</span>

  <span class="s1">//to support http.request</span>
  <span class="s1">if (this.pathname || this.search) {</span>
    <span class="s1">var p = this.pathname || '';</span>
    <span class="s1">var s = this.search || '';</span>
    <span class="s1">this.path = p + s;</span>
  <span class="s1">}</span>

  <span class="s1">// finally, reconstruct the href based on what has been validated.</span>
  <span class="s1">this.href = this.format();</span>
  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">// format a parsed object into a url string</span>
<span class="s1">function urlFormat(obj) {</span>
  <span class="s1">// ensure it's an object, and not a string url.</span>
  <span class="s1">// If it's an obj, this is a no-op.</span>
  <span class="s1">// this way, you can call url_format() on strings</span>
  <span class="s1">// to clean up potentially wonky urls.</span>
  <span class="s1">if (isString(obj)) obj = urlParse(obj);</span>
  <span class="s1">if (!(obj instanceof Url)) return Url.prototype.format.call(obj);</span>
  <span class="s1">return obj.format();</span>
<span class="s1">}</span>

<span class="s1">Url.prototype.format = function() {</span>
  <span class="s1">var auth = this.auth || '';</span>
  <span class="s1">if (auth) {</span>
    <span class="s1">auth = encodeURIComponent(auth);</span>
    <span class="s1">auth = auth.replace(/%3A/i, ':');</span>
    <span class="s1">auth += '@';</span>
  <span class="s1">}</span>

  <span class="s1">var protocol = this.protocol || '',</span>
      <span class="s1">pathname = this.pathname || '',</span>
      <span class="s1">hash = this.hash || '',</span>
      <span class="s1">host = false,</span>
      <span class="s1">query = '';</span>

  <span class="s1">if (this.host) {</span>
    <span class="s1">host = auth + this.host;</span>
  <span class="s1">} else if (this.hostname) {</span>
    <span class="s1">host = auth + (this.hostname.indexOf(':') === -1 ?</span>
        <span class="s1">this.hostname :</span>
        <span class="s1">'[' + this.hostname + ']');</span>
    <span class="s1">if (this.port) {</span>
      <span class="s1">host += ':' + this.port;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (this.query &amp;&amp;</span>
      <span class="s1">isObject(this.query) &amp;&amp;</span>
      <span class="s1">Object.keys(this.query).length) {</span>
    <span class="s1">query = querystring.stringify(this.query);</span>
  <span class="s1">}</span>

  <span class="s1">var search = this.search || (query &amp;&amp; ('?' + query)) || '';</span>

  <span class="s1">if (protocol &amp;&amp; protocol.substr(-1) !== ':') protocol += ':';</span>

  <span class="s1">// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.</span>
  <span class="s1">// unless they had them to begin with.</span>
  <span class="s1">if (this.slashes ||</span>
      <span class="s1">(!protocol || slashedProtocol[protocol]) &amp;&amp; host !== false) {</span>
    <span class="s1">host = '//' + (host || '');</span>
    <span class="s1">if (pathname &amp;&amp; pathname.charAt(0) !== '/') pathname = '/' + pathname;</span>
  <span class="s1">} else if (!host) {</span>
    <span class="s1">host = '';</span>
  <span class="s1">}</span>

  <span class="s1">if (hash &amp;&amp; hash.charAt(0) !== '#') hash = '#' + hash;</span>
  <span class="s1">if (search &amp;&amp; search.charAt(0) !== '?') search = '?' + search;</span>

  <span class="s1">pathname = pathname.replace(/[?#]/g, function(match) {</span>
    <span class="s1">return encodeURIComponent(match);</span>
  <span class="s1">});</span>
  <span class="s1">search = search.replace('#', '%23');</span>

  <span class="s1">return protocol + host + pathname + search + hash;</span>
<span class="s1">};</span>

<span class="s1">function urlResolve(source, relative) {</span>
  <span class="s1">return urlParse(source, false, true).resolve(relative);</span>
<span class="s1">}</span>

<span class="s1">Url.prototype.resolve = function(relative) {</span>
  <span class="s1">return this.resolveObject(urlParse(relative, false, true)).format();</span>
<span class="s1">};</span>

<span class="s1">function urlResolveObject(source, relative) {</span>
  <span class="s1">if (!source) return relative;</span>
  <span class="s1">return urlParse(source, false, true).resolveObject(relative);</span>
<span class="s1">}</span>

<span class="s1">Url.prototype.resolveObject = function(relative) {</span>
  <span class="s1">if (isString(relative)) {</span>
    <span class="s1">var rel = new Url();</span>
    <span class="s1">rel.parse(relative, false, true);</span>
    <span class="s1">relative = rel;</span>
  <span class="s1">}</span>

  <span class="s1">var result = new Url();</span>
  <span class="s1">Object.keys(this).forEach(function(k) {</span>
    <span class="s1">result[k] = this[k];</span>
  <span class="s1">}, this);</span>

  <span class="s1">// hash is always overridden, no matter what.</span>
  <span class="s1">// even href=&quot;&quot; will remove it.</span>
  <span class="s1">result.hash = relative.hash;</span>

  <span class="s1">// if the relative url is empty, then there's nothing left to do here.</span>
  <span class="s1">if (relative.href === '') {</span>
    <span class="s1">result.href = result.format();</span>
    <span class="s1">return result;</span>
  <span class="s1">}</span>

  <span class="s1">// hrefs like //foo/bar always cut to the protocol.</span>
  <span class="s1">if (relative.slashes &amp;&amp; !relative.protocol) {</span>
    <span class="s1">// take everything except the protocol from relative</span>
    <span class="s1">Object.keys(relative).forEach(function(k) {</span>
      <span class="s1">if (k !== 'protocol')</span>
        <span class="s1">result[k] = relative[k];</span>
    <span class="s1">});</span>

    <span class="s1">//urlParse appends trailing / to urls like http://www.example.com</span>
    <span class="s1">if (slashedProtocol[result.protocol] &amp;&amp;</span>
        <span class="s1">result.hostname &amp;&amp; !result.pathname) {</span>
      <span class="s1">result.path = result.pathname = '/';</span>
    <span class="s1">}</span>

    <span class="s1">result.href = result.format();</span>
    <span class="s1">return result;</span>
  <span class="s1">}</span>

  <span class="s1">if (relative.protocol &amp;&amp; relative.protocol !== result.protocol) {</span>
    <span class="s1">// if it's a known url protocol, then changing</span>
    <span class="s1">// the protocol does weird things</span>
    <span class="s1">// first, if it's not file:, then we MUST have a host,</span>
    <span class="s1">// and if there was a path</span>
    <span class="s1">// to begin with, then we MUST have a path.</span>
    <span class="s1">// if it is file:, then the host is dropped,</span>
    <span class="s1">// because that's known to be hostless.</span>
    <span class="s1">// anything else is assumed to be absolute.</span>
    <span class="s1">if (!slashedProtocol[relative.protocol]) {</span>
      <span class="s1">Object.keys(relative).forEach(function(k) {</span>
        <span class="s1">result[k] = relative[k];</span>
      <span class="s1">});</span>
      <span class="s1">result.href = result.format();</span>
      <span class="s1">return result;</span>
    <span class="s1">}</span>

    <span class="s1">result.protocol = relative.protocol;</span>
    <span class="s1">if (!relative.host &amp;&amp; !hostlessProtocol[relative.protocol]) {</span>
      <span class="s1">var relPath = (relative.pathname || '').split('/');</span>
      <span class="s1">while (relPath.length &amp;&amp; !(relative.host = relPath.shift()));</span>
      <span class="s1">if (!relative.host) relative.host = '';</span>
      <span class="s1">if (!relative.hostname) relative.hostname = '';</span>
      <span class="s1">if (relPath[0] !== '') relPath.unshift('');</span>
      <span class="s1">if (relPath.length &lt; 2) relPath.unshift('');</span>
      <span class="s1">result.pathname = relPath.join('/');</span>
    <span class="s1">} else {</span>
      <span class="s1">result.pathname = relative.pathname;</span>
    <span class="s1">}</span>
    <span class="s1">result.search = relative.search;</span>
    <span class="s1">result.query = relative.query;</span>
    <span class="s1">result.host = relative.host || '';</span>
    <span class="s1">result.auth = relative.auth;</span>
    <span class="s1">result.hostname = relative.hostname || relative.host;</span>
    <span class="s1">result.port = relative.port;</span>
    <span class="s1">// to support http.request</span>
    <span class="s1">if (result.pathname || result.search) {</span>
      <span class="s1">var p = result.pathname || '';</span>
      <span class="s1">var s = result.search || '';</span>
      <span class="s1">result.path = p + s;</span>
    <span class="s1">}</span>
    <span class="s1">result.slashes = result.slashes || relative.slashes;</span>
    <span class="s1">result.href = result.format();</span>
    <span class="s1">return result;</span>
  <span class="s1">}</span>

  <span class="s1">var isSourceAbs = (result.pathname &amp;&amp; result.pathname.charAt(0) === '/'),</span>
      <span class="s1">isRelAbs = (</span>
          <span class="s1">relative.host ||</span>
          <span class="s1">relative.pathname &amp;&amp; relative.pathname.charAt(0) === '/'</span>
      <span class="s1">),</span>
      <span class="s1">mustEndAbs = (isRelAbs || isSourceAbs ||</span>
                    <span class="s1">(result.host &amp;&amp; relative.pathname)),</span>
      <span class="s1">removeAllDots = mustEndAbs,</span>
      <span class="s1">srcPath = result.pathname &amp;&amp; result.pathname.split('/') || [],</span>
      <span class="s1">relPath = relative.pathname &amp;&amp; relative.pathname.split('/') || [],</span>
      <span class="s1">psychotic = result.protocol &amp;&amp; !slashedProtocol[result.protocol];</span>

  <span class="s1">// if the url is a non-slashed url, then relative</span>
  <span class="s1">// links like ../.. should be able</span>
  <span class="s1">// to crawl up to the hostname, as well.  This is strange.</span>
  <span class="s1">// result.protocol has already been set by now.</span>
  <span class="s1">// Later on, put the first path part into the host field.</span>
  <span class="s1">if (psychotic) {</span>
    <span class="s1">result.hostname = '';</span>
    <span class="s1">result.port = null;</span>
    <span class="s1">if (result.host) {</span>
      <span class="s1">if (srcPath[0] === '') srcPath[0] = result.host;</span>
      <span class="s1">else srcPath.unshift(result.host);</span>
    <span class="s1">}</span>
    <span class="s1">result.host = '';</span>
    <span class="s1">if (relative.protocol) {</span>
      <span class="s1">relative.hostname = null;</span>
      <span class="s1">relative.port = null;</span>
      <span class="s1">if (relative.host) {</span>
        <span class="s1">if (relPath[0] === '') relPath[0] = relative.host;</span>
        <span class="s1">else relPath.unshift(relative.host);</span>
      <span class="s1">}</span>
      <span class="s1">relative.host = null;</span>
    <span class="s1">}</span>
    <span class="s1">mustEndAbs = mustEndAbs &amp;&amp; (relPath[0] === '' || srcPath[0] === '');</span>
  <span class="s1">}</span>

  <span class="s1">if (isRelAbs) {</span>
    <span class="s1">// it's absolute.</span>
    <span class="s1">result.host = (relative.host || relative.host === '') ?</span>
                  <span class="s1">relative.host : result.host;</span>
    <span class="s1">result.hostname = (relative.hostname || relative.hostname === '') ?</span>
                      <span class="s1">relative.hostname : result.hostname;</span>
    <span class="s1">result.search = relative.search;</span>
    <span class="s1">result.query = relative.query;</span>
    <span class="s1">srcPath = relPath;</span>
    <span class="s1">// fall through to the dot-handling below.</span>
  <span class="s1">} else if (relPath.length) {</span>
    <span class="s1">// it's relative</span>
    <span class="s1">// throw away the existing file, and take the new path instead.</span>
    <span class="s1">if (!srcPath) srcPath = [];</span>
    <span class="s1">srcPath.pop();</span>
    <span class="s1">srcPath = srcPath.concat(relPath);</span>
    <span class="s1">result.search = relative.search;</span>
    <span class="s1">result.query = relative.query;</span>
  <span class="s1">} else if (!isNullOrUndefined(relative.search)) {</span>
    <span class="s1">// just pull out the search.</span>
    <span class="s1">// like href='?foo'.</span>
    <span class="s1">// Put this after the other two cases because it simplifies the booleans</span>
    <span class="s1">if (psychotic) {</span>
      <span class="s1">result.hostname = result.host = srcPath.shift();</span>
      <span class="s1">//occationaly the auth can get stuck only in host</span>
      <span class="s1">//this especialy happens in cases like</span>
      <span class="s1">//url.resolveObject('mailto:local1@domain1', 'local2@domain2')</span>
      <span class="s1">var authInHost = result.host &amp;&amp; result.host.indexOf('@') &gt; 0 ?</span>
                       <span class="s1">result.host.split('@') : false;</span>
      <span class="s1">if (authInHost) {</span>
        <span class="s1">result.auth = authInHost.shift();</span>
        <span class="s1">result.host = result.hostname = authInHost.shift();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">result.search = relative.search;</span>
    <span class="s1">result.query = relative.query;</span>
    <span class="s1">//to support http.request</span>
    <span class="s1">if (!isNull(result.pathname) || !isNull(result.search)) {</span>
      <span class="s1">result.path = (result.pathname ? result.pathname : '') +</span>
                    <span class="s1">(result.search ? result.search : '');</span>
    <span class="s1">}</span>
    <span class="s1">result.href = result.format();</span>
    <span class="s1">return result;</span>
  <span class="s1">}</span>

  <span class="s1">if (!srcPath.length) {</span>
    <span class="s1">// no path at all.  easy.</span>
    <span class="s1">// we've already handled the other stuff above.</span>
    <span class="s1">result.pathname = null;</span>
    <span class="s1">//to support http.request</span>
    <span class="s1">if (result.search) {</span>
      <span class="s1">result.path = '/' + result.search;</span>
    <span class="s1">} else {</span>
      <span class="s1">result.path = null;</span>
    <span class="s1">}</span>
    <span class="s1">result.href = result.format();</span>
    <span class="s1">return result;</span>
  <span class="s1">}</span>

  <span class="s1">// if a url ENDs in . or .., then it must get a trailing slash.</span>
  <span class="s1">// however, if it ends in anything else non-slashy,</span>
  <span class="s1">// then it must NOT get a trailing slash.</span>
  <span class="s1">var last = srcPath.slice(-1)[0];</span>
  <span class="s1">var hasTrailingSlash = (</span>
      <span class="s1">(result.host || relative.host) &amp;&amp; (last === '.' || last === '..') ||</span>
      <span class="s1">last === '');</span>

  <span class="s1">// strip single dots, resolve double dots to parent dir</span>
  <span class="s1">// if the path tries to go above the root, `up` ends up &gt; 0</span>
  <span class="s1">var up = 0;</span>
  <span class="s1">for (var i = srcPath.length; i &gt;= 0; i--) {</span>
    <span class="s1">last = srcPath[i];</span>
    <span class="s1">if (last == '.') {</span>
      <span class="s1">srcPath.splice(i, 1);</span>
    <span class="s1">} else if (last === '..') {</span>
      <span class="s1">srcPath.splice(i, 1);</span>
      <span class="s1">up++;</span>
    <span class="s1">} else if (up) {</span>
      <span class="s1">srcPath.splice(i, 1);</span>
      <span class="s1">up--;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">// if the path is allowed to go above the root, restore leading ..s</span>
  <span class="s1">if (!mustEndAbs &amp;&amp; !removeAllDots) {</span>
    <span class="s1">for (; up--; up) {</span>
      <span class="s1">srcPath.unshift('..');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (mustEndAbs &amp;&amp; srcPath[0] !== '' &amp;&amp;</span>
      <span class="s1">(!srcPath[0] || srcPath[0].charAt(0) !== '/')) {</span>
    <span class="s1">srcPath.unshift('');</span>
  <span class="s1">}</span>

  <span class="s1">if (hasTrailingSlash &amp;&amp; (srcPath.join('/').substr(-1) !== '/')) {</span>
    <span class="s1">srcPath.push('');</span>
  <span class="s1">}</span>

  <span class="s1">var isAbsolute = srcPath[0] === '' ||</span>
      <span class="s1">(srcPath[0] &amp;&amp; srcPath[0].charAt(0) === '/');</span>

  <span class="s1">// put the host back</span>
  <span class="s1">if (psychotic) {</span>
    <span class="s1">result.hostname = result.host = isAbsolute ? '' :</span>
                                    <span class="s1">srcPath.length ? srcPath.shift() : '';</span>
    <span class="s1">//occationaly the auth can get stuck only in host</span>
    <span class="s1">//this especialy happens in cases like</span>
    <span class="s1">//url.resolveObject('mailto:local1@domain1', 'local2@domain2')</span>
    <span class="s1">var authInHost = result.host &amp;&amp; result.host.indexOf('@') &gt; 0 ?</span>
                     <span class="s1">result.host.split('@') : false;</span>
    <span class="s1">if (authInHost) {</span>
      <span class="s1">result.auth = authInHost.shift();</span>
      <span class="s1">result.host = result.hostname = authInHost.shift();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">mustEndAbs = mustEndAbs || (result.host &amp;&amp; srcPath.length);</span>

  <span class="s1">if (mustEndAbs &amp;&amp; !isAbsolute) {</span>
    <span class="s1">srcPath.unshift('');</span>
  <span class="s1">}</span>

  <span class="s1">if (!srcPath.length) {</span>
    <span class="s1">result.pathname = null;</span>
    <span class="s1">result.path = null;</span>
  <span class="s1">} else {</span>
    <span class="s1">result.pathname = srcPath.join('/');</span>
  <span class="s1">}</span>

  <span class="s1">//to support request.http</span>
  <span class="s1">if (!isNull(result.pathname) || !isNull(result.search)) {</span>
    <span class="s1">result.path = (result.pathname ? result.pathname : '') +</span>
                  <span class="s1">(result.search ? result.search : '');</span>
  <span class="s1">}</span>
  <span class="s1">result.auth = relative.auth || result.auth;</span>
  <span class="s1">result.slashes = result.slashes || relative.slashes;</span>
  <span class="s1">result.href = result.format();</span>
  <span class="s1">return result;</span>
<span class="s1">};</span>

<span class="s1">Url.prototype.parseHost = function() {</span>
  <span class="s1">var host = this.host;</span>
  <span class="s1">var port = portPattern.exec(host);</span>
  <span class="s1">if (port) {</span>
    <span class="s1">port = port[0];</span>
    <span class="s1">if (port !== ':') {</span>
      <span class="s1">this.port = port.substr(1);</span>
    <span class="s1">}</span>
    <span class="s1">host = host.substr(0, host.length - port.length);</span>
  <span class="s1">}</span>
  <span class="s1">if (host) this.hostname = host;</span>
<span class="s1">};</span>

<span class="s1">function isString(arg) {</span>
  <span class="s1">return typeof arg === &quot;string&quot;;</span>
<span class="s1">}</span>

<span class="s1">function isObject(arg) {</span>
  <span class="s1">return typeof arg === 'object' &amp;&amp; arg !== null;</span>
<span class="s1">}</span>

<span class="s1">function isNull(arg) {</span>
  <span class="s1">return arg === null;</span>
<span class="s1">}</span>
<span class="s1">function isNullOrUndefined(arg) {</span>
  <span class="s1">return  arg == null;</span>
<span class="s1">}</span>

<span class="s1">},{&quot;punycode&quot;:14,&quot;querystring&quot;:17}],27:[function(require,module,exports){</span>
<span class="s1">if (typeof Object.create === 'function') {</span>
  <span class="s1">// implementation from standard node.js 'util' module</span>
  <span class="s1">module.exports = function inherits(ctor, superCtor) {</span>
    <span class="s1">ctor.super_ = superCtor</span>
    <span class="s1">ctor.prototype = Object.create(superCtor.prototype, {</span>
      <span class="s1">constructor: {</span>
        <span class="s1">value: ctor,</span>
        <span class="s1">enumerable: false,</span>
        <span class="s1">writable: true,</span>
        <span class="s1">configurable: true</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">};</span>
<span class="s1">} else {</span>
  <span class="s1">// old school shim for old browsers</span>
  <span class="s1">module.exports = function inherits(ctor, superCtor) {</span>
    <span class="s1">ctor.super_ = superCtor</span>
    <span class="s1">var TempCtor = function () {}</span>
    <span class="s1">TempCtor.prototype = superCtor.prototype</span>
    <span class="s1">ctor.prototype = new TempCtor()</span>
    <span class="s1">ctor.prototype.constructor = ctor</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">},{}],28:[function(require,module,exports){</span>
<span class="s1">module.exports = function isBuffer(arg) {</span>
  <span class="s1">return arg &amp;&amp; typeof arg === 'object'</span>
    <span class="s1">&amp;&amp; typeof arg.copy === 'function'</span>
    <span class="s1">&amp;&amp; typeof arg.fill === 'function'</span>
    <span class="s1">&amp;&amp; typeof arg.readUInt8 === 'function';</span>
<span class="s1">}</span>
<span class="s1">},{}],29:[function(require,module,exports){</span>
<span class="s1">(function (process,global){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">var formatRegExp = /%[sdj%]/g;</span>
<span class="s1">exports.format = function(f) {</span>
  <span class="s1">if (!isString(f)) {</span>
    <span class="s1">var objects = [];</span>
    <span class="s1">for (var i = 0; i &lt; arguments.length; i++) {</span>
      <span class="s1">objects.push(inspect(arguments[i]));</span>
    <span class="s1">}</span>
    <span class="s1">return objects.join(' ');</span>
  <span class="s1">}</span>

  <span class="s1">var i = 1;</span>
  <span class="s1">var args = arguments;</span>
  <span class="s1">var len = args.length;</span>
  <span class="s1">var str = String(f).replace(formatRegExp, function(x) {</span>
    <span class="s1">if (x === '%%') return '%';</span>
    <span class="s1">if (i &gt;= len) return x;</span>
    <span class="s1">switch (x) {</span>
      <span class="s1">case '%s': return String(args[i++]);</span>
      <span class="s1">case '%d': return Number(args[i++]);</span>
      <span class="s1">case '%j':</span>
        <span class="s1">try {</span>
          <span class="s1">return JSON.stringify(args[i++]);</span>
        <span class="s1">} catch (_) {</span>
          <span class="s1">return '[Circular]';</span>
        <span class="s1">}</span>
      <span class="s1">default:</span>
        <span class="s1">return x;</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s1">for (var x = args[i]; i &lt; len; x = args[++i]) {</span>
    <span class="s1">if (isNull(x) || !isObject(x)) {</span>
      <span class="s1">str += ' ' + x;</span>
    <span class="s1">} else {</span>
      <span class="s1">str += ' ' + inspect(x);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">return str;</span>
<span class="s1">};</span>


<span class="s1">// Mark that a method should not be used.</span>
<span class="s1">// Returns a modified function which warns once by default.</span>
<span class="s1">// If --no-deprecation is set, then it is a no-op.</span>
<span class="s1">exports.deprecate = function(fn, msg) {</span>
  <span class="s1">// Allow for deprecating things in the process of starting up.</span>
  <span class="s1">if (isUndefined(global.process)) {</span>
    <span class="s1">return function() {</span>
      <span class="s1">return exports.deprecate(fn, msg).apply(this, arguments);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">if (process.noDeprecation === true) {</span>
    <span class="s1">return fn;</span>
  <span class="s1">}</span>

  <span class="s1">var warned = false;</span>
  <span class="s1">function deprecated() {</span>
    <span class="s1">if (!warned) {</span>
      <span class="s1">if (process.throwDeprecation) {</span>
        <span class="s1">throw new Error(msg);</span>
      <span class="s1">} else if (process.traceDeprecation) {</span>
        <span class="s1">console.trace(msg);</span>
      <span class="s1">} else {</span>
        <span class="s1">console.error(msg);</span>
      <span class="s1">}</span>
      <span class="s1">warned = true;</span>
    <span class="s1">}</span>
    <span class="s1">return fn.apply(this, arguments);</span>
  <span class="s1">}</span>

  <span class="s1">return deprecated;</span>
<span class="s1">};</span>


<span class="s1">var debugs = {};</span>
<span class="s1">var debugEnviron;</span>
<span class="s1">exports.debuglog = function(set) {</span>
  <span class="s1">if (isUndefined(debugEnviron))</span>
    <span class="s1">debugEnviron = process.env.NODE_DEBUG || '';</span>
  <span class="s1">set = set.toUpperCase();</span>
  <span class="s1">if (!debugs[set]) {</span>
    <span class="s1">if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {</span>
      <span class="s1">var pid = process.pid;</span>
      <span class="s1">debugs[set] = function() {</span>
        <span class="s1">var msg = exports.format.apply(exports, arguments);</span>
        <span class="s1">console.error('%s %d: %s', set, pid, msg);</span>
      <span class="s1">};</span>
    <span class="s1">} else {</span>
      <span class="s1">debugs[set] = function() {};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">return debugs[set];</span>
<span class="s1">};</span>


<span class="s1">/**</span>
 <span class="s1">* Echos the value of a value. Trys to print the value out</span>
 <span class="s1">* in the best way possible given the different types.</span>
 <span class="s1">*</span>
 <span class="s1">* @param {Object} obj The object to print out.</span>
 <span class="s1">* @param {Object} opts Optional options object that alters the output.</span>
 <span class="s1">*/</span>
<span class="s1">/* legacy: obj, showHidden, depth, colors*/</span>
<span class="s1">function inspect(obj, opts) {</span>
  <span class="s1">// default options</span>
  <span class="s1">var ctx = {</span>
    <span class="s1">seen: [],</span>
    <span class="s1">stylize: stylizeNoColor</span>
  <span class="s1">};</span>
  <span class="s1">// legacy...</span>
  <span class="s1">if (arguments.length &gt;= 3) ctx.depth = arguments[2];</span>
  <span class="s1">if (arguments.length &gt;= 4) ctx.colors = arguments[3];</span>
  <span class="s1">if (isBoolean(opts)) {</span>
    <span class="s1">// legacy...</span>
    <span class="s1">ctx.showHidden = opts;</span>
  <span class="s1">} else if (opts) {</span>
    <span class="s1">// got an &quot;options&quot; object</span>
    <span class="s1">exports._extend(ctx, opts);</span>
  <span class="s1">}</span>
  <span class="s1">// set default options</span>
  <span class="s1">if (isUndefined(ctx.showHidden)) ctx.showHidden = false;</span>
  <span class="s1">if (isUndefined(ctx.depth)) ctx.depth = 2;</span>
  <span class="s1">if (isUndefined(ctx.colors)) ctx.colors = false;</span>
  <span class="s1">if (isUndefined(ctx.customInspect)) ctx.customInspect = true;</span>
  <span class="s1">if (ctx.colors) ctx.stylize = stylizeWithColor;</span>
  <span class="s1">return formatValue(ctx, obj, ctx.depth);</span>
<span class="s1">}</span>
<span class="s1">exports.inspect = inspect;</span>


<span class="s1">// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics</span>
<span class="s1">inspect.colors = {</span>
  <span class="s1">'bold' : [1, 22],</span>
  <span class="s1">'italic' : [3, 23],</span>
  <span class="s1">'underline' : [4, 24],</span>
  <span class="s1">'inverse' : [7, 27],</span>
  <span class="s1">'white' : [37, 39],</span>
  <span class="s1">'grey' : [90, 39],</span>
  <span class="s1">'black' : [30, 39],</span>
  <span class="s1">'blue' : [34, 39],</span>
  <span class="s1">'cyan' : [36, 39],</span>
  <span class="s1">'green' : [32, 39],</span>
  <span class="s1">'magenta' : [35, 39],</span>
  <span class="s1">'red' : [31, 39],</span>
  <span class="s1">'yellow' : [33, 39]</span>
<span class="s1">};</span>

<span class="s1">// Don't use 'blue' not visible on cmd.exe</span>
<span class="s1">inspect.styles = {</span>
  <span class="s1">'special': 'cyan',</span>
  <span class="s1">'number': 'yellow',</span>
  <span class="s1">'boolean': 'yellow',</span>
  <span class="s1">'undefined': 'grey',</span>
  <span class="s1">'null': 'bold',</span>
  <span class="s1">'string': 'green',</span>
  <span class="s1">'date': 'magenta',</span>
  <span class="s1">// &quot;name&quot;: intentionally not styling</span>
  <span class="s1">'regexp': 'red'</span>
<span class="s1">};</span>


<span class="s1">function stylizeWithColor(str, styleType) {</span>
  <span class="s1">var style = inspect.styles[styleType];</span>

  <span class="s1">if (style) {</span>
    <span class="s1">return '\u001b[' + inspect.colors[style][0] + 'm' + str +</span>
           <span class="s1">'\u001b[' + inspect.colors[style][1] + 'm';</span>
  <span class="s1">} else {</span>
    <span class="s1">return str;</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s1">function stylizeNoColor(str, styleType) {</span>
  <span class="s1">return str;</span>
<span class="s1">}</span>


<span class="s1">function arrayToHash(array) {</span>
  <span class="s1">var hash = {};</span>

  <span class="s1">array.forEach(function(val, idx) {</span>
    <span class="s1">hash[val] = true;</span>
  <span class="s1">});</span>

  <span class="s1">return hash;</span>
<span class="s1">}</span>


<span class="s1">function formatValue(ctx, value, recurseTimes) {</span>
  <span class="s1">// Provide a hook for user-specified inspect functions.</span>
  <span class="s1">// Check that value is an object with an inspect function on it</span>
  <span class="s1">if (ctx.customInspect &amp;&amp;</span>
      <span class="s1">value &amp;&amp;</span>
      <span class="s1">isFunction(value.inspect) &amp;&amp;</span>
      <span class="s1">// Filter out the util module, it's inspect function is special</span>
      <span class="s1">value.inspect !== exports.inspect &amp;&amp;</span>
      <span class="s1">// Also filter out any prototype objects using the circular check.</span>
      <span class="s1">!(value.constructor &amp;&amp; value.constructor.prototype === value)) {</span>
    <span class="s1">var ret = value.inspect(recurseTimes, ctx);</span>
    <span class="s1">if (!isString(ret)) {</span>
      <span class="s1">ret = formatValue(ctx, ret, recurseTimes);</span>
    <span class="s1">}</span>
    <span class="s1">return ret;</span>
  <span class="s1">}</span>

  <span class="s1">// Primitive types cannot have properties</span>
  <span class="s1">var primitive = formatPrimitive(ctx, value);</span>
  <span class="s1">if (primitive) {</span>
    <span class="s1">return primitive;</span>
  <span class="s1">}</span>

  <span class="s1">// Look up the keys of the object.</span>
  <span class="s1">var keys = Object.keys(value);</span>
  <span class="s1">var visibleKeys = arrayToHash(keys);</span>

  <span class="s1">if (ctx.showHidden) {</span>
    <span class="s1">keys = Object.getOwnPropertyNames(value);</span>
  <span class="s1">}</span>

  <span class="s1">// IE doesn't make error fields non-enumerable</span>
  <span class="s1">// http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx</span>
  <span class="s1">if (isError(value)</span>
      <span class="s1">&amp;&amp; (keys.indexOf('message') &gt;= 0 || keys.indexOf('description') &gt;= 0)) {</span>
    <span class="s1">return formatError(value);</span>
  <span class="s1">}</span>

  <span class="s1">// Some type of object without properties can be shortcutted.</span>
  <span class="s1">if (keys.length === 0) {</span>
    <span class="s1">if (isFunction(value)) {</span>
      <span class="s1">var name = value.name ? ': ' + value.name : '';</span>
      <span class="s1">return ctx.stylize('[Function' + name + ']', 'special');</span>
    <span class="s1">}</span>
    <span class="s1">if (isRegExp(value)) {</span>
      <span class="s1">return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');</span>
    <span class="s1">}</span>
    <span class="s1">if (isDate(value)) {</span>
      <span class="s1">return ctx.stylize(Date.prototype.toString.call(value), 'date');</span>
    <span class="s1">}</span>
    <span class="s1">if (isError(value)) {</span>
      <span class="s1">return formatError(value);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">var base = '', array = false, braces = ['{', '}'];</span>

  <span class="s1">// Make Array say that they are Array</span>
  <span class="s1">if (isArray(value)) {</span>
    <span class="s1">array = true;</span>
    <span class="s1">braces = ['[', ']'];</span>
  <span class="s1">}</span>

  <span class="s1">// Make functions say that they are functions</span>
  <span class="s1">if (isFunction(value)) {</span>
    <span class="s1">var n = value.name ? ': ' + value.name : '';</span>
    <span class="s1">base = ' [Function' + n + ']';</span>
  <span class="s1">}</span>

  <span class="s1">// Make RegExps say that they are RegExps</span>
  <span class="s1">if (isRegExp(value)) {</span>
    <span class="s1">base = ' ' + RegExp.prototype.toString.call(value);</span>
  <span class="s1">}</span>

  <span class="s1">// Make dates with properties first say the date</span>
  <span class="s1">if (isDate(value)) {</span>
    <span class="s1">base = ' ' + Date.prototype.toUTCString.call(value);</span>
  <span class="s1">}</span>

  <span class="s1">// Make error with message first say the error</span>
  <span class="s1">if (isError(value)) {</span>
    <span class="s1">base = ' ' + formatError(value);</span>
  <span class="s1">}</span>

  <span class="s1">if (keys.length === 0 &amp;&amp; (!array || value.length == 0)) {</span>
    <span class="s1">return braces[0] + base + braces[1];</span>
  <span class="s1">}</span>

  <span class="s1">if (recurseTimes &lt; 0) {</span>
    <span class="s1">if (isRegExp(value)) {</span>
      <span class="s1">return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');</span>
    <span class="s1">} else {</span>
      <span class="s1">return ctx.stylize('[Object]', 'special');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">ctx.seen.push(value);</span>

  <span class="s1">var output;</span>
  <span class="s1">if (array) {</span>
    <span class="s1">output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);</span>
  <span class="s1">} else {</span>
    <span class="s1">output = keys.map(function(key) {</span>
      <span class="s1">return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s1">ctx.seen.pop();</span>

  <span class="s1">return reduceToSingleString(output, base, braces);</span>
<span class="s1">}</span>


<span class="s1">function formatPrimitive(ctx, value) {</span>
  <span class="s1">if (isUndefined(value))</span>
    <span class="s1">return ctx.stylize('undefined', 'undefined');</span>
  <span class="s1">if (isString(value)) {</span>
    <span class="s1">var simple = '\'' + JSON.stringify(value).replace(/^&quot;|&quot;$/g, '')</span>
                                             <span class="s1">.replace(/'/g, &quot;\\'&quot;)</span>
                                             <span class="s1">.replace(/\\&quot;/g, '&quot;') + '\'';</span>
    <span class="s1">return ctx.stylize(simple, 'string');</span>
  <span class="s1">}</span>
  <span class="s1">if (isNumber(value))</span>
    <span class="s1">return ctx.stylize('' + value, 'number');</span>
  <span class="s1">if (isBoolean(value))</span>
    <span class="s1">return ctx.stylize('' + value, 'boolean');</span>
  <span class="s1">// For some reason typeof null is &quot;object&quot;, so special case here.</span>
  <span class="s1">if (isNull(value))</span>
    <span class="s1">return ctx.stylize('null', 'null');</span>
<span class="s1">}</span>


<span class="s1">function formatError(value) {</span>
  <span class="s1">return '[' + Error.prototype.toString.call(value) + ']';</span>
<span class="s1">}</span>


<span class="s1">function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {</span>
  <span class="s1">var output = [];</span>
  <span class="s1">for (var i = 0, l = value.length; i &lt; l; ++i) {</span>
    <span class="s1">if (hasOwnProperty(value, String(i))) {</span>
      <span class="s1">output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,</span>
          <span class="s1">String(i), true));</span>
    <span class="s1">} else {</span>
      <span class="s1">output.push('');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">keys.forEach(function(key) {</span>
    <span class="s1">if (!key.match(/^\d+$/)) {</span>
      <span class="s1">output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,</span>
          <span class="s1">key, true));</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s1">return output;</span>
<span class="s1">}</span>


<span class="s1">function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {</span>
  <span class="s1">var name, str, desc;</span>
  <span class="s1">desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };</span>
  <span class="s1">if (desc.get) {</span>
    <span class="s1">if (desc.set) {</span>
      <span class="s1">str = ctx.stylize('[Getter/Setter]', 'special');</span>
    <span class="s1">} else {</span>
      <span class="s1">str = ctx.stylize('[Getter]', 'special');</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">if (desc.set) {</span>
      <span class="s1">str = ctx.stylize('[Setter]', 'special');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">if (!hasOwnProperty(visibleKeys, key)) {</span>
    <span class="s1">name = '[' + key + ']';</span>
  <span class="s1">}</span>
  <span class="s1">if (!str) {</span>
    <span class="s1">if (ctx.seen.indexOf(desc.value) &lt; 0) {</span>
      <span class="s1">if (isNull(recurseTimes)) {</span>
        <span class="s1">str = formatValue(ctx, desc.value, null);</span>
      <span class="s1">} else {</span>
        <span class="s1">str = formatValue(ctx, desc.value, recurseTimes - 1);</span>
      <span class="s1">}</span>
      <span class="s1">if (str.indexOf('\n') &gt; -1) {</span>
        <span class="s1">if (array) {</span>
          <span class="s1">str = str.split('\n').map(function(line) {</span>
            <span class="s1">return '  ' + line;</span>
          <span class="s1">}).join('\n').substr(2);</span>
        <span class="s1">} else {</span>
          <span class="s1">str = '\n' + str.split('\n').map(function(line) {</span>
            <span class="s1">return '   ' + line;</span>
          <span class="s1">}).join('\n');</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} else {</span>
      <span class="s1">str = ctx.stylize('[Circular]', 'special');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">if (isUndefined(name)) {</span>
    <span class="s1">if (array &amp;&amp; key.match(/^\d+$/)) {</span>
      <span class="s1">return str;</span>
    <span class="s1">}</span>
    <span class="s1">name = JSON.stringify('' + key);</span>
    <span class="s1">if (name.match(/^&quot;([a-zA-Z_][a-zA-Z_0-9]*)&quot;$/)) {</span>
      <span class="s1">name = name.substr(1, name.length - 2);</span>
      <span class="s1">name = ctx.stylize(name, 'name');</span>
    <span class="s1">} else {</span>
      <span class="s1">name = name.replace(/'/g, &quot;\\'&quot;)</span>
                 <span class="s1">.replace(/\\&quot;/g, '&quot;')</span>
                 <span class="s1">.replace(/(^&quot;|&quot;$)/g, &quot;'&quot;);</span>
      <span class="s1">name = ctx.stylize(name, 'string');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return name + ': ' + str;</span>
<span class="s1">}</span>


<span class="s1">function reduceToSingleString(output, base, braces) {</span>
  <span class="s1">var numLinesEst = 0;</span>
  <span class="s1">var length = output.reduce(function(prev, cur) {</span>
    <span class="s1">numLinesEst++;</span>
    <span class="s1">if (cur.indexOf('\n') &gt;= 0) numLinesEst++;</span>
    <span class="s1">return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;</span>
  <span class="s1">}, 0);</span>

  <span class="s1">if (length &gt; 60) {</span>
    <span class="s1">return braces[0] +</span>
           <span class="s1">(base === '' ? '' : base + '\n ') +</span>
           <span class="s1">' ' +</span>
           <span class="s1">output.join(',\n  ') +</span>
           <span class="s1">' ' +</span>
           <span class="s1">braces[1];</span>
  <span class="s1">}</span>

  <span class="s1">return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];</span>
<span class="s1">}</span>


<span class="s1">// NOTE: These type checking functions intentionally don't use `instanceof`</span>
<span class="s1">// because it is fragile and can be easily faked with `Object.create()`.</span>
<span class="s1">function isArray(ar) {</span>
  <span class="s1">return Array.isArray(ar);</span>
<span class="s1">}</span>
<span class="s1">exports.isArray = isArray;</span>

<span class="s1">function isBoolean(arg) {</span>
  <span class="s1">return typeof arg === 'boolean';</span>
<span class="s1">}</span>
<span class="s1">exports.isBoolean = isBoolean;</span>

<span class="s1">function isNull(arg) {</span>
  <span class="s1">return arg === null;</span>
<span class="s1">}</span>
<span class="s1">exports.isNull = isNull;</span>

<span class="s1">function isNullOrUndefined(arg) {</span>
  <span class="s1">return arg == null;</span>
<span class="s1">}</span>
<span class="s1">exports.isNullOrUndefined = isNullOrUndefined;</span>

<span class="s1">function isNumber(arg) {</span>
  <span class="s1">return typeof arg === 'number';</span>
<span class="s1">}</span>
<span class="s1">exports.isNumber = isNumber;</span>

<span class="s1">function isString(arg) {</span>
  <span class="s1">return typeof arg === 'string';</span>
<span class="s1">}</span>
<span class="s1">exports.isString = isString;</span>

<span class="s1">function isSymbol(arg) {</span>
  <span class="s1">return typeof arg === 'symbol';</span>
<span class="s1">}</span>
<span class="s1">exports.isSymbol = isSymbol;</span>

<span class="s1">function isUndefined(arg) {</span>
  <span class="s1">return arg === void 0;</span>
<span class="s1">}</span>
<span class="s1">exports.isUndefined = isUndefined;</span>

<span class="s1">function isRegExp(re) {</span>
  <span class="s1">return isObject(re) &amp;&amp; objectToString(re) === '[object RegExp]';</span>
<span class="s1">}</span>
<span class="s1">exports.isRegExp = isRegExp;</span>

<span class="s1">function isObject(arg) {</span>
  <span class="s1">return typeof arg === 'object' &amp;&amp; arg !== null;</span>
<span class="s1">}</span>
<span class="s1">exports.isObject = isObject;</span>

<span class="s1">function isDate(d) {</span>
  <span class="s1">return isObject(d) &amp;&amp; objectToString(d) === '[object Date]';</span>
<span class="s1">}</span>
<span class="s1">exports.isDate = isDate;</span>

<span class="s1">function isError(e) {</span>
  <span class="s1">return isObject(e) &amp;&amp;</span>
      <span class="s1">(objectToString(e) === '[object Error]' || e instanceof Error);</span>
<span class="s1">}</span>
<span class="s1">exports.isError = isError;</span>

<span class="s1">function isFunction(arg) {</span>
  <span class="s1">return typeof arg === 'function';</span>
<span class="s1">}</span>
<span class="s1">exports.isFunction = isFunction;</span>

<span class="s1">function isPrimitive(arg) {</span>
  <span class="s1">return arg === null ||</span>
         <span class="s1">typeof arg === 'boolean' ||</span>
         <span class="s1">typeof arg === 'number' ||</span>
         <span class="s1">typeof arg === 'string' ||</span>
         <span class="s1">typeof arg === 'symbol' ||  // ES6 symbol</span>
         <span class="s1">typeof arg === 'undefined';</span>
<span class="s1">}</span>
<span class="s1">exports.isPrimitive = isPrimitive;</span>

<span class="s1">exports.isBuffer = require('./support/isBuffer');</span>

<span class="s1">function objectToString(o) {</span>
  <span class="s1">return Object.prototype.toString.call(o);</span>
<span class="s1">}</span>


<span class="s1">function pad(n) {</span>
  <span class="s1">return n &lt; 10 ? '0' + n.toString(10) : n.toString(10);</span>
<span class="s1">}</span>


<span class="s1">var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',</span>
              <span class="s1">'Oct', 'Nov', 'Dec'];</span>

<span class="s1">// 26 Feb 16:19:34</span>
<span class="s1">function timestamp() {</span>
  <span class="s1">var d = new Date();</span>
  <span class="s1">var time = [pad(d.getHours()),</span>
              <span class="s1">pad(d.getMinutes()),</span>
              <span class="s1">pad(d.getSeconds())].join(':');</span>
  <span class="s1">return [d.getDate(), months[d.getMonth()], time].join(' ');</span>
<span class="s1">}</span>


<span class="s1">// log is just a thin wrapper to console.log that prepends a timestamp</span>
<span class="s1">exports.log = function() {</span>
  <span class="s1">console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));</span>
<span class="s1">};</span>


<span class="s1">/**</span>
 <span class="s1">* Inherit the prototype methods from one constructor into another.</span>
 <span class="s1">*</span>
 <span class="s1">* The Function.prototype.inherits from lang.js rewritten as a standalone</span>
 <span class="s1">* function (not on Function.prototype). NOTE: If this file is to be loaded</span>
 <span class="s1">* during bootstrapping this function needs to be rewritten using some native</span>
 <span class="s1">* functions as prototype setup using normal JavaScript does not work as</span>
 <span class="s1">* expected during bootstrapping (see mirror.js in r114903).</span>
 <span class="s1">*</span>
 <span class="s1">* @param {function} ctor Constructor function which needs to inherit the</span>
 <span class="s1">*     prototype.</span>
 <span class="s1">* @param {function} superCtor Constructor function to inherit prototype from.</span>
 <span class="s1">*/</span>
<span class="s1">exports.inherits = require('inherits');</span>

<span class="s1">exports._extend = function(origin, add) {</span>
  <span class="s1">// Don't do anything if add isn't an object</span>
  <span class="s1">if (!add || !isObject(add)) return origin;</span>

  <span class="s1">var keys = Object.keys(add);</span>
  <span class="s1">var i = keys.length;</span>
  <span class="s1">while (i--) {</span>
    <span class="s1">origin[keys[i]] = add[keys[i]];</span>
  <span class="s1">}</span>
  <span class="s1">return origin;</span>
<span class="s1">};</span>

<span class="s1">function hasOwnProperty(obj, prop) {</span>
  <span class="s1">return Object.prototype.hasOwnProperty.call(obj, prop);</span>
<span class="s1">}</span>

<span class="s1">}).call(this,require(&quot;g5I+bs&quot;),typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})</span>
<span class="s1">},{&quot;./support/isBuffer&quot;:28,&quot;g5I+bs&quot;:13,&quot;inherits&quot;:27}],30:[function(require,module,exports){</span>
<span class="s1">var http = require('http');</span>
<span class="s1">var Stream = require('stream');</span>
<span class="s1">var encode = typeof encodeURIComponent !== 'undefined'</span>
    <span class="s1">? encodeURIComponent : escape</span>
<span class="s1">;</span>

<span class="s1">module.exports = function (opts) {</span>
    <span class="s1">if (typeof opts === 'string') {</span>
        <span class="s1">opts = { path : opts };</span>
    <span class="s1">}</span>
    <span class="s1">if (!opts) opts = {};</span>
    <span class="s1">if (!opts.id) {</span>
        <span class="s1">opts.id = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);</span>
    <span class="s1">}</span>
    
    <span class="s1">var stream = new Stream;</span>
    <span class="s1">stream.writable = true;</span>
    <span class="s1">stream.order = 0;</span>
    
    <span class="s1">stream.write = function (msg) {</span>
        <span class="s1">if (stream.ended) return;</span>
        <span class="s1">var data = 'order=' + stream.order</span>
            <span class="s1">+ '&amp;data=' + encode(msg)</span>
            <span class="s1">+ '&amp;id=' + encode(opts.id)</span>
        <span class="s1">;</span>
        <span class="s1">stream.order ++;</span>
        <span class="s1">send(data);</span>
    <span class="s1">};</span>
    
    <span class="s1">stream.destroy = function () {</span>
        <span class="s1">stream.ended = true;</span>
        <span class="s1">stream.emit('close');</span>
    <span class="s1">};</span>
    
    <span class="s1">stream.end = function (msg) {</span>
        <span class="s1">if (stream.ended) return;</span>
        
        <span class="s1">var data = 'order=' + stream.order</span>
            <span class="s1">+ '&amp;id=' + encode(opts.id)</span>
            <span class="s1">+ '&amp;end=true'</span>
        <span class="s1">;</span>
        <span class="s1">if (msg !== undefined) data += '&amp;data=' + encode(msg);</span>
        <span class="s1">stream.order ++;</span>
        <span class="s1">send(data);</span>
        <span class="s1">stream.ended = true;</span>
        <span class="s1">stream.emit('close');</span>
    <span class="s1">};</span>
    
    <span class="s1">function send (data) {</span>
        <span class="s1">var params = {</span>
            <span class="s1">method : 'POST',</span>
            <span class="s1">host : opts.host || window.location.hostname,</span>
            <span class="s1">port : opts.port || window.location.port,</span>
            <span class="s1">path : opts.path || '/',</span>
            <span class="s1">headers : {</span>
                <span class="s1">'content-type' : 'application/x-www-form-urlencoded'</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s1">var req = http.request(params);</span>
        <span class="s1">req.end(data);</span>
    <span class="s1">}</span>
    
    <span class="s1">return stream</span>
<span class="s1">};</span>

<span class="s1">},{&quot;http&quot;:6,&quot;stream&quot;:19}]},{},[1])</span><span class="s0">&lt;/script&gt;&lt;script&gt;</span><span class="s1">(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=&quot;function&quot;==typeof require&amp;</span><span class="s4">&amp;require;</span><span class="s1">if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error(&quot;Cannot find module '&quot;+i+&quot;'&quot;);throw a.code=&quot;MODULE_NOT_FOUND&quot;,a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=&quot;function&quot;==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">// modified from https://github.com/es-shims/es6-shim</span>
<span class="s1">var keys = require('object-keys');</span>
<span class="s1">var hasSymbols = require('has-symbols/shams')();</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var toObject = Object;</span>
<span class="s1">var $push = callBound('Array.prototype.push');</span>
<span class="s1">var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');</span>
<span class="s1">var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;</span>

<span class="s1">// eslint-disable-next-line no-unused-vars</span>
<span class="s1">module.exports = function assign(target, source1) {</span>
	<span class="s1">if (target == null) { throw new TypeError('target must be an object'); }</span>
	<span class="s1">var objTarget = toObject(target);</span>
	<span class="s1">var s, source, i, props, syms, value, key;</span>
	<span class="s1">for (s = 1; s &lt; arguments.length; ++s) {</span>
		<span class="s1">source = toObject(arguments[s]);</span>
		<span class="s1">props = keys(source);</span>
		<span class="s1">var getSymbols = hasSymbols &amp;&amp; (Object.getOwnPropertySymbols || originalGetSymbols);</span>
		<span class="s1">if (getSymbols) {</span>
			<span class="s1">syms = getSymbols(source);</span>
			<span class="s1">for (i = 0; i &lt; syms.length; ++i) {</span>
				<span class="s1">key = syms[i];</span>
				<span class="s1">if ($propIsEnumerable(source, key)) {</span>
					<span class="s1">$push(props, key);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">for (i = 0; i &lt; props.length; ++i) {</span>
			<span class="s1">key = props[i];</span>
			<span class="s1">value = source[key];</span>
			<span class="s1">if ($propIsEnumerable(source, key)) {</span>
				<span class="s1">objTarget[key] = value;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return objTarget;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;has-symbols/shams&quot;:43,&quot;object-keys&quot;:71}],2:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var defineProperties = require('define-properties');</span>
<span class="s1">var callBind = require('call-bind');</span>

<span class="s1">var implementation = require('./implementation');</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>
<span class="s1">var shim = require('./shim');</span>

<span class="s1">var polyfill = callBind.apply(getPolyfill());</span>
<span class="s1">// eslint-disable-next-line no-unused-vars</span>
<span class="s1">var bound = function assign(target, source1) {</span>
	<span class="s1">return polyfill(Object, arguments);</span>
<span class="s1">};</span>

<span class="s1">defineProperties(bound, {</span>
	<span class="s1">getPolyfill: getPolyfill,</span>
	<span class="s1">implementation: implementation,</span>
	<span class="s1">shim: shim</span>
<span class="s1">});</span>

<span class="s1">module.exports = bound;</span>

<span class="s1">},{&quot;./implementation&quot;:1,&quot;./polyfill&quot;:116,&quot;./shim&quot;:117,&quot;call-bind&quot;:12,&quot;define-properties&quot;:16}],3:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var IsCallable = require('es-abstract/2021/IsCallable');</span>
<span class="s1">var ToObject = require('es-abstract/2021/ToObject');</span>
<span class="s1">var ToUint32 = require('es-abstract/2021/ToUint32');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var isString = require('is-string');</span>

<span class="s1">// Check failure of by-index access of string characters (IE &lt; 9) and failure of `0 in boxedString` (Rhino)</span>
<span class="s1">var boxedString = Object('a');</span>
<span class="s1">var splitString = boxedString[0] !== 'a' || !(0 in boxedString);</span>

<span class="s1">var $split = callBound('String.prototype.split');</span>

<span class="s1">module.exports = function every(callbackfn) {</span>
	<span class="s1">var O = ToObject(this);</span>
	<span class="s1">var self = splitString &amp;&amp; isString(O) ? $split(O, '') : O;</span>
	<span class="s1">var len = ToUint32(self.length);</span>
	<span class="s1">var T;</span>
	<span class="s1">if (arguments.length &gt; 1) {</span>
		<span class="s1">T = arguments[1];</span>
	<span class="s1">}</span>

	<span class="s1">// If no callback function or if callback is not a callable function</span>
	<span class="s1">if (!IsCallable(callbackfn)) {</span>
		<span class="s1">throw new TypeError('Array.prototype.every callback must be a function');</span>
	<span class="s1">}</span>

	<span class="s1">for (var i = 0; i &lt; len; i++) {</span>
		<span class="s1">if (i in self &amp;&amp; !(typeof T === 'undefined' ? callbackfn(self[i], i, O) : callbackfn.call(T, self[i], i, O))) {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return true;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;es-abstract/2021/IsCallable&quot;:18,&quot;es-abstract/2021/ToObject&quot;:21,&quot;es-abstract/2021/ToUint32&quot;:24,&quot;is-string&quot;:57}],4:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var define = require('define-properties');</span>
<span class="s1">var RequireObjectCoercible = require('es-abstract/2021/RequireObjectCoercible');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>

<span class="s1">var implementation = require('./implementation');</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>
<span class="s1">var polyfill = getPolyfill();</span>
<span class="s1">var shim = require('./shim');</span>

<span class="s1">var $slice = callBound('Array.prototype.slice');</span>

<span class="s1">// eslint-disable-next-line no-unused-vars</span>
<span class="s1">var boundEveryShim = function every(array, callbackfn) {</span>
	<span class="s1">RequireObjectCoercible(array);</span>
	<span class="s1">return polyfill.apply(array, $slice(arguments, 1));</span>
<span class="s1">};</span>
<span class="s1">define(boundEveryShim, {</span>
	<span class="s1">getPolyfill: getPolyfill,</span>
	<span class="s1">implementation: implementation,</span>
	<span class="s1">shim: shim</span>
<span class="s1">});</span>

<span class="s1">module.exports = boundEveryShim;</span>

<span class="s1">},{&quot;./implementation&quot;:3,&quot;./polyfill&quot;:5,&quot;./shim&quot;:6,&quot;call-bind/callBound&quot;:11,&quot;define-properties&quot;:16,&quot;es-abstract/2021/RequireObjectCoercible&quot;:19}],5:[function(require,module,exports){</span>
<span class="s1">var implementation = require('./implementation');</span>

<span class="s1">module.exports = function getPolyfill() {</span>
	<span class="s1">if (typeof Array.prototype.every === 'function') {</span>
		<span class="s1">var hasPrimitiveContextInStrict = [1].every(function () {</span>
			<span class="s1">'use strict';</span>

			<span class="s1">return typeof this === 'string' &amp;&amp; this === 'x';</span>
		<span class="s1">}, 'x');</span>
		<span class="s1">if (hasPrimitiveContextInStrict) {</span>
			<span class="s1">return Array.prototype.every;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return implementation;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./implementation&quot;:3}],6:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var define = require('define-properties');</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>

<span class="s1">module.exports = function shimArrayPrototypeEvery() {</span>
	<span class="s1">var polyfill = getPolyfill();</span>
	<span class="s1">define(</span>
		<span class="s1">Array.prototype,</span>
		<span class="s1">{ every: polyfill },</span>
		<span class="s1">{ every: function () { return Array.prototype.every !== polyfill; } }</span>
	<span class="s1">);</span>
	<span class="s1">return polyfill;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./polyfill&quot;:5,&quot;define-properties&quot;:16}],7:[function(require,module,exports){</span>
<span class="s1">(function (global){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">var possibleNames = [</span>
	<span class="s1">'BigInt64Array',</span>
	<span class="s1">'BigUint64Array',</span>
	<span class="s1">'Float32Array',</span>
	<span class="s1">'Float64Array',</span>
	<span class="s1">'Int16Array',</span>
	<span class="s1">'Int32Array',</span>
	<span class="s1">'Int8Array',</span>
	<span class="s1">'Uint16Array',</span>
	<span class="s1">'Uint32Array',</span>
	<span class="s1">'Uint8Array',</span>
	<span class="s1">'Uint8ClampedArray'</span>
<span class="s1">];</span>

<span class="s1">var g = typeof globalThis === 'undefined' ? global : globalThis;</span>

<span class="s1">module.exports = function availableTypedArrays() {</span>
	<span class="s1">var out = [];</span>
	<span class="s1">for (var i = 0; i &lt; possibleNames.length; i++) {</span>
		<span class="s1">if (typeof g[possibleNames[i]] === 'function') {</span>
			<span class="s1">out[out.length] = possibleNames[i];</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return out;</span>
<span class="s1">};</span>

<span class="s1">}).call(this)}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})</span>

<span class="s1">},{}],8:[function(require,module,exports){</span>
<span class="s1">'use strict'</span>

<span class="s1">exports.byteLength = byteLength</span>
<span class="s1">exports.toByteArray = toByteArray</span>
<span class="s1">exports.fromByteArray = fromByteArray</span>

<span class="s1">var lookup = []</span>
<span class="s1">var revLookup = []</span>
<span class="s1">var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array</span>

<span class="s1">var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>
<span class="s1">for (var i = 0, len = code.length; i &lt; len; ++i) {</span>
  <span class="s1">lookup[i] = code[i]</span>
  <span class="s1">revLookup[code.charCodeAt(i)] = i</span>
<span class="s1">}</span>

<span class="s1">// Support decoding URL-safe base64 strings, as Node.js does.</span>
<span class="s1">// See: https://en.wikipedia.org/wiki/Base64#URL_applications</span>
<span class="s1">revLookup['-'.charCodeAt(0)] = 62</span>
<span class="s1">revLookup['_'.charCodeAt(0)] = 63</span>

<span class="s1">function getLens (b64) {</span>
  <span class="s1">var len = b64.length</span>

  <span class="s1">if (len % 4 &gt; 0) {</span>
    <span class="s1">throw new Error('Invalid string. Length must be a multiple of 4')</span>
  <span class="s1">}</span>

  <span class="s1">// Trim off extra bytes after placeholder bytes are found</span>
  <span class="s1">// See: https://github.com/beatgammit/base64-js/issues/42</span>
  <span class="s1">var validLen = b64.indexOf('=')</span>
  <span class="s1">if (validLen === -1) validLen = len</span>

  <span class="s1">var placeHoldersLen = validLen === len</span>
    <span class="s1">? 0</span>
    <span class="s1">: 4 - (validLen % 4)</span>

  <span class="s1">return [validLen, placeHoldersLen]</span>
<span class="s1">}</span>

<span class="s1">// base64 is 4/3 + up to two characters of the original data</span>
<span class="s1">function byteLength (b64) {</span>
  <span class="s1">var lens = getLens(b64)</span>
  <span class="s1">var validLen = lens[0]</span>
  <span class="s1">var placeHoldersLen = lens[1]</span>
  <span class="s1">return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen</span>
<span class="s1">}</span>

<span class="s1">function _byteLength (b64, validLen, placeHoldersLen) {</span>
  <span class="s1">return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen</span>
<span class="s1">}</span>

<span class="s1">function toByteArray (b64) {</span>
  <span class="s1">var tmp</span>
  <span class="s1">var lens = getLens(b64)</span>
  <span class="s1">var validLen = lens[0]</span>
  <span class="s1">var placeHoldersLen = lens[1]</span>

  <span class="s1">var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))</span>

  <span class="s1">var curByte = 0</span>

  <span class="s1">// if there are placeholders, only get up to the last complete 4 chars</span>
  <span class="s1">var len = placeHoldersLen &gt; 0</span>
    <span class="s1">? validLen - 4</span>
    <span class="s1">: validLen</span>

  <span class="s1">var i</span>
  <span class="s1">for (i = 0; i &lt; len; i += 4) {</span>
    <span class="s1">tmp =</span>
      <span class="s1">(revLookup[b64.charCodeAt(i)] &lt;&lt; 18) |</span>
      <span class="s1">(revLookup[b64.charCodeAt(i + 1)] &lt;&lt; 12) |</span>
      <span class="s1">(revLookup[b64.charCodeAt(i + 2)] &lt;&lt; 6) |</span>
      <span class="s1">revLookup[b64.charCodeAt(i + 3)]</span>
    <span class="s1">arr[curByte++] = (tmp &gt;&gt; 16) &amp; 0xFF</span>
    <span class="s1">arr[curByte++] = (tmp &gt;&gt; 8) &amp; 0xFF</span>
    <span class="s1">arr[curByte++] = tmp &amp; 0xFF</span>
  <span class="s1">}</span>

  <span class="s1">if (placeHoldersLen === 2) {</span>
    <span class="s1">tmp =</span>
      <span class="s1">(revLookup[b64.charCodeAt(i)] &lt;&lt; 2) |</span>
      <span class="s1">(revLookup[b64.charCodeAt(i + 1)] &gt;&gt; 4)</span>
    <span class="s1">arr[curByte++] = tmp &amp; 0xFF</span>
  <span class="s1">}</span>

  <span class="s1">if (placeHoldersLen === 1) {</span>
    <span class="s1">tmp =</span>
      <span class="s1">(revLookup[b64.charCodeAt(i)] &lt;&lt; 10) |</span>
      <span class="s1">(revLookup[b64.charCodeAt(i + 1)] &lt;&lt; 4) |</span>
      <span class="s1">(revLookup[b64.charCodeAt(i + 2)] &gt;&gt; 2)</span>
    <span class="s1">arr[curByte++] = (tmp &gt;&gt; 8) &amp; 0xFF</span>
    <span class="s1">arr[curByte++] = tmp &amp; 0xFF</span>
  <span class="s1">}</span>

  <span class="s1">return arr</span>
<span class="s1">}</span>

<span class="s1">function tripletToBase64 (num) {</span>
  <span class="s1">return lookup[num &gt;&gt; 18 &amp; 0x3F] +</span>
    <span class="s1">lookup[num &gt;&gt; 12 &amp; 0x3F] +</span>
    <span class="s1">lookup[num &gt;&gt; 6 &amp; 0x3F] +</span>
    <span class="s1">lookup[num &amp; 0x3F]</span>
<span class="s1">}</span>

<span class="s1">function encodeChunk (uint8, start, end) {</span>
  <span class="s1">var tmp</span>
  <span class="s1">var output = []</span>
  <span class="s1">for (var i = start; i &lt; end; i += 3) {</span>
    <span class="s1">tmp =</span>
      <span class="s1">((uint8[i] &lt;&lt; 16) &amp; 0xFF0000) +</span>
      <span class="s1">((uint8[i + 1] &lt;&lt; 8) &amp; 0xFF00) +</span>
      <span class="s1">(uint8[i + 2] &amp; 0xFF)</span>
    <span class="s1">output.push(tripletToBase64(tmp))</span>
  <span class="s1">}</span>
  <span class="s1">return output.join('')</span>
<span class="s1">}</span>

<span class="s1">function fromByteArray (uint8) {</span>
  <span class="s1">var tmp</span>
  <span class="s1">var len = uint8.length</span>
  <span class="s1">var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes</span>
  <span class="s1">var parts = []</span>
  <span class="s1">var maxChunkLength = 16383 // must be multiple of 3</span>

  <span class="s1">// go through the array every three bytes, we'll deal with trailing stuff later</span>
  <span class="s1">for (var i = 0, len2 = len - extraBytes; i &lt; len2; i += maxChunkLength) {</span>
    <span class="s1">parts.push(encodeChunk(uint8, i, (i + maxChunkLength) &gt; len2 ? len2 : (i + maxChunkLength)))</span>
  <span class="s1">}</span>

  <span class="s1">// pad the end with zeros, but make sure to not forget the extra bytes</span>
  <span class="s1">if (extraBytes === 1) {</span>
    <span class="s1">tmp = uint8[len - 1]</span>
    <span class="s1">parts.push(</span>
      <span class="s1">lookup[tmp &gt;&gt; 2] +</span>
      <span class="s1">lookup[(tmp &lt;&lt; 4) &amp; 0x3F] +</span>
      <span class="s1">'=='</span>
    <span class="s1">)</span>
  <span class="s1">} else if (extraBytes === 2) {</span>
    <span class="s1">tmp = (uint8[len - 2] &lt;&lt; 8) + uint8[len - 1]</span>
    <span class="s1">parts.push(</span>
      <span class="s1">lookup[tmp &gt;&gt; 10] +</span>
      <span class="s1">lookup[(tmp &gt;&gt; 4) &amp; 0x3F] +</span>
      <span class="s1">lookup[(tmp &lt;&lt; 2) &amp; 0x3F] +</span>
      <span class="s1">'='</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">return parts.join('')</span>
<span class="s1">}</span>

<span class="s1">},{}],9:[function(require,module,exports){</span>

<span class="s1">},{}],10:[function(require,module,exports){</span>
<span class="s1">(function (Buffer){(function (){</span>
<span class="s1">/*!</span>
 <span class="s1">* The buffer module from node.js, for the browser.</span>
 <span class="s1">*</span>
 <span class="s1">* @author   Feross Aboukhadijeh &lt;https://feross.org&gt;</span>
 <span class="s1">* @license  MIT</span>
 <span class="s1">*/</span>
<span class="s1">/* eslint-disable no-proto */</span>

<span class="s1">'use strict'</span>

<span class="s1">var base64 = require('base64-js')</span>
<span class="s1">var ieee754 = require('ieee754')</span>

<span class="s1">exports.Buffer = Buffer</span>
<span class="s1">exports.SlowBuffer = SlowBuffer</span>
<span class="s1">exports.INSPECT_MAX_BYTES = 50</span>

<span class="s1">var K_MAX_LENGTH = 0x7fffffff</span>
<span class="s1">exports.kMaxLength = K_MAX_LENGTH</span>

<span class="s1">/**</span>
 <span class="s1">* If `Buffer.TYPED_ARRAY_SUPPORT`:</span>
 <span class="s1">*   === true    Use Uint8Array implementation (fastest)</span>
 <span class="s1">*   === false   Print warning and recommend using `buffer` v4.x which has an Object</span>
 <span class="s1">*               implementation (most compatible, even IE6)</span>
 <span class="s1">*</span>
 <span class="s1">* Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,</span>
 <span class="s1">* Opera 11.6+, iOS 4.2+.</span>
 <span class="s1">*</span>
 <span class="s1">* We report that the browser does not support typed arrays if the are not subclassable</span>
 <span class="s1">* using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`</span>
 <span class="s1">* (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support</span>
 <span class="s1">* for __proto__ and has a buggy typed array implementation.</span>
 <span class="s1">*/</span>
<span class="s1">Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()</span>

<span class="s1">if (!Buffer.TYPED_ARRAY_SUPPORT &amp;&amp; typeof console !== 'undefined' &amp;&amp;</span>
    <span class="s1">typeof console.error === 'function') {</span>
  <span class="s1">console.error(</span>
    <span class="s1">'This browser lacks typed array (Uint8Array) support which is required by ' +</span>
    <span class="s1">'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'</span>
  <span class="s1">)</span>
<span class="s1">}</span>

<span class="s1">function typedArraySupport () {</span>
  <span class="s1">// Can typed array instances can be augmented?</span>
  <span class="s1">try {</span>
    <span class="s1">var arr = new Uint8Array(1)</span>
    <span class="s1">arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }</span>
    <span class="s1">return arr.foo() === 42</span>
  <span class="s1">} catch (e) {</span>
    <span class="s1">return false</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Object.defineProperty(Buffer.prototype, 'parent', {</span>
  <span class="s1">enumerable: true,</span>
  <span class="s1">get: function () {</span>
    <span class="s1">if (!Buffer.isBuffer(this)) return undefined</span>
    <span class="s1">return this.buffer</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">Object.defineProperty(Buffer.prototype, 'offset', {</span>
  <span class="s1">enumerable: true,</span>
  <span class="s1">get: function () {</span>
    <span class="s1">if (!Buffer.isBuffer(this)) return undefined</span>
    <span class="s1">return this.byteOffset</span>
  <span class="s1">}</span>
<span class="s1">})</span>

<span class="s1">function createBuffer (length) {</span>
  <span class="s1">if (length &gt; K_MAX_LENGTH) {</span>
    <span class="s1">throw new RangeError('The value &quot;' + length + '&quot; is invalid for option &quot;size&quot;')</span>
  <span class="s1">}</span>
  <span class="s1">// Return an augmented `Uint8Array` instance</span>
  <span class="s1">var buf = new Uint8Array(length)</span>
  <span class="s1">buf.__proto__ = Buffer.prototype</span>
  <span class="s1">return buf</span>
<span class="s1">}</span>

<span class="s1">/**</span>
 <span class="s1">* The Buffer constructor returns instances of `Uint8Array` that have their</span>
 <span class="s1">* prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of</span>
 <span class="s1">* `Uint8Array`, so the returned instances will have all the node `Buffer` methods</span>
 <span class="s1">* and the `Uint8Array` methods. Square bracket notation works as expected -- it</span>
 <span class="s1">* returns a single octet.</span>
 <span class="s1">*</span>
 <span class="s1">* The `Uint8Array` prototype remains unmodified.</span>
 <span class="s1">*/</span>

<span class="s1">function Buffer (arg, encodingOrOffset, length) {</span>
  <span class="s1">// Common case.</span>
  <span class="s1">if (typeof arg === 'number') {</span>
    <span class="s1">if (typeof encodingOrOffset === 'string') {</span>
      <span class="s1">throw new TypeError(</span>
        <span class="s1">'The &quot;string&quot; argument must be of type string. Received type number'</span>
      <span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s1">return allocUnsafe(arg)</span>
  <span class="s1">}</span>
  <span class="s1">return from(arg, encodingOrOffset, length)</span>
<span class="s1">}</span>

<span class="s1">// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97</span>
<span class="s1">if (typeof Symbol !== 'undefined' &amp;&amp; Symbol.species != null &amp;&amp;</span>
    <span class="s1">Buffer[Symbol.species] === Buffer) {</span>
  <span class="s1">Object.defineProperty(Buffer, Symbol.species, {</span>
    <span class="s1">value: null,</span>
    <span class="s1">configurable: true,</span>
    <span class="s1">enumerable: false,</span>
    <span class="s1">writable: false</span>
  <span class="s1">})</span>
<span class="s1">}</span>

<span class="s1">Buffer.poolSize = 8192 // not used by this implementation</span>

<span class="s1">function from (value, encodingOrOffset, length) {</span>
  <span class="s1">if (typeof value === 'string') {</span>
    <span class="s1">return fromString(value, encodingOrOffset)</span>
  <span class="s1">}</span>

  <span class="s1">if (ArrayBuffer.isView(value)) {</span>
    <span class="s1">return fromArrayLike(value)</span>
  <span class="s1">}</span>

  <span class="s1">if (value == null) {</span>
    <span class="s1">throw TypeError(</span>
      <span class="s1">'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +</span>
      <span class="s1">'or Array-like Object. Received type ' + (typeof value)</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">if (isInstance(value, ArrayBuffer) ||</span>
      <span class="s1">(value &amp;&amp; isInstance(value.buffer, ArrayBuffer))) {</span>
    <span class="s1">return fromArrayBuffer(value, encodingOrOffset, length)</span>
  <span class="s1">}</span>

  <span class="s1">if (typeof value === 'number') {</span>
    <span class="s1">throw new TypeError(</span>
      <span class="s1">'The &quot;value&quot; argument must not be of type number. Received type number'</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">var valueOf = value.valueOf &amp;&amp; value.valueOf()</span>
  <span class="s1">if (valueOf != null &amp;&amp; valueOf !== value) {</span>
    <span class="s1">return Buffer.from(valueOf, encodingOrOffset, length)</span>
  <span class="s1">}</span>

  <span class="s1">var b = fromObject(value)</span>
  <span class="s1">if (b) return b</span>

  <span class="s1">if (typeof Symbol !== 'undefined' &amp;&amp; Symbol.toPrimitive != null &amp;&amp;</span>
      <span class="s1">typeof value[Symbol.toPrimitive] === 'function') {</span>
    <span class="s1">return Buffer.from(</span>
      <span class="s1">value[Symbol.toPrimitive]('string'), encodingOrOffset, length</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">throw new TypeError(</span>
    <span class="s1">'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +</span>
    <span class="s1">'or Array-like Object. Received type ' + (typeof value)</span>
  <span class="s1">)</span>
<span class="s1">}</span>

<span class="s1">/**</span>
 <span class="s1">* Functionally equivalent to Buffer(arg, encoding) but throws a TypeError</span>
 <span class="s1">* if value is a number.</span>
 <span class="s1">* Buffer.from(str[, encoding])</span>
 <span class="s1">* Buffer.from(array)</span>
 <span class="s1">* Buffer.from(buffer)</span>
 <span class="s1">* Buffer.from(arrayBuffer[, byteOffset[, length]])</span>
 <span class="s1">**/</span>
<span class="s1">Buffer.from = function (value, encodingOrOffset, length) {</span>
  <span class="s1">return from(value, encodingOrOffset, length)</span>
<span class="s1">}</span>

<span class="s1">// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:</span>
<span class="s1">// https://github.com/feross/buffer/pull/148</span>
<span class="s1">Buffer.prototype.__proto__ = Uint8Array.prototype</span>
<span class="s1">Buffer.__proto__ = Uint8Array</span>

<span class="s1">function assertSize (size) {</span>
  <span class="s1">if (typeof size !== 'number') {</span>
    <span class="s1">throw new TypeError('&quot;size&quot; argument must be of type number')</span>
  <span class="s1">} else if (size &lt; 0) {</span>
    <span class="s1">throw new RangeError('The value &quot;' + size + '&quot; is invalid for option &quot;size&quot;')</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function alloc (size, fill, encoding) {</span>
  <span class="s1">assertSize(size)</span>
  <span class="s1">if (size &lt;= 0) {</span>
    <span class="s1">return createBuffer(size)</span>
  <span class="s1">}</span>
  <span class="s1">if (fill !== undefined) {</span>
    <span class="s1">// Only pay attention to encoding if it's a string. This</span>
    <span class="s1">// prevents accidentally sending in a number that would</span>
    <span class="s1">// be interpretted as a start offset.</span>
    <span class="s1">return typeof encoding === 'string'</span>
      <span class="s1">? createBuffer(size).fill(fill, encoding)</span>
      <span class="s1">: createBuffer(size).fill(fill)</span>
  <span class="s1">}</span>
  <span class="s1">return createBuffer(size)</span>
<span class="s1">}</span>

<span class="s1">/**</span>
 <span class="s1">* Creates a new filled Buffer instance.</span>
 <span class="s1">* alloc(size[, fill[, encoding]])</span>
 <span class="s1">**/</span>
<span class="s1">Buffer.alloc = function (size, fill, encoding) {</span>
  <span class="s1">return alloc(size, fill, encoding)</span>
<span class="s1">}</span>

<span class="s1">function allocUnsafe (size) {</span>
  <span class="s1">assertSize(size)</span>
  <span class="s1">return createBuffer(size &lt; 0 ? 0 : checked(size) | 0)</span>
<span class="s1">}</span>

<span class="s1">/**</span>
 <span class="s1">* Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.</span>
 <span class="s1">* */</span>
<span class="s1">Buffer.allocUnsafe = function (size) {</span>
  <span class="s1">return allocUnsafe(size)</span>
<span class="s1">}</span>
<span class="s1">/**</span>
 <span class="s1">* Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.</span>
 <span class="s1">*/</span>
<span class="s1">Buffer.allocUnsafeSlow = function (size) {</span>
  <span class="s1">return allocUnsafe(size)</span>
<span class="s1">}</span>

<span class="s1">function fromString (string, encoding) {</span>
  <span class="s1">if (typeof encoding !== 'string' || encoding === '') {</span>
    <span class="s1">encoding = 'utf8'</span>
  <span class="s1">}</span>

  <span class="s1">if (!Buffer.isEncoding(encoding)) {</span>
    <span class="s1">throw new TypeError('Unknown encoding: ' + encoding)</span>
  <span class="s1">}</span>

  <span class="s1">var length = byteLength(string, encoding) | 0</span>
  <span class="s1">var buf = createBuffer(length)</span>

  <span class="s1">var actual = buf.write(string, encoding)</span>

  <span class="s1">if (actual !== length) {</span>
    <span class="s1">// Writing a hex string, for example, that contains invalid characters will</span>
    <span class="s1">// cause everything after the first invalid character to be ignored. (e.g.</span>
    <span class="s1">// 'abxxcd' will be treated as 'ab')</span>
    <span class="s1">buf = buf.slice(0, actual)</span>
  <span class="s1">}</span>

  <span class="s1">return buf</span>
<span class="s1">}</span>

<span class="s1">function fromArrayLike (array) {</span>
  <span class="s1">var length = array.length &lt; 0 ? 0 : checked(array.length) | 0</span>
  <span class="s1">var buf = createBuffer(length)</span>
  <span class="s1">for (var i = 0; i &lt; length; i += 1) {</span>
    <span class="s1">buf[i] = array[i] &amp; 255</span>
  <span class="s1">}</span>
  <span class="s1">return buf</span>
<span class="s1">}</span>

<span class="s1">function fromArrayBuffer (array, byteOffset, length) {</span>
  <span class="s1">if (byteOffset &lt; 0 || array.byteLength &lt; byteOffset) {</span>
    <span class="s1">throw new RangeError('&quot;offset&quot; is outside of buffer bounds')</span>
  <span class="s1">}</span>

  <span class="s1">if (array.byteLength &lt; byteOffset + (length || 0)) {</span>
    <span class="s1">throw new RangeError('&quot;length&quot; is outside of buffer bounds')</span>
  <span class="s1">}</span>

  <span class="s1">var buf</span>
  <span class="s1">if (byteOffset === undefined &amp;&amp; length === undefined) {</span>
    <span class="s1">buf = new Uint8Array(array)</span>
  <span class="s1">} else if (length === undefined) {</span>
    <span class="s1">buf = new Uint8Array(array, byteOffset)</span>
  <span class="s1">} else {</span>
    <span class="s1">buf = new Uint8Array(array, byteOffset, length)</span>
  <span class="s1">}</span>

  <span class="s1">// Return an augmented `Uint8Array` instance</span>
  <span class="s1">buf.__proto__ = Buffer.prototype</span>
  <span class="s1">return buf</span>
<span class="s1">}</span>

<span class="s1">function fromObject (obj) {</span>
  <span class="s1">if (Buffer.isBuffer(obj)) {</span>
    <span class="s1">var len = checked(obj.length) | 0</span>
    <span class="s1">var buf = createBuffer(len)</span>

    <span class="s1">if (buf.length === 0) {</span>
      <span class="s1">return buf</span>
    <span class="s1">}</span>

    <span class="s1">obj.copy(buf, 0, 0, len)</span>
    <span class="s1">return buf</span>
  <span class="s1">}</span>

  <span class="s1">if (obj.length !== undefined) {</span>
    <span class="s1">if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {</span>
      <span class="s1">return createBuffer(0)</span>
    <span class="s1">}</span>
    <span class="s1">return fromArrayLike(obj)</span>
  <span class="s1">}</span>

  <span class="s1">if (obj.type === 'Buffer' &amp;&amp; Array.isArray(obj.data)) {</span>
    <span class="s1">return fromArrayLike(obj.data)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function checked (length) {</span>
  <span class="s1">// Note: cannot use `length &lt; K_MAX_LENGTH` here because that fails when</span>
  <span class="s1">// length is NaN (which is otherwise coerced to zero.)</span>
  <span class="s1">if (length &gt;= K_MAX_LENGTH) {</span>
    <span class="s1">throw new RangeError('Attempt to allocate Buffer larger than maximum ' +</span>
                         <span class="s1">'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')</span>
  <span class="s1">}</span>
  <span class="s1">return length | 0</span>
<span class="s1">}</span>

<span class="s1">function SlowBuffer (length) {</span>
  <span class="s1">if (+length != length) { // eslint-disable-line eqeqeq</span>
    <span class="s1">length = 0</span>
  <span class="s1">}</span>
  <span class="s1">return Buffer.alloc(+length)</span>
<span class="s1">}</span>

<span class="s1">Buffer.isBuffer = function isBuffer (b) {</span>
  <span class="s1">return b != null &amp;&amp; b._isBuffer === true &amp;&amp;</span>
    <span class="s1">b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false</span>
<span class="s1">}</span>

<span class="s1">Buffer.compare = function compare (a, b) {</span>
  <span class="s1">if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)</span>
  <span class="s1">if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)</span>
  <span class="s1">if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {</span>
    <span class="s1">throw new TypeError(</span>
      <span class="s1">'The &quot;buf1&quot;, &quot;buf2&quot; arguments must be one of type Buffer or Uint8Array'</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">if (a === b) return 0</span>

  <span class="s1">var x = a.length</span>
  <span class="s1">var y = b.length</span>

  <span class="s1">for (var i = 0, len = Math.min(x, y); i &lt; len; ++i) {</span>
    <span class="s1">if (a[i] !== b[i]) {</span>
      <span class="s1">x = a[i]</span>
      <span class="s1">y = b[i]</span>
      <span class="s1">break</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (x &lt; y) return -1</span>
  <span class="s1">if (y &lt; x) return 1</span>
  <span class="s1">return 0</span>
<span class="s1">}</span>

<span class="s1">Buffer.isEncoding = function isEncoding (encoding) {</span>
  <span class="s1">switch (String(encoding).toLowerCase()) {</span>
    <span class="s1">case 'hex':</span>
    <span class="s1">case 'utf8':</span>
    <span class="s1">case 'utf-8':</span>
    <span class="s1">case 'ascii':</span>
    <span class="s1">case 'latin1':</span>
    <span class="s1">case 'binary':</span>
    <span class="s1">case 'base64':</span>
    <span class="s1">case 'ucs2':</span>
    <span class="s1">case 'ucs-2':</span>
    <span class="s1">case 'utf16le':</span>
    <span class="s1">case 'utf-16le':</span>
      <span class="s1">return true</span>
    <span class="s1">default:</span>
      <span class="s1">return false</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Buffer.concat = function concat (list, length) {</span>
  <span class="s1">if (!Array.isArray(list)) {</span>
    <span class="s1">throw new TypeError('&quot;list&quot; argument must be an Array of Buffers')</span>
  <span class="s1">}</span>

  <span class="s1">if (list.length === 0) {</span>
    <span class="s1">return Buffer.alloc(0)</span>
  <span class="s1">}</span>

  <span class="s1">var i</span>
  <span class="s1">if (length === undefined) {</span>
    <span class="s1">length = 0</span>
    <span class="s1">for (i = 0; i &lt; list.length; ++i) {</span>
      <span class="s1">length += list[i].length</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">var buffer = Buffer.allocUnsafe(length)</span>
  <span class="s1">var pos = 0</span>
  <span class="s1">for (i = 0; i &lt; list.length; ++i) {</span>
    <span class="s1">var buf = list[i]</span>
    <span class="s1">if (isInstance(buf, Uint8Array)) {</span>
      <span class="s1">buf = Buffer.from(buf)</span>
    <span class="s1">}</span>
    <span class="s1">if (!Buffer.isBuffer(buf)) {</span>
      <span class="s1">throw new TypeError('&quot;list&quot; argument must be an Array of Buffers')</span>
    <span class="s1">}</span>
    <span class="s1">buf.copy(buffer, pos)</span>
    <span class="s1">pos += buf.length</span>
  <span class="s1">}</span>
  <span class="s1">return buffer</span>
<span class="s1">}</span>

<span class="s1">function byteLength (string, encoding) {</span>
  <span class="s1">if (Buffer.isBuffer(string)) {</span>
    <span class="s1">return string.length</span>
  <span class="s1">}</span>
  <span class="s1">if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {</span>
    <span class="s1">return string.byteLength</span>
  <span class="s1">}</span>
  <span class="s1">if (typeof string !== 'string') {</span>
    <span class="s1">throw new TypeError(</span>
      <span class="s1">'The &quot;string&quot; argument must be one of type string, Buffer, or ArrayBuffer. ' +</span>
      <span class="s1">'Received type ' + typeof string</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">var len = string.length</span>
  <span class="s1">var mustMatch = (arguments.length &gt; 2 &amp;&amp; arguments[2] === true)</span>
  <span class="s1">if (!mustMatch &amp;&amp; len === 0) return 0</span>

  <span class="s1">// Use a for loop to avoid recursion</span>
  <span class="s1">var loweredCase = false</span>
  <span class="s1">for (;;) {</span>
    <span class="s1">switch (encoding) {</span>
      <span class="s1">case 'ascii':</span>
      <span class="s1">case 'latin1':</span>
      <span class="s1">case 'binary':</span>
        <span class="s1">return len</span>
      <span class="s1">case 'utf8':</span>
      <span class="s1">case 'utf-8':</span>
        <span class="s1">return utf8ToBytes(string).length</span>
      <span class="s1">case 'ucs2':</span>
      <span class="s1">case 'ucs-2':</span>
      <span class="s1">case 'utf16le':</span>
      <span class="s1">case 'utf-16le':</span>
        <span class="s1">return len * 2</span>
      <span class="s1">case 'hex':</span>
        <span class="s1">return len &gt;&gt;&gt; 1</span>
      <span class="s1">case 'base64':</span>
        <span class="s1">return base64ToBytes(string).length</span>
      <span class="s1">default:</span>
        <span class="s1">if (loweredCase) {</span>
          <span class="s1">return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8</span>
        <span class="s1">}</span>
        <span class="s1">encoding = ('' + encoding).toLowerCase()</span>
        <span class="s1">loweredCase = true</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">Buffer.byteLength = byteLength</span>

<span class="s1">function slowToString (encoding, start, end) {</span>
  <span class="s1">var loweredCase = false</span>

  <span class="s1">// No need to verify that &quot;this.length &lt;= MAX_UINT32&quot; since it's a read-only</span>
  <span class="s1">// property of a typed array.</span>

  <span class="s1">// This behaves neither like String nor Uint8Array in that we set start/end</span>
  <span class="s1">// to their upper/lower bounds if the value passed is out of range.</span>
  <span class="s1">// undefined is handled specially as per ECMA-262 6th Edition,</span>
  <span class="s1">// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.</span>
  <span class="s1">if (start === undefined || start &lt; 0) {</span>
    <span class="s1">start = 0</span>
  <span class="s1">}</span>
  <span class="s1">// Return early if start &gt; this.length. Done here to prevent potential uint32</span>
  <span class="s1">// coercion fail below.</span>
  <span class="s1">if (start &gt; this.length) {</span>
    <span class="s1">return ''</span>
  <span class="s1">}</span>

  <span class="s1">if (end === undefined || end &gt; this.length) {</span>
    <span class="s1">end = this.length</span>
  <span class="s1">}</span>

  <span class="s1">if (end &lt;= 0) {</span>
    <span class="s1">return ''</span>
  <span class="s1">}</span>

  <span class="s1">// Force coersion to uint32. This will also coerce falsey/NaN values to 0.</span>
  <span class="s1">end &gt;&gt;&gt;= 0</span>
  <span class="s1">start &gt;&gt;&gt;= 0</span>

  <span class="s1">if (end &lt;= start) {</span>
    <span class="s1">return ''</span>
  <span class="s1">}</span>

  <span class="s1">if (!encoding) encoding = 'utf8'</span>

  <span class="s1">while (true) {</span>
    <span class="s1">switch (encoding) {</span>
      <span class="s1">case 'hex':</span>
        <span class="s1">return hexSlice(this, start, end)</span>

      <span class="s1">case 'utf8':</span>
      <span class="s1">case 'utf-8':</span>
        <span class="s1">return utf8Slice(this, start, end)</span>

      <span class="s1">case 'ascii':</span>
        <span class="s1">return asciiSlice(this, start, end)</span>

      <span class="s1">case 'latin1':</span>
      <span class="s1">case 'binary':</span>
        <span class="s1">return latin1Slice(this, start, end)</span>

      <span class="s1">case 'base64':</span>
        <span class="s1">return base64Slice(this, start, end)</span>

      <span class="s1">case 'ucs2':</span>
      <span class="s1">case 'ucs-2':</span>
      <span class="s1">case 'utf16le':</span>
      <span class="s1">case 'utf-16le':</span>
        <span class="s1">return utf16leSlice(this, start, end)</span>

      <span class="s1">default:</span>
        <span class="s1">if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)</span>
        <span class="s1">encoding = (encoding + '').toLowerCase()</span>
        <span class="s1">loweredCase = true</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)</span>
<span class="s1">// to detect a Buffer instance. It's not possible to use `instanceof Buffer`</span>
<span class="s1">// reliably in a browserify context because there could be multiple different</span>
<span class="s1">// copies of the 'buffer' package in use. This method works even for Buffer</span>
<span class="s1">// instances that were created from another copy of the `buffer` package.</span>
<span class="s1">// See: https://github.com/feross/buffer/issues/154</span>
<span class="s1">Buffer.prototype._isBuffer = true</span>

<span class="s1">function swap (b, n, m) {</span>
  <span class="s1">var i = b[n]</span>
  <span class="s1">b[n] = b[m]</span>
  <span class="s1">b[m] = i</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.swap16 = function swap16 () {</span>
  <span class="s1">var len = this.length</span>
  <span class="s1">if (len % 2 !== 0) {</span>
    <span class="s1">throw new RangeError('Buffer size must be a multiple of 16-bits')</span>
  <span class="s1">}</span>
  <span class="s1">for (var i = 0; i &lt; len; i += 2) {</span>
    <span class="s1">swap(this, i, i + 1)</span>
  <span class="s1">}</span>
  <span class="s1">return this</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.swap32 = function swap32 () {</span>
  <span class="s1">var len = this.length</span>
  <span class="s1">if (len % 4 !== 0) {</span>
    <span class="s1">throw new RangeError('Buffer size must be a multiple of 32-bits')</span>
  <span class="s1">}</span>
  <span class="s1">for (var i = 0; i &lt; len; i += 4) {</span>
    <span class="s1">swap(this, i, i + 3)</span>
    <span class="s1">swap(this, i + 1, i + 2)</span>
  <span class="s1">}</span>
  <span class="s1">return this</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.swap64 = function swap64 () {</span>
  <span class="s1">var len = this.length</span>
  <span class="s1">if (len % 8 !== 0) {</span>
    <span class="s1">throw new RangeError('Buffer size must be a multiple of 64-bits')</span>
  <span class="s1">}</span>
  <span class="s1">for (var i = 0; i &lt; len; i += 8) {</span>
    <span class="s1">swap(this, i, i + 7)</span>
    <span class="s1">swap(this, i + 1, i + 6)</span>
    <span class="s1">swap(this, i + 2, i + 5)</span>
    <span class="s1">swap(this, i + 3, i + 4)</span>
  <span class="s1">}</span>
  <span class="s1">return this</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.toString = function toString () {</span>
  <span class="s1">var length = this.length</span>
  <span class="s1">if (length === 0) return ''</span>
  <span class="s1">if (arguments.length === 0) return utf8Slice(this, 0, length)</span>
  <span class="s1">return slowToString.apply(this, arguments)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.toLocaleString = Buffer.prototype.toString</span>

<span class="s1">Buffer.prototype.equals = function equals (b) {</span>
  <span class="s1">if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')</span>
  <span class="s1">if (this === b) return true</span>
  <span class="s1">return Buffer.compare(this, b) === 0</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.inspect = function inspect () {</span>
  <span class="s1">var str = ''</span>
  <span class="s1">var max = exports.INSPECT_MAX_BYTES</span>
  <span class="s1">str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()</span>
  <span class="s1">if (this.length &gt; max) str += ' ... '</span>
  <span class="s1">return '&lt;Buffer ' + str + '&gt;'</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {</span>
  <span class="s1">if (isInstance(target, Uint8Array)) {</span>
    <span class="s1">target = Buffer.from(target, target.offset, target.byteLength)</span>
  <span class="s1">}</span>
  <span class="s1">if (!Buffer.isBuffer(target)) {</span>
    <span class="s1">throw new TypeError(</span>
      <span class="s1">'The &quot;target&quot; argument must be one of type Buffer or Uint8Array. ' +</span>
      <span class="s1">'Received type ' + (typeof target)</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">if (start === undefined) {</span>
    <span class="s1">start = 0</span>
  <span class="s1">}</span>
  <span class="s1">if (end === undefined) {</span>
    <span class="s1">end = target ? target.length : 0</span>
  <span class="s1">}</span>
  <span class="s1">if (thisStart === undefined) {</span>
    <span class="s1">thisStart = 0</span>
  <span class="s1">}</span>
  <span class="s1">if (thisEnd === undefined) {</span>
    <span class="s1">thisEnd = this.length</span>
  <span class="s1">}</span>

  <span class="s1">if (start &lt; 0 || end &gt; target.length || thisStart &lt; 0 || thisEnd &gt; this.length) {</span>
    <span class="s1">throw new RangeError('out of range index')</span>
  <span class="s1">}</span>

  <span class="s1">if (thisStart &gt;= thisEnd &amp;&amp; start &gt;= end) {</span>
    <span class="s1">return 0</span>
  <span class="s1">}</span>
  <span class="s1">if (thisStart &gt;= thisEnd) {</span>
    <span class="s1">return -1</span>
  <span class="s1">}</span>
  <span class="s1">if (start &gt;= end) {</span>
    <span class="s1">return 1</span>
  <span class="s1">}</span>

  <span class="s1">start &gt;&gt;&gt;= 0</span>
  <span class="s1">end &gt;&gt;&gt;= 0</span>
  <span class="s1">thisStart &gt;&gt;&gt;= 0</span>
  <span class="s1">thisEnd &gt;&gt;&gt;= 0</span>

  <span class="s1">if (this === target) return 0</span>

  <span class="s1">var x = thisEnd - thisStart</span>
  <span class="s1">var y = end - start</span>
  <span class="s1">var len = Math.min(x, y)</span>

  <span class="s1">var thisCopy = this.slice(thisStart, thisEnd)</span>
  <span class="s1">var targetCopy = target.slice(start, end)</span>

  <span class="s1">for (var i = 0; i &lt; len; ++i) {</span>
    <span class="s1">if (thisCopy[i] !== targetCopy[i]) {</span>
      <span class="s1">x = thisCopy[i]</span>
      <span class="s1">y = targetCopy[i]</span>
      <span class="s1">break</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (x &lt; y) return -1</span>
  <span class="s1">if (y &lt; x) return 1</span>
  <span class="s1">return 0</span>
<span class="s1">}</span>

<span class="s1">// Finds either the first index of `val` in `buffer` at offset &gt;= `byteOffset`,</span>
<span class="s1">// OR the last index of `val` in `buffer` at offset &lt;= `byteOffset`.</span>
<span class="s1">//</span>
<span class="s1">// Arguments:</span>
<span class="s1">// - buffer - a Buffer to search</span>
<span class="s1">// - val - a string, Buffer, or number</span>
<span class="s1">// - byteOffset - an index into `buffer`; will be clamped to an int32</span>
<span class="s1">// - encoding - an optional encoding, relevant is val is a string</span>
<span class="s1">// - dir - true for indexOf, false for lastIndexOf</span>
<span class="s1">function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {</span>
  <span class="s1">// Empty buffer means no match</span>
  <span class="s1">if (buffer.length === 0) return -1</span>

  <span class="s1">// Normalize byteOffset</span>
  <span class="s1">if (typeof byteOffset === 'string') {</span>
    <span class="s1">encoding = byteOffset</span>
    <span class="s1">byteOffset = 0</span>
  <span class="s1">} else if (byteOffset &gt; 0x7fffffff) {</span>
    <span class="s1">byteOffset = 0x7fffffff</span>
  <span class="s1">} else if (byteOffset &lt; -0x80000000) {</span>
    <span class="s1">byteOffset = -0x80000000</span>
  <span class="s1">}</span>
  <span class="s1">byteOffset = +byteOffset // Coerce to Number.</span>
  <span class="s1">if (numberIsNaN(byteOffset)) {</span>
    <span class="s1">// byteOffset: it it's undefined, null, NaN, &quot;foo&quot;, etc, search whole buffer</span>
    <span class="s1">byteOffset = dir ? 0 : (buffer.length - 1)</span>
  <span class="s1">}</span>

  <span class="s1">// Normalize byteOffset: negative offsets start from the end of the buffer</span>
  <span class="s1">if (byteOffset &lt; 0) byteOffset = buffer.length + byteOffset</span>
  <span class="s1">if (byteOffset &gt;= buffer.length) {</span>
    <span class="s1">if (dir) return -1</span>
    <span class="s1">else byteOffset = buffer.length - 1</span>
  <span class="s1">} else if (byteOffset &lt; 0) {</span>
    <span class="s1">if (dir) byteOffset = 0</span>
    <span class="s1">else return -1</span>
  <span class="s1">}</span>

  <span class="s1">// Normalize val</span>
  <span class="s1">if (typeof val === 'string') {</span>
    <span class="s1">val = Buffer.from(val, encoding)</span>
  <span class="s1">}</span>

  <span class="s1">// Finally, search either indexOf (if dir is true) or lastIndexOf</span>
  <span class="s1">if (Buffer.isBuffer(val)) {</span>
    <span class="s1">// Special case: looking for empty string/buffer always fails</span>
    <span class="s1">if (val.length === 0) {</span>
      <span class="s1">return -1</span>
    <span class="s1">}</span>
    <span class="s1">return arrayIndexOf(buffer, val, byteOffset, encoding, dir)</span>
  <span class="s1">} else if (typeof val === 'number') {</span>
    <span class="s1">val = val &amp; 0xFF // Search for a byte value [0-255]</span>
    <span class="s1">if (typeof Uint8Array.prototype.indexOf === 'function') {</span>
      <span class="s1">if (dir) {</span>
        <span class="s1">return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)</span>
      <span class="s1">} else {</span>
        <span class="s1">return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)</span>
  <span class="s1">}</span>

  <span class="s1">throw new TypeError('val must be string, number or Buffer')</span>
<span class="s1">}</span>

<span class="s1">function arrayIndexOf (arr, val, byteOffset, encoding, dir) {</span>
  <span class="s1">var indexSize = 1</span>
  <span class="s1">var arrLength = arr.length</span>
  <span class="s1">var valLength = val.length</span>

  <span class="s1">if (encoding !== undefined) {</span>
    <span class="s1">encoding = String(encoding).toLowerCase()</span>
    <span class="s1">if (encoding === 'ucs2' || encoding === 'ucs-2' ||</span>
        <span class="s1">encoding === 'utf16le' || encoding === 'utf-16le') {</span>
      <span class="s1">if (arr.length &lt; 2 || val.length &lt; 2) {</span>
        <span class="s1">return -1</span>
      <span class="s1">}</span>
      <span class="s1">indexSize = 2</span>
      <span class="s1">arrLength /= 2</span>
      <span class="s1">valLength /= 2</span>
      <span class="s1">byteOffset /= 2</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">function read (buf, i) {</span>
    <span class="s1">if (indexSize === 1) {</span>
      <span class="s1">return buf[i]</span>
    <span class="s1">} else {</span>
      <span class="s1">return buf.readUInt16BE(i * indexSize)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">var i</span>
  <span class="s1">if (dir) {</span>
    <span class="s1">var foundIndex = -1</span>
    <span class="s1">for (i = byteOffset; i &lt; arrLength; i++) {</span>
      <span class="s1">if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {</span>
        <span class="s1">if (foundIndex === -1) foundIndex = i</span>
        <span class="s1">if (i - foundIndex + 1 === valLength) return foundIndex * indexSize</span>
      <span class="s1">} else {</span>
        <span class="s1">if (foundIndex !== -1) i -= i - foundIndex</span>
        <span class="s1">foundIndex = -1</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">if (byteOffset + valLength &gt; arrLength) byteOffset = arrLength - valLength</span>
    <span class="s1">for (i = byteOffset; i &gt;= 0; i--) {</span>
      <span class="s1">var found = true</span>
      <span class="s1">for (var j = 0; j &lt; valLength; j++) {</span>
        <span class="s1">if (read(arr, i + j) !== read(val, j)) {</span>
          <span class="s1">found = false</span>
          <span class="s1">break</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">if (found) return i</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return -1</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.includes = function includes (val, byteOffset, encoding) {</span>
  <span class="s1">return this.indexOf(val, byteOffset, encoding) !== -1</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {</span>
  <span class="s1">return bidirectionalIndexOf(this, val, byteOffset, encoding, true)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {</span>
  <span class="s1">return bidirectionalIndexOf(this, val, byteOffset, encoding, false)</span>
<span class="s1">}</span>

<span class="s1">function hexWrite (buf, string, offset, length) {</span>
  <span class="s1">offset = Number(offset) || 0</span>
  <span class="s1">var remaining = buf.length - offset</span>
  <span class="s1">if (!length) {</span>
    <span class="s1">length = remaining</span>
  <span class="s1">} else {</span>
    <span class="s1">length = Number(length)</span>
    <span class="s1">if (length &gt; remaining) {</span>
      <span class="s1">length = remaining</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">var strLen = string.length</span>

  <span class="s1">if (length &gt; strLen / 2) {</span>
    <span class="s1">length = strLen / 2</span>
  <span class="s1">}</span>
  <span class="s1">for (var i = 0; i &lt; length; ++i) {</span>
    <span class="s1">var parsed = parseInt(string.substr(i * 2, 2), 16)</span>
    <span class="s1">if (numberIsNaN(parsed)) return i</span>
    <span class="s1">buf[offset + i] = parsed</span>
  <span class="s1">}</span>
  <span class="s1">return i</span>
<span class="s1">}</span>

<span class="s1">function utf8Write (buf, string, offset, length) {</span>
  <span class="s1">return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)</span>
<span class="s1">}</span>

<span class="s1">function asciiWrite (buf, string, offset, length) {</span>
  <span class="s1">return blitBuffer(asciiToBytes(string), buf, offset, length)</span>
<span class="s1">}</span>

<span class="s1">function latin1Write (buf, string, offset, length) {</span>
  <span class="s1">return asciiWrite(buf, string, offset, length)</span>
<span class="s1">}</span>

<span class="s1">function base64Write (buf, string, offset, length) {</span>
  <span class="s1">return blitBuffer(base64ToBytes(string), buf, offset, length)</span>
<span class="s1">}</span>

<span class="s1">function ucs2Write (buf, string, offset, length) {</span>
  <span class="s1">return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.write = function write (string, offset, length, encoding) {</span>
  <span class="s1">// Buffer#write(string)</span>
  <span class="s1">if (offset === undefined) {</span>
    <span class="s1">encoding = 'utf8'</span>
    <span class="s1">length = this.length</span>
    <span class="s1">offset = 0</span>
  <span class="s1">// Buffer#write(string, encoding)</span>
  <span class="s1">} else if (length === undefined &amp;&amp; typeof offset === 'string') {</span>
    <span class="s1">encoding = offset</span>
    <span class="s1">length = this.length</span>
    <span class="s1">offset = 0</span>
  <span class="s1">// Buffer#write(string, offset[, length][, encoding])</span>
  <span class="s1">} else if (isFinite(offset)) {</span>
    <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
    <span class="s1">if (isFinite(length)) {</span>
      <span class="s1">length = length &gt;&gt;&gt; 0</span>
      <span class="s1">if (encoding === undefined) encoding = 'utf8'</span>
    <span class="s1">} else {</span>
      <span class="s1">encoding = length</span>
      <span class="s1">length = undefined</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">throw new Error(</span>
      <span class="s1">'Buffer.write(string, encoding, offset[, length]) is no longer supported'</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">var remaining = this.length - offset</span>
  <span class="s1">if (length === undefined || length &gt; remaining) length = remaining</span>

  <span class="s1">if ((string.length &gt; 0 &amp;&amp; (length &lt; 0 || offset &lt; 0)) || offset &gt; this.length) {</span>
    <span class="s1">throw new RangeError('Attempt to write outside buffer bounds')</span>
  <span class="s1">}</span>

  <span class="s1">if (!encoding) encoding = 'utf8'</span>

  <span class="s1">var loweredCase = false</span>
  <span class="s1">for (;;) {</span>
    <span class="s1">switch (encoding) {</span>
      <span class="s1">case 'hex':</span>
        <span class="s1">return hexWrite(this, string, offset, length)</span>

      <span class="s1">case 'utf8':</span>
      <span class="s1">case 'utf-8':</span>
        <span class="s1">return utf8Write(this, string, offset, length)</span>

      <span class="s1">case 'ascii':</span>
        <span class="s1">return asciiWrite(this, string, offset, length)</span>

      <span class="s1">case 'latin1':</span>
      <span class="s1">case 'binary':</span>
        <span class="s1">return latin1Write(this, string, offset, length)</span>

      <span class="s1">case 'base64':</span>
        <span class="s1">// Warning: maxLength not taken into account in base64Write</span>
        <span class="s1">return base64Write(this, string, offset, length)</span>

      <span class="s1">case 'ucs2':</span>
      <span class="s1">case 'ucs-2':</span>
      <span class="s1">case 'utf16le':</span>
      <span class="s1">case 'utf-16le':</span>
        <span class="s1">return ucs2Write(this, string, offset, length)</span>

      <span class="s1">default:</span>
        <span class="s1">if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)</span>
        <span class="s1">encoding = ('' + encoding).toLowerCase()</span>
        <span class="s1">loweredCase = true</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.toJSON = function toJSON () {</span>
  <span class="s1">return {</span>
    <span class="s1">type: 'Buffer',</span>
    <span class="s1">data: Array.prototype.slice.call(this._arr || this, 0)</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function base64Slice (buf, start, end) {</span>
  <span class="s1">if (start === 0 &amp;&amp; end === buf.length) {</span>
    <span class="s1">return base64.fromByteArray(buf)</span>
  <span class="s1">} else {</span>
    <span class="s1">return base64.fromByteArray(buf.slice(start, end))</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function utf8Slice (buf, start, end) {</span>
  <span class="s1">end = Math.min(buf.length, end)</span>
  <span class="s1">var res = []</span>

  <span class="s1">var i = start</span>
  <span class="s1">while (i &lt; end) {</span>
    <span class="s1">var firstByte = buf[i]</span>
    <span class="s1">var codePoint = null</span>
    <span class="s1">var bytesPerSequence = (firstByte &gt; 0xEF) ? 4</span>
      <span class="s1">: (firstByte &gt; 0xDF) ? 3</span>
        <span class="s1">: (firstByte &gt; 0xBF) ? 2</span>
          <span class="s1">: 1</span>

    <span class="s1">if (i + bytesPerSequence &lt;= end) {</span>
      <span class="s1">var secondByte, thirdByte, fourthByte, tempCodePoint</span>

      <span class="s1">switch (bytesPerSequence) {</span>
        <span class="s1">case 1:</span>
          <span class="s1">if (firstByte &lt; 0x80) {</span>
            <span class="s1">codePoint = firstByte</span>
          <span class="s1">}</span>
          <span class="s1">break</span>
        <span class="s1">case 2:</span>
          <span class="s1">secondByte = buf[i + 1]</span>
          <span class="s1">if ((secondByte &amp; 0xC0) === 0x80) {</span>
            <span class="s1">tempCodePoint = (firstByte &amp; 0x1F) &lt;&lt; 0x6 | (secondByte &amp; 0x3F)</span>
            <span class="s1">if (tempCodePoint &gt; 0x7F) {</span>
              <span class="s1">codePoint = tempCodePoint</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s1">break</span>
        <span class="s1">case 3:</span>
          <span class="s1">secondByte = buf[i + 1]</span>
          <span class="s1">thirdByte = buf[i + 2]</span>
          <span class="s1">if ((secondByte &amp; 0xC0) === 0x80 &amp;&amp; (thirdByte &amp; 0xC0) === 0x80) {</span>
            <span class="s1">tempCodePoint = (firstByte &amp; 0xF) &lt;&lt; 0xC | (secondByte &amp; 0x3F) &lt;&lt; 0x6 | (thirdByte &amp; 0x3F)</span>
            <span class="s1">if (tempCodePoint &gt; 0x7FF &amp;&amp; (tempCodePoint &lt; 0xD800 || tempCodePoint &gt; 0xDFFF)) {</span>
              <span class="s1">codePoint = tempCodePoint</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s1">break</span>
        <span class="s1">case 4:</span>
          <span class="s1">secondByte = buf[i + 1]</span>
          <span class="s1">thirdByte = buf[i + 2]</span>
          <span class="s1">fourthByte = buf[i + 3]</span>
          <span class="s1">if ((secondByte &amp; 0xC0) === 0x80 &amp;&amp; (thirdByte &amp; 0xC0) === 0x80 &amp;&amp; (fourthByte &amp; 0xC0) === 0x80) {</span>
            <span class="s1">tempCodePoint = (firstByte &amp; 0xF) &lt;&lt; 0x12 | (secondByte &amp; 0x3F) &lt;&lt; 0xC | (thirdByte &amp; 0x3F) &lt;&lt; 0x6 | (fourthByte &amp; 0x3F)</span>
            <span class="s1">if (tempCodePoint &gt; 0xFFFF &amp;&amp; tempCodePoint &lt; 0x110000) {</span>
              <span class="s1">codePoint = tempCodePoint</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">if (codePoint === null) {</span>
      <span class="s1">// we did not generate a valid codePoint so insert a</span>
      <span class="s1">// replacement char (U+FFFD) and advance only 1 byte</span>
      <span class="s1">codePoint = 0xFFFD</span>
      <span class="s1">bytesPerSequence = 1</span>
    <span class="s1">} else if (codePoint &gt; 0xFFFF) {</span>
      <span class="s1">// encode to utf16 (surrogate pair dance)</span>
      <span class="s1">codePoint -= 0x10000</span>
      <span class="s1">res.push(codePoint &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800)</span>
      <span class="s1">codePoint = 0xDC00 | codePoint &amp; 0x3FF</span>
    <span class="s1">}</span>

    <span class="s1">res.push(codePoint)</span>
    <span class="s1">i += bytesPerSequence</span>
  <span class="s1">}</span>

  <span class="s1">return decodeCodePointsArray(res)</span>
<span class="s1">}</span>

<span class="s1">// Based on http://stackoverflow.com/a/22747272/680742, the browser with</span>
<span class="s1">// the lowest limit is Chrome, with 0x10000 args.</span>
<span class="s1">// We go 1 magnitude less, for safety</span>
<span class="s1">var MAX_ARGUMENTS_LENGTH = 0x1000</span>

<span class="s1">function decodeCodePointsArray (codePoints) {</span>
  <span class="s1">var len = codePoints.length</span>
  <span class="s1">if (len &lt;= MAX_ARGUMENTS_LENGTH) {</span>
    <span class="s1">return String.fromCharCode.apply(String, codePoints) // avoid extra slice()</span>
  <span class="s1">}</span>

  <span class="s1">// Decode in chunks to avoid &quot;call stack size exceeded&quot;.</span>
  <span class="s1">var res = ''</span>
  <span class="s1">var i = 0</span>
  <span class="s1">while (i &lt; len) {</span>
    <span class="s1">res += String.fromCharCode.apply(</span>
      <span class="s1">String,</span>
      <span class="s1">codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)</span>
    <span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s1">return res</span>
<span class="s1">}</span>

<span class="s1">function asciiSlice (buf, start, end) {</span>
  <span class="s1">var ret = ''</span>
  <span class="s1">end = Math.min(buf.length, end)</span>

  <span class="s1">for (var i = start; i &lt; end; ++i) {</span>
    <span class="s1">ret += String.fromCharCode(buf[i] &amp; 0x7F)</span>
  <span class="s1">}</span>
  <span class="s1">return ret</span>
<span class="s1">}</span>

<span class="s1">function latin1Slice (buf, start, end) {</span>
  <span class="s1">var ret = ''</span>
  <span class="s1">end = Math.min(buf.length, end)</span>

  <span class="s1">for (var i = start; i &lt; end; ++i) {</span>
    <span class="s1">ret += String.fromCharCode(buf[i])</span>
  <span class="s1">}</span>
  <span class="s1">return ret</span>
<span class="s1">}</span>

<span class="s1">function hexSlice (buf, start, end) {</span>
  <span class="s1">var len = buf.length</span>

  <span class="s1">if (!start || start &lt; 0) start = 0</span>
  <span class="s1">if (!end || end &lt; 0 || end &gt; len) end = len</span>

  <span class="s1">var out = ''</span>
  <span class="s1">for (var i = start; i &lt; end; ++i) {</span>
    <span class="s1">out += toHex(buf[i])</span>
  <span class="s1">}</span>
  <span class="s1">return out</span>
<span class="s1">}</span>

<span class="s1">function utf16leSlice (buf, start, end) {</span>
  <span class="s1">var bytes = buf.slice(start, end)</span>
  <span class="s1">var res = ''</span>
  <span class="s1">for (var i = 0; i &lt; bytes.length; i += 2) {</span>
    <span class="s1">res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))</span>
  <span class="s1">}</span>
  <span class="s1">return res</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.slice = function slice (start, end) {</span>
  <span class="s1">var len = this.length</span>
  <span class="s1">start = ~~start</span>
  <span class="s1">end = end === undefined ? len : ~~end</span>

  <span class="s1">if (start &lt; 0) {</span>
    <span class="s1">start += len</span>
    <span class="s1">if (start &lt; 0) start = 0</span>
  <span class="s1">} else if (start &gt; len) {</span>
    <span class="s1">start = len</span>
  <span class="s1">}</span>

  <span class="s1">if (end &lt; 0) {</span>
    <span class="s1">end += len</span>
    <span class="s1">if (end &lt; 0) end = 0</span>
  <span class="s1">} else if (end &gt; len) {</span>
    <span class="s1">end = len</span>
  <span class="s1">}</span>

  <span class="s1">if (end &lt; start) end = start</span>

  <span class="s1">var newBuf = this.subarray(start, end)</span>
  <span class="s1">// Return an augmented `Uint8Array` instance</span>
  <span class="s1">newBuf.__proto__ = Buffer.prototype</span>
  <span class="s1">return newBuf</span>
<span class="s1">}</span>

<span class="s1">/*</span>
 <span class="s1">* Need to make sure that buffer isn't trying to write out of bounds.</span>
 <span class="s1">*/</span>
<span class="s1">function checkOffset (offset, ext, length) {</span>
  <span class="s1">if ((offset % 1) !== 0 || offset &lt; 0) throw new RangeError('offset is not uint')</span>
  <span class="s1">if (offset + ext &gt; length) throw new RangeError('Trying to access beyond buffer length')</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">byteLength = byteLength &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, byteLength, this.length)</span>

  <span class="s1">var val = this[offset]</span>
  <span class="s1">var mul = 1</span>
  <span class="s1">var i = 0</span>
  <span class="s1">while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {</span>
    <span class="s1">val += this[offset + i] * mul</span>
  <span class="s1">}</span>

  <span class="s1">return val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">byteLength = byteLength &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">checkOffset(offset, byteLength, this.length)</span>
  <span class="s1">}</span>

  <span class="s1">var val = this[offset + --byteLength]</span>
  <span class="s1">var mul = 1</span>
  <span class="s1">while (byteLength &gt; 0 &amp;&amp; (mul *= 0x100)) {</span>
    <span class="s1">val += this[offset + --byteLength] * mul</span>
  <span class="s1">}</span>

  <span class="s1">return val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 1, this.length)</span>
  <span class="s1">return this[offset]</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 2, this.length)</span>
  <span class="s1">return this[offset] | (this[offset + 1] &lt;&lt; 8)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 2, this.length)</span>
  <span class="s1">return (this[offset] &lt;&lt; 8) | this[offset + 1]</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 4, this.length)</span>

  <span class="s1">return ((this[offset]) |</span>
      <span class="s1">(this[offset + 1] &lt;&lt; 8) |</span>
      <span class="s1">(this[offset + 2] &lt;&lt; 16)) +</span>
      <span class="s1">(this[offset + 3] * 0x1000000)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 4, this.length)</span>

  <span class="s1">return (this[offset] * 0x1000000) +</span>
    <span class="s1">((this[offset + 1] &lt;&lt; 16) |</span>
    <span class="s1">(this[offset + 2] &lt;&lt; 8) |</span>
    <span class="s1">this[offset + 3])</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">byteLength = byteLength &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, byteLength, this.length)</span>

  <span class="s1">var val = this[offset]</span>
  <span class="s1">var mul = 1</span>
  <span class="s1">var i = 0</span>
  <span class="s1">while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {</span>
    <span class="s1">val += this[offset + i] * mul</span>
  <span class="s1">}</span>
  <span class="s1">mul *= 0x80</span>

  <span class="s1">if (val &gt;= mul) val -= Math.pow(2, 8 * byteLength)</span>

  <span class="s1">return val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">byteLength = byteLength &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, byteLength, this.length)</span>

  <span class="s1">var i = byteLength</span>
  <span class="s1">var mul = 1</span>
  <span class="s1">var val = this[offset + --i]</span>
  <span class="s1">while (i &gt; 0 &amp;&amp; (mul *= 0x100)) {</span>
    <span class="s1">val += this[offset + --i] * mul</span>
  <span class="s1">}</span>
  <span class="s1">mul *= 0x80</span>

  <span class="s1">if (val &gt;= mul) val -= Math.pow(2, 8 * byteLength)</span>

  <span class="s1">return val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 1, this.length)</span>
  <span class="s1">if (!(this[offset] &amp; 0x80)) return (this[offset])</span>
  <span class="s1">return ((0xff - this[offset] + 1) * -1)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 2, this.length)</span>
  <span class="s1">var val = this[offset] | (this[offset + 1] &lt;&lt; 8)</span>
  <span class="s1">return (val &amp; 0x8000) ? val | 0xFFFF0000 : val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 2, this.length)</span>
  <span class="s1">var val = this[offset + 1] | (this[offset] &lt;&lt; 8)</span>
  <span class="s1">return (val &amp; 0x8000) ? val | 0xFFFF0000 : val</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 4, this.length)</span>

  <span class="s1">return (this[offset]) |</span>
    <span class="s1">(this[offset + 1] &lt;&lt; 8) |</span>
    <span class="s1">(this[offset + 2] &lt;&lt; 16) |</span>
    <span class="s1">(this[offset + 3] &lt;&lt; 24)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 4, this.length)</span>

  <span class="s1">return (this[offset] &lt;&lt; 24) |</span>
    <span class="s1">(this[offset + 1] &lt;&lt; 16) |</span>
    <span class="s1">(this[offset + 2] &lt;&lt; 8) |</span>
    <span class="s1">(this[offset + 3])</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 4, this.length)</span>
  <span class="s1">return ieee754.read(this, offset, true, 23, 4)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 4, this.length)</span>
  <span class="s1">return ieee754.read(this, offset, false, 23, 4)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 8, this.length)</span>
  <span class="s1">return ieee754.read(this, offset, true, 52, 8)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkOffset(offset, 8, this.length)</span>
  <span class="s1">return ieee754.read(this, offset, false, 52, 8)</span>
<span class="s1">}</span>

<span class="s1">function checkInt (buf, value, offset, ext, max, min) {</span>
  <span class="s1">if (!Buffer.isBuffer(buf)) throw new TypeError('&quot;buffer&quot; argument must be a Buffer instance')</span>
  <span class="s1">if (value &gt; max || value &lt; min) throw new RangeError('&quot;value&quot; argument is out of bounds')</span>
  <span class="s1">if (offset + ext &gt; buf.length) throw new RangeError('Index out of range')</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">byteLength = byteLength &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">var maxBytes = Math.pow(2, 8 * byteLength) - 1</span>
    <span class="s1">checkInt(this, value, offset, byteLength, maxBytes, 0)</span>
  <span class="s1">}</span>

  <span class="s1">var mul = 1</span>
  <span class="s1">var i = 0</span>
  <span class="s1">this[offset] = value &amp; 0xFF</span>
  <span class="s1">while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {</span>
    <span class="s1">this[offset + i] = (value / mul) &amp; 0xFF</span>
  <span class="s1">}</span>

  <span class="s1">return offset + byteLength</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">byteLength = byteLength &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">var maxBytes = Math.pow(2, 8 * byteLength) - 1</span>
    <span class="s1">checkInt(this, value, offset, byteLength, maxBytes, 0)</span>
  <span class="s1">}</span>

  <span class="s1">var i = byteLength - 1</span>
  <span class="s1">var mul = 1</span>
  <span class="s1">this[offset + i] = value &amp; 0xFF</span>
  <span class="s1">while (--i &gt;= 0 &amp;&amp; (mul *= 0x100)) {</span>
    <span class="s1">this[offset + i] = (value / mul) &amp; 0xFF</span>
  <span class="s1">}</span>

  <span class="s1">return offset + byteLength</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)</span>
  <span class="s1">this[offset] = (value &amp; 0xff)</span>
  <span class="s1">return offset + 1</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)</span>
  <span class="s1">this[offset] = (value &amp; 0xff)</span>
  <span class="s1">this[offset + 1] = (value &gt;&gt;&gt; 8)</span>
  <span class="s1">return offset + 2</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)</span>
  <span class="s1">this[offset] = (value &gt;&gt;&gt; 8)</span>
  <span class="s1">this[offset + 1] = (value &amp; 0xff)</span>
  <span class="s1">return offset + 2</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)</span>
  <span class="s1">this[offset + 3] = (value &gt;&gt;&gt; 24)</span>
  <span class="s1">this[offset + 2] = (value &gt;&gt;&gt; 16)</span>
  <span class="s1">this[offset + 1] = (value &gt;&gt;&gt; 8)</span>
  <span class="s1">this[offset] = (value &amp; 0xff)</span>
  <span class="s1">return offset + 4</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)</span>
  <span class="s1">this[offset] = (value &gt;&gt;&gt; 24)</span>
  <span class="s1">this[offset + 1] = (value &gt;&gt;&gt; 16)</span>
  <span class="s1">this[offset + 2] = (value &gt;&gt;&gt; 8)</span>
  <span class="s1">this[offset + 3] = (value &amp; 0xff)</span>
  <span class="s1">return offset + 4</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">var limit = Math.pow(2, (8 * byteLength) - 1)</span>

    <span class="s1">checkInt(this, value, offset, byteLength, limit - 1, -limit)</span>
  <span class="s1">}</span>

  <span class="s1">var i = 0</span>
  <span class="s1">var mul = 1</span>
  <span class="s1">var sub = 0</span>
  <span class="s1">this[offset] = value &amp; 0xFF</span>
  <span class="s1">while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {</span>
    <span class="s1">if (value &lt; 0 &amp;&amp; sub === 0 &amp;&amp; this[offset + i - 1] !== 0) {</span>
      <span class="s1">sub = 1</span>
    <span class="s1">}</span>
    <span class="s1">this[offset + i] = ((value / mul) &gt;&gt; 0) - sub &amp; 0xFF</span>
  <span class="s1">}</span>

  <span class="s1">return offset + byteLength</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">var limit = Math.pow(2, (8 * byteLength) - 1)</span>

    <span class="s1">checkInt(this, value, offset, byteLength, limit - 1, -limit)</span>
  <span class="s1">}</span>

  <span class="s1">var i = byteLength - 1</span>
  <span class="s1">var mul = 1</span>
  <span class="s1">var sub = 0</span>
  <span class="s1">this[offset + i] = value &amp; 0xFF</span>
  <span class="s1">while (--i &gt;= 0 &amp;&amp; (mul *= 0x100)) {</span>
    <span class="s1">if (value &lt; 0 &amp;&amp; sub === 0 &amp;&amp; this[offset + i + 1] !== 0) {</span>
      <span class="s1">sub = 1</span>
    <span class="s1">}</span>
    <span class="s1">this[offset + i] = ((value / mul) &gt;&gt; 0) - sub &amp; 0xFF</span>
  <span class="s1">}</span>

  <span class="s1">return offset + byteLength</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)</span>
  <span class="s1">if (value &lt; 0) value = 0xff + value + 1</span>
  <span class="s1">this[offset] = (value &amp; 0xff)</span>
  <span class="s1">return offset + 1</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)</span>
  <span class="s1">this[offset] = (value &amp; 0xff)</span>
  <span class="s1">this[offset + 1] = (value &gt;&gt;&gt; 8)</span>
  <span class="s1">return offset + 2</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)</span>
  <span class="s1">this[offset] = (value &gt;&gt;&gt; 8)</span>
  <span class="s1">this[offset + 1] = (value &amp; 0xff)</span>
  <span class="s1">return offset + 2</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)</span>
  <span class="s1">this[offset] = (value &amp; 0xff)</span>
  <span class="s1">this[offset + 1] = (value &gt;&gt;&gt; 8)</span>
  <span class="s1">this[offset + 2] = (value &gt;&gt;&gt; 16)</span>
  <span class="s1">this[offset + 3] = (value &gt;&gt;&gt; 24)</span>
  <span class="s1">return offset + 4</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)</span>
  <span class="s1">if (value &lt; 0) value = 0xffffffff + value + 1</span>
  <span class="s1">this[offset] = (value &gt;&gt;&gt; 24)</span>
  <span class="s1">this[offset + 1] = (value &gt;&gt;&gt; 16)</span>
  <span class="s1">this[offset + 2] = (value &gt;&gt;&gt; 8)</span>
  <span class="s1">this[offset + 3] = (value &amp; 0xff)</span>
  <span class="s1">return offset + 4</span>
<span class="s1">}</span>

<span class="s1">function checkIEEE754 (buf, value, offset, ext, max, min) {</span>
  <span class="s1">if (offset + ext &gt; buf.length) throw new RangeError('Index out of range')</span>
  <span class="s1">if (offset &lt; 0) throw new RangeError('Index out of range')</span>
<span class="s1">}</span>

<span class="s1">function writeFloat (buf, value, offset, littleEndian, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)</span>
  <span class="s1">}</span>
  <span class="s1">ieee754.write(buf, value, offset, littleEndian, 23, 4)</span>
  <span class="s1">return offset + 4</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {</span>
  <span class="s1">return writeFloat(this, value, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {</span>
  <span class="s1">return writeFloat(this, value, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">function writeDouble (buf, value, offset, littleEndian, noAssert) {</span>
  <span class="s1">value = +value</span>
  <span class="s1">offset = offset &gt;&gt;&gt; 0</span>
  <span class="s1">if (!noAssert) {</span>
    <span class="s1">checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)</span>
  <span class="s1">}</span>
  <span class="s1">ieee754.write(buf, value, offset, littleEndian, 52, 8)</span>
  <span class="s1">return offset + 8</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {</span>
  <span class="s1">return writeDouble(this, value, offset, true, noAssert)</span>
<span class="s1">}</span>

<span class="s1">Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {</span>
  <span class="s1">return writeDouble(this, value, offset, false, noAssert)</span>
<span class="s1">}</span>

<span class="s1">// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</span>
<span class="s1">Buffer.prototype.copy = function copy (target, targetStart, start, end) {</span>
  <span class="s1">if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')</span>
  <span class="s1">if (!start) start = 0</span>
  <span class="s1">if (!end &amp;&amp; end !== 0) end = this.length</span>
  <span class="s1">if (targetStart &gt;= target.length) targetStart = target.length</span>
  <span class="s1">if (!targetStart) targetStart = 0</span>
  <span class="s1">if (end &gt; 0 &amp;&amp; end &lt; start) end = start</span>

  <span class="s1">// Copy 0 bytes; we're done</span>
  <span class="s1">if (end === start) return 0</span>
  <span class="s1">if (target.length === 0 || this.length === 0) return 0</span>

  <span class="s1">// Fatal error conditions</span>
  <span class="s1">if (targetStart &lt; 0) {</span>
    <span class="s1">throw new RangeError('targetStart out of bounds')</span>
  <span class="s1">}</span>
  <span class="s1">if (start &lt; 0 || start &gt;= this.length) throw new RangeError('Index out of range')</span>
  <span class="s1">if (end &lt; 0) throw new RangeError('sourceEnd out of bounds')</span>

  <span class="s1">// Are we oob?</span>
  <span class="s1">if (end &gt; this.length) end = this.length</span>
  <span class="s1">if (target.length - targetStart &lt; end - start) {</span>
    <span class="s1">end = target.length - targetStart + start</span>
  <span class="s1">}</span>

  <span class="s1">var len = end - start</span>

  <span class="s1">if (this === target &amp;&amp; typeof Uint8Array.prototype.copyWithin === 'function') {</span>
    <span class="s1">// Use built-in when available, missing from IE11</span>
    <span class="s1">this.copyWithin(targetStart, start, end)</span>
  <span class="s1">} else if (this === target &amp;&amp; start &lt; targetStart &amp;&amp; targetStart &lt; end) {</span>
    <span class="s1">// descending copy from end</span>
    <span class="s1">for (var i = len - 1; i &gt;= 0; --i) {</span>
      <span class="s1">target[i + targetStart] = this[i + start]</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">Uint8Array.prototype.set.call(</span>
      <span class="s1">target,</span>
      <span class="s1">this.subarray(start, end),</span>
      <span class="s1">targetStart</span>
    <span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s1">return len</span>
<span class="s1">}</span>

<span class="s1">// Usage:</span>
<span class="s1">//    buffer.fill(number[, offset[, end]])</span>
<span class="s1">//    buffer.fill(buffer[, offset[, end]])</span>
<span class="s1">//    buffer.fill(string[, offset[, end]][, encoding])</span>
<span class="s1">Buffer.prototype.fill = function fill (val, start, end, encoding) {</span>
  <span class="s1">// Handle string cases:</span>
  <span class="s1">if (typeof val === 'string') {</span>
    <span class="s1">if (typeof start === 'string') {</span>
      <span class="s1">encoding = start</span>
      <span class="s1">start = 0</span>
      <span class="s1">end = this.length</span>
    <span class="s1">} else if (typeof end === 'string') {</span>
      <span class="s1">encoding = end</span>
      <span class="s1">end = this.length</span>
    <span class="s1">}</span>
    <span class="s1">if (encoding !== undefined &amp;&amp; typeof encoding !== 'string') {</span>
      <span class="s1">throw new TypeError('encoding must be a string')</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof encoding === 'string' &amp;&amp; !Buffer.isEncoding(encoding)) {</span>
      <span class="s1">throw new TypeError('Unknown encoding: ' + encoding)</span>
    <span class="s1">}</span>
    <span class="s1">if (val.length === 1) {</span>
      <span class="s1">var code = val.charCodeAt(0)</span>
      <span class="s1">if ((encoding === 'utf8' &amp;&amp; code &lt; 128) ||</span>
          <span class="s1">encoding === 'latin1') {</span>
        <span class="s1">// Fast path: If `val` fits into a single byte, use that numeric value.</span>
        <span class="s1">val = code</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} else if (typeof val === 'number') {</span>
    <span class="s1">val = val &amp; 255</span>
  <span class="s1">}</span>

  <span class="s1">// Invalid ranges are not set to a default, so can range check early.</span>
  <span class="s1">if (start &lt; 0 || this.length &lt; start || this.length &lt; end) {</span>
    <span class="s1">throw new RangeError('Out of range index')</span>
  <span class="s1">}</span>

  <span class="s1">if (end &lt;= start) {</span>
    <span class="s1">return this</span>
  <span class="s1">}</span>

  <span class="s1">start = start &gt;&gt;&gt; 0</span>
  <span class="s1">end = end === undefined ? this.length : end &gt;&gt;&gt; 0</span>

  <span class="s1">if (!val) val = 0</span>

  <span class="s1">var i</span>
  <span class="s1">if (typeof val === 'number') {</span>
    <span class="s1">for (i = start; i &lt; end; ++i) {</span>
      <span class="s1">this[i] = val</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">var bytes = Buffer.isBuffer(val)</span>
      <span class="s1">? val</span>
      <span class="s1">: Buffer.from(val, encoding)</span>
    <span class="s1">var len = bytes.length</span>
    <span class="s1">if (len === 0) {</span>
      <span class="s1">throw new TypeError('The value &quot;' + val +</span>
        <span class="s1">'&quot; is invalid for argument &quot;value&quot;')</span>
    <span class="s1">}</span>
    <span class="s1">for (i = 0; i &lt; end - start; ++i) {</span>
      <span class="s1">this[i + start] = bytes[i % len]</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return this</span>
<span class="s1">}</span>

<span class="s1">// HELPER FUNCTIONS</span>
<span class="s1">// ================</span>

<span class="s1">var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g</span>

<span class="s1">function base64clean (str) {</span>
  <span class="s1">// Node takes equal signs as end of the Base64 encoding</span>
  <span class="s1">str = str.split('=')[0]</span>
  <span class="s1">// Node strips out invalid characters like \n and \t from the string, base64-js does not</span>
  <span class="s1">str = str.trim().replace(INVALID_BASE64_RE, '')</span>
  <span class="s1">// Node converts strings with length &lt; 2 to ''</span>
  <span class="s1">if (str.length &lt; 2) return ''</span>
  <span class="s1">// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not</span>
  <span class="s1">while (str.length % 4 !== 0) {</span>
    <span class="s1">str = str + '='</span>
  <span class="s1">}</span>
  <span class="s1">return str</span>
<span class="s1">}</span>

<span class="s1">function toHex (n) {</span>
  <span class="s1">if (n &lt; 16) return '0' + n.toString(16)</span>
  <span class="s1">return n.toString(16)</span>
<span class="s1">}</span>

<span class="s1">function utf8ToBytes (string, units) {</span>
  <span class="s1">units = units || Infinity</span>
  <span class="s1">var codePoint</span>
  <span class="s1">var length = string.length</span>
  <span class="s1">var leadSurrogate = null</span>
  <span class="s1">var bytes = []</span>

  <span class="s1">for (var i = 0; i &lt; length; ++i) {</span>
    <span class="s1">codePoint = string.charCodeAt(i)</span>

    <span class="s1">// is surrogate component</span>
    <span class="s1">if (codePoint &gt; 0xD7FF &amp;&amp; codePoint &lt; 0xE000) {</span>
      <span class="s1">// last char was a lead</span>
      <span class="s1">if (!leadSurrogate) {</span>
        <span class="s1">// no lead yet</span>
        <span class="s1">if (codePoint &gt; 0xDBFF) {</span>
          <span class="s1">// unexpected trail</span>
          <span class="s1">if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)</span>
          <span class="s1">continue</span>
        <span class="s1">} else if (i + 1 === length) {</span>
          <span class="s1">// unpaired lead</span>
          <span class="s1">if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)</span>
          <span class="s1">continue</span>
        <span class="s1">}</span>

        <span class="s1">// valid lead</span>
        <span class="s1">leadSurrogate = codePoint</span>

        <span class="s1">continue</span>
      <span class="s1">}</span>

      <span class="s1">// 2 leads in a row</span>
      <span class="s1">if (codePoint &lt; 0xDC00) {</span>
        <span class="s1">if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)</span>
        <span class="s1">leadSurrogate = codePoint</span>
        <span class="s1">continue</span>
      <span class="s1">}</span>

      <span class="s1">// valid surrogate pair</span>
      <span class="s1">codePoint = (leadSurrogate - 0xD800 &lt;&lt; 10 | codePoint - 0xDC00) + 0x10000</span>
    <span class="s1">} else if (leadSurrogate) {</span>
      <span class="s1">// valid bmp char, but last char was a lead</span>
      <span class="s1">if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)</span>
    <span class="s1">}</span>

    <span class="s1">leadSurrogate = null</span>

    <span class="s1">// encode utf8</span>
    <span class="s1">if (codePoint &lt; 0x80) {</span>
      <span class="s1">if ((units -= 1) &lt; 0) break</span>
      <span class="s1">bytes.push(codePoint)</span>
    <span class="s1">} else if (codePoint &lt; 0x800) {</span>
      <span class="s1">if ((units -= 2) &lt; 0) break</span>
      <span class="s1">bytes.push(</span>
        <span class="s1">codePoint &gt;&gt; 0x6 | 0xC0,</span>
        <span class="s1">codePoint &amp; 0x3F | 0x80</span>
      <span class="s1">)</span>
    <span class="s1">} else if (codePoint &lt; 0x10000) {</span>
      <span class="s1">if ((units -= 3) &lt; 0) break</span>
      <span class="s1">bytes.push(</span>
        <span class="s1">codePoint &gt;&gt; 0xC | 0xE0,</span>
        <span class="s1">codePoint &gt;&gt; 0x6 &amp; 0x3F | 0x80,</span>
        <span class="s1">codePoint &amp; 0x3F | 0x80</span>
      <span class="s1">)</span>
    <span class="s1">} else if (codePoint &lt; 0x110000) {</span>
      <span class="s1">if ((units -= 4) &lt; 0) break</span>
      <span class="s1">bytes.push(</span>
        <span class="s1">codePoint &gt;&gt; 0x12 | 0xF0,</span>
        <span class="s1">codePoint &gt;&gt; 0xC &amp; 0x3F | 0x80,</span>
        <span class="s1">codePoint &gt;&gt; 0x6 &amp; 0x3F | 0x80,</span>
        <span class="s1">codePoint &amp; 0x3F | 0x80</span>
      <span class="s1">)</span>
    <span class="s1">} else {</span>
      <span class="s1">throw new Error('Invalid code point')</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return bytes</span>
<span class="s1">}</span>

<span class="s1">function asciiToBytes (str) {</span>
  <span class="s1">var byteArray = []</span>
  <span class="s1">for (var i = 0; i &lt; str.length; ++i) {</span>
    <span class="s1">// Node's code seems to be doing this and not &amp; 0x7F..</span>
    <span class="s1">byteArray.push(str.charCodeAt(i) &amp; 0xFF)</span>
  <span class="s1">}</span>
  <span class="s1">return byteArray</span>
<span class="s1">}</span>

<span class="s1">function utf16leToBytes (str, units) {</span>
  <span class="s1">var c, hi, lo</span>
  <span class="s1">var byteArray = []</span>
  <span class="s1">for (var i = 0; i &lt; str.length; ++i) {</span>
    <span class="s1">if ((units -= 2) &lt; 0) break</span>

    <span class="s1">c = str.charCodeAt(i)</span>
    <span class="s1">hi = c &gt;&gt; 8</span>
    <span class="s1">lo = c % 256</span>
    <span class="s1">byteArray.push(lo)</span>
    <span class="s1">byteArray.push(hi)</span>
  <span class="s1">}</span>

  <span class="s1">return byteArray</span>
<span class="s1">}</span>

<span class="s1">function base64ToBytes (str) {</span>
  <span class="s1">return base64.toByteArray(base64clean(str))</span>
<span class="s1">}</span>

<span class="s1">function blitBuffer (src, dst, offset, length) {</span>
  <span class="s1">for (var i = 0; i &lt; length; ++i) {</span>
    <span class="s1">if ((i + offset &gt;= dst.length) || (i &gt;= src.length)) break</span>
    <span class="s1">dst[i + offset] = src[i]</span>
  <span class="s1">}</span>
  <span class="s1">return i</span>
<span class="s1">}</span>

<span class="s1">// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass</span>
<span class="s1">// the `instanceof` check but they should be treated as of that type.</span>
<span class="s1">// See: https://github.com/feross/buffer/issues/166</span>
<span class="s1">function isInstance (obj, type) {</span>
  <span class="s1">return obj instanceof type ||</span>
    <span class="s1">(obj != null &amp;&amp; obj.constructor != null &amp;&amp; obj.constructor.name != null &amp;&amp;</span>
      <span class="s1">obj.constructor.name === type.name)</span>
<span class="s1">}</span>
<span class="s1">function numberIsNaN (obj) {</span>
  <span class="s1">// For IE11 support</span>
  <span class="s1">return obj !== obj // eslint-disable-line no-self-compare</span>
<span class="s1">}</span>

<span class="s1">}).call(this)}).call(this,require(&quot;buffer&quot;).Buffer)</span>

<span class="s1">},{&quot;base64-js&quot;:8,&quot;buffer&quot;:10,&quot;ieee754&quot;:46}],11:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var callBind = require('./');</span>

<span class="s1">var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));</span>

<span class="s1">module.exports = function callBoundIntrinsic(name, allowMissing) {</span>
	<span class="s1">var intrinsic = GetIntrinsic(name, !!allowMissing);</span>
	<span class="s1">if (typeof intrinsic === 'function' &amp;&amp; $indexOf(name, '.prototype.') &gt; -1) {</span>
		<span class="s1">return callBind(intrinsic);</span>
	<span class="s1">}</span>
	<span class="s1">return intrinsic;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./&quot;:12,&quot;get-intrinsic&quot;:39}],12:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var bind = require('function-bind');</span>
<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var $apply = GetIntrinsic('%Function.prototype.apply%');</span>
<span class="s1">var $call = GetIntrinsic('%Function.prototype.call%');</span>
<span class="s1">var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);</span>

<span class="s1">var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);</span>
<span class="s1">var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);</span>
<span class="s1">var $max = GetIntrinsic('%Math.max%');</span>

<span class="s1">if ($defineProperty) {</span>
	<span class="s1">try {</span>
		<span class="s1">$defineProperty({}, 'a', { value: 1 });</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">// IE 8 has a broken defineProperty</span>
		<span class="s1">$defineProperty = null;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">module.exports = function callBind(originalFunction) {</span>
	<span class="s1">var func = $reflectApply(bind, $call, arguments);</span>
	<span class="s1">if ($gOPD &amp;&amp; $defineProperty) {</span>
		<span class="s1">var desc = $gOPD(func, 'length');</span>
		<span class="s1">if (desc.configurable) {</span>
			<span class="s1">// original length, plus the receiver, minus any additional arguments (after the receiver)</span>
			<span class="s1">$defineProperty(</span>
				<span class="s1">func,</span>
				<span class="s1">'length',</span>
				<span class="s1">{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }</span>
			<span class="s1">);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return func;</span>
<span class="s1">};</span>

<span class="s1">var applyBind = function applyBind() {</span>
	<span class="s1">return $reflectApply(bind, $apply, arguments);</span>
<span class="s1">};</span>

<span class="s1">if ($defineProperty) {</span>
	<span class="s1">$defineProperty(module.exports, 'apply', { value: applyBind });</span>
<span class="s1">} else {</span>
	<span class="s1">module.exports.apply = applyBind;</span>
<span class="s1">}</span>

<span class="s1">},{&quot;function-bind&quot;:37,&quot;get-intrinsic&quot;:39}],13:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// NOTE: These type checking functions intentionally don't use `instanceof`</span>
<span class="s1">// because it is fragile and can be easily faked with `Object.create()`.</span>

<span class="s1">function isArray(arg) {</span>
  <span class="s1">if (Array.isArray) {</span>
    <span class="s1">return Array.isArray(arg);</span>
  <span class="s1">}</span>
  <span class="s1">return objectToString(arg) === '[object Array]';</span>
<span class="s1">}</span>
<span class="s1">exports.isArray = isArray;</span>

<span class="s1">function isBoolean(arg) {</span>
  <span class="s1">return typeof arg === 'boolean';</span>
<span class="s1">}</span>
<span class="s1">exports.isBoolean = isBoolean;</span>

<span class="s1">function isNull(arg) {</span>
  <span class="s1">return arg === null;</span>
<span class="s1">}</span>
<span class="s1">exports.isNull = isNull;</span>

<span class="s1">function isNullOrUndefined(arg) {</span>
  <span class="s1">return arg == null;</span>
<span class="s1">}</span>
<span class="s1">exports.isNullOrUndefined = isNullOrUndefined;</span>

<span class="s1">function isNumber(arg) {</span>
  <span class="s1">return typeof arg === 'number';</span>
<span class="s1">}</span>
<span class="s1">exports.isNumber = isNumber;</span>

<span class="s1">function isString(arg) {</span>
  <span class="s1">return typeof arg === 'string';</span>
<span class="s1">}</span>
<span class="s1">exports.isString = isString;</span>

<span class="s1">function isSymbol(arg) {</span>
  <span class="s1">return typeof arg === 'symbol';</span>
<span class="s1">}</span>
<span class="s1">exports.isSymbol = isSymbol;</span>

<span class="s1">function isUndefined(arg) {</span>
  <span class="s1">return arg === void 0;</span>
<span class="s1">}</span>
<span class="s1">exports.isUndefined = isUndefined;</span>

<span class="s1">function isRegExp(re) {</span>
  <span class="s1">return objectToString(re) === '[object RegExp]';</span>
<span class="s1">}</span>
<span class="s1">exports.isRegExp = isRegExp;</span>

<span class="s1">function isObject(arg) {</span>
  <span class="s1">return typeof arg === 'object' &amp;&amp; arg !== null;</span>
<span class="s1">}</span>
<span class="s1">exports.isObject = isObject;</span>

<span class="s1">function isDate(d) {</span>
  <span class="s1">return objectToString(d) === '[object Date]';</span>
<span class="s1">}</span>
<span class="s1">exports.isDate = isDate;</span>

<span class="s1">function isError(e) {</span>
  <span class="s1">return (objectToString(e) === '[object Error]' || e instanceof Error);</span>
<span class="s1">}</span>
<span class="s1">exports.isError = isError;</span>

<span class="s1">function isFunction(arg) {</span>
  <span class="s1">return typeof arg === 'function';</span>
<span class="s1">}</span>
<span class="s1">exports.isFunction = isFunction;</span>

<span class="s1">function isPrimitive(arg) {</span>
  <span class="s1">return arg === null ||</span>
         <span class="s1">typeof arg === 'boolean' ||</span>
         <span class="s1">typeof arg === 'number' ||</span>
         <span class="s1">typeof arg === 'string' ||</span>
         <span class="s1">typeof arg === 'symbol' ||  // ES6 symbol</span>
         <span class="s1">typeof arg === 'undefined';</span>
<span class="s1">}</span>
<span class="s1">exports.isPrimitive = isPrimitive;</span>

<span class="s1">exports.isBuffer = require('buffer').Buffer.isBuffer;</span>

<span class="s1">function objectToString(o) {</span>
  <span class="s1">return Object.prototype.toString.call(o);</span>
<span class="s1">}</span>

<span class="s1">},{&quot;buffer&quot;:10}],14:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var objectKeys = require('object-keys');</span>
<span class="s1">var isArguments = require('is-arguments');</span>
<span class="s1">var is = require('object-is');</span>
<span class="s1">var isRegex = require('is-regex');</span>
<span class="s1">var flags = require('regexp.prototype.flags');</span>
<span class="s1">var isArray = require('isarray');</span>
<span class="s1">var isDate = require('is-date-object');</span>
<span class="s1">var whichBoxedPrimitive = require('which-boxed-primitive');</span>
<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var whichCollection = require('which-collection');</span>
<span class="s1">var getIterator = require('es-get-iterator');</span>
<span class="s1">var getSideChannel = require('side-channel');</span>
<span class="s1">var whichTypedArray = require('which-typed-array');</span>
<span class="s1">var assign = require('object.assign');</span>

<span class="s1">var $getTime = callBound('Date.prototype.getTime');</span>
<span class="s1">var gPO = Object.getPrototypeOf;</span>
<span class="s1">var $objToString = callBound('Object.prototype.toString');</span>

<span class="s1">var $Set = GetIntrinsic('%Set%', true);</span>
<span class="s1">var $mapHas = callBound('Map.prototype.has', true);</span>
<span class="s1">var $mapGet = callBound('Map.prototype.get', true);</span>
<span class="s1">var $mapSize = callBound('Map.prototype.size', true);</span>
<span class="s1">var $setAdd = callBound('Set.prototype.add', true);</span>
<span class="s1">var $setDelete = callBound('Set.prototype.delete', true);</span>
<span class="s1">var $setHas = callBound('Set.prototype.has', true);</span>
<span class="s1">var $setSize = callBound('Set.prototype.size', true);</span>

<span class="s1">// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414</span>
<span class="s1">function setHasEqualElement(set, val1, opts, channel) {</span>
  <span class="s1">var i = getIterator(set);</span>
  <span class="s1">var result;</span>
  <span class="s1">while ((result = i.next()) &amp;&amp; !result.done) {</span>
    <span class="s1">if (internalDeepEqual(val1, result.value, opts, channel)) { // eslint-disable-line no-use-before-define</span>
      <span class="s1">// Remove the matching element to make sure we do not check that again.</span>
      <span class="s1">$setDelete(set, result.value);</span>
      <span class="s1">return true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439</span>
<span class="s1">function findLooseMatchingPrimitives(prim) {</span>
  <span class="s1">if (typeof prim === 'undefined') {</span>
    <span class="s1">return null;</span>
  <span class="s1">}</span>
  <span class="s1">if (typeof prim === 'object') { // Only pass in null as object!</span>
    <span class="s1">return void 0;</span>
  <span class="s1">}</span>
  <span class="s1">if (typeof prim === 'symbol') {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>
  <span class="s1">if (typeof prim === 'string' || typeof prim === 'number') {</span>
    <span class="s1">// Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.</span>
    <span class="s1">return +prim === +prim; // eslint-disable-line no-implicit-coercion</span>
  <span class="s1">}</span>
  <span class="s1">return true;</span>
<span class="s1">}</span>

<span class="s1">// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460</span>
<span class="s1">function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {</span>
  <span class="s1">var altValue = findLooseMatchingPrimitives(prim);</span>
  <span class="s1">if (altValue != null) {</span>
    <span class="s1">return altValue;</span>
  <span class="s1">}</span>
  <span class="s1">var curB = $mapGet(b, altValue);</span>
  <span class="s1">var looseOpts = assign({}, opts, { strict: false });</span>
  <span class="s1">if (</span>
    <span class="s1">(typeof curB === 'undefined' &amp;&amp; !$mapHas(b, altValue))</span>
    <span class="s1">// eslint-disable-next-line no-use-before-define</span>
    <span class="s1">|| !internalDeepEqual(item, curB, looseOpts, channel)</span>
  <span class="s1">) {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>
  <span class="s1">// eslint-disable-next-line no-use-before-define</span>
  <span class="s1">return !$mapHas(a, altValue) &amp;&amp; internalDeepEqual(item, curB, looseOpts, channel);</span>
<span class="s1">}</span>

<span class="s1">// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447</span>
<span class="s1">function setMightHaveLoosePrim(a, b, prim) {</span>
  <span class="s1">var altValue = findLooseMatchingPrimitives(prim);</span>
  <span class="s1">if (altValue != null) {</span>
    <span class="s1">return altValue;</span>
  <span class="s1">}</span>

  <span class="s1">return $setHas(b, altValue) &amp;&amp; !$setHas(a, altValue);</span>
<span class="s1">}</span>

<span class="s1">// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533</span>
<span class="s1">function mapHasEqualEntry(set, map, key1, item1, opts, channel) {</span>
  <span class="s1">var i = getIterator(set);</span>
  <span class="s1">var result;</span>
  <span class="s1">var key2;</span>
  <span class="s1">while ((result = i.next()) &amp;&amp; !result.done) {</span>
    <span class="s1">key2 = result.value;</span>
    <span class="s1">if (</span>
      <span class="s1">// eslint-disable-next-line no-use-before-define</span>
      <span class="s1">internalDeepEqual(key1, key2, opts, channel)</span>
      <span class="s1">// eslint-disable-next-line no-use-before-define</span>
      <span class="s1">&amp;&amp; internalDeepEqual(item1, $mapGet(map, key2), opts, channel)</span>
    <span class="s1">) {</span>
      <span class="s1">$setDelete(set, key2);</span>
      <span class="s1">return true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function internalDeepEqual(actual, expected, options, channel) {</span>
  <span class="s1">var opts = options || {};</span>

  <span class="s1">// 7.1. All identical values are equivalent, as determined by ===.</span>
  <span class="s1">if (opts.strict ? is(actual, expected) : actual === expected) {</span>
    <span class="s1">return true;</span>
  <span class="s1">}</span>

  <span class="s1">var actualBoxed = whichBoxedPrimitive(actual);</span>
  <span class="s1">var expectedBoxed = whichBoxedPrimitive(expected);</span>
  <span class="s1">if (actualBoxed !== expectedBoxed) {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>

  <span class="s1">// 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.</span>
  <span class="s1">if (!actual || !expected || (typeof actual !== 'object' &amp;&amp; typeof expected !== 'object')) {</span>
    <span class="s1">return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq</span>
  <span class="s1">}</span>

  <span class="s1">/*</span>
   <span class="s1">* 7.4. For all other Object pairs, including Array objects, equivalence is</span>
   <span class="s1">* determined by having the same number of owned properties (as verified</span>
   <span class="s1">* with Object.prototype.hasOwnProperty.call), the same set of keys</span>
   <span class="s1">* (although not necessarily the same order), equivalent values for every</span>
   <span class="s1">* corresponding key, and an identical 'prototype' property. Note: this</span>
   <span class="s1">* accounts for both named and indexed properties on Arrays.</span>
   <span class="s1">*/</span>
  <span class="s1">// see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration</span>

  <span class="s1">var hasActual = channel.has(actual);</span>
  <span class="s1">var hasExpected = channel.has(expected);</span>
  <span class="s1">var sentinel;</span>
  <span class="s1">if (hasActual &amp;&amp; hasExpected) {</span>
    <span class="s1">if (channel.get(actual) === channel.get(expected)) {</span>
      <span class="s1">return true;</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">sentinel = {};</span>
  <span class="s1">}</span>
  <span class="s1">if (!hasActual) { channel.set(actual, sentinel); }</span>
  <span class="s1">if (!hasExpected) { channel.set(expected, sentinel); }</span>

  <span class="s1">// eslint-disable-next-line no-use-before-define</span>
  <span class="s1">return objEquiv(actual, expected, opts, channel);</span>
<span class="s1">}</span>

<span class="s1">function isBuffer(x) {</span>
  <span class="s1">if (!x || typeof x !== 'object' || typeof x.length !== 'number') {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>
  <span class="s1">if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>
  <span class="s1">if (x.length &gt; 0 &amp;&amp; typeof x[0] !== 'number') {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>

  <span class="s1">return !!(x.constructor &amp;&amp; x.constructor.isBuffer &amp;&amp; x.constructor.isBuffer(x));</span>
<span class="s1">}</span>

<span class="s1">function setEquiv(a, b, opts, channel) {</span>
  <span class="s1">if ($setSize(a) !== $setSize(b)) {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>
  <span class="s1">var iA = getIterator(a);</span>
  <span class="s1">var iB = getIterator(b);</span>
  <span class="s1">var resultA;</span>
  <span class="s1">var resultB;</span>
  <span class="s1">var set;</span>
  <span class="s1">while ((resultA = iA.next()) &amp;&amp; !resultA.done) {</span>
    <span class="s1">if (resultA.value &amp;&amp; typeof resultA.value === 'object') {</span>
      <span class="s1">if (!set) { set = new $Set(); }</span>
      <span class="s1">$setAdd(set, resultA.value);</span>
    <span class="s1">} else if (!$setHas(b, resultA.value)) {</span>
      <span class="s1">if (opts.strict) { return false; }</span>
      <span class="s1">if (!setMightHaveLoosePrim(a, b, resultA.value)) {</span>
        <span class="s1">return false;</span>
      <span class="s1">}</span>
      <span class="s1">if (!set) { set = new $Set(); }</span>
      <span class="s1">$setAdd(set, resultA.value);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">if (set) {</span>
    <span class="s1">while ((resultB = iB.next()) &amp;&amp; !resultB.done) {</span>
      <span class="s1">// We have to check if a primitive value is already matching and only if it's not, go hunting for it.</span>
      <span class="s1">if (resultB.value &amp;&amp; typeof resultB.value === 'object') {</span>
        <span class="s1">if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {</span>
          <span class="s1">return false;</span>
        <span class="s1">}</span>
      <span class="s1">} else if (</span>
        <span class="s1">!opts.strict</span>
        <span class="s1">&amp;&amp; !$setHas(a, resultB.value)</span>
        <span class="s1">&amp;&amp; !setHasEqualElement(set, resultB.value, opts.strict, channel)</span>
      <span class="s1">) {</span>
        <span class="s1">return false;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return $setSize(set) === 0;</span>
  <span class="s1">}</span>
  <span class="s1">return true;</span>
<span class="s1">}</span>

<span class="s1">function mapEquiv(a, b, opts, channel) {</span>
  <span class="s1">if ($mapSize(a) !== $mapSize(b)) {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>
  <span class="s1">var iA = getIterator(a);</span>
  <span class="s1">var iB = getIterator(b);</span>
  <span class="s1">var resultA;</span>
  <span class="s1">var resultB;</span>
  <span class="s1">var set;</span>
  <span class="s1">var key;</span>
  <span class="s1">var item1;</span>
  <span class="s1">var item2;</span>
  <span class="s1">while ((resultA = iA.next()) &amp;&amp; !resultA.done) {</span>
    <span class="s1">key = resultA.value[0];</span>
    <span class="s1">item1 = resultA.value[1];</span>
    <span class="s1">if (key &amp;&amp; typeof key === 'object') {</span>
      <span class="s1">if (!set) { set = new $Set(); }</span>
      <span class="s1">$setAdd(set, key);</span>
    <span class="s1">} else {</span>
      <span class="s1">item2 = $mapGet(b, key);</span>
      <span class="s1">if ((typeof item2 === 'undefined' &amp;&amp; !$mapHas(b, key)) || !internalDeepEqual(item1, item2, opts, channel)) {</span>
        <span class="s1">if (opts.strict) {</span>
          <span class="s1">return false;</span>
        <span class="s1">}</span>
        <span class="s1">if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {</span>
          <span class="s1">return false;</span>
        <span class="s1">}</span>
        <span class="s1">if (!set) { set = new $Set(); }</span>
        <span class="s1">$setAdd(set, key);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (set) {</span>
    <span class="s1">while ((resultB = iB.next()) &amp;&amp; !resultB.done) {</span>
      <span class="s1">key = resultB.value[0];</span>
      <span class="s1">item2 = resultB.value[1];</span>
      <span class="s1">if (key &amp;&amp; typeof key === 'object') {</span>
        <span class="s1">if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {</span>
          <span class="s1">return false;</span>
        <span class="s1">}</span>
      <span class="s1">} else if (</span>
        <span class="s1">!opts.strict</span>
        <span class="s1">&amp;&amp; (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel))</span>
        <span class="s1">&amp;&amp; !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)</span>
      <span class="s1">) {</span>
        <span class="s1">return false;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return $setSize(set) === 0;</span>
  <span class="s1">}</span>
  <span class="s1">return true;</span>
<span class="s1">}</span>

<span class="s1">function objEquiv(a, b, opts, channel) {</span>
  <span class="s1">/* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5] */</span>
  <span class="s1">var i, key;</span>

  <span class="s1">if (typeof a !== typeof b) { return false; }</span>
  <span class="s1">if (a == null || b == null) { return false; }</span>

  <span class="s1">if ($objToString(a) !== $objToString(b)) { return false; }</span>

  <span class="s1">if (isArguments(a) !== isArguments(b)) { return false; }</span>

  <span class="s1">var aIsArray = isArray(a);</span>
  <span class="s1">var bIsArray = isArray(b);</span>
  <span class="s1">if (aIsArray !== bIsArray) { return false; }</span>

  <span class="s1">// TODO: replace when a cross-realm brand check is available</span>
  <span class="s1">var aIsError = a instanceof Error;</span>
  <span class="s1">var bIsError = b instanceof Error;</span>
  <span class="s1">if (aIsError !== bIsError) { return false; }</span>
  <span class="s1">if (aIsError || bIsError) {</span>
    <span class="s1">if (a.name !== b.name || a.message !== b.message) { return false; }</span>
  <span class="s1">}</span>

  <span class="s1">var aIsRegex = isRegex(a);</span>
  <span class="s1">var bIsRegex = isRegex(b);</span>
  <span class="s1">if (aIsRegex !== bIsRegex) { return false; }</span>
  <span class="s1">if ((aIsRegex || bIsRegex) &amp;&amp; (a.source !== b.source || flags(a) !== flags(b))) {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>

  <span class="s1">var aIsDate = isDate(a);</span>
  <span class="s1">var bIsDate = isDate(b);</span>
  <span class="s1">if (aIsDate !== bIsDate) { return false; }</span>
  <span class="s1">if (aIsDate || bIsDate) { // &amp;&amp; would work too, because both are true or both false here</span>
    <span class="s1">if ($getTime(a) !== $getTime(b)) { return false; }</span>
  <span class="s1">}</span>
  <span class="s1">if (opts.strict &amp;&amp; gPO &amp;&amp; gPO(a) !== gPO(b)) { return false; }</span>

  <span class="s1">if (whichTypedArray(a) !== whichTypedArray(b)) {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>

  <span class="s1">var aIsBuffer = isBuffer(a);</span>
  <span class="s1">var bIsBuffer = isBuffer(b);</span>
  <span class="s1">if (aIsBuffer !== bIsBuffer) { return false; }</span>
  <span class="s1">if (aIsBuffer || bIsBuffer) { // &amp;&amp; would work too, because both are true or both false here</span>
    <span class="s1">if (a.length !== b.length) { return false; }</span>
    <span class="s1">for (i = 0; i &lt; a.length; i++) {</span>
      <span class="s1">if (a[i] !== b[i]) { return false; }</span>
    <span class="s1">}</span>
    <span class="s1">return true;</span>
  <span class="s1">}</span>

  <span class="s1">if (typeof a !== typeof b) { return false; }</span>

  <span class="s1">var ka = objectKeys(a);</span>
  <span class="s1">var kb = objectKeys(b);</span>
  <span class="s1">// having the same number of owned properties (keys incorporates hasOwnProperty)</span>
  <span class="s1">if (ka.length !== kb.length) { return false; }</span>

  <span class="s1">// the same set of keys (although not necessarily the same order),</span>
  <span class="s1">ka.sort();</span>
  <span class="s1">kb.sort();</span>
  <span class="s1">// ~~~cheap key test</span>
  <span class="s1">for (i = ka.length - 1; i &gt;= 0; i--) {</span>
    <span class="s1">if (ka[i] != kb[i]) { return false; } // eslint-disable-line eqeqeq</span>
  <span class="s1">}</span>

  <span class="s1">// equivalent values for every corresponding key, and ~~~possibly expensive deep test</span>
  <span class="s1">for (i = ka.length - 1; i &gt;= 0; i--) {</span>
    <span class="s1">key = ka[i];</span>
    <span class="s1">if (!internalDeepEqual(a[key], b[key], opts, channel)) { return false; }</span>
  <span class="s1">}</span>

  <span class="s1">var aCollection = whichCollection(a);</span>
  <span class="s1">var bCollection = whichCollection(b);</span>
  <span class="s1">if (aCollection !== bCollection) {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>
  <span class="s1">if (aCollection === 'Set' || bCollection === 'Set') { // aCollection === bCollection</span>
    <span class="s1">return setEquiv(a, b, opts, channel);</span>
  <span class="s1">}</span>
  <span class="s1">if (aCollection === 'Map') { // aCollection === bCollection</span>
    <span class="s1">return mapEquiv(a, b, opts, channel);</span>
  <span class="s1">}</span>

  <span class="s1">return true;</span>
<span class="s1">}</span>

<span class="s1">module.exports = function deepEqual(a, b, opts) {</span>
  <span class="s1">return internalDeepEqual(a, b, opts, getSideChannel());</span>
<span class="s1">};</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;es-get-iterator&quot;:29,&quot;get-intrinsic&quot;:39,&quot;is-arguments&quot;:48,&quot;is-date-object&quot;:52,&quot;is-regex&quot;:55,&quot;isarray&quot;:15,&quot;object-is&quot;:67,&quot;object-keys&quot;:71,&quot;object.assign&quot;:74,&quot;regexp.prototype.flags&quot;:96,&quot;side-channel&quot;:100,&quot;which-boxed-primitive&quot;:113,&quot;which-collection&quot;:114,&quot;which-typed-array&quot;:115}],15:[function(require,module,exports){</span>
<span class="s1">var toString = {}.toString;</span>

<span class="s1">module.exports = Array.isArray || function (arr) {</span>
  <span class="s1">return toString.call(arr) == '[object Array]';</span>
<span class="s1">};</span>

<span class="s1">},{}],16:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var keys = require('object-keys');</span>
<span class="s1">var hasSymbols = typeof Symbol === 'function' &amp;&amp; typeof Symbol('foo') === 'symbol';</span>

<span class="s1">var toStr = Object.prototype.toString;</span>
<span class="s1">var concat = Array.prototype.concat;</span>
<span class="s1">var origDefineProperty = Object.defineProperty;</span>

<span class="s1">var isFunction = function (fn) {</span>
	<span class="s1">return typeof fn === 'function' &amp;&amp; toStr.call(fn) === '[object Function]';</span>
<span class="s1">};</span>

<span class="s1">var hasPropertyDescriptors = require('has-property-descriptors')();</span>

<span class="s1">var supportsDescriptors = origDefineProperty &amp;&amp; hasPropertyDescriptors;</span>

<span class="s1">var defineProperty = function (object, name, value, predicate) {</span>
	<span class="s1">if (name in object &amp;&amp; (!isFunction(predicate) || !predicate())) {</span>
		<span class="s1">return;</span>
	<span class="s1">}</span>
	<span class="s1">if (supportsDescriptors) {</span>
		<span class="s1">origDefineProperty(object, name, {</span>
			<span class="s1">configurable: true,</span>
			<span class="s1">enumerable: false,</span>
			<span class="s1">value: value,</span>
			<span class="s1">writable: true</span>
		<span class="s1">});</span>
	<span class="s1">} else {</span>
		<span class="s1">object[name] = value; // eslint-disable-line no-param-reassign</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">var defineProperties = function (object, map) {</span>
	<span class="s1">var predicates = arguments.length &gt; 2 ? arguments[2] : {};</span>
	<span class="s1">var props = keys(map);</span>
	<span class="s1">if (hasSymbols) {</span>
		<span class="s1">props = concat.call(props, Object.getOwnPropertySymbols(map));</span>
	<span class="s1">}</span>
	<span class="s1">for (var i = 0; i &lt; props.length; i += 1) {</span>
		<span class="s1">defineProperty(object, props[i], map[props[i]], predicates[props[i]]);</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">defineProperties.supportsDescriptors = !!supportsDescriptors;</span>

<span class="s1">module.exports = defineProperties;</span>

<span class="s1">},{&quot;has-property-descriptors&quot;:41,&quot;object-keys&quot;:71}],17:[function(require,module,exports){</span>
<span class="s1">module.exports = function () {</span>
    <span class="s1">for (var i = 0; i &lt; arguments.length; i++) {</span>
        <span class="s1">if (arguments[i] !== undefined) return arguments[i];</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">},{}],18:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">// http://262.ecma-international.org/5.1/#sec-9.11</span>

<span class="s1">module.exports = require('is-callable');</span>

<span class="s1">},{&quot;is-callable&quot;:51}],19:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">module.exports = require('../5/CheckObjectCoercible');</span>

<span class="s1">},{&quot;../5/CheckObjectCoercible&quot;:25}],20:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var $TypeError = GetIntrinsic('%TypeError%');</span>
<span class="s1">var $Number = GetIntrinsic('%Number%');</span>
<span class="s1">var $RegExp = GetIntrinsic('%RegExp%');</span>
<span class="s1">var $parseInteger = GetIntrinsic('%parseInt%');</span>

<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var regexTester = require('../helpers/regexTester');</span>
<span class="s1">var isPrimitive = require('../helpers/isPrimitive');</span>

<span class="s1">var $strSlice = callBound('String.prototype.slice');</span>
<span class="s1">var isBinary = regexTester(/^0b[01]+$/i);</span>
<span class="s1">var isOctal = regexTester(/^0o[0-7]+$/i);</span>
<span class="s1">var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);</span>
<span class="s1">var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');</span>
<span class="s1">var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');</span>
<span class="s1">var hasNonWS = regexTester(nonWSregex);</span>

<span class="s1">// whitespace from: https://es5.github.io/#x15.5.4.20</span>
<span class="s1">// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324</span>
<span class="s1">var ws = [</span>
	<span class="s1">'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',</span>
	<span class="s1">'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',</span>
	<span class="s1">'\u2029\uFEFF'</span>
<span class="s1">].join('');</span>
<span class="s1">var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');</span>
<span class="s1">var $replace = callBound('String.prototype.replace');</span>
<span class="s1">var $trim = function (value) {</span>
	<span class="s1">return $replace(value, trimRegex, '');</span>
<span class="s1">};</span>

<span class="s1">var ToPrimitive = require('./ToPrimitive');</span>

<span class="s1">// https://ecma-international.org/ecma-262/6.0/#sec-tonumber</span>

<span class="s1">module.exports = function ToNumber(argument) {</span>
	<span class="s1">var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);</span>
	<span class="s1">if (typeof value === 'symbol') {</span>
		<span class="s1">throw new $TypeError('Cannot convert a Symbol value to a number');</span>
	<span class="s1">}</span>
	<span class="s1">if (typeof value === 'bigint') {</span>
		<span class="s1">throw new $TypeError('Conversion from \'BigInt\' to \'number\' is not allowed.');</span>
	<span class="s1">}</span>
	<span class="s1">if (typeof value === 'string') {</span>
		<span class="s1">if (isBinary(value)) {</span>
			<span class="s1">return ToNumber($parseInteger($strSlice(value, 2), 2));</span>
		<span class="s1">} else if (isOctal(value)) {</span>
			<span class="s1">return ToNumber($parseInteger($strSlice(value, 2), 8));</span>
		<span class="s1">} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {</span>
			<span class="s1">return NaN;</span>
		<span class="s1">}</span>
		<span class="s1">var trimmed = $trim(value);</span>
		<span class="s1">if (trimmed !== value) {</span>
			<span class="s1">return ToNumber(trimmed);</span>
		<span class="s1">}</span>

	<span class="s1">}</span>
	<span class="s1">return $Number(value);</span>
<span class="s1">};</span>

<span class="s1">},{&quot;../helpers/isPrimitive&quot;:27,&quot;../helpers/regexTester&quot;:28,&quot;./ToPrimitive&quot;:22,&quot;call-bind/callBound&quot;:11,&quot;get-intrinsic&quot;:39}],21:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var $Object = GetIntrinsic('%Object%');</span>

<span class="s1">var RequireObjectCoercible = require('./RequireObjectCoercible');</span>

<span class="s1">// https://ecma-international.org/ecma-262/6.0/#sec-toobject</span>

<span class="s1">module.exports = function ToObject(value) {</span>
	<span class="s1">RequireObjectCoercible(value);</span>
	<span class="s1">return $Object(value);</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./RequireObjectCoercible&quot;:19,&quot;get-intrinsic&quot;:39}],22:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var toPrimitive = require('es-to-primitive/es2015');</span>

<span class="s1">// https://ecma-international.org/ecma-262/6.0/#sec-toprimitive</span>

<span class="s1">module.exports = function ToPrimitive(input) {</span>
	<span class="s1">if (arguments.length &gt; 1) {</span>
		<span class="s1">return toPrimitive(input, arguments[1]);</span>
	<span class="s1">}</span>
	<span class="s1">return toPrimitive(input);</span>
<span class="s1">};</span>

<span class="s1">},{&quot;es-to-primitive/es2015&quot;:31}],23:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var $String = GetIntrinsic('%String%');</span>
<span class="s1">var $TypeError = GetIntrinsic('%TypeError%');</span>

<span class="s1">// https://ecma-international.org/ecma-262/6.0/#sec-tostring</span>

<span class="s1">module.exports = function ToString(argument) {</span>
	<span class="s1">if (typeof argument === 'symbol') {</span>
		<span class="s1">throw new $TypeError('Cannot convert a Symbol value to a string');</span>
	<span class="s1">}</span>
	<span class="s1">return $String(argument);</span>
<span class="s1">};</span>

<span class="s1">},{&quot;get-intrinsic&quot;:39}],24:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var ToNumber = require('./ToNumber');</span>

<span class="s1">// http://262.ecma-international.org/5.1/#sec-9.6</span>

<span class="s1">module.exports = function ToUint32(x) {</span>
	<span class="s1">return ToNumber(x) &gt;&gt;&gt; 0;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./ToNumber&quot;:20}],25:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var $TypeError = GetIntrinsic('%TypeError%');</span>

<span class="s1">// http://262.ecma-international.org/5.1/#sec-9.10</span>

<span class="s1">module.exports = function CheckObjectCoercible(value, optMessage) {</span>
	<span class="s1">if (value == null) {</span>
		<span class="s1">throw new $TypeError(optMessage || ('Cannot call method on ' + value));</span>
	<span class="s1">}</span>
	<span class="s1">return value;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;get-intrinsic&quot;:39}],26:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);</span>
<span class="s1">if ($gOPD) {</span>
	<span class="s1">try {</span>
		<span class="s1">$gOPD([], 'length');</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">// IE 8 has a broken gOPD</span>
		<span class="s1">$gOPD = null;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">module.exports = $gOPD;</span>

<span class="s1">},{&quot;get-intrinsic&quot;:39}],27:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">module.exports = function isPrimitive(value) {</span>
	<span class="s1">return value === null || (typeof value !== 'function' &amp;&amp; typeof value !== 'object');</span>
<span class="s1">};</span>

<span class="s1">},{}],28:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var $test = GetIntrinsic('RegExp.prototype.test');</span>

<span class="s1">var callBind = require('call-bind');</span>

<span class="s1">module.exports = function regexTester(regex) {</span>
	<span class="s1">return callBind($test, regex);</span>
<span class="s1">};</span>

<span class="s1">},{&quot;call-bind&quot;:12,&quot;get-intrinsic&quot;:39}],29:[function(require,module,exports){</span>
<span class="s1">(function (process){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">/* eslint global-require: 0 */</span>
<span class="s1">// the code is structured this way so that bundlers can</span>
<span class="s1">// alias out `has-symbols` to `() =&gt; true` or `() =&gt; false` if your target</span>
<span class="s1">// environments' Symbol capabilities are known, and then use</span>
<span class="s1">// dead code elimination on the rest of this module.</span>
<span class="s1">//</span>
<span class="s1">// Similarly, `isarray` can be aliased to `Array.isArray` if</span>
<span class="s1">// available in all target environments.</span>

<span class="s1">var isArguments = require('is-arguments');</span>

<span class="s1">if (require('has-symbols')() || require('has-symbols/shams')()) {</span>
	<span class="s1">var $iterator = Symbol.iterator;</span>
	<span class="s1">// Symbol is available natively or shammed</span>
	<span class="s1">// natively:</span>
	<span class="s1">//  - Chrome &gt;= 38</span>
	<span class="s1">//  - Edge 12-14?, Edge &gt;= 15 for sure</span>
	<span class="s1">//  - FF &gt;= 36</span>
	<span class="s1">//  - Safari &gt;= 9</span>
	<span class="s1">//  - node &gt;= 0.12</span>
	<span class="s1">module.exports = function getIterator(iterable) {</span>
		<span class="s1">// alternatively, `iterable[$iterator]?.()`</span>
		<span class="s1">if (iterable != null &amp;&amp; typeof iterable[$iterator] !== 'undefined') {</span>
			<span class="s1">return iterable[$iterator]();</span>
		<span class="s1">}</span>
		<span class="s1">if (isArguments(iterable)) {</span>
			<span class="s1">// arguments objects lack Symbol.iterator</span>
			<span class="s1">// - node 0.12</span>
			<span class="s1">return Array.prototype[$iterator].call(iterable);</span>
		<span class="s1">}</span>
	<span class="s1">};</span>
<span class="s1">} else {</span>
	<span class="s1">// Symbol is not available, native or shammed</span>
	<span class="s1">var isArray = require('isarray');</span>
	<span class="s1">var isString = require('is-string');</span>
	<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>
	<span class="s1">var $Map = GetIntrinsic('%Map%', true);</span>
	<span class="s1">var $Set = GetIntrinsic('%Set%', true);</span>
	<span class="s1">var callBound = require('call-bind/callBound');</span>
	<span class="s1">var $arrayPush = callBound('Array.prototype.push');</span>
	<span class="s1">var $charCodeAt = callBound('String.prototype.charCodeAt');</span>
	<span class="s1">var $stringSlice = callBound('String.prototype.slice');</span>

	<span class="s1">var advanceStringIndex = function advanceStringIndex(S, index) {</span>
		<span class="s1">var length = S.length;</span>
		<span class="s1">if ((index + 1) &gt;= length) {</span>
			<span class="s1">return index + 1;</span>
		<span class="s1">}</span>

		<span class="s1">var first = $charCodeAt(S, index);</span>
		<span class="s1">if (first &lt; 0xD800 || first &gt; 0xDBFF) {</span>
			<span class="s1">return index + 1;</span>
		<span class="s1">}</span>

		<span class="s1">var second = $charCodeAt(S, index + 1);</span>
		<span class="s1">if (second &lt; 0xDC00 || second &gt; 0xDFFF) {</span>
			<span class="s1">return index + 1;</span>
		<span class="s1">}</span>

		<span class="s1">return index + 2;</span>
	<span class="s1">};</span>

	<span class="s1">var getArrayIterator = function getArrayIterator(arraylike) {</span>
		<span class="s1">var i = 0;</span>
		<span class="s1">return {</span>
			<span class="s1">next: function next() {</span>
				<span class="s1">var done = i &gt;= arraylike.length;</span>
				<span class="s1">var value;</span>
				<span class="s1">if (!done) {</span>
					<span class="s1">value = arraylike[i];</span>
					<span class="s1">i += 1;</span>
				<span class="s1">}</span>
				<span class="s1">return {</span>
					<span class="s1">done: done,</span>
					<span class="s1">value: value</span>
				<span class="s1">};</span>
			<span class="s1">}</span>
		<span class="s1">};</span>
	<span class="s1">};</span>

	<span class="s1">var getNonCollectionIterator = function getNonCollectionIterator(iterable, noPrimordialCollections) {</span>
		<span class="s1">if (isArray(iterable) || isArguments(iterable)) {</span>
			<span class="s1">return getArrayIterator(iterable);</span>
		<span class="s1">}</span>
		<span class="s1">if (isString(iterable)) {</span>
			<span class="s1">var i = 0;</span>
			<span class="s1">return {</span>
				<span class="s1">next: function next() {</span>
					<span class="s1">var nextIndex = advanceStringIndex(iterable, i);</span>
					<span class="s1">var value = $stringSlice(iterable, i, nextIndex);</span>
					<span class="s1">i = nextIndex;</span>
					<span class="s1">return {</span>
						<span class="s1">done: nextIndex &gt; iterable.length,</span>
						<span class="s1">value: value</span>
					<span class="s1">};</span>
				<span class="s1">}</span>
			<span class="s1">};</span>
		<span class="s1">}</span>

		<span class="s1">// es6-shim and es-shims' es-map use a string &quot;_es6-shim iterator_&quot; property on different iterables, such as MapIterator.</span>
		<span class="s1">if (noPrimordialCollections &amp;&amp; typeof iterable['_es6-shim iterator_'] !== 'undefined') {</span>
			<span class="s1">return iterable['_es6-shim iterator_']();</span>
		<span class="s1">}</span>
	<span class="s1">};</span>

	<span class="s1">if (!$Map &amp;&amp; !$Set) {</span>
		<span class="s1">// the only language iterables are Array, String, arguments</span>
		<span class="s1">// - Safari &lt;= 6.0</span>
		<span class="s1">// - Chrome &lt; 38</span>
		<span class="s1">// - node &lt; 0.12</span>
		<span class="s1">// - FF &lt; 13</span>
		<span class="s1">// - IE &lt; 11</span>
		<span class="s1">// - Edge &lt; 11</span>

		<span class="s1">module.exports = function getIterator(iterable) {</span>
			<span class="s1">if (iterable != null) {</span>
				<span class="s1">return getNonCollectionIterator(iterable, true);</span>
			<span class="s1">}</span>
		<span class="s1">};</span>
	<span class="s1">} else {</span>
		<span class="s1">// either Map or Set are available, but Symbol is not</span>
		<span class="s1">// - es6-shim on an ES5 browser</span>
		<span class="s1">// - Safari 6.2 (maybe 6.1?)</span>
		<span class="s1">// - FF v[13, 36)</span>
		<span class="s1">// - IE 11</span>
		<span class="s1">// - Edge 11</span>
		<span class="s1">// - Safari v[6, 9)</span>

		<span class="s1">var isMap = require('is-map');</span>
		<span class="s1">var isSet = require('is-set');</span>

		<span class="s1">// Firefox &gt;= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach</span>
		<span class="s1">var $mapForEach = callBound('Map.prototype.forEach', true);</span>
		<span class="s1">var $setForEach = callBound('Set.prototype.forEach', true);</span>
		<span class="s1">if (typeof process === 'undefined' || !process.versions || !process.versions.node) { // &quot;if is not node&quot;</span>

			<span class="s1">// Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either</span>
			<span class="s1">// returns a value, or throws a StopIteration object. These browsers</span>
			<span class="s1">// do not have any other mechanism for iteration.</span>
			<span class="s1">var $mapIterator = callBound('Map.prototype.iterator', true);</span>
			<span class="s1">var $setIterator = callBound('Set.prototype.iterator', true);</span>
			<span class="s1">var getStopIterationIterator = function (iterator) {</span>
				<span class="s1">var done = false;</span>
				<span class="s1">return {</span>
					<span class="s1">next: function next() {</span>
						<span class="s1">try {</span>
							<span class="s1">return {</span>
								<span class="s1">done: done,</span>
								<span class="s1">value: done ? undefined : iterator.next()</span>
							<span class="s1">};</span>
						<span class="s1">} catch (e) {</span>
							<span class="s1">done = true;</span>
							<span class="s1">return {</span>
								<span class="s1">done: true,</span>
								<span class="s1">value: undefined</span>
							<span class="s1">};</span>
						<span class="s1">}</span>
					<span class="s1">}</span>
				<span class="s1">};</span>
			<span class="s1">};</span>
		<span class="s1">}</span>
		<span class="s1">// Firefox 27-35, and some older es6-shim versions, use a string &quot;@@iterator&quot; property</span>
		<span class="s1">// this returns a proper iterator object, so we should use it instead of forEach.</span>
		<span class="s1">// newer es6-shim versions use a string &quot;_es6-shim iterator_&quot; property.</span>
		<span class="s1">var $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);</span>
		<span class="s1">var $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);</span>

		<span class="s1">var getCollectionIterator = function getCollectionIterator(iterable) {</span>
			<span class="s1">if (isMap(iterable)) {</span>
				<span class="s1">if ($mapIterator) {</span>
					<span class="s1">return getStopIterationIterator($mapIterator(iterable));</span>
				<span class="s1">}</span>
				<span class="s1">if ($mapAtAtIterator) {</span>
					<span class="s1">return $mapAtAtIterator(iterable);</span>
				<span class="s1">}</span>
				<span class="s1">if ($mapForEach) {</span>
					<span class="s1">var entries = [];</span>
					<span class="s1">$mapForEach(iterable, function (v, k) {</span>
						<span class="s1">$arrayPush(entries, [k, v]);</span>
					<span class="s1">});</span>
					<span class="s1">return getArrayIterator(entries);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s1">if (isSet(iterable)) {</span>
				<span class="s1">if ($setIterator) {</span>
					<span class="s1">return getStopIterationIterator($setIterator(iterable));</span>
				<span class="s1">}</span>
				<span class="s1">if ($setAtAtIterator) {</span>
					<span class="s1">return $setAtAtIterator(iterable);</span>
				<span class="s1">}</span>
				<span class="s1">if ($setForEach) {</span>
					<span class="s1">var values = [];</span>
					<span class="s1">$setForEach(iterable, function (v) {</span>
						<span class="s1">$arrayPush(values, v);</span>
					<span class="s1">});</span>
					<span class="s1">return getArrayIterator(values);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">};</span>

		<span class="s1">module.exports = function getIterator(iterable) {</span>
			<span class="s1">return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);</span>
		<span class="s1">};</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">}).call(this)}).call(this,require('_process'))</span>

<span class="s1">},{&quot;_process&quot;:79,&quot;call-bind/callBound&quot;:11,&quot;get-intrinsic&quot;:39,&quot;has-symbols&quot;:42,&quot;has-symbols/shams&quot;:43,&quot;is-arguments&quot;:48,&quot;is-map&quot;:53,&quot;is-set&quot;:56,&quot;is-string&quot;:57,&quot;isarray&quot;:30}],30:[function(require,module,exports){</span>
<span class="s1">arguments[4][15][0].apply(exports,arguments)</span>
<span class="s1">},{&quot;dup&quot;:15}],31:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var hasSymbols = typeof Symbol === 'function' &amp;&amp; typeof Symbol.iterator === 'symbol';</span>

<span class="s1">var isPrimitive = require('./helpers/isPrimitive');</span>
<span class="s1">var isCallable = require('is-callable');</span>
<span class="s1">var isDate = require('is-date-object');</span>
<span class="s1">var isSymbol = require('is-symbol');</span>

<span class="s1">var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {</span>
	<span class="s1">if (typeof O === 'undefined' || O === null) {</span>
		<span class="s1">throw new TypeError('Cannot call method on ' + O);</span>
	<span class="s1">}</span>
	<span class="s1">if (typeof hint !== 'string' || (hint !== 'number' &amp;&amp; hint !== 'string')) {</span>
		<span class="s1">throw new TypeError('hint must be &quot;string&quot; or &quot;number&quot;');</span>
	<span class="s1">}</span>
	<span class="s1">var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];</span>
	<span class="s1">var method, result, i;</span>
	<span class="s1">for (i = 0; i &lt; methodNames.length; ++i) {</span>
		<span class="s1">method = O[methodNames[i]];</span>
		<span class="s1">if (isCallable(method)) {</span>
			<span class="s1">result = method.call(O);</span>
			<span class="s1">if (isPrimitive(result)) {</span>
				<span class="s1">return result;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">throw new TypeError('No default value');</span>
<span class="s1">};</span>

<span class="s1">var GetMethod = function GetMethod(O, P) {</span>
	<span class="s1">var func = O[P];</span>
	<span class="s1">if (func !== null &amp;&amp; typeof func !== 'undefined') {</span>
		<span class="s1">if (!isCallable(func)) {</span>
			<span class="s1">throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');</span>
		<span class="s1">}</span>
		<span class="s1">return func;</span>
	<span class="s1">}</span>
	<span class="s1">return void 0;</span>
<span class="s1">};</span>

<span class="s1">// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive</span>
<span class="s1">module.exports = function ToPrimitive(input) {</span>
	<span class="s1">if (isPrimitive(input)) {</span>
		<span class="s1">return input;</span>
	<span class="s1">}</span>
	<span class="s1">var hint = 'default';</span>
	<span class="s1">if (arguments.length &gt; 1) {</span>
		<span class="s1">if (arguments[1] === String) {</span>
			<span class="s1">hint = 'string';</span>
		<span class="s1">} else if (arguments[1] === Number) {</span>
			<span class="s1">hint = 'number';</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">var exoticToPrim;</span>
	<span class="s1">if (hasSymbols) {</span>
		<span class="s1">if (Symbol.toPrimitive) {</span>
			<span class="s1">exoticToPrim = GetMethod(input, Symbol.toPrimitive);</span>
		<span class="s1">} else if (isSymbol(input)) {</span>
			<span class="s1">exoticToPrim = Symbol.prototype.valueOf;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">if (typeof exoticToPrim !== 'undefined') {</span>
		<span class="s1">var result = exoticToPrim.call(input, hint);</span>
		<span class="s1">if (isPrimitive(result)) {</span>
			<span class="s1">return result;</span>
		<span class="s1">}</span>
		<span class="s1">throw new TypeError('unable to convert exotic object to primitive');</span>
	<span class="s1">}</span>
	<span class="s1">if (hint === 'default' &amp;&amp; (isDate(input) || isSymbol(input))) {</span>
		<span class="s1">hint = 'string';</span>
	<span class="s1">}</span>
	<span class="s1">return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./helpers/isPrimitive&quot;:32,&quot;is-callable&quot;:51,&quot;is-date-object&quot;:52,&quot;is-symbol&quot;:58}],32:[function(require,module,exports){</span>
<span class="s1">arguments[4][27][0].apply(exports,arguments)</span>
<span class="s1">},{&quot;dup&quot;:27}],33:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">var objectCreate = Object.create || objectCreatePolyfill</span>
<span class="s1">var objectKeys = Object.keys || objectKeysPolyfill</span>
<span class="s1">var bind = Function.prototype.bind || functionBindPolyfill</span>

<span class="s1">function EventEmitter() {</span>
  <span class="s1">if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {</span>
    <span class="s1">this._events = objectCreate(null);</span>
    <span class="s1">this._eventsCount = 0;</span>
  <span class="s1">}</span>

  <span class="s1">this._maxListeners = this._maxListeners || undefined;</span>
<span class="s1">}</span>
<span class="s1">module.exports = EventEmitter;</span>

<span class="s1">// Backwards-compat with node 0.10.x</span>
<span class="s1">EventEmitter.EventEmitter = EventEmitter;</span>

<span class="s1">EventEmitter.prototype._events = undefined;</span>
<span class="s1">EventEmitter.prototype._maxListeners = undefined;</span>

<span class="s1">// By default EventEmitters will print a warning if more than 10 listeners are</span>
<span class="s1">// added to it. This is a useful default which helps finding memory leaks.</span>
<span class="s1">var defaultMaxListeners = 10;</span>

<span class="s1">var hasDefineProperty;</span>
<span class="s1">try {</span>
  <span class="s1">var o = {};</span>
  <span class="s1">if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });</span>
  <span class="s1">hasDefineProperty = o.x === 0;</span>
<span class="s1">} catch (err) { hasDefineProperty = false }</span>
<span class="s1">if (hasDefineProperty) {</span>
  <span class="s1">Object.defineProperty(EventEmitter, 'defaultMaxListeners', {</span>
    <span class="s1">enumerable: true,</span>
    <span class="s1">get: function() {</span>
      <span class="s1">return defaultMaxListeners;</span>
    <span class="s1">},</span>
    <span class="s1">set: function(arg) {</span>
      <span class="s1">// check whether the input is a positive number (whose value is zero or</span>
      <span class="s1">// greater and not a NaN).</span>
      <span class="s1">if (typeof arg !== 'number' || arg &lt; 0 || arg !== arg)</span>
        <span class="s1">throw new TypeError('&quot;defaultMaxListeners&quot; must be a positive number');</span>
      <span class="s1">defaultMaxListeners = arg;</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
<span class="s1">} else {</span>
  <span class="s1">EventEmitter.defaultMaxListeners = defaultMaxListeners;</span>
<span class="s1">}</span>

<span class="s1">// Obviously not all Emitters should be limited to 10. This function allows</span>
<span class="s1">// that to be increased. Set to zero for unlimited.</span>
<span class="s1">EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {</span>
  <span class="s1">if (typeof n !== 'number' || n &lt; 0 || isNaN(n))</span>
    <span class="s1">throw new TypeError('&quot;n&quot; argument must be a positive number');</span>
  <span class="s1">this._maxListeners = n;</span>
  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">function $getMaxListeners(that) {</span>
  <span class="s1">if (that._maxListeners === undefined)</span>
    <span class="s1">return EventEmitter.defaultMaxListeners;</span>
  <span class="s1">return that._maxListeners;</span>
<span class="s1">}</span>

<span class="s1">EventEmitter.prototype.getMaxListeners = function getMaxListeners() {</span>
  <span class="s1">return $getMaxListeners(this);</span>
<span class="s1">};</span>

<span class="s1">// These standalone emit* functions are used to optimize calling of event</span>
<span class="s1">// handlers for fast cases because emit() itself often has a variable number of</span>
<span class="s1">// arguments and can be deoptimized because of that. These functions always have</span>
<span class="s1">// the same number of arguments and thus do not get deoptimized, so the code</span>
<span class="s1">// inside them can execute faster.</span>
<span class="s1">function emitNone(handler, isFn, self) {</span>
  <span class="s1">if (isFn)</span>
    <span class="s1">handler.call(self);</span>
  <span class="s1">else {</span>
    <span class="s1">var len = handler.length;</span>
    <span class="s1">var listeners = arrayClone(handler, len);</span>
    <span class="s1">for (var i = 0; i &lt; len; ++i)</span>
      <span class="s1">listeners[i].call(self);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">function emitOne(handler, isFn, self, arg1) {</span>
  <span class="s1">if (isFn)</span>
    <span class="s1">handler.call(self, arg1);</span>
  <span class="s1">else {</span>
    <span class="s1">var len = handler.length;</span>
    <span class="s1">var listeners = arrayClone(handler, len);</span>
    <span class="s1">for (var i = 0; i &lt; len; ++i)</span>
      <span class="s1">listeners[i].call(self, arg1);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">function emitTwo(handler, isFn, self, arg1, arg2) {</span>
  <span class="s1">if (isFn)</span>
    <span class="s1">handler.call(self, arg1, arg2);</span>
  <span class="s1">else {</span>
    <span class="s1">var len = handler.length;</span>
    <span class="s1">var listeners = arrayClone(handler, len);</span>
    <span class="s1">for (var i = 0; i &lt; len; ++i)</span>
      <span class="s1">listeners[i].call(self, arg1, arg2);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">function emitThree(handler, isFn, self, arg1, arg2, arg3) {</span>
  <span class="s1">if (isFn)</span>
    <span class="s1">handler.call(self, arg1, arg2, arg3);</span>
  <span class="s1">else {</span>
    <span class="s1">var len = handler.length;</span>
    <span class="s1">var listeners = arrayClone(handler, len);</span>
    <span class="s1">for (var i = 0; i &lt; len; ++i)</span>
      <span class="s1">listeners[i].call(self, arg1, arg2, arg3);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function emitMany(handler, isFn, self, args) {</span>
  <span class="s1">if (isFn)</span>
    <span class="s1">handler.apply(self, args);</span>
  <span class="s1">else {</span>
    <span class="s1">var len = handler.length;</span>
    <span class="s1">var listeners = arrayClone(handler, len);</span>
    <span class="s1">for (var i = 0; i &lt; len; ++i)</span>
      <span class="s1">listeners[i].apply(self, args);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">EventEmitter.prototype.emit = function emit(type) {</span>
  <span class="s1">var er, handler, len, args, i, events;</span>
  <span class="s1">var doError = (type === 'error');</span>

  <span class="s1">events = this._events;</span>
  <span class="s1">if (events)</span>
    <span class="s1">doError = (doError &amp;&amp; events.error == null);</span>
  <span class="s1">else if (!doError)</span>
    <span class="s1">return false;</span>

  <span class="s1">// If there is no 'error' event listener then throw.</span>
  <span class="s1">if (doError) {</span>
    <span class="s1">if (arguments.length &gt; 1)</span>
      <span class="s1">er = arguments[1];</span>
    <span class="s1">if (er instanceof Error) {</span>
      <span class="s1">throw er; // Unhandled 'error' event</span>
    <span class="s1">} else {</span>
      <span class="s1">// At least give some kind of context to the user</span>
      <span class="s1">var err = new Error('Unhandled &quot;error&quot; event. (' + er + ')');</span>
      <span class="s1">err.context = er;</span>
      <span class="s1">throw err;</span>
    <span class="s1">}</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>

  <span class="s1">handler = events[type];</span>

  <span class="s1">if (!handler)</span>
    <span class="s1">return false;</span>

  <span class="s1">var isFn = typeof handler === 'function';</span>
  <span class="s1">len = arguments.length;</span>
  <span class="s1">switch (len) {</span>
      <span class="s1">// fast cases</span>
    <span class="s1">case 1:</span>
      <span class="s1">emitNone(handler, isFn, this);</span>
      <span class="s1">break;</span>
    <span class="s1">case 2:</span>
      <span class="s1">emitOne(handler, isFn, this, arguments[1]);</span>
      <span class="s1">break;</span>
    <span class="s1">case 3:</span>
      <span class="s1">emitTwo(handler, isFn, this, arguments[1], arguments[2]);</span>
      <span class="s1">break;</span>
    <span class="s1">case 4:</span>
      <span class="s1">emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);</span>
      <span class="s1">break;</span>
      <span class="s1">// slower</span>
    <span class="s1">default:</span>
      <span class="s1">args = new Array(len - 1);</span>
      <span class="s1">for (i = 1; i &lt; len; i++)</span>
        <span class="s1">args[i - 1] = arguments[i];</span>
      <span class="s1">emitMany(handler, isFn, this, args);</span>
  <span class="s1">}</span>

  <span class="s1">return true;</span>
<span class="s1">};</span>

<span class="s1">function _addListener(target, type, listener, prepend) {</span>
  <span class="s1">var m;</span>
  <span class="s1">var events;</span>
  <span class="s1">var existing;</span>

  <span class="s1">if (typeof listener !== 'function')</span>
    <span class="s1">throw new TypeError('&quot;listener&quot; argument must be a function');</span>

  <span class="s1">events = target._events;</span>
  <span class="s1">if (!events) {</span>
    <span class="s1">events = target._events = objectCreate(null);</span>
    <span class="s1">target._eventsCount = 0;</span>
  <span class="s1">} else {</span>
    <span class="s1">// To avoid recursion in the case that type === &quot;newListener&quot;! Before</span>
    <span class="s1">// adding it to the listeners, first emit &quot;newListener&quot;.</span>
    <span class="s1">if (events.newListener) {</span>
      <span class="s1">target.emit('newListener', type,</span>
          <span class="s1">listener.listener ? listener.listener : listener);</span>

      <span class="s1">// Re-assign `events` because a newListener handler could have caused the</span>
      <span class="s1">// this._events to be assigned to a new object</span>
      <span class="s1">events = target._events;</span>
    <span class="s1">}</span>
    <span class="s1">existing = events[type];</span>
  <span class="s1">}</span>

  <span class="s1">if (!existing) {</span>
    <span class="s1">// Optimize the case of one listener. Don't need the extra array object.</span>
    <span class="s1">existing = events[type] = listener;</span>
    <span class="s1">++target._eventsCount;</span>
  <span class="s1">} else {</span>
    <span class="s1">if (typeof existing === 'function') {</span>
      <span class="s1">// Adding the second element, need to change to array.</span>
      <span class="s1">existing = events[type] =</span>
          <span class="s1">prepend ? [listener, existing] : [existing, listener];</span>
    <span class="s1">} else {</span>
      <span class="s1">// If we've already got an array, just append.</span>
      <span class="s1">if (prepend) {</span>
        <span class="s1">existing.unshift(listener);</span>
      <span class="s1">} else {</span>
        <span class="s1">existing.push(listener);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">// Check for listener leak</span>
    <span class="s1">if (!existing.warned) {</span>
      <span class="s1">m = $getMaxListeners(target);</span>
      <span class="s1">if (m &amp;&amp; m &gt; 0 &amp;&amp; existing.length &gt; m) {</span>
        <span class="s1">existing.warned = true;</span>
        <span class="s1">var w = new Error('Possible EventEmitter memory leak detected. ' +</span>
            <span class="s1">existing.length + ' &quot;' + String(type) + '&quot; listeners ' +</span>
            <span class="s1">'added. Use emitter.setMaxListeners() to ' +</span>
            <span class="s1">'increase limit.');</span>
        <span class="s1">w.name = 'MaxListenersExceededWarning';</span>
        <span class="s1">w.emitter = target;</span>
        <span class="s1">w.type = type;</span>
        <span class="s1">w.count = existing.length;</span>
        <span class="s1">if (typeof console === 'object' &amp;&amp; console.warn) {</span>
          <span class="s1">console.warn('%s: %s', w.name, w.message);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return target;</span>
<span class="s1">}</span>

<span class="s1">EventEmitter.prototype.addListener = function addListener(type, listener) {</span>
  <span class="s1">return _addListener(this, type, listener, false);</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.on = EventEmitter.prototype.addListener;</span>

<span class="s1">EventEmitter.prototype.prependListener =</span>
    <span class="s1">function prependListener(type, listener) {</span>
      <span class="s1">return _addListener(this, type, listener, true);</span>
    <span class="s1">};</span>

<span class="s1">function onceWrapper() {</span>
  <span class="s1">if (!this.fired) {</span>
    <span class="s1">this.target.removeListener(this.type, this.wrapFn);</span>
    <span class="s1">this.fired = true;</span>
    <span class="s1">switch (arguments.length) {</span>
      <span class="s1">case 0:</span>
        <span class="s1">return this.listener.call(this.target);</span>
      <span class="s1">case 1:</span>
        <span class="s1">return this.listener.call(this.target, arguments[0]);</span>
      <span class="s1">case 2:</span>
        <span class="s1">return this.listener.call(this.target, arguments[0], arguments[1]);</span>
      <span class="s1">case 3:</span>
        <span class="s1">return this.listener.call(this.target, arguments[0], arguments[1],</span>
            <span class="s1">arguments[2]);</span>
      <span class="s1">default:</span>
        <span class="s1">var args = new Array(arguments.length);</span>
        <span class="s1">for (var i = 0; i &lt; args.length; ++i)</span>
          <span class="s1">args[i] = arguments[i];</span>
        <span class="s1">this.listener.apply(this.target, args);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function _onceWrap(target, type, listener) {</span>
  <span class="s1">var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };</span>
  <span class="s1">var wrapped = bind.call(onceWrapper, state);</span>
  <span class="s1">wrapped.listener = listener;</span>
  <span class="s1">state.wrapFn = wrapped;</span>
  <span class="s1">return wrapped;</span>
<span class="s1">}</span>

<span class="s1">EventEmitter.prototype.once = function once(type, listener) {</span>
  <span class="s1">if (typeof listener !== 'function')</span>
    <span class="s1">throw new TypeError('&quot;listener&quot; argument must be a function');</span>
  <span class="s1">this.on(type, _onceWrap(this, type, listener));</span>
  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.prependOnceListener =</span>
    <span class="s1">function prependOnceListener(type, listener) {</span>
      <span class="s1">if (typeof listener !== 'function')</span>
        <span class="s1">throw new TypeError('&quot;listener&quot; argument must be a function');</span>
      <span class="s1">this.prependListener(type, _onceWrap(this, type, listener));</span>
      <span class="s1">return this;</span>
    <span class="s1">};</span>

<span class="s1">// Emits a 'removeListener' event if and only if the listener was removed.</span>
<span class="s1">EventEmitter.prototype.removeListener =</span>
    <span class="s1">function removeListener(type, listener) {</span>
      <span class="s1">var list, events, position, i, originalListener;</span>

      <span class="s1">if (typeof listener !== 'function')</span>
        <span class="s1">throw new TypeError('&quot;listener&quot; argument must be a function');</span>

      <span class="s1">events = this._events;</span>
      <span class="s1">if (!events)</span>
        <span class="s1">return this;</span>

      <span class="s1">list = events[type];</span>
      <span class="s1">if (!list)</span>
        <span class="s1">return this;</span>

      <span class="s1">if (list === listener || list.listener === listener) {</span>
        <span class="s1">if (--this._eventsCount === 0)</span>
          <span class="s1">this._events = objectCreate(null);</span>
        <span class="s1">else {</span>
          <span class="s1">delete events[type];</span>
          <span class="s1">if (events.removeListener)</span>
            <span class="s1">this.emit('removeListener', type, list.listener || listener);</span>
        <span class="s1">}</span>
      <span class="s1">} else if (typeof list !== 'function') {</span>
        <span class="s1">position = -1;</span>

        <span class="s1">for (i = list.length - 1; i &gt;= 0; i--) {</span>
          <span class="s1">if (list[i] === listener || list[i].listener === listener) {</span>
            <span class="s1">originalListener = list[i].listener;</span>
            <span class="s1">position = i;</span>
            <span class="s1">break;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">if (position &lt; 0)</span>
          <span class="s1">return this;</span>

        <span class="s1">if (position === 0)</span>
          <span class="s1">list.shift();</span>
        <span class="s1">else</span>
          <span class="s1">spliceOne(list, position);</span>

        <span class="s1">if (list.length === 1)</span>
          <span class="s1">events[type] = list[0];</span>

        <span class="s1">if (events.removeListener)</span>
          <span class="s1">this.emit('removeListener', type, originalListener || listener);</span>
      <span class="s1">}</span>

      <span class="s1">return this;</span>
    <span class="s1">};</span>

<span class="s1">EventEmitter.prototype.removeAllListeners =</span>
    <span class="s1">function removeAllListeners(type) {</span>
      <span class="s1">var listeners, events, i;</span>

      <span class="s1">events = this._events;</span>
      <span class="s1">if (!events)</span>
        <span class="s1">return this;</span>

      <span class="s1">// not listening for removeListener, no need to emit</span>
      <span class="s1">if (!events.removeListener) {</span>
        <span class="s1">if (arguments.length === 0) {</span>
          <span class="s1">this._events = objectCreate(null);</span>
          <span class="s1">this._eventsCount = 0;</span>
        <span class="s1">} else if (events[type]) {</span>
          <span class="s1">if (--this._eventsCount === 0)</span>
            <span class="s1">this._events = objectCreate(null);</span>
          <span class="s1">else</span>
            <span class="s1">delete events[type];</span>
        <span class="s1">}</span>
        <span class="s1">return this;</span>
      <span class="s1">}</span>

      <span class="s1">// emit removeListener for all listeners on all events</span>
      <span class="s1">if (arguments.length === 0) {</span>
        <span class="s1">var keys = objectKeys(events);</span>
        <span class="s1">var key;</span>
        <span class="s1">for (i = 0; i &lt; keys.length; ++i) {</span>
          <span class="s1">key = keys[i];</span>
          <span class="s1">if (key === 'removeListener') continue;</span>
          <span class="s1">this.removeAllListeners(key);</span>
        <span class="s1">}</span>
        <span class="s1">this.removeAllListeners('removeListener');</span>
        <span class="s1">this._events = objectCreate(null);</span>
        <span class="s1">this._eventsCount = 0;</span>
        <span class="s1">return this;</span>
      <span class="s1">}</span>

      <span class="s1">listeners = events[type];</span>

      <span class="s1">if (typeof listeners === 'function') {</span>
        <span class="s1">this.removeListener(type, listeners);</span>
      <span class="s1">} else if (listeners) {</span>
        <span class="s1">// LIFO order</span>
        <span class="s1">for (i = listeners.length - 1; i &gt;= 0; i--) {</span>
          <span class="s1">this.removeListener(type, listeners[i]);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">return this;</span>
    <span class="s1">};</span>

<span class="s1">function _listeners(target, type, unwrap) {</span>
  <span class="s1">var events = target._events;</span>

  <span class="s1">if (!events)</span>
    <span class="s1">return [];</span>

  <span class="s1">var evlistener = events[type];</span>
  <span class="s1">if (!evlistener)</span>
    <span class="s1">return [];</span>

  <span class="s1">if (typeof evlistener === 'function')</span>
    <span class="s1">return unwrap ? [evlistener.listener || evlistener] : [evlistener];</span>

  <span class="s1">return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);</span>
<span class="s1">}</span>

<span class="s1">EventEmitter.prototype.listeners = function listeners(type) {</span>
  <span class="s1">return _listeners(this, type, true);</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.rawListeners = function rawListeners(type) {</span>
  <span class="s1">return _listeners(this, type, false);</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.listenerCount = function(emitter, type) {</span>
  <span class="s1">if (typeof emitter.listenerCount === 'function') {</span>
    <span class="s1">return emitter.listenerCount(type);</span>
  <span class="s1">} else {</span>
    <span class="s1">return listenerCount.call(emitter, type);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">EventEmitter.prototype.listenerCount = listenerCount;</span>
<span class="s1">function listenerCount(type) {</span>
  <span class="s1">var events = this._events;</span>

  <span class="s1">if (events) {</span>
    <span class="s1">var evlistener = events[type];</span>

    <span class="s1">if (typeof evlistener === 'function') {</span>
      <span class="s1">return 1;</span>
    <span class="s1">} else if (evlistener) {</span>
      <span class="s1">return evlistener.length;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return 0;</span>
<span class="s1">}</span>

<span class="s1">EventEmitter.prototype.eventNames = function eventNames() {</span>
  <span class="s1">return this._eventsCount &gt; 0 ? Reflect.ownKeys(this._events) : [];</span>
<span class="s1">};</span>

<span class="s1">// About 1.5x faster than the two-arg version of Array#splice().</span>
<span class="s1">function spliceOne(list, index) {</span>
  <span class="s1">for (var i = index, k = i + 1, n = list.length; k &lt; n; i += 1, k += 1)</span>
    <span class="s1">list[i] = list[k];</span>
  <span class="s1">list.pop();</span>
<span class="s1">}</span>

<span class="s1">function arrayClone(arr, n) {</span>
  <span class="s1">var copy = new Array(n);</span>
  <span class="s1">for (var i = 0; i &lt; n; ++i)</span>
    <span class="s1">copy[i] = arr[i];</span>
  <span class="s1">return copy;</span>
<span class="s1">}</span>

<span class="s1">function unwrapListeners(arr) {</span>
  <span class="s1">var ret = new Array(arr.length);</span>
  <span class="s1">for (var i = 0; i &lt; ret.length; ++i) {</span>
    <span class="s1">ret[i] = arr[i].listener || arr[i];</span>
  <span class="s1">}</span>
  <span class="s1">return ret;</span>
<span class="s1">}</span>

<span class="s1">function objectCreatePolyfill(proto) {</span>
  <span class="s1">var F = function() {};</span>
  <span class="s1">F.prototype = proto;</span>
  <span class="s1">return new F;</span>
<span class="s1">}</span>
<span class="s1">function objectKeysPolyfill(obj) {</span>
  <span class="s1">var keys = [];</span>
  <span class="s1">for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {</span>
    <span class="s1">keys.push(k);</span>
  <span class="s1">}</span>
  <span class="s1">return k;</span>
<span class="s1">}</span>
<span class="s1">function functionBindPolyfill(context) {</span>
  <span class="s1">var fn = this;</span>
  <span class="s1">return function () {</span>
    <span class="s1">return fn.apply(context, arguments);</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">},{}],34:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var isCallable = require('is-callable');</span>

<span class="s1">var toStr = Object.prototype.toString;</span>
<span class="s1">var hasOwnProperty = Object.prototype.hasOwnProperty;</span>

<span class="s1">var forEachArray = function forEachArray(array, iterator, receiver) {</span>
    <span class="s1">for (var i = 0, len = array.length; i &lt; len; i++) {</span>
        <span class="s1">if (hasOwnProperty.call(array, i)) {</span>
            <span class="s1">if (receiver == null) {</span>
                <span class="s1">iterator(array[i], i, array);</span>
            <span class="s1">} else {</span>
                <span class="s1">iterator.call(receiver, array[i], i, array);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">var forEachString = function forEachString(string, iterator, receiver) {</span>
    <span class="s1">for (var i = 0, len = string.length; i &lt; len; i++) {</span>
        <span class="s1">// no such thing as a sparse string.</span>
        <span class="s1">if (receiver == null) {</span>
            <span class="s1">iterator(string.charAt(i), i, string);</span>
        <span class="s1">} else {</span>
            <span class="s1">iterator.call(receiver, string.charAt(i), i, string);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">var forEachObject = function forEachObject(object, iterator, receiver) {</span>
    <span class="s1">for (var k in object) {</span>
        <span class="s1">if (hasOwnProperty.call(object, k)) {</span>
            <span class="s1">if (receiver == null) {</span>
                <span class="s1">iterator(object[k], k, object);</span>
            <span class="s1">} else {</span>
                <span class="s1">iterator.call(receiver, object[k], k, object);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">var forEach = function forEach(list, iterator, thisArg) {</span>
    <span class="s1">if (!isCallable(iterator)) {</span>
        <span class="s1">throw new TypeError('iterator must be a function');</span>
    <span class="s1">}</span>

    <span class="s1">var receiver;</span>
    <span class="s1">if (arguments.length &gt;= 3) {</span>
        <span class="s1">receiver = thisArg;</span>
    <span class="s1">}</span>

    <span class="s1">if (toStr.call(list) === '[object Array]') {</span>
        <span class="s1">forEachArray(list, iterator, receiver);</span>
    <span class="s1">} else if (typeof list === 'string') {</span>
        <span class="s1">forEachString(list, iterator, receiver);</span>
    <span class="s1">} else {</span>
        <span class="s1">forEachObject(list, iterator, receiver);</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">module.exports = forEach;</span>

<span class="s1">},{&quot;is-callable&quot;:51}],35:[function(require,module,exports){</span>

<span class="s1">var hasOwn = Object.prototype.hasOwnProperty;</span>
<span class="s1">var toString = Object.prototype.toString;</span>

<span class="s1">module.exports = function forEach (obj, fn, ctx) {</span>
    <span class="s1">if (toString.call(fn) !== '[object Function]') {</span>
        <span class="s1">throw new TypeError('iterator must be a function');</span>
    <span class="s1">}</span>
    <span class="s1">var l = obj.length;</span>
    <span class="s1">if (l === +l) {</span>
        <span class="s1">for (var i = 0; i &lt; l; i++) {</span>
            <span class="s1">fn.call(ctx, obj[i], i, obj);</span>
        <span class="s1">}</span>
    <span class="s1">} else {</span>
        <span class="s1">for (var k in obj) {</span>
            <span class="s1">if (hasOwn.call(obj, k)) {</span>
                <span class="s1">fn.call(ctx, obj[k], k, obj);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">};</span>


<span class="s1">},{}],36:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">/* eslint no-invalid-this: 1 */</span>

<span class="s1">var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';</span>
<span class="s1">var slice = Array.prototype.slice;</span>
<span class="s1">var toStr = Object.prototype.toString;</span>
<span class="s1">var funcType = '[object Function]';</span>

<span class="s1">module.exports = function bind(that) {</span>
    <span class="s1">var target = this;</span>
    <span class="s1">if (typeof target !== 'function' || toStr.call(target) !== funcType) {</span>
        <span class="s1">throw new TypeError(ERROR_MESSAGE + target);</span>
    <span class="s1">}</span>
    <span class="s1">var args = slice.call(arguments, 1);</span>

    <span class="s1">var bound;</span>
    <span class="s1">var binder = function () {</span>
        <span class="s1">if (this instanceof bound) {</span>
            <span class="s1">var result = target.apply(</span>
                <span class="s1">this,</span>
                <span class="s1">args.concat(slice.call(arguments))</span>
            <span class="s1">);</span>
            <span class="s1">if (Object(result) === result) {</span>
                <span class="s1">return result;</span>
            <span class="s1">}</span>
            <span class="s1">return this;</span>
        <span class="s1">} else {</span>
            <span class="s1">return target.apply(</span>
                <span class="s1">that,</span>
                <span class="s1">args.concat(slice.call(arguments))</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">var boundLength = Math.max(0, target.length - args.length);</span>
    <span class="s1">var boundArgs = [];</span>
    <span class="s1">for (var i = 0; i &lt; boundLength; i++) {</span>
        <span class="s1">boundArgs.push('$' + i);</span>
    <span class="s1">}</span>

    <span class="s1">bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);</span>

    <span class="s1">if (target.prototype) {</span>
        <span class="s1">var Empty = function Empty() {};</span>
        <span class="s1">Empty.prototype = target.prototype;</span>
        <span class="s1">bound.prototype = new Empty();</span>
        <span class="s1">Empty.prototype = null;</span>
    <span class="s1">}</span>

    <span class="s1">return bound;</span>
<span class="s1">};</span>

<span class="s1">},{}],37:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var implementation = require('./implementation');</span>

<span class="s1">module.exports = Function.prototype.bind || implementation;</span>

<span class="s1">},{&quot;./implementation&quot;:36}],38:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var functionsHaveNames = function functionsHaveNames() {</span>
	<span class="s1">return typeof function f() {}.name === 'string';</span>
<span class="s1">};</span>

<span class="s1">var gOPD = Object.getOwnPropertyDescriptor;</span>
<span class="s1">if (gOPD) {</span>
	<span class="s1">try {</span>
		<span class="s1">gOPD([], 'length');</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">// IE 8 has a broken gOPD</span>
		<span class="s1">gOPD = null;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {</span>
	<span class="s1">if (!functionsHaveNames() || !gOPD) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">var desc = gOPD(function () {}, 'name');</span>
	<span class="s1">return !!desc &amp;&amp; !!desc.configurable;</span>
<span class="s1">};</span>

<span class="s1">var $bind = Function.prototype.bind;</span>

<span class="s1">functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {</span>
	<span class="s1">return functionsHaveNames() &amp;&amp; typeof $bind === 'function' &amp;&amp; function f() {}.bind().name !== '';</span>
<span class="s1">};</span>

<span class="s1">module.exports = functionsHaveNames;</span>

<span class="s1">},{}],39:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var undefined;</span>

<span class="s1">var $SyntaxError = SyntaxError;</span>
<span class="s1">var $Function = Function;</span>
<span class="s1">var $TypeError = TypeError;</span>

<span class="s1">// eslint-disable-next-line consistent-return</span>
<span class="s1">var getEvalledConstructor = function (expressionSyntax) {</span>
	<span class="s1">try {</span>
		<span class="s1">return $Function('&quot;use strict&quot;; return (' + expressionSyntax + ').constructor;')();</span>
	<span class="s1">} catch (e) {}</span>
<span class="s1">};</span>

<span class="s1">var $gOPD = Object.getOwnPropertyDescriptor;</span>
<span class="s1">if ($gOPD) {</span>
	<span class="s1">try {</span>
		<span class="s1">$gOPD({}, '');</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">$gOPD = null; // this is IE 8, which has a broken gOPD</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">var throwTypeError = function () {</span>
	<span class="s1">throw new $TypeError();</span>
<span class="s1">};</span>
<span class="s1">var ThrowTypeError = $gOPD</span>
	<span class="s1">? (function () {</span>
		<span class="s1">try {</span>
			<span class="s1">// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties</span>
			<span class="s1">arguments.callee; // IE 8 does not throw here</span>
			<span class="s1">return throwTypeError;</span>
		<span class="s1">} catch (calleeThrows) {</span>
			<span class="s1">try {</span>
				<span class="s1">// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')</span>
				<span class="s1">return $gOPD(arguments, 'callee').get;</span>
			<span class="s1">} catch (gOPDthrows) {</span>
				<span class="s1">return throwTypeError;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}())</span>
	<span class="s1">: throwTypeError;</span>

<span class="s1">var hasSymbols = require('has-symbols')();</span>

<span class="s1">var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto</span>

<span class="s1">var needsEval = {};</span>

<span class="s1">var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);</span>

<span class="s1">var INTRINSICS = {</span>
	<span class="s1">'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,</span>
	<span class="s1">'%Array%': Array,</span>
	<span class="s1">'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,</span>
	<span class="s1">'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,</span>
	<span class="s1">'%AsyncFromSyncIteratorPrototype%': undefined,</span>
	<span class="s1">'%AsyncFunction%': needsEval,</span>
	<span class="s1">'%AsyncGenerator%': needsEval,</span>
	<span class="s1">'%AsyncGeneratorFunction%': needsEval,</span>
	<span class="s1">'%AsyncIteratorPrototype%': needsEval,</span>
	<span class="s1">'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,</span>
	<span class="s1">'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,</span>
	<span class="s1">'%Boolean%': Boolean,</span>
	<span class="s1">'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,</span>
	<span class="s1">'%Date%': Date,</span>
	<span class="s1">'%decodeURI%': decodeURI,</span>
	<span class="s1">'%decodeURIComponent%': decodeURIComponent,</span>
	<span class="s1">'%encodeURI%': encodeURI,</span>
	<span class="s1">'%encodeURIComponent%': encodeURIComponent,</span>
	<span class="s1">'%Error%': Error,</span>
	<span class="s1">'%eval%': eval, // eslint-disable-line no-eval</span>
	<span class="s1">'%EvalError%': EvalError,</span>
	<span class="s1">'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,</span>
	<span class="s1">'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,</span>
	<span class="s1">'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,</span>
	<span class="s1">'%Function%': $Function,</span>
	<span class="s1">'%GeneratorFunction%': needsEval,</span>
	<span class="s1">'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,</span>
	<span class="s1">'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,</span>
	<span class="s1">'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,</span>
	<span class="s1">'%isFinite%': isFinite,</span>
	<span class="s1">'%isNaN%': isNaN,</span>
	<span class="s1">'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,</span>
	<span class="s1">'%JSON%': typeof JSON === 'object' ? JSON : undefined,</span>
	<span class="s1">'%Map%': typeof Map === 'undefined' ? undefined : Map,</span>
	<span class="s1">'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),</span>
	<span class="s1">'%Math%': Math,</span>
	<span class="s1">'%Number%': Number,</span>
	<span class="s1">'%Object%': Object,</span>
	<span class="s1">'%parseFloat%': parseFloat,</span>
	<span class="s1">'%parseInt%': parseInt,</span>
	<span class="s1">'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,</span>
	<span class="s1">'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,</span>
	<span class="s1">'%RangeError%': RangeError,</span>
	<span class="s1">'%ReferenceError%': ReferenceError,</span>
	<span class="s1">'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,</span>
	<span class="s1">'%RegExp%': RegExp,</span>
	<span class="s1">'%Set%': typeof Set === 'undefined' ? undefined : Set,</span>
	<span class="s1">'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),</span>
	<span class="s1">'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,</span>
	<span class="s1">'%String%': String,</span>
	<span class="s1">'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,</span>
	<span class="s1">'%Symbol%': hasSymbols ? Symbol : undefined,</span>
	<span class="s1">'%SyntaxError%': $SyntaxError,</span>
	<span class="s1">'%ThrowTypeError%': ThrowTypeError,</span>
	<span class="s1">'%TypedArray%': TypedArray,</span>
	<span class="s1">'%TypeError%': $TypeError,</span>
	<span class="s1">'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,</span>
	<span class="s1">'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,</span>
	<span class="s1">'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,</span>
	<span class="s1">'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,</span>
	<span class="s1">'%URIError%': URIError,</span>
	<span class="s1">'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,</span>
	<span class="s1">'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,</span>
	<span class="s1">'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet</span>
<span class="s1">};</span>

<span class="s1">var doEval = function doEval(name) {</span>
	<span class="s1">var value;</span>
	<span class="s1">if (name === '%AsyncFunction%') {</span>
		<span class="s1">value = getEvalledConstructor('async function () {}');</span>
	<span class="s1">} else if (name === '%GeneratorFunction%') {</span>
		<span class="s1">value = getEvalledConstructor('function* () {}');</span>
	<span class="s1">} else if (name === '%AsyncGeneratorFunction%') {</span>
		<span class="s1">value = getEvalledConstructor('async function* () {}');</span>
	<span class="s1">} else if (name === '%AsyncGenerator%') {</span>
		<span class="s1">var fn = doEval('%AsyncGeneratorFunction%');</span>
		<span class="s1">if (fn) {</span>
			<span class="s1">value = fn.prototype;</span>
		<span class="s1">}</span>
	<span class="s1">} else if (name === '%AsyncIteratorPrototype%') {</span>
		<span class="s1">var gen = doEval('%AsyncGenerator%');</span>
		<span class="s1">if (gen) {</span>
			<span class="s1">value = getProto(gen.prototype);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">INTRINSICS[name] = value;</span>

	<span class="s1">return value;</span>
<span class="s1">};</span>

<span class="s1">var LEGACY_ALIASES = {</span>
	<span class="s1">'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],</span>
	<span class="s1">'%ArrayPrototype%': ['Array', 'prototype'],</span>
	<span class="s1">'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],</span>
	<span class="s1">'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],</span>
	<span class="s1">'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],</span>
	<span class="s1">'%ArrayProto_values%': ['Array', 'prototype', 'values'],</span>
	<span class="s1">'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],</span>
	<span class="s1">'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],</span>
	<span class="s1">'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],</span>
	<span class="s1">'%BooleanPrototype%': ['Boolean', 'prototype'],</span>
	<span class="s1">'%DataViewPrototype%': ['DataView', 'prototype'],</span>
	<span class="s1">'%DatePrototype%': ['Date', 'prototype'],</span>
	<span class="s1">'%ErrorPrototype%': ['Error', 'prototype'],</span>
	<span class="s1">'%EvalErrorPrototype%': ['EvalError', 'prototype'],</span>
	<span class="s1">'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],</span>
	<span class="s1">'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],</span>
	<span class="s1">'%FunctionPrototype%': ['Function', 'prototype'],</span>
	<span class="s1">'%Generator%': ['GeneratorFunction', 'prototype'],</span>
	<span class="s1">'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],</span>
	<span class="s1">'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],</span>
	<span class="s1">'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],</span>
	<span class="s1">'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],</span>
	<span class="s1">'%JSONParse%': ['JSON', 'parse'],</span>
	<span class="s1">'%JSONStringify%': ['JSON', 'stringify'],</span>
	<span class="s1">'%MapPrototype%': ['Map', 'prototype'],</span>
	<span class="s1">'%NumberPrototype%': ['Number', 'prototype'],</span>
	<span class="s1">'%ObjectPrototype%': ['Object', 'prototype'],</span>
	<span class="s1">'%ObjProto_toString%': ['Object', 'prototype', 'toString'],</span>
	<span class="s1">'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],</span>
	<span class="s1">'%PromisePrototype%': ['Promise', 'prototype'],</span>
	<span class="s1">'%PromiseProto_then%': ['Promise', 'prototype', 'then'],</span>
	<span class="s1">'%Promise_all%': ['Promise', 'all'],</span>
	<span class="s1">'%Promise_reject%': ['Promise', 'reject'],</span>
	<span class="s1">'%Promise_resolve%': ['Promise', 'resolve'],</span>
	<span class="s1">'%RangeErrorPrototype%': ['RangeError', 'prototype'],</span>
	<span class="s1">'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],</span>
	<span class="s1">'%RegExpPrototype%': ['RegExp', 'prototype'],</span>
	<span class="s1">'%SetPrototype%': ['Set', 'prototype'],</span>
	<span class="s1">'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],</span>
	<span class="s1">'%StringPrototype%': ['String', 'prototype'],</span>
	<span class="s1">'%SymbolPrototype%': ['Symbol', 'prototype'],</span>
	<span class="s1">'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],</span>
	<span class="s1">'%TypedArrayPrototype%': ['TypedArray', 'prototype'],</span>
	<span class="s1">'%TypeErrorPrototype%': ['TypeError', 'prototype'],</span>
	<span class="s1">'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],</span>
	<span class="s1">'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],</span>
	<span class="s1">'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],</span>
	<span class="s1">'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],</span>
	<span class="s1">'%URIErrorPrototype%': ['URIError', 'prototype'],</span>
	<span class="s1">'%WeakMapPrototype%': ['WeakMap', 'prototype'],</span>
	<span class="s1">'%WeakSetPrototype%': ['WeakSet', 'prototype']</span>
<span class="s1">};</span>

<span class="s1">var bind = require('function-bind');</span>
<span class="s1">var hasOwn = require('has');</span>
<span class="s1">var $concat = bind.call(Function.call, Array.prototype.concat);</span>
<span class="s1">var $spliceApply = bind.call(Function.apply, Array.prototype.splice);</span>
<span class="s1">var $replace = bind.call(Function.call, String.prototype.replace);</span>
<span class="s1">var $strSlice = bind.call(Function.call, String.prototype.slice);</span>

<span class="s1">/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */</span>
<span class="s1">var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|([&quot;'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;</span>
<span class="s1">var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */</span>
<span class="s1">var stringToPath = function stringToPath(string) {</span>
	<span class="s1">var first = $strSlice(string, 0, 1);</span>
	<span class="s1">var last = $strSlice(string, -1);</span>
	<span class="s1">if (first === '%' &amp;&amp; last !== '%') {</span>
		<span class="s1">throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');</span>
	<span class="s1">} else if (last === '%' &amp;&amp; first !== '%') {</span>
		<span class="s1">throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');</span>
	<span class="s1">}</span>
	<span class="s1">var result = [];</span>
	<span class="s1">$replace(string, rePropName, function (match, number, quote, subString) {</span>
		<span class="s1">result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;</span>
	<span class="s1">});</span>
	<span class="s1">return result;</span>
<span class="s1">};</span>
<span class="s1">/* end adaptation */</span>

<span class="s1">var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {</span>
	<span class="s1">var intrinsicName = name;</span>
	<span class="s1">var alias;</span>
	<span class="s1">if (hasOwn(LEGACY_ALIASES, intrinsicName)) {</span>
		<span class="s1">alias = LEGACY_ALIASES[intrinsicName];</span>
		<span class="s1">intrinsicName = '%' + alias[0] + '%';</span>
	<span class="s1">}</span>

	<span class="s1">if (hasOwn(INTRINSICS, intrinsicName)) {</span>
		<span class="s1">var value = INTRINSICS[intrinsicName];</span>
		<span class="s1">if (value === needsEval) {</span>
			<span class="s1">value = doEval(intrinsicName);</span>
		<span class="s1">}</span>
		<span class="s1">if (typeof value === 'undefined' &amp;&amp; !allowMissing) {</span>
			<span class="s1">throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');</span>
		<span class="s1">}</span>

		<span class="s1">return {</span>
			<span class="s1">alias: alias,</span>
			<span class="s1">name: intrinsicName,</span>
			<span class="s1">value: value</span>
		<span class="s1">};</span>
	<span class="s1">}</span>

	<span class="s1">throw new $SyntaxError('intrinsic ' + name + ' does not exist!');</span>
<span class="s1">};</span>

<span class="s1">module.exports = function GetIntrinsic(name, allowMissing) {</span>
	<span class="s1">if (typeof name !== 'string' || name.length === 0) {</span>
		<span class="s1">throw new $TypeError('intrinsic name must be a non-empty string');</span>
	<span class="s1">}</span>
	<span class="s1">if (arguments.length &gt; 1 &amp;&amp; typeof allowMissing !== 'boolean') {</span>
		<span class="s1">throw new $TypeError('&quot;allowMissing&quot; argument must be a boolean');</span>
	<span class="s1">}</span>

	<span class="s1">var parts = stringToPath(name);</span>
	<span class="s1">var intrinsicBaseName = parts.length &gt; 0 ? parts[0] : '';</span>

	<span class="s1">var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);</span>
	<span class="s1">var intrinsicRealName = intrinsic.name;</span>
	<span class="s1">var value = intrinsic.value;</span>
	<span class="s1">var skipFurtherCaching = false;</span>

	<span class="s1">var alias = intrinsic.alias;</span>
	<span class="s1">if (alias) {</span>
		<span class="s1">intrinsicBaseName = alias[0];</span>
		<span class="s1">$spliceApply(parts, $concat([0, 1], alias));</span>
	<span class="s1">}</span>

	<span class="s1">for (var i = 1, isOwn = true; i &lt; parts.length; i += 1) {</span>
		<span class="s1">var part = parts[i];</span>
		<span class="s1">var first = $strSlice(part, 0, 1);</span>
		<span class="s1">var last = $strSlice(part, -1);</span>
		<span class="s1">if (</span>
			<span class="s1">(</span>
				<span class="s1">(first === '&quot;' || first === &quot;'&quot; || first === '`')</span>
				<span class="s1">|| (last === '&quot;' || last === &quot;'&quot; || last === '`')</span>
			<span class="s1">)</span>
			<span class="s1">&amp;&amp; first !== last</span>
		<span class="s1">) {</span>
			<span class="s1">throw new $SyntaxError('property names with quotes must have matching quotes');</span>
		<span class="s1">}</span>
		<span class="s1">if (part === 'constructor' || !isOwn) {</span>
			<span class="s1">skipFurtherCaching = true;</span>
		<span class="s1">}</span>

		<span class="s1">intrinsicBaseName += '.' + part;</span>
		<span class="s1">intrinsicRealName = '%' + intrinsicBaseName + '%';</span>

		<span class="s1">if (hasOwn(INTRINSICS, intrinsicRealName)) {</span>
			<span class="s1">value = INTRINSICS[intrinsicRealName];</span>
		<span class="s1">} else if (value != null) {</span>
			<span class="s1">if (!(part in value)) {</span>
				<span class="s1">if (!allowMissing) {</span>
					<span class="s1">throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');</span>
				<span class="s1">}</span>
				<span class="s1">return void undefined;</span>
			<span class="s1">}</span>
			<span class="s1">if ($gOPD &amp;&amp; (i + 1) &gt;= parts.length) {</span>
				<span class="s1">var desc = $gOPD(value, part);</span>
				<span class="s1">isOwn = !!desc;</span>

				<span class="s1">// By convention, when a data property is converted to an accessor</span>
				<span class="s1">// property to emulate a data property that does not suffer from</span>
				<span class="s1">// the override mistake, that accessor's getter is marked with</span>
				<span class="s1">// an `originalValue` property. Here, when we detect this, we</span>
				<span class="s1">// uphold the illusion by pretending to see that original data</span>
				<span class="s1">// property, i.e., returning the value rather than the getter</span>
				<span class="s1">// itself.</span>
				<span class="s1">if (isOwn &amp;&amp; 'get' in desc &amp;&amp; !('originalValue' in desc.get)) {</span>
					<span class="s1">value = desc.get;</span>
				<span class="s1">} else {</span>
					<span class="s1">value = value[part];</span>
				<span class="s1">}</span>
			<span class="s1">} else {</span>
				<span class="s1">isOwn = hasOwn(value, part);</span>
				<span class="s1">value = value[part];</span>
			<span class="s1">}</span>

			<span class="s1">if (isOwn &amp;&amp; !skipFurtherCaching) {</span>
				<span class="s1">INTRINSICS[intrinsicRealName] = value;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return value;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;function-bind&quot;:37,&quot;has&quot;:45,&quot;has-symbols&quot;:42}],40:[function(require,module,exports){</span>
<span class="s1">(function (global){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">var $BigInt = global.BigInt;</span>

<span class="s1">module.exports = function hasNativeBigInts() {</span>
	<span class="s1">return typeof $BigInt === 'function'</span>
		<span class="s1">&amp;&amp; typeof BigInt === 'function'</span>
		<span class="s1">&amp;&amp; typeof $BigInt(42) === 'bigint' // eslint-disable-line no-magic-numbers</span>
		<span class="s1">&amp;&amp; typeof BigInt(42) === 'bigint'; // eslint-disable-line no-magic-numbers</span>
<span class="s1">};</span>

<span class="s1">}).call(this)}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})</span>

<span class="s1">},{}],41:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>

<span class="s1">var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);</span>

<span class="s1">var hasPropertyDescriptors = function hasPropertyDescriptors() {</span>
	<span class="s1">if ($defineProperty) {</span>
		<span class="s1">try {</span>
			<span class="s1">$defineProperty({}, 'a', { value: 1 });</span>
			<span class="s1">return true;</span>
		<span class="s1">} catch (e) {</span>
			<span class="s1">// IE 8 has a broken defineProperty</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return false;</span>
<span class="s1">};</span>

<span class="s1">hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {</span>
	<span class="s1">// node v0.6 has a bug where array lengths can be Set but not Defined</span>
	<span class="s1">if (!hasPropertyDescriptors()) {</span>
		<span class="s1">return null;</span>
	<span class="s1">}</span>
	<span class="s1">try {</span>
		<span class="s1">return $defineProperty([], 'length', { value: 1 }).length !== 1;</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">// In Firefox 4-22, defining length on an array throws an exception.</span>
		<span class="s1">return true;</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">module.exports = hasPropertyDescriptors;</span>

<span class="s1">},{&quot;get-intrinsic&quot;:39}],42:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var origSymbol = typeof Symbol !== 'undefined' &amp;&amp; Symbol;</span>
<span class="s1">var hasSymbolSham = require('./shams');</span>

<span class="s1">module.exports = function hasNativeSymbols() {</span>
	<span class="s1">if (typeof origSymbol !== 'function') { return false; }</span>
	<span class="s1">if (typeof Symbol !== 'function') { return false; }</span>
	<span class="s1">if (typeof origSymbol('foo') !== 'symbol') { return false; }</span>
	<span class="s1">if (typeof Symbol('bar') !== 'symbol') { return false; }</span>

	<span class="s1">return hasSymbolSham();</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./shams&quot;:43}],43:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">/* eslint complexity: [2, 18], max-statements: [2, 33] */</span>
<span class="s1">module.exports = function hasSymbols() {</span>
	<span class="s1">if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }</span>
	<span class="s1">if (typeof Symbol.iterator === 'symbol') { return true; }</span>

	<span class="s1">var obj = {};</span>
	<span class="s1">var sym = Symbol('test');</span>
	<span class="s1">var symObj = Object(sym);</span>
	<span class="s1">if (typeof sym === 'string') { return false; }</span>

	<span class="s1">if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }</span>
	<span class="s1">if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }</span>

	<span class="s1">// temp disabled per https://github.com/ljharb/object.assign/issues/17</span>
	<span class="s1">// if (sym instanceof Symbol) { return false; }</span>
	<span class="s1">// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4</span>
	<span class="s1">// if (!(symObj instanceof Symbol)) { return false; }</span>

	<span class="s1">// if (typeof Symbol.prototype.toString !== 'function') { return false; }</span>
	<span class="s1">// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }</span>

	<span class="s1">var symVal = 42;</span>
	<span class="s1">obj[sym] = symVal;</span>
	<span class="s1">for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop</span>
	<span class="s1">if (typeof Object.keys === 'function' &amp;&amp; Object.keys(obj).length !== 0) { return false; }</span>

	<span class="s1">if (typeof Object.getOwnPropertyNames === 'function' &amp;&amp; Object.getOwnPropertyNames(obj).length !== 0) { return false; }</span>

	<span class="s1">var syms = Object.getOwnPropertySymbols(obj);</span>
	<span class="s1">if (syms.length !== 1 || syms[0] !== sym) { return false; }</span>

	<span class="s1">if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }</span>

	<span class="s1">if (typeof Object.getOwnPropertyDescriptor === 'function') {</span>
		<span class="s1">var descriptor = Object.getOwnPropertyDescriptor(obj, sym);</span>
		<span class="s1">if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }</span>
	<span class="s1">}</span>

	<span class="s1">return true;</span>
<span class="s1">};</span>

<span class="s1">},{}],44:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var hasSymbols = require('has-symbols/shams');</span>

<span class="s1">module.exports = function hasToStringTagShams() {</span>
	<span class="s1">return hasSymbols() &amp;&amp; !!Symbol.toStringTag;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;has-symbols/shams&quot;:43}],45:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var bind = require('function-bind');</span>

<span class="s1">module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);</span>

<span class="s1">},{&quot;function-bind&quot;:37}],46:[function(require,module,exports){</span>
<span class="s1">/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh &lt;https://feross.org/opensource&gt; */</span>
<span class="s1">exports.read = function (buffer, offset, isLE, mLen, nBytes) {</span>
  <span class="s1">var e, m</span>
  <span class="s1">var eLen = (nBytes * 8) - mLen - 1</span>
  <span class="s1">var eMax = (1 &lt;&lt; eLen) - 1</span>
  <span class="s1">var eBias = eMax &gt;&gt; 1</span>
  <span class="s1">var nBits = -7</span>
  <span class="s1">var i = isLE ? (nBytes - 1) : 0</span>
  <span class="s1">var d = isLE ? -1 : 1</span>
  <span class="s1">var s = buffer[offset + i]</span>

  <span class="s1">i += d</span>

  <span class="s1">e = s &amp; ((1 &lt;&lt; (-nBits)) - 1)</span>
  <span class="s1">s &gt;&gt;= (-nBits)</span>
  <span class="s1">nBits += eLen</span>
  <span class="s1">for (; nBits &gt; 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}</span>

  <span class="s1">m = e &amp; ((1 &lt;&lt; (-nBits)) - 1)</span>
  <span class="s1">e &gt;&gt;= (-nBits)</span>
  <span class="s1">nBits += mLen</span>
  <span class="s1">for (; nBits &gt; 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}</span>

  <span class="s1">if (e === 0) {</span>
    <span class="s1">e = 1 - eBias</span>
  <span class="s1">} else if (e === eMax) {</span>
    <span class="s1">return m ? NaN : ((s ? -1 : 1) * Infinity)</span>
  <span class="s1">} else {</span>
    <span class="s1">m = m + Math.pow(2, mLen)</span>
    <span class="s1">e = e - eBias</span>
  <span class="s1">}</span>
  <span class="s1">return (s ? -1 : 1) * m * Math.pow(2, e - mLen)</span>
<span class="s1">}</span>

<span class="s1">exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {</span>
  <span class="s1">var e, m, c</span>
  <span class="s1">var eLen = (nBytes * 8) - mLen - 1</span>
  <span class="s1">var eMax = (1 &lt;&lt; eLen) - 1</span>
  <span class="s1">var eBias = eMax &gt;&gt; 1</span>
  <span class="s1">var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)</span>
  <span class="s1">var i = isLE ? 0 : (nBytes - 1)</span>
  <span class="s1">var d = isLE ? 1 : -1</span>
  <span class="s1">var s = value &lt; 0 || (value === 0 &amp;&amp; 1 / value &lt; 0) ? 1 : 0</span>

  <span class="s1">value = Math.abs(value)</span>

  <span class="s1">if (isNaN(value) || value === Infinity) {</span>
    <span class="s1">m = isNaN(value) ? 1 : 0</span>
    <span class="s1">e = eMax</span>
  <span class="s1">} else {</span>
    <span class="s1">e = Math.floor(Math.log(value) / Math.LN2)</span>
    <span class="s1">if (value * (c = Math.pow(2, -e)) &lt; 1) {</span>
      <span class="s1">e--</span>
      <span class="s1">c *= 2</span>
    <span class="s1">}</span>
    <span class="s1">if (e + eBias &gt;= 1) {</span>
      <span class="s1">value += rt / c</span>
    <span class="s1">} else {</span>
      <span class="s1">value += rt * Math.pow(2, 1 - eBias)</span>
    <span class="s1">}</span>
    <span class="s1">if (value * c &gt;= 2) {</span>
      <span class="s1">e++</span>
      <span class="s1">c /= 2</span>
    <span class="s1">}</span>

    <span class="s1">if (e + eBias &gt;= eMax) {</span>
      <span class="s1">m = 0</span>
      <span class="s1">e = eMax</span>
    <span class="s1">} else if (e + eBias &gt;= 1) {</span>
      <span class="s1">m = ((value * c) - 1) * Math.pow(2, mLen)</span>
      <span class="s1">e = e + eBias</span>
    <span class="s1">} else {</span>
      <span class="s1">m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)</span>
      <span class="s1">e = 0</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">for (; mLen &gt;= 8; buffer[offset + i] = m &amp; 0xff, i += d, m /= 256, mLen -= 8) {}</span>

  <span class="s1">e = (e &lt;&lt; mLen) | m</span>
  <span class="s1">eLen += mLen</span>
  <span class="s1">for (; eLen &gt; 0; buffer[offset + i] = e &amp; 0xff, i += d, e /= 256, eLen -= 8) {}</span>

  <span class="s1">buffer[offset + i - d] |= s * 128</span>
<span class="s1">}</span>

<span class="s1">},{}],47:[function(require,module,exports){</span>
<span class="s1">if (typeof Object.create === 'function') {</span>
  <span class="s1">// implementation from standard node.js 'util' module</span>
  <span class="s1">module.exports = function inherits(ctor, superCtor) {</span>
    <span class="s1">if (superCtor) {</span>
      <span class="s1">ctor.super_ = superCtor</span>
      <span class="s1">ctor.prototype = Object.create(superCtor.prototype, {</span>
        <span class="s1">constructor: {</span>
          <span class="s1">value: ctor,</span>
          <span class="s1">enumerable: false,</span>
          <span class="s1">writable: true,</span>
          <span class="s1">configurable: true</span>
        <span class="s1">}</span>
      <span class="s1">})</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">} else {</span>
  <span class="s1">// old school shim for old browsers</span>
  <span class="s1">module.exports = function inherits(ctor, superCtor) {</span>
    <span class="s1">if (superCtor) {</span>
      <span class="s1">ctor.super_ = superCtor</span>
      <span class="s1">var TempCtor = function () {}</span>
      <span class="s1">TempCtor.prototype = superCtor.prototype</span>
      <span class="s1">ctor.prototype = new TempCtor()</span>
      <span class="s1">ctor.prototype.constructor = ctor</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">},{}],48:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var hasToStringTag = require('has-tostringtag/shams')();</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>

<span class="s1">var $toString = callBound('Object.prototype.toString');</span>

<span class="s1">var isStandardArguments = function isArguments(value) {</span>
	<span class="s1">if (hasToStringTag &amp;&amp; value &amp;&amp; typeof value === 'object' &amp;&amp; Symbol.toStringTag in value) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">return $toString(value) === '[object Arguments]';</span>
<span class="s1">};</span>

<span class="s1">var isLegacyArguments = function isArguments(value) {</span>
	<span class="s1">if (isStandardArguments(value)) {</span>
		<span class="s1">return true;</span>
	<span class="s1">}</span>
	<span class="s1">return value !== null &amp;&amp;</span>
		<span class="s1">typeof value === 'object' &amp;&amp;</span>
		<span class="s1">typeof value.length === 'number' &amp;&amp;</span>
		<span class="s1">value.length &gt;= 0 &amp;&amp;</span>
		<span class="s1">$toString(value) !== '[object Array]' &amp;&amp;</span>
		<span class="s1">$toString(value.callee) === '[object Function]';</span>
<span class="s1">};</span>

<span class="s1">var supportsStandardArguments = (function () {</span>
	<span class="s1">return isStandardArguments(arguments);</span>
<span class="s1">}());</span>

<span class="s1">isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests</span>

<span class="s1">module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;has-tostringtag/shams&quot;:44}],49:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var hasBigInts = require('has-bigints')();</span>

<span class="s1">if (hasBigInts) {</span>
	<span class="s1">var bigIntValueOf = BigInt.prototype.valueOf;</span>
	<span class="s1">var tryBigInt = function tryBigIntObject(value) {</span>
		<span class="s1">try {</span>
			<span class="s1">bigIntValueOf.call(value);</span>
			<span class="s1">return true;</span>
		<span class="s1">} catch (e) {</span>
		<span class="s1">}</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>

	<span class="s1">module.exports = function isBigInt(value) {</span>
		<span class="s1">if (</span>
			<span class="s1">value === null</span>
			<span class="s1">|| typeof value === 'undefined'</span>
			<span class="s1">|| typeof value === 'boolean'</span>
			<span class="s1">|| typeof value === 'string'</span>
			<span class="s1">|| typeof value === 'number'</span>
			<span class="s1">|| typeof value === 'symbol'</span>
			<span class="s1">|| typeof value === 'function'</span>
		<span class="s1">) {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>
		<span class="s1">if (typeof value === 'bigint') {</span>
			<span class="s1">return true;</span>
		<span class="s1">}</span>

		<span class="s1">return tryBigInt(value);</span>
	<span class="s1">};</span>
<span class="s1">} else {</span>
	<span class="s1">module.exports = function isBigInt(value) {</span>
		<span class="s1">return false &amp;&amp; value;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">},{&quot;has-bigints&quot;:40}],50:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var $boolToStr = callBound('Boolean.prototype.toString');</span>
<span class="s1">var $toString = callBound('Object.prototype.toString');</span>

<span class="s1">var tryBooleanObject = function booleanBrandCheck(value) {</span>
	<span class="s1">try {</span>
		<span class="s1">$boolToStr(value);</span>
		<span class="s1">return true;</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">var boolClass = '[object Boolean]';</span>
<span class="s1">var hasToStringTag = require('has-tostringtag/shams')();</span>

<span class="s1">module.exports = function isBoolean(value) {</span>
	<span class="s1">if (typeof value === 'boolean') {</span>
		<span class="s1">return true;</span>
	<span class="s1">}</span>
	<span class="s1">if (value === null || typeof value !== 'object') {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">return hasToStringTag &amp;&amp; Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;has-tostringtag/shams&quot;:44}],51:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var fnToStr = Function.prototype.toString;</span>
<span class="s1">var reflectApply = typeof Reflect === 'object' &amp;&amp; Reflect !== null &amp;&amp; Reflect.apply;</span>
<span class="s1">var badArrayLike;</span>
<span class="s1">var isCallableMarker;</span>
<span class="s1">if (typeof reflectApply === 'function' &amp;&amp; typeof Object.defineProperty === 'function') {</span>
	<span class="s1">try {</span>
		<span class="s1">badArrayLike = Object.defineProperty({}, 'length', {</span>
			<span class="s1">get: function () {</span>
				<span class="s1">throw isCallableMarker;</span>
			<span class="s1">}</span>
		<span class="s1">});</span>
		<span class="s1">isCallableMarker = {};</span>
		<span class="s1">// eslint-disable-next-line no-throw-literal</span>
		<span class="s1">reflectApply(function () { throw 42; }, null, badArrayLike);</span>
	<span class="s1">} catch (_) {</span>
		<span class="s1">if (_ !== isCallableMarker) {</span>
			<span class="s1">reflectApply = null;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">} else {</span>
	<span class="s1">reflectApply = null;</span>
<span class="s1">}</span>

<span class="s1">var constructorRegex = /^\s*class\b/;</span>
<span class="s1">var isES6ClassFn = function isES6ClassFunction(value) {</span>
	<span class="s1">try {</span>
		<span class="s1">var fnStr = fnToStr.call(value);</span>
		<span class="s1">return constructorRegex.test(fnStr);</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">return false; // not a function</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">var tryFunctionObject = function tryFunctionToStr(value) {</span>
	<span class="s1">try {</span>
		<span class="s1">if (isES6ClassFn(value)) { return false; }</span>
		<span class="s1">fnToStr.call(value);</span>
		<span class="s1">return true;</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">var toStr = Object.prototype.toString;</span>
<span class="s1">var fnClass = '[object Function]';</span>
<span class="s1">var genClass = '[object GeneratorFunction]';</span>
<span class="s1">var hasToStringTag = typeof Symbol === 'function' &amp;&amp; !!Symbol.toStringTag; // better: use `has-tostringtag`</span>
<span class="s1">/* globals document: false */</span>
<span class="s1">var documentDotAll = typeof document === 'object' &amp;&amp; typeof document.all === 'undefined' &amp;&amp; document.all !== undefined ? document.all : {};</span>

<span class="s1">module.exports = reflectApply</span>
	<span class="s1">? function isCallable(value) {</span>
		<span class="s1">if (value === documentDotAll) { return true; }</span>
		<span class="s1">if (!value) { return false; }</span>
		<span class="s1">if (typeof value !== 'function' &amp;&amp; typeof value !== 'object') { return false; }</span>
		<span class="s1">if (typeof value === 'function' &amp;&amp; !value.prototype) { return true; }</span>
		<span class="s1">try {</span>
			<span class="s1">reflectApply(value, null, badArrayLike);</span>
		<span class="s1">} catch (e) {</span>
			<span class="s1">if (e !== isCallableMarker) { return false; }</span>
		<span class="s1">}</span>
		<span class="s1">return !isES6ClassFn(value);</span>
	<span class="s1">}</span>
	<span class="s1">: function isCallable(value) {</span>
		<span class="s1">if (value === documentDotAll) { return true; }</span>
		<span class="s1">if (!value) { return false; }</span>
		<span class="s1">if (typeof value !== 'function' &amp;&amp; typeof value !== 'object') { return false; }</span>
		<span class="s1">if (typeof value === 'function' &amp;&amp; !value.prototype) { return true; }</span>
		<span class="s1">if (hasToStringTag) { return tryFunctionObject(value); }</span>
		<span class="s1">if (isES6ClassFn(value)) { return false; }</span>
		<span class="s1">var strClass = toStr.call(value);</span>
		<span class="s1">return strClass === fnClass || strClass === genClass;</span>
	<span class="s1">};</span>

<span class="s1">},{}],52:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var getDay = Date.prototype.getDay;</span>
<span class="s1">var tryDateObject = function tryDateGetDayCall(value) {</span>
	<span class="s1">try {</span>
		<span class="s1">getDay.call(value);</span>
		<span class="s1">return true;</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">var toStr = Object.prototype.toString;</span>
<span class="s1">var dateClass = '[object Date]';</span>
<span class="s1">var hasToStringTag = require('has-tostringtag/shams')();</span>

<span class="s1">module.exports = function isDateObject(value) {</span>
	<span class="s1">if (typeof value !== 'object' || value === null) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;has-tostringtag/shams&quot;:44}],53:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var $Map = typeof Map === 'function' &amp;&amp; Map.prototype ? Map : null;</span>
<span class="s1">var $Set = typeof Set === 'function' &amp;&amp; Set.prototype ? Set : null;</span>

<span class="s1">var exported;</span>

<span class="s1">if (!$Map) {</span>
	<span class="s1">// eslint-disable-next-line no-unused-vars</span>
	<span class="s1">exported = function isMap(x) {</span>
		<span class="s1">// `Map` is not present in this environment.</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">var $mapHas = $Map ? Map.prototype.has : null;</span>
<span class="s1">var $setHas = $Set ? Set.prototype.has : null;</span>
<span class="s1">if (!exported &amp;&amp; !$mapHas) {</span>
	<span class="s1">// eslint-disable-next-line no-unused-vars</span>
	<span class="s1">exported = function isMap(x) {</span>
		<span class="s1">// `Map` does not have a `has` method</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">module.exports = exported || function isMap(x) {</span>
	<span class="s1">if (!x || typeof x !== 'object') {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">try {</span>
		<span class="s1">$mapHas.call(x);</span>
		<span class="s1">if ($setHas) {</span>
			<span class="s1">try {</span>
				<span class="s1">$setHas.call(x);</span>
			<span class="s1">} catch (e) {</span>
				<span class="s1">return true;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">return x instanceof $Map; // core-js workaround, pre-v2.5.0</span>
	<span class="s1">} catch (e) {}</span>
	<span class="s1">return false;</span>
<span class="s1">};</span>

<span class="s1">},{}],54:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var numToStr = Number.prototype.toString;</span>
<span class="s1">var tryNumberObject = function tryNumberObject(value) {</span>
	<span class="s1">try {</span>
		<span class="s1">numToStr.call(value);</span>
		<span class="s1">return true;</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">var toStr = Object.prototype.toString;</span>
<span class="s1">var numClass = '[object Number]';</span>
<span class="s1">var hasToStringTag = require('has-tostringtag/shams')();</span>

<span class="s1">module.exports = function isNumberObject(value) {</span>
	<span class="s1">if (typeof value === 'number') {</span>
		<span class="s1">return true;</span>
	<span class="s1">}</span>
	<span class="s1">if (typeof value !== 'object') {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;has-tostringtag/shams&quot;:44}],55:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var hasToStringTag = require('has-tostringtag/shams')();</span>
<span class="s1">var has;</span>
<span class="s1">var $exec;</span>
<span class="s1">var isRegexMarker;</span>
<span class="s1">var badStringifier;</span>

<span class="s1">if (hasToStringTag) {</span>
	<span class="s1">has = callBound('Object.prototype.hasOwnProperty');</span>
	<span class="s1">$exec = callBound('RegExp.prototype.exec');</span>
	<span class="s1">isRegexMarker = {};</span>

	<span class="s1">var throwRegexMarker = function () {</span>
		<span class="s1">throw isRegexMarker;</span>
	<span class="s1">};</span>
	<span class="s1">badStringifier = {</span>
		<span class="s1">toString: throwRegexMarker,</span>
		<span class="s1">valueOf: throwRegexMarker</span>
	<span class="s1">};</span>

	<span class="s1">if (typeof Symbol.toPrimitive === 'symbol') {</span>
		<span class="s1">badStringifier[Symbol.toPrimitive] = throwRegexMarker;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">var $toString = callBound('Object.prototype.toString');</span>
<span class="s1">var gOPD = Object.getOwnPropertyDescriptor;</span>
<span class="s1">var regexClass = '[object RegExp]';</span>

<span class="s1">module.exports = hasToStringTag</span>
	<span class="s1">// eslint-disable-next-line consistent-return</span>
	<span class="s1">? function isRegex(value) {</span>
		<span class="s1">if (!value || typeof value !== 'object') {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>

		<span class="s1">var descriptor = gOPD(value, 'lastIndex');</span>
		<span class="s1">var hasLastIndexDataProperty = descriptor &amp;&amp; has(descriptor, 'value');</span>
		<span class="s1">if (!hasLastIndexDataProperty) {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>

		<span class="s1">try {</span>
			<span class="s1">$exec(value, badStringifier);</span>
		<span class="s1">} catch (e) {</span>
			<span class="s1">return e === isRegexMarker;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">: function isRegex(value) {</span>
		<span class="s1">// In older browsers, typeof regex incorrectly returns 'function'</span>
		<span class="s1">if (!value || (typeof value !== 'object' &amp;&amp; typeof value !== 'function')) {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>

		<span class="s1">return $toString(value) === regexClass;</span>
	<span class="s1">};</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;has-tostringtag/shams&quot;:44}],56:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var $Map = typeof Map === 'function' &amp;&amp; Map.prototype ? Map : null;</span>
<span class="s1">var $Set = typeof Set === 'function' &amp;&amp; Set.prototype ? Set : null;</span>

<span class="s1">var exported;</span>

<span class="s1">if (!$Set) {</span>
	<span class="s1">// eslint-disable-next-line no-unused-vars</span>
	<span class="s1">exported = function isSet(x) {</span>
		<span class="s1">// `Set` is not present in this environment.</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">var $mapHas = $Map ? Map.prototype.has : null;</span>
<span class="s1">var $setHas = $Set ? Set.prototype.has : null;</span>
<span class="s1">if (!exported &amp;&amp; !$setHas) {</span>
	<span class="s1">// eslint-disable-next-line no-unused-vars</span>
	<span class="s1">exported = function isSet(x) {</span>
		<span class="s1">// `Set` does not have a `has` method</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">module.exports = exported || function isSet(x) {</span>
	<span class="s1">if (!x || typeof x !== 'object') {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">try {</span>
		<span class="s1">$setHas.call(x);</span>
		<span class="s1">if ($mapHas) {</span>
			<span class="s1">try {</span>
				<span class="s1">$mapHas.call(x);</span>
			<span class="s1">} catch (e) {</span>
				<span class="s1">return true;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">return x instanceof $Set; // core-js workaround, pre-v2.5.0</span>
	<span class="s1">} catch (e) {}</span>
	<span class="s1">return false;</span>
<span class="s1">};</span>

<span class="s1">},{}],57:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var strValue = String.prototype.valueOf;</span>
<span class="s1">var tryStringObject = function tryStringObject(value) {</span>
	<span class="s1">try {</span>
		<span class="s1">strValue.call(value);</span>
		<span class="s1">return true;</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">var toStr = Object.prototype.toString;</span>
<span class="s1">var strClass = '[object String]';</span>
<span class="s1">var hasToStringTag = require('has-tostringtag/shams')();</span>

<span class="s1">module.exports = function isString(value) {</span>
	<span class="s1">if (typeof value === 'string') {</span>
		<span class="s1">return true;</span>
	<span class="s1">}</span>
	<span class="s1">if (typeof value !== 'object') {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;has-tostringtag/shams&quot;:44}],58:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var toStr = Object.prototype.toString;</span>
<span class="s1">var hasSymbols = require('has-symbols')();</span>

<span class="s1">if (hasSymbols) {</span>
	<span class="s1">var symToStr = Symbol.prototype.toString;</span>
	<span class="s1">var symStringRegex = /^Symbol\(.*\)$/;</span>
	<span class="s1">var isSymbolObject = function isRealSymbolObject(value) {</span>
		<span class="s1">if (typeof value.valueOf() !== 'symbol') {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>
		<span class="s1">return symStringRegex.test(symToStr.call(value));</span>
	<span class="s1">};</span>

	<span class="s1">module.exports = function isSymbol(value) {</span>
		<span class="s1">if (typeof value === 'symbol') {</span>
			<span class="s1">return true;</span>
		<span class="s1">}</span>
		<span class="s1">if (toStr.call(value) !== '[object Symbol]') {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>
		<span class="s1">try {</span>
			<span class="s1">return isSymbolObject(value);</span>
		<span class="s1">} catch (e) {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>
	<span class="s1">};</span>
<span class="s1">} else {</span>

	<span class="s1">module.exports = function isSymbol(value) {</span>
		<span class="s1">// this environment does not support Symbols.</span>
		<span class="s1">return false &amp;&amp; value;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">},{&quot;has-symbols&quot;:42}],59:[function(require,module,exports){</span>
<span class="s1">(function (global){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">var forEach = require('foreach');</span>
<span class="s1">var availableTypedArrays = require('available-typed-arrays');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>

<span class="s1">var $toString = callBound('Object.prototype.toString');</span>
<span class="s1">var hasToStringTag = require('has-tostringtag/shams')();</span>

<span class="s1">var g = typeof globalThis === 'undefined' ? global : globalThis;</span>
<span class="s1">var typedArrays = availableTypedArrays();</span>

<span class="s1">var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {</span>
	<span class="s1">for (var i = 0; i &lt; array.length; i += 1) {</span>
		<span class="s1">if (array[i] === value) {</span>
			<span class="s1">return i;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return -1;</span>
<span class="s1">};</span>
<span class="s1">var $slice = callBound('String.prototype.slice');</span>
<span class="s1">var toStrTags = {};</span>
<span class="s1">var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');</span>
<span class="s1">var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');</span>
<span class="s1">if (hasToStringTag &amp;&amp; gOPD &amp;&amp; getPrototypeOf) {</span>
	<span class="s1">forEach(typedArrays, function (typedArray) {</span>
		<span class="s1">var arr = new g[typedArray]();</span>
		<span class="s1">if (Symbol.toStringTag in arr) {</span>
			<span class="s1">var proto = getPrototypeOf(arr);</span>
			<span class="s1">var descriptor = gOPD(proto, Symbol.toStringTag);</span>
			<span class="s1">if (!descriptor) {</span>
				<span class="s1">var superProto = getPrototypeOf(proto);</span>
				<span class="s1">descriptor = gOPD(superProto, Symbol.toStringTag);</span>
			<span class="s1">}</span>
			<span class="s1">toStrTags[typedArray] = descriptor.get;</span>
		<span class="s1">}</span>
	<span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">var tryTypedArrays = function tryAllTypedArrays(value) {</span>
	<span class="s1">var anyTrue = false;</span>
	<span class="s1">forEach(toStrTags, function (getter, typedArray) {</span>
		<span class="s1">if (!anyTrue) {</span>
			<span class="s1">try {</span>
				<span class="s1">anyTrue = getter.call(value) === typedArray;</span>
			<span class="s1">} catch (e) { /**/ }</span>
		<span class="s1">}</span>
	<span class="s1">});</span>
	<span class="s1">return anyTrue;</span>
<span class="s1">};</span>

<span class="s1">module.exports = function isTypedArray(value) {</span>
	<span class="s1">if (!value || typeof value !== 'object') { return false; }</span>
	<span class="s1">if (!hasToStringTag || !(Symbol.toStringTag in value)) {</span>
		<span class="s1">var tag = $slice($toString(value), 8, -1);</span>
		<span class="s1">return $indexOf(typedArrays, tag) &gt; -1;</span>
	<span class="s1">}</span>
	<span class="s1">if (!gOPD) { return false; }</span>
	<span class="s1">return tryTypedArrays(value);</span>
<span class="s1">};</span>

<span class="s1">}).call(this)}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})</span>

<span class="s1">},{&quot;available-typed-arrays&quot;:7,&quot;call-bind/callBound&quot;:11,&quot;es-abstract/helpers/getOwnPropertyDescriptor&quot;:26,&quot;foreach&quot;:35,&quot;has-tostringtag/shams&quot;:44}],60:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var $WeakMap = typeof WeakMap === 'function' &amp;&amp; WeakMap.prototype ? WeakMap : null;</span>
<span class="s1">var $WeakSet = typeof WeakSet === 'function' &amp;&amp; WeakSet.prototype ? WeakSet : null;</span>

<span class="s1">var exported;</span>

<span class="s1">if (!$WeakMap) {</span>
	<span class="s1">// eslint-disable-next-line no-unused-vars</span>
	<span class="s1">exported = function isWeakMap(x) {</span>
		<span class="s1">// `WeakMap` is not present in this environment.</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;</span>
<span class="s1">var $setHas = $WeakSet ? $WeakSet.prototype.has : null;</span>
<span class="s1">if (!exported &amp;&amp; !$mapHas) {</span>
	<span class="s1">// eslint-disable-next-line no-unused-vars</span>
	<span class="s1">exported = function isWeakMap(x) {</span>
		<span class="s1">// `WeakMap` does not have a `has` method</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">module.exports = exported || function isWeakMap(x) {</span>
	<span class="s1">if (!x || typeof x !== 'object') {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">try {</span>
		<span class="s1">$mapHas.call(x, $mapHas);</span>
		<span class="s1">if ($setHas) {</span>
			<span class="s1">try {</span>
				<span class="s1">$setHas.call(x, $setHas);</span>
			<span class="s1">} catch (e) {</span>
				<span class="s1">return true;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">return x instanceof $WeakMap; // core-js workaround, pre-v3</span>
	<span class="s1">} catch (e) {}</span>
	<span class="s1">return false;</span>
<span class="s1">};</span>

<span class="s1">},{}],61:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>

<span class="s1">var $WeakSet = GetIntrinsic('%WeakSet%', true);</span>

<span class="s1">var $setHas = callBound('WeakSet.prototype.has', true);</span>

<span class="s1">if ($setHas) {</span>
	<span class="s1">var $mapHas = callBound('WeakMap.prototype.has', true);</span>

	<span class="s1">module.exports = function isWeakSet(x) {</span>
		<span class="s1">if (!x || typeof x !== 'object') {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>
		<span class="s1">try {</span>
			<span class="s1">$setHas(x, $setHas);</span>
			<span class="s1">if ($mapHas) {</span>
				<span class="s1">try {</span>
					<span class="s1">$mapHas(x, $mapHas);</span>
				<span class="s1">} catch (e) {</span>
					<span class="s1">return true;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s1">return x instanceof $WeakSet; // core-js workaround, pre-v3</span>
		<span class="s1">} catch (e) {}</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>
<span class="s1">} else {</span>
	<span class="s1">// eslint-disable-next-line no-unused-vars</span>
	<span class="s1">module.exports = function isWeakSet(x) {</span>
		<span class="s1">// `WeakSet` does not exist, or does not have a `has` method</span>
		<span class="s1">return false;</span>
	<span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;get-intrinsic&quot;:39}],62:[function(require,module,exports){</span>
<span class="s1">arguments[4][15][0].apply(exports,arguments)</span>
<span class="s1">},{&quot;dup&quot;:15}],63:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var has = require('has');</span>
<span class="s1">var hasPropertyDescriptors = require('has-property-descriptors');</span>
<span class="s1">var isArray = require('isarray');</span>
<span class="s1">var functionsHaveConfigurableNames = require('functions-have-names').functionsHaveConfigurableNames();</span>

<span class="s1">var $defineProperty = hasPropertyDescriptors() &amp;&amp; Object.defineProperty;</span>

<span class="s1">var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();</span>

<span class="s1">var gOPD = Object.getOwnPropertyDescriptor;</span>

<span class="s1">var $TypeError = TypeError;</span>
<span class="s1">var $SyntaxError = SyntaxError;</span>

<span class="s1">module.exports = function mockProperty(obj, prop, options) {</span>
	<span class="s1">if (has(options, 'nonEnumerable') &amp;&amp; typeof options.nonEnumerable !== 'boolean') {</span>
		<span class="s1">throw new $TypeError('`nonEnumerable` option, when present, must be a boolean');</span>
	<span class="s1">}</span>
	<span class="s1">if (has(options, 'nonWritable') &amp;&amp; typeof options.nonWritable !== 'boolean') {</span>
		<span class="s1">throw new $TypeError('`nonEnumerable` option, when present, must be a boolean');</span>
	<span class="s1">}</span>
	<span class="s1">if (has(options, 'delete') &amp;&amp; typeof options['delete'] !== 'boolean') {</span>
		<span class="s1">throw new $TypeError('`delete` option, when present, must be a boolean');</span>
	<span class="s1">}</span>

	<span class="s1">var wantsData = has(options, 'value') || has(options, 'nonWritable');</span>
	<span class="s1">var wantsAccessor = has(options, 'get') || has(options, 'set');</span>

	<span class="s1">if (wantsAccessor) {</span>
		<span class="s1">if (wantsData) {</span>
			<span class="s1">throw new $TypeError('`value` and `nonWritable` options are mutually exclusive with `get`/`set` options');</span>
		<span class="s1">}</span>
		<span class="s1">if (</span>
			<span class="s1">(has(options, 'get') &amp;&amp; typeof options.get !== 'function' &amp;&amp; typeof options.get !== 'undefined')</span>
            <span class="s1">|| (has(options, 'set') &amp;&amp; typeof options.set !== 'function' &amp;&amp; typeof options.set !== 'undefined')</span>
		<span class="s1">) {</span>
			<span class="s1">throw new $TypeError('`get` and `set` options, when present, must be functions or `undefined`');</span>
		<span class="s1">}</span>
		<span class="s1">if (!gOPD || !$defineProperty) {</span>
			<span class="s1">throw new $SyntaxError('the `get`/`set` options require native getter/setter support');</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">if (options['delete'] &amp;&amp; (wantsData || wantsAccessor || has(options, 'nonEnumerable'))) {</span>
		<span class="s1">throw new $TypeError('`delete` option must not be set to true when any of `value`, `get`, `set`, `nonWritable`, or `nonEnumerable` are provided');</span>
	<span class="s1">}</span>

	<span class="s1">var objIsArray = isArray(obj);</span>
	<span class="s1">var origDescriptor = gOPD</span>
		<span class="s1">? gOPD(obj, prop)</span>
		<span class="s1">: {</span>
			<span class="s1">configurable: typeof obj === 'function' &amp;&amp; prop === 'name' ? functionsHaveConfigurableNames : true,</span>
			<span class="s1">enumerable: !(objIsArray &amp;&amp; prop === 'length'),</span>
			<span class="s1">value: obj[prop],</span>
			<span class="s1">writable: true</span>
		<span class="s1">};</span>

	<span class="s1">var origConfigurable = origDescriptor ? origDescriptor.configurable : true;</span>
	<span class="s1">var origEnumerable = origDescriptor ? origDescriptor.enumerable : true;</span>

	<span class="s1">if (wantsAccessor) {</span>
		<span class="s1">var hasGetter = origDescriptor &amp;&amp; typeof origDescriptor.get === 'function';</span>
		<span class="s1">var hasSetter = origDescriptor &amp;&amp; typeof origDescriptor.set === 'function';</span>
		<span class="s1">var hasFutureGetter = has(options, 'get') ? typeof options.get === 'function' : hasGetter;</span>
		<span class="s1">var hasFutureSetter = has(options, 'set') ? typeof options.set === 'function' : hasSetter;</span>
		<span class="s1">if (!hasFutureGetter &amp;&amp; !hasFutureSetter) {</span>
			<span class="s1">throw new $TypeError('when the `get` or `set` options are provided, the mocked object property must end up with at least one of a getter or a setter function');</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">var isChangingEnumerability = has(options, 'nonEnumerable') ? !options.nonEnumerable !== origEnumerable : false;</span>
	<span class="s1">if (origDescriptor &amp;&amp; !origDescriptor.configurable) {</span>
		<span class="s1">if (isChangingEnumerability) {</span>
			<span class="s1">throw new $TypeError('`' + prop + '` is nonconfigurable, and can not be changed');</span>
		<span class="s1">}</span>
		<span class="s1">if (wantsAccessor) {</span>
			<span class="s1">if (has(origDescriptor, 'value')) {</span>
				<span class="s1">throw new $TypeError('`' + prop + '` is a nonconfigurable data property, and can not be changed to an accessor');</span>
			<span class="s1">}</span>

			<span class="s1">var isChangingGetter = has(options, 'get') &amp;&amp; has(origDescriptor, 'get') &amp;&amp; options.get !== origDescriptor.get;</span>
			<span class="s1">var isChangingSetter = has(options, 'set') &amp;&amp; has(origDescriptor, 'set') &amp;&amp; options.set !== origDescriptor.set;</span>

			<span class="s1">if (isChangingGetter || isChangingSetter) {</span>
				<span class="s1">throw new $TypeError('`' + prop + '` is nonconfigurable, and can not be changed');</span>
			<span class="s1">}</span>
			<span class="s1">return function restore() {};</span>
		<span class="s1">}</span>
		<span class="s1">if (has(origDescriptor, 'get') || has(origDescriptor, 'set')) {</span>
			<span class="s1">throw new $TypeError('`' + prop + '` is a nonconfigurable accessor property, and can not be changed to a data property');</span>
		<span class="s1">}</span>

		<span class="s1">var isChangingValue = has(options, 'value') &amp;&amp; has(origDescriptor, 'value') &amp;&amp; options.value !== origDescriptor.value;</span>
		<span class="s1">var isChangingWriteability = has(options, 'nonWritable') &amp;&amp; !options.nonWritable !== origDescriptor.writable;</span>

		<span class="s1">if ((!origDescriptor.writable &amp;&amp; isChangingValue) || isChangingEnumerability || isChangingWriteability) {</span>
			<span class="s1">throw new $TypeError('`' + prop + '` is nonconfigurable, and can not be changed');</span>
		<span class="s1">}</span>
		<span class="s1">if (!isChangingWriteability &amp;&amp; !isChangingValue) {</span>
			<span class="s1">return function restore() {};</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">if (options['delete']) {</span>
		<span class="s1">delete obj[prop]; // eslint-disable-line no-param-reassign</span>
	<span class="s1">} else if (</span>
		<span class="s1">wantsData</span>
            <span class="s1">&amp;&amp; !isChangingEnumerability</span>
            <span class="s1">&amp;&amp; (!origDescriptor || origDescriptor.enumerable)</span>
            <span class="s1">&amp;&amp; (!has(options, 'nonWritable') || !options.nonWritable)</span>
            <span class="s1">&amp;&amp; (!origDescriptor || origDescriptor.writable)</span>
            <span class="s1">&amp;&amp; (!gOPD || !(prop in obj))</span>
	<span class="s1">) {</span>
		<span class="s1">obj[prop] = options.value; // eslint-disable-line no-param-reassign</span>
	<span class="s1">} else {</span>
		<span class="s1">if (objIsArray &amp;&amp; prop === 'length' &amp;&amp; hasArrayLengthDefineBug) {</span>
			<span class="s1">throw new $SyntaxError('this environment does not support Define on an array’s length');</span>
		<span class="s1">}</span>

		<span class="s1">var newEnumerable = has(options, 'nonEnumerable') ? !options.nonEnumerable : origEnumerable;</span>

		<span class="s1">if (wantsData) {</span>
			<span class="s1">$defineProperty(obj, prop, {</span>
				<span class="s1">configurable: origConfigurable,</span>
				<span class="s1">enumerable: newEnumerable,</span>
				<span class="s1">value: has(options, 'value') ? options.value : origDescriptor.value,</span>
				<span class="s1">writable: has(options, 'nonWritable') ? !options.nonWritable : has(origDescriptor, 'writable') ? origDescriptor.writable : true</span>
			<span class="s1">});</span>
		<span class="s1">} else if (wantsAccessor) {</span>
			<span class="s1">var getter = has(options, 'get') ? options.get : origDescriptor &amp;&amp; origDescriptor.get;</span>
			<span class="s1">var setter = has(options, 'set') ? options.set : origDescriptor &amp;&amp; origDescriptor.set;</span>

			<span class="s1">$defineProperty(obj, prop, {</span>
				<span class="s1">configurable: origConfigurable,</span>
				<span class="s1">enumerable: newEnumerable,</span>
				<span class="s1">get: getter,</span>
				<span class="s1">set: setter</span>
			<span class="s1">});</span>
		<span class="s1">} else {</span>
			<span class="s1">$defineProperty(obj, prop, {</span>
				<span class="s1">configurable: origConfigurable,</span>
				<span class="s1">enumerable: newEnumerable</span>
			<span class="s1">});</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">return function restore() {</span>
		<span class="s1">if (!origDescriptor) {</span>
			<span class="s1">delete obj[prop]; // eslint-disable-line no-param-reassign</span>
		<span class="s1">} else if ($defineProperty) {</span>
			<span class="s1">if (has(origDescriptor, 'writable')) {</span>
				<span class="s1">$defineProperty(obj, prop, {</span>
					<span class="s1">configurable: origDescriptor.configurable,</span>
					<span class="s1">enumerable: origDescriptor.enumerable,</span>
					<span class="s1">value: origDescriptor.value,</span>
					<span class="s1">writable: origDescriptor.writable</span>
				<span class="s1">});</span>
			<span class="s1">} else {</span>
				<span class="s1">var oldGetter = origDescriptor &amp;&amp; origDescriptor.get;</span>
				<span class="s1">var oldSetter = origDescriptor &amp;&amp; origDescriptor.set;</span>

				<span class="s1">$defineProperty(obj, prop, {</span>
					<span class="s1">configurable: origDescriptor.configurable,</span>
					<span class="s1">enumerable: origDescriptor.enumerable,</span>
					<span class="s1">get: oldGetter,</span>
					<span class="s1">set: oldSetter</span>
				<span class="s1">});</span>
			<span class="s1">}</span>
		<span class="s1">} else {</span>
			<span class="s1">obj[prop] = origDescriptor.value; // eslint-disable-line no-param-reassign</span>
		<span class="s1">}</span>
	<span class="s1">};</span>
<span class="s1">};</span>

<span class="s1">},{&quot;functions-have-names&quot;:38,&quot;has&quot;:45,&quot;has-property-descriptors&quot;:41,&quot;isarray&quot;:64}],64:[function(require,module,exports){</span>
<span class="s1">arguments[4][15][0].apply(exports,arguments)</span>
<span class="s1">},{&quot;dup&quot;:15}],65:[function(require,module,exports){</span>
<span class="s1">var hasMap = typeof Map === 'function' &amp;&amp; Map.prototype;</span>
<span class="s1">var mapSizeDescriptor = Object.getOwnPropertyDescriptor &amp;&amp; hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;</span>
<span class="s1">var mapSize = hasMap &amp;&amp; mapSizeDescriptor &amp;&amp; typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;</span>
<span class="s1">var mapForEach = hasMap &amp;&amp; Map.prototype.forEach;</span>
<span class="s1">var hasSet = typeof Set === 'function' &amp;&amp; Set.prototype;</span>
<span class="s1">var setSizeDescriptor = Object.getOwnPropertyDescriptor &amp;&amp; hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;</span>
<span class="s1">var setSize = hasSet &amp;&amp; setSizeDescriptor &amp;&amp; typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;</span>
<span class="s1">var setForEach = hasSet &amp;&amp; Set.prototype.forEach;</span>
<span class="s1">var hasWeakMap = typeof WeakMap === 'function' &amp;&amp; WeakMap.prototype;</span>
<span class="s1">var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;</span>
<span class="s1">var hasWeakSet = typeof WeakSet === 'function' &amp;&amp; WeakSet.prototype;</span>
<span class="s1">var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;</span>
<span class="s1">var hasWeakRef = typeof WeakRef === 'function' &amp;&amp; WeakRef.prototype;</span>
<span class="s1">var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;</span>
<span class="s1">var booleanValueOf = Boolean.prototype.valueOf;</span>
<span class="s1">var objectToString = Object.prototype.toString;</span>
<span class="s1">var functionToString = Function.prototype.toString;</span>
<span class="s1">var $match = String.prototype.match;</span>
<span class="s1">var $slice = String.prototype.slice;</span>
<span class="s1">var $replace = String.prototype.replace;</span>
<span class="s1">var $toUpperCase = String.prototype.toUpperCase;</span>
<span class="s1">var $toLowerCase = String.prototype.toLowerCase;</span>
<span class="s1">var $test = RegExp.prototype.test;</span>
<span class="s1">var $concat = Array.prototype.concat;</span>
<span class="s1">var $join = Array.prototype.join;</span>
<span class="s1">var $arrSlice = Array.prototype.slice;</span>
<span class="s1">var $floor = Math.floor;</span>
<span class="s1">var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;</span>
<span class="s1">var gOPS = Object.getOwnPropertySymbols;</span>
<span class="s1">var symToString = typeof Symbol === 'function' &amp;&amp; typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;</span>
<span class="s1">var hasShammedSymbols = typeof Symbol === 'function' &amp;&amp; typeof Symbol.iterator === 'object';</span>
<span class="s1">// ie, `has-tostringtag/shams</span>
<span class="s1">var toStringTag = typeof Symbol === 'function' &amp;&amp; Symbol.toStringTag &amp;&amp; (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')</span>
    <span class="s1">? Symbol.toStringTag</span>
    <span class="s1">: null;</span>
<span class="s1">var isEnumerable = Object.prototype.propertyIsEnumerable;</span>

<span class="s1">var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (</span>
    <span class="s1">[].__proto__ === Array.prototype // eslint-disable-line no-proto</span>
        <span class="s1">? function (O) {</span>
            <span class="s1">return O.__proto__; // eslint-disable-line no-proto</span>
        <span class="s1">}</span>
        <span class="s1">: null</span>
<span class="s1">);</span>

<span class="s1">function addNumericSeparator(num, str) {</span>
    <span class="s1">if (</span>
        <span class="s1">num === Infinity</span>
        <span class="s1">|| num === -Infinity</span>
        <span class="s1">|| num !== num</span>
        <span class="s1">|| (num &amp;&amp; num &gt; -1000 &amp;&amp; num &lt; 1000)</span>
        <span class="s1">|| $test.call(/e/, str)</span>
    <span class="s1">) {</span>
        <span class="s1">return str;</span>
    <span class="s1">}</span>
    <span class="s1">var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;</span>
    <span class="s1">if (typeof num === 'number') {</span>
        <span class="s1">var int = num &lt; 0 ? -$floor(-num) : $floor(num); // trunc(num)</span>
        <span class="s1">if (int !== num) {</span>
            <span class="s1">var intStr = String(int);</span>
            <span class="s1">var dec = $slice.call(str, intStr.length + 1);</span>
            <span class="s1">return $replace.call(intStr, sepRegex, '$&amp;_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&amp;_'), /_$/, '');</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return $replace.call(str, sepRegex, '$&amp;_');</span>
<span class="s1">}</span>

<span class="s1">var inspectCustom = require('./util.inspect').custom;</span>
<span class="s1">var inspectSymbol = inspectCustom &amp;&amp; isSymbol(inspectCustom) ? inspectCustom : null;</span>

<span class="s1">module.exports = function inspect_(obj, options, depth, seen) {</span>
    <span class="s1">var opts = options || {};</span>

    <span class="s1">if (has(opts, 'quoteStyle') &amp;&amp; (opts.quoteStyle !== 'single' &amp;&amp; opts.quoteStyle !== 'double')) {</span>
        <span class="s1">throw new TypeError('option &quot;quoteStyle&quot; must be &quot;single&quot; or &quot;double&quot;');</span>
    <span class="s1">}</span>
    <span class="s1">if (</span>
        <span class="s1">has(opts, 'maxStringLength') &amp;&amp; (typeof opts.maxStringLength === 'number'</span>
            <span class="s1">? opts.maxStringLength &lt; 0 &amp;&amp; opts.maxStringLength !== Infinity</span>
            <span class="s1">: opts.maxStringLength !== null</span>
        <span class="s1">)</span>
    <span class="s1">) {</span>
        <span class="s1">throw new TypeError('option &quot;maxStringLength&quot;, if provided, must be a positive integer, Infinity, or `null`');</span>
    <span class="s1">}</span>
    <span class="s1">var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;</span>
    <span class="s1">if (typeof customInspect !== 'boolean' &amp;&amp; customInspect !== 'symbol') {</span>
        <span class="s1">throw new TypeError('option &quot;customInspect&quot;, if provided, must be `true`, `false`, or `\'symbol\'`');</span>
    <span class="s1">}</span>

    <span class="s1">if (</span>
        <span class="s1">has(opts, 'indent')</span>
        <span class="s1">&amp;&amp; opts.indent !== null</span>
        <span class="s1">&amp;&amp; opts.indent !== '\t'</span>
        <span class="s1">&amp;&amp; !(parseInt(opts.indent, 10) === opts.indent &amp;&amp; opts.indent &gt; 0)</span>
    <span class="s1">) {</span>
        <span class="s1">throw new TypeError('option &quot;indent&quot; must be &quot;\\t&quot;, an integer &gt; 0, or `null`');</span>
    <span class="s1">}</span>
    <span class="s1">if (has(opts, 'numericSeparator') &amp;&amp; typeof opts.numericSeparator !== 'boolean') {</span>
        <span class="s1">throw new TypeError('option &quot;numericSeparator&quot;, if provided, must be `true` or `false`');</span>
    <span class="s1">}</span>
    <span class="s1">var numericSeparator = opts.numericSeparator;</span>

    <span class="s1">if (typeof obj === 'undefined') {</span>
        <span class="s1">return 'undefined';</span>
    <span class="s1">}</span>
    <span class="s1">if (obj === null) {</span>
        <span class="s1">return 'null';</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'boolean') {</span>
        <span class="s1">return obj ? 'true' : 'false';</span>
    <span class="s1">}</span>

    <span class="s1">if (typeof obj === 'string') {</span>
        <span class="s1">return inspectString(obj, opts);</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'number') {</span>
        <span class="s1">if (obj === 0) {</span>
            <span class="s1">return Infinity / obj &gt; 0 ? '0' : '-0';</span>
        <span class="s1">}</span>
        <span class="s1">var str = String(obj);</span>
        <span class="s1">return numericSeparator ? addNumericSeparator(obj, str) : str;</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'bigint') {</span>
        <span class="s1">var bigIntStr = String(obj) + 'n';</span>
        <span class="s1">return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;</span>
    <span class="s1">}</span>

    <span class="s1">var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;</span>
    <span class="s1">if (typeof depth === 'undefined') { depth = 0; }</span>
    <span class="s1">if (depth &gt;= maxDepth &amp;&amp; maxDepth &gt; 0 &amp;&amp; typeof obj === 'object') {</span>
        <span class="s1">return isArray(obj) ? '[Array]' : '[Object]';</span>
    <span class="s1">}</span>

    <span class="s1">var indent = getIndent(opts, depth);</span>

    <span class="s1">if (typeof seen === 'undefined') {</span>
        <span class="s1">seen = [];</span>
    <span class="s1">} else if (indexOf(seen, obj) &gt;= 0) {</span>
        <span class="s1">return '[Circular]';</span>
    <span class="s1">}</span>

    <span class="s1">function inspect(value, from, noIndent) {</span>
        <span class="s1">if (from) {</span>
            <span class="s1">seen = $arrSlice.call(seen);</span>
            <span class="s1">seen.push(from);</span>
        <span class="s1">}</span>
        <span class="s1">if (noIndent) {</span>
            <span class="s1">var newOpts = {</span>
                <span class="s1">depth: opts.depth</span>
            <span class="s1">};</span>
            <span class="s1">if (has(opts, 'quoteStyle')) {</span>
                <span class="s1">newOpts.quoteStyle = opts.quoteStyle;</span>
            <span class="s1">}</span>
            <span class="s1">return inspect_(value, newOpts, depth + 1, seen);</span>
        <span class="s1">}</span>
        <span class="s1">return inspect_(value, opts, depth + 1, seen);</span>
    <span class="s1">}</span>

    <span class="s1">if (typeof obj === 'function') {</span>
        <span class="s1">var name = nameOf(obj);</span>
        <span class="s1">var keys = arrObjKeys(obj, inspect);</span>
        <span class="s1">return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length &gt; 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');</span>
    <span class="s1">}</span>
    <span class="s1">if (isSymbol(obj)) {</span>
        <span class="s1">var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);</span>
        <span class="s1">return typeof obj === 'object' &amp;&amp; !hasShammedSymbols ? markBoxed(symString) : symString;</span>
    <span class="s1">}</span>
    <span class="s1">if (isElement(obj)) {</span>
        <span class="s1">var s = '&lt;' + $toLowerCase.call(String(obj.nodeName));</span>
        <span class="s1">var attrs = obj.attributes || [];</span>
        <span class="s1">for (var i = 0; i &lt; attrs.length; i++) {</span>
            <span class="s1">s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);</span>
        <span class="s1">}</span>
        <span class="s1">s += '&gt;';</span>
        <span class="s1">if (obj.childNodes &amp;&amp; obj.childNodes.length) { s += '...'; }</span>
        <span class="s1">s += '&lt;/' + $toLowerCase.call(String(obj.nodeName)) + '&gt;';</span>
        <span class="s1">return s;</span>
    <span class="s1">}</span>
    <span class="s1">if (isArray(obj)) {</span>
        <span class="s1">if (obj.length === 0) { return '[]'; }</span>
        <span class="s1">var xs = arrObjKeys(obj, inspect);</span>
        <span class="s1">if (indent &amp;&amp; !singleLineValues(xs)) {</span>
            <span class="s1">return '[' + indentedJoin(xs, indent) + ']';</span>
        <span class="s1">}</span>
        <span class="s1">return '[ ' + $join.call(xs, ', ') + ' ]';</span>
    <span class="s1">}</span>
    <span class="s1">if (isError(obj)) {</span>
        <span class="s1">var parts = arrObjKeys(obj, inspect);</span>
        <span class="s1">if ('cause' in obj &amp;&amp; !isEnumerable.call(obj, 'cause')) {</span>
            <span class="s1">return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';</span>
        <span class="s1">}</span>
        <span class="s1">if (parts.length === 0) { return '[' + String(obj) + ']'; }</span>
        <span class="s1">return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'object' &amp;&amp; customInspect) {</span>
        <span class="s1">if (inspectSymbol &amp;&amp; typeof obj[inspectSymbol] === 'function') {</span>
            <span class="s1">return obj[inspectSymbol]();</span>
        <span class="s1">} else if (customInspect !== 'symbol' &amp;&amp; typeof obj.inspect === 'function') {</span>
            <span class="s1">return obj.inspect();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">if (isMap(obj)) {</span>
        <span class="s1">var mapParts = [];</span>
        <span class="s1">mapForEach.call(obj, function (value, key) {</span>
            <span class="s1">mapParts.push(inspect(key, obj, true) + ' =&gt; ' + inspect(value, obj));</span>
        <span class="s1">});</span>
        <span class="s1">return collectionOf('Map', mapSize.call(obj), mapParts, indent);</span>
    <span class="s1">}</span>
    <span class="s1">if (isSet(obj)) {</span>
        <span class="s1">var setParts = [];</span>
        <span class="s1">setForEach.call(obj, function (value) {</span>
            <span class="s1">setParts.push(inspect(value, obj));</span>
        <span class="s1">});</span>
        <span class="s1">return collectionOf('Set', setSize.call(obj), setParts, indent);</span>
    <span class="s1">}</span>
    <span class="s1">if (isWeakMap(obj)) {</span>
        <span class="s1">return weakCollectionOf('WeakMap');</span>
    <span class="s1">}</span>
    <span class="s1">if (isWeakSet(obj)) {</span>
        <span class="s1">return weakCollectionOf('WeakSet');</span>
    <span class="s1">}</span>
    <span class="s1">if (isWeakRef(obj)) {</span>
        <span class="s1">return weakCollectionOf('WeakRef');</span>
    <span class="s1">}</span>
    <span class="s1">if (isNumber(obj)) {</span>
        <span class="s1">return markBoxed(inspect(Number(obj)));</span>
    <span class="s1">}</span>
    <span class="s1">if (isBigInt(obj)) {</span>
        <span class="s1">return markBoxed(inspect(bigIntValueOf.call(obj)));</span>
    <span class="s1">}</span>
    <span class="s1">if (isBoolean(obj)) {</span>
        <span class="s1">return markBoxed(booleanValueOf.call(obj));</span>
    <span class="s1">}</span>
    <span class="s1">if (isString(obj)) {</span>
        <span class="s1">return markBoxed(inspect(String(obj)));</span>
    <span class="s1">}</span>
    <span class="s1">if (!isDate(obj) &amp;&amp; !isRegExp(obj)) {</span>
        <span class="s1">var ys = arrObjKeys(obj, inspect);</span>
        <span class="s1">var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;</span>
        <span class="s1">var protoTag = obj instanceof Object ? '' : 'null prototype';</span>
        <span class="s1">var stringTag = !isPlainObject &amp;&amp; toStringTag &amp;&amp; Object(obj) === obj &amp;&amp; toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';</span>
        <span class="s1">var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';</span>
        <span class="s1">var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');</span>
        <span class="s1">if (ys.length === 0) { return tag + '{}'; }</span>
        <span class="s1">if (indent) {</span>
            <span class="s1">return tag + '{' + indentedJoin(ys, indent) + '}';</span>
        <span class="s1">}</span>
        <span class="s1">return tag + '{ ' + $join.call(ys, ', ') + ' }';</span>
    <span class="s1">}</span>
    <span class="s1">return String(obj);</span>
<span class="s1">};</span>

<span class="s1">function wrapQuotes(s, defaultStyle, opts) {</span>
    <span class="s1">var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '&quot;' : &quot;'&quot;;</span>
    <span class="s1">return quoteChar + s + quoteChar;</span>
<span class="s1">}</span>

<span class="s1">function quote(s) {</span>
    <span class="s1">return $replace.call(String(s), /&quot;/g, '</span><span class="s4">&amp;quot;</span><span class="s1">');</span>
<span class="s1">}</span>

<span class="s1">function isArray(obj) { return toStr(obj) === '[object Array]' &amp;&amp; (!toStringTag || !(typeof obj === 'object' &amp;&amp; toStringTag in obj)); }</span>
<span class="s1">function isDate(obj) { return toStr(obj) === '[object Date]' &amp;&amp; (!toStringTag || !(typeof obj === 'object' &amp;&amp; toStringTag in obj)); }</span>
<span class="s1">function isRegExp(obj) { return toStr(obj) === '[object RegExp]' &amp;&amp; (!toStringTag || !(typeof obj === 'object' &amp;&amp; toStringTag in obj)); }</span>
<span class="s1">function isError(obj) { return toStr(obj) === '[object Error]' &amp;&amp; (!toStringTag || !(typeof obj === 'object' &amp;&amp; toStringTag in obj)); }</span>
<span class="s1">function isString(obj) { return toStr(obj) === '[object String]' &amp;&amp; (!toStringTag || !(typeof obj === 'object' &amp;&amp; toStringTag in obj)); }</span>
<span class="s1">function isNumber(obj) { return toStr(obj) === '[object Number]' &amp;&amp; (!toStringTag || !(typeof obj === 'object' &amp;&amp; toStringTag in obj)); }</span>
<span class="s1">function isBoolean(obj) { return toStr(obj) === '[object Boolean]' &amp;&amp; (!toStringTag || !(typeof obj === 'object' &amp;&amp; toStringTag in obj)); }</span>

<span class="s1">// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives</span>
<span class="s1">function isSymbol(obj) {</span>
    <span class="s1">if (hasShammedSymbols) {</span>
        <span class="s1">return obj &amp;&amp; typeof obj === 'object' &amp;&amp; obj instanceof Symbol;</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof obj === 'symbol') {</span>
        <span class="s1">return true;</span>
    <span class="s1">}</span>
    <span class="s1">if (!obj || typeof obj !== 'object' || !symToString) {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">symToString.call(obj);</span>
        <span class="s1">return true;</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isBigInt(obj) {</span>
    <span class="s1">if (!obj || typeof obj !== 'object' || !bigIntValueOf) {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">bigIntValueOf.call(obj);</span>
        <span class="s1">return true;</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };</span>
<span class="s1">function has(obj, key) {</span>
    <span class="s1">return hasOwn.call(obj, key);</span>
<span class="s1">}</span>

<span class="s1">function toStr(obj) {</span>
    <span class="s1">return objectToString.call(obj);</span>
<span class="s1">}</span>

<span class="s1">function nameOf(f) {</span>
    <span class="s1">if (f.name) { return f.name; }</span>
    <span class="s1">var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);</span>
    <span class="s1">if (m) { return m[1]; }</span>
    <span class="s1">return null;</span>
<span class="s1">}</span>

<span class="s1">function indexOf(xs, x) {</span>
    <span class="s1">if (xs.indexOf) { return xs.indexOf(x); }</span>
    <span class="s1">for (var i = 0, l = xs.length; i &lt; l; i++) {</span>
        <span class="s1">if (xs[i] === x) { return i; }</span>
    <span class="s1">}</span>
    <span class="s1">return -1;</span>
<span class="s1">}</span>

<span class="s1">function isMap(x) {</span>
    <span class="s1">if (!mapSize || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">mapSize.call(x);</span>
        <span class="s1">try {</span>
            <span class="s1">setSize.call(x);</span>
        <span class="s1">} catch (s) {</span>
            <span class="s1">return true;</span>
        <span class="s1">}</span>
        <span class="s1">return x instanceof Map; // core-js workaround, pre-v2.5.0</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isWeakMap(x) {</span>
    <span class="s1">if (!weakMapHas || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">weakMapHas.call(x, weakMapHas);</span>
        <span class="s1">try {</span>
            <span class="s1">weakSetHas.call(x, weakSetHas);</span>
        <span class="s1">} catch (s) {</span>
            <span class="s1">return true;</span>
        <span class="s1">}</span>
        <span class="s1">return x instanceof WeakMap; // core-js workaround, pre-v2.5.0</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isWeakRef(x) {</span>
    <span class="s1">if (!weakRefDeref || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">weakRefDeref.call(x);</span>
        <span class="s1">return true;</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isSet(x) {</span>
    <span class="s1">if (!setSize || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">setSize.call(x);</span>
        <span class="s1">try {</span>
            <span class="s1">mapSize.call(x);</span>
        <span class="s1">} catch (m) {</span>
            <span class="s1">return true;</span>
        <span class="s1">}</span>
        <span class="s1">return x instanceof Set; // core-js workaround, pre-v2.5.0</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isWeakSet(x) {</span>
    <span class="s1">if (!weakSetHas || !x || typeof x !== 'object') {</span>
        <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">weakSetHas.call(x, weakSetHas);</span>
        <span class="s1">try {</span>
            <span class="s1">weakMapHas.call(x, weakMapHas);</span>
        <span class="s1">} catch (s) {</span>
            <span class="s1">return true;</span>
        <span class="s1">}</span>
        <span class="s1">return x instanceof WeakSet; // core-js workaround, pre-v2.5.0</span>
    <span class="s1">} catch (e) {}</span>
    <span class="s1">return false;</span>
<span class="s1">}</span>

<span class="s1">function isElement(x) {</span>
    <span class="s1">if (!x || typeof x !== 'object') { return false; }</span>
    <span class="s1">if (typeof HTMLElement !== 'undefined' &amp;&amp; x instanceof HTMLElement) {</span>
        <span class="s1">return true;</span>
    <span class="s1">}</span>
    <span class="s1">return typeof x.nodeName === 'string' &amp;&amp; typeof x.getAttribute === 'function';</span>
<span class="s1">}</span>

<span class="s1">function inspectString(str, opts) {</span>
    <span class="s1">if (str.length &gt; opts.maxStringLength) {</span>
        <span class="s1">var remaining = str.length - opts.maxStringLength;</span>
        <span class="s1">var trailer = '... ' + remaining + ' more character' + (remaining &gt; 1 ? 's' : '');</span>
        <span class="s1">return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;</span>
    <span class="s1">}</span>
    <span class="s1">// eslint-disable-next-line no-control-regex</span>
    <span class="s1">var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);</span>
    <span class="s1">return wrapQuotes(s, 'single', opts);</span>
<span class="s1">}</span>

<span class="s1">function lowbyte(c) {</span>
    <span class="s1">var n = c.charCodeAt(0);</span>
    <span class="s1">var x = {</span>
        <span class="s1">8: 'b',</span>
        <span class="s1">9: 't',</span>
        <span class="s1">10: 'n',</span>
        <span class="s1">12: 'f',</span>
        <span class="s1">13: 'r'</span>
    <span class="s1">}[n];</span>
    <span class="s1">if (x) { return '\\' + x; }</span>
    <span class="s1">return '\\x' + (n &lt; 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));</span>
<span class="s1">}</span>

<span class="s1">function markBoxed(str) {</span>
    <span class="s1">return 'Object(' + str + ')';</span>
<span class="s1">}</span>

<span class="s1">function weakCollectionOf(type) {</span>
    <span class="s1">return type + ' { ? }';</span>
<span class="s1">}</span>

<span class="s1">function collectionOf(type, size, entries, indent) {</span>
    <span class="s1">var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');</span>
    <span class="s1">return type + ' (' + size + ') {' + joinedEntries + '}';</span>
<span class="s1">}</span>

<span class="s1">function singleLineValues(xs) {</span>
    <span class="s1">for (var i = 0; i &lt; xs.length; i++) {</span>
        <span class="s1">if (indexOf(xs[i], '\n') &gt;= 0) {</span>
            <span class="s1">return false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return true;</span>
<span class="s1">}</span>

<span class="s1">function getIndent(opts, depth) {</span>
    <span class="s1">var baseIndent;</span>
    <span class="s1">if (opts.indent === '\t') {</span>
        <span class="s1">baseIndent = '\t';</span>
    <span class="s1">} else if (typeof opts.indent === 'number' &amp;&amp; opts.indent &gt; 0) {</span>
        <span class="s1">baseIndent = $join.call(Array(opts.indent + 1), ' ');</span>
    <span class="s1">} else {</span>
        <span class="s1">return null;</span>
    <span class="s1">}</span>
    <span class="s1">return {</span>
        <span class="s1">base: baseIndent,</span>
        <span class="s1">prev: $join.call(Array(depth + 1), baseIndent)</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">function indentedJoin(xs, indent) {</span>
    <span class="s1">if (xs.length === 0) { return ''; }</span>
    <span class="s1">var lineJoiner = '\n' + indent.prev + indent.base;</span>
    <span class="s1">return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;</span>
<span class="s1">}</span>

<span class="s1">function arrObjKeys(obj, inspect) {</span>
    <span class="s1">var isArr = isArray(obj);</span>
    <span class="s1">var xs = [];</span>
    <span class="s1">if (isArr) {</span>
        <span class="s1">xs.length = obj.length;</span>
        <span class="s1">for (var i = 0; i &lt; obj.length; i++) {</span>
            <span class="s1">xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">var syms = typeof gOPS === 'function' ? gOPS(obj) : [];</span>
    <span class="s1">var symMap;</span>
    <span class="s1">if (hasShammedSymbols) {</span>
        <span class="s1">symMap = {};</span>
        <span class="s1">for (var k = 0; k &lt; syms.length; k++) {</span>
            <span class="s1">symMap['$' + syms[k]] = syms[k];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">for (var key in obj) { // eslint-disable-line no-restricted-syntax</span>
        <span class="s1">if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue</span>
        <span class="s1">if (isArr &amp;&amp; String(Number(key)) === key &amp;&amp; key &lt; obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue</span>
        <span class="s1">if (hasShammedSymbols &amp;&amp; symMap['$' + key] instanceof Symbol) {</span>
            <span class="s1">// this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section</span>
            <span class="s1">continue; // eslint-disable-line no-restricted-syntax, no-continue</span>
        <span class="s1">} else if ($test.call(/[^\w$]/, key)) {</span>
            <span class="s1">xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));</span>
        <span class="s1">} else {</span>
            <span class="s1">xs.push(key + ': ' + inspect(obj[key], obj));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">if (typeof gOPS === 'function') {</span>
        <span class="s1">for (var j = 0; j &lt; syms.length; j++) {</span>
            <span class="s1">if (isEnumerable.call(obj, syms[j])) {</span>
                <span class="s1">xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return xs;</span>
<span class="s1">}</span>

<span class="s1">},{&quot;./util.inspect&quot;:9}],66:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var numberIsNaN = function (value) {</span>
	<span class="s1">return value !== value;</span>
<span class="s1">};</span>

<span class="s1">module.exports = function is(a, b) {</span>
	<span class="s1">if (a === 0 &amp;&amp; b === 0) {</span>
		<span class="s1">return 1 / a === 1 / b;</span>
	<span class="s1">}</span>
	<span class="s1">if (a === b) {</span>
		<span class="s1">return true;</span>
	<span class="s1">}</span>
	<span class="s1">if (numberIsNaN(a) &amp;&amp; numberIsNaN(b)) {</span>
		<span class="s1">return true;</span>
	<span class="s1">}</span>
	<span class="s1">return false;</span>
<span class="s1">};</span>


<span class="s1">},{}],67:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var define = require('define-properties');</span>
<span class="s1">var callBind = require('call-bind');</span>

<span class="s1">var implementation = require('./implementation');</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>
<span class="s1">var shim = require('./shim');</span>

<span class="s1">var polyfill = callBind(getPolyfill(), Object);</span>

<span class="s1">define(polyfill, {</span>
	<span class="s1">getPolyfill: getPolyfill,</span>
	<span class="s1">implementation: implementation,</span>
	<span class="s1">shim: shim</span>
<span class="s1">});</span>

<span class="s1">module.exports = polyfill;</span>

<span class="s1">},{&quot;./implementation&quot;:66,&quot;./polyfill&quot;:68,&quot;./shim&quot;:69,&quot;call-bind&quot;:12,&quot;define-properties&quot;:16}],68:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var implementation = require('./implementation');</span>

<span class="s1">module.exports = function getPolyfill() {</span>
	<span class="s1">return typeof Object.is === 'function' ? Object.is : implementation;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./implementation&quot;:66}],69:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var getPolyfill = require('./polyfill');</span>
<span class="s1">var define = require('define-properties');</span>

<span class="s1">module.exports = function shimObjectIs() {</span>
	<span class="s1">var polyfill = getPolyfill();</span>
	<span class="s1">define(Object, { is: polyfill }, {</span>
		<span class="s1">is: function testObjectIs() {</span>
			<span class="s1">return Object.is !== polyfill;</span>
		<span class="s1">}</span>
	<span class="s1">});</span>
	<span class="s1">return polyfill;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./polyfill&quot;:68,&quot;define-properties&quot;:16}],70:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var keysShim;</span>
<span class="s1">if (!Object.keys) {</span>
	<span class="s1">// modified from https://github.com/es-shims/es5-shim</span>
	<span class="s1">var has = Object.prototype.hasOwnProperty;</span>
	<span class="s1">var toStr = Object.prototype.toString;</span>
	<span class="s1">var isArgs = require('./isArguments'); // eslint-disable-line global-require</span>
	<span class="s1">var isEnumerable = Object.prototype.propertyIsEnumerable;</span>
	<span class="s1">var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');</span>
	<span class="s1">var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');</span>
	<span class="s1">var dontEnums = [</span>
		<span class="s1">'toString',</span>
		<span class="s1">'toLocaleString',</span>
		<span class="s1">'valueOf',</span>
		<span class="s1">'hasOwnProperty',</span>
		<span class="s1">'isPrototypeOf',</span>
		<span class="s1">'propertyIsEnumerable',</span>
		<span class="s1">'constructor'</span>
	<span class="s1">];</span>
	<span class="s1">var equalsConstructorPrototype = function (o) {</span>
		<span class="s1">var ctor = o.constructor;</span>
		<span class="s1">return ctor &amp;&amp; ctor.prototype === o;</span>
	<span class="s1">};</span>
	<span class="s1">var excludedKeys = {</span>
		<span class="s1">$applicationCache: true,</span>
		<span class="s1">$console: true,</span>
		<span class="s1">$external: true,</span>
		<span class="s1">$frame: true,</span>
		<span class="s1">$frameElement: true,</span>
		<span class="s1">$frames: true,</span>
		<span class="s1">$innerHeight: true,</span>
		<span class="s1">$innerWidth: true,</span>
		<span class="s1">$onmozfullscreenchange: true,</span>
		<span class="s1">$onmozfullscreenerror: true,</span>
		<span class="s1">$outerHeight: true,</span>
		<span class="s1">$outerWidth: true,</span>
		<span class="s1">$pageXOffset: true,</span>
		<span class="s1">$pageYOffset: true,</span>
		<span class="s1">$parent: true,</span>
		<span class="s1">$scrollLeft: true,</span>
		<span class="s1">$scrollTop: true,</span>
		<span class="s1">$scrollX: true,</span>
		<span class="s1">$scrollY: true,</span>
		<span class="s1">$self: true,</span>
		<span class="s1">$webkitIndexedDB: true,</span>
		<span class="s1">$webkitStorageInfo: true,</span>
		<span class="s1">$window: true</span>
	<span class="s1">};</span>
	<span class="s1">var hasAutomationEqualityBug = (function () {</span>
		<span class="s1">/* global window */</span>
		<span class="s1">if (typeof window === 'undefined') { return false; }</span>
		<span class="s1">for (var k in window) {</span>
			<span class="s1">try {</span>
				<span class="s1">if (!excludedKeys['$' + k] &amp;&amp; has.call(window, k) &amp;&amp; window[k] !== null &amp;&amp; typeof window[k] === 'object') {</span>
					<span class="s1">try {</span>
						<span class="s1">equalsConstructorPrototype(window[k]);</span>
					<span class="s1">} catch (e) {</span>
						<span class="s1">return true;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">} catch (e) {</span>
				<span class="s1">return true;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">return false;</span>
	<span class="s1">}());</span>
	<span class="s1">var equalsConstructorPrototypeIfNotBuggy = function (o) {</span>
		<span class="s1">/* global window */</span>
		<span class="s1">if (typeof window === 'undefined' || !hasAutomationEqualityBug) {</span>
			<span class="s1">return equalsConstructorPrototype(o);</span>
		<span class="s1">}</span>
		<span class="s1">try {</span>
			<span class="s1">return equalsConstructorPrototype(o);</span>
		<span class="s1">} catch (e) {</span>
			<span class="s1">return false;</span>
		<span class="s1">}</span>
	<span class="s1">};</span>

	<span class="s1">keysShim = function keys(object) {</span>
		<span class="s1">var isObject = object !== null &amp;&amp; typeof object === 'object';</span>
		<span class="s1">var isFunction = toStr.call(object) === '[object Function]';</span>
		<span class="s1">var isArguments = isArgs(object);</span>
		<span class="s1">var isString = isObject &amp;&amp; toStr.call(object) === '[object String]';</span>
		<span class="s1">var theKeys = [];</span>

		<span class="s1">if (!isObject &amp;&amp; !isFunction &amp;&amp; !isArguments) {</span>
			<span class="s1">throw new TypeError('Object.keys called on a non-object');</span>
		<span class="s1">}</span>

		<span class="s1">var skipProto = hasProtoEnumBug &amp;&amp; isFunction;</span>
		<span class="s1">if (isString &amp;&amp; object.length &gt; 0 &amp;&amp; !has.call(object, 0)) {</span>
			<span class="s1">for (var i = 0; i &lt; object.length; ++i) {</span>
				<span class="s1">theKeys.push(String(i));</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">if (isArguments &amp;&amp; object.length &gt; 0) {</span>
			<span class="s1">for (var j = 0; j &lt; object.length; ++j) {</span>
				<span class="s1">theKeys.push(String(j));</span>
			<span class="s1">}</span>
		<span class="s1">} else {</span>
			<span class="s1">for (var name in object) {</span>
				<span class="s1">if (!(skipProto &amp;&amp; name === 'prototype') &amp;&amp; has.call(object, name)) {</span>
					<span class="s1">theKeys.push(String(name));</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">if (hasDontEnumBug) {</span>
			<span class="s1">var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);</span>

			<span class="s1">for (var k = 0; k &lt; dontEnums.length; ++k) {</span>
				<span class="s1">if (!(skipConstructor &amp;&amp; dontEnums[k] === 'constructor') &amp;&amp; has.call(object, dontEnums[k])) {</span>
					<span class="s1">theKeys.push(dontEnums[k]);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">return theKeys;</span>
	<span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">module.exports = keysShim;</span>

<span class="s1">},{&quot;./isArguments&quot;:72}],71:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var slice = Array.prototype.slice;</span>
<span class="s1">var isArgs = require('./isArguments');</span>

<span class="s1">var origKeys = Object.keys;</span>
<span class="s1">var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');</span>

<span class="s1">var originalKeys = Object.keys;</span>

<span class="s1">keysShim.shim = function shimObjectKeys() {</span>
	<span class="s1">if (Object.keys) {</span>
		<span class="s1">var keysWorksWithArguments = (function () {</span>
			<span class="s1">// Safari 5.0 bug</span>
			<span class="s1">var args = Object.keys(arguments);</span>
			<span class="s1">return args &amp;&amp; args.length === arguments.length;</span>
		<span class="s1">}(1, 2));</span>
		<span class="s1">if (!keysWorksWithArguments) {</span>
			<span class="s1">Object.keys = function keys(object) { // eslint-disable-line func-name-matching</span>
				<span class="s1">if (isArgs(object)) {</span>
					<span class="s1">return originalKeys(slice.call(object));</span>
				<span class="s1">}</span>
				<span class="s1">return originalKeys(object);</span>
			<span class="s1">};</span>
		<span class="s1">}</span>
	<span class="s1">} else {</span>
		<span class="s1">Object.keys = keysShim;</span>
	<span class="s1">}</span>
	<span class="s1">return Object.keys || keysShim;</span>
<span class="s1">};</span>

<span class="s1">module.exports = keysShim;</span>

<span class="s1">},{&quot;./implementation&quot;:70,&quot;./isArguments&quot;:72}],72:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var toStr = Object.prototype.toString;</span>

<span class="s1">module.exports = function isArguments(value) {</span>
	<span class="s1">var str = toStr.call(value);</span>
	<span class="s1">var isArgs = str === '[object Arguments]';</span>
	<span class="s1">if (!isArgs) {</span>
		<span class="s1">isArgs = str !== '[object Array]' &amp;&amp;</span>
			<span class="s1">value !== null &amp;&amp;</span>
			<span class="s1">typeof value === 'object' &amp;&amp;</span>
			<span class="s1">typeof value.length === 'number' &amp;&amp;</span>
			<span class="s1">value.length &gt;= 0 &amp;&amp;</span>
			<span class="s1">toStr.call(value.callee) === '[object Function]';</span>
	<span class="s1">}</span>
	<span class="s1">return isArgs;</span>
<span class="s1">};</span>

<span class="s1">},{}],73:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">// modified from https://github.com/es-shims/es6-shim</span>
<span class="s1">var keys = require('object-keys');</span>
<span class="s1">var canBeObject = function (obj) {</span>
	<span class="s1">return typeof obj !== 'undefined' &amp;&amp; obj !== null;</span>
<span class="s1">};</span>
<span class="s1">var hasSymbols = require('has-symbols/shams')();</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var toObject = Object;</span>
<span class="s1">var $push = callBound('Array.prototype.push');</span>
<span class="s1">var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');</span>
<span class="s1">var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;</span>

<span class="s1">// eslint-disable-next-line no-unused-vars</span>
<span class="s1">module.exports = function assign(target, source1) {</span>
	<span class="s1">if (!canBeObject(target)) { throw new TypeError('target must be an object'); }</span>
	<span class="s1">var objTarget = toObject(target);</span>
	<span class="s1">var s, source, i, props, syms, value, key;</span>
	<span class="s1">for (s = 1; s &lt; arguments.length; ++s) {</span>
		<span class="s1">source = toObject(arguments[s]);</span>
		<span class="s1">props = keys(source);</span>
		<span class="s1">var getSymbols = hasSymbols &amp;&amp; (Object.getOwnPropertySymbols || originalGetSymbols);</span>
		<span class="s1">if (getSymbols) {</span>
			<span class="s1">syms = getSymbols(source);</span>
			<span class="s1">for (i = 0; i &lt; syms.length; ++i) {</span>
				<span class="s1">key = syms[i];</span>
				<span class="s1">if ($propIsEnumerable(source, key)) {</span>
					<span class="s1">$push(props, key);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">for (i = 0; i &lt; props.length; ++i) {</span>
			<span class="s1">key = props[i];</span>
			<span class="s1">value = source[key];</span>
			<span class="s1">if ($propIsEnumerable(source, key)) {</span>
				<span class="s1">objTarget[key] = value;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return objTarget;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;has-symbols/shams&quot;:43,&quot;object-keys&quot;:71}],74:[function(require,module,exports){</span>
<span class="s1">arguments[4][2][0].apply(exports,arguments)</span>
<span class="s1">},{&quot;./implementation&quot;:73,&quot;./polyfill&quot;:75,&quot;./shim&quot;:76,&quot;call-bind&quot;:12,&quot;define-properties&quot;:16,&quot;dup&quot;:2}],75:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var implementation = require('./implementation');</span>

<span class="s1">var lacksProperEnumerationOrder = function () {</span>
	<span class="s1">if (!Object.assign) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">/*</span>
	 <span class="s1">* v8, specifically in node 4.x, has a bug with incorrect property enumeration order</span>
	 <span class="s1">* note: this does not detect the bug unless there's 20 characters</span>
	 <span class="s1">*/</span>
	<span class="s1">var str = 'abcdefghijklmnopqrst';</span>
	<span class="s1">var letters = str.split('');</span>
	<span class="s1">var map = {};</span>
	<span class="s1">for (var i = 0; i &lt; letters.length; ++i) {</span>
		<span class="s1">map[letters[i]] = letters[i];</span>
	<span class="s1">}</span>
	<span class="s1">var obj = Object.assign({}, map);</span>
	<span class="s1">var actual = '';</span>
	<span class="s1">for (var k in obj) {</span>
		<span class="s1">actual += k;</span>
	<span class="s1">}</span>
	<span class="s1">return str !== actual;</span>
<span class="s1">};</span>

<span class="s1">var assignHasPendingExceptions = function () {</span>
	<span class="s1">if (!Object.assign || !Object.preventExtensions) {</span>
		<span class="s1">return false;</span>
	<span class="s1">}</span>
	<span class="s1">/*</span>
	 <span class="s1">* Firefox 37 still has &quot;pending exception&quot; logic in its Object.assign implementation,</span>
	 <span class="s1">* which is 72% slower than our shim, and Firefox 40's native implementation.</span>
	 <span class="s1">*/</span>
	<span class="s1">var thrower = Object.preventExtensions({ 1: 2 });</span>
	<span class="s1">try {</span>
		<span class="s1">Object.assign(thrower, 'xy');</span>
	<span class="s1">} catch (e) {</span>
		<span class="s1">return thrower[1] === 'y';</span>
	<span class="s1">}</span>
	<span class="s1">return false;</span>
<span class="s1">};</span>

<span class="s1">module.exports = function getPolyfill() {</span>
	<span class="s1">if (!Object.assign) {</span>
		<span class="s1">return implementation;</span>
	<span class="s1">}</span>
	<span class="s1">if (lacksProperEnumerationOrder()) {</span>
		<span class="s1">return implementation;</span>
	<span class="s1">}</span>
	<span class="s1">if (assignHasPendingExceptions()) {</span>
		<span class="s1">return implementation;</span>
	<span class="s1">}</span>
	<span class="s1">return Object.assign;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./implementation&quot;:73}],76:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var define = require('define-properties');</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>

<span class="s1">module.exports = function shimAssign() {</span>
	<span class="s1">var polyfill = getPolyfill();</span>
	<span class="s1">define(</span>
		<span class="s1">Object,</span>
		<span class="s1">{ assign: polyfill },</span>
		<span class="s1">{ assign: function () { return Object.assign !== polyfill; } }</span>
	<span class="s1">);</span>
	<span class="s1">return polyfill;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./polyfill&quot;:75,&quot;define-properties&quot;:16}],77:[function(require,module,exports){</span>
<span class="s1">(function (process){(function (){</span>
<span class="s1">// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,</span>
<span class="s1">// backported and transplited with Babel, with backwards-compat fixes</span>

<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// resolves . and .. elements in a path array with directory names there</span>
<span class="s1">// must be no slashes, empty elements, or device names (c:\) in the array</span>
<span class="s1">// (so also no leading and trailing slashes - it does not distinguish</span>
<span class="s1">// relative and absolute paths)</span>
<span class="s1">function normalizeArray(parts, allowAboveRoot) {</span>
  <span class="s1">// if the path tries to go above the root, `up` ends up &gt; 0</span>
  <span class="s1">var up = 0;</span>
  <span class="s1">for (var i = parts.length - 1; i &gt;= 0; i--) {</span>
    <span class="s1">var last = parts[i];</span>
    <span class="s1">if (last === '.') {</span>
      <span class="s1">parts.splice(i, 1);</span>
    <span class="s1">} else if (last === '..') {</span>
      <span class="s1">parts.splice(i, 1);</span>
      <span class="s1">up++;</span>
    <span class="s1">} else if (up) {</span>
      <span class="s1">parts.splice(i, 1);</span>
      <span class="s1">up--;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">// if the path is allowed to go above the root, restore leading ..s</span>
  <span class="s1">if (allowAboveRoot) {</span>
    <span class="s1">for (; up--; up) {</span>
      <span class="s1">parts.unshift('..');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return parts;</span>
<span class="s1">}</span>

<span class="s1">// path.resolve([from ...], to)</span>
<span class="s1">// posix version</span>
<span class="s1">exports.resolve = function() {</span>
  <span class="s1">var resolvedPath = '',</span>
      <span class="s1">resolvedAbsolute = false;</span>

  <span class="s1">for (var i = arguments.length - 1; i &gt;= -1 &amp;&amp; !resolvedAbsolute; i--) {</span>
    <span class="s1">var path = (i &gt;= 0) ? arguments[i] : process.cwd();</span>

    <span class="s1">// Skip empty and invalid entries</span>
    <span class="s1">if (typeof path !== 'string') {</span>
      <span class="s1">throw new TypeError('Arguments to path.resolve must be strings');</span>
    <span class="s1">} else if (!path) {</span>
      <span class="s1">continue;</span>
    <span class="s1">}</span>

    <span class="s1">resolvedPath = path + '/' + resolvedPath;</span>
    <span class="s1">resolvedAbsolute = path.charAt(0) === '/';</span>
  <span class="s1">}</span>

  <span class="s1">// At this point the path should be resolved to a full absolute path, but</span>
  <span class="s1">// handle relative paths to be safe (might happen when process.cwd() fails)</span>

  <span class="s1">// Normalize the path</span>
  <span class="s1">resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {</span>
    <span class="s1">return !!p;</span>
  <span class="s1">}), !resolvedAbsolute).join('/');</span>

  <span class="s1">return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';</span>
<span class="s1">};</span>

<span class="s1">// path.normalize(path)</span>
<span class="s1">// posix version</span>
<span class="s1">exports.normalize = function(path) {</span>
  <span class="s1">var isAbsolute = exports.isAbsolute(path),</span>
      <span class="s1">trailingSlash = substr(path, -1) === '/';</span>

  <span class="s1">// Normalize the path</span>
  <span class="s1">path = normalizeArray(filter(path.split('/'), function(p) {</span>
    <span class="s1">return !!p;</span>
  <span class="s1">}), !isAbsolute).join('/');</span>

  <span class="s1">if (!path &amp;&amp; !isAbsolute) {</span>
    <span class="s1">path = '.';</span>
  <span class="s1">}</span>
  <span class="s1">if (path &amp;&amp; trailingSlash) {</span>
    <span class="s1">path += '/';</span>
  <span class="s1">}</span>

  <span class="s1">return (isAbsolute ? '/' : '') + path;</span>
<span class="s1">};</span>

<span class="s1">// posix version</span>
<span class="s1">exports.isAbsolute = function(path) {</span>
  <span class="s1">return path.charAt(0) === '/';</span>
<span class="s1">};</span>

<span class="s1">// posix version</span>
<span class="s1">exports.join = function() {</span>
  <span class="s1">var paths = Array.prototype.slice.call(arguments, 0);</span>
  <span class="s1">return exports.normalize(filter(paths, function(p, index) {</span>
    <span class="s1">if (typeof p !== 'string') {</span>
      <span class="s1">throw new TypeError('Arguments to path.join must be strings');</span>
    <span class="s1">}</span>
    <span class="s1">return p;</span>
  <span class="s1">}).join('/'));</span>
<span class="s1">};</span>


<span class="s1">// path.relative(from, to)</span>
<span class="s1">// posix version</span>
<span class="s1">exports.relative = function(from, to) {</span>
  <span class="s1">from = exports.resolve(from).substr(1);</span>
  <span class="s1">to = exports.resolve(to).substr(1);</span>

  <span class="s1">function trim(arr) {</span>
    <span class="s1">var start = 0;</span>
    <span class="s1">for (; start &lt; arr.length; start++) {</span>
      <span class="s1">if (arr[start] !== '') break;</span>
    <span class="s1">}</span>

    <span class="s1">var end = arr.length - 1;</span>
    <span class="s1">for (; end &gt;= 0; end--) {</span>
      <span class="s1">if (arr[end] !== '') break;</span>
    <span class="s1">}</span>

    <span class="s1">if (start &gt; end) return [];</span>
    <span class="s1">return arr.slice(start, end - start + 1);</span>
  <span class="s1">}</span>

  <span class="s1">var fromParts = trim(from.split('/'));</span>
  <span class="s1">var toParts = trim(to.split('/'));</span>

  <span class="s1">var length = Math.min(fromParts.length, toParts.length);</span>
  <span class="s1">var samePartsLength = length;</span>
  <span class="s1">for (var i = 0; i &lt; length; i++) {</span>
    <span class="s1">if (fromParts[i] !== toParts[i]) {</span>
      <span class="s1">samePartsLength = i;</span>
      <span class="s1">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">var outputParts = [];</span>
  <span class="s1">for (var i = samePartsLength; i &lt; fromParts.length; i++) {</span>
    <span class="s1">outputParts.push('..');</span>
  <span class="s1">}</span>

  <span class="s1">outputParts = outputParts.concat(toParts.slice(samePartsLength));</span>

  <span class="s1">return outputParts.join('/');</span>
<span class="s1">};</span>

<span class="s1">exports.sep = '/';</span>
<span class="s1">exports.delimiter = ':';</span>

<span class="s1">exports.dirname = function (path) {</span>
  <span class="s1">if (typeof path !== 'string') path = path + '';</span>
  <span class="s1">if (path.length === 0) return '.';</span>
  <span class="s1">var code = path.charCodeAt(0);</span>
  <span class="s1">var hasRoot = code === 47 /*/*/;</span>
  <span class="s1">var end = -1;</span>
  <span class="s1">var matchedSlash = true;</span>
  <span class="s1">for (var i = path.length - 1; i &gt;= 1; --i) {</span>
    <span class="s1">code = path.charCodeAt(i);</span>
    <span class="s1">if (code === 47 /*/*/) {</span>
        <span class="s1">if (!matchedSlash) {</span>
          <span class="s1">end = i;</span>
          <span class="s1">break;</span>
        <span class="s1">}</span>
      <span class="s1">} else {</span>
      <span class="s1">// We saw the first non-path separator</span>
      <span class="s1">matchedSlash = false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (end === -1) return hasRoot ? '/' : '.';</span>
  <span class="s1">if (hasRoot &amp;&amp; end === 1) {</span>
    <span class="s1">// return '//';</span>
    <span class="s1">// Backwards-compat fix:</span>
    <span class="s1">return '/';</span>
  <span class="s1">}</span>
  <span class="s1">return path.slice(0, end);</span>
<span class="s1">};</span>

<span class="s1">function basename(path) {</span>
  <span class="s1">if (typeof path !== 'string') path = path + '';</span>

  <span class="s1">var start = 0;</span>
  <span class="s1">var end = -1;</span>
  <span class="s1">var matchedSlash = true;</span>
  <span class="s1">var i;</span>

  <span class="s1">for (i = path.length - 1; i &gt;= 0; --i) {</span>
    <span class="s1">if (path.charCodeAt(i) === 47 /*/*/) {</span>
        <span class="s1">// If we reached a path separator that was not part of a set of path</span>
        <span class="s1">// separators at the end of the string, stop now</span>
        <span class="s1">if (!matchedSlash) {</span>
          <span class="s1">start = i + 1;</span>
          <span class="s1">break;</span>
        <span class="s1">}</span>
      <span class="s1">} else if (end === -1) {</span>
      <span class="s1">// We saw the first non-path separator, mark this as the end of our</span>
      <span class="s1">// path component</span>
      <span class="s1">matchedSlash = false;</span>
      <span class="s1">end = i + 1;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (end === -1) return '';</span>
  <span class="s1">return path.slice(start, end);</span>
<span class="s1">}</span>

<span class="s1">// Uses a mixed approach for backwards-compatibility, as ext behavior changed</span>
<span class="s1">// in new Node.js versions, so only basename() above is backported here</span>
<span class="s1">exports.basename = function (path, ext) {</span>
  <span class="s1">var f = basename(path);</span>
  <span class="s1">if (ext &amp;&amp; f.substr(-1 * ext.length) === ext) {</span>
    <span class="s1">f = f.substr(0, f.length - ext.length);</span>
  <span class="s1">}</span>
  <span class="s1">return f;</span>
<span class="s1">};</span>

<span class="s1">exports.extname = function (path) {</span>
  <span class="s1">if (typeof path !== 'string') path = path + '';</span>
  <span class="s1">var startDot = -1;</span>
  <span class="s1">var startPart = 0;</span>
  <span class="s1">var end = -1;</span>
  <span class="s1">var matchedSlash = true;</span>
  <span class="s1">// Track the state of characters (if any) we see before our first dot and</span>
  <span class="s1">// after any path separator we find</span>
  <span class="s1">var preDotState = 0;</span>
  <span class="s1">for (var i = path.length - 1; i &gt;= 0; --i) {</span>
    <span class="s1">var code = path.charCodeAt(i);</span>
    <span class="s1">if (code === 47 /*/*/) {</span>
        <span class="s1">// If we reached a path separator that was not part of a set of path</span>
        <span class="s1">// separators at the end of the string, stop now</span>
        <span class="s1">if (!matchedSlash) {</span>
          <span class="s1">startPart = i + 1;</span>
          <span class="s1">break;</span>
        <span class="s1">}</span>
        <span class="s1">continue;</span>
      <span class="s1">}</span>
    <span class="s1">if (end === -1) {</span>
      <span class="s1">// We saw the first non-path separator, mark this as the end of our</span>
      <span class="s1">// extension</span>
      <span class="s1">matchedSlash = false;</span>
      <span class="s1">end = i + 1;</span>
    <span class="s1">}</span>
    <span class="s1">if (code === 46 /*.*/) {</span>
        <span class="s1">// If this is our first dot, mark it as the start of our extension</span>
        <span class="s1">if (startDot === -1)</span>
          <span class="s1">startDot = i;</span>
        <span class="s1">else if (preDotState !== 1)</span>
          <span class="s1">preDotState = 1;</span>
    <span class="s1">} else if (startDot !== -1) {</span>
      <span class="s1">// We saw a non-dot and non-path separator before our dot, so we should</span>
      <span class="s1">// have a good chance at having a non-empty extension</span>
      <span class="s1">preDotState = -1;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">if (startDot === -1 || end === -1 ||</span>
      <span class="s1">// We saw a non-dot character immediately before the dot</span>
      <span class="s1">preDotState === 0 ||</span>
      <span class="s1">// The (right-most) trimmed path component is exactly '..'</span>
      <span class="s1">preDotState === 1 &amp;&amp; startDot === end - 1 &amp;&amp; startDot === startPart + 1) {</span>
    <span class="s1">return '';</span>
  <span class="s1">}</span>
  <span class="s1">return path.slice(startDot, end);</span>
<span class="s1">};</span>

<span class="s1">function filter (xs, f) {</span>
    <span class="s1">if (xs.filter) return xs.filter(f);</span>
    <span class="s1">var res = [];</span>
    <span class="s1">for (var i = 0; i &lt; xs.length; i++) {</span>
        <span class="s1">if (f(xs[i], i, xs)) res.push(xs[i]);</span>
    <span class="s1">}</span>
    <span class="s1">return res;</span>
<span class="s1">}</span>

<span class="s1">// String.prototype.substr - negative index don't work in IE8</span>
<span class="s1">var substr = 'ab'.substr(-1) === 'b'</span>
    <span class="s1">? function (str, start, len) { return str.substr(start, len) }</span>
    <span class="s1">: function (str, start, len) {</span>
        <span class="s1">if (start &lt; 0) start = str.length + start;</span>
        <span class="s1">return str.substr(start, len);</span>
    <span class="s1">}</span>
<span class="s1">;</span>

<span class="s1">}).call(this)}).call(this,require('_process'))</span>

<span class="s1">},{&quot;_process&quot;:79}],78:[function(require,module,exports){</span>
<span class="s1">(function (process){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">if (typeof process === 'undefined' ||</span>
    <span class="s1">!process.version ||</span>
    <span class="s1">process.version.indexOf('v0.') === 0 ||</span>
    <span class="s1">process.version.indexOf('v1.') === 0 &amp;&amp; process.version.indexOf('v1.8.') !== 0) {</span>
  <span class="s1">module.exports = { nextTick: nextTick };</span>
<span class="s1">} else {</span>
  <span class="s1">module.exports = process</span>
<span class="s1">}</span>

<span class="s1">function nextTick(fn, arg1, arg2, arg3) {</span>
  <span class="s1">if (typeof fn !== 'function') {</span>
    <span class="s1">throw new TypeError('&quot;callback&quot; argument must be a function');</span>
  <span class="s1">}</span>
  <span class="s1">var len = arguments.length;</span>
  <span class="s1">var args, i;</span>
  <span class="s1">switch (len) {</span>
  <span class="s1">case 0:</span>
  <span class="s1">case 1:</span>
    <span class="s1">return process.nextTick(fn);</span>
  <span class="s1">case 2:</span>
    <span class="s1">return process.nextTick(function afterTickOne() {</span>
      <span class="s1">fn.call(null, arg1);</span>
    <span class="s1">});</span>
  <span class="s1">case 3:</span>
    <span class="s1">return process.nextTick(function afterTickTwo() {</span>
      <span class="s1">fn.call(null, arg1, arg2);</span>
    <span class="s1">});</span>
  <span class="s1">case 4:</span>
    <span class="s1">return process.nextTick(function afterTickThree() {</span>
      <span class="s1">fn.call(null, arg1, arg2, arg3);</span>
    <span class="s1">});</span>
  <span class="s1">default:</span>
    <span class="s1">args = new Array(len - 1);</span>
    <span class="s1">i = 0;</span>
    <span class="s1">while (i &lt; args.length) {</span>
      <span class="s1">args[i++] = arguments[i];</span>
    <span class="s1">}</span>
    <span class="s1">return process.nextTick(function afterTick() {</span>
      <span class="s1">fn.apply(null, args);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s1">}).call(this)}).call(this,require('_process'))</span>

<span class="s1">},{&quot;_process&quot;:79}],79:[function(require,module,exports){</span>
<span class="s1">// shim for using process in browser</span>
<span class="s1">var process = module.exports = {};</span>

<span class="s1">// cached from whatever global is present so that test runners that stub it</span>
<span class="s1">// don't break things.  But we need to wrap it in a try catch in case it is</span>
<span class="s1">// wrapped in strict mode code which doesn't define any globals.  It's inside a</span>
<span class="s1">// function because try/catches deoptimize in certain engines.</span>

<span class="s1">var cachedSetTimeout;</span>
<span class="s1">var cachedClearTimeout;</span>

<span class="s1">function defaultSetTimout() {</span>
    <span class="s1">throw new Error('setTimeout has not been defined');</span>
<span class="s1">}</span>
<span class="s1">function defaultClearTimeout () {</span>
    <span class="s1">throw new Error('clearTimeout has not been defined');</span>
<span class="s1">}</span>
<span class="s1">(function () {</span>
    <span class="s1">try {</span>
        <span class="s1">if (typeof setTimeout === 'function') {</span>
            <span class="s1">cachedSetTimeout = setTimeout;</span>
        <span class="s1">} else {</span>
            <span class="s1">cachedSetTimeout = defaultSetTimout;</span>
        <span class="s1">}</span>
    <span class="s1">} catch (e) {</span>
        <span class="s1">cachedSetTimeout = defaultSetTimout;</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">if (typeof clearTimeout === 'function') {</span>
            <span class="s1">cachedClearTimeout = clearTimeout;</span>
        <span class="s1">} else {</span>
            <span class="s1">cachedClearTimeout = defaultClearTimeout;</span>
        <span class="s1">}</span>
    <span class="s1">} catch (e) {</span>
        <span class="s1">cachedClearTimeout = defaultClearTimeout;</span>
    <span class="s1">}</span>
<span class="s1">} ())</span>
<span class="s1">function runTimeout(fun) {</span>
    <span class="s1">if (cachedSetTimeout === setTimeout) {</span>
        <span class="s1">//normal enviroments in sane situations</span>
        <span class="s1">return setTimeout(fun, 0);</span>
    <span class="s1">}</span>
    <span class="s1">// if setTimeout wasn't available but was latter defined</span>
    <span class="s1">if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {</span>
        <span class="s1">cachedSetTimeout = setTimeout;</span>
        <span class="s1">return setTimeout(fun, 0);</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span>
        <span class="s1">return cachedSetTimeout(fun, 0);</span>
    <span class="s1">} catch(e){</span>
        <span class="s1">try {</span>
            <span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally</span>
            <span class="s1">return cachedSetTimeout.call(null, fun, 0);</span>
        <span class="s1">} catch(e){</span>
            <span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error</span>
            <span class="s1">return cachedSetTimeout.call(this, fun, 0);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>


<span class="s1">}</span>
<span class="s1">function runClearTimeout(marker) {</span>
    <span class="s1">if (cachedClearTimeout === clearTimeout) {</span>
        <span class="s1">//normal enviroments in sane situations</span>
        <span class="s1">return clearTimeout(marker);</span>
    <span class="s1">}</span>
    <span class="s1">// if clearTimeout wasn't available but was latter defined</span>
    <span class="s1">if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {</span>
        <span class="s1">cachedClearTimeout = clearTimeout;</span>
        <span class="s1">return clearTimeout(marker);</span>
    <span class="s1">}</span>
    <span class="s1">try {</span>
        <span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span>
        <span class="s1">return cachedClearTimeout(marker);</span>
    <span class="s1">} catch (e){</span>
        <span class="s1">try {</span>
            <span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally</span>
            <span class="s1">return cachedClearTimeout.call(null, marker);</span>
        <span class="s1">} catch (e){</span>
            <span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.</span>
            <span class="s1">// Some versions of I.E. have different rules for clearTimeout vs setTimeout</span>
            <span class="s1">return cachedClearTimeout.call(this, marker);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>



<span class="s1">}</span>
<span class="s1">var queue = [];</span>
<span class="s1">var draining = false;</span>
<span class="s1">var currentQueue;</span>
<span class="s1">var queueIndex = -1;</span>

<span class="s1">function cleanUpNextTick() {</span>
    <span class="s1">if (!draining || !currentQueue) {</span>
        <span class="s1">return;</span>
    <span class="s1">}</span>
    <span class="s1">draining = false;</span>
    <span class="s1">if (currentQueue.length) {</span>
        <span class="s1">queue = currentQueue.concat(queue);</span>
    <span class="s1">} else {</span>
        <span class="s1">queueIndex = -1;</span>
    <span class="s1">}</span>
    <span class="s1">if (queue.length) {</span>
        <span class="s1">drainQueue();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function drainQueue() {</span>
    <span class="s1">if (draining) {</span>
        <span class="s1">return;</span>
    <span class="s1">}</span>
    <span class="s1">var timeout = runTimeout(cleanUpNextTick);</span>
    <span class="s1">draining = true;</span>

    <span class="s1">var len = queue.length;</span>
    <span class="s1">while(len) {</span>
        <span class="s1">currentQueue = queue;</span>
        <span class="s1">queue = [];</span>
        <span class="s1">while (++queueIndex &lt; len) {</span>
            <span class="s1">if (currentQueue) {</span>
                <span class="s1">currentQueue[queueIndex].run();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">queueIndex = -1;</span>
        <span class="s1">len = queue.length;</span>
    <span class="s1">}</span>
    <span class="s1">currentQueue = null;</span>
    <span class="s1">draining = false;</span>
    <span class="s1">runClearTimeout(timeout);</span>
<span class="s1">}</span>

<span class="s1">process.nextTick = function (fun) {</span>
    <span class="s1">var args = new Array(arguments.length - 1);</span>
    <span class="s1">if (arguments.length &gt; 1) {</span>
        <span class="s1">for (var i = 1; i &lt; arguments.length; i++) {</span>
            <span class="s1">args[i - 1] = arguments[i];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">queue.push(new Item(fun, args));</span>
    <span class="s1">if (queue.length === 1 &amp;&amp; !draining) {</span>
        <span class="s1">runTimeout(drainQueue);</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">// v8 likes predictible objects</span>
<span class="s1">function Item(fun, array) {</span>
    <span class="s1">this.fun = fun;</span>
    <span class="s1">this.array = array;</span>
<span class="s1">}</span>
<span class="s1">Item.prototype.run = function () {</span>
    <span class="s1">this.fun.apply(null, this.array);</span>
<span class="s1">};</span>
<span class="s1">process.title = 'browser';</span>
<span class="s1">process.browser = true;</span>
<span class="s1">process.env = {};</span>
<span class="s1">process.argv = [];</span>
<span class="s1">process.version = ''; // empty string to avoid regexp issues</span>
<span class="s1">process.versions = {};</span>

<span class="s1">function noop() {}</span>

<span class="s1">process.on = noop;</span>
<span class="s1">process.addListener = noop;</span>
<span class="s1">process.once = noop;</span>
<span class="s1">process.off = noop;</span>
<span class="s1">process.removeListener = noop;</span>
<span class="s1">process.removeAllListeners = noop;</span>
<span class="s1">process.emit = noop;</span>
<span class="s1">process.prependListener = noop;</span>
<span class="s1">process.prependOnceListener = noop;</span>

<span class="s1">process.listeners = function (name) { return [] }</span>

<span class="s1">process.binding = function (name) {</span>
    <span class="s1">throw new Error('process.binding is not supported');</span>
<span class="s1">};</span>

<span class="s1">process.cwd = function () { return '/' };</span>
<span class="s1">process.chdir = function (dir) {</span>
    <span class="s1">throw new Error('process.chdir is not supported');</span>
<span class="s1">};</span>
<span class="s1">process.umask = function() { return 0; };</span>

<span class="s1">},{}],80:[function(require,module,exports){</span>
<span class="s1">module.exports = require('./lib/_stream_duplex.js');</span>

<span class="s1">},{&quot;./lib/_stream_duplex.js&quot;:81}],81:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// a duplex stream is just a stream that is both readable and writable.</span>
<span class="s1">// Since JS doesn't have multiple prototypal inheritance, this class</span>
<span class="s1">// prototypally inherits from Readable, and then parasitically from</span>
<span class="s1">// Writable.</span>

<span class="s1">'use strict';</span>

<span class="s1">/*&lt;replacement&gt;*/</span>

<span class="s1">var pna = require('process-nextick-args');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var objectKeys = Object.keys || function (obj) {</span>
  <span class="s1">var keys = [];</span>
  <span class="s1">for (var key in obj) {</span>
    <span class="s1">keys.push(key);</span>
  <span class="s1">}return keys;</span>
<span class="s1">};</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">module.exports = Duplex;</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var util = Object.create(require('core-util-is'));</span>
<span class="s1">util.inherits = require('inherits');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">var Readable = require('./_stream_readable');</span>
<span class="s1">var Writable = require('./_stream_writable');</span>

<span class="s1">util.inherits(Duplex, Readable);</span>

<span class="s1">{</span>
  <span class="s1">// avoid scope creep, the keys array can then be collected</span>
  <span class="s1">var keys = objectKeys(Writable.prototype);</span>
  <span class="s1">for (var v = 0; v &lt; keys.length; v++) {</span>
    <span class="s1">var method = keys[v];</span>
    <span class="s1">if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function Duplex(options) {</span>
  <span class="s1">if (!(this instanceof Duplex)) return new Duplex(options);</span>

  <span class="s1">Readable.call(this, options);</span>
  <span class="s1">Writable.call(this, options);</span>

  <span class="s1">if (options &amp;&amp; options.readable === false) this.readable = false;</span>

  <span class="s1">if (options &amp;&amp; options.writable === false) this.writable = false;</span>

  <span class="s1">this.allowHalfOpen = true;</span>
  <span class="s1">if (options &amp;&amp; options.allowHalfOpen === false) this.allowHalfOpen = false;</span>

  <span class="s1">this.once('end', onend);</span>
<span class="s1">}</span>

<span class="s1">Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {</span>
  <span class="s1">// making it explicit this property is not enumerable</span>
  <span class="s1">// because otherwise some prototype manipulation in</span>
  <span class="s1">// userland will fail</span>
  <span class="s1">enumerable: false,</span>
  <span class="s1">get: function () {</span>
    <span class="s1">return this._writableState.highWaterMark;</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">// the no-half-open enforcer</span>
<span class="s1">function onend() {</span>
  <span class="s1">// if we allow half-open state, or if the writable side ended,</span>
  <span class="s1">// then we're ok.</span>
  <span class="s1">if (this.allowHalfOpen || this._writableState.ended) return;</span>

  <span class="s1">// no more data can be written.</span>
  <span class="s1">// But allow more writes to happen in this tick.</span>
  <span class="s1">pna.nextTick(onEndNT, this);</span>
<span class="s1">}</span>

<span class="s1">function onEndNT(self) {</span>
  <span class="s1">self.end();</span>
<span class="s1">}</span>

<span class="s1">Object.defineProperty(Duplex.prototype, 'destroyed', {</span>
  <span class="s1">get: function () {</span>
    <span class="s1">if (this._readableState === undefined || this._writableState === undefined) {</span>
      <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">return this._readableState.destroyed &amp;&amp; this._writableState.destroyed;</span>
  <span class="s1">},</span>
  <span class="s1">set: function (value) {</span>
    <span class="s1">// we ignore the value if the stream</span>
    <span class="s1">// has not been initialized yet</span>
    <span class="s1">if (this._readableState === undefined || this._writableState === undefined) {</span>
      <span class="s1">return;</span>
    <span class="s1">}</span>

    <span class="s1">// backward compatibility, the user is explicitly</span>
    <span class="s1">// managing destroyed</span>
    <span class="s1">this._readableState.destroyed = value;</span>
    <span class="s1">this._writableState.destroyed = value;</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">Duplex.prototype._destroy = function (err, cb) {</span>
  <span class="s1">this.push(null);</span>
  <span class="s1">this.end();</span>

  <span class="s1">pna.nextTick(cb, err);</span>
<span class="s1">};</span>
<span class="s1">},{&quot;./_stream_readable&quot;:83,&quot;./_stream_writable&quot;:85,&quot;core-util-is&quot;:13,&quot;inherits&quot;:47,&quot;process-nextick-args&quot;:78}],82:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// a passthrough stream.</span>
<span class="s1">// basically just the most minimal sort of Transform stream.</span>
<span class="s1">// Every written chunk gets output as-is.</span>

<span class="s1">'use strict';</span>

<span class="s1">module.exports = PassThrough;</span>

<span class="s1">var Transform = require('./_stream_transform');</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var util = Object.create(require('core-util-is'));</span>
<span class="s1">util.inherits = require('inherits');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">util.inherits(PassThrough, Transform);</span>

<span class="s1">function PassThrough(options) {</span>
  <span class="s1">if (!(this instanceof PassThrough)) return new PassThrough(options);</span>

  <span class="s1">Transform.call(this, options);</span>
<span class="s1">}</span>

<span class="s1">PassThrough.prototype._transform = function (chunk, encoding, cb) {</span>
  <span class="s1">cb(null, chunk);</span>
<span class="s1">};</span>
<span class="s1">},{&quot;./_stream_transform&quot;:84,&quot;core-util-is&quot;:13,&quot;inherits&quot;:47}],83:[function(require,module,exports){</span>
<span class="s1">(function (process,global){(function (){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">'use strict';</span>

<span class="s1">/*&lt;replacement&gt;*/</span>

<span class="s1">var pna = require('process-nextick-args');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">module.exports = Readable;</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var isArray = require('isarray');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var Duplex;</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">Readable.ReadableState = ReadableState;</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var EE = require('events').EventEmitter;</span>

<span class="s1">var EElistenerCount = function (emitter, type) {</span>
  <span class="s1">return emitter.listeners(type).length;</span>
<span class="s1">};</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var Stream = require('./internal/streams/stream');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>

<span class="s1">var Buffer = require('safe-buffer').Buffer;</span>
<span class="s1">var OurUint8Array = global.Uint8Array || function () {};</span>
<span class="s1">function _uint8ArrayToBuffer(chunk) {</span>
  <span class="s1">return Buffer.from(chunk);</span>
<span class="s1">}</span>
<span class="s1">function _isUint8Array(obj) {</span>
  <span class="s1">return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;</span>
<span class="s1">}</span>

<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var util = Object.create(require('core-util-is'));</span>
<span class="s1">util.inherits = require('inherits');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var debugUtil = require('util');</span>
<span class="s1">var debug = void 0;</span>
<span class="s1">if (debugUtil &amp;&amp; debugUtil.debuglog) {</span>
  <span class="s1">debug = debugUtil.debuglog('stream');</span>
<span class="s1">} else {</span>
  <span class="s1">debug = function () {};</span>
<span class="s1">}</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">var BufferList = require('./internal/streams/BufferList');</span>
<span class="s1">var destroyImpl = require('./internal/streams/destroy');</span>
<span class="s1">var StringDecoder;</span>

<span class="s1">util.inherits(Readable, Stream);</span>

<span class="s1">var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];</span>

<span class="s1">function prependListener(emitter, event, fn) {</span>
  <span class="s1">// Sadly this is not cacheable as some libraries bundle their own</span>
  <span class="s1">// event emitter implementation with them.</span>
  <span class="s1">if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);</span>

  <span class="s1">// This is a hack to make sure that our error handler is attached before any</span>
  <span class="s1">// userland ones.  NEVER DO THIS. This is here only because this code needs</span>
  <span class="s1">// to continue to work with older versions of Node.js that do not include</span>
  <span class="s1">// the prependListener() method. The goal is to eventually remove this hack.</span>
  <span class="s1">if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];</span>
<span class="s1">}</span>

<span class="s1">function ReadableState(options, stream) {</span>
  <span class="s1">Duplex = Duplex || require('./_stream_duplex');</span>

  <span class="s1">options = options || {};</span>

  <span class="s1">// Duplex streams are both readable and writable, but share</span>
  <span class="s1">// the same options object.</span>
  <span class="s1">// However, some cases require setting options to different</span>
  <span class="s1">// values for the readable and the writable sides of the duplex stream.</span>
  <span class="s1">// These options can be provided separately as readableXXX and writableXXX.</span>
  <span class="s1">var isDuplex = stream instanceof Duplex;</span>

  <span class="s1">// object stream flag. Used to make read(n) ignore n and to</span>
  <span class="s1">// make all the buffer merging and length checks go away</span>
  <span class="s1">this.objectMode = !!options.objectMode;</span>

  <span class="s1">if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;</span>

  <span class="s1">// the point at which it stops calling _read() to fill the buffer</span>
  <span class="s1">// Note: 0 is a valid value, means &quot;don't call _read preemptively ever&quot;</span>
  <span class="s1">var hwm = options.highWaterMark;</span>
  <span class="s1">var readableHwm = options.readableHighWaterMark;</span>
  <span class="s1">var defaultHwm = this.objectMode ? 16 : 16 * 1024;</span>

  <span class="s1">if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex &amp;&amp; (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;</span>

  <span class="s1">// cast to ints.</span>
  <span class="s1">this.highWaterMark = Math.floor(this.highWaterMark);</span>

  <span class="s1">// A linked list is used to store data chunks instead of an array because the</span>
  <span class="s1">// linked list can remove elements from the beginning faster than</span>
  <span class="s1">// array.shift()</span>
  <span class="s1">this.buffer = new BufferList();</span>
  <span class="s1">this.length = 0;</span>
  <span class="s1">this.pipes = null;</span>
  <span class="s1">this.pipesCount = 0;</span>
  <span class="s1">this.flowing = null;</span>
  <span class="s1">this.ended = false;</span>
  <span class="s1">this.endEmitted = false;</span>
  <span class="s1">this.reading = false;</span>

  <span class="s1">// a flag to be able to tell if the event 'readable'/'data' is emitted</span>
  <span class="s1">// immediately, or on a later tick.  We set this to true at first, because</span>
  <span class="s1">// any actions that shouldn't happen until &quot;later&quot; should generally also</span>
  <span class="s1">// not happen before the first read call.</span>
  <span class="s1">this.sync = true;</span>

  <span class="s1">// whenever we return null, then we set a flag to say</span>
  <span class="s1">// that we're awaiting a 'readable' event emission.</span>
  <span class="s1">this.needReadable = false;</span>
  <span class="s1">this.emittedReadable = false;</span>
  <span class="s1">this.readableListening = false;</span>
  <span class="s1">this.resumeScheduled = false;</span>

  <span class="s1">// has it been destroyed</span>
  <span class="s1">this.destroyed = false;</span>

  <span class="s1">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="s1">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="s1">// Everything else in the universe uses 'utf8', though.</span>
  <span class="s1">this.defaultEncoding = options.defaultEncoding || 'utf8';</span>

  <span class="s1">// the number of writers that are awaiting a drain event in .pipe()s</span>
  <span class="s1">this.awaitDrain = 0;</span>

  <span class="s1">// if true, a maybeReadMore has been scheduled</span>
  <span class="s1">this.readingMore = false;</span>

  <span class="s1">this.decoder = null;</span>
  <span class="s1">this.encoding = null;</span>
  <span class="s1">if (options.encoding) {</span>
    <span class="s1">if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;</span>
    <span class="s1">this.decoder = new StringDecoder(options.encoding);</span>
    <span class="s1">this.encoding = options.encoding;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function Readable(options) {</span>
  <span class="s1">Duplex = Duplex || require('./_stream_duplex');</span>

  <span class="s1">if (!(this instanceof Readable)) return new Readable(options);</span>

  <span class="s1">this._readableState = new ReadableState(options, this);</span>

  <span class="s1">// legacy</span>
  <span class="s1">this.readable = true;</span>

  <span class="s1">if (options) {</span>
    <span class="s1">if (typeof options.read === 'function') this._read = options.read;</span>

    <span class="s1">if (typeof options.destroy === 'function') this._destroy = options.destroy;</span>
  <span class="s1">}</span>

  <span class="s1">Stream.call(this);</span>
<span class="s1">}</span>

<span class="s1">Object.defineProperty(Readable.prototype, 'destroyed', {</span>
  <span class="s1">get: function () {</span>
    <span class="s1">if (this._readableState === undefined) {</span>
      <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">return this._readableState.destroyed;</span>
  <span class="s1">},</span>
  <span class="s1">set: function (value) {</span>
    <span class="s1">// we ignore the value if the stream</span>
    <span class="s1">// has not been initialized yet</span>
    <span class="s1">if (!this._readableState) {</span>
      <span class="s1">return;</span>
    <span class="s1">}</span>

    <span class="s1">// backward compatibility, the user is explicitly</span>
    <span class="s1">// managing destroyed</span>
    <span class="s1">this._readableState.destroyed = value;</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">Readable.prototype.destroy = destroyImpl.destroy;</span>
<span class="s1">Readable.prototype._undestroy = destroyImpl.undestroy;</span>
<span class="s1">Readable.prototype._destroy = function (err, cb) {</span>
  <span class="s1">this.push(null);</span>
  <span class="s1">cb(err);</span>
<span class="s1">};</span>

<span class="s1">// Manually shove something into the read() buffer.</span>
<span class="s1">// This returns true if the highWaterMark has not been hit yet,</span>
<span class="s1">// similar to how Writable.write() returns true if you should</span>
<span class="s1">// write() some more.</span>
<span class="s1">Readable.prototype.push = function (chunk, encoding) {</span>
  <span class="s1">var state = this._readableState;</span>
  <span class="s1">var skipChunkCheck;</span>

  <span class="s1">if (!state.objectMode) {</span>
    <span class="s1">if (typeof chunk === 'string') {</span>
      <span class="s1">encoding = encoding || state.defaultEncoding;</span>
      <span class="s1">if (encoding !== state.encoding) {</span>
        <span class="s1">chunk = Buffer.from(chunk, encoding);</span>
        <span class="s1">encoding = '';</span>
      <span class="s1">}</span>
      <span class="s1">skipChunkCheck = true;</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">skipChunkCheck = true;</span>
  <span class="s1">}</span>

  <span class="s1">return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);</span>
<span class="s1">};</span>

<span class="s1">// Unshift should *always* be something directly out of read()</span>
<span class="s1">Readable.prototype.unshift = function (chunk) {</span>
  <span class="s1">return readableAddChunk(this, chunk, null, true, false);</span>
<span class="s1">};</span>

<span class="s1">function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {</span>
  <span class="s1">var state = stream._readableState;</span>
  <span class="s1">if (chunk === null) {</span>
    <span class="s1">state.reading = false;</span>
    <span class="s1">onEofChunk(stream, state);</span>
  <span class="s1">} else {</span>
    <span class="s1">var er;</span>
    <span class="s1">if (!skipChunkCheck) er = chunkInvalid(state, chunk);</span>
    <span class="s1">if (er) {</span>
      <span class="s1">stream.emit('error', er);</span>
    <span class="s1">} else if (state.objectMode || chunk &amp;&amp; chunk.length &gt; 0) {</span>
      <span class="s1">if (typeof chunk !== 'string' &amp;&amp; !state.objectMode &amp;&amp; Object.getPrototypeOf(chunk) !== Buffer.prototype) {</span>
        <span class="s1">chunk = _uint8ArrayToBuffer(chunk);</span>
      <span class="s1">}</span>

      <span class="s1">if (addToFront) {</span>
        <span class="s1">if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);</span>
      <span class="s1">} else if (state.ended) {</span>
        <span class="s1">stream.emit('error', new Error('stream.push() after EOF'));</span>
      <span class="s1">} else {</span>
        <span class="s1">state.reading = false;</span>
        <span class="s1">if (state.decoder &amp;&amp; !encoding) {</span>
          <span class="s1">chunk = state.decoder.write(chunk);</span>
          <span class="s1">if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);</span>
        <span class="s1">} else {</span>
          <span class="s1">addChunk(stream, state, chunk, false);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} else if (!addToFront) {</span>
      <span class="s1">state.reading = false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return needMoreData(state);</span>
<span class="s1">}</span>

<span class="s1">function addChunk(stream, state, chunk, addToFront) {</span>
  <span class="s1">if (state.flowing &amp;&amp; state.length === 0 &amp;&amp; !state.sync) {</span>
    <span class="s1">stream.emit('data', chunk);</span>
    <span class="s1">stream.read(0);</span>
  <span class="s1">} else {</span>
    <span class="s1">// update the buffer info.</span>
    <span class="s1">state.length += state.objectMode ? 1 : chunk.length;</span>
    <span class="s1">if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);</span>

    <span class="s1">if (state.needReadable) emitReadable(stream);</span>
  <span class="s1">}</span>
  <span class="s1">maybeReadMore(stream, state);</span>
<span class="s1">}</span>

<span class="s1">function chunkInvalid(state, chunk) {</span>
  <span class="s1">var er;</span>
  <span class="s1">if (!_isUint8Array(chunk) &amp;&amp; typeof chunk !== 'string' &amp;&amp; chunk !== undefined &amp;&amp; !state.objectMode) {</span>
    <span class="s1">er = new TypeError('Invalid non-string/buffer chunk');</span>
  <span class="s1">}</span>
  <span class="s1">return er;</span>
<span class="s1">}</span>

<span class="s1">// if it's past the high water mark, we can push in some more.</span>
<span class="s1">// Also, if we have no data yet, we can stand some</span>
<span class="s1">// more bytes.  This is to work around cases where hwm=0,</span>
<span class="s1">// such as the repl.  Also, if the push() triggered a</span>
<span class="s1">// readable event, and the user called read(largeNumber) such that</span>
<span class="s1">// needReadable was set, then we ought to push more, so that another</span>
<span class="s1">// 'readable' event will be triggered.</span>
<span class="s1">function needMoreData(state) {</span>
  <span class="s1">return !state.ended &amp;&amp; (state.needReadable || state.length &lt; state.highWaterMark || state.length === 0);</span>
<span class="s1">}</span>

<span class="s1">Readable.prototype.isPaused = function () {</span>
  <span class="s1">return this._readableState.flowing === false;</span>
<span class="s1">};</span>

<span class="s1">// backwards compatibility.</span>
<span class="s1">Readable.prototype.setEncoding = function (enc) {</span>
  <span class="s1">if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;</span>
  <span class="s1">this._readableState.decoder = new StringDecoder(enc);</span>
  <span class="s1">this._readableState.encoding = enc;</span>
  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">// Don't raise the hwm &gt; 8MB</span>
<span class="s1">var MAX_HWM = 0x800000;</span>
<span class="s1">function computeNewHighWaterMark(n) {</span>
  <span class="s1">if (n &gt;= MAX_HWM) {</span>
    <span class="s1">n = MAX_HWM;</span>
  <span class="s1">} else {</span>
    <span class="s1">// Get the next highest power of 2 to prevent increasing hwm excessively in</span>
    <span class="s1">// tiny amounts</span>
    <span class="s1">n--;</span>
    <span class="s1">n |= n &gt;&gt;&gt; 1;</span>
    <span class="s1">n |= n &gt;&gt;&gt; 2;</span>
    <span class="s1">n |= n &gt;&gt;&gt; 4;</span>
    <span class="s1">n |= n &gt;&gt;&gt; 8;</span>
    <span class="s1">n |= n &gt;&gt;&gt; 16;</span>
    <span class="s1">n++;</span>
  <span class="s1">}</span>
  <span class="s1">return n;</span>
<span class="s1">}</span>

<span class="s1">// This function is designed to be inlinable, so please take care when making</span>
<span class="s1">// changes to the function body.</span>
<span class="s1">function howMuchToRead(n, state) {</span>
  <span class="s1">if (n &lt;= 0 || state.length === 0 &amp;&amp; state.ended) return 0;</span>
  <span class="s1">if (state.objectMode) return 1;</span>
  <span class="s1">if (n !== n) {</span>
    <span class="s1">// Only flow one buffer at a time</span>
    <span class="s1">if (state.flowing &amp;&amp; state.length) return state.buffer.head.data.length;else return state.length;</span>
  <span class="s1">}</span>
  <span class="s1">// If we're asking for more than the current hwm, then raise the hwm.</span>
  <span class="s1">if (n &gt; state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);</span>
  <span class="s1">if (n &lt;= state.length) return n;</span>
  <span class="s1">// Don't have enough</span>
  <span class="s1">if (!state.ended) {</span>
    <span class="s1">state.needReadable = true;</span>
    <span class="s1">return 0;</span>
  <span class="s1">}</span>
  <span class="s1">return state.length;</span>
<span class="s1">}</span>

<span class="s1">// you can override either this method, or the async _read(n) below.</span>
<span class="s1">Readable.prototype.read = function (n) {</span>
  <span class="s1">debug('read', n);</span>
  <span class="s1">n = parseInt(n, 10);</span>
  <span class="s1">var state = this._readableState;</span>
  <span class="s1">var nOrig = n;</span>

  <span class="s1">if (n !== 0) state.emittedReadable = false;</span>

  <span class="s1">// if we're doing read(0) to trigger a readable event, but we</span>
  <span class="s1">// already have a bunch of data in the buffer, then just trigger</span>
  <span class="s1">// the 'readable' event and move on.</span>
  <span class="s1">if (n === 0 &amp;&amp; state.needReadable &amp;&amp; (state.length &gt;= state.highWaterMark || state.ended)) {</span>
    <span class="s1">debug('read: emitReadable', state.length, state.ended);</span>
    <span class="s1">if (state.length === 0 &amp;&amp; state.ended) endReadable(this);else emitReadable(this);</span>
    <span class="s1">return null;</span>
  <span class="s1">}</span>

  <span class="s1">n = howMuchToRead(n, state);</span>

  <span class="s1">// if we've ended, and we're now clear, then finish it up.</span>
  <span class="s1">if (n === 0 &amp;&amp; state.ended) {</span>
    <span class="s1">if (state.length === 0) endReadable(this);</span>
    <span class="s1">return null;</span>
  <span class="s1">}</span>

  <span class="s1">// All the actual chunk generation logic needs to be</span>
  <span class="s1">// *below* the call to _read.  The reason is that in certain</span>
  <span class="s1">// synthetic stream cases, such as passthrough streams, _read</span>
  <span class="s1">// may be a completely synchronous operation which may change</span>
  <span class="s1">// the state of the read buffer, providing enough data when</span>
  <span class="s1">// before there was *not* enough.</span>
  <span class="s1">//</span>
  <span class="s1">// So, the steps are:</span>
  <span class="s1">// 1. Figure out what the state of things will be after we do</span>
  <span class="s1">// a read from the buffer.</span>
  <span class="s1">//</span>
  <span class="s1">// 2. If that resulting state will trigger a _read, then call _read.</span>
  <span class="s1">// Note that this may be asynchronous, or synchronous.  Yes, it is</span>
  <span class="s1">// deeply ugly to write APIs this way, but that still doesn't mean</span>
  <span class="s1">// that the Readable class should behave improperly, as streams are</span>
  <span class="s1">// designed to be sync/async agnostic.</span>
  <span class="s1">// Take note if the _read call is sync or async (ie, if the read call</span>
  <span class="s1">// has returned yet), so that we know whether or not it's safe to emit</span>
  <span class="s1">// 'readable' etc.</span>
  <span class="s1">//</span>
  <span class="s1">// 3. Actually pull the requested chunks out of the buffer and return.</span>

  <span class="s1">// if we need a readable event, then we need to do some reading.</span>
  <span class="s1">var doRead = state.needReadable;</span>
  <span class="s1">debug('need readable', doRead);</span>

  <span class="s1">// if we currently have less than the highWaterMark, then also read some</span>
  <span class="s1">if (state.length === 0 || state.length - n &lt; state.highWaterMark) {</span>
    <span class="s1">doRead = true;</span>
    <span class="s1">debug('length less than watermark', doRead);</span>
  <span class="s1">}</span>

  <span class="s1">// however, if we've ended, then there's no point, and if we're already</span>
  <span class="s1">// reading, then it's unnecessary.</span>
  <span class="s1">if (state.ended || state.reading) {</span>
    <span class="s1">doRead = false;</span>
    <span class="s1">debug('reading or ended', doRead);</span>
  <span class="s1">} else if (doRead) {</span>
    <span class="s1">debug('do read');</span>
    <span class="s1">state.reading = true;</span>
    <span class="s1">state.sync = true;</span>
    <span class="s1">// if the length is currently zero, then we *need* a readable event.</span>
    <span class="s1">if (state.length === 0) state.needReadable = true;</span>
    <span class="s1">// call internal read method</span>
    <span class="s1">this._read(state.highWaterMark);</span>
    <span class="s1">state.sync = false;</span>
    <span class="s1">// If _read pushed data synchronously, then `reading` will be false,</span>
    <span class="s1">// and we need to re-evaluate how much data we can return to the user.</span>
    <span class="s1">if (!state.reading) n = howMuchToRead(nOrig, state);</span>
  <span class="s1">}</span>

  <span class="s1">var ret;</span>
  <span class="s1">if (n &gt; 0) ret = fromList(n, state);else ret = null;</span>

  <span class="s1">if (ret === null) {</span>
    <span class="s1">state.needReadable = true;</span>
    <span class="s1">n = 0;</span>
  <span class="s1">} else {</span>
    <span class="s1">state.length -= n;</span>
  <span class="s1">}</span>

  <span class="s1">if (state.length === 0) {</span>
    <span class="s1">// If we have nothing in the buffer, then we want to know</span>
    <span class="s1">// as soon as we *do* get something into the buffer.</span>
    <span class="s1">if (!state.ended) state.needReadable = true;</span>

    <span class="s1">// If we tried to read() past the EOF, then emit end on the next tick.</span>
    <span class="s1">if (nOrig !== n &amp;&amp; state.ended) endReadable(this);</span>
  <span class="s1">}</span>

  <span class="s1">if (ret !== null) this.emit('data', ret);</span>

  <span class="s1">return ret;</span>
<span class="s1">};</span>

<span class="s1">function onEofChunk(stream, state) {</span>
  <span class="s1">if (state.ended) return;</span>
  <span class="s1">if (state.decoder) {</span>
    <span class="s1">var chunk = state.decoder.end();</span>
    <span class="s1">if (chunk &amp;&amp; chunk.length) {</span>
      <span class="s1">state.buffer.push(chunk);</span>
      <span class="s1">state.length += state.objectMode ? 1 : chunk.length;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">state.ended = true;</span>

  <span class="s1">// emit 'readable' now to make sure it gets picked up.</span>
  <span class="s1">emitReadable(stream);</span>
<span class="s1">}</span>

<span class="s1">// Don't emit readable right away in sync mode, because this can trigger</span>
<span class="s1">// another read() call =&gt; stack overflow.  This way, it might trigger</span>
<span class="s1">// a nextTick recursion warning, but that's not so bad.</span>
<span class="s1">function emitReadable(stream) {</span>
  <span class="s1">var state = stream._readableState;</span>
  <span class="s1">state.needReadable = false;</span>
  <span class="s1">if (!state.emittedReadable) {</span>
    <span class="s1">debug('emitReadable', state.flowing);</span>
    <span class="s1">state.emittedReadable = true;</span>
    <span class="s1">if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function emitReadable_(stream) {</span>
  <span class="s1">debug('emit readable');</span>
  <span class="s1">stream.emit('readable');</span>
  <span class="s1">flow(stream);</span>
<span class="s1">}</span>

<span class="s1">// at this point, the user has presumably seen the 'readable' event,</span>
<span class="s1">// and called read() to consume some data.  that may have triggered</span>
<span class="s1">// in turn another _read(n) call, in which case reading = true if</span>
<span class="s1">// it's in progress.</span>
<span class="s1">// However, if we're not ended, or reading, and the length &lt; hwm,</span>
<span class="s1">// then go ahead and try to read some more preemptively.</span>
<span class="s1">function maybeReadMore(stream, state) {</span>
  <span class="s1">if (!state.readingMore) {</span>
    <span class="s1">state.readingMore = true;</span>
    <span class="s1">pna.nextTick(maybeReadMore_, stream, state);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function maybeReadMore_(stream, state) {</span>
  <span class="s1">var len = state.length;</span>
  <span class="s1">while (!state.reading &amp;&amp; !state.flowing &amp;&amp; !state.ended &amp;&amp; state.length &lt; state.highWaterMark) {</span>
    <span class="s1">debug('maybeReadMore read 0');</span>
    <span class="s1">stream.read(0);</span>
    <span class="s1">if (len === state.length)</span>
      <span class="s1">// didn't get any data, stop spinning.</span>
      <span class="s1">break;else len = state.length;</span>
  <span class="s1">}</span>
  <span class="s1">state.readingMore = false;</span>
<span class="s1">}</span>

<span class="s1">// abstract method.  to be overridden in specific implementation classes.</span>
<span class="s1">// call cb(er, data) where data is &lt;= n in length.</span>
<span class="s1">// for virtual (non-string, non-buffer) streams, &quot;length&quot; is somewhat</span>
<span class="s1">// arbitrary, and perhaps not very meaningful.</span>
<span class="s1">Readable.prototype._read = function (n) {</span>
  <span class="s1">this.emit('error', new Error('_read() is not implemented'));</span>
<span class="s1">};</span>

<span class="s1">Readable.prototype.pipe = function (dest, pipeOpts) {</span>
  <span class="s1">var src = this;</span>
  <span class="s1">var state = this._readableState;</span>

  <span class="s1">switch (state.pipesCount) {</span>
    <span class="s1">case 0:</span>
      <span class="s1">state.pipes = dest;</span>
      <span class="s1">break;</span>
    <span class="s1">case 1:</span>
      <span class="s1">state.pipes = [state.pipes, dest];</span>
      <span class="s1">break;</span>
    <span class="s1">default:</span>
      <span class="s1">state.pipes.push(dest);</span>
      <span class="s1">break;</span>
  <span class="s1">}</span>
  <span class="s1">state.pipesCount += 1;</span>
  <span class="s1">debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);</span>

  <span class="s1">var doEnd = (!pipeOpts || pipeOpts.end !== false) &amp;&amp; dest !== process.stdout &amp;&amp; dest !== process.stderr;</span>

  <span class="s1">var endFn = doEnd ? onend : unpipe;</span>
  <span class="s1">if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);</span>

  <span class="s1">dest.on('unpipe', onunpipe);</span>
  <span class="s1">function onunpipe(readable, unpipeInfo) {</span>
    <span class="s1">debug('onunpipe');</span>
    <span class="s1">if (readable === src) {</span>
      <span class="s1">if (unpipeInfo &amp;&amp; unpipeInfo.hasUnpiped === false) {</span>
        <span class="s1">unpipeInfo.hasUnpiped = true;</span>
        <span class="s1">cleanup();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">function onend() {</span>
    <span class="s1">debug('onend');</span>
    <span class="s1">dest.end();</span>
  <span class="s1">}</span>

  <span class="s1">// when the dest drains, it reduces the awaitDrain counter</span>
  <span class="s1">// on the source.  This would be more elegant with a .once()</span>
  <span class="s1">// handler in flow(), but adding and removing repeatedly is</span>
  <span class="s1">// too slow.</span>
  <span class="s1">var ondrain = pipeOnDrain(src);</span>
  <span class="s1">dest.on('drain', ondrain);</span>

  <span class="s1">var cleanedUp = false;</span>
  <span class="s1">function cleanup() {</span>
    <span class="s1">debug('cleanup');</span>
    <span class="s1">// cleanup event handlers once the pipe is broken</span>
    <span class="s1">dest.removeListener('close', onclose);</span>
    <span class="s1">dest.removeListener('finish', onfinish);</span>
    <span class="s1">dest.removeListener('drain', ondrain);</span>
    <span class="s1">dest.removeListener('error', onerror);</span>
    <span class="s1">dest.removeListener('unpipe', onunpipe);</span>
    <span class="s1">src.removeListener('end', onend);</span>
    <span class="s1">src.removeListener('end', unpipe);</span>
    <span class="s1">src.removeListener('data', ondata);</span>

    <span class="s1">cleanedUp = true;</span>

    <span class="s1">// if the reader is waiting for a drain event from this</span>
    <span class="s1">// specific writer, then it would cause it to never start</span>
    <span class="s1">// flowing again.</span>
    <span class="s1">// So, if this is awaiting a drain, then we just call it now.</span>
    <span class="s1">// If we don't know, then assume that we are waiting for one.</span>
    <span class="s1">if (state.awaitDrain &amp;&amp; (!dest._writableState || dest._writableState.needDrain)) ondrain();</span>
  <span class="s1">}</span>

  <span class="s1">// If the user pushes more data while we're writing to dest then we'll end up</span>
  <span class="s1">// in ondata again. However, we only want to increase awaitDrain once because</span>
  <span class="s1">// dest will only emit one 'drain' event for the multiple writes.</span>
  <span class="s1">// =&gt; Introduce a guard on increasing awaitDrain.</span>
  <span class="s1">var increasedAwaitDrain = false;</span>
  <span class="s1">src.on('data', ondata);</span>
  <span class="s1">function ondata(chunk) {</span>
    <span class="s1">debug('ondata');</span>
    <span class="s1">increasedAwaitDrain = false;</span>
    <span class="s1">var ret = dest.write(chunk);</span>
    <span class="s1">if (false === ret &amp;&amp; !increasedAwaitDrain) {</span>
      <span class="s1">// If the user unpiped during `dest.write()`, it is possible</span>
      <span class="s1">// to get stuck in a permanently paused state if that write</span>
      <span class="s1">// also returned false.</span>
      <span class="s1">// =&gt; Check whether `dest` is still a piping destination.</span>
      <span class="s1">if ((state.pipesCount === 1 &amp;&amp; state.pipes === dest || state.pipesCount &gt; 1 &amp;&amp; indexOf(state.pipes, dest) !== -1) &amp;&amp; !cleanedUp) {</span>
        <span class="s1">debug('false write response, pause', src._readableState.awaitDrain);</span>
        <span class="s1">src._readableState.awaitDrain++;</span>
        <span class="s1">increasedAwaitDrain = true;</span>
      <span class="s1">}</span>
      <span class="s1">src.pause();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">// if the dest has an error, then stop piping into it.</span>
  <span class="s1">// however, don't suppress the throwing behavior for this.</span>
  <span class="s1">function onerror(er) {</span>
    <span class="s1">debug('onerror', er);</span>
    <span class="s1">unpipe();</span>
    <span class="s1">dest.removeListener('error', onerror);</span>
    <span class="s1">if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);</span>
  <span class="s1">}</span>

  <span class="s1">// Make sure our error handler is attached before userland ones.</span>
  <span class="s1">prependListener(dest, 'error', onerror);</span>

  <span class="s1">// Both close and finish should trigger unpipe, but only once.</span>
  <span class="s1">function onclose() {</span>
    <span class="s1">dest.removeListener('finish', onfinish);</span>
    <span class="s1">unpipe();</span>
  <span class="s1">}</span>
  <span class="s1">dest.once('close', onclose);</span>
  <span class="s1">function onfinish() {</span>
    <span class="s1">debug('onfinish');</span>
    <span class="s1">dest.removeListener('close', onclose);</span>
    <span class="s1">unpipe();</span>
  <span class="s1">}</span>
  <span class="s1">dest.once('finish', onfinish);</span>

  <span class="s1">function unpipe() {</span>
    <span class="s1">debug('unpipe');</span>
    <span class="s1">src.unpipe(dest);</span>
  <span class="s1">}</span>

  <span class="s1">// tell the dest that it's being piped to</span>
  <span class="s1">dest.emit('pipe', src);</span>

  <span class="s1">// start the flow if it hasn't been started already.</span>
  <span class="s1">if (!state.flowing) {</span>
    <span class="s1">debug('pipe resume');</span>
    <span class="s1">src.resume();</span>
  <span class="s1">}</span>

  <span class="s1">return dest;</span>
<span class="s1">};</span>

<span class="s1">function pipeOnDrain(src) {</span>
  <span class="s1">return function () {</span>
    <span class="s1">var state = src._readableState;</span>
    <span class="s1">debug('pipeOnDrain', state.awaitDrain);</span>
    <span class="s1">if (state.awaitDrain) state.awaitDrain--;</span>
    <span class="s1">if (state.awaitDrain === 0 &amp;&amp; EElistenerCount(src, 'data')) {</span>
      <span class="s1">state.flowing = true;</span>
      <span class="s1">flow(src);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">Readable.prototype.unpipe = function (dest) {</span>
  <span class="s1">var state = this._readableState;</span>
  <span class="s1">var unpipeInfo = { hasUnpiped: false };</span>

  <span class="s1">// if we're not piping anywhere, then do nothing.</span>
  <span class="s1">if (state.pipesCount === 0) return this;</span>

  <span class="s1">// just one destination.  most common case.</span>
  <span class="s1">if (state.pipesCount === 1) {</span>
    <span class="s1">// passed in one, but it's not the right one.</span>
    <span class="s1">if (dest &amp;&amp; dest !== state.pipes) return this;</span>

    <span class="s1">if (!dest) dest = state.pipes;</span>

    <span class="s1">// got a match.</span>
    <span class="s1">state.pipes = null;</span>
    <span class="s1">state.pipesCount = 0;</span>
    <span class="s1">state.flowing = false;</span>
    <span class="s1">if (dest) dest.emit('unpipe', this, unpipeInfo);</span>
    <span class="s1">return this;</span>
  <span class="s1">}</span>

  <span class="s1">// slow case. multiple pipe destinations.</span>

  <span class="s1">if (!dest) {</span>
    <span class="s1">// remove all.</span>
    <span class="s1">var dests = state.pipes;</span>
    <span class="s1">var len = state.pipesCount;</span>
    <span class="s1">state.pipes = null;</span>
    <span class="s1">state.pipesCount = 0;</span>
    <span class="s1">state.flowing = false;</span>

    <span class="s1">for (var i = 0; i &lt; len; i++) {</span>
      <span class="s1">dests[i].emit('unpipe', this, unpipeInfo);</span>
    <span class="s1">}return this;</span>
  <span class="s1">}</span>

  <span class="s1">// try to find the right one.</span>
  <span class="s1">var index = indexOf(state.pipes, dest);</span>
  <span class="s1">if (index === -1) return this;</span>

  <span class="s1">state.pipes.splice(index, 1);</span>
  <span class="s1">state.pipesCount -= 1;</span>
  <span class="s1">if (state.pipesCount === 1) state.pipes = state.pipes[0];</span>

  <span class="s1">dest.emit('unpipe', this, unpipeInfo);</span>

  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">// set up data events if they are asked for</span>
<span class="s1">// Ensure readable listeners eventually get something</span>
<span class="s1">Readable.prototype.on = function (ev, fn) {</span>
  <span class="s1">var res = Stream.prototype.on.call(this, ev, fn);</span>

  <span class="s1">if (ev === 'data') {</span>
    <span class="s1">// Start flowing on next tick if stream isn't explicitly paused</span>
    <span class="s1">if (this._readableState.flowing !== false) this.resume();</span>
  <span class="s1">} else if (ev === 'readable') {</span>
    <span class="s1">var state = this._readableState;</span>
    <span class="s1">if (!state.endEmitted &amp;&amp; !state.readableListening) {</span>
      <span class="s1">state.readableListening = state.needReadable = true;</span>
      <span class="s1">state.emittedReadable = false;</span>
      <span class="s1">if (!state.reading) {</span>
        <span class="s1">pna.nextTick(nReadingNextTick, this);</span>
      <span class="s1">} else if (state.length) {</span>
        <span class="s1">emitReadable(this);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">return res;</span>
<span class="s1">};</span>
<span class="s1">Readable.prototype.addListener = Readable.prototype.on;</span>

<span class="s1">function nReadingNextTick(self) {</span>
  <span class="s1">debug('readable nexttick read 0');</span>
  <span class="s1">self.read(0);</span>
<span class="s1">}</span>

<span class="s1">// pause() and resume() are remnants of the legacy readable stream API</span>
<span class="s1">// If the user uses them, then switch into old mode.</span>
<span class="s1">Readable.prototype.resume = function () {</span>
  <span class="s1">var state = this._readableState;</span>
  <span class="s1">if (!state.flowing) {</span>
    <span class="s1">debug('resume');</span>
    <span class="s1">state.flowing = true;</span>
    <span class="s1">resume(this, state);</span>
  <span class="s1">}</span>
  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">function resume(stream, state) {</span>
  <span class="s1">if (!state.resumeScheduled) {</span>
    <span class="s1">state.resumeScheduled = true;</span>
    <span class="s1">pna.nextTick(resume_, stream, state);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function resume_(stream, state) {</span>
  <span class="s1">if (!state.reading) {</span>
    <span class="s1">debug('resume read 0');</span>
    <span class="s1">stream.read(0);</span>
  <span class="s1">}</span>

  <span class="s1">state.resumeScheduled = false;</span>
  <span class="s1">state.awaitDrain = 0;</span>
  <span class="s1">stream.emit('resume');</span>
  <span class="s1">flow(stream);</span>
  <span class="s1">if (state.flowing &amp;&amp; !state.reading) stream.read(0);</span>
<span class="s1">}</span>

<span class="s1">Readable.prototype.pause = function () {</span>
  <span class="s1">debug('call pause flowing=%j', this._readableState.flowing);</span>
  <span class="s1">if (false !== this._readableState.flowing) {</span>
    <span class="s1">debug('pause');</span>
    <span class="s1">this._readableState.flowing = false;</span>
    <span class="s1">this.emit('pause');</span>
  <span class="s1">}</span>
  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">function flow(stream) {</span>
  <span class="s1">var state = stream._readableState;</span>
  <span class="s1">debug('flow', state.flowing);</span>
  <span class="s1">while (state.flowing &amp;&amp; stream.read() !== null) {}</span>
<span class="s1">}</span>

<span class="s1">// wrap an old-style stream as the async data source.</span>
<span class="s1">// This is *not* part of the readable stream interface.</span>
<span class="s1">// It is an ugly unfortunate mess of history.</span>
<span class="s1">Readable.prototype.wrap = function (stream) {</span>
  <span class="s1">var _this = this;</span>

  <span class="s1">var state = this._readableState;</span>
  <span class="s1">var paused = false;</span>

  <span class="s1">stream.on('end', function () {</span>
    <span class="s1">debug('wrapped end');</span>
    <span class="s1">if (state.decoder &amp;&amp; !state.ended) {</span>
      <span class="s1">var chunk = state.decoder.end();</span>
      <span class="s1">if (chunk &amp;&amp; chunk.length) _this.push(chunk);</span>
    <span class="s1">}</span>

    <span class="s1">_this.push(null);</span>
  <span class="s1">});</span>

  <span class="s1">stream.on('data', function (chunk) {</span>
    <span class="s1">debug('wrapped data');</span>
    <span class="s1">if (state.decoder) chunk = state.decoder.write(chunk);</span>

    <span class="s1">// don't skip over falsy values in objectMode</span>
    <span class="s1">if (state.objectMode &amp;&amp; (chunk === null || chunk === undefined)) return;else if (!state.objectMode &amp;&amp; (!chunk || !chunk.length)) return;</span>

    <span class="s1">var ret = _this.push(chunk);</span>
    <span class="s1">if (!ret) {</span>
      <span class="s1">paused = true;</span>
      <span class="s1">stream.pause();</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s1">// proxy all the other methods.</span>
  <span class="s1">// important when wrapping filters and duplexes.</span>
  <span class="s1">for (var i in stream) {</span>
    <span class="s1">if (this[i] === undefined &amp;&amp; typeof stream[i] === 'function') {</span>
      <span class="s1">this[i] = function (method) {</span>
        <span class="s1">return function () {</span>
          <span class="s1">return stream[method].apply(stream, arguments);</span>
        <span class="s1">};</span>
      <span class="s1">}(i);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">// proxy certain important events.</span>
  <span class="s1">for (var n = 0; n &lt; kProxyEvents.length; n++) {</span>
    <span class="s1">stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));</span>
  <span class="s1">}</span>

  <span class="s1">// when we try to consume some more bytes, simply unpause the</span>
  <span class="s1">// underlying stream.</span>
  <span class="s1">this._read = function (n) {</span>
    <span class="s1">debug('wrapped _read', n);</span>
    <span class="s1">if (paused) {</span>
      <span class="s1">paused = false;</span>
      <span class="s1">stream.resume();</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {</span>
  <span class="s1">// making it explicit this property is not enumerable</span>
  <span class="s1">// because otherwise some prototype manipulation in</span>
  <span class="s1">// userland will fail</span>
  <span class="s1">enumerable: false,</span>
  <span class="s1">get: function () {</span>
    <span class="s1">return this._readableState.highWaterMark;</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">// exposed for testing purposes only.</span>
<span class="s1">Readable._fromList = fromList;</span>

<span class="s1">// Pluck off n bytes from an array of buffers.</span>
<span class="s1">// Length is the combined lengths of all the buffers in the list.</span>
<span class="s1">// This function is designed to be inlinable, so please take care when making</span>
<span class="s1">// changes to the function body.</span>
<span class="s1">function fromList(n, state) {</span>
  <span class="s1">// nothing buffered</span>
  <span class="s1">if (state.length === 0) return null;</span>

  <span class="s1">var ret;</span>
  <span class="s1">if (state.objectMode) ret = state.buffer.shift();else if (!n || n &gt;= state.length) {</span>
    <span class="s1">// read it all, truncate the list</span>
    <span class="s1">if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);</span>
    <span class="s1">state.buffer.clear();</span>
  <span class="s1">} else {</span>
    <span class="s1">// read part of list</span>
    <span class="s1">ret = fromListPartial(n, state.buffer, state.decoder);</span>
  <span class="s1">}</span>

  <span class="s1">return ret;</span>
<span class="s1">}</span>

<span class="s1">// Extracts only enough buffered data to satisfy the amount requested.</span>
<span class="s1">// This function is designed to be inlinable, so please take care when making</span>
<span class="s1">// changes to the function body.</span>
<span class="s1">function fromListPartial(n, list, hasStrings) {</span>
  <span class="s1">var ret;</span>
  <span class="s1">if (n &lt; list.head.data.length) {</span>
    <span class="s1">// slice is the same for buffers and strings</span>
    <span class="s1">ret = list.head.data.slice(0, n);</span>
    <span class="s1">list.head.data = list.head.data.slice(n);</span>
  <span class="s1">} else if (n === list.head.data.length) {</span>
    <span class="s1">// first chunk is a perfect match</span>
    <span class="s1">ret = list.shift();</span>
  <span class="s1">} else {</span>
    <span class="s1">// result spans more than one buffer</span>
    <span class="s1">ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);</span>
  <span class="s1">}</span>
  <span class="s1">return ret;</span>
<span class="s1">}</span>

<span class="s1">// Copies a specified amount of characters from the list of buffered data</span>
<span class="s1">// chunks.</span>
<span class="s1">// This function is designed to be inlinable, so please take care when making</span>
<span class="s1">// changes to the function body.</span>
<span class="s1">function copyFromBufferString(n, list) {</span>
  <span class="s1">var p = list.head;</span>
  <span class="s1">var c = 1;</span>
  <span class="s1">var ret = p.data;</span>
  <span class="s1">n -= ret.length;</span>
  <span class="s1">while (p = p.next) {</span>
    <span class="s1">var str = p.data;</span>
    <span class="s1">var nb = n &gt; str.length ? str.length : n;</span>
    <span class="s1">if (nb === str.length) ret += str;else ret += str.slice(0, n);</span>
    <span class="s1">n -= nb;</span>
    <span class="s1">if (n === 0) {</span>
      <span class="s1">if (nb === str.length) {</span>
        <span class="s1">++c;</span>
        <span class="s1">if (p.next) list.head = p.next;else list.head = list.tail = null;</span>
      <span class="s1">} else {</span>
        <span class="s1">list.head = p;</span>
        <span class="s1">p.data = str.slice(nb);</span>
      <span class="s1">}</span>
      <span class="s1">break;</span>
    <span class="s1">}</span>
    <span class="s1">++c;</span>
  <span class="s1">}</span>
  <span class="s1">list.length -= c;</span>
  <span class="s1">return ret;</span>
<span class="s1">}</span>

<span class="s1">// Copies a specified amount of bytes from the list of buffered data chunks.</span>
<span class="s1">// This function is designed to be inlinable, so please take care when making</span>
<span class="s1">// changes to the function body.</span>
<span class="s1">function copyFromBuffer(n, list) {</span>
  <span class="s1">var ret = Buffer.allocUnsafe(n);</span>
  <span class="s1">var p = list.head;</span>
  <span class="s1">var c = 1;</span>
  <span class="s1">p.data.copy(ret);</span>
  <span class="s1">n -= p.data.length;</span>
  <span class="s1">while (p = p.next) {</span>
    <span class="s1">var buf = p.data;</span>
    <span class="s1">var nb = n &gt; buf.length ? buf.length : n;</span>
    <span class="s1">buf.copy(ret, ret.length - n, 0, nb);</span>
    <span class="s1">n -= nb;</span>
    <span class="s1">if (n === 0) {</span>
      <span class="s1">if (nb === buf.length) {</span>
        <span class="s1">++c;</span>
        <span class="s1">if (p.next) list.head = p.next;else list.head = list.tail = null;</span>
      <span class="s1">} else {</span>
        <span class="s1">list.head = p;</span>
        <span class="s1">p.data = buf.slice(nb);</span>
      <span class="s1">}</span>
      <span class="s1">break;</span>
    <span class="s1">}</span>
    <span class="s1">++c;</span>
  <span class="s1">}</span>
  <span class="s1">list.length -= c;</span>
  <span class="s1">return ret;</span>
<span class="s1">}</span>

<span class="s1">function endReadable(stream) {</span>
  <span class="s1">var state = stream._readableState;</span>

  <span class="s1">// If we get here before consuming all the bytes, then that is a</span>
  <span class="s1">// bug in node.  Should never happen.</span>
  <span class="s1">if (state.length &gt; 0) throw new Error('&quot;endReadable()&quot; called on non-empty stream');</span>

  <span class="s1">if (!state.endEmitted) {</span>
    <span class="s1">state.ended = true;</span>
    <span class="s1">pna.nextTick(endReadableNT, state, stream);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function endReadableNT(state, stream) {</span>
  <span class="s1">// Check that we didn't get one last unshift.</span>
  <span class="s1">if (!state.endEmitted &amp;&amp; state.length === 0) {</span>
    <span class="s1">state.endEmitted = true;</span>
    <span class="s1">stream.readable = false;</span>
    <span class="s1">stream.emit('end');</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function indexOf(xs, x) {</span>
  <span class="s1">for (var i = 0, l = xs.length; i &lt; l; i++) {</span>
    <span class="s1">if (xs[i] === x) return i;</span>
  <span class="s1">}</span>
  <span class="s1">return -1;</span>
<span class="s1">}</span>
<span class="s1">}).call(this)}).call(this,require('_process'),typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})</span>

<span class="s1">},{&quot;./_stream_duplex&quot;:81,&quot;./internal/streams/BufferList&quot;:86,&quot;./internal/streams/destroy&quot;:87,&quot;./internal/streams/stream&quot;:88,&quot;_process&quot;:79,&quot;core-util-is&quot;:13,&quot;events&quot;:33,&quot;inherits&quot;:47,&quot;isarray&quot;:62,&quot;process-nextick-args&quot;:78,&quot;safe-buffer&quot;:89,&quot;string_decoder/&quot;:90,&quot;util&quot;:9}],84:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// a transform stream is a readable/writable stream where you do</span>
<span class="s1">// something with the data.  Sometimes it's called a &quot;filter&quot;,</span>
<span class="s1">// but that's not a great name for it, since that implies a thing where</span>
<span class="s1">// some bits pass through, and others are simply ignored.  (That would</span>
<span class="s1">// be a valid example of a transform, of course.)</span>
<span class="s1">//</span>
<span class="s1">// While the output is causally related to the input, it's not a</span>
<span class="s1">// necessarily symmetric or synchronous transformation.  For example,</span>
<span class="s1">// a zlib stream might take multiple plain-text writes(), and then</span>
<span class="s1">// emit a single compressed chunk some time in the future.</span>
<span class="s1">//</span>
<span class="s1">// Here's how this works:</span>
<span class="s1">//</span>
<span class="s1">// The Transform stream has all the aspects of the readable and writable</span>
<span class="s1">// stream classes.  When you write(chunk), that calls _write(chunk,cb)</span>
<span class="s1">// internally, and returns false if there's a lot of pending writes</span>
<span class="s1">// buffered up.  When you call read(), that calls _read(n) until</span>
<span class="s1">// there's enough pending readable data buffered up.</span>
<span class="s1">//</span>
<span class="s1">// In a transform stream, the written data is placed in a buffer.  When</span>
<span class="s1">// _read(n) is called, it transforms the queued up data, calling the</span>
<span class="s1">// buffered _write cb's as it consumes chunks.  If consuming a single</span>
<span class="s1">// written chunk would result in multiple output chunks, then the first</span>
<span class="s1">// outputted bit calls the readcb, and subsequent chunks just go into</span>
<span class="s1">// the read buffer, and will cause it to emit 'readable' if necessary.</span>
<span class="s1">//</span>
<span class="s1">// This way, back-pressure is actually determined by the reading side,</span>
<span class="s1">// since _read has to be called to start processing a new chunk.  However,</span>
<span class="s1">// a pathological inflate type of transform can cause excessive buffering</span>
<span class="s1">// here.  For example, imagine a stream where every byte of input is</span>
<span class="s1">// interpreted as an integer from 0-255, and then results in that many</span>
<span class="s1">// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in</span>
<span class="s1">// 1kb of data being output.  In this case, you could write a very small</span>
<span class="s1">// amount of input, and end up with a very large amount of output.  In</span>
<span class="s1">// such a pathological inflating mechanism, there'd be no way to tell</span>
<span class="s1">// the system to stop doing the transform.  A single 4MB write could</span>
<span class="s1">// cause the system to run out of memory.</span>
<span class="s1">//</span>
<span class="s1">// However, even in such a pathological case, only a single written chunk</span>
<span class="s1">// would be consumed, and then the rest would wait (un-transformed) until</span>
<span class="s1">// the results of the previous transformed chunk were consumed.</span>

<span class="s1">'use strict';</span>

<span class="s1">module.exports = Transform;</span>

<span class="s1">var Duplex = require('./_stream_duplex');</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var util = Object.create(require('core-util-is'));</span>
<span class="s1">util.inherits = require('inherits');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">util.inherits(Transform, Duplex);</span>

<span class="s1">function afterTransform(er, data) {</span>
  <span class="s1">var ts = this._transformState;</span>
  <span class="s1">ts.transforming = false;</span>

  <span class="s1">var cb = ts.writecb;</span>

  <span class="s1">if (!cb) {</span>
    <span class="s1">return this.emit('error', new Error('write callback called multiple times'));</span>
  <span class="s1">}</span>

  <span class="s1">ts.writechunk = null;</span>
  <span class="s1">ts.writecb = null;</span>

  <span class="s1">if (data != null) // single equals check for both `null` and `undefined`</span>
    <span class="s1">this.push(data);</span>

  <span class="s1">cb(er);</span>

  <span class="s1">var rs = this._readableState;</span>
  <span class="s1">rs.reading = false;</span>
  <span class="s1">if (rs.needReadable || rs.length &lt; rs.highWaterMark) {</span>
    <span class="s1">this._read(rs.highWaterMark);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function Transform(options) {</span>
  <span class="s1">if (!(this instanceof Transform)) return new Transform(options);</span>

  <span class="s1">Duplex.call(this, options);</span>

  <span class="s1">this._transformState = {</span>
    <span class="s1">afterTransform: afterTransform.bind(this),</span>
    <span class="s1">needTransform: false,</span>
    <span class="s1">transforming: false,</span>
    <span class="s1">writecb: null,</span>
    <span class="s1">writechunk: null,</span>
    <span class="s1">writeencoding: null</span>
  <span class="s1">};</span>

  <span class="s1">// start out asking for a readable event once data is transformed.</span>
  <span class="s1">this._readableState.needReadable = true;</span>

  <span class="s1">// we have implemented the _read method, and done the other things</span>
  <span class="s1">// that Readable wants before the first _read call, so unset the</span>
  <span class="s1">// sync guard flag.</span>
  <span class="s1">this._readableState.sync = false;</span>

  <span class="s1">if (options) {</span>
    <span class="s1">if (typeof options.transform === 'function') this._transform = options.transform;</span>

    <span class="s1">if (typeof options.flush === 'function') this._flush = options.flush;</span>
  <span class="s1">}</span>

  <span class="s1">// When the writable side finishes, then flush out anything remaining.</span>
  <span class="s1">this.on('prefinish', prefinish);</span>
<span class="s1">}</span>

<span class="s1">function prefinish() {</span>
  <span class="s1">var _this = this;</span>

  <span class="s1">if (typeof this._flush === 'function') {</span>
    <span class="s1">this._flush(function (er, data) {</span>
      <span class="s1">done(_this, er, data);</span>
    <span class="s1">});</span>
  <span class="s1">} else {</span>
    <span class="s1">done(this, null, null);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Transform.prototype.push = function (chunk, encoding) {</span>
  <span class="s1">this._transformState.needTransform = false;</span>
  <span class="s1">return Duplex.prototype.push.call(this, chunk, encoding);</span>
<span class="s1">};</span>

<span class="s1">// This is the part where you do stuff!</span>
<span class="s1">// override this function in implementation classes.</span>
<span class="s1">// 'chunk' is an input chunk.</span>
<span class="s1">//</span>
<span class="s1">// Call `push(newChunk)` to pass along transformed output</span>
<span class="s1">// to the readable side.  You may call 'push' zero or more times.</span>
<span class="s1">//</span>
<span class="s1">// Call `cb(err)` when you are done with this chunk.  If you pass</span>
<span class="s1">// an error, then that'll put the hurt on the whole operation.  If you</span>
<span class="s1">// never call cb(), then you'll never get another chunk.</span>
<span class="s1">Transform.prototype._transform = function (chunk, encoding, cb) {</span>
  <span class="s1">throw new Error('_transform() is not implemented');</span>
<span class="s1">};</span>

<span class="s1">Transform.prototype._write = function (chunk, encoding, cb) {</span>
  <span class="s1">var ts = this._transformState;</span>
  <span class="s1">ts.writecb = cb;</span>
  <span class="s1">ts.writechunk = chunk;</span>
  <span class="s1">ts.writeencoding = encoding;</span>
  <span class="s1">if (!ts.transforming) {</span>
    <span class="s1">var rs = this._readableState;</span>
    <span class="s1">if (ts.needTransform || rs.needReadable || rs.length &lt; rs.highWaterMark) this._read(rs.highWaterMark);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">// Doesn't matter what the args are here.</span>
<span class="s1">// _transform does all the work.</span>
<span class="s1">// That we got here means that the readable side wants more data.</span>
<span class="s1">Transform.prototype._read = function (n) {</span>
  <span class="s1">var ts = this._transformState;</span>

  <span class="s1">if (ts.writechunk !== null &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {</span>
    <span class="s1">ts.transforming = true;</span>
    <span class="s1">this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);</span>
  <span class="s1">} else {</span>
    <span class="s1">// mark that we need a transform, so that any data that comes in</span>
    <span class="s1">// will get processed, now that we've asked for it.</span>
    <span class="s1">ts.needTransform = true;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Transform.prototype._destroy = function (err, cb) {</span>
  <span class="s1">var _this2 = this;</span>

  <span class="s1">Duplex.prototype._destroy.call(this, err, function (err2) {</span>
    <span class="s1">cb(err2);</span>
    <span class="s1">_this2.emit('close');</span>
  <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">function done(stream, er, data) {</span>
  <span class="s1">if (er) return stream.emit('error', er);</span>

  <span class="s1">if (data != null) // single equals check for both `null` and `undefined`</span>
    <span class="s1">stream.push(data);</span>

  <span class="s1">// if there's nothing in the write buffer, then that means</span>
  <span class="s1">// that nothing more will ever be provided</span>
  <span class="s1">if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');</span>

  <span class="s1">if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');</span>

  <span class="s1">return stream.push(null);</span>
<span class="s1">}</span>
<span class="s1">},{&quot;./_stream_duplex&quot;:81,&quot;core-util-is&quot;:13,&quot;inherits&quot;:47}],85:[function(require,module,exports){</span>
<span class="s1">(function (process,global,setImmediate){(function (){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">// A bit simpler than readable streams.</span>
<span class="s1">// Implement an async ._write(chunk, encoding, cb), and it'll handle all</span>
<span class="s1">// the drain event emission and buffering.</span>

<span class="s1">'use strict';</span>

<span class="s1">/*&lt;replacement&gt;*/</span>

<span class="s1">var pna = require('process-nextick-args');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">module.exports = Writable;</span>

<span class="s1">/* &lt;replacement&gt; */</span>
<span class="s1">function WriteReq(chunk, encoding, cb) {</span>
  <span class="s1">this.chunk = chunk;</span>
  <span class="s1">this.encoding = encoding;</span>
  <span class="s1">this.callback = cb;</span>
  <span class="s1">this.next = null;</span>
<span class="s1">}</span>

<span class="s1">// It seems a linked list but it is not</span>
<span class="s1">// there will be only 2 of these for each stream</span>
<span class="s1">function CorkedRequest(state) {</span>
  <span class="s1">var _this = this;</span>

  <span class="s1">this.next = null;</span>
  <span class="s1">this.entry = null;</span>
  <span class="s1">this.finish = function () {</span>
    <span class="s1">onCorkedFinish(_this, state);</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">/* &lt;/replacement&gt; */</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var asyncWrite = !process.browser &amp;&amp; ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) &gt; -1 ? setImmediate : pna.nextTick;</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var Duplex;</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">Writable.WritableState = WritableState;</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var util = Object.create(require('core-util-is'));</span>
<span class="s1">util.inherits = require('inherits');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var internalUtil = {</span>
  <span class="s1">deprecate: require('util-deprecate')</span>
<span class="s1">};</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>
<span class="s1">var Stream = require('./internal/streams/stream');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">/*&lt;replacement&gt;*/</span>

<span class="s1">var Buffer = require('safe-buffer').Buffer;</span>
<span class="s1">var OurUint8Array = global.Uint8Array || function () {};</span>
<span class="s1">function _uint8ArrayToBuffer(chunk) {</span>
  <span class="s1">return Buffer.from(chunk);</span>
<span class="s1">}</span>
<span class="s1">function _isUint8Array(obj) {</span>
  <span class="s1">return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;</span>
<span class="s1">}</span>

<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">var destroyImpl = require('./internal/streams/destroy');</span>

<span class="s1">util.inherits(Writable, Stream);</span>

<span class="s1">function nop() {}</span>

<span class="s1">function WritableState(options, stream) {</span>
  <span class="s1">Duplex = Duplex || require('./_stream_duplex');</span>

  <span class="s1">options = options || {};</span>

  <span class="s1">// Duplex streams are both readable and writable, but share</span>
  <span class="s1">// the same options object.</span>
  <span class="s1">// However, some cases require setting options to different</span>
  <span class="s1">// values for the readable and the writable sides of the duplex stream.</span>
  <span class="s1">// These options can be provided separately as readableXXX and writableXXX.</span>
  <span class="s1">var isDuplex = stream instanceof Duplex;</span>

  <span class="s1">// object stream flag to indicate whether or not this stream</span>
  <span class="s1">// contains buffers or objects.</span>
  <span class="s1">this.objectMode = !!options.objectMode;</span>

  <span class="s1">if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;</span>

  <span class="s1">// the point at which write() starts returning false</span>
  <span class="s1">// Note: 0 is a valid value, means that we always return false if</span>
  <span class="s1">// the entire buffer is not flushed immediately on write()</span>
  <span class="s1">var hwm = options.highWaterMark;</span>
  <span class="s1">var writableHwm = options.writableHighWaterMark;</span>
  <span class="s1">var defaultHwm = this.objectMode ? 16 : 16 * 1024;</span>

  <span class="s1">if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex &amp;&amp; (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;</span>

  <span class="s1">// cast to ints.</span>
  <span class="s1">this.highWaterMark = Math.floor(this.highWaterMark);</span>

  <span class="s1">// if _final has been called</span>
  <span class="s1">this.finalCalled = false;</span>

  <span class="s1">// drain event flag.</span>
  <span class="s1">this.needDrain = false;</span>
  <span class="s1">// at the start of calling end()</span>
  <span class="s1">this.ending = false;</span>
  <span class="s1">// when end() has been called, and returned</span>
  <span class="s1">this.ended = false;</span>
  <span class="s1">// when 'finish' is emitted</span>
  <span class="s1">this.finished = false;</span>

  <span class="s1">// has it been destroyed</span>
  <span class="s1">this.destroyed = false;</span>

  <span class="s1">// should we decode strings into buffers before passing to _write?</span>
  <span class="s1">// this is here so that some node-core streams can optimize string</span>
  <span class="s1">// handling at a lower level.</span>
  <span class="s1">var noDecode = options.decodeStrings === false;</span>
  <span class="s1">this.decodeStrings = !noDecode;</span>

  <span class="s1">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="s1">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="s1">// Everything else in the universe uses 'utf8', though.</span>
  <span class="s1">this.defaultEncoding = options.defaultEncoding || 'utf8';</span>

  <span class="s1">// not an actual buffer we keep track of, but a measurement</span>
  <span class="s1">// of how much we're waiting to get pushed to some underlying</span>
  <span class="s1">// socket or file.</span>
  <span class="s1">this.length = 0;</span>

  <span class="s1">// a flag to see when we're in the middle of a write.</span>
  <span class="s1">this.writing = false;</span>

  <span class="s1">// when true all writes will be buffered until .uncork() call</span>
  <span class="s1">this.corked = 0;</span>

  <span class="s1">// a flag to be able to tell if the onwrite cb is called immediately,</span>
  <span class="s1">// or on a later tick.  We set this to true at first, because any</span>
  <span class="s1">// actions that shouldn't happen until &quot;later&quot; should generally also</span>
  <span class="s1">// not happen before the first write call.</span>
  <span class="s1">this.sync = true;</span>

  <span class="s1">// a flag to know if we're processing previously buffered items, which</span>
  <span class="s1">// may call the _write() callback in the same tick, so that we don't</span>
  <span class="s1">// end up in an overlapped onwrite situation.</span>
  <span class="s1">this.bufferProcessing = false;</span>

  <span class="s1">// the callback that's passed to _write(chunk,cb)</span>
  <span class="s1">this.onwrite = function (er) {</span>
    <span class="s1">onwrite(stream, er);</span>
  <span class="s1">};</span>

  <span class="s1">// the callback that the user supplies to write(chunk,encoding,cb)</span>
  <span class="s1">this.writecb = null;</span>

  <span class="s1">// the amount that is being written when _write is called.</span>
  <span class="s1">this.writelen = 0;</span>

  <span class="s1">this.bufferedRequest = null;</span>
  <span class="s1">this.lastBufferedRequest = null;</span>

  <span class="s1">// number of pending user-supplied write callbacks</span>
  <span class="s1">// this must be 0 before 'finish' can be emitted</span>
  <span class="s1">this.pendingcb = 0;</span>

  <span class="s1">// emit prefinish if the only thing we're waiting for is _write cbs</span>
  <span class="s1">// This is relevant for synchronous Transform streams</span>
  <span class="s1">this.prefinished = false;</span>

  <span class="s1">// True if the error was already emitted and should not be thrown again</span>
  <span class="s1">this.errorEmitted = false;</span>

  <span class="s1">// count buffered requests</span>
  <span class="s1">this.bufferedRequestCount = 0;</span>

  <span class="s1">// allocate the first CorkedRequest, there is always</span>
  <span class="s1">// one allocated and free to use, and we maintain at most two</span>
  <span class="s1">this.corkedRequestsFree = new CorkedRequest(this);</span>
<span class="s1">}</span>

<span class="s1">WritableState.prototype.getBuffer = function getBuffer() {</span>
  <span class="s1">var current = this.bufferedRequest;</span>
  <span class="s1">var out = [];</span>
  <span class="s1">while (current) {</span>
    <span class="s1">out.push(current);</span>
    <span class="s1">current = current.next;</span>
  <span class="s1">}</span>
  <span class="s1">return out;</span>
<span class="s1">};</span>

<span class="s1">(function () {</span>
  <span class="s1">try {</span>
    <span class="s1">Object.defineProperty(WritableState.prototype, 'buffer', {</span>
      <span class="s1">get: internalUtil.deprecate(function () {</span>
        <span class="s1">return this.getBuffer();</span>
      <span class="s1">}, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')</span>
    <span class="s1">});</span>
  <span class="s1">} catch (_) {}</span>
<span class="s1">})();</span>

<span class="s1">// Test _writableState for inheritance to account for Duplex streams,</span>
<span class="s1">// whose prototype chain only points to Readable.</span>
<span class="s1">var realHasInstance;</span>
<span class="s1">if (typeof Symbol === 'function' &amp;&amp; Symbol.hasInstance &amp;&amp; typeof Function.prototype[Symbol.hasInstance] === 'function') {</span>
  <span class="s1">realHasInstance = Function.prototype[Symbol.hasInstance];</span>
  <span class="s1">Object.defineProperty(Writable, Symbol.hasInstance, {</span>
    <span class="s1">value: function (object) {</span>
      <span class="s1">if (realHasInstance.call(this, object)) return true;</span>
      <span class="s1">if (this !== Writable) return false;</span>

      <span class="s1">return object &amp;&amp; object._writableState instanceof WritableState;</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
<span class="s1">} else {</span>
  <span class="s1">realHasInstance = function (object) {</span>
    <span class="s1">return object instanceof this;</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">function Writable(options) {</span>
  <span class="s1">Duplex = Duplex || require('./_stream_duplex');</span>

  <span class="s1">// Writable ctor is applied to Duplexes, too.</span>
  <span class="s1">// `realHasInstance` is necessary because using plain `instanceof`</span>
  <span class="s1">// would return false, as no `_writableState` property is attached.</span>

  <span class="s1">// Trying to use the custom `instanceof` for Writable here will also break the</span>
  <span class="s1">// Node.js LazyTransform implementation, which has a non-trivial getter for</span>
  <span class="s1">// `_writableState` that would lead to infinite recursion.</span>
  <span class="s1">if (!realHasInstance.call(Writable, this) &amp;&amp; !(this instanceof Duplex)) {</span>
    <span class="s1">return new Writable(options);</span>
  <span class="s1">}</span>

  <span class="s1">this._writableState = new WritableState(options, this);</span>

  <span class="s1">// legacy.</span>
  <span class="s1">this.writable = true;</span>

  <span class="s1">if (options) {</span>
    <span class="s1">if (typeof options.write === 'function') this._write = options.write;</span>

    <span class="s1">if (typeof options.writev === 'function') this._writev = options.writev;</span>

    <span class="s1">if (typeof options.destroy === 'function') this._destroy = options.destroy;</span>

    <span class="s1">if (typeof options.final === 'function') this._final = options.final;</span>
  <span class="s1">}</span>

  <span class="s1">Stream.call(this);</span>
<span class="s1">}</span>

<span class="s1">// Otherwise people can pipe Writable streams, which is just wrong.</span>
<span class="s1">Writable.prototype.pipe = function () {</span>
  <span class="s1">this.emit('error', new Error('Cannot pipe, not readable'));</span>
<span class="s1">};</span>

<span class="s1">function writeAfterEnd(stream, cb) {</span>
  <span class="s1">var er = new Error('write after end');</span>
  <span class="s1">// TODO: defer error events consistently everywhere, not just the cb</span>
  <span class="s1">stream.emit('error', er);</span>
  <span class="s1">pna.nextTick(cb, er);</span>
<span class="s1">}</span>

<span class="s1">// Checks that a user-supplied chunk is valid, especially for the particular</span>
<span class="s1">// mode the stream is in. Currently this means that `null` is never accepted</span>
<span class="s1">// and undefined/non-string values are only allowed in object mode.</span>
<span class="s1">function validChunk(stream, state, chunk, cb) {</span>
  <span class="s1">var valid = true;</span>
  <span class="s1">var er = false;</span>

  <span class="s1">if (chunk === null) {</span>
    <span class="s1">er = new TypeError('May not write null values to stream');</span>
  <span class="s1">} else if (typeof chunk !== 'string' &amp;&amp; chunk !== undefined &amp;&amp; !state.objectMode) {</span>
    <span class="s1">er = new TypeError('Invalid non-string/buffer chunk');</span>
  <span class="s1">}</span>
  <span class="s1">if (er) {</span>
    <span class="s1">stream.emit('error', er);</span>
    <span class="s1">pna.nextTick(cb, er);</span>
    <span class="s1">valid = false;</span>
  <span class="s1">}</span>
  <span class="s1">return valid;</span>
<span class="s1">}</span>

<span class="s1">Writable.prototype.write = function (chunk, encoding, cb) {</span>
  <span class="s1">var state = this._writableState;</span>
  <span class="s1">var ret = false;</span>
  <span class="s1">var isBuf = !state.objectMode &amp;&amp; _isUint8Array(chunk);</span>

  <span class="s1">if (isBuf &amp;&amp; !Buffer.isBuffer(chunk)) {</span>
    <span class="s1">chunk = _uint8ArrayToBuffer(chunk);</span>
  <span class="s1">}</span>

  <span class="s1">if (typeof encoding === 'function') {</span>
    <span class="s1">cb = encoding;</span>
    <span class="s1">encoding = null;</span>
  <span class="s1">}</span>

  <span class="s1">if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;</span>

  <span class="s1">if (typeof cb !== 'function') cb = nop;</span>

  <span class="s1">if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {</span>
    <span class="s1">state.pendingcb++;</span>
    <span class="s1">ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);</span>
  <span class="s1">}</span>

  <span class="s1">return ret;</span>
<span class="s1">};</span>

<span class="s1">Writable.prototype.cork = function () {</span>
  <span class="s1">var state = this._writableState;</span>

  <span class="s1">state.corked++;</span>
<span class="s1">};</span>

<span class="s1">Writable.prototype.uncork = function () {</span>
  <span class="s1">var state = this._writableState;</span>

  <span class="s1">if (state.corked) {</span>
    <span class="s1">state.corked--;</span>

    <span class="s1">if (!state.writing &amp;&amp; !state.corked &amp;&amp; !state.finished &amp;&amp; !state.bufferProcessing &amp;&amp; state.bufferedRequest) clearBuffer(this, state);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {</span>
  <span class="s1">// node::ParseEncoding() requires lower case.</span>
  <span class="s1">if (typeof encoding === 'string') encoding = encoding.toLowerCase();</span>
  <span class="s1">if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) &gt; -1)) throw new TypeError('Unknown encoding: ' + encoding);</span>
  <span class="s1">this._writableState.defaultEncoding = encoding;</span>
  <span class="s1">return this;</span>
<span class="s1">};</span>

<span class="s1">function decodeChunk(state, chunk, encoding) {</span>
  <span class="s1">if (!state.objectMode &amp;&amp; state.decodeStrings !== false &amp;&amp; typeof chunk === 'string') {</span>
    <span class="s1">chunk = Buffer.from(chunk, encoding);</span>
  <span class="s1">}</span>
  <span class="s1">return chunk;</span>
<span class="s1">}</span>

<span class="s1">Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {</span>
  <span class="s1">// making it explicit this property is not enumerable</span>
  <span class="s1">// because otherwise some prototype manipulation in</span>
  <span class="s1">// userland will fail</span>
  <span class="s1">enumerable: false,</span>
  <span class="s1">get: function () {</span>
    <span class="s1">return this._writableState.highWaterMark;</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">// if we're already writing something, then just put this</span>
<span class="s1">// in the queue, and wait our turn.  Otherwise, call _write</span>
<span class="s1">// If we return false, then we need a drain event, so set that flag.</span>
<span class="s1">function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {</span>
  <span class="s1">if (!isBuf) {</span>
    <span class="s1">var newChunk = decodeChunk(state, chunk, encoding);</span>
    <span class="s1">if (chunk !== newChunk) {</span>
      <span class="s1">isBuf = true;</span>
      <span class="s1">encoding = 'buffer';</span>
      <span class="s1">chunk = newChunk;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">var len = state.objectMode ? 1 : chunk.length;</span>

  <span class="s1">state.length += len;</span>

  <span class="s1">var ret = state.length &lt; state.highWaterMark;</span>
  <span class="s1">// we must ensure that previous needDrain will not be reset to false.</span>
  <span class="s1">if (!ret) state.needDrain = true;</span>

  <span class="s1">if (state.writing || state.corked) {</span>
    <span class="s1">var last = state.lastBufferedRequest;</span>
    <span class="s1">state.lastBufferedRequest = {</span>
      <span class="s1">chunk: chunk,</span>
      <span class="s1">encoding: encoding,</span>
      <span class="s1">isBuf: isBuf,</span>
      <span class="s1">callback: cb,</span>
      <span class="s1">next: null</span>
    <span class="s1">};</span>
    <span class="s1">if (last) {</span>
      <span class="s1">last.next = state.lastBufferedRequest;</span>
    <span class="s1">} else {</span>
      <span class="s1">state.bufferedRequest = state.lastBufferedRequest;</span>
    <span class="s1">}</span>
    <span class="s1">state.bufferedRequestCount += 1;</span>
  <span class="s1">} else {</span>
    <span class="s1">doWrite(stream, state, false, len, chunk, encoding, cb);</span>
  <span class="s1">}</span>

  <span class="s1">return ret;</span>
<span class="s1">}</span>

<span class="s1">function doWrite(stream, state, writev, len, chunk, encoding, cb) {</span>
  <span class="s1">state.writelen = len;</span>
  <span class="s1">state.writecb = cb;</span>
  <span class="s1">state.writing = true;</span>
  <span class="s1">state.sync = true;</span>
  <span class="s1">if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);</span>
  <span class="s1">state.sync = false;</span>
<span class="s1">}</span>

<span class="s1">function onwriteError(stream, state, sync, er, cb) {</span>
  <span class="s1">--state.pendingcb;</span>

  <span class="s1">if (sync) {</span>
    <span class="s1">// defer the callback if we are being called synchronously</span>
    <span class="s1">// to avoid piling up things on the stack</span>
    <span class="s1">pna.nextTick(cb, er);</span>
    <span class="s1">// this can emit finish, and it will always happen</span>
    <span class="s1">// after error</span>
    <span class="s1">pna.nextTick(finishMaybe, stream, state);</span>
    <span class="s1">stream._writableState.errorEmitted = true;</span>
    <span class="s1">stream.emit('error', er);</span>
  <span class="s1">} else {</span>
    <span class="s1">// the caller expect this to happen before if</span>
    <span class="s1">// it is async</span>
    <span class="s1">cb(er);</span>
    <span class="s1">stream._writableState.errorEmitted = true;</span>
    <span class="s1">stream.emit('error', er);</span>
    <span class="s1">// this can emit finish, but finish must</span>
    <span class="s1">// always follow error</span>
    <span class="s1">finishMaybe(stream, state);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function onwriteStateUpdate(state) {</span>
  <span class="s1">state.writing = false;</span>
  <span class="s1">state.writecb = null;</span>
  <span class="s1">state.length -= state.writelen;</span>
  <span class="s1">state.writelen = 0;</span>
<span class="s1">}</span>

<span class="s1">function onwrite(stream, er) {</span>
  <span class="s1">var state = stream._writableState;</span>
  <span class="s1">var sync = state.sync;</span>
  <span class="s1">var cb = state.writecb;</span>

  <span class="s1">onwriteStateUpdate(state);</span>

  <span class="s1">if (er) onwriteError(stream, state, sync, er, cb);else {</span>
    <span class="s1">// Check if we're actually ready to finish, but don't emit yet</span>
    <span class="s1">var finished = needFinish(state);</span>

    <span class="s1">if (!finished &amp;&amp; !state.corked &amp;&amp; !state.bufferProcessing &amp;&amp; state.bufferedRequest) {</span>
      <span class="s1">clearBuffer(stream, state);</span>
    <span class="s1">}</span>

    <span class="s1">if (sync) {</span>
      <span class="s1">/*&lt;replacement&gt;*/</span>
      <span class="s1">asyncWrite(afterWrite, stream, state, finished, cb);</span>
      <span class="s1">/*&lt;/replacement&gt;*/</span>
    <span class="s1">} else {</span>
      <span class="s1">afterWrite(stream, state, finished, cb);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function afterWrite(stream, state, finished, cb) {</span>
  <span class="s1">if (!finished) onwriteDrain(stream, state);</span>
  <span class="s1">state.pendingcb--;</span>
  <span class="s1">cb();</span>
  <span class="s1">finishMaybe(stream, state);</span>
<span class="s1">}</span>

<span class="s1">// Must force callback to be called on nextTick, so that we don't</span>
<span class="s1">// emit 'drain' before the write() consumer gets the 'false' return</span>
<span class="s1">// value, and has a chance to attach a 'drain' listener.</span>
<span class="s1">function onwriteDrain(stream, state) {</span>
  <span class="s1">if (state.length === 0 &amp;&amp; state.needDrain) {</span>
    <span class="s1">state.needDrain = false;</span>
    <span class="s1">stream.emit('drain');</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">// if there's something in the buffer waiting, then process it</span>
<span class="s1">function clearBuffer(stream, state) {</span>
  <span class="s1">state.bufferProcessing = true;</span>
  <span class="s1">var entry = state.bufferedRequest;</span>

  <span class="s1">if (stream._writev &amp;&amp; entry &amp;&amp; entry.next) {</span>
    <span class="s1">// Fast case, write everything using _writev()</span>
    <span class="s1">var l = state.bufferedRequestCount;</span>
    <span class="s1">var buffer = new Array(l);</span>
    <span class="s1">var holder = state.corkedRequestsFree;</span>
    <span class="s1">holder.entry = entry;</span>

    <span class="s1">var count = 0;</span>
    <span class="s1">var allBuffers = true;</span>
    <span class="s1">while (entry) {</span>
      <span class="s1">buffer[count] = entry;</span>
      <span class="s1">if (!entry.isBuf) allBuffers = false;</span>
      <span class="s1">entry = entry.next;</span>
      <span class="s1">count += 1;</span>
    <span class="s1">}</span>
    <span class="s1">buffer.allBuffers = allBuffers;</span>

    <span class="s1">doWrite(stream, state, true, state.length, buffer, '', holder.finish);</span>

    <span class="s1">// doWrite is almost always async, defer these to save a bit of time</span>
    <span class="s1">// as the hot path ends with doWrite</span>
    <span class="s1">state.pendingcb++;</span>
    <span class="s1">state.lastBufferedRequest = null;</span>
    <span class="s1">if (holder.next) {</span>
      <span class="s1">state.corkedRequestsFree = holder.next;</span>
      <span class="s1">holder.next = null;</span>
    <span class="s1">} else {</span>
      <span class="s1">state.corkedRequestsFree = new CorkedRequest(state);</span>
    <span class="s1">}</span>
    <span class="s1">state.bufferedRequestCount = 0;</span>
  <span class="s1">} else {</span>
    <span class="s1">// Slow case, write chunks one-by-one</span>
    <span class="s1">while (entry) {</span>
      <span class="s1">var chunk = entry.chunk;</span>
      <span class="s1">var encoding = entry.encoding;</span>
      <span class="s1">var cb = entry.callback;</span>
      <span class="s1">var len = state.objectMode ? 1 : chunk.length;</span>

      <span class="s1">doWrite(stream, state, false, len, chunk, encoding, cb);</span>
      <span class="s1">entry = entry.next;</span>
      <span class="s1">state.bufferedRequestCount--;</span>
      <span class="s1">// if we didn't call the onwrite immediately, then</span>
      <span class="s1">// it means that we need to wait until it does.</span>
      <span class="s1">// also, that means that the chunk and cb are currently</span>
      <span class="s1">// being processed, so move the buffer counter past them.</span>
      <span class="s1">if (state.writing) {</span>
        <span class="s1">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">if (entry === null) state.lastBufferedRequest = null;</span>
  <span class="s1">}</span>

  <span class="s1">state.bufferedRequest = entry;</span>
  <span class="s1">state.bufferProcessing = false;</span>
<span class="s1">}</span>

<span class="s1">Writable.prototype._write = function (chunk, encoding, cb) {</span>
  <span class="s1">cb(new Error('_write() is not implemented'));</span>
<span class="s1">};</span>

<span class="s1">Writable.prototype._writev = null;</span>

<span class="s1">Writable.prototype.end = function (chunk, encoding, cb) {</span>
  <span class="s1">var state = this._writableState;</span>

  <span class="s1">if (typeof chunk === 'function') {</span>
    <span class="s1">cb = chunk;</span>
    <span class="s1">chunk = null;</span>
    <span class="s1">encoding = null;</span>
  <span class="s1">} else if (typeof encoding === 'function') {</span>
    <span class="s1">cb = encoding;</span>
    <span class="s1">encoding = null;</span>
  <span class="s1">}</span>

  <span class="s1">if (chunk !== null &amp;&amp; chunk !== undefined) this.write(chunk, encoding);</span>

  <span class="s1">// .end() fully uncorks</span>
  <span class="s1">if (state.corked) {</span>
    <span class="s1">state.corked = 1;</span>
    <span class="s1">this.uncork();</span>
  <span class="s1">}</span>

  <span class="s1">// ignore unnecessary end() calls.</span>
  <span class="s1">if (!state.ending &amp;&amp; !state.finished) endWritable(this, state, cb);</span>
<span class="s1">};</span>

<span class="s1">function needFinish(state) {</span>
  <span class="s1">return state.ending &amp;&amp; state.length === 0 &amp;&amp; state.bufferedRequest === null &amp;&amp; !state.finished &amp;&amp; !state.writing;</span>
<span class="s1">}</span>
<span class="s1">function callFinal(stream, state) {</span>
  <span class="s1">stream._final(function (err) {</span>
    <span class="s1">state.pendingcb--;</span>
    <span class="s1">if (err) {</span>
      <span class="s1">stream.emit('error', err);</span>
    <span class="s1">}</span>
    <span class="s1">state.prefinished = true;</span>
    <span class="s1">stream.emit('prefinish');</span>
    <span class="s1">finishMaybe(stream, state);</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">function prefinish(stream, state) {</span>
  <span class="s1">if (!state.prefinished &amp;&amp; !state.finalCalled) {</span>
    <span class="s1">if (typeof stream._final === 'function') {</span>
      <span class="s1">state.pendingcb++;</span>
      <span class="s1">state.finalCalled = true;</span>
      <span class="s1">pna.nextTick(callFinal, stream, state);</span>
    <span class="s1">} else {</span>
      <span class="s1">state.prefinished = true;</span>
      <span class="s1">stream.emit('prefinish');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function finishMaybe(stream, state) {</span>
  <span class="s1">var need = needFinish(state);</span>
  <span class="s1">if (need) {</span>
    <span class="s1">prefinish(stream, state);</span>
    <span class="s1">if (state.pendingcb === 0) {</span>
      <span class="s1">state.finished = true;</span>
      <span class="s1">stream.emit('finish');</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">return need;</span>
<span class="s1">}</span>

<span class="s1">function endWritable(stream, state, cb) {</span>
  <span class="s1">state.ending = true;</span>
  <span class="s1">finishMaybe(stream, state);</span>
  <span class="s1">if (cb) {</span>
    <span class="s1">if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);</span>
  <span class="s1">}</span>
  <span class="s1">state.ended = true;</span>
  <span class="s1">stream.writable = false;</span>
<span class="s1">}</span>

<span class="s1">function onCorkedFinish(corkReq, state, err) {</span>
  <span class="s1">var entry = corkReq.entry;</span>
  <span class="s1">corkReq.entry = null;</span>
  <span class="s1">while (entry) {</span>
    <span class="s1">var cb = entry.callback;</span>
    <span class="s1">state.pendingcb--;</span>
    <span class="s1">cb(err);</span>
    <span class="s1">entry = entry.next;</span>
  <span class="s1">}</span>
  <span class="s1">if (state.corkedRequestsFree) {</span>
    <span class="s1">state.corkedRequestsFree.next = corkReq;</span>
  <span class="s1">} else {</span>
    <span class="s1">state.corkedRequestsFree = corkReq;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Object.defineProperty(Writable.prototype, 'destroyed', {</span>
  <span class="s1">get: function () {</span>
    <span class="s1">if (this._writableState === undefined) {</span>
      <span class="s1">return false;</span>
    <span class="s1">}</span>
    <span class="s1">return this._writableState.destroyed;</span>
  <span class="s1">},</span>
  <span class="s1">set: function (value) {</span>
    <span class="s1">// we ignore the value if the stream</span>
    <span class="s1">// has not been initialized yet</span>
    <span class="s1">if (!this._writableState) {</span>
      <span class="s1">return;</span>
    <span class="s1">}</span>

    <span class="s1">// backward compatibility, the user is explicitly</span>
    <span class="s1">// managing destroyed</span>
    <span class="s1">this._writableState.destroyed = value;</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">Writable.prototype.destroy = destroyImpl.destroy;</span>
<span class="s1">Writable.prototype._undestroy = destroyImpl.undestroy;</span>
<span class="s1">Writable.prototype._destroy = function (err, cb) {</span>
  <span class="s1">this.end();</span>
  <span class="s1">cb(err);</span>
<span class="s1">};</span>
<span class="s1">}).call(this)}).call(this,require('_process'),typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {},require(&quot;timers&quot;).setImmediate)</span>

<span class="s1">},{&quot;./_stream_duplex&quot;:81,&quot;./internal/streams/destroy&quot;:87,&quot;./internal/streams/stream&quot;:88,&quot;_process&quot;:79,&quot;core-util-is&quot;:13,&quot;inherits&quot;:47,&quot;process-nextick-args&quot;:78,&quot;safe-buffer&quot;:89,&quot;timers&quot;:111,&quot;util-deprecate&quot;:112}],86:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }</span>

<span class="s1">var Buffer = require('safe-buffer').Buffer;</span>
<span class="s1">var util = require('util');</span>

<span class="s1">function copyBuffer(src, target, offset) {</span>
  <span class="s1">src.copy(target, offset);</span>
<span class="s1">}</span>

<span class="s1">module.exports = function () {</span>
  <span class="s1">function BufferList() {</span>
    <span class="s1">_classCallCheck(this, BufferList);</span>

    <span class="s1">this.head = null;</span>
    <span class="s1">this.tail = null;</span>
    <span class="s1">this.length = 0;</span>
  <span class="s1">}</span>

  <span class="s1">BufferList.prototype.push = function push(v) {</span>
    <span class="s1">var entry = { data: v, next: null };</span>
    <span class="s1">if (this.length &gt; 0) this.tail.next = entry;else this.head = entry;</span>
    <span class="s1">this.tail = entry;</span>
    <span class="s1">++this.length;</span>
  <span class="s1">};</span>

  <span class="s1">BufferList.prototype.unshift = function unshift(v) {</span>
    <span class="s1">var entry = { data: v, next: this.head };</span>
    <span class="s1">if (this.length === 0) this.tail = entry;</span>
    <span class="s1">this.head = entry;</span>
    <span class="s1">++this.length;</span>
  <span class="s1">};</span>

  <span class="s1">BufferList.prototype.shift = function shift() {</span>
    <span class="s1">if (this.length === 0) return;</span>
    <span class="s1">var ret = this.head.data;</span>
    <span class="s1">if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;</span>
    <span class="s1">--this.length;</span>
    <span class="s1">return ret;</span>
  <span class="s1">};</span>

  <span class="s1">BufferList.prototype.clear = function clear() {</span>
    <span class="s1">this.head = this.tail = null;</span>
    <span class="s1">this.length = 0;</span>
  <span class="s1">};</span>

  <span class="s1">BufferList.prototype.join = function join(s) {</span>
    <span class="s1">if (this.length === 0) return '';</span>
    <span class="s1">var p = this.head;</span>
    <span class="s1">var ret = '' + p.data;</span>
    <span class="s1">while (p = p.next) {</span>
      <span class="s1">ret += s + p.data;</span>
    <span class="s1">}return ret;</span>
  <span class="s1">};</span>

  <span class="s1">BufferList.prototype.concat = function concat(n) {</span>
    <span class="s1">if (this.length === 0) return Buffer.alloc(0);</span>
    <span class="s1">if (this.length === 1) return this.head.data;</span>
    <span class="s1">var ret = Buffer.allocUnsafe(n &gt;&gt;&gt; 0);</span>
    <span class="s1">var p = this.head;</span>
    <span class="s1">var i = 0;</span>
    <span class="s1">while (p) {</span>
      <span class="s1">copyBuffer(p.data, ret, i);</span>
      <span class="s1">i += p.data.length;</span>
      <span class="s1">p = p.next;</span>
    <span class="s1">}</span>
    <span class="s1">return ret;</span>
  <span class="s1">};</span>

  <span class="s1">return BufferList;</span>
<span class="s1">}();</span>

<span class="s1">if (util &amp;&amp; util.inspect &amp;&amp; util.inspect.custom) {</span>
  <span class="s1">module.exports.prototype[util.inspect.custom] = function () {</span>
    <span class="s1">var obj = util.inspect({ length: this.length });</span>
    <span class="s1">return this.constructor.name + ' ' + obj;</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">},{&quot;safe-buffer&quot;:89,&quot;util&quot;:9}],87:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">/*&lt;replacement&gt;*/</span>

<span class="s1">var pna = require('process-nextick-args');</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">// undocumented cb() API, needed for core, not for public API</span>
<span class="s1">function destroy(err, cb) {</span>
  <span class="s1">var _this = this;</span>

  <span class="s1">var readableDestroyed = this._readableState &amp;&amp; this._readableState.destroyed;</span>
  <span class="s1">var writableDestroyed = this._writableState &amp;&amp; this._writableState.destroyed;</span>

  <span class="s1">if (readableDestroyed || writableDestroyed) {</span>
    <span class="s1">if (cb) {</span>
      <span class="s1">cb(err);</span>
    <span class="s1">} else if (err &amp;&amp; (!this._writableState || !this._writableState.errorEmitted)) {</span>
      <span class="s1">pna.nextTick(emitErrorNT, this, err);</span>
    <span class="s1">}</span>
    <span class="s1">return this;</span>
  <span class="s1">}</span>

  <span class="s1">// we set destroyed to true before firing error callbacks in order</span>
  <span class="s1">// to make it re-entrance safe in case destroy() is called within callbacks</span>

  <span class="s1">if (this._readableState) {</span>
    <span class="s1">this._readableState.destroyed = true;</span>
  <span class="s1">}</span>

  <span class="s1">// if this is a duplex stream mark the writable part as destroyed as well</span>
  <span class="s1">if (this._writableState) {</span>
    <span class="s1">this._writableState.destroyed = true;</span>
  <span class="s1">}</span>

  <span class="s1">this._destroy(err || null, function (err) {</span>
    <span class="s1">if (!cb &amp;&amp; err) {</span>
      <span class="s1">pna.nextTick(emitErrorNT, _this, err);</span>
      <span class="s1">if (_this._writableState) {</span>
        <span class="s1">_this._writableState.errorEmitted = true;</span>
      <span class="s1">}</span>
    <span class="s1">} else if (cb) {</span>
      <span class="s1">cb(err);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s1">return this;</span>
<span class="s1">}</span>

<span class="s1">function undestroy() {</span>
  <span class="s1">if (this._readableState) {</span>
    <span class="s1">this._readableState.destroyed = false;</span>
    <span class="s1">this._readableState.reading = false;</span>
    <span class="s1">this._readableState.ended = false;</span>
    <span class="s1">this._readableState.endEmitted = false;</span>
  <span class="s1">}</span>

  <span class="s1">if (this._writableState) {</span>
    <span class="s1">this._writableState.destroyed = false;</span>
    <span class="s1">this._writableState.ended = false;</span>
    <span class="s1">this._writableState.ending = false;</span>
    <span class="s1">this._writableState.finished = false;</span>
    <span class="s1">this._writableState.errorEmitted = false;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">function emitErrorNT(self, err) {</span>
  <span class="s1">self.emit('error', err);</span>
<span class="s1">}</span>

<span class="s1">module.exports = {</span>
  <span class="s1">destroy: destroy,</span>
  <span class="s1">undestroy: undestroy</span>
<span class="s1">};</span>
<span class="s1">},{&quot;process-nextick-args&quot;:78}],88:[function(require,module,exports){</span>
<span class="s1">module.exports = require('events').EventEmitter;</span>

<span class="s1">},{&quot;events&quot;:33}],89:[function(require,module,exports){</span>
<span class="s1">/* eslint-disable node/no-deprecated-api */</span>
<span class="s1">var buffer = require('buffer')</span>
<span class="s1">var Buffer = buffer.Buffer</span>

<span class="s1">// alternative to using Object.keys for old browsers</span>
<span class="s1">function copyProps (src, dst) {</span>
  <span class="s1">for (var key in src) {</span>
    <span class="s1">dst[key] = src[key]</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">if (Buffer.from &amp;&amp; Buffer.alloc &amp;&amp; Buffer.allocUnsafe &amp;&amp; Buffer.allocUnsafeSlow) {</span>
  <span class="s1">module.exports = buffer</span>
<span class="s1">} else {</span>
  <span class="s1">// Copy properties from require('buffer')</span>
  <span class="s1">copyProps(buffer, exports)</span>
  <span class="s1">exports.Buffer = SafeBuffer</span>
<span class="s1">}</span>

<span class="s1">function SafeBuffer (arg, encodingOrOffset, length) {</span>
  <span class="s1">return Buffer(arg, encodingOrOffset, length)</span>
<span class="s1">}</span>

<span class="s1">// Copy static methods from Buffer</span>
<span class="s1">copyProps(Buffer, SafeBuffer)</span>

<span class="s1">SafeBuffer.from = function (arg, encodingOrOffset, length) {</span>
  <span class="s1">if (typeof arg === 'number') {</span>
    <span class="s1">throw new TypeError('Argument must not be a number')</span>
  <span class="s1">}</span>
  <span class="s1">return Buffer(arg, encodingOrOffset, length)</span>
<span class="s1">}</span>

<span class="s1">SafeBuffer.alloc = function (size, fill, encoding) {</span>
  <span class="s1">if (typeof size !== 'number') {</span>
    <span class="s1">throw new TypeError('Argument must be a number')</span>
  <span class="s1">}</span>
  <span class="s1">var buf = Buffer(size)</span>
  <span class="s1">if (fill !== undefined) {</span>
    <span class="s1">if (typeof encoding === 'string') {</span>
      <span class="s1">buf.fill(fill, encoding)</span>
    <span class="s1">} else {</span>
      <span class="s1">buf.fill(fill)</span>
    <span class="s1">}</span>
  <span class="s1">} else {</span>
    <span class="s1">buf.fill(0)</span>
  <span class="s1">}</span>
  <span class="s1">return buf</span>
<span class="s1">}</span>

<span class="s1">SafeBuffer.allocUnsafe = function (size) {</span>
  <span class="s1">if (typeof size !== 'number') {</span>
    <span class="s1">throw new TypeError('Argument must be a number')</span>
  <span class="s1">}</span>
  <span class="s1">return Buffer(size)</span>
<span class="s1">}</span>

<span class="s1">SafeBuffer.allocUnsafeSlow = function (size) {</span>
  <span class="s1">if (typeof size !== 'number') {</span>
    <span class="s1">throw new TypeError('Argument must be a number')</span>
  <span class="s1">}</span>
  <span class="s1">return buffer.SlowBuffer(size)</span>
<span class="s1">}</span>

<span class="s1">},{&quot;buffer&quot;:10}],90:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">'use strict';</span>

<span class="s1">/*&lt;replacement&gt;*/</span>

<span class="s1">var Buffer = require('safe-buffer').Buffer;</span>
<span class="s1">/*&lt;/replacement&gt;*/</span>

<span class="s1">var isEncoding = Buffer.isEncoding || function (encoding) {</span>
  <span class="s1">encoding = '' + encoding;</span>
  <span class="s1">switch (encoding &amp;&amp; encoding.toLowerCase()) {</span>
    <span class="s1">case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':</span>
      <span class="s1">return true;</span>
    <span class="s1">default:</span>
      <span class="s1">return false;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">function _normalizeEncoding(enc) {</span>
  <span class="s1">if (!enc) return 'utf8';</span>
  <span class="s1">var retried;</span>
  <span class="s1">while (true) {</span>
    <span class="s1">switch (enc) {</span>
      <span class="s1">case 'utf8':</span>
      <span class="s1">case 'utf-8':</span>
        <span class="s1">return 'utf8';</span>
      <span class="s1">case 'ucs2':</span>
      <span class="s1">case 'ucs-2':</span>
      <span class="s1">case 'utf16le':</span>
      <span class="s1">case 'utf-16le':</span>
        <span class="s1">return 'utf16le';</span>
      <span class="s1">case 'latin1':</span>
      <span class="s1">case 'binary':</span>
        <span class="s1">return 'latin1';</span>
      <span class="s1">case 'base64':</span>
      <span class="s1">case 'ascii':</span>
      <span class="s1">case 'hex':</span>
        <span class="s1">return enc;</span>
      <span class="s1">default:</span>
        <span class="s1">if (retried) return; // undefined</span>
        <span class="s1">enc = ('' + enc).toLowerCase();</span>
        <span class="s1">retried = true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">// Do not cache `Buffer.isEncoding` when checking encoding names as some</span>
<span class="s1">// modules monkey-patch it to support additional encodings</span>
<span class="s1">function normalizeEncoding(enc) {</span>
  <span class="s1">var nenc = _normalizeEncoding(enc);</span>
  <span class="s1">if (typeof nenc !== 'string' &amp;&amp; (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);</span>
  <span class="s1">return nenc || enc;</span>
<span class="s1">}</span>

<span class="s1">// StringDecoder provides an interface for efficiently splitting a series of</span>
<span class="s1">// buffers into a series of JS strings without breaking apart multi-byte</span>
<span class="s1">// characters.</span>
<span class="s1">exports.StringDecoder = StringDecoder;</span>
<span class="s1">function StringDecoder(encoding) {</span>
  <span class="s1">this.encoding = normalizeEncoding(encoding);</span>
  <span class="s1">var nb;</span>
  <span class="s1">switch (this.encoding) {</span>
    <span class="s1">case 'utf16le':</span>
      <span class="s1">this.text = utf16Text;</span>
      <span class="s1">this.end = utf16End;</span>
      <span class="s1">nb = 4;</span>
      <span class="s1">break;</span>
    <span class="s1">case 'utf8':</span>
      <span class="s1">this.fillLast = utf8FillLast;</span>
      <span class="s1">nb = 4;</span>
      <span class="s1">break;</span>
    <span class="s1">case 'base64':</span>
      <span class="s1">this.text = base64Text;</span>
      <span class="s1">this.end = base64End;</span>
      <span class="s1">nb = 3;</span>
      <span class="s1">break;</span>
    <span class="s1">default:</span>
      <span class="s1">this.write = simpleWrite;</span>
      <span class="s1">this.end = simpleEnd;</span>
      <span class="s1">return;</span>
  <span class="s1">}</span>
  <span class="s1">this.lastNeed = 0;</span>
  <span class="s1">this.lastTotal = 0;</span>
  <span class="s1">this.lastChar = Buffer.allocUnsafe(nb);</span>
<span class="s1">}</span>

<span class="s1">StringDecoder.prototype.write = function (buf) {</span>
  <span class="s1">if (buf.length === 0) return '';</span>
  <span class="s1">var r;</span>
  <span class="s1">var i;</span>
  <span class="s1">if (this.lastNeed) {</span>
    <span class="s1">r = this.fillLast(buf);</span>
    <span class="s1">if (r === undefined) return '';</span>
    <span class="s1">i = this.lastNeed;</span>
    <span class="s1">this.lastNeed = 0;</span>
  <span class="s1">} else {</span>
    <span class="s1">i = 0;</span>
  <span class="s1">}</span>
  <span class="s1">if (i &lt; buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);</span>
  <span class="s1">return r || '';</span>
<span class="s1">};</span>

<span class="s1">StringDecoder.prototype.end = utf8End;</span>

<span class="s1">// Returns only complete characters in a Buffer</span>
<span class="s1">StringDecoder.prototype.text = utf8Text;</span>

<span class="s1">// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer</span>
<span class="s1">StringDecoder.prototype.fillLast = function (buf) {</span>
  <span class="s1">if (this.lastNeed &lt;= buf.length) {</span>
    <span class="s1">buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);</span>
    <span class="s1">return this.lastChar.toString(this.encoding, 0, this.lastTotal);</span>
  <span class="s1">}</span>
  <span class="s1">buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);</span>
  <span class="s1">this.lastNeed -= buf.length;</span>
<span class="s1">};</span>

<span class="s1">// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a</span>
<span class="s1">// continuation byte. If an invalid byte is detected, -2 is returned.</span>
<span class="s1">function utf8CheckByte(byte) {</span>
  <span class="s1">if (byte &lt;= 0x7F) return 0;else if (byte &gt;&gt; 5 === 0x06) return 2;else if (byte &gt;&gt; 4 === 0x0E) return 3;else if (byte &gt;&gt; 3 === 0x1E) return 4;</span>
  <span class="s1">return byte &gt;&gt; 6 === 0x02 ? -1 : -2;</span>
<span class="s1">}</span>

<span class="s1">// Checks at most 3 bytes at the end of a Buffer in order to detect an</span>
<span class="s1">// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)</span>
<span class="s1">// needed to complete the UTF-8 character (if applicable) are returned.</span>
<span class="s1">function utf8CheckIncomplete(self, buf, i) {</span>
  <span class="s1">var j = buf.length - 1;</span>
  <span class="s1">if (j &lt; i) return 0;</span>
  <span class="s1">var nb = utf8CheckByte(buf[j]);</span>
  <span class="s1">if (nb &gt;= 0) {</span>
    <span class="s1">if (nb &gt; 0) self.lastNeed = nb - 1;</span>
    <span class="s1">return nb;</span>
  <span class="s1">}</span>
  <span class="s1">if (--j &lt; i || nb === -2) return 0;</span>
  <span class="s1">nb = utf8CheckByte(buf[j]);</span>
  <span class="s1">if (nb &gt;= 0) {</span>
    <span class="s1">if (nb &gt; 0) self.lastNeed = nb - 2;</span>
    <span class="s1">return nb;</span>
  <span class="s1">}</span>
  <span class="s1">if (--j &lt; i || nb === -2) return 0;</span>
  <span class="s1">nb = utf8CheckByte(buf[j]);</span>
  <span class="s1">if (nb &gt;= 0) {</span>
    <span class="s1">if (nb &gt; 0) {</span>
      <span class="s1">if (nb === 2) nb = 0;else self.lastNeed = nb - 3;</span>
    <span class="s1">}</span>
    <span class="s1">return nb;</span>
  <span class="s1">}</span>
  <span class="s1">return 0;</span>
<span class="s1">}</span>

<span class="s1">// Validates as many continuation bytes for a multi-byte UTF-8 character as</span>
<span class="s1">// needed or are available. If we see a non-continuation byte where we expect</span>
<span class="s1">// one, we &quot;replace&quot; the validated continuation bytes we've seen so far with</span>
<span class="s1">// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding</span>
<span class="s1">// behavior. The continuation byte check is included three times in the case</span>
<span class="s1">// where all of the continuation bytes for a character exist in the same buffer.</span>
<span class="s1">// It is also done this way as a slight performance increase instead of using a</span>
<span class="s1">// loop.</span>
<span class="s1">function utf8CheckExtraBytes(self, buf, p) {</span>
  <span class="s1">if ((buf[0] &amp; 0xC0) !== 0x80) {</span>
    <span class="s1">self.lastNeed = 0;</span>
    <span class="s1">return '\ufffd';</span>
  <span class="s1">}</span>
  <span class="s1">if (self.lastNeed &gt; 1 &amp;&amp; buf.length &gt; 1) {</span>
    <span class="s1">if ((buf[1] &amp; 0xC0) !== 0x80) {</span>
      <span class="s1">self.lastNeed = 1;</span>
      <span class="s1">return '\ufffd';</span>
    <span class="s1">}</span>
    <span class="s1">if (self.lastNeed &gt; 2 &amp;&amp; buf.length &gt; 2) {</span>
      <span class="s1">if ((buf[2] &amp; 0xC0) !== 0x80) {</span>
        <span class="s1">self.lastNeed = 2;</span>
        <span class="s1">return '\ufffd';</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.</span>
<span class="s1">function utf8FillLast(buf) {</span>
  <span class="s1">var p = this.lastTotal - this.lastNeed;</span>
  <span class="s1">var r = utf8CheckExtraBytes(this, buf, p);</span>
  <span class="s1">if (r !== undefined) return r;</span>
  <span class="s1">if (this.lastNeed &lt;= buf.length) {</span>
    <span class="s1">buf.copy(this.lastChar, p, 0, this.lastNeed);</span>
    <span class="s1">return this.lastChar.toString(this.encoding, 0, this.lastTotal);</span>
  <span class="s1">}</span>
  <span class="s1">buf.copy(this.lastChar, p, 0, buf.length);</span>
  <span class="s1">this.lastNeed -= buf.length;</span>
<span class="s1">}</span>

<span class="s1">// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a</span>
<span class="s1">// partial character, the character's bytes are buffered until the required</span>
<span class="s1">// number of bytes are available.</span>
<span class="s1">function utf8Text(buf, i) {</span>
  <span class="s1">var total = utf8CheckIncomplete(this, buf, i);</span>
  <span class="s1">if (!this.lastNeed) return buf.toString('utf8', i);</span>
  <span class="s1">this.lastTotal = total;</span>
  <span class="s1">var end = buf.length - (total - this.lastNeed);</span>
  <span class="s1">buf.copy(this.lastChar, 0, end);</span>
  <span class="s1">return buf.toString('utf8', i, end);</span>
<span class="s1">}</span>

<span class="s1">// For UTF-8, a replacement character is added when ending on a partial</span>
<span class="s1">// character.</span>
<span class="s1">function utf8End(buf) {</span>
  <span class="s1">var r = buf &amp;&amp; buf.length ? this.write(buf) : '';</span>
  <span class="s1">if (this.lastNeed) return r + '\ufffd';</span>
  <span class="s1">return r;</span>
<span class="s1">}</span>

<span class="s1">// UTF-16LE typically needs two bytes per character, but even if we have an even</span>
<span class="s1">// number of bytes available, we need to check if we end on a leading/high</span>
<span class="s1">// surrogate. In that case, we need to wait for the next two bytes in order to</span>
<span class="s1">// decode the last character properly.</span>
<span class="s1">function utf16Text(buf, i) {</span>
  <span class="s1">if ((buf.length - i) % 2 === 0) {</span>
    <span class="s1">var r = buf.toString('utf16le', i);</span>
    <span class="s1">if (r) {</span>
      <span class="s1">var c = r.charCodeAt(r.length - 1);</span>
      <span class="s1">if (c &gt;= 0xD800 &amp;&amp; c &lt;= 0xDBFF) {</span>
        <span class="s1">this.lastNeed = 2;</span>
        <span class="s1">this.lastTotal = 4;</span>
        <span class="s1">this.lastChar[0] = buf[buf.length - 2];</span>
        <span class="s1">this.lastChar[1] = buf[buf.length - 1];</span>
        <span class="s1">return r.slice(0, -1);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return r;</span>
  <span class="s1">}</span>
  <span class="s1">this.lastNeed = 1;</span>
  <span class="s1">this.lastTotal = 2;</span>
  <span class="s1">this.lastChar[0] = buf[buf.length - 1];</span>
  <span class="s1">return buf.toString('utf16le', i, buf.length - 1);</span>
<span class="s1">}</span>

<span class="s1">// For UTF-16LE we do not explicitly append special replacement characters if we</span>
<span class="s1">// end on a partial character, we simply let v8 handle that.</span>
<span class="s1">function utf16End(buf) {</span>
  <span class="s1">var r = buf &amp;&amp; buf.length ? this.write(buf) : '';</span>
  <span class="s1">if (this.lastNeed) {</span>
    <span class="s1">var end = this.lastTotal - this.lastNeed;</span>
    <span class="s1">return r + this.lastChar.toString('utf16le', 0, end);</span>
  <span class="s1">}</span>
  <span class="s1">return r;</span>
<span class="s1">}</span>

<span class="s1">function base64Text(buf, i) {</span>
  <span class="s1">var n = (buf.length - i) % 3;</span>
  <span class="s1">if (n === 0) return buf.toString('base64', i);</span>
  <span class="s1">this.lastNeed = 3 - n;</span>
  <span class="s1">this.lastTotal = 3;</span>
  <span class="s1">if (n === 1) {</span>
    <span class="s1">this.lastChar[0] = buf[buf.length - 1];</span>
  <span class="s1">} else {</span>
    <span class="s1">this.lastChar[0] = buf[buf.length - 2];</span>
    <span class="s1">this.lastChar[1] = buf[buf.length - 1];</span>
  <span class="s1">}</span>
  <span class="s1">return buf.toString('base64', i, buf.length - n);</span>
<span class="s1">}</span>

<span class="s1">function base64End(buf) {</span>
  <span class="s1">var r = buf &amp;&amp; buf.length ? this.write(buf) : '';</span>
  <span class="s1">if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);</span>
  <span class="s1">return r;</span>
<span class="s1">}</span>

<span class="s1">// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)</span>
<span class="s1">function simpleWrite(buf) {</span>
  <span class="s1">return buf.toString(this.encoding);</span>
<span class="s1">}</span>

<span class="s1">function simpleEnd(buf) {</span>
  <span class="s1">return buf &amp;&amp; buf.length ? this.write(buf) : '';</span>
<span class="s1">}</span>
<span class="s1">},{&quot;safe-buffer&quot;:89}],91:[function(require,module,exports){</span>
<span class="s1">module.exports = require('./readable').PassThrough</span>

<span class="s1">},{&quot;./readable&quot;:92}],92:[function(require,module,exports){</span>
<span class="s1">exports = module.exports = require('./lib/_stream_readable.js');</span>
<span class="s1">exports.Stream = exports;</span>
<span class="s1">exports.Readable = exports;</span>
<span class="s1">exports.Writable = require('./lib/_stream_writable.js');</span>
<span class="s1">exports.Duplex = require('./lib/_stream_duplex.js');</span>
<span class="s1">exports.Transform = require('./lib/_stream_transform.js');</span>
<span class="s1">exports.PassThrough = require('./lib/_stream_passthrough.js');</span>

<span class="s1">},{&quot;./lib/_stream_duplex.js&quot;:81,&quot;./lib/_stream_passthrough.js&quot;:82,&quot;./lib/_stream_readable.js&quot;:83,&quot;./lib/_stream_transform.js&quot;:84,&quot;./lib/_stream_writable.js&quot;:85}],93:[function(require,module,exports){</span>
<span class="s1">module.exports = require('./readable').Transform</span>

<span class="s1">},{&quot;./readable&quot;:92}],94:[function(require,module,exports){</span>
<span class="s1">module.exports = require('./lib/_stream_writable.js');</span>

<span class="s1">},{&quot;./lib/_stream_writable.js&quot;:85}],95:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var $Object = Object;</span>
<span class="s1">var $TypeError = TypeError;</span>

<span class="s1">module.exports = function flags() {</span>
	<span class="s1">if (this != null &amp;&amp; this !== $Object(this)) {</span>
		<span class="s1">throw new $TypeError('RegExp.prototype.flags getter called on non-object');</span>
	<span class="s1">}</span>
	<span class="s1">var result = '';</span>
	<span class="s1">if (this.global) {</span>
		<span class="s1">result += 'g';</span>
	<span class="s1">}</span>
	<span class="s1">if (this.ignoreCase) {</span>
		<span class="s1">result += 'i';</span>
	<span class="s1">}</span>
	<span class="s1">if (this.multiline) {</span>
		<span class="s1">result += 'm';</span>
	<span class="s1">}</span>
	<span class="s1">if (this.dotAll) {</span>
		<span class="s1">result += 's';</span>
	<span class="s1">}</span>
	<span class="s1">if (this.unicode) {</span>
		<span class="s1">result += 'u';</span>
	<span class="s1">}</span>
	<span class="s1">if (this.sticky) {</span>
		<span class="s1">result += 'y';</span>
	<span class="s1">}</span>
	<span class="s1">return result;</span>
<span class="s1">};</span>

<span class="s1">},{}],96:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var define = require('define-properties');</span>
<span class="s1">var callBind = require('call-bind');</span>

<span class="s1">var implementation = require('./implementation');</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>
<span class="s1">var shim = require('./shim');</span>

<span class="s1">var flagsBound = callBind(implementation);</span>

<span class="s1">define(flagsBound, {</span>
	<span class="s1">getPolyfill: getPolyfill,</span>
	<span class="s1">implementation: implementation,</span>
	<span class="s1">shim: shim</span>
<span class="s1">});</span>

<span class="s1">module.exports = flagsBound;</span>

<span class="s1">},{&quot;./implementation&quot;:95,&quot;./polyfill&quot;:97,&quot;./shim&quot;:98,&quot;call-bind&quot;:12,&quot;define-properties&quot;:16}],97:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var implementation = require('./implementation');</span>

<span class="s1">var supportsDescriptors = require('define-properties').supportsDescriptors;</span>
<span class="s1">var $gOPD = Object.getOwnPropertyDescriptor;</span>
<span class="s1">var $TypeError = TypeError;</span>

<span class="s1">module.exports = function getPolyfill() {</span>
	<span class="s1">if (!supportsDescriptors) {</span>
		<span class="s1">throw new $TypeError('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');</span>
	<span class="s1">}</span>
	<span class="s1">if ((/a/mig).flags === 'gim') {</span>
		<span class="s1">var descriptor = $gOPD(RegExp.prototype, 'flags');</span>
		<span class="s1">if (descriptor &amp;&amp; typeof descriptor.get === 'function' &amp;&amp; typeof (/a/).dotAll === 'boolean') {</span>
			<span class="s1">return descriptor.get;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return implementation;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./implementation&quot;:95,&quot;define-properties&quot;:16}],98:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var supportsDescriptors = require('define-properties').supportsDescriptors;</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>
<span class="s1">var gOPD = Object.getOwnPropertyDescriptor;</span>
<span class="s1">var defineProperty = Object.defineProperty;</span>
<span class="s1">var TypeErr = TypeError;</span>
<span class="s1">var getProto = Object.getPrototypeOf;</span>
<span class="s1">var regex = /a/;</span>

<span class="s1">module.exports = function shimFlags() {</span>
	<span class="s1">if (!supportsDescriptors || !getProto) {</span>
		<span class="s1">throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');</span>
	<span class="s1">}</span>
	<span class="s1">var polyfill = getPolyfill();</span>
	<span class="s1">var proto = getProto(regex);</span>
	<span class="s1">var descriptor = gOPD(proto, 'flags');</span>
	<span class="s1">if (!descriptor || descriptor.get !== polyfill) {</span>
		<span class="s1">defineProperty(proto, 'flags', {</span>
			<span class="s1">configurable: true,</span>
			<span class="s1">enumerable: false,</span>
			<span class="s1">get: polyfill</span>
		<span class="s1">});</span>
	<span class="s1">}</span>
	<span class="s1">return polyfill;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./polyfill&quot;:97,&quot;define-properties&quot;:16}],99:[function(require,module,exports){</span>
<span class="s1">(function (process,setImmediate){(function (){</span>
<span class="s1">var through = require('through');</span>
<span class="s1">var nextTick = typeof setImmediate !== 'undefined'</span>
    <span class="s1">? setImmediate</span>
    <span class="s1">: process.nextTick</span>
<span class="s1">;</span>

<span class="s1">module.exports = function (write, end) {</span>
    <span class="s1">var tr = through(write, end);</span>
    <span class="s1">tr.pause();</span>
    <span class="s1">var resume = tr.resume;</span>
    <span class="s1">var pause = tr.pause;</span>
    <span class="s1">var paused = false;</span>
    
    <span class="s1">tr.pause = function () {</span>
        <span class="s1">paused = true;</span>
        <span class="s1">return pause.apply(this, arguments);</span>
    <span class="s1">};</span>
    
    <span class="s1">tr.resume = function () {</span>
        <span class="s1">paused = false;</span>
        <span class="s1">return resume.apply(this, arguments);</span>
    <span class="s1">};</span>
    
    <span class="s1">nextTick(function () {</span>
        <span class="s1">if (!paused) tr.resume();</span>
    <span class="s1">});</span>
    
    <span class="s1">return tr;</span>
<span class="s1">};</span>

<span class="s1">}).call(this)}).call(this,require('_process'),require(&quot;timers&quot;).setImmediate)</span>

<span class="s1">},{&quot;_process&quot;:79,&quot;through&quot;:110,&quot;timers&quot;:111}],100:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var GetIntrinsic = require('get-intrinsic');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var inspect = require('object-inspect');</span>

<span class="s1">var $TypeError = GetIntrinsic('%TypeError%');</span>
<span class="s1">var $WeakMap = GetIntrinsic('%WeakMap%', true);</span>
<span class="s1">var $Map = GetIntrinsic('%Map%', true);</span>

<span class="s1">var $weakMapGet = callBound('WeakMap.prototype.get', true);</span>
<span class="s1">var $weakMapSet = callBound('WeakMap.prototype.set', true);</span>
<span class="s1">var $weakMapHas = callBound('WeakMap.prototype.has', true);</span>
<span class="s1">var $mapGet = callBound('Map.prototype.get', true);</span>
<span class="s1">var $mapSet = callBound('Map.prototype.set', true);</span>
<span class="s1">var $mapHas = callBound('Map.prototype.has', true);</span>

<span class="s1">/*</span>
 <span class="s1">* This function traverses the list returning the node corresponding to the</span>
 <span class="s1">* given key.</span>
 <span class="s1">*</span>
 <span class="s1">* That node is also moved to the head of the list, so that if it's accessed</span>
 <span class="s1">* again we don't need to traverse the whole list. By doing so, all the recently</span>
 <span class="s1">* used nodes can be accessed relatively quickly.</span>
 <span class="s1">*/</span>
<span class="s1">var listGetNode = function (list, key) { // eslint-disable-line consistent-return</span>
	<span class="s1">for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {</span>
		<span class="s1">if (curr.key === key) {</span>
			<span class="s1">prev.next = curr.next;</span>
			<span class="s1">curr.next = list.next;</span>
			<span class="s1">list.next = curr; // eslint-disable-line no-param-reassign</span>
			<span class="s1">return curr;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">var listGet = function (objects, key) {</span>
	<span class="s1">var node = listGetNode(objects, key);</span>
	<span class="s1">return node &amp;&amp; node.value;</span>
<span class="s1">};</span>
<span class="s1">var listSet = function (objects, key, value) {</span>
	<span class="s1">var node = listGetNode(objects, key);</span>
	<span class="s1">if (node) {</span>
		<span class="s1">node.value = value;</span>
	<span class="s1">} else {</span>
		<span class="s1">// Prepend the new node to the beginning of the list</span>
		<span class="s1">objects.next = { // eslint-disable-line no-param-reassign</span>
			<span class="s1">key: key,</span>
			<span class="s1">next: objects.next,</span>
			<span class="s1">value: value</span>
		<span class="s1">};</span>
	<span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">var listHas = function (objects, key) {</span>
	<span class="s1">return !!listGetNode(objects, key);</span>
<span class="s1">};</span>

<span class="s1">module.exports = function getSideChannel() {</span>
	<span class="s1">var $wm;</span>
	<span class="s1">var $m;</span>
	<span class="s1">var $o;</span>
	<span class="s1">var channel = {</span>
		<span class="s1">assert: function (key) {</span>
			<span class="s1">if (!channel.has(key)) {</span>
				<span class="s1">throw new $TypeError('Side channel does not contain ' + inspect(key));</span>
			<span class="s1">}</span>
		<span class="s1">},</span>
		<span class="s1">get: function (key) { // eslint-disable-line consistent-return</span>
			<span class="s1">if ($WeakMap &amp;&amp; key &amp;&amp; (typeof key === 'object' || typeof key === 'function')) {</span>
				<span class="s1">if ($wm) {</span>
					<span class="s1">return $weakMapGet($wm, key);</span>
				<span class="s1">}</span>
			<span class="s1">} else if ($Map) {</span>
				<span class="s1">if ($m) {</span>
					<span class="s1">return $mapGet($m, key);</span>
				<span class="s1">}</span>
			<span class="s1">} else {</span>
				<span class="s1">if ($o) { // eslint-disable-line no-lonely-if</span>
					<span class="s1">return listGet($o, key);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">},</span>
		<span class="s1">has: function (key) {</span>
			<span class="s1">if ($WeakMap &amp;&amp; key &amp;&amp; (typeof key === 'object' || typeof key === 'function')) {</span>
				<span class="s1">if ($wm) {</span>
					<span class="s1">return $weakMapHas($wm, key);</span>
				<span class="s1">}</span>
			<span class="s1">} else if ($Map) {</span>
				<span class="s1">if ($m) {</span>
					<span class="s1">return $mapHas($m, key);</span>
				<span class="s1">}</span>
			<span class="s1">} else {</span>
				<span class="s1">if ($o) { // eslint-disable-line no-lonely-if</span>
					<span class="s1">return listHas($o, key);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s1">return false;</span>
		<span class="s1">},</span>
		<span class="s1">set: function (key, value) {</span>
			<span class="s1">if ($WeakMap &amp;&amp; key &amp;&amp; (typeof key === 'object' || typeof key === 'function')) {</span>
				<span class="s1">if (!$wm) {</span>
					<span class="s1">$wm = new $WeakMap();</span>
				<span class="s1">}</span>
				<span class="s1">$weakMapSet($wm, key, value);</span>
			<span class="s1">} else if ($Map) {</span>
				<span class="s1">if (!$m) {</span>
					<span class="s1">$m = new $Map();</span>
				<span class="s1">}</span>
				<span class="s1">$mapSet($m, key, value);</span>
			<span class="s1">} else {</span>
				<span class="s1">if (!$o) {</span>
					<span class="s1">/*</span>
					 <span class="s1">* Initialize the linked list as an empty node, so that we don't have</span>
					 <span class="s1">* to special-case handling of the first node: we can always refer to</span>
					 <span class="s1">* it as (previous node).next, instead of something like (list).head</span>
					 <span class="s1">*/</span>
					<span class="s1">$o = { key: {}, next: null };</span>
				<span class="s1">}</span>
				<span class="s1">listSet($o, key, value);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">};</span>
	<span class="s1">return channel;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;get-intrinsic&quot;:39,&quot;object-inspect&quot;:65}],101:[function(require,module,exports){</span>
<span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s1">//</span>
<span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s1">// copy of this software and associated documentation files (the</span>
<span class="s1">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s1">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s1">// following conditions:</span>
<span class="s1">//</span>
<span class="s1">// The above copyright notice and this permission notice shall be included</span>
<span class="s1">// in all copies or substantial portions of the Software.</span>
<span class="s1">//</span>
<span class="s1">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s1">module.exports = Stream;</span>

<span class="s1">var EE = require('events').EventEmitter;</span>
<span class="s1">var inherits = require('inherits');</span>

<span class="s1">inherits(Stream, EE);</span>
<span class="s1">Stream.Readable = require('readable-stream/readable.js');</span>
<span class="s1">Stream.Writable = require('readable-stream/writable.js');</span>
<span class="s1">Stream.Duplex = require('readable-stream/duplex.js');</span>
<span class="s1">Stream.Transform = require('readable-stream/transform.js');</span>
<span class="s1">Stream.PassThrough = require('readable-stream/passthrough.js');</span>

<span class="s1">// Backwards-compat with node 0.4.x</span>
<span class="s1">Stream.Stream = Stream;</span>



<span class="s1">// old-style streams.  Note that the pipe method (the only relevant</span>
<span class="s1">// part of this class) is overridden in the Readable class.</span>

<span class="s1">function Stream() {</span>
  <span class="s1">EE.call(this);</span>
<span class="s1">}</span>

<span class="s1">Stream.prototype.pipe = function(dest, options) {</span>
  <span class="s1">var source = this;</span>

  <span class="s1">function ondata(chunk) {</span>
    <span class="s1">if (dest.writable) {</span>
      <span class="s1">if (false === dest.write(chunk) &amp;&amp; source.pause) {</span>
        <span class="s1">source.pause();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">source.on('data', ondata);</span>

  <span class="s1">function ondrain() {</span>
    <span class="s1">if (source.readable &amp;&amp; source.resume) {</span>
      <span class="s1">source.resume();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">dest.on('drain', ondrain);</span>

  <span class="s1">// If the 'end' option is not supplied, dest.end() will be called when</span>
  <span class="s1">// source gets the 'end' or 'close' events.  Only dest.end() once.</span>
  <span class="s1">if (!dest._isStdio &amp;&amp; (!options || options.end !== false)) {</span>
    <span class="s1">source.on('end', onend);</span>
    <span class="s1">source.on('close', onclose);</span>
  <span class="s1">}</span>

  <span class="s1">var didOnEnd = false;</span>
  <span class="s1">function onend() {</span>
    <span class="s1">if (didOnEnd) return;</span>
    <span class="s1">didOnEnd = true;</span>

    <span class="s1">dest.end();</span>
  <span class="s1">}</span>


  <span class="s1">function onclose() {</span>
    <span class="s1">if (didOnEnd) return;</span>
    <span class="s1">didOnEnd = true;</span>

    <span class="s1">if (typeof dest.destroy === 'function') dest.destroy();</span>
  <span class="s1">}</span>

  <span class="s1">// don't leave dangling pipes when there are errors.</span>
  <span class="s1">function onerror(er) {</span>
    <span class="s1">cleanup();</span>
    <span class="s1">if (EE.listenerCount(this, 'error') === 0) {</span>
      <span class="s1">throw er; // Unhandled stream error in pipe.</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">source.on('error', onerror);</span>
  <span class="s1">dest.on('error', onerror);</span>

  <span class="s1">// remove all the event listeners that were added.</span>
  <span class="s1">function cleanup() {</span>
    <span class="s1">source.removeListener('data', ondata);</span>
    <span class="s1">dest.removeListener('drain', ondrain);</span>

    <span class="s1">source.removeListener('end', onend);</span>
    <span class="s1">source.removeListener('close', onclose);</span>

    <span class="s1">source.removeListener('error', onerror);</span>
    <span class="s1">dest.removeListener('error', onerror);</span>

    <span class="s1">source.removeListener('end', cleanup);</span>
    <span class="s1">source.removeListener('close', cleanup);</span>

    <span class="s1">dest.removeListener('close', cleanup);</span>
  <span class="s1">}</span>

  <span class="s1">source.on('end', cleanup);</span>
  <span class="s1">source.on('close', cleanup);</span>

  <span class="s1">dest.on('close', cleanup);</span>

  <span class="s1">dest.emit('pipe', source);</span>

  <span class="s1">// Allow for unix-like usage: A.pipe(B).pipe(C)</span>
  <span class="s1">return dest;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;events&quot;:33,&quot;inherits&quot;:47,&quot;readable-stream/duplex.js&quot;:80,&quot;readable-stream/passthrough.js&quot;:91,&quot;readable-stream/readable.js&quot;:92,&quot;readable-stream/transform.js&quot;:93,&quot;readable-stream/writable.js&quot;:94}],102:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var RequireObjectCoercible = require('es-abstract/2021/RequireObjectCoercible');</span>
<span class="s1">var ToString = require('es-abstract/2021/ToString');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var $replace = callBound('String.prototype.replace');</span>

<span class="s1">/* eslint-disable no-control-regex */</span>
<span class="s1">var leftWhitespace = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;</span>
<span class="s1">var rightWhitespace = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;</span>
<span class="s1">/* eslint-enable no-control-regex */</span>

<span class="s1">module.exports = function trim() {</span>
	<span class="s1">var S = ToString(RequireObjectCoercible(this));</span>
	<span class="s1">return $replace($replace(S, leftWhitespace, ''), rightWhitespace, '');</span>
<span class="s1">};</span>

<span class="s1">},{&quot;call-bind/callBound&quot;:11,&quot;es-abstract/2021/RequireObjectCoercible&quot;:19,&quot;es-abstract/2021/ToString&quot;:23}],103:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var callBind = require('call-bind');</span>
<span class="s1">var define = require('define-properties');</span>

<span class="s1">var implementation = require('./implementation');</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>
<span class="s1">var shim = require('./shim');</span>

<span class="s1">var boundTrim = callBind(getPolyfill());</span>

<span class="s1">define(boundTrim, {</span>
	<span class="s1">getPolyfill: getPolyfill,</span>
	<span class="s1">implementation: implementation,</span>
	<span class="s1">shim: shim</span>
<span class="s1">});</span>

<span class="s1">module.exports = boundTrim;</span>

<span class="s1">},{&quot;./implementation&quot;:102,&quot;./polyfill&quot;:104,&quot;./shim&quot;:105,&quot;call-bind&quot;:12,&quot;define-properties&quot;:16}],104:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var implementation = require('./implementation');</span>

<span class="s1">var zeroWidthSpace = '\u200b';</span>

<span class="s1">module.exports = function getPolyfill() {</span>
	<span class="s1">if (String.prototype.trim &amp;&amp; zeroWidthSpace.trim() === zeroWidthSpace) {</span>
		<span class="s1">return String.prototype.trim;</span>
	<span class="s1">}</span>
	<span class="s1">return implementation;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./implementation&quot;:102}],105:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var define = require('define-properties');</span>
<span class="s1">var getPolyfill = require('./polyfill');</span>

<span class="s1">module.exports = function shimStringTrim() {</span>
	<span class="s1">var polyfill = getPolyfill();</span>
	<span class="s1">define(String.prototype, { trim: polyfill }, {</span>
		<span class="s1">trim: function testTrim() {</span>
			<span class="s1">return String.prototype.trim !== polyfill;</span>
		<span class="s1">}</span>
	<span class="s1">});</span>
	<span class="s1">return polyfill;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;./polyfill&quot;:104,&quot;define-properties&quot;:16}],106:[function(require,module,exports){</span>
<span class="s1">(function (process){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">var defined = require('defined');</span>
<span class="s1">var createDefaultStream = require('./lib/default_stream');</span>
<span class="s1">var Test = require('./lib/test');</span>
<span class="s1">var createResult = require('./lib/results');</span>
<span class="s1">var through = require('through');</span>

<span class="s1">var canEmitExit = typeof process !== 'undefined' &amp;&amp; process</span>
    <span class="s1">&amp;&amp; typeof process.on === 'function' &amp;&amp; process.browser !== true;</span>
<span class="s1">var canExit = typeof process !== 'undefined' &amp;&amp; process</span>
    <span class="s1">&amp;&amp; typeof process.exit === 'function';</span>

<span class="s1">module.exports = (function () {</span>
    <span class="s1">var wait = false;</span>
    <span class="s1">var harness;</span>
    <span class="s1">var lazyLoad = function () {</span>
        <span class="s1">// eslint-disable-next-line no-invalid-this</span>
        <span class="s1">return getHarness().apply(this, arguments);</span>
    <span class="s1">};</span>

    <span class="s1">lazyLoad.wait = function () {</span>
        <span class="s1">wait = true;</span>
    <span class="s1">};</span>

    <span class="s1">lazyLoad.run = function () {</span>
        <span class="s1">var run = getHarness().run;</span>

        <span class="s1">if (run) { run(); }</span>
    <span class="s1">};</span>

    <span class="s1">lazyLoad.only = function () {</span>
        <span class="s1">return getHarness().only.apply(this, arguments);</span>
    <span class="s1">};</span>

    <span class="s1">lazyLoad.createStream = function (opts) {</span>
        <span class="s1">var options = opts || {};</span>
        <span class="s1">if (!harness) {</span>
            <span class="s1">var output = through();</span>
            <span class="s1">getHarness({ stream: output, objectMode: options.objectMode });</span>
            <span class="s1">return output;</span>
        <span class="s1">}</span>
        <span class="s1">return harness.createStream(options);</span>
    <span class="s1">};</span>

    <span class="s1">lazyLoad.onFinish = function () {</span>
        <span class="s1">return getHarness().onFinish.apply(this, arguments);</span>
    <span class="s1">};</span>

    <span class="s1">lazyLoad.onFailure = function () {</span>
        <span class="s1">return getHarness().onFailure.apply(this, arguments);</span>
    <span class="s1">};</span>

    <span class="s1">lazyLoad.getHarness = getHarness;</span>

    <span class="s1">return lazyLoad;</span>

    <span class="s1">function getHarness(opts) {</span>
        <span class="s1">if (!opts) { opts = {}; }</span>
        <span class="s1">opts.autoclose = !canEmitExit;</span>
        <span class="s1">if (!harness) { harness = createExitHarness(opts, wait); }</span>
        <span class="s1">return harness;</span>
    <span class="s1">}</span>
<span class="s1">}());</span>

<span class="s1">function createExitHarness(conf, wait) {</span>
    <span class="s1">var config = conf || {};</span>
    <span class="s1">var harness = createHarness({</span>
        <span class="s1">autoclose: defined(config.autoclose, false),</span>
        <span class="s1">noOnly: defined(conf.noOnly, defined(process.env.NODE_TAPE_NO_ONLY_TEST, false))</span>
    <span class="s1">});</span>
    <span class="s1">var running = false;</span>
    <span class="s1">var ended = false;</span>

    <span class="s1">if (wait) {</span>
        <span class="s1">harness.run = run;</span>
    <span class="s1">} else {</span>
        <span class="s1">run();</span>
    <span class="s1">}</span>

    <span class="s1">if (config.exit === false) { return harness; }</span>
    <span class="s1">if (!canEmitExit || !canExit) { return harness; }</span>

    <span class="s1">process.on('exit', function (code) {</span>
        <span class="s1">// let the process exit cleanly.</span>
        <span class="s1">if (typeof code === 'number' &amp;&amp; code !== 0) {</span>
            <span class="s1">return;</span>
        <span class="s1">}</span>

        <span class="s1">if (!ended) {</span>
            <span class="s1">var only = harness._results._only;</span>
            <span class="s1">for (var i = 0; i &lt; harness._tests.length; i++) {</span>
                <span class="s1">var t = harness._tests[i];</span>
                <span class="s1">if (!only || t === only) {</span>
                    <span class="s1">t._exit();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">harness.close();</span>

        <span class="s1">process.removeAllListeners('exit'); // necessary for node v0.6</span>
        <span class="s1">process.exit(code || harness._exitCode); // eslint-disable-line no-process-exit</span>
    <span class="s1">});</span>

    <span class="s1">return harness;</span>

    <span class="s1">function run() {</span>
        <span class="s1">if (running) { return; }</span>
        <span class="s1">running = true;</span>
        <span class="s1">var stream = harness.createStream({ objectMode: config.objectMode });</span>
        <span class="s1">var es = stream.pipe(config.stream || createDefaultStream());</span>
        <span class="s1">if (canEmitExit) {</span>
            <span class="s1">// TODO: use `err` arg?</span>
            <span class="s1">// eslint-disable-next-line no-unused-vars</span>
            <span class="s1">es.on('error', function (err) { harness._exitCode = 1; });</span>
        <span class="s1">}</span>
        <span class="s1">stream.on('end', function () { ended = true; });</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">module.exports.createHarness = createHarness;</span>
<span class="s1">module.exports.Test = Test;</span>
<span class="s1">module.exports.test = module.exports; // tap compat</span>
<span class="s1">module.exports.test.skip = Test.skip;</span>

<span class="s1">function createHarness(conf_) {</span>
    <span class="s1">var results = createResult();</span>
    <span class="s1">if (!conf_ || conf_.autoclose !== false) {</span>
        <span class="s1">results.once('done', function () { results.close(); });</span>
    <span class="s1">}</span>

    <span class="s1">var test = function (name, conf, cb) {</span>
        <span class="s1">var t = new Test(name, conf, cb);</span>
        <span class="s1">test._tests.push(t);</span>

        <span class="s1">(function inspectCode(st) {</span>
            <span class="s1">st.on('test', function sub(st_) {</span>
                <span class="s1">inspectCode(st_);</span>
            <span class="s1">});</span>
            <span class="s1">st.on('result', function (r) {</span>
                <span class="s1">if (!r.todo &amp;&amp; !r.ok &amp;&amp; typeof r !== 'string') { test._exitCode = 1; }</span>
            <span class="s1">});</span>
        <span class="s1">}(t));</span>

        <span class="s1">results.push(t);</span>
        <span class="s1">return t;</span>
    <span class="s1">};</span>
    <span class="s1">test._results = results;</span>

    <span class="s1">test._tests = [];</span>

    <span class="s1">test.createStream = function (opts) {</span>
        <span class="s1">return results.createStream(opts);</span>
    <span class="s1">};</span>

    <span class="s1">test.onFinish = function (cb) {</span>
        <span class="s1">results.on('done', cb);</span>
    <span class="s1">};</span>

    <span class="s1">test.onFailure = function (cb) {</span>
        <span class="s1">results.on('fail', cb);</span>
    <span class="s1">};</span>

    <span class="s1">var only = false;</span>
    <span class="s1">test.only = function () {</span>
        <span class="s1">if (only) { throw new Error('there can only be one only test'); }</span>
        <span class="s1">if (conf_.noOnly) { throw new Error('`only` tests are prohibited'); }</span>
        <span class="s1">only = true;</span>
        <span class="s1">var t = test.apply(null, arguments);</span>
        <span class="s1">results.only(t);</span>
        <span class="s1">return t;</span>
    <span class="s1">};</span>
    <span class="s1">test._exitCode = 0;</span>

    <span class="s1">test.close = function () { results.close(); };</span>

    <span class="s1">return test;</span>
<span class="s1">}</span>

<span class="s1">}).call(this)}).call(this,require('_process'))</span>

<span class="s1">},{&quot;./lib/default_stream&quot;:107,&quot;./lib/results&quot;:108,&quot;./lib/test&quot;:109,&quot;_process&quot;:79,&quot;defined&quot;:17,&quot;through&quot;:110}],107:[function(require,module,exports){</span>
<span class="s1">(function (process){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">var through = require('through');</span>
<span class="s1">var fs = require('fs');</span>

<span class="s1">module.exports = function () {</span>
    <span class="s1">var line = '';</span>
    <span class="s1">var stream = through(write, flush);</span>
    <span class="s1">return stream;</span>

    <span class="s1">function write(buf) {</span>
        <span class="s1">for (var i = 0; i &lt; buf.length; i++) {</span>
            <span class="s1">var c = typeof buf === 'string'</span>
                <span class="s1">? buf.charAt(i)</span>
                <span class="s1">: String.fromCharCode(buf[i]);</span>
            <span class="s1">if (c === '\n') {</span>
                <span class="s1">flush();</span>
            <span class="s1">} else {</span>
                <span class="s1">line += c;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">function flush() {</span>
        <span class="s1">if (fs.writeSync &amp;&amp; (/^win/).test(process.platform)) {</span>
            <span class="s1">try {</span>
                <span class="s1">fs.writeSync(1, line + '\n');</span>
            <span class="s1">} catch (e) {</span>
                <span class="s1">stream.emit('error', e);</span>
            <span class="s1">}</span>
        <span class="s1">} else {</span>
            <span class="s1">try {</span>
                <span class="s1">console.log(line); // eslint-disable-line no-console</span>
            <span class="s1">} catch (e) {</span>
                <span class="s1">stream.emit('error', e);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">line = '';</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">}).call(this)}).call(this,require('_process'))</span>

<span class="s1">},{&quot;_process&quot;:79,&quot;fs&quot;:9,&quot;through&quot;:110}],108:[function(require,module,exports){</span>
<span class="s1">(function (process,setImmediate){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">var defined = require('defined');</span>
<span class="s1">var EventEmitter = require('events').EventEmitter;</span>
<span class="s1">var inherits = require('inherits');</span>
<span class="s1">var through = require('through');</span>
<span class="s1">var resumer = require('resumer');</span>
<span class="s1">var inspect = require('object-inspect');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var has = require('has');</span>
<span class="s1">var regexpTest = callBound('RegExp.prototype.test');</span>
<span class="s1">var $split = callBound('String.prototype.split');</span>
<span class="s1">var $replace = callBound('String.prototype.replace');</span>
<span class="s1">var $shift = callBound('Array.prototype.shift');</span>
<span class="s1">var $push = callBound('Array.prototype.push');</span>
<span class="s1">var yamlIndicators = /:|-|\?/;</span>
<span class="s1">var nextTick = typeof setImmediate !== 'undefined'</span>
    <span class="s1">? setImmediate</span>
    <span class="s1">: process.nextTick;</span>
<span class="s1">module.exports = Results;</span>
<span class="s1">inherits(Results, EventEmitter);</span>

<span class="s1">function coalesceWhiteSpaces(str) {</span>
    <span class="s1">return $replace(String(str), /\s+/g, ' ');</span>
<span class="s1">}</span>

<span class="s1">function Results() {</span>
    <span class="s1">if (!(this instanceof Results)) { return new Results(); }</span>
    <span class="s1">this.count = 0;</span>
    <span class="s1">this.fail = 0;</span>
    <span class="s1">this.pass = 0;</span>
    <span class="s1">this.todo = 0;</span>
    <span class="s1">this._stream = through();</span>
    <span class="s1">this.tests = [];</span>
    <span class="s1">this._only = null;</span>
    <span class="s1">this._isRunning = false;</span>
<span class="s1">}</span>

<span class="s1">Results.prototype.createStream = function (opts) {</span>
    <span class="s1">if (!opts) { opts = {}; }</span>
    <span class="s1">var self = this;</span>
    <span class="s1">var output;</span>
    <span class="s1">var testId = 0;</span>
    <span class="s1">if (opts.objectMode) {</span>
        <span class="s1">output = through();</span>
        <span class="s1">self.on('_push', function ontest(t, extra) {</span>
            <span class="s1">if (!extra) { extra = {}; }</span>
            <span class="s1">var id = testId++;</span>
            <span class="s1">t.once('prerun', function () {</span>
                <span class="s1">var row = {</span>
                    <span class="s1">type: 'test',</span>
                    <span class="s1">name: t.name,</span>
                    <span class="s1">id: id,</span>
                    <span class="s1">skip: t._skip,</span>
                    <span class="s1">todo: t._todo</span>
                <span class="s1">};</span>
                <span class="s1">if (has(extra, 'parent')) {</span>
                    <span class="s1">row.parent = extra.parent;</span>
                <span class="s1">}</span>
                <span class="s1">output.queue(row);</span>
            <span class="s1">});</span>
            <span class="s1">t.on('test', function (st) {</span>
                <span class="s1">ontest(st, { parent: id });</span>
            <span class="s1">});</span>
            <span class="s1">t.on('result', function (res) {</span>
                <span class="s1">if (res &amp;&amp; typeof res === 'object') {</span>
                    <span class="s1">res.test = id;</span>
                    <span class="s1">res.type = 'assert';</span>
                <span class="s1">}</span>
                <span class="s1">output.queue(res);</span>
            <span class="s1">});</span>
            <span class="s1">t.on('end', function () {</span>
                <span class="s1">output.queue({ type: 'end', test: id });</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
        <span class="s1">self.on('done', function () { output.queue(null); });</span>
    <span class="s1">} else {</span>
        <span class="s1">output = resumer();</span>
        <span class="s1">output.queue('TAP version 13\n');</span>
        <span class="s1">self._stream.pipe(output);</span>
    <span class="s1">}</span>

    <span class="s1">if (!this._isRunning) {</span>
        <span class="s1">this._isRunning = true;</span>
        <span class="s1">nextTick(function next() {</span>
            <span class="s1">var t;</span>
            <span class="s1">while (t = getNextTest(self)) {</span>
                <span class="s1">t.run();</span>
                <span class="s1">if (!t.ended) {</span>
                    <span class="s1">t.once('end', function () { nextTick(next); });</span>
                    <span class="s1">return;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">self.emit('done');</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">return output;</span>
<span class="s1">};</span>

<span class="s1">Results.prototype.push = function (t) {</span>
    <span class="s1">var self = this;</span>
    <span class="s1">$push(self.tests, t);</span>
    <span class="s1">self._watch(t);</span>
    <span class="s1">self.emit('_push', t);</span>
<span class="s1">};</span>

<span class="s1">Results.prototype.only = function (t) {</span>
    <span class="s1">this._only = t;</span>
<span class="s1">};</span>

<span class="s1">Results.prototype._watch = function (t) {</span>
    <span class="s1">var self = this;</span>
    <span class="s1">var write = function (s) { self._stream.queue(s); };</span>
    <span class="s1">t.once('prerun', function () {</span>
        <span class="s1">var premsg = '';</span>
        <span class="s1">if (t._skip) {</span>
            <span class="s1">premsg = 'SKIP ';</span>
        <span class="s1">} else if (t._todo) {</span>
            <span class="s1">premsg = 'TODO ';</span>
        <span class="s1">}</span>
        <span class="s1">write('# ' + premsg + coalesceWhiteSpaces(t.name) + '\n');</span>
    <span class="s1">});</span>

    <span class="s1">t.on('result', function (res) {</span>
        <span class="s1">if (typeof res === 'string') {</span>
            <span class="s1">write('# ' + res + '\n');</span>
            <span class="s1">return;</span>
        <span class="s1">}</span>
        <span class="s1">write(encodeResult(res, self.count + 1));</span>
        <span class="s1">self.count++;</span>

        <span class="s1">if (res.ok || res.todo) {</span>
            <span class="s1">self.pass++;</span>
        <span class="s1">} else {</span>
            <span class="s1">self.fail++;</span>
            <span class="s1">self.emit('fail');</span>
        <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">t.on('test', function (st) { self._watch(st); });</span>
<span class="s1">};</span>

<span class="s1">Results.prototype.close = function () {</span>
    <span class="s1">var self = this;</span>
    <span class="s1">if (self.closed) { self._stream.emit('error', new Error('ALREADY CLOSED')); }</span>
    <span class="s1">self.closed = true;</span>
    <span class="s1">var write = function (s) { self._stream.queue(s); };</span>

    <span class="s1">write('\n1..' + self.count + '\n');</span>
    <span class="s1">write('# tests ' + self.count + '\n');</span>
    <span class="s1">write('# pass  ' + (self.pass + self.todo) + '\n');</span>
    <span class="s1">if (self.todo) { write('# todo  ' + self.todo + '\n'); }</span>
    <span class="s1">if (self.fail) {</span>
        <span class="s1">write('# fail  ' + self.fail + '\n');</span>
    <span class="s1">} else {</span>
        <span class="s1">write('\n# ok\n');</span>
    <span class="s1">}</span>

    <span class="s1">self._stream.queue(null);</span>
<span class="s1">};</span>

<span class="s1">function encodeResult(res, count) {</span>
    <span class="s1">var output = '';</span>
    <span class="s1">output += (res.ok ? 'ok ' : 'not ok ') + count;</span>
    <span class="s1">output += res.name ? ' ' + coalesceWhiteSpaces(res.name) : '';</span>

    <span class="s1">if (res.skip) {</span>
        <span class="s1">output += ' # SKIP' + (typeof res.skip === 'string' ? ' ' + coalesceWhiteSpaces(res.skip) : '');</span>
    <span class="s1">} else if (res.todo) {</span>
        <span class="s1">output += ' # TODO' + (typeof res.todo === 'string' ? ' ' + coalesceWhiteSpaces(res.todo) : '');</span>
    <span class="s1">}</span>

    <span class="s1">output += '\n';</span>
    <span class="s1">if (res.ok) { return output; }</span>

    <span class="s1">var outer = '  ';</span>
    <span class="s1">var inner = outer + '  ';</span>
    <span class="s1">output += outer + '---\n';</span>
    <span class="s1">output += inner + 'operator: ' + res.operator + '\n';</span>

    <span class="s1">if (has(res, 'expected') || has(res, 'actual')) {</span>
        <span class="s1">var ex = inspect(res.expected, { depth: res.objectPrintDepth });</span>
        <span class="s1">var ac = inspect(res.actual, { depth: res.objectPrintDepth });</span>

        <span class="s1">if (Math.max(ex.length, ac.length) &gt; 65 || invalidYaml(ex) || invalidYaml(ac)) {</span>
            <span class="s1">output += inner + 'expected: |-\n' + inner + '  ' + ex + '\n';</span>
            <span class="s1">output += inner + 'actual: |-\n' + inner + '  ' + ac + '\n';</span>
        <span class="s1">} else {</span>
            <span class="s1">output += inner + 'expected: ' + ex + '\n';</span>
            <span class="s1">output += inner + 'actual:   ' + ac + '\n';</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">if (res.at) {</span>
        <span class="s1">output += inner + 'at: ' + res.at + '\n';</span>
    <span class="s1">}</span>

    <span class="s1">var actualStack = res.actual &amp;&amp; (typeof res.actual === 'object' || typeof res.actual === 'function') ? res.actual.stack : undefined;</span>
    <span class="s1">var errorStack = res.error &amp;&amp; res.error.stack;</span>
    <span class="s1">var stack = defined(actualStack, errorStack);</span>
    <span class="s1">if (stack) {</span>
        <span class="s1">var lines = $split(String(stack), '\n');</span>
        <span class="s1">output += inner + 'stack: |-\n';</span>
        <span class="s1">for (var i = 0; i &lt; lines.length; i++) {</span>
            <span class="s1">output += inner + '  ' + lines[i] + '\n';</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">output += outer + '...\n';</span>
    <span class="s1">return output;</span>
<span class="s1">}</span>

<span class="s1">function getNextTest(results) {</span>
    <span class="s1">if (!results._only) {</span>
        <span class="s1">return $shift(results.tests);</span>
    <span class="s1">}</span>

    <span class="s1">do {</span>
        <span class="s1">var t = $shift(results.tests);</span>
        <span class="s1">if (t &amp;&amp; results._only === t) {</span>
            <span class="s1">return t;</span>
        <span class="s1">}</span>
    <span class="s1">} while (results.tests.length !== 0);</span>

    <span class="s1">return void undefined;</span>
<span class="s1">}</span>

<span class="s1">function invalidYaml(str) {</span>
    <span class="s1">return regexpTest(yamlIndicators, str);</span>
<span class="s1">}</span>

<span class="s1">}).call(this)}).call(this,require('_process'),require(&quot;timers&quot;).setImmediate)</span>

<span class="s1">},{&quot;_process&quot;:79,&quot;call-bind/callBound&quot;:11,&quot;defined&quot;:17,&quot;events&quot;:33,&quot;has&quot;:45,&quot;inherits&quot;:47,&quot;object-inspect&quot;:65,&quot;resumer&quot;:99,&quot;through&quot;:110,&quot;timers&quot;:111}],109:[function(require,module,exports){</span>
<span class="s1">(function (process,setImmediate,__dirname){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">var deepEqual = require('deep-equal');</span>
<span class="s1">var defined = require('defined');</span>
<span class="s1">var path = require('path');</span>
<span class="s1">var inherits = require('inherits');</span>
<span class="s1">var EventEmitter = require('events').EventEmitter;</span>
<span class="s1">var has = require('has');</span>
<span class="s1">var isRegExp = require('is-regex');</span>
<span class="s1">var trim = require('string.prototype.trim');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>
<span class="s1">var forEach = require('for-each');</span>
<span class="s1">var inspect = require('object-inspect');</span>
<span class="s1">var is = require('object-is');</span>
<span class="s1">var objectKeys = require('object-keys');</span>
<span class="s1">var every = require('array.prototype.every');</span>

<span class="s1">var isEnumerable = callBound('Object.prototype.propertyIsEnumerable');</span>
<span class="s1">var toLowerCase = callBound('String.prototype.toLowerCase');</span>
<span class="s1">var isProto = callBound('Object.prototype.isPrototypeOf');</span>
<span class="s1">var $exec = callBound('RegExp.prototype.exec');</span>
<span class="s1">var objectToString = callBound('Object.prototype.toString');</span>
<span class="s1">var $split = callBound('String.prototype.split');</span>
<span class="s1">var $replace = callBound('String.prototype.replace');</span>
<span class="s1">var $strSlice = callBound('String.prototype.slice');</span>
<span class="s1">var $push = callBound('Array.prototype.push');</span>
<span class="s1">var $shift = callBound('Array.prototype.shift');</span>

<span class="s1">module.exports = Test;</span>

<span class="s1">var nextTick = typeof setImmediate !== 'undefined'</span>
    <span class="s1">? setImmediate</span>
    <span class="s1">: process.nextTick;</span>
<span class="s1">var safeSetTimeout = setTimeout;</span>
<span class="s1">var safeClearTimeout = clearTimeout;</span>

<span class="s1">inherits(Test, EventEmitter);</span>

<span class="s1">// eslint-disable-next-line no-unused-vars</span>
<span class="s1">var getTestArgs = function (name_, opts_, cb_) {</span>
    <span class="s1">var name = '(anonymous)';</span>
    <span class="s1">var opts = {};</span>
    <span class="s1">var cb;</span>

    <span class="s1">for (var i = 0; i &lt; arguments.length; i++) {</span>
        <span class="s1">var arg = arguments[i];</span>
        <span class="s1">var t = typeof arg;</span>
        <span class="s1">if (t === 'string') {</span>
            <span class="s1">name = arg;</span>
        <span class="s1">} else if (t === 'object') {</span>
            <span class="s1">opts = arg || opts;</span>
        <span class="s1">} else if (t === 'function') {</span>
            <span class="s1">cb = arg;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">return {</span>
        <span class="s1">name: name,</span>
        <span class="s1">opts: opts,</span>
        <span class="s1">cb: cb</span>
    <span class="s1">};</span>
<span class="s1">};</span>

<span class="s1">function Test(name_, opts_, cb_) {</span>
    <span class="s1">if (!(this instanceof Test)) {</span>
        <span class="s1">return new Test(name_, opts_, cb_);</span>
    <span class="s1">}</span>

    <span class="s1">var args = getTestArgs(name_, opts_, cb_);</span>

    <span class="s1">this.readable = true;</span>
    <span class="s1">this.name = args.name || '(anonymous)';</span>
    <span class="s1">this.assertCount = 0;</span>
    <span class="s1">this.pendingCount = 0;</span>
    <span class="s1">this._skip = args.opts.skip || false;</span>
    <span class="s1">this._todo = args.opts.todo || false;</span>
    <span class="s1">this._timeout = args.opts.timeout;</span>
    <span class="s1">this._plan = undefined;</span>
    <span class="s1">this._cb = args.cb;</span>
    <span class="s1">this._progeny = [];</span>
    <span class="s1">this._teardown = [];</span>
    <span class="s1">this._ok = true;</span>
    <span class="s1">var depthEnvVar = process.env.NODE_TAPE_OBJECT_PRINT_DEPTH;</span>
    <span class="s1">if (args.opts.objectPrintDepth) {</span>
        <span class="s1">this._objectPrintDepth = args.opts.objectPrintDepth;</span>
    <span class="s1">} else if (depthEnvVar) {</span>
        <span class="s1">if (toLowerCase(depthEnvVar) === 'infinity') {</span>
            <span class="s1">this._objectPrintDepth = Infinity;</span>
        <span class="s1">} else {</span>
            <span class="s1">this._objectPrintDepth = depthEnvVar;</span>
        <span class="s1">}</span>
    <span class="s1">} else {</span>
        <span class="s1">this._objectPrintDepth = 5;</span>
    <span class="s1">}</span>

    <span class="s1">for (var prop in this) {</span>
        <span class="s1">this[prop] = (function bind(self, val) {</span>
            <span class="s1">if (typeof val === 'function') {</span>
                <span class="s1">return function bound() {</span>
                    <span class="s1">return val.apply(self, arguments);</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s1">return val;</span>
        <span class="s1">}(this, this[prop]));</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">Test.prototype.run = function run() {</span>
    <span class="s1">this.emit('prerun');</span>
    <span class="s1">if (!this._cb || this._skip) {</span>
        <span class="s1">this._end();</span>
        <span class="s1">return;</span>
    <span class="s1">}</span>
    <span class="s1">if (this._timeout != null) {</span>
        <span class="s1">this.timeoutAfter(this._timeout);</span>
    <span class="s1">}</span>

    <span class="s1">var callbackReturn = this._cb(this);</span>

    <span class="s1">if (</span>
        <span class="s1">typeof Promise === 'function'</span>
        <span class="s1">&amp;&amp; callbackReturn</span>
        <span class="s1">&amp;&amp; typeof callbackReturn.then === 'function'</span>
    <span class="s1">) {</span>
        <span class="s1">var self = this;</span>
        <span class="s1">Promise.resolve(callbackReturn).then(function onResolve() {</span>
            <span class="s1">if (!self.calledEnd) {</span>
                <span class="s1">self.end();</span>
            <span class="s1">}</span>
        <span class="s1">})['catch'](function onError(err) {</span>
            <span class="s1">if (err instanceof Error || objectToString(err) === '[object Error]') {</span>
                <span class="s1">self.ifError(err);</span>
            <span class="s1">} else {</span>
                <span class="s1">self.fail(err);</span>
            <span class="s1">}</span>
            <span class="s1">self.end();</span>
        <span class="s1">});</span>
        <span class="s1">return;</span>
    <span class="s1">}</span>

    <span class="s1">this.emit('run');</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.test = function test(name, opts, cb) {</span>
    <span class="s1">var self = this;</span>
    <span class="s1">var t = new Test(name, opts, cb);</span>
    <span class="s1">$push(this._progeny, t);</span>
    <span class="s1">this.pendingCount++;</span>
    <span class="s1">this.emit('test', t);</span>
    <span class="s1">t.on('prerun', function () {</span>
        <span class="s1">self.assertCount++;</span>
    <span class="s1">});</span>

    <span class="s1">if (!self._pendingAsserts()) {</span>
        <span class="s1">nextTick(function () {</span>
            <span class="s1">self._end();</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s1">nextTick(function () {</span>
        <span class="s1">if (!self._plan &amp;&amp; self.pendingCount == self._progeny.length) {</span>
            <span class="s1">self._end();</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.comment = function comment(msg) {</span>
    <span class="s1">var that = this;</span>
    <span class="s1">forEach($split(trim(msg), '\n'), function (aMsg) {</span>
        <span class="s1">that.emit('result', $replace(trim(aMsg), /^#\s*/, ''));</span>
    <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.plan = function plan(n) {</span>
    <span class="s1">this._plan = n;</span>
    <span class="s1">this.emit('plan', n);</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.timeoutAfter = function timeoutAfter(ms) {</span>
    <span class="s1">if (!ms) { throw new Error('timeoutAfter requires a timespan'); }</span>
    <span class="s1">var self = this;</span>
    <span class="s1">var timeout = safeSetTimeout(function () {</span>
        <span class="s1">self.fail(self.name + ' timed out after ' + ms + 'ms');</span>
        <span class="s1">self.end();</span>
    <span class="s1">}, ms);</span>
    <span class="s1">this.once('end', function () {</span>
        <span class="s1">safeClearTimeout(timeout);</span>
    <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.end = function end(err) {</span>
    <span class="s1">if (arguments.length &gt;= 1 &amp;&amp; !!err) {</span>
        <span class="s1">this.ifError(err);</span>
    <span class="s1">}</span>

    <span class="s1">if (this.calledEnd) {</span>
        <span class="s1">this.fail('.end() already called');</span>
    <span class="s1">}</span>
    <span class="s1">this.calledEnd = true;</span>
    <span class="s1">this._end();</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.teardown = function teardown(fn) {</span>
    <span class="s1">if (typeof fn !== 'function') {</span>
        <span class="s1">this.fail('teardown: ' + inspect(fn) + ' is not a function');</span>
    <span class="s1">} else {</span>
        <span class="s1">this._teardown.push(fn);</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Test.prototype._end = function _end(err) {</span>
    <span class="s1">var self = this;</span>

    <span class="s1">if (!this._cb &amp;&amp; !this._todo &amp;&amp; !this._skip) {</span>
        <span class="s1">this.fail('# TODO ' + this.name);</span>
    <span class="s1">}</span>

    <span class="s1">if (this._progeny.length) {</span>
        <span class="s1">var t = $shift(this._progeny);</span>
        <span class="s1">t.on('end', function () { self._end(); });</span>
        <span class="s1">t.run();</span>
        <span class="s1">return;</span>
    <span class="s1">}</span>

    <span class="s1">function next() {</span>
        <span class="s1">if (self._teardown.length === 0) {</span>
            <span class="s1">completeEnd();</span>
            <span class="s1">return;</span>
        <span class="s1">}</span>
        <span class="s1">var fn = self._teardown.shift();</span>
        <span class="s1">var res;</span>
        <span class="s1">try {</span>
            <span class="s1">res = fn();</span>
        <span class="s1">} catch (e) {</span>
            <span class="s1">self.fail(e);</span>
        <span class="s1">}</span>
        <span class="s1">if (res &amp;&amp; typeof res.then === 'function') {</span>
            <span class="s1">res.then(next, function (_err) {</span>
                <span class="s1">// TODO: wth?</span>
                <span class="s1">err = err || _err;</span>
            <span class="s1">});</span>
        <span class="s1">} else {</span>
            <span class="s1">next();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">next();</span>

    <span class="s1">function completeEnd() {</span>
        <span class="s1">if (!self.ended) { self.emit('end'); }</span>
        <span class="s1">var pendingAsserts = self._pendingAsserts();</span>
        <span class="s1">if (!self._planError &amp;&amp; self._plan !== undefined &amp;&amp; pendingAsserts) {</span>
            <span class="s1">self._planError = true;</span>
            <span class="s1">self.fail('plan != count', {</span>
                <span class="s1">expected: self._plan,</span>
                <span class="s1">actual: self.assertCount</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">self.ended = true;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Test.prototype._exit = function _exit() {</span>
    <span class="s1">if (this._plan !== undefined &amp;&amp; !this._planError &amp;&amp; this.assertCount !== this._plan) {</span>
        <span class="s1">this._planError = true;</span>
        <span class="s1">this.fail('plan != count', {</span>
            <span class="s1">expected: this._plan,</span>
            <span class="s1">actual: this.assertCount,</span>
            <span class="s1">exiting: true</span>
        <span class="s1">});</span>
    <span class="s1">} else if (!this.ended) {</span>
        <span class="s1">this.fail('test exited without ending: ' + this.name, {</span>
            <span class="s1">exiting: true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Test.prototype._pendingAsserts = function _pendingAsserts() {</span>
    <span class="s1">if (this._plan === undefined) {</span>
        <span class="s1">return 1;</span>
    <span class="s1">}</span>
    <span class="s1">return this._plan - (this._progeny.length + this.assertCount);</span>
<span class="s1">};</span>

<span class="s1">Test.prototype._assert = function assert(ok, opts) {</span>
    <span class="s1">var self = this;</span>
    <span class="s1">var extra = opts.extra || {};</span>

    <span class="s1">ok = !!ok || !!extra.skip;</span>

    <span class="s1">var name = defined(extra.message, opts.message, '(unnamed assert)');</span>
    <span class="s1">if (this.calledEnd &amp;&amp; opts.operator !== 'fail') {</span>
        <span class="s1">this.fail('.end() already called: ' + name);</span>
        <span class="s1">return;</span>
    <span class="s1">}</span>

    <span class="s1">var res = {</span>
        <span class="s1">id: self.assertCount++,</span>
        <span class="s1">ok: ok,</span>
        <span class="s1">skip: defined(extra.skip, opts.skip),</span>
        <span class="s1">todo: defined(extra.todo, opts.todo, self._todo),</span>
        <span class="s1">name: name,</span>
        <span class="s1">operator: defined(extra.operator, opts.operator),</span>
        <span class="s1">objectPrintDepth: self._objectPrintDepth</span>
    <span class="s1">};</span>
    <span class="s1">if (has(opts, 'actual') || has(extra, 'actual')) {</span>
        <span class="s1">res.actual = defined(extra.actual, opts.actual);</span>
    <span class="s1">}</span>
    <span class="s1">if (has(opts, 'expected') || has(extra, 'expected')) {</span>
        <span class="s1">res.expected = defined(extra.expected, opts.expected);</span>
    <span class="s1">}</span>
    <span class="s1">this._ok = !!(this._ok &amp;&amp; ok);</span>

    <span class="s1">if (!ok &amp;&amp; !res.todo) {</span>
        <span class="s1">res.error = defined(extra.error, opts.error, new Error(res.name));</span>
    <span class="s1">}</span>

    <span class="s1">if (!ok) {</span>
        <span class="s1">var e = new Error('exception');</span>
        <span class="s1">var err = $split(e.stack || '', '\n');</span>
        <span class="s1">var dir = __dirname + path.sep;</span>

        <span class="s1">for (var i = 0; i &lt; err.length; i++) {</span>
            <span class="s1">/*</span>
                <span class="s1">Stack trace lines may resemble one of the following. We need</span>
                <span class="s1">to correctly extract a function name (if any) and path / line</span>
                <span class="s1">number for each line.</span>

                    <span class="s1">at myFunction (/path/to/file.js:123:45)</span>
                    <span class="s1">at myFunction (/path/to/file.other-ext:123:45)</span>
                    <span class="s1">at myFunction (/path to/file.js:123:45)</span>
                    <span class="s1">at myFunction (C:\path\to\file.js:123:45)</span>
                    <span class="s1">at myFunction (/path/to/file.js:123)</span>
                    <span class="s1">at Test.&lt;anonymous&gt; (/path/to/file.js:123:45)</span>
                    <span class="s1">at Test.bound [as run] (/path/to/file.js:123:45)</span>
                    <span class="s1">at /path/to/file.js:123:45</span>

                <span class="s1">Regex has three parts. First is non-capturing group for 'at '</span>
                <span class="s1">(plus anything preceding it).</span>

                    <span class="s1">/^(?:[^\s]*\s*\bat\s+)/</span>

                <span class="s1">Second captures function call description (optional). This is</span>
                <span class="s1">not necessarily a valid JS function name, but just what the</span>
                <span class="s1">stack trace is using to represent a function call. It may look</span>
                <span class="s1">like `&lt;anonymous&gt;` or 'Test.bound [as run]'.</span>

                <span class="s1">For our purposes, we assume that, if there is a function</span>
                <span class="s1">name, it's everything leading up to the first open</span>
                <span class="s1">parentheses (trimmed) before our pathname.</span>

                    <span class="s1">/(?:(.*)\s+\()?/</span>

                <span class="s1">Last part captures file path plus line no (and optional</span>
                <span class="s1">column no).</span>

                    <span class="s1">/((?:\/|[a-zA-Z]:\\)[^:\)]+:(\d+)(?::(\d+))?)\)?/</span>
            <span class="s1">*/</span>
            <span class="s1">var re = /^(?:[^\s]*\s*\bat\s+)(?:(.*)\s+\()?((?:\/|[a-zA-Z]:\\)[^:)]+:(\d+)(?::(\d+))?)\)?$/;</span>
            <span class="s1">var lineWithTokens = $replace($replace(err[i], process.cwd(), '/$CWD'), __dirname, '/$TEST');</span>
            <span class="s1">var m = re.exec(lineWithTokens);</span>

            <span class="s1">if (!m) {</span>
                <span class="s1">continue;</span>
            <span class="s1">}</span>

            <span class="s1">var callDescription = m[1] || '&lt;anonymous&gt;';</span>
            <span class="s1">var filePath = $replace($replace(m[2], '/$CWD', process.cwd()), '/$TEST', __dirname);</span>

            <span class="s1">if ($strSlice(filePath, 0, dir.length) === dir) {</span>
                <span class="s1">continue;</span>
            <span class="s1">}</span>

            <span class="s1">// Function call description may not (just) be a function name.</span>
            <span class="s1">// Try to extract function name by looking at first &quot;word&quot; only.</span>
            <span class="s1">res.functionName = $split(callDescription, /\s+/)[0];</span>
            <span class="s1">res.file = filePath;</span>
            <span class="s1">res.line = Number(m[3]);</span>
            <span class="s1">if (m[4]) { res.column = Number(m[4]); }</span>

            <span class="s1">res.at = callDescription + ' (' + filePath + ')';</span>
            <span class="s1">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">self.emit('result', res);</span>

    <span class="s1">var pendingAsserts = self._pendingAsserts();</span>
    <span class="s1">if (!pendingAsserts) {</span>
        <span class="s1">if (extra.exiting) {</span>
            <span class="s1">self._end();</span>
        <span class="s1">} else {</span>
            <span class="s1">nextTick(function () {</span>
                <span class="s1">self._end();</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">if (!self._planError &amp;&amp; pendingAsserts &lt; 0) {</span>
        <span class="s1">self._planError = true;</span>
        <span class="s1">self.fail('plan != count', {</span>
            <span class="s1">expected: self._plan,</span>
            <span class="s1">actual: self._plan - pendingAsserts</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.fail = function fail(msg, extra) {</span>
    <span class="s1">this._assert(false, {</span>
        <span class="s1">message: msg,</span>
        <span class="s1">operator: 'fail',</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.pass = function pass(msg, extra) {</span>
    <span class="s1">this._assert(true, {</span>
        <span class="s1">message: msg,</span>
        <span class="s1">operator: 'pass',</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.skip = function skip(msg, extra) {</span>
    <span class="s1">this._assert(true, {</span>
        <span class="s1">message: msg,</span>
        <span class="s1">operator: 'skip',</span>
        <span class="s1">skip: true,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">var testAssert = function assert(value, msg, extra) {</span>
    <span class="s1">this._assert(value, {</span>
        <span class="s1">message: defined(msg, 'should be truthy'),</span>
        <span class="s1">operator: 'ok',</span>
        <span class="s1">expected: true,</span>
        <span class="s1">actual: value,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">};</span>
<span class="s1">Test.prototype.ok</span>
<span class="s1">= Test.prototype['true']</span>
<span class="s1">= Test.prototype.assert</span>
<span class="s1">= testAssert;</span>

<span class="s1">function notOK(value, msg, extra) {</span>
    <span class="s1">this._assert(!value, {</span>
        <span class="s1">message: defined(msg, 'should be falsy'),</span>
        <span class="s1">operator: 'notOk',</span>
        <span class="s1">expected: false,</span>
        <span class="s1">actual: value,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">Test.prototype.notOk</span>
<span class="s1">= Test.prototype['false']</span>
<span class="s1">= Test.prototype.notok</span>
<span class="s1">= notOK;</span>

<span class="s1">function error(err, msg, extra) {</span>
    <span class="s1">this._assert(!err, {</span>
        <span class="s1">message: defined(msg, String(err)),</span>
        <span class="s1">operator: 'error',</span>
        <span class="s1">error: err,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">Test.prototype.error</span>
<span class="s1">= Test.prototype.ifError</span>
<span class="s1">= Test.prototype.ifErr</span>
<span class="s1">= Test.prototype.iferror</span>
<span class="s1">= error;</span>

<span class="s1">function strictEqual(a, b, msg, extra) {</span>
    <span class="s1">if (arguments.length &lt; 2) {</span>
        <span class="s1">throw new TypeError('two arguments must be provided to compare');</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(is(a, b), {</span>
        <span class="s1">message: defined(msg, 'should be strictly equal'),</span>
        <span class="s1">operator: 'equal',</span>
        <span class="s1">actual: a,</span>
        <span class="s1">expected: b,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">Test.prototype.equal</span>
<span class="s1">= Test.prototype.equals</span>
<span class="s1">= Test.prototype.isEqual</span>
<span class="s1">= Test.prototype.strictEqual</span>
<span class="s1">= Test.prototype.strictEquals</span>
<span class="s1">= Test.prototype.is</span>
<span class="s1">= strictEqual;</span>

<span class="s1">function notStrictEqual(a, b, msg, extra) {</span>
    <span class="s1">if (arguments.length &lt; 2) {</span>
        <span class="s1">throw new TypeError('two arguments must be provided to compare');</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(!is(a, b), {</span>
        <span class="s1">message: defined(msg, 'should not be strictly equal'),</span>
        <span class="s1">operator: 'notEqual',</span>
        <span class="s1">actual: a,</span>
        <span class="s1">expected: b,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">Test.prototype.notEqual</span>
<span class="s1">= Test.prototype.notEquals</span>
<span class="s1">= Test.prototype.isNotEqual</span>
<span class="s1">= Test.prototype.doesNotEqual</span>
<span class="s1">= Test.prototype.isInequal</span>
<span class="s1">= Test.prototype.notStrictEqual</span>
<span class="s1">= Test.prototype.notStrictEquals</span>
<span class="s1">= Test.prototype.isNot</span>
<span class="s1">= Test.prototype.not</span>
<span class="s1">= notStrictEqual;</span>

<span class="s1">function looseEqual(a, b, msg, extra) {</span>
    <span class="s1">if (arguments.length &lt; 2) {</span>
        <span class="s1">throw new TypeError('two arguments must be provided to compare');</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(a == b, {</span>
        <span class="s1">message: defined(msg, 'should be loosely equal'),</span>
        <span class="s1">operator: 'looseEqual',</span>
        <span class="s1">actual: a,</span>
        <span class="s1">expected: b,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">Test.prototype.looseEqual</span>
<span class="s1">= Test.prototype.looseEquals</span>
<span class="s1">= looseEqual;</span>

<span class="s1">function notLooseEqual(a, b, msg, extra) {</span>
    <span class="s1">if (arguments.length &lt; 2) {</span>
        <span class="s1">throw new TypeError('two arguments must be provided to compare');</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(a != b, {</span>
        <span class="s1">message: defined(msg, 'should not be loosely equal'),</span>
        <span class="s1">operator: 'notLooseEqual',</span>
        <span class="s1">actual: a,</span>
        <span class="s1">expected: b,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">Test.prototype.notLooseEqual</span>
<span class="s1">= Test.prototype.notLooseEquals</span>
<span class="s1">= notLooseEqual;</span>

<span class="s1">function tapeDeepEqual(a, b, msg, extra) {</span>
    <span class="s1">if (arguments.length &lt; 2) {</span>
        <span class="s1">throw new TypeError('two arguments must be provided to compare');</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(deepEqual(a, b, { strict: true }), {</span>
        <span class="s1">message: defined(msg, 'should be deeply equivalent'),</span>
        <span class="s1">operator: 'deepEqual',</span>
        <span class="s1">actual: a,</span>
        <span class="s1">expected: b,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">Test.prototype.deepEqual</span>
<span class="s1">= Test.prototype.deepEquals</span>
<span class="s1">= Test.prototype.isEquivalent</span>
<span class="s1">= Test.prototype.same</span>
<span class="s1">= tapeDeepEqual;</span>

<span class="s1">function notDeepEqual(a, b, msg, extra) {</span>
    <span class="s1">if (arguments.length &lt; 2) {</span>
        <span class="s1">throw new TypeError('two arguments must be provided to compare');</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(!deepEqual(a, b, { strict: true }), {</span>
        <span class="s1">message: defined(msg, 'should not be deeply equivalent'),</span>
        <span class="s1">operator: 'notDeepEqual',</span>
        <span class="s1">actual: a,</span>
        <span class="s1">expected: b,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">Test.prototype.notDeepEqual</span>
<span class="s1">= Test.prototype.notDeepEquals</span>
<span class="s1">= Test.prototype.notEquivalent</span>
<span class="s1">= Test.prototype.notDeeply</span>
<span class="s1">= Test.prototype.notSame</span>
<span class="s1">= Test.prototype.isNotDeepEqual</span>
<span class="s1">= Test.prototype.isNotDeeply</span>
<span class="s1">= Test.prototype.isNotEquivalent</span>
<span class="s1">= Test.prototype.isInequivalent</span>
<span class="s1">= notDeepEqual;</span>

<span class="s1">function deepLooseEqual(a, b, msg, extra) {</span>
    <span class="s1">if (arguments.length &lt; 2) {</span>
        <span class="s1">throw new TypeError('two arguments must be provided to compare');</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(deepEqual(a, b), {</span>
        <span class="s1">message: defined(msg, 'should be loosely deeply equivalent'),</span>
        <span class="s1">operator: 'deepLooseEqual',</span>
        <span class="s1">actual: a,</span>
        <span class="s1">expected: b,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">Test.prototype.deepLooseEqual</span>
<span class="s1">= deepLooseEqual;</span>

<span class="s1">function notDeepLooseEqual(a, b, msg, extra) {</span>
    <span class="s1">if (arguments.length &lt; 2) {</span>
        <span class="s1">throw new TypeError('two arguments must be provided to compare');</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(!deepEqual(a, b), {</span>
        <span class="s1">message: defined(msg, 'should not be loosely deeply equivalent'),</span>
        <span class="s1">operator: 'notDeepLooseEqual',</span>
        <span class="s1">actual: a,</span>
        <span class="s1">expected: b,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">Test.prototype.notDeepLooseEqual</span>
<span class="s1">= notDeepLooseEqual;</span>

<span class="s1">Test.prototype['throws'] = function (fn, expected, msg, extra) {</span>
    <span class="s1">if (typeof expected === 'string') {</span>
        <span class="s1">msg = expected;</span>
        <span class="s1">expected = undefined;</span>
    <span class="s1">}</span>

    <span class="s1">var caught;</span>

    <span class="s1">try {</span>
        <span class="s1">fn();</span>
    <span class="s1">} catch (err) {</span>
        <span class="s1">caught = { error: err };</span>
        <span class="s1">if (Object(err) === err &amp;&amp; (!isEnumerable(err, 'message') || !has(err, 'message'))) {</span>
            <span class="s1">var message = err.message;</span>
            <span class="s1">delete err.message;</span>
            <span class="s1">err.message = message;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">var passed = caught;</span>

    <span class="s1">if (caught) {</span>
        <span class="s1">if (typeof expected === 'string' &amp;&amp; caught.error &amp;&amp; caught.error.message === expected) {</span>
            <span class="s1">throw new TypeError('The &quot;error/message&quot; argument is ambiguous. The error message ' + inspect(expected) + ' is identical to the message.');</span>
        <span class="s1">}</span>
        <span class="s1">if (typeof expected === 'function') {</span>
            <span class="s1">if (typeof expected.prototype !== 'undefined' &amp;&amp; caught.error instanceof expected) {</span>
                <span class="s1">passed = true;</span>
            <span class="s1">} else if (isProto(Error, expected)) {</span>
                <span class="s1">passed = false;</span>
            <span class="s1">} else {</span>
                <span class="s1">passed = expected.call({}, caught.error) === true;</span>
            <span class="s1">}</span>
        <span class="s1">} else if (isRegExp(expected)) {</span>
            <span class="s1">passed = $exec(expected, caught.error) !== null;</span>
            <span class="s1">expected = inspect(expected);</span>
        <span class="s1">} else if (expected &amp;&amp; typeof expected === 'object') { // Handle validation objects.</span>
            <span class="s1">var keys = objectKeys(expected);</span>
            <span class="s1">// Special handle errors to make sure the name and the message are compared as well.</span>
            <span class="s1">if (expected instanceof Error) {</span>
                <span class="s1">$push(keys, 'name', 'message');</span>
            <span class="s1">} else if (keys.length === 0) {</span>
                <span class="s1">throw new TypeError('`throws` validation object must not be empty');</span>
            <span class="s1">}</span>
            <span class="s1">passed = every(keys, function (key) {</span>
                <span class="s1">if (typeof caught.error[key] === 'string' &amp;&amp; isRegExp(expected[key]) &amp;&amp; $exec(expected[key], caught.error[key]) !== null) {</span>
                    <span class="s1">return true;</span>
                <span class="s1">}</span>
                <span class="s1">if (key in caught.error &amp;&amp; deepEqual(caught.error[key], expected[key], { strict: true })) {</span>
                    <span class="s1">return true;</span>
                <span class="s1">}</span>
                <span class="s1">return false;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">this._assert(!!passed, {</span>
        <span class="s1">message: defined(msg, 'should throw'),</span>
        <span class="s1">operator: 'throws',</span>
        <span class="s1">actual: caught &amp;&amp; caught.error,</span>
        <span class="s1">expected: expected,</span>
        <span class="s1">error: !passed &amp;&amp; caught &amp;&amp; caught.error,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.doesNotThrow = function doesNotThrow(fn, expected, msg, extra) {</span>
    <span class="s1">if (typeof expected === 'string') {</span>
        <span class="s1">msg = expected;</span>
        <span class="s1">expected = undefined;</span>
    <span class="s1">}</span>
    <span class="s1">var caught;</span>
    <span class="s1">try {</span>
        <span class="s1">fn();</span>
    <span class="s1">} catch (err) {</span>
        <span class="s1">caught = { error: err };</span>
    <span class="s1">}</span>
    <span class="s1">this._assert(!caught, {</span>
        <span class="s1">message: defined(msg, 'should not throw'),</span>
        <span class="s1">operator: 'throws',</span>
        <span class="s1">actual: caught &amp;&amp; caught.error,</span>
        <span class="s1">expected: expected,</span>
        <span class="s1">error: caught &amp;&amp; caught.error,</span>
        <span class="s1">extra: extra</span>
    <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.match = function match(string, regexp, msg, extra) {</span>
    <span class="s1">if (!isRegExp(regexp)) {</span>
        <span class="s1">this._assert(false, {</span>
            <span class="s1">message: defined(msg, 'The &quot;regexp&quot; argument must be an instance of RegExp. Received type ' + typeof regexp + ' (' + inspect(regexp) + ')'),</span>
            <span class="s1">operator: 'match',</span>
            <span class="s1">actual: objectToString(regexp),</span>
            <span class="s1">expected: '[object RegExp]',</span>
            <span class="s1">extra: extra</span>
        <span class="s1">});</span>
    <span class="s1">} else if (typeof string !== 'string') {</span>
        <span class="s1">this._assert(false, {</span>
            <span class="s1">message: defined(msg, 'The &quot;string&quot; argument must be of type string. Received type ' + typeof string + ' (' + inspect(string) + ')'),</span>
            <span class="s1">operator: 'match',</span>
            <span class="s1">actual: string === null ? null : typeof string,</span>
            <span class="s1">expected: 'string',</span>
            <span class="s1">extra: extra</span>
        <span class="s1">});</span>
    <span class="s1">} else {</span>
        <span class="s1">var matches = $exec(regexp, string) !== null;</span>
        <span class="s1">var message = defined(</span>
            <span class="s1">msg,</span>
            <span class="s1">'The input ' + (matches ? 'matched' : 'did not match') + ' the regular expression ' + inspect(regexp) + '. Input: ' + inspect(string)</span>
        <span class="s1">);</span>
        <span class="s1">this._assert(matches, {</span>
            <span class="s1">message: message,</span>
            <span class="s1">operator: 'match',</span>
            <span class="s1">actual: string,</span>
            <span class="s1">expected: regexp,</span>
            <span class="s1">extra: extra</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">Test.prototype.doesNotMatch = function doesNotMatch(string, regexp, msg, extra) {</span>
    <span class="s1">if (!isRegExp(regexp)) {</span>
        <span class="s1">this._assert(false, {</span>
            <span class="s1">message: defined(msg, 'The &quot;regexp&quot; argument must be an instance of RegExp. Received type ' + typeof regexp + ' (' + inspect(regexp) + ')'),</span>
            <span class="s1">operator: 'doesNotMatch',</span>
            <span class="s1">actual: objectToString(regexp),</span>
            <span class="s1">expected: '[object RegExp]',</span>
            <span class="s1">extra: extra</span>
        <span class="s1">});</span>
    <span class="s1">} else if (typeof string !== 'string') {</span>
        <span class="s1">this._assert(false, {</span>
            <span class="s1">message: defined(msg, 'The &quot;string&quot; argument must be of type string. Received type ' + typeof string + ' (' + inspect(string) + ')'),</span>
            <span class="s1">operator: 'doesNotMatch',</span>
            <span class="s1">actual: string === null ? null : typeof string,</span>
            <span class="s1">expected: 'string',</span>
            <span class="s1">extra: extra</span>
        <span class="s1">});</span>
    <span class="s1">} else {</span>
        <span class="s1">var matches = $exec(regexp, string) !== null;</span>
        <span class="s1">var message = defined(</span>
            <span class="s1">msg,</span>
            <span class="s1">'The input ' + (matches ? 'was expected to not match' : 'did not match') + ' the regular expression ' + inspect(regexp) + '. Input: ' + inspect(string)</span>
        <span class="s1">);</span>
        <span class="s1">this._assert(!matches, {</span>
            <span class="s1">message: message,</span>
            <span class="s1">operator: 'doesNotMatch',</span>
            <span class="s1">actual: string,</span>
            <span class="s1">expected: regexp,</span>
            <span class="s1">extra: extra</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">// eslint-disable-next-line no-unused-vars</span>
<span class="s1">Test.skip = function skip(name_, _opts, _cb) {</span>
    <span class="s1">var args = getTestArgs.apply(null, arguments);</span>
    <span class="s1">args.opts.skip = true;</span>
    <span class="s1">return new Test(args.name, args.opts, args.cb);</span>
<span class="s1">};</span>

<span class="s1">// vim: set softtabstop=4 shiftwidth=4:</span>

<span class="s1">}).call(this)}).call(this,require('_process'),require(&quot;timers&quot;).setImmediate,&quot;/node_modules/tape/lib&quot;)</span>

<span class="s1">},{&quot;_process&quot;:79,&quot;array.prototype.every&quot;:4,&quot;call-bind/callBound&quot;:11,&quot;deep-equal&quot;:14,&quot;defined&quot;:17,&quot;events&quot;:33,&quot;for-each&quot;:34,&quot;has&quot;:45,&quot;inherits&quot;:47,&quot;is-regex&quot;:55,&quot;object-inspect&quot;:65,&quot;object-is&quot;:67,&quot;object-keys&quot;:71,&quot;path&quot;:77,&quot;string.prototype.trim&quot;:103,&quot;timers&quot;:111}],110:[function(require,module,exports){</span>
<span class="s1">(function (process){(function (){</span>
<span class="s1">var Stream = require('stream')</span>

<span class="s1">// through</span>
<span class="s1">//</span>
<span class="s1">// a stream that does nothing but re-emit the input.</span>
<span class="s1">// useful for aggregating a series of changing but not ending streams into one stream)</span>

<span class="s1">exports = module.exports = through</span>
<span class="s1">through.through = through</span>

<span class="s1">//create a readable writable stream.</span>

<span class="s1">function through (write, end, opts) {</span>
  <span class="s1">write = write || function (data) { this.queue(data) }</span>
  <span class="s1">end = end || function () { this.queue(null) }</span>

  <span class="s1">var ended = false, destroyed = false, buffer = [], _ended = false</span>
  <span class="s1">var stream = new Stream()</span>
  <span class="s1">stream.readable = stream.writable = true</span>
  <span class="s1">stream.paused = false</span>

<span class="s1">//  stream.autoPause   = !(opts &amp;&amp; opts.autoPause   === false)</span>
  <span class="s1">stream.autoDestroy = !(opts &amp;&amp; opts.autoDestroy === false)</span>

  <span class="s1">stream.write = function (data) {</span>
    <span class="s1">write.call(this, data)</span>
    <span class="s1">return !stream.paused</span>
  <span class="s1">}</span>

  <span class="s1">function drain() {</span>
    <span class="s1">while(buffer.length &amp;&amp; !stream.paused) {</span>
      <span class="s1">var data = buffer.shift()</span>
      <span class="s1">if(null === data)</span>
        <span class="s1">return stream.emit('end')</span>
      <span class="s1">else</span>
        <span class="s1">stream.emit('data', data)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">stream.queue = stream.push = function (data) {</span>
<span class="s1">//    console.error(ended)</span>
    <span class="s1">if(_ended) return stream</span>
    <span class="s1">if(data === null) _ended = true</span>
    <span class="s1">buffer.push(data)</span>
    <span class="s1">drain()</span>
    <span class="s1">return stream</span>
  <span class="s1">}</span>

  <span class="s1">//this will be registered as the first 'end' listener</span>
  <span class="s1">//must call destroy next tick, to make sure we're after any</span>
  <span class="s1">//stream piped from here.</span>
  <span class="s1">//this is only a problem if end is not emitted synchronously.</span>
  <span class="s1">//a nicer way to do this is to make sure this is the last listener for 'end'</span>

  <span class="s1">stream.on('end', function () {</span>
    <span class="s1">stream.readable = false</span>
    <span class="s1">if(!stream.writable &amp;&amp; stream.autoDestroy)</span>
      <span class="s1">process.nextTick(function () {</span>
        <span class="s1">stream.destroy()</span>
      <span class="s1">})</span>
  <span class="s1">})</span>

  <span class="s1">function _end () {</span>
    <span class="s1">stream.writable = false</span>
    <span class="s1">end.call(stream)</span>
    <span class="s1">if(!stream.readable &amp;&amp; stream.autoDestroy)</span>
      <span class="s1">stream.destroy()</span>
  <span class="s1">}</span>

  <span class="s1">stream.end = function (data) {</span>
    <span class="s1">if(ended) return</span>
    <span class="s1">ended = true</span>
    <span class="s1">if(arguments.length) stream.write(data)</span>
    <span class="s1">_end() // will emit or queue</span>
    <span class="s1">return stream</span>
  <span class="s1">}</span>

  <span class="s1">stream.destroy = function () {</span>
    <span class="s1">if(destroyed) return</span>
    <span class="s1">destroyed = true</span>
    <span class="s1">ended = true</span>
    <span class="s1">buffer.length = 0</span>
    <span class="s1">stream.writable = stream.readable = false</span>
    <span class="s1">stream.emit('close')</span>
    <span class="s1">return stream</span>
  <span class="s1">}</span>

  <span class="s1">stream.pause = function () {</span>
    <span class="s1">if(stream.paused) return</span>
    <span class="s1">stream.paused = true</span>
    <span class="s1">return stream</span>
  <span class="s1">}</span>

  <span class="s1">stream.resume = function () {</span>
    <span class="s1">if(stream.paused) {</span>
      <span class="s1">stream.paused = false</span>
      <span class="s1">stream.emit('resume')</span>
    <span class="s1">}</span>
    <span class="s1">drain()</span>
    <span class="s1">//may have become paused again,</span>
    <span class="s1">//as drain emits 'data'.</span>
    <span class="s1">if(!stream.paused)</span>
      <span class="s1">stream.emit('drain')</span>
    <span class="s1">return stream</span>
  <span class="s1">}</span>
  <span class="s1">return stream</span>
<span class="s1">}</span>


<span class="s1">}).call(this)}).call(this,require('_process'))</span>

<span class="s1">},{&quot;_process&quot;:79,&quot;stream&quot;:101}],111:[function(require,module,exports){</span>
<span class="s1">(function (setImmediate,clearImmediate){(function (){</span>
<span class="s1">var nextTick = require('process/browser.js').nextTick;</span>
<span class="s1">var apply = Function.prototype.apply;</span>
<span class="s1">var slice = Array.prototype.slice;</span>
<span class="s1">var immediateIds = {};</span>
<span class="s1">var nextImmediateId = 0;</span>

<span class="s1">// DOM APIs, for completeness</span>

<span class="s1">exports.setTimeout = function() {</span>
  <span class="s1">return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);</span>
<span class="s1">};</span>
<span class="s1">exports.setInterval = function() {</span>
  <span class="s1">return new Timeout(apply.call(setInterval, window, arguments), clearInterval);</span>
<span class="s1">};</span>
<span class="s1">exports.clearTimeout =</span>
<span class="s1">exports.clearInterval = function(timeout) { timeout.close(); };</span>

<span class="s1">function Timeout(id, clearFn) {</span>
  <span class="s1">this._id = id;</span>
  <span class="s1">this._clearFn = clearFn;</span>
<span class="s1">}</span>
<span class="s1">Timeout.prototype.unref = Timeout.prototype.ref = function() {};</span>
<span class="s1">Timeout.prototype.close = function() {</span>
  <span class="s1">this._clearFn.call(window, this._id);</span>
<span class="s1">};</span>

<span class="s1">// Does not start the time, just sets up the members needed.</span>
<span class="s1">exports.enroll = function(item, msecs) {</span>
  <span class="s1">clearTimeout(item._idleTimeoutId);</span>
  <span class="s1">item._idleTimeout = msecs;</span>
<span class="s1">};</span>

<span class="s1">exports.unenroll = function(item) {</span>
  <span class="s1">clearTimeout(item._idleTimeoutId);</span>
  <span class="s1">item._idleTimeout = -1;</span>
<span class="s1">};</span>

<span class="s1">exports._unrefActive = exports.active = function(item) {</span>
  <span class="s1">clearTimeout(item._idleTimeoutId);</span>

  <span class="s1">var msecs = item._idleTimeout;</span>
  <span class="s1">if (msecs &gt;= 0) {</span>
    <span class="s1">item._idleTimeoutId = setTimeout(function onTimeout() {</span>
      <span class="s1">if (item._onTimeout)</span>
        <span class="s1">item._onTimeout();</span>
    <span class="s1">}, msecs);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">// That's not how node.js implements it but the exposed api is the same.</span>
<span class="s1">exports.setImmediate = typeof setImmediate === &quot;function&quot; ? setImmediate : function(fn) {</span>
  <span class="s1">var id = nextImmediateId++;</span>
  <span class="s1">var args = arguments.length &lt; 2 ? false : slice.call(arguments, 1);</span>

  <span class="s1">immediateIds[id] = true;</span>

  <span class="s1">nextTick(function onNextTick() {</span>
    <span class="s1">if (immediateIds[id]) {</span>
      <span class="s1">// fn.call() is faster so we optimize for the common use-case</span>
      <span class="s1">// @see http://jsperf.com/call-apply-segu</span>
      <span class="s1">if (args) {</span>
        <span class="s1">fn.apply(null, args);</span>
      <span class="s1">} else {</span>
        <span class="s1">fn.call(null);</span>
      <span class="s1">}</span>
      <span class="s1">// Prevent ids from leaking</span>
      <span class="s1">exports.clearImmediate(id);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s1">return id;</span>
<span class="s1">};</span>

<span class="s1">exports.clearImmediate = typeof clearImmediate === &quot;function&quot; ? clearImmediate : function(id) {</span>
  <span class="s1">delete immediateIds[id];</span>
<span class="s1">};</span>
<span class="s1">}).call(this)}).call(this,require(&quot;timers&quot;).setImmediate,require(&quot;timers&quot;).clearImmediate)</span>

<span class="s1">},{&quot;process/browser.js&quot;:79,&quot;timers&quot;:111}],112:[function(require,module,exports){</span>
<span class="s1">(function (global){(function (){</span>

<span class="s1">/**</span>
 <span class="s1">* Module exports.</span>
 <span class="s1">*/</span>

<span class="s1">module.exports = deprecate;</span>

<span class="s1">/**</span>
 <span class="s1">* Mark that a method should not be used.</span>
 <span class="s1">* Returns a modified function which warns once by default.</span>
 <span class="s1">*</span>
 <span class="s1">* If `localStorage.noDeprecation = true` is set, then it is a no-op.</span>
 <span class="s1">*</span>
 <span class="s1">* If `localStorage.throwDeprecation = true` is set, then deprecated functions</span>
 <span class="s1">* will throw an Error when invoked.</span>
 <span class="s1">*</span>
 <span class="s1">* If `localStorage.traceDeprecation = true` is set, then deprecated functions</span>
 <span class="s1">* will invoke `console.trace()` instead of `console.error()`.</span>
 <span class="s1">*</span>
 <span class="s1">* @param {Function} fn - the function to deprecate</span>
 <span class="s1">* @param {String} msg - the string to print to the console when `fn` is invoked</span>
 <span class="s1">* @returns {Function} a new &quot;deprecated&quot; version of `fn`</span>
 <span class="s1">* @api public</span>
 <span class="s1">*/</span>

<span class="s1">function deprecate (fn, msg) {</span>
  <span class="s1">if (config('noDeprecation')) {</span>
    <span class="s1">return fn;</span>
  <span class="s1">}</span>

  <span class="s1">var warned = false;</span>
  <span class="s1">function deprecated() {</span>
    <span class="s1">if (!warned) {</span>
      <span class="s1">if (config('throwDeprecation')) {</span>
        <span class="s1">throw new Error(msg);</span>
      <span class="s1">} else if (config('traceDeprecation')) {</span>
        <span class="s1">console.trace(msg);</span>
      <span class="s1">} else {</span>
        <span class="s1">console.warn(msg);</span>
      <span class="s1">}</span>
      <span class="s1">warned = true;</span>
    <span class="s1">}</span>
    <span class="s1">return fn.apply(this, arguments);</span>
  <span class="s1">}</span>

  <span class="s1">return deprecated;</span>
<span class="s1">}</span>

<span class="s1">/**</span>
 <span class="s1">* Checks `localStorage` for boolean values for the given `name`.</span>
 <span class="s1">*</span>
 <span class="s1">* @param {String} name</span>
 <span class="s1">* @returns {Boolean}</span>
 <span class="s1">* @api private</span>
 <span class="s1">*/</span>

<span class="s1">function config (name) {</span>
  <span class="s1">// accessing global.localStorage can trigger a DOMException in sandboxed iframes</span>
  <span class="s1">try {</span>
    <span class="s1">if (!global.localStorage) return false;</span>
  <span class="s1">} catch (_) {</span>
    <span class="s1">return false;</span>
  <span class="s1">}</span>
  <span class="s1">var val = global.localStorage[name];</span>
  <span class="s1">if (null == val) return false;</span>
  <span class="s1">return String(val).toLowerCase() === 'true';</span>
<span class="s1">}</span>

<span class="s1">}).call(this)}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})</span>

<span class="s1">},{}],113:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var isString = require('is-string');</span>
<span class="s1">var isNumber = require('is-number-object');</span>
<span class="s1">var isBoolean = require('is-boolean-object');</span>
<span class="s1">var isSymbol = require('is-symbol');</span>
<span class="s1">var isBigInt = require('is-bigint');</span>

<span class="s1">// eslint-disable-next-line consistent-return</span>
<span class="s1">module.exports = function whichBoxedPrimitive(value) {</span>
	<span class="s1">// eslint-disable-next-line eqeqeq</span>
	<span class="s1">if (value == null || (typeof value !== 'object' &amp;&amp; typeof value !== 'function')) {</span>
		<span class="s1">return null;</span>
	<span class="s1">}</span>
	<span class="s1">if (isString(value)) {</span>
		<span class="s1">return 'String';</span>
	<span class="s1">}</span>
	<span class="s1">if (isNumber(value)) {</span>
		<span class="s1">return 'Number';</span>
	<span class="s1">}</span>
	<span class="s1">if (isBoolean(value)) {</span>
		<span class="s1">return 'Boolean';</span>
	<span class="s1">}</span>
	<span class="s1">if (isSymbol(value)) {</span>
		<span class="s1">return 'Symbol';</span>
	<span class="s1">}</span>
	<span class="s1">if (isBigInt(value)) {</span>
		<span class="s1">return 'BigInt';</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">},{&quot;is-bigint&quot;:49,&quot;is-boolean-object&quot;:50,&quot;is-number-object&quot;:54,&quot;is-string&quot;:57,&quot;is-symbol&quot;:58}],114:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var isMap = require('is-map');</span>
<span class="s1">var isSet = require('is-set');</span>
<span class="s1">var isWeakMap = require('is-weakmap');</span>
<span class="s1">var isWeakSet = require('is-weakset');</span>

<span class="s1">module.exports = function whichCollection(value) {</span>
	<span class="s1">if (value &amp;&amp; typeof value === 'object') {</span>
		<span class="s1">if (isMap(value)) {</span>
			<span class="s1">return 'Map';</span>
		<span class="s1">}</span>
		<span class="s1">if (isSet(value)) {</span>
			<span class="s1">return 'Set';</span>
		<span class="s1">}</span>
		<span class="s1">if (isWeakMap(value)) {</span>
			<span class="s1">return 'WeakMap';</span>
		<span class="s1">}</span>
		<span class="s1">if (isWeakSet(value)) {</span>
			<span class="s1">return 'WeakSet';</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s1">return false;</span>
<span class="s1">};</span>

<span class="s1">},{&quot;is-map&quot;:53,&quot;is-set&quot;:56,&quot;is-weakmap&quot;:60,&quot;is-weakset&quot;:61}],115:[function(require,module,exports){</span>
<span class="s1">(function (global){(function (){</span>
<span class="s1">'use strict';</span>

<span class="s1">var forEach = require('foreach');</span>
<span class="s1">var availableTypedArrays = require('available-typed-arrays');</span>
<span class="s1">var callBound = require('call-bind/callBound');</span>

<span class="s1">var $toString = callBound('Object.prototype.toString');</span>
<span class="s1">var hasToStringTag = require('has-tostringtag/shams')();</span>

<span class="s1">var g = typeof globalThis === 'undefined' ? global : globalThis;</span>
<span class="s1">var typedArrays = availableTypedArrays();</span>

<span class="s1">var $slice = callBound('String.prototype.slice');</span>
<span class="s1">var toStrTags = {};</span>
<span class="s1">var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');</span>
<span class="s1">var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');</span>
<span class="s1">if (hasToStringTag &amp;&amp; gOPD &amp;&amp; getPrototypeOf) {</span>
	<span class="s1">forEach(typedArrays, function (typedArray) {</span>
		<span class="s1">if (typeof g[typedArray] === 'function') {</span>
			<span class="s1">var arr = new g[typedArray]();</span>
			<span class="s1">if (Symbol.toStringTag in arr) {</span>
				<span class="s1">var proto = getPrototypeOf(arr);</span>
				<span class="s1">var descriptor = gOPD(proto, Symbol.toStringTag);</span>
				<span class="s1">if (!descriptor) {</span>
					<span class="s1">var superProto = getPrototypeOf(proto);</span>
					<span class="s1">descriptor = gOPD(superProto, Symbol.toStringTag);</span>
				<span class="s1">}</span>
				<span class="s1">toStrTags[typedArray] = descriptor.get;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">var tryTypedArrays = function tryAllTypedArrays(value) {</span>
	<span class="s1">var foundName = false;</span>
	<span class="s1">forEach(toStrTags, function (getter, typedArray) {</span>
		<span class="s1">if (!foundName) {</span>
			<span class="s1">try {</span>
				<span class="s1">var name = getter.call(value);</span>
				<span class="s1">if (name === typedArray) {</span>
					<span class="s1">foundName = name;</span>
				<span class="s1">}</span>
			<span class="s1">} catch (e) {}</span>
		<span class="s1">}</span>
	<span class="s1">});</span>
	<span class="s1">return foundName;</span>
<span class="s1">};</span>

<span class="s1">var isTypedArray = require('is-typed-array');</span>

<span class="s1">module.exports = function whichTypedArray(value) {</span>
	<span class="s1">if (!isTypedArray(value)) { return false; }</span>
	<span class="s1">if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }</span>
	<span class="s1">return tryTypedArrays(value);</span>
<span class="s1">};</span>

<span class="s1">}).call(this)}).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})</span>

<span class="s1">},{&quot;available-typed-arrays&quot;:7,&quot;call-bind/callBound&quot;:11,&quot;es-abstract/helpers/getOwnPropertyDescriptor&quot;:26,&quot;foreach&quot;:35,&quot;has-tostringtag/shams&quot;:44,&quot;is-typed-array&quot;:59}],116:[function(require,module,exports){</span>
<span class="s1">arguments[4][75][0].apply(exports,arguments)</span>
<span class="s1">},{&quot;./implementation&quot;:1,&quot;dup&quot;:75}],117:[function(require,module,exports){</span>
<span class="s1">arguments[4][76][0].apply(exports,arguments)</span>
<span class="s1">},{&quot;./polyfill&quot;:116,&quot;define-properties&quot;:16,&quot;dup&quot;:76}],118:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var assign = require('../');</span>
<span class="s1">var test = require('tape');</span>
<span class="s1">var runTests = require('./tests');</span>

<span class="s1">test('as a function', function (t) {</span>
	<span class="s1">t.test('bad array/this value', function (st) {</span>
		<span class="s1">st['throws'](function () { assign(undefined); }, TypeError, 'undefined is not an object');</span>
		<span class="s1">st['throws'](function () { assign(null); }, TypeError, 'null is not an object');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">runTests(assign, t);</span>

	<span class="s1">t.end();</span>
<span class="s1">});</span>

<span class="s1">},{&quot;../&quot;:2,&quot;./tests&quot;:119,&quot;tape&quot;:106}],119:[function(require,module,exports){</span>
<span class="s1">'use strict';</span>

<span class="s1">var hasSymbols = require('has-symbols/shams')();</span>
<span class="s1">var forEach = require('for-each');</span>
<span class="s1">var has = require('has');</span>
<span class="s1">var mockProperty = require('mock-property');</span>

<span class="s1">module.exports = function (assign, t) {</span>
	<span class="s1">t.test('error cases', function (st) {</span>
		<span class="s1">st['throws'](function () { assign(null); }, TypeError, 'target must be an object');</span>
		<span class="s1">st['throws'](function () { assign(undefined); }, TypeError, 'target must be an object');</span>
		<span class="s1">st['throws'](function () { assign(null, {}); }, TypeError, 'target must be an object');</span>
		<span class="s1">st['throws'](function () { assign(undefined, {}); }, TypeError, 'target must be an object');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('non-object target, no sources', function (st) {</span>
		<span class="s1">var bool = assign(true);</span>
		<span class="s1">st.equal(typeof bool, 'object', 'bool is object');</span>
		<span class="s1">st.equal(Boolean.prototype.valueOf.call(bool), true, 'bool coerces to `true`');</span>

		<span class="s1">var number = assign(1);</span>
		<span class="s1">st.equal(typeof number, 'object', 'number is object');</span>
		<span class="s1">st.equal(Number.prototype.valueOf.call(number), 1, 'number coerces to `1`');</span>

		<span class="s1">var string = assign('1');</span>
		<span class="s1">st.equal(typeof string, 'object', 'number is object');</span>
		<span class="s1">st.equal(String.prototype.valueOf.call(string), '1', 'number coerces to `&quot;1&quot;`');</span>

		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('non-object target, with sources', function (st) {</span>
		<span class="s1">var signal = {};</span>

		<span class="s1">st.test('boolean', function (st2) {</span>
			<span class="s1">var bool = assign(true, { a: signal });</span>
			<span class="s1">st2.equal(typeof bool, 'object', 'bool is object');</span>
			<span class="s1">st2.equal(Boolean.prototype.valueOf.call(bool), true, 'bool coerces to `true`');</span>
			<span class="s1">st2.equal(bool.a, signal, 'source properties copied');</span>
			<span class="s1">st2.end();</span>
		<span class="s1">});</span>

		<span class="s1">st.test('number', function (st2) {</span>
			<span class="s1">var number = assign(1, { a: signal });</span>
			<span class="s1">st2.equal(typeof number, 'object', 'number is object');</span>
			<span class="s1">st2.equal(Number.prototype.valueOf.call(number), 1, 'number coerces to `1`');</span>
			<span class="s1">st2.equal(number.a, signal, 'source properties copied');</span>
			<span class="s1">st2.end();</span>
		<span class="s1">});</span>

		<span class="s1">st.test('string', function (st2) {</span>
			<span class="s1">var string = assign('1', { a: signal });</span>
			<span class="s1">st2.equal(typeof string, 'object', 'number is object');</span>
			<span class="s1">st2.equal(String.prototype.valueOf.call(string), '1', 'number coerces to `&quot;1&quot;`');</span>
			<span class="s1">st2.equal(string.a, signal, 'source properties copied');</span>
			<span class="s1">st2.end();</span>
		<span class="s1">});</span>

		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('non-object sources', function (st) {</span>
		<span class="s1">st.deepEqual(assign({ a: 1 }, null, { b: 2 }), { a: 1, b: 2 }, 'ignores null source');</span>
		<span class="s1">st.deepEqual(assign({ a: 1 }, { b: 2 }, undefined), { a: 1, b: 2 }, 'ignores undefined source');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('returns the modified target object', function (st) {</span>
		<span class="s1">var target = {};</span>
		<span class="s1">var returned = assign(target, { a: 1 });</span>
		<span class="s1">st.equal(returned, target, 'returned object is the same reference as the target object');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('has the right length', function (st) {</span>
		<span class="s1">st.equal(assign.length, 2, 'length is 2 =&gt; 2 required arguments');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('merge two objects', function (st) {</span>
		<span class="s1">var target = { a: 1 };</span>
		<span class="s1">var returned = assign(target, { b: 2 });</span>
		<span class="s1">st.deepEqual(returned, { a: 1, b: 2 }, 'returned object has properties from both');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('works with functions', function (st) {</span>
		<span class="s1">var target = function () {};</span>
		<span class="s1">target.a = 1;</span>
		<span class="s1">var returned = assign(target, { b: 2 });</span>
		<span class="s1">st.equal(target, returned, 'returned object is target');</span>
		<span class="s1">st.equal(returned.a, 1);</span>
		<span class="s1">st.equal(returned.b, 2);</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('works with primitives', function (st) {</span>
		<span class="s1">var target = 2;</span>
		<span class="s1">var source = { b: 42 };</span>
		<span class="s1">var returned = assign(target, source);</span>
		<span class="s1">st.equal(Object.prototype.toString.call(returned), '[object Number]', 'returned is object form of number primitive');</span>
		<span class="s1">st.equal(Number(returned), target, 'returned and target have same valueOf');</span>
		<span class="s1">st.equal(returned.b, source.b);</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">/* globals window */</span>
	<span class="s1">t.test('works with window.location', { skip: typeof window === 'undefined' }, function (st) {</span>
		<span class="s1">var target = {};</span>
		<span class="s1">assign(target, window.location);</span>
		<span class="s1">for (var prop in window.location) {</span>
			<span class="s1">if (has(window.location, prop)) {</span>
				<span class="s1">st.deepEqual(target[prop], window.location[prop], prop + ' is copied');</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('merge N objects', function (st) {</span>
		<span class="s1">var target = { a: 1 };</span>
		<span class="s1">var source1 = { b: 2 };</span>
		<span class="s1">var source2 = { c: 3 };</span>
		<span class="s1">var returned = assign(target, source1, source2);</span>
		<span class="s1">st.deepEqual(returned, { a: 1, b: 2, c: 3 }, 'returned object has properties from all sources');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('only iterates over own keys', function (st) {</span>
		<span class="s1">var Foo = function () {};</span>
		<span class="s1">Foo.prototype.bar = true;</span>
		<span class="s1">var foo = new Foo();</span>
		<span class="s1">foo.baz = true;</span>
		<span class="s1">var target = { a: 1 };</span>
		<span class="s1">var returned = assign(target, foo);</span>
		<span class="s1">st.equal(returned, target, 'returned object is the same reference as the target object');</span>
		<span class="s1">st.deepEqual(target, { a: 1, baz: true }, 'returned object has only own properties from both');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('includes enumerable symbols, after keys', { skip: !hasSymbols }, function (st) {</span>
		<span class="s1">var visited = [];</span>
		<span class="s1">var obj = {};</span>
		<span class="s1">Object.defineProperty(obj, 'a', { enumerable: true, get: function () { visited.push('a'); return 42; } });</span>
		<span class="s1">var symbol = Symbol('enumerable');</span>
		<span class="s1">Object.defineProperty(obj, symbol, {</span>
			<span class="s1">enumerable: true,</span>
			<span class="s1">get: function () { visited.push(symbol); return Infinity; }</span>
		<span class="s1">});</span>
		<span class="s1">var nonEnumSymbol = Symbol('non-enumerable');</span>
		<span class="s1">Object.defineProperty(obj, nonEnumSymbol, {</span>
			<span class="s1">enumerable: false,</span>
			<span class="s1">get: function () { visited.push(nonEnumSymbol); return -Infinity; }</span>
		<span class="s1">});</span>
		<span class="s1">var target = assign({}, obj);</span>
		<span class="s1">st.deepEqual(visited, ['a', symbol], 'key is visited first, then symbol');</span>
		<span class="s1">st.equal(target.a, 42, 'target.a is 42');</span>
		<span class="s1">st.equal(target[symbol], Infinity, 'target[symbol] is Infinity');</span>
		<span class="s1">st.notEqual(target[nonEnumSymbol], -Infinity, 'target[nonEnumSymbol] is not -Infinity');</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('does not fail when symbols are not present', { skip: !Object.isFrozen || Object.isFrozen(Object) }, function (st) {</span>
		<span class="s1">st.teardown(mockProperty(Object, 'getOwnPropertySymbols', { 'delete': true }));</span>

		<span class="s1">var visited = [];</span>
		<span class="s1">var obj = {};</span>
		<span class="s1">Object.defineProperty(obj, 'a', { enumerable: true, get: function () { visited.push('a'); return 42; } });</span>
		<span class="s1">var keys = ['a'];</span>
		<span class="s1">if (hasSymbols) {</span>
			<span class="s1">var symbol = Symbol('sym');</span>
			<span class="s1">Object.defineProperty(obj, symbol, {</span>
				<span class="s1">enumerable: true,</span>
				<span class="s1">get: function () { visited.push(symbol); return Infinity; }</span>
			<span class="s1">});</span>
			<span class="s1">keys.push(symbol);</span>
		<span class="s1">}</span>
		<span class="s1">var target = assign({}, obj);</span>
		<span class="s1">st.deepEqual(visited, keys, 'assign visits expected keys');</span>
		<span class="s1">st.equal(target.a, 42, 'target.a is 42');</span>

		<span class="s1">if (hasSymbols) {</span>
			<span class="s1">st.equal(target[symbol], Infinity);</span>
		<span class="s1">}</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('preserves correct property enumeration order', function (st) {</span>
		<span class="s1">var str = 'abcdefghijklmnopqrst';</span>
		<span class="s1">var letters = {};</span>
		<span class="s1">forEach(str.split(''), function (letter) {</span>
			<span class="s1">letters[letter] = letter;</span>
		<span class="s1">});</span>

		<span class="s1">var n = 5;</span>
		<span class="s1">st.comment('run the next test ' + n + ' times');</span>
		<span class="s1">var object = assign({}, letters);</span>
		<span class="s1">var actual = '';</span>
		<span class="s1">for (var k in object) {</span>
			<span class="s1">actual += k;</span>
		<span class="s1">}</span>
		<span class="s1">for (var i = 0; i &lt; n; ++i) {</span>
			<span class="s1">st.equal(actual, str, 'property enumeration order should be followed');</span>
		<span class="s1">}</span>
		<span class="s1">st.end();</span>
	<span class="s1">});</span>

	<span class="s1">t.test('checks enumerability and existence, in case of modification during [[Get]]', { skip: !Object.defineProperty }, function (st) {</span>
		<span class="s1">var targetBvalue = {};</span>
		<span class="s1">var targetCvalue = {};</span>
		<span class="s1">var target = { b: targetBvalue, c: targetCvalue };</span>
		<span class="s1">var source = {};</span>
		<span class="s1">Object.defineProperty(source, 'a', {</span>
			<span class="s1">enumerable: true,</span>
			<span class="s1">get: function () {</span>
				<span class="s1">delete this.b;</span>
				<span class="s1">Object.defineProperty(this, 'c', { enumerable: false });</span>
				<span class="s1">return 'a';</span>
			<span class="s1">}</span>
		<span class="s1">});</span>
		<span class="s1">var sourceBvalue = {};</span>
		<span class="s1">var sourceCvalue = {};</span>
		<span class="s1">source.b = sourceBvalue;</span>
		<span class="s1">source.c = sourceCvalue;</span>
		<span class="s1">var result = assign(target, source);</span>
		<span class="s1">st.equal(result, target, 'sanity check: result is === target');</span>
		<span class="s1">st.equal(result.b, targetBvalue, 'target key not overwritten by deleted source key');</span>
		<span class="s1">st.equal(result.c, targetCvalue, 'target key not overwritten by non-enumerable source key');</span>

		<span class="s1">st.end();</span>
	<span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">},{&quot;for-each&quot;:34,&quot;has&quot;:45,&quot;has-symbols/shams&quot;:43,&quot;mock-property&quot;:63}]},{},[118])</span>
<span class="s1">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbXBsZW1lbnRhdGlvbi5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5ldmVyeS9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS5wcm90b3R5cGUuZXZlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXkucHJvdG90eXBlLmV2ZXJ5L3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LnByb3RvdHlwZS5ldmVyeS9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWZpbmVkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvSXNDYWxsYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1JlcXVpcmVPYmplY3RDb2VyY2libGUuanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9Ub051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzIwMjEvVG9QcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvMjAyMS9Ub1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC8yMDIxL1RvVWludDMyLmpzIiwibm9kZV9tb2R1bGVzL2VzLWFic3RyYWN0LzUvQ2hlY2tPYmplY3RDb2VyY2libGUuanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9pc1ByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9lcy1hYnN0cmFjdC9oZWxwZXJzL3JlZ2V4VGVzdGVyLmpzIiwibm9kZV9tb2R1bGVzL2VzLWdldC1pdGVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lcy10by1wcmltaXRpdmUvZXMyMDE1LmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb25zLWhhdmUtbmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtYmlnaW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtcHJvcGVydHktZGVzY3JpcHRvcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCJub2RlX21vZHVsZXMvaGFzLXRvc3RyaW5ndGFnL3NoYW1zLmpzIiwibm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1iaWdpbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYm9vbGVhbi1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGF0ZS1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtbWFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLW51bWJlci1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtc2V0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtd2Vha21hcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy13ZWFrc2V0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vY2stcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWluc3BlY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWlzL2ltcGxlbWVudGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWlzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QuYXNzaWduL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVnZXhwLnByb3RvdHlwZS5mbGFncy9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWdleHAucHJvdG90eXBlLmZsYWdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlZ2V4cC5wcm90b3R5cGUuZmxhZ3MvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvcmVnZXhwLnByb3RvdHlwZS5mbGFncy9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3Jlc3VtZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUudHJpbS9pbXBsZW1lbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmcucHJvdG90eXBlLnRyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nLnByb3RvdHlwZS50cmltL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZy5wcm90b3R5cGUudHJpbS9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3RhcGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGFwZS9saWIvZGVmYXVsdF9zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvdGFwZS9saWIvcmVzdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy90YXBlL2xpYi90ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3doaWNoLWJveGVkLXByaW1pdGl2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93aGljaC1jb2xsZWN0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzIiwidGVzdC9pbmRleC5qcyIsInRlc3QvdGVzdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9mQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlNBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy93QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM2LXNoaW1cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciB0b09iamVjdCA9IE9iamVjdDtcbnZhciAkcHVzaCA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLnB1c2gnKTtcbnZhciAkcHJvcElzRW51bWVyYWJsZSA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZScpO1xudmFyIG9yaWdpbmFsR2V0U3ltYm9scyA9IGhhc1N5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogbnVsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZTEpIHtcblx0aWYgKHRhcmdldCA9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpOyB9XG5cdHZhciBvYmpUYXJnZXQgPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgcywgc291cmNlLCBpLCBwcm9wcywgc3ltcywgdmFsdWUsIGtleTtcblx0Zm9yIChzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7ICsrcykge1xuXHRcdHNvdXJjZSA9IHRvT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cdFx0cHJvcHMgPSBrZXlzKHNvdXJjZSk7XG5cdFx0dmFyIGdldFN5bWJvbHMgPSBoYXNTeW1ib2xzICYmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIHx8IG9yaWdpbmFsR2V0U3ltYm9scyk7XG5cdFx0aWYgKGdldFN5bWJvbHMpIHtcblx0XHRcdHN5bXMgPSBnZXRTeW1ib2xzKHNvdXJjZSk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3ltcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRrZXkgPSBzeW1zW2ldO1xuXHRcdFx0XHRpZiAoJHByb3BJc0VudW1lcmFibGUoc291cmNlLCBrZXkpKSB7XG5cdFx0XHRcdFx0JHB1c2gocHJvcHMsIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yIChpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRrZXkgPSBwcm9wc1tpXTtcblx0XHRcdHZhbHVlID0gc291cmNlW2tleV07XG5cdFx0XHRpZiAoJHByb3BJc0VudW1lcmFibGUoc291cmNlLCBrZXkpKSB7XG5cdFx0XHRcdG9ialRhcmdldFtrZXldID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmpUYXJnZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQuYXBwbHkoZ2V0UG9seWZpbGwoKSk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBib3VuZCA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZTEpIHtcblx0cmV0dXJuIHBvbHlmaWxsKE9iamVjdCwgYXJndW1lbnRzKTtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoYm91bmQsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJvdW5kO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvSXNDYWxsYWJsZScpO1xudmFyIFRvT2JqZWN0ID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9Ub09iamVjdCcpO1xudmFyIFRvVWludDMyID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvMjAyMS9Ub1VpbnQzMicpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJ2lzLXN0cmluZycpO1xuXG4vLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KSBhbmQgZmFpbHVyZSBvZiBgMCBpbiBib3hlZFN0cmluZ2AgKFJoaW5vKVxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciAkc3BsaXQgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc3BsaXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuKSB7XG5cdHZhciBPID0gVG9PYmplY3QodGhpcyk7XG5cdHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcoTykgPyAkc3BsaXQoTywgJycpIDogTztcblx0dmFyIGxlbiA9IFRvVWludDMyKHNlbGYubGVuZ3RoKTtcblx0dmFyIFQ7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFQgPSBhcmd1bWVudHNbMV07XG5cdH1cblxuXHQvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuXHRpZiAoIUlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZXZlcnkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0aWYgKGkgaW4gc2VsZiAmJiAhKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgTykgOiBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgTykpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgUmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvUmVxdWlyZU9iamVjdENvZXJjaWJsZScpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5zbGljZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBib3VuZEV2ZXJ5U2hpbSA9IGZ1bmN0aW9uIGV2ZXJ5KGFycmF5LCBjYWxsYmFja2ZuKSB7XG5cdFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJyYXkpO1xuXHRyZXR1cm4gcG9seWZpbGwuYXBwbHkoYXJyYXksICRzbGljZShhcmd1bWVudHMsIDEpKTtcbn07XG5kZWZpbmUoYm91bmRFdmVyeVNoaW0sIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJvdW5kRXZlcnlTaGltO1xuIiwidmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZS5ldmVyeSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBoYXNQcmltaXRpdmVDb250ZXh0SW5TdHJpY3QgPSBbMV0uZXZlcnkoZnVuY3Rpb24gKCkge1xuXHRcdFx0J3VzZSBzdHJpY3QnO1xuXG5cdFx0XHRyZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnICYmIHRoaXMgPT09ICd4Jztcblx0XHR9LCAneCcpO1xuXHRcdGlmIChoYXNQcmltaXRpdmVDb250ZXh0SW5TdHJpY3QpIHtcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuZXZlcnk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1BcnJheVByb3RvdHlwZUV2ZXJ5KCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoXG5cdFx0QXJyYXkucHJvdG90eXBlLFxuXHRcdHsgZXZlcnk6IHBvbHlmaWxsIH0sXG5cdFx0eyBldmVyeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLmV2ZXJ5ICE9PSBwb2x5ZmlsbDsgfSB9XG5cdCk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gW1xuXHQnQmlnSW50NjRBcnJheScsXG5cdCdCaWdVaW50NjRBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDE2QXJyYXknLFxuXHQnSW50MzJBcnJheScsXG5cdCdJbnQ4QXJyYXknLFxuXHQnVWludDE2QXJyYXknLFxuXHQnVWludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheSdcbl07XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIG91dCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGdbcG9zc2libGVOYW1lc1tpXV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG91dFtvdXQubGVuZ3RoXSA9IHBvc3NpYmxlTmFtZXNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpcyA9IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIGlzUmVnZXggPSByZXF1aXJlKCdpcy1yZWdleCcpO1xudmFyIGZsYWdzID0gcmVxdWlyZSgncmVnZXhwLnByb3RvdHlwZS5mbGFncycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNEYXRlID0gcmVxdWlyZSgnaXMtZGF0ZS1vYmplY3QnKTtcbnZhciB3aGljaEJveGVkUHJpbWl0aXZlID0gcmVxdWlyZSgnd2hpY2gtYm94ZWQtcHJpbWl0aXZlJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciB3aGljaENvbGxlY3Rpb24gPSByZXF1aXJlKCd3aGljaC1jb2xsZWN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3IgPSByZXF1aXJlKCdlcy1nZXQtaXRlcmF0b3InKTtcbnZhciBnZXRTaWRlQ2hhbm5lbCA9IHJlcXVpcmUoJ3NpZGUtY2hhbm5lbCcpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LmFzc2lnbicpO1xuXG52YXIgJGdldFRpbWUgPSBjYWxsQm91bmQoJ0RhdGUucHJvdG90eXBlLmdldFRpbWUnKTtcbnZhciBnUE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgJG9ialRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciAkU2V0ID0gR2V0SW50cmluc2ljKCclU2V0JScsIHRydWUpO1xudmFyICRtYXBIYXMgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG52YXIgJG1hcEdldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbnZhciAkbWFwU2l6ZSA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5zaXplJywgdHJ1ZSk7XG52YXIgJHNldEFkZCA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5hZGQnLCB0cnVlKTtcbnZhciAkc2V0RGVsZXRlID0gY2FsbEJvdW5kKCdTZXQucHJvdG90eXBlLmRlbGV0ZScsIHRydWUpO1xudmFyICRzZXRIYXMgPSBjYWxsQm91bmQoJ1NldC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG52YXIgJHNldFNpemUgPSBjYWxsQm91bmQoJ1NldC5wcm90b3R5cGUuc2l6ZScsIHRydWUpO1xuXG4vLyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9icm93c2VyaWZ5L2NvbW1vbmpzLWFzc2VydC9ibG9iL2JiYTgzOGU5YmE5ZTI4ZWRmMzEyN2NlNjk3NDYyNDIwODUwMmY2YmMvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qcyNMNDAxLUw0MTRcbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIG9wdHMsIGNoYW5uZWwpIHtcbiAgdmFyIGkgPSBnZXRJdGVyYXRvcihzZXQpO1xuICB2YXIgcmVzdWx0O1xuICB3aGlsZSAoKHJlc3VsdCA9IGkubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBpZiAoaW50ZXJuYWxEZWVwRXF1YWwodmFsMSwgcmVzdWx0LnZhbHVlLCBvcHRzLCBjaGFubmVsKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgJHNldERlbGV0ZShzZXQsIHJlc3VsdC52YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Jyb3dzZXJpZnkvY29tbW9uanMtYXNzZXJ0L2Jsb2IvYmJhODM4ZTliYTllMjhlZGYzMTI3Y2U2OTc0NjI0MjA4NTAyZjZiYy9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzI0w0MTYtTDQzOVxuZnVuY3Rpb24gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pIHtcbiAgaWYgKHR5cGVvZiBwcmltID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgcHJpbSA9PT0gJ29iamVjdCcpIHsgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcmltID09PSAnc3ltYm9sJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHByaW0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcmltID09PSAnbnVtYmVyJykge1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG8gYSByZWd1bGFyIG51bWJlciBhbmQgbm90IE5hTi5cbiAgICByZXR1cm4gK3ByaW0gPT09ICtwcmltOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Jyb3dzZXJpZnkvY29tbW9uanMtYXNzZXJ0L2Jsb2IvYmJhODM4ZTliYTllMjhlZGYzMTI3Y2U2OTc0NjI0MjA4NTAyZjZiYy9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzI0w0NDktTDQ2MFxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG9wdHMsIGNoYW5uZWwpIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBhbHRWYWx1ZTtcbiAgfVxuICB2YXIgY3VyQiA9ICRtYXBHZXQoYiwgYWx0VmFsdWUpO1xuICB2YXIgbG9vc2VPcHRzID0gYXNzaWduKHt9LCBvcHRzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gIGlmIChcbiAgICAodHlwZW9mIGN1ckIgPT09ICd1bmRlZmluZWQnICYmICEkbWFwSGFzKGIsIGFsdFZhbHVlKSlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICB8fCAhaW50ZXJuYWxEZWVwRXF1YWwoaXRlbSwgY3VyQiwgbG9vc2VPcHRzLCBjaGFubmVsKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIHJldHVybiAhJG1hcEhhcyhhLCBhbHRWYWx1ZSkgJiYgaW50ZXJuYWxEZWVwRXF1YWwoaXRlbSwgY3VyQiwgbG9vc2VPcHRzLCBjaGFubmVsKTtcbn1cblxuLy8gdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYnJvd3NlcmlmeS9jb21tb25qcy1hc3NlcnQvYmxvYi9iYmE4MzhlOWJhOWUyOGVkZjMxMjdjZTY5NzQ2MjQyMDg1MDJmNmJjL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMjTDQ0MS1MNDQ3XG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuICRzZXRIYXMoYiwgYWx0VmFsdWUpICYmICEkc2V0SGFzKGEsIGFsdFZhbHVlKTtcbn1cblxuLy8gdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYnJvd3NlcmlmeS9jb21tb25qcy1hc3NlcnQvYmxvYi9iYmE4MzhlOWJhOWUyOGVkZjMxMjdjZTY5NzQ2MjQyMDg1MDJmNmJjL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMjTDUxOC1MNTMzXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgb3B0cywgY2hhbm5lbCkge1xuICB2YXIgaSA9IGdldEl0ZXJhdG9yKHNldCk7XG4gIHZhciByZXN1bHQ7XG4gIHZhciBrZXkyO1xuICB3aGlsZSAoKHJlc3VsdCA9IGkubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBrZXkyID0gcmVzdWx0LnZhbHVlO1xuICAgIGlmIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgaW50ZXJuYWxEZWVwRXF1YWwoa2V5MSwga2V5Miwgb3B0cywgY2hhbm5lbClcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgJiYgaW50ZXJuYWxEZWVwRXF1YWwoaXRlbTEsICRtYXBHZXQobWFwLCBrZXkyKSwgb3B0cywgY2hhbm5lbClcbiAgICApIHtcbiAgICAgICRzZXREZWxldGUoc2V0LCBrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgb3B0aW9ucywgY2hhbm5lbCkge1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChvcHRzLnN0cmljdCA/IGlzKGFjdHVhbCwgZXhwZWN0ZWQpIDogYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGFjdHVhbEJveGVkID0gd2hpY2hCb3hlZFByaW1pdGl2ZShhY3R1YWwpO1xuICB2YXIgZXhwZWN0ZWRCb3hlZCA9IHdoaWNoQm94ZWRQcmltaXRpdmUoZXhwZWN0ZWQpO1xuICBpZiAoYWN0dWFsQm94ZWQgIT09IGV4cGVjdGVkQm94ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCAodHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBpcyhhY3R1YWwsIGV4cGVjdGVkKSA6IGFjdHVhbCA9PSBleHBlY3RlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgfVxuXG4gIC8qXG4gICAqIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAgKiBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgICogd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAgKiAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gICAqIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gICAqIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICAgKi9cbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvZDNhYWZkMDJlZmQzYTQwM2Q2NDZhMzA0NGFkY2YxNGU2M2E4OGQzMiBmb3IgbWVtb3MvY2hhbm5lbCBpbnNwaXJhdGlvblxuXG4gIHZhciBoYXNBY3R1YWwgPSBjaGFubmVsLmhhcyhhY3R1YWwpO1xuICB2YXIgaGFzRXhwZWN0ZWQgPSBjaGFubmVsLmhhcyhleHBlY3RlZCk7XG4gIHZhciBzZW50aW5lbDtcbiAgaWYgKGhhc0FjdHVhbCAmJiBoYXNFeHBlY3RlZCkge1xuICAgIGlmIChjaGFubmVsLmdldChhY3R1YWwpID09PSBjaGFubmVsLmdldChleHBlY3RlZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZW50aW5lbCA9IHt9O1xuICB9XG4gIGlmICghaGFzQWN0dWFsKSB7IGNoYW5uZWwuc2V0KGFjdHVhbCwgc2VudGluZWwpOyB9XG4gIGlmICghaGFzRXhwZWN0ZWQpIHsgY2hhbm5lbC5zZXQoZXhwZWN0ZWQsIHNlbnRpbmVsKTsgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cywgY2hhbm5lbCk7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiB4LmNvbnN0cnVjdG9yLmlzQnVmZmVyKHgpKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgb3B0cywgY2hhbm5lbCkge1xuICBpZiAoJHNldFNpemUoYSkgIT09ICRzZXRTaXplKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpQSA9IGdldEl0ZXJhdG9yKGEpO1xuICB2YXIgaUIgPSBnZXRJdGVyYXRvcihiKTtcbiAgdmFyIHJlc3VsdEE7XG4gIHZhciByZXN1bHRCO1xuICB2YXIgc2V0O1xuICB3aGlsZSAoKHJlc3VsdEEgPSBpQS5uZXh0KCkpICYmICFyZXN1bHRBLmRvbmUpIHtcbiAgICBpZiAocmVzdWx0QS52YWx1ZSAmJiB0eXBlb2YgcmVzdWx0QS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICghc2V0KSB7IHNldCA9IG5ldyAkU2V0KCk7IH1cbiAgICAgICRzZXRBZGQoc2V0LCByZXN1bHRBLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCEkc2V0SGFzKGIsIHJlc3VsdEEudmFsdWUpKSB7XG4gICAgICBpZiAob3B0cy5zdHJpY3QpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCByZXN1bHRBLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXNldCkgeyBzZXQgPSBuZXcgJFNldCgpOyB9XG4gICAgICAkc2V0QWRkKHNldCwgcmVzdWx0QS52YWx1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChzZXQpIHtcbiAgICB3aGlsZSAoKHJlc3VsdEIgPSBpQi5uZXh0KCkpICYmICFyZXN1bHRCLmRvbmUpIHtcbiAgICAgIC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeSBtYXRjaGluZyBhbmQgb25seSBpZiBpdCdzIG5vdCwgZ28gaHVudGluZyBmb3IgaXQuXG4gICAgICBpZiAocmVzdWx0Qi52YWx1ZSAmJiB0eXBlb2YgcmVzdWx0Qi52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCByZXN1bHRCLnZhbHVlLCBvcHRzLnN0cmljdCwgY2hhbm5lbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICFvcHRzLnN0cmljdFxuICAgICAgICAmJiAhJHNldEhhcyhhLCByZXN1bHRCLnZhbHVlKVxuICAgICAgICAmJiAhc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgcmVzdWx0Qi52YWx1ZSwgb3B0cy5zdHJpY3QsIGNoYW5uZWwpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHNldFNpemUoc2V0KSA9PT0gMDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgb3B0cywgY2hhbm5lbCkge1xuICBpZiAoJG1hcFNpemUoYSkgIT09ICRtYXBTaXplKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpQSA9IGdldEl0ZXJhdG9yKGEpO1xuICB2YXIgaUIgPSBnZXRJdGVyYXRvcihiKTtcbiAgdmFyIHJlc3VsdEE7XG4gIHZhciByZXN1bHRCO1xuICB2YXIgc2V0O1xuICB2YXIga2V5O1xuICB2YXIgaXRlbTE7XG4gIHZhciBpdGVtMjtcbiAgd2hpbGUgKChyZXN1bHRBID0gaUEubmV4dCgpKSAmJiAhcmVzdWx0QS5kb25lKSB7XG4gICAga2V5ID0gcmVzdWx0QS52YWx1ZVswXTtcbiAgICBpdGVtMSA9IHJlc3VsdEEudmFsdWVbMV07XG4gICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKCFzZXQpIHsgc2V0ID0gbmV3ICRTZXQoKTsgfVxuICAgICAgJHNldEFkZChzZXQsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0yID0gJG1hcEdldChiLCBrZXkpO1xuICAgICAgaWYgKCh0eXBlb2YgaXRlbTIgPT09ICd1bmRlZmluZWQnICYmICEkbWFwSGFzKGIsIGtleSkpIHx8ICFpbnRlcm5hbERlZXBFcXVhbChpdGVtMSwgaXRlbTIsIG9wdHMsIGNoYW5uZWwpKSB7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBrZXksIGl0ZW0xLCBvcHRzLCBjaGFubmVsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNldCkgeyBzZXQgPSBuZXcgJFNldCgpOyB9XG4gICAgICAgICRzZXRBZGQoc2V0LCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQpIHtcbiAgICB3aGlsZSAoKHJlc3VsdEIgPSBpQi5uZXh0KCkpICYmICFyZXN1bHRCLmRvbmUpIHtcbiAgICAgIGtleSA9IHJlc3VsdEIudmFsdWVbMF07XG4gICAgICBpdGVtMiA9IHJlc3VsdEIudmFsdWVbMV07XG4gICAgICBpZiAoa2V5ICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbTIsIG9wdHMsIGNoYW5uZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAhb3B0cy5zdHJpY3RcbiAgICAgICAgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbnRlcm5hbERlZXBFcXVhbCgkbWFwR2V0KGEsIGtleSksIGl0ZW0yLCBvcHRzLCBjaGFubmVsKSlcbiAgICAgICAgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0yLCBhc3NpZ24oe30sIG9wdHMsIHsgc3RyaWN0OiBmYWxzZSB9KSwgY2hhbm5lbClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAkc2V0U2l6ZShzZXQpID09PSAwO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzLCBjaGFubmVsKSB7XG4gIC8qIGVzbGludCBtYXgtc3RhdGVtZW50czogWzIsIDEwMF0sIG1heC1saW5lcy1wZXItZnVuY3Rpb246IFsyLCAxMjBdLCBtYXgtZGVwdGg6IFsyLCA1XSAqL1xuICB2YXIgaSwga2V5O1xuXG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICgkb2JqVG9TdHJpbmcoYSkgIT09ICRvYmpUb1N0cmluZyhiKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoaXNBcmd1bWVudHMoYSkgIT09IGlzQXJndW1lbnRzKGIpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBhSXNBcnJheSA9IGlzQXJyYXkoYSk7XG4gIHZhciBiSXNBcnJheSA9IGlzQXJyYXkoYik7XG4gIGlmIChhSXNBcnJheSAhPT0gYklzQXJyYXkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gVE9ETzogcmVwbGFjZSB3aGVuIGEgY3Jvc3MtcmVhbG0gYnJhbmQgY2hlY2sgaXMgYXZhaWxhYmxlXG4gIHZhciBhSXNFcnJvciA9IGEgaW5zdGFuY2VvZiBFcnJvcjtcbiAgdmFyIGJJc0Vycm9yID0gYiBpbnN0YW5jZW9mIEVycm9yO1xuICBpZiAoYUlzRXJyb3IgIT09IGJJc0Vycm9yKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYUlzRXJyb3IgfHwgYklzRXJyb3IpIHtcbiAgICBpZiAoYS5uYW1lICE9PSBiLm5hbWUgfHwgYS5tZXNzYWdlICE9PSBiLm1lc3NhZ2UpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIH1cblxuICB2YXIgYUlzUmVnZXggPSBpc1JlZ2V4KGEpO1xuICB2YXIgYklzUmVnZXggPSBpc1JlZ2V4KGIpO1xuICBpZiAoYUlzUmVnZXggIT09IGJJc1JlZ2V4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoKGFJc1JlZ2V4IHx8IGJJc1JlZ2V4KSAmJiAoYS5zb3VyY2UgIT09IGIuc291cmNlIHx8IGZsYWdzKGEpICE9PSBmbGFncyhiKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYUlzRGF0ZSA9IGlzRGF0ZShhKTtcbiAgdmFyIGJJc0RhdGUgPSBpc0RhdGUoYik7XG4gIGlmIChhSXNEYXRlICE9PSBiSXNEYXRlKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYUlzRGF0ZSB8fCBiSXNEYXRlKSB7IC8vICYmIHdvdWxkIHdvcmsgdG9vLCBiZWNhdXNlIGJvdGggYXJlIHRydWUgb3IgYm90aCBmYWxzZSBoZXJlXG4gICAgaWYgKCRnZXRUaW1lKGEpICE9PSAkZ2V0VGltZShiKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgfVxuICBpZiAob3B0cy5zdHJpY3QgJiYgZ1BPICYmIGdQTyhhKSAhPT0gZ1BPKGIpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICh3aGljaFR5cGVkQXJyYXkoYSkgIT09IHdoaWNoVHlwZWRBcnJheShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBhSXNCdWZmZXIgPSBpc0J1ZmZlcihhKTtcbiAgdmFyIGJJc0J1ZmZlciA9IGlzQnVmZmVyKGIpO1xuICBpZiAoYUlzQnVmZmVyICE9PSBiSXNCdWZmZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChhSXNCdWZmZXIgfHwgYklzQnVmZmVyKSB7IC8vICYmIHdvdWxkIHdvcmsgdG9vLCBiZWNhdXNlIGJvdGggYXJlIHRydWUgb3IgYm90aCBmYWxzZSBoZXJlXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikgeyByZXR1cm4gZmFsc2U7IH1cblxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvLyB+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSkgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgfVxuXG4gIC8vIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kIH5+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWludGVybmFsRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzLCBjaGFubmVsKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgfVxuXG4gIHZhciBhQ29sbGVjdGlvbiA9IHdoaWNoQ29sbGVjdGlvbihhKTtcbiAgdmFyIGJDb2xsZWN0aW9uID0gd2hpY2hDb2xsZWN0aW9uKGIpO1xuICBpZiAoYUNvbGxlY3Rpb24gIT09IGJDb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhQ29sbGVjdGlvbiA9PT0gJ1NldCcgfHwgYkNvbGxlY3Rpb24gPT09ICdTZXQnKSB7IC8vIGFDb2xsZWN0aW9uID09PSBiQ29sbGVjdGlvblxuICAgIHJldHVybiBzZXRFcXVpdihhLCBiLCBvcHRzLCBjaGFubmVsKTtcbiAgfVxuICBpZiAoYUNvbGxlY3Rpb24gPT09ICdNYXAnKSB7IC8vIGFDb2xsZWN0aW9uID09PSBiQ29sbGVjdGlvblxuICAgIHJldHVybiBtYXBFcXVpdihhLCBiLCBvcHRzLCBjaGFubmVsKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiLCBvcHRzKSB7XG4gIHJldHVybiBpbnRlcm5hbERlZXBFcXVhbChhLCBiLCBvcHRzLCBnZXRTaWRlQ2hhbm5lbCgpKTtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJ2ZvbycpID09PSAnc3ltYm9sJztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIG9yaWdEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gcmVxdWlyZSgnaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzJykoKTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBvcmlnRGVmaW5lUHJvcGVydHkgJiYgaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QgJiYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdG9yaWdEZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvYmplY3RbbmFtZV0gPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IGNvbmNhdC5jYWxsKHByb3BzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BzW2ldLCBtYXBbcHJvcHNbaV1dLCBwcmVkaWNhdGVzW3Byb3BzW2ldXSk7XG5cdH1cbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGh0dHA6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy81LjEvI3NlYy05LjExXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi81L0NoZWNrT2JqZWN0Q29lcmNpYmxlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xudmFyICROdW1iZXIgPSBHZXRJbnRyaW5zaWMoJyVOdW1iZXIlJyk7XG52YXIgJFJlZ0V4cCA9IEdldEludHJpbnNpYygnJVJlZ0V4cCUnKTtcbnZhciAkcGFyc2VJbnRlZ2VyID0gR2V0SW50cmluc2ljKCclcGFyc2VJbnQlJyk7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgcmVnZXhUZXN0ZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlZ2V4VGVzdGVyJyk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzUHJpbWl0aXZlJyk7XG5cbnZhciAkc3RyU2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciBpc0JpbmFyeSA9IHJlZ2V4VGVzdGVyKC9eMGJbMDFdKyQvaSk7XG52YXIgaXNPY3RhbCA9IHJlZ2V4VGVzdGVyKC9eMG9bMC03XSskL2kpO1xudmFyIGlzSW52YWxpZEhleExpdGVyYWwgPSByZWdleFRlc3RlcigvXlstK10weFswLTlhLWZdKyQvaSk7XG52YXIgbm9uV1MgPSBbJ1xcdTAwODUnLCAnXFx1MjAwYicsICdcXHVmZmZlJ10uam9pbignJyk7XG52YXIgbm9uV1NyZWdleCA9IG5ldyAkUmVnRXhwKCdbJyArIG5vbldTICsgJ10nLCAnZycpO1xudmFyIGhhc05vbldTID0gcmVnZXhUZXN0ZXIobm9uV1NyZWdleCk7XG5cbi8vIHdoaXRlc3BhY2UgZnJvbTogaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG4vLyBpbXBsZW1lbnRhdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL3YzLjQuMC9lczUtc2hpbS5qcyNMMTMwNC1MMTMyNFxudmFyIHdzID0gW1xuXHQnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnLFxuXHQnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnLFxuXHQnXFx1MjAyOVxcdUZFRkYnXG5dLmpvaW4oJycpO1xudmFyIHRyaW1SZWdleCA9IG5ldyBSZWdFeHAoJyheWycgKyB3cyArICddKyl8KFsnICsgd3MgKyAnXSskKScsICdnJyk7XG52YXIgJHJlcGxhY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUucmVwbGFjZScpO1xudmFyICR0cmltID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiAkcmVwbGFjZSh2YWx1ZSwgdHJpbVJlZ2V4LCAnJyk7XG59O1xuXG52YXIgVG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL1RvUHJpbWl0aXZlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b251bWJlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvTnVtYmVyKGFyZ3VtZW50KSB7XG5cdHZhciB2YWx1ZSA9IGlzUHJpbWl0aXZlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogVG9QcmltaXRpdmUoYXJndW1lbnQsICROdW1iZXIpO1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIG51bWJlcicpO1xuXHR9XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ0NvbnZlcnNpb24gZnJvbSBcXCdCaWdJbnRcXCcgdG8gXFwnbnVtYmVyXFwnIGlzIG5vdCBhbGxvd2VkLicpO1xuXHR9XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0aWYgKGlzQmluYXJ5KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIFRvTnVtYmVyKCRwYXJzZUludGVnZXIoJHN0clNsaWNlKHZhbHVlLCAyKSwgMikpO1xuXHRcdH0gZWxzZSBpZiAoaXNPY3RhbCh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiBUb051bWJlcigkcGFyc2VJbnRlZ2VyKCRzdHJTbGljZSh2YWx1ZSwgMiksIDgpKTtcblx0XHR9IGVsc2UgaWYgKGhhc05vbldTKHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0dmFyIHRyaW1tZWQgPSAkdHJpbSh2YWx1ZSk7XG5cdFx0aWYgKHRyaW1tZWQgIT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gVG9OdW1iZXIodHJpbW1lZCk7XG5cdFx0fVxuXG5cdH1cblx0cmV0dXJuICROdW1iZXIodmFsdWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRPYmplY3QgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QlJyk7XG5cbnZhciBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi9SZXF1aXJlT2JqZWN0Q29lcmNpYmxlJyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b29iamVjdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvT2JqZWN0KHZhbHVlKSB7XG5cdFJlcXVpcmVPYmplY3RDb2VyY2libGUodmFsdWUpO1xuXHRyZXR1cm4gJE9iamVjdCh2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCdlcy10by1wcmltaXRpdmUvZXMyMDE1Jyk7XG5cbi8vIGh0dHBzOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3ByaW1pdGl2ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdHJldHVybiB0b1ByaW1pdGl2ZShpbnB1dCwgYXJndW1lbnRzWzFdKTtcblx0fVxuXHRyZXR1cm4gdG9QcmltaXRpdmUoaW5wdXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRTdHJpbmcgPSBHZXRJbnRyaW5zaWMoJyVTdHJpbmclJyk7XG52YXIgJFR5cGVFcnJvciA9IEdldEludHJpbnNpYygnJVR5cGVFcnJvciUnKTtcblxuLy8gaHR0cHM6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvc3RyaW5nXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9TdHJpbmcoYXJndW1lbnQpIHtcblx0aWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N5bWJvbCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcblx0fVxuXHRyZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9OdW1iZXIgPSByZXF1aXJlKCcuL1RvTnVtYmVyJyk7XG5cbi8vIGh0dHA6Ly8yNjIuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy81LjEvI3NlYy05LjZcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUb1VpbnQzMih4KSB7XG5cdHJldHVybiBUb051bWJlcih4KSA+Pj4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkVHlwZUVycm9yID0gR2V0SW50cmluc2ljKCclVHlwZUVycm9yJScpO1xuXG4vLyBodHRwOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvNS4xLyNzZWMtOS4xMFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENoZWNrT2JqZWN0Q29lcmNpYmxlKHZhbHVlLCBvcHRNZXNzYWdlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3Iob3B0TWVzc2FnZSB8fCAoJ0Nhbm5vdCBjYWxsIG1ldGhvZCBvbiAnICsgdmFsdWUpKTtcblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkdGVzdCA9IEdldEludHJpbnNpYygnUmVnRXhwLnByb3RvdHlwZS50ZXN0Jyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZ2V4VGVzdGVyKHJlZ2V4KSB7XG5cdHJldHVybiBjYWxsQmluZCgkdGVzdCwgcmVnZXgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiAwICovXG4vLyB0aGUgY29kZSBpcyBzdHJ1Y3R1cmVkIHRoaXMgd2F5IHNvIHRoYXQgYnVuZGxlcnMgY2FuXG4vLyBhbGlhcyBvdXQgYGhhcy1zeW1ib2xzYCB0byBgKCkgPT4gdHJ1ZWAgb3IgYCgpID0+IGZhbHNlYCBpZiB5b3VyIHRhcmdldFxuLy8gZW52aXJvbm1lbnRzJyBTeW1ib2wgY2FwYWJpbGl0aWVzIGFyZSBrbm93biwgYW5kIHRoZW4gdXNlXG4vLyBkZWFkIGNvZGUgZWxpbWluYXRpb24gb24gdGhlIHJlc3Qgb2YgdGhpcyBtb2R1bGUuXG4vL1xuLy8gU2ltaWxhcmx5LCBgaXNhcnJheWAgY2FuIGJlIGFsaWFzZWQgdG8gYEFycmF5LmlzQXJyYXlgIGlmXG4vLyBhdmFpbGFibGUgaW4gYWxsIHRhcmdldCBlbnZpcm9ubWVudHMuXG5cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xuXG5pZiAocmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpIHx8IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJykoKSkge1xuXHR2YXIgJGl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuXHQvLyBTeW1ib2wgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5IG9yIHNoYW1tZWRcblx0Ly8gbmF0aXZlbHk6XG5cdC8vICAtIENocm9tZSA+PSAzOFxuXHQvLyAgLSBFZGdlIDEyLTE0PywgRWRnZSA+PSAxNSBmb3Igc3VyZVxuXHQvLyAgLSBGRiA+PSAzNlxuXHQvLyAgLSBTYWZhcmkgPj0gOVxuXHQvLyAgLSBub2RlID49IDAuMTJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuXHRcdC8vIGFsdGVybmF0aXZlbHksIGBpdGVyYWJsZVskaXRlcmF0b3JdPy4oKWBcblx0XHRpZiAoaXRlcmFibGUgIT0gbnVsbCAmJiB0eXBlb2YgaXRlcmFibGVbJGl0ZXJhdG9yXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBpdGVyYWJsZVskaXRlcmF0b3JdKCk7XG5cdFx0fVxuXHRcdGlmIChpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcblx0XHRcdC8vIGFyZ3VtZW50cyBvYmplY3RzIGxhY2sgU3ltYm9sLml0ZXJhdG9yXG5cdFx0XHQvLyAtIG5vZGUgMC4xMlxuXHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZVskaXRlcmF0b3JdLmNhbGwoaXRlcmFibGUpO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cdC8vIFN5bWJvbCBpcyBub3QgYXZhaWxhYmxlLCBuYXRpdmUgb3Igc2hhbW1lZFxuXHR2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblx0dmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG5cdHZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cdHZhciAkTWFwID0gR2V0SW50cmluc2ljKCclTWFwJScsIHRydWUpO1xuXHR2YXIgJFNldCA9IEdldEludHJpbnNpYygnJVNldCUnLCB0cnVlKTtcblx0dmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblx0dmFyICRhcnJheVB1c2ggPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5wdXNoJyk7XG5cdHZhciAkY2hhckNvZGVBdCA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0Jyk7XG5cdHZhciAkc3RyaW5nU2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcblxuXHR2YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gZnVuY3Rpb24gYWR2YW5jZVN0cmluZ0luZGV4KFMsIGluZGV4KSB7XG5cdFx0dmFyIGxlbmd0aCA9IFMubGVuZ3RoO1xuXHRcdGlmICgoaW5kZXggKyAxKSA+PSBsZW5ndGgpIHtcblx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0ID0gJGNoYXJDb2RlQXQoUywgaW5kZXgpO1xuXHRcdGlmIChmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRikge1xuXHRcdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0XHR9XG5cblx0XHR2YXIgc2Vjb25kID0gJGNoYXJDb2RlQXQoUywgaW5kZXggKyAxKTtcblx0XHRpZiAoc2Vjb25kIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRikge1xuXHRcdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXggKyAyO1xuXHR9O1xuXG5cdHZhciBnZXRBcnJheUl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0QXJyYXlJdGVyYXRvcihhcnJheWxpa2UpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0XHRcdHZhciBkb25lID0gaSA+PSBhcnJheWxpa2UubGVuZ3RoO1xuXHRcdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRcdGlmICghZG9uZSkge1xuXHRcdFx0XHRcdHZhbHVlID0gYXJyYXlsaWtlW2ldO1xuXHRcdFx0XHRcdGkgKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGRvbmU6IGRvbmUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHR2YXIgZ2V0Tm9uQ29sbGVjdGlvbkl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0Tm9uQ29sbGVjdGlvbkl0ZXJhdG9yKGl0ZXJhYmxlLCBub1ByaW1vcmRpYWxDb2xsZWN0aW9ucykge1xuXHRcdGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcblx0XHRcdHJldHVybiBnZXRBcnJheUl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0XHR9XG5cdFx0aWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcblx0XHRcdFx0XHR2YXIgbmV4dEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KGl0ZXJhYmxlLCBpKTtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSAkc3RyaW5nU2xpY2UoaXRlcmFibGUsIGksIG5leHRJbmRleCk7XG5cdFx0XHRcdFx0aSA9IG5leHRJbmRleDtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZG9uZTogbmV4dEluZGV4ID4gaXRlcmFibGUubGVuZ3RoLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBlczYtc2hpbSBhbmQgZXMtc2hpbXMnIGVzLW1hcCB1c2UgYSBzdHJpbmcgXCJfZXM2LXNoaW0gaXRlcmF0b3JfXCIgcHJvcGVydHkgb24gZGlmZmVyZW50IGl0ZXJhYmxlcywgc3VjaCBhcyBNYXBJdGVyYXRvci5cblx0XHRpZiAobm9Qcmltb3JkaWFsQ29sbGVjdGlvbnMgJiYgdHlwZW9mIGl0ZXJhYmxlWydfZXM2LXNoaW0gaXRlcmF0b3JfJ10gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gaXRlcmFibGVbJ19lczYtc2hpbSBpdGVyYXRvcl8nXSgpO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoISRNYXAgJiYgISRTZXQpIHtcblx0XHQvLyB0aGUgb25seSBsYW5ndWFnZSBpdGVyYWJsZXMgYXJlIEFycmF5LCBTdHJpbmcsIGFyZ3VtZW50c1xuXHRcdC8vIC0gU2FmYXJpIDw9IDYuMFxuXHRcdC8vIC0gQ2hyb21lIDwgMzhcblx0XHQvLyAtIG5vZGUgPCAwLjEyXG5cdFx0Ly8gLSBGRiA8IDEzXG5cdFx0Ly8gLSBJRSA8IDExXG5cdFx0Ly8gLSBFZGdlIDwgMTFcblxuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcblx0XHRcdGlmIChpdGVyYWJsZSAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBnZXROb25Db2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUsIHRydWUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gZWl0aGVyIE1hcCBvciBTZXQgYXJlIGF2YWlsYWJsZSwgYnV0IFN5bWJvbCBpcyBub3Rcblx0XHQvLyAtIGVzNi1zaGltIG9uIGFuIEVTNSBicm93c2VyXG5cdFx0Ly8gLSBTYWZhcmkgNi4yIChtYXliZSA2LjE/KVxuXHRcdC8vIC0gRkYgdlsxMywgMzYpXG5cdFx0Ly8gLSBJRSAxMVxuXHRcdC8vIC0gRWRnZSAxMVxuXHRcdC8vIC0gU2FmYXJpIHZbNiwgOSlcblxuXHRcdHZhciBpc01hcCA9IHJlcXVpcmUoJ2lzLW1hcCcpO1xuXHRcdHZhciBpc1NldCA9IHJlcXVpcmUoJ2lzLXNldCcpO1xuXG5cdFx0Ly8gRmlyZWZveCA+PSAyNywgSUUgMTEsIFNhZmFyaSA2LjIgLSA5LCBFZGdlIDExLCBlczYtc2hpbSBpbiBvbGRlciBlbnZzLCBhbGwgaGF2ZSBmb3JFYWNoXG5cdFx0dmFyICRtYXBGb3JFYWNoID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmZvckVhY2gnLCB0cnVlKTtcblx0XHR2YXIgJHNldEZvckVhY2ggPSBjYWxsQm91bmQoJ1NldC5wcm90b3R5cGUuZm9yRWFjaCcsIHRydWUpO1xuXHRcdGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXByb2Nlc3MudmVyc2lvbnMgfHwgIXByb2Nlc3MudmVyc2lvbnMubm9kZSkgeyAvLyBcImlmIGlzIG5vdCBub2RlXCJcblxuXHRcdFx0Ly8gRmlyZWZveCAxNyAtIDI2IGhhcyBgLml0ZXJhdG9yKClgLCB3aG9zZSBpdGVyYXRvciBgLm5leHQoKWAgZWl0aGVyXG5cdFx0XHQvLyByZXR1cm5zIGEgdmFsdWUsIG9yIHRocm93cyBhIFN0b3BJdGVyYXRpb24gb2JqZWN0LiBUaGVzZSBicm93c2Vyc1xuXHRcdFx0Ly8gZG8gbm90IGhhdmUgYW55IG90aGVyIG1lY2hhbmlzbSBmb3IgaXRlcmF0aW9uLlxuXHRcdFx0dmFyICRtYXBJdGVyYXRvciA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5pdGVyYXRvcicsIHRydWUpO1xuXHRcdFx0dmFyICRzZXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5pdGVyYXRvcicsIHRydWUpO1xuXHRcdFx0dmFyIGdldFN0b3BJdGVyYXRpb25JdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuXHRcdFx0XHR2YXIgZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdGRvbmU6IGRvbmUsXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBpdGVyYXRvci5uZXh0KClcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdFx0ZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9uZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0Ly8gRmlyZWZveCAyNy0zNSwgYW5kIHNvbWUgb2xkZXIgZXM2LXNoaW0gdmVyc2lvbnMsIHVzZSBhIHN0cmluZyBcIkBAaXRlcmF0b3JcIiBwcm9wZXJ0eVxuXHRcdC8vIHRoaXMgcmV0dXJucyBhIHByb3BlciBpdGVyYXRvciBvYmplY3QsIHNvIHdlIHNob3VsZCB1c2UgaXQgaW5zdGVhZCBvZiBmb3JFYWNoLlxuXHRcdC8vIG5ld2VyIGVzNi1zaGltIHZlcnNpb25zIHVzZSBhIHN0cmluZyBcIl9lczYtc2hpbSBpdGVyYXRvcl9cIiBwcm9wZXJ0eS5cblx0XHR2YXIgJG1hcEF0QXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5AQGl0ZXJhdG9yJywgdHJ1ZSkgfHwgY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLl9lczYtc2hpbSBpdGVyYXRvcl8nLCB0cnVlKTtcblx0XHR2YXIgJHNldEF0QXRJdGVyYXRvciA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5AQGl0ZXJhdG9yJywgdHJ1ZSkgfHwgY2FsbEJvdW5kKCdTZXQucHJvdG90eXBlLl9lczYtc2hpbSBpdGVyYXRvcl8nLCB0cnVlKTtcblxuXHRcdHZhciBnZXRDb2xsZWN0aW9uSXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRDb2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUpIHtcblx0XHRcdGlmIChpc01hcChpdGVyYWJsZSkpIHtcblx0XHRcdFx0aWYgKCRtYXBJdGVyYXRvcikge1xuXHRcdFx0XHRcdHJldHVybiBnZXRTdG9wSXRlcmF0aW9uSXRlcmF0b3IoJG1hcEl0ZXJhdG9yKGl0ZXJhYmxlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCRtYXBBdEF0SXRlcmF0b3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gJG1hcEF0QXRJdGVyYXRvcihpdGVyYWJsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCRtYXBGb3JFYWNoKSB7XG5cdFx0XHRcdFx0dmFyIGVudHJpZXMgPSBbXTtcblx0XHRcdFx0XHQkbWFwRm9yRWFjaChpdGVyYWJsZSwgZnVuY3Rpb24gKHYsIGspIHtcblx0XHRcdFx0XHRcdCRhcnJheVB1c2goZW50cmllcywgW2ssIHZdKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0QXJyYXlJdGVyYXRvcihlbnRyaWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzU2V0KGl0ZXJhYmxlKSkge1xuXHRcdFx0XHRpZiAoJHNldEl0ZXJhdG9yKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdldFN0b3BJdGVyYXRpb25JdGVyYXRvcigkc2V0SXRlcmF0b3IoaXRlcmFibGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJHNldEF0QXRJdGVyYXRvcikge1xuXHRcdFx0XHRcdHJldHVybiAkc2V0QXRBdEl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJHNldEZvckVhY2gpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cdFx0XHRcdFx0JHNldEZvckVhY2goaXRlcmFibGUsIGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdFx0XHQkYXJyYXlQdXNoKHZhbHVlcywgdik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIGdldEFycmF5SXRlcmF0b3IodmFsdWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG5cdFx0XHRyZXR1cm4gZ2V0Q29sbGVjdGlvbkl0ZXJhdG9yKGl0ZXJhYmxlKSB8fCBnZXROb25Db2xsZWN0aW9uSXRlcmF0b3IoaXRlcmFibGUpO1xuXHRcdH07XG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnO1xuXG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcmltaXRpdmUnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnaXMtY2FsbGFibGUnKTtcbnZhciBpc0RhdGUgPSByZXF1aXJlKCdpcy1kYXRlLW9iamVjdCcpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnaXMtc3ltYm9sJyk7XG5cbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KSB7XG5cdGlmICh0eXBlb2YgTyA9PT0gJ3VuZGVmaW5lZCcgfHwgTyA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIG1ldGhvZCBvbiAnICsgTyk7XG5cdH1cblx0aWYgKHR5cGVvZiBoaW50ICE9PSAnc3RyaW5nJyB8fCAoaGludCAhPT0gJ251bWJlcicgJiYgaGludCAhPT0gJ3N0cmluZycpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaGludCBtdXN0IGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIicpO1xuXHR9XG5cdHZhciBtZXRob2ROYW1lcyA9IGhpbnQgPT09ICdzdHJpbmcnID8gWyd0b1N0cmluZycsICd2YWx1ZU9mJ10gOiBbJ3ZhbHVlT2YnLCAndG9TdHJpbmcnXTtcblx0dmFyIG1ldGhvZCwgcmVzdWx0LCBpO1xuXHRmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcblx0XHRtZXRob2QgPSBPW21ldGhvZE5hbWVzW2ldXTtcblx0XHRpZiAoaXNDYWxsYWJsZShtZXRob2QpKSB7XG5cdFx0XHRyZXN1bHQgPSBtZXRob2QuY2FsbChPKTtcblx0XHRcdGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIGRlZmF1bHQgdmFsdWUnKTtcbn07XG5cbnZhciBHZXRNZXRob2QgPSBmdW5jdGlvbiBHZXRNZXRob2QoTywgUCkge1xuXHR2YXIgZnVuYyA9IE9bUF07XG5cdGlmIChmdW5jICE9PSBudWxsICYmIHR5cGVvZiBmdW5jICE9PSAndW5kZWZpbmVkJykge1xuXHRcdGlmICghaXNDYWxsYWJsZShmdW5jKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihmdW5jICsgJyByZXR1cm5lZCBmb3IgcHJvcGVydHkgJyArIFAgKyAnIG9mIG9iamVjdCAnICsgTyArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmM7XG5cdH1cblx0cmV0dXJuIHZvaWQgMDtcbn07XG5cbi8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCkge1xuXHRpZiAoaXNQcmltaXRpdmUoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIGlucHV0O1xuXHR9XG5cdHZhciBoaW50ID0gJ2RlZmF1bHQnO1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRpZiAoYXJndW1lbnRzWzFdID09PSBTdHJpbmcpIHtcblx0XHRcdGhpbnQgPSAnc3RyaW5nJztcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50c1sxXSA9PT0gTnVtYmVyKSB7XG5cdFx0XHRoaW50ID0gJ251bWJlcic7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGV4b3RpY1RvUHJpbTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRpZiAoU3ltYm9sLnRvUHJpbWl0aXZlKSB7XG5cdFx0XHRleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIFN5bWJvbC50b1ByaW1pdGl2ZSk7XG5cdFx0fSBlbHNlIGlmIChpc1N5bWJvbChpbnB1dCkpIHtcblx0XHRcdGV4b3RpY1RvUHJpbSA9IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZjtcblx0XHR9XG5cdH1cblx0aWYgKHR5cGVvZiBleG90aWNUb1ByaW0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBoaW50KTtcblx0XHRpZiAoaXNQcmltaXRpdmUocmVzdWx0KSkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigndW5hYmxlIHRvIGNvbnZlcnQgZXhvdGljIG9iamVjdCB0byBwcmltaXRpdmUnKTtcblx0fVxuXHRpZiAoaGludCA9PT0gJ2RlZmF1bHQnICYmIChpc0RhdGUoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkpIHtcblx0XHRoaW50ID0gJ3N0cmluZyc7XG5cdH1cblx0cmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIGhpbnQgPT09ICdkZWZhdWx0JyA/ICdudW1iZXInIDogaGludCk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm9yRWFjaEFycmF5ID0gZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaFN0cmluZyA9IGZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlcmF0b3Ioc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaE9iamVjdCA9IGZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgb2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCB0aGlzQXJnKSB7XG4gICAgaWYgKCFpc0NhbGxhYmxlKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjZWl2ZXI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICByZWNlaXZlciA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgaWYgKHRvU3RyLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSBmdW5jdGlvbiBmdW5jdGlvbnNIYXZlTmFtZXMoKSB7XG5cdHJldHVybiB0eXBlb2YgZnVuY3Rpb24gZigpIHt9Lm5hbWUgPT09ICdzdHJpbmcnO1xufTtcblxudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKGdPUEQpIHtcblx0dHJ5IHtcblx0XHRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0Z09QRCA9IG51bGw7XG5cdH1cbn1cblxuZnVuY3Rpb25zSGF2ZU5hbWVzLmZ1bmN0aW9uc0hhdmVDb25maWd1cmFibGVOYW1lcyA9IGZ1bmN0aW9uIGZ1bmN0aW9uc0hhdmVDb25maWd1cmFibGVOYW1lcygpIHtcblx0aWYgKCFmdW5jdGlvbnNIYXZlTmFtZXMoKSB8fCAhZ09QRCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR2YXIgZGVzYyA9IGdPUEQoZnVuY3Rpb24gKCkge30sICduYW1lJyk7XG5cdHJldHVybiAhIWRlc2MgJiYgISFkZXNjLmNvbmZpZ3VyYWJsZTtcbn07XG5cbnZhciAkYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXG5mdW5jdGlvbnNIYXZlTmFtZXMuYm91bmRGdW5jdGlvbnNIYXZlTmFtZXMgPSBmdW5jdGlvbiBib3VuZEZ1bmN0aW9uc0hhdmVOYW1lcygpIHtcblx0cmV0dXJuIGZ1bmN0aW9uc0hhdmVOYW1lcygpICYmIHR5cGVvZiAkYmluZCA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiBmKCkge30uYmluZCgpLm5hbWUgIT09ICcnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbnNIYXZlTmFtZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJEJpZ0ludCA9IGdsb2JhbC5CaWdJbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlQmlnSW50cygpIHtcblx0cmV0dXJuIHR5cGVvZiAkQmlnSW50ID09PSAnZnVuY3Rpb24nXG5cdFx0JiYgdHlwZW9mIEJpZ0ludCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCYmIHR5cGVvZiAkQmlnSW50KDQyKSA9PT0gJ2JpZ2ludCcgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG5cdFx0JiYgdHlwZW9mIEJpZ0ludCg0MikgPT09ICdiaWdpbnQnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHRyeSB7XG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbmhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBmdW5jdGlvbiBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZygpIHtcblx0Ly8gbm9kZSB2MC42IGhhcyBhIGJ1ZyB3aGVyZSBhcnJheSBsZW5ndGhzIGNhbiBiZSBTZXQgYnV0IG5vdCBEZWZpbmVkXG5cdGlmICghaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gJGRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJbiBGaXJlZm94IDQtMjIsIGRlZmluaW5nIGxlbmd0aCBvbiBhbiBhcnJheSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc0JpZ0ludHMgPSByZXF1aXJlKCdoYXMtYmlnaW50cycpKCk7XG5cbmlmIChoYXNCaWdJbnRzKSB7XG5cdHZhciBiaWdJbnRWYWx1ZU9mID0gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mO1xuXHR2YXIgdHJ5QmlnSW50ID0gZnVuY3Rpb24gdHJ5QmlnSW50T2JqZWN0KHZhbHVlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGJpZ0ludFZhbHVlT2YuY2FsbCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQmlnSW50KHZhbHVlKSB7XG5cdFx0aWYgKFxuXHRcdFx0dmFsdWUgPT09IG51bGxcblx0XHRcdHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG5cdFx0XHR8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG5cdFx0XHR8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG5cdFx0XHR8fCB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnXG5cdFx0XHR8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcblx0XHQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnlCaWdJbnQodmFsdWUpO1xuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0JpZ0ludCh2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZSAmJiB2YWx1ZTtcblx0fTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciAkYm9vbFRvU3RyID0gY2FsbEJvdW5kKCdCb29sZWFuLnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgdHJ5Qm9vbGVhbk9iamVjdCA9IGZ1bmN0aW9uIGJvb2xlYW5CcmFuZENoZWNrKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0JGJvb2xUb1N0cih2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgYm9vbENsYXNzID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGhhc1RvU3RyaW5nVGFnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSA/IHRyeUJvb2xlYW5PYmplY3QodmFsdWUpIDogJHRvU3RyaW5nKHZhbHVlKSA9PT0gYm9vbENsYXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgcmVmbGVjdEFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QgIT09IG51bGwgJiYgUmVmbGVjdC5hcHBseTtcbnZhciBiYWRBcnJheUxpa2U7XG52YXIgaXNDYWxsYWJsZU1hcmtlcjtcbmlmICh0eXBlb2YgcmVmbGVjdEFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcblx0dHJ5IHtcblx0XHRiYWRBcnJheUxpa2UgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdsZW5ndGgnLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgaXNDYWxsYWJsZU1hcmtlcjtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRpc0NhbGxhYmxlTWFya2VyID0ge307XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcblx0XHRyZWZsZWN0QXBwbHkoZnVuY3Rpb24gKCkgeyB0aHJvdyA0MjsgfSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0fSBjYXRjaCAoXykge1xuXHRcdGlmIChfICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkgPSBudWxsO1xuXHRcdH1cblx0fVxufSBlbHNlIHtcblx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcbn1cblxudmFyIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzc1xcYi87XG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KGZuU3RyKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTsgLy8gbm90IGEgZnVuY3Rpb25cblx0fVxufTtcblxudmFyIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25Ub1N0cih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7IC8vIGJldHRlcjogdXNlIGBoYXMtdG9zdHJpbmd0YWdgXG4vKiBnbG9iYWxzIGRvY3VtZW50OiBmYWxzZSAqL1xudmFyIGRvY3VtZW50RG90QWxsID0gdHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZG9jdW1lbnQuYWxsID09PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5hbGwgIT09IHVuZGVmaW5lZCA/IGRvY3VtZW50LmFsbCA6IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RBcHBseVxuXHQ/IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT09IGRvY3VtZW50RG90QWxsKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucHJvdG90eXBlKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dHJ5IHtcblx0XHRcdHJlZmxlY3RBcHBseSh2YWx1ZSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoZSAhPT0gaXNDYWxsYWJsZU1hcmtlcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuICFpc0VTNkNsYXNzRm4odmFsdWUpO1xuXHR9XG5cdDogZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gZG9jdW1lbnREb3RBbGwpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICF2YWx1ZS5wcm90b3R5cGUpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfVxuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBzdHJDbGFzcyA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBzdHJDbGFzcyA9PT0gZm5DbGFzcyB8fCBzdHJDbGFzcyA9PT0gZ2VuQ2xhc3M7XG5cdH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXREYXkgPSBEYXRlLnByb3RvdHlwZS5nZXREYXk7XG52YXIgdHJ5RGF0ZU9iamVjdCA9IGZ1bmN0aW9uIHRyeURhdGVHZXREYXlDYWxsKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0Z2V0RGF5LmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEYXRlT2JqZWN0KHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeURhdGVPYmplY3QodmFsdWUpIDogdG9TdHIuY2FsbCh2YWx1ZSkgPT09IGRhdGVDbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlID8gTWFwIDogbnVsbDtcbnZhciAkU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlID8gU2V0IDogbnVsbDtcblxudmFyIGV4cG9ydGVkO1xuXG5pZiAoISRNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cdGV4cG9ydGVkID0gZnVuY3Rpb24gaXNNYXAoeCkge1xuXHRcdC8vIGBNYXBgIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgZW52aXJvbm1lbnQuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG52YXIgJG1hcEhhcyA9ICRNYXAgPyBNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgJHNldEhhcyA9ICRTZXQgPyBTZXQucHJvdG90eXBlLmhhcyA6IG51bGw7XG5pZiAoIWV4cG9ydGVkICYmICEkbWFwSGFzKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRleHBvcnRlZCA9IGZ1bmN0aW9uIGlzTWFwKHgpIHtcblx0XHQvLyBgTWFwYCBkb2VzIG5vdCBoYXZlIGEgYGhhc2AgbWV0aG9kXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkIHx8IGZ1bmN0aW9uIGlzTWFwKHgpIHtcblx0aWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdCRtYXBIYXMuY2FsbCh4KTtcblx0XHRpZiAoJHNldEhhcykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0JHNldEhhcy5jYWxsKHgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHggaW5zdGFuY2VvZiAkTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bVRvU3RyID0gTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZztcbnZhciB0cnlOdW1iZXJPYmplY3QgPSBmdW5jdGlvbiB0cnlOdW1iZXJPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRudW1Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbnVtQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlOdW1iZXJPYmplY3QodmFsdWUpIDogdG9TdHIuY2FsbCh2YWx1ZSkgPT09IG51bUNsYXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgaGFzO1xudmFyICRleGVjO1xudmFyIGlzUmVnZXhNYXJrZXI7XG52YXIgYmFkU3RyaW5naWZpZXI7XG5cbmlmIChoYXNUb1N0cmluZ1RhZykge1xuXHRoYXMgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHknKTtcblx0JGV4ZWMgPSBjYWxsQm91bmQoJ1JlZ0V4cC5wcm90b3R5cGUuZXhlYycpO1xuXHRpc1JlZ2V4TWFya2VyID0ge307XG5cblx0dmFyIHRocm93UmVnZXhNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhyb3cgaXNSZWdleE1hcmtlcjtcblx0fTtcblx0YmFkU3RyaW5naWZpZXIgPSB7XG5cdFx0dG9TdHJpbmc6IHRocm93UmVnZXhNYXJrZXIsXG5cdFx0dmFsdWVPZjogdGhyb3dSZWdleE1hcmtlclxuXHR9O1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlID09PSAnc3ltYm9sJykge1xuXHRcdGJhZFN0cmluZ2lmaWVyW1N5bWJvbC50b1ByaW1pdGl2ZV0gPSB0aHJvd1JlZ2V4TWFya2VyO1xuXHR9XG59XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciByZWdleENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVG9TdHJpbmdUYWdcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdD8gZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkge1xuXHRcdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRCh2YWx1ZSwgJ2xhc3RJbmRleCcpO1xuXHRcdHZhciBoYXNMYXN0SW5kZXhEYXRhUHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGhhcyhkZXNjcmlwdG9yLCAndmFsdWUnKTtcblx0XHRpZiAoIWhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHQkZXhlYyh2YWx1ZSwgYmFkU3RyaW5naWZpZXIpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBlID09PSBpc1JlZ2V4TWFya2VyO1xuXHRcdH1cblx0fVxuXHQ6IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0XHQvLyBJbiBvbGRlciBicm93c2VycywgdHlwZW9mIHJlZ2V4IGluY29ycmVjdGx5IHJldHVybnMgJ2Z1bmN0aW9uJ1xuXHRcdGlmICghdmFsdWUgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSByZWdleENsYXNzO1xuXHR9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJE1hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZSA/IE1hcCA6IG51bGw7XG52YXIgJFNldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZSA/IFNldCA6IG51bGw7XG5cbnZhciBleHBvcnRlZDtcblxuaWYgKCEkU2V0KSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRleHBvcnRlZCA9IGZ1bmN0aW9uIGlzU2V0KHgpIHtcblx0XHQvLyBgU2V0YCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIGVudmlyb25tZW50LlxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxudmFyICRtYXBIYXMgPSAkTWFwID8gTWFwLnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyICRzZXRIYXMgPSAkU2V0ID8gU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xuaWYgKCFleHBvcnRlZCAmJiAhJHNldEhhcykge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ZXhwb3J0ZWQgPSBmdW5jdGlvbiBpc1NldCh4KSB7XG5cdFx0Ly8gYFNldGAgZG9lcyBub3QgaGF2ZSBhIGBoYXNgIG1ldGhvZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlZCB8fCBmdW5jdGlvbiBpc1NldCh4KSB7XG5cdGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHQkc2V0SGFzLmNhbGwoeCk7XG5cdFx0aWYgKCRtYXBIYXMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdCRtYXBIYXMuY2FsbCh4KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB4IGluc3RhbmNlb2YgJFNldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG5cdH0gY2F0Y2ggKGUpIHt9XG5cdHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJWYWx1ZSA9IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZjtcbnZhciB0cnlTdHJpbmdPYmplY3QgPSBmdW5jdGlvbiB0cnlTdHJpbmdPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRzdHJWYWx1ZS5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc3RyQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlTdHJpbmdPYmplY3QodmFsdWUpIDogdG9TdHIuY2FsbCh2YWx1ZSkgPT09IHN0ckNsYXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG5pZiAoaGFzU3ltYm9scykge1xuXHR2YXIgc3ltVG9TdHIgPSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgc3ltU3RyaW5nUmVnZXggPSAvXlN5bWJvbFxcKC4qXFwpJC87XG5cdHZhciBpc1N5bWJvbE9iamVjdCA9IGZ1bmN0aW9uIGlzUmVhbFN5bWJvbE9iamVjdCh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUudmFsdWVPZigpICE9PSAnc3ltYm9sJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gc3ltU3RyaW5nUmVnZXgudGVzdChzeW1Ub1N0ci5jYWxsKHZhbHVlKSk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKHRvU3RyLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBTeW1ib2xdJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbHVlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xufSBlbHNlIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG5cdFx0Ly8gdGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFN5bWJvbHMuXG5cdFx0cmV0dXJuIGZhbHNlICYmIHZhbHVlO1xuXHR9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIFdlYWtNYXAucHJvdG90eXBlID8gV2Vha01hcCA6IG51bGw7XG52YXIgJFdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrU2V0LnByb3RvdHlwZSA/IFdlYWtTZXQgOiBudWxsO1xuXG52YXIgZXhwb3J0ZWQ7XG5cbmlmICghJFdlYWtNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cdGV4cG9ydGVkID0gZnVuY3Rpb24gaXNXZWFrTWFwKHgpIHtcblx0XHQvLyBgV2Vha01hcGAgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBlbnZpcm9ubWVudC5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbnZhciAkbWFwSGFzID0gJFdlYWtNYXAgPyAkV2Vha01hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciAkc2V0SGFzID0gJFdlYWtTZXQgPyAkV2Vha1NldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbmlmICghZXhwb3J0ZWQgJiYgISRtYXBIYXMpIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cdGV4cG9ydGVkID0gZnVuY3Rpb24gaXNXZWFrTWFwKHgpIHtcblx0XHQvLyBgV2Vha01hcGAgZG9lcyBub3QgaGF2ZSBhIGBoYXNgIG1ldGhvZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlZCB8fCBmdW5jdGlvbiBpc1dlYWtNYXAoeCkge1xuXHRpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0JG1hcEhhcy5jYWxsKHgsICRtYXBIYXMpO1xuXHRcdGlmICgkc2V0SGFzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQkc2V0SGFzLmNhbGwoeCwgJHNldEhhcyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4geCBpbnN0YW5jZW9mICRXZWFrTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12M1xuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICRXZWFrU2V0ID0gR2V0SW50cmluc2ljKCclV2Vha1NldCUnLCB0cnVlKTtcblxudmFyICRzZXRIYXMgPSBjYWxsQm91bmQoJ1dlYWtTZXQucHJvdG90eXBlLmhhcycsIHRydWUpO1xuXG5pZiAoJHNldEhhcykge1xuXHR2YXIgJG1hcEhhcyA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1dlYWtTZXQoeCkge1xuXHRcdGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdCRzZXRIYXMoeCwgJHNldEhhcyk7XG5cdFx0XHRpZiAoJG1hcEhhcykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdCRtYXBIYXMoeCwgJG1hcEhhcyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHggaW5zdGFuY2VvZiAkV2Vha1NldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjNcblx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn0gZWxzZSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzV2Vha1NldCh4KSB7XG5cdFx0Ly8gYFdlYWtTZXRgIGRvZXMgbm90IGV4aXN0LCBvciBkb2VzIG5vdCBoYXZlIGEgYGhhc2AgbWV0aG9kXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IHJlcXVpcmUoJ2hhcy1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgZnVuY3Rpb25zSGF2ZUNvbmZpZ3VyYWJsZU5hbWVzID0gcmVxdWlyZSgnZnVuY3Rpb25zLWhhdmUtbmFtZXMnKS5mdW5jdGlvbnNIYXZlQ29uZmlndXJhYmxlTmFtZXMoKTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcoKTtcblxudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtb2NrUHJvcGVydHkob2JqLCBwcm9wLCBvcHRpb25zKSB7XG5cdGlmIChoYXMob3B0aW9ucywgJ25vbkVudW1lcmFibGUnKSAmJiB0eXBlb2Ygb3B0aW9ucy5ub25FbnVtZXJhYmxlICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkVudW1lcmFibGVgIG9wdGlvbiwgd2hlbiBwcmVzZW50LCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cdGlmIChoYXMob3B0aW9ucywgJ25vbldyaXRhYmxlJykgJiYgdHlwZW9mIG9wdGlvbnMubm9uV3JpdGFibGUgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uRW51bWVyYWJsZWAgb3B0aW9uLCB3aGVuIHByZXNlbnQsIG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblx0aWYgKGhhcyhvcHRpb25zLCAnZGVsZXRlJykgJiYgdHlwZW9mIG9wdGlvbnNbJ2RlbGV0ZSddICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGRlbGV0ZWAgb3B0aW9uLCB3aGVuIHByZXNlbnQsIG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgd2FudHNEYXRhID0gaGFzKG9wdGlvbnMsICd2YWx1ZScpIHx8IGhhcyhvcHRpb25zLCAnbm9uV3JpdGFibGUnKTtcblx0dmFyIHdhbnRzQWNjZXNzb3IgPSBoYXMob3B0aW9ucywgJ2dldCcpIHx8IGhhcyhvcHRpb25zLCAnc2V0Jyk7XG5cblx0aWYgKHdhbnRzQWNjZXNzb3IpIHtcblx0XHRpZiAod2FudHNEYXRhKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYHZhbHVlYCBhbmQgYG5vbldyaXRhYmxlYCBvcHRpb25zIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBgZ2V0YC9gc2V0YCBvcHRpb25zJyk7XG5cdFx0fVxuXHRcdGlmIChcblx0XHRcdChoYXMob3B0aW9ucywgJ2dldCcpICYmIHR5cGVvZiBvcHRpb25zLmdldCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb3B0aW9ucy5nZXQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgfHwgKGhhcyhvcHRpb25zLCAnc2V0JykgJiYgdHlwZW9mIG9wdGlvbnMuc2V0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvcHRpb25zLnNldCAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGdldGAgYW5kIGBzZXRgIG9wdGlvbnMsIHdoZW4gcHJlc2VudCwgbXVzdCBiZSBmdW5jdGlvbnMgb3IgYHVuZGVmaW5lZGAnKTtcblx0XHR9XG5cdFx0aWYgKCFnT1BEIHx8ICEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3RoZSBgZ2V0YC9gc2V0YCBvcHRpb25zIHJlcXVpcmUgbmF0aXZlIGdldHRlci9zZXR0ZXIgc3VwcG9ydCcpO1xuXHRcdH1cblx0fVxuXHRpZiAob3B0aW9uc1snZGVsZXRlJ10gJiYgKHdhbnRzRGF0YSB8fCB3YW50c0FjY2Vzc29yIHx8IGhhcyhvcHRpb25zLCAnbm9uRW51bWVyYWJsZScpKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgZGVsZXRlYCBvcHRpb24gbXVzdCBub3QgYmUgc2V0IHRvIHRydWUgd2hlbiBhbnkgb2YgYHZhbHVlYCwgYGdldGAsIGBzZXRgLCBgbm9uV3JpdGFibGVgLCBvciBgbm9uRW51bWVyYWJsZWAgYXJlIHByb3ZpZGVkJyk7XG5cdH1cblxuXHR2YXIgb2JqSXNBcnJheSA9IGlzQXJyYXkob2JqKTtcblx0dmFyIG9yaWdEZXNjcmlwdG9yID0gZ09QRFxuXHRcdD8gZ09QRChvYmosIHByb3ApXG5cdFx0OiB7XG5cdFx0XHRjb25maWd1cmFibGU6IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgJiYgcHJvcCA9PT0gJ25hbWUnID8gZnVuY3Rpb25zSGF2ZUNvbmZpZ3VyYWJsZU5hbWVzIDogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6ICEob2JqSXNBcnJheSAmJiBwcm9wID09PSAnbGVuZ3RoJyksXG5cdFx0XHR2YWx1ZTogb2JqW3Byb3BdLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9O1xuXG5cdHZhciBvcmlnQ29uZmlndXJhYmxlID0gb3JpZ0Rlc2NyaXB0b3IgPyBvcmlnRGVzY3JpcHRvci5jb25maWd1cmFibGUgOiB0cnVlO1xuXHR2YXIgb3JpZ0VudW1lcmFibGUgPSBvcmlnRGVzY3JpcHRvciA/IG9yaWdEZXNjcmlwdG9yLmVudW1lcmFibGUgOiB0cnVlO1xuXG5cdGlmICh3YW50c0FjY2Vzc29yKSB7XG5cdFx0dmFyIGhhc0dldHRlciA9IG9yaWdEZXNjcmlwdG9yICYmIHR5cGVvZiBvcmlnRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbic7XG5cdFx0dmFyIGhhc1NldHRlciA9IG9yaWdEZXNjcmlwdG9yICYmIHR5cGVvZiBvcmlnRGVzY3JpcHRvci5zZXQgPT09ICdmdW5jdGlvbic7XG5cdFx0dmFyIGhhc0Z1dHVyZUdldHRlciA9IGhhcyhvcHRpb25zLCAnZ2V0JykgPyB0eXBlb2Ygb3B0aW9ucy5nZXQgPT09ICdmdW5jdGlvbicgOiBoYXNHZXR0ZXI7XG5cdFx0dmFyIGhhc0Z1dHVyZVNldHRlciA9IGhhcyhvcHRpb25zLCAnc2V0JykgPyB0eXBlb2Ygb3B0aW9ucy5zZXQgPT09ICdmdW5jdGlvbicgOiBoYXNTZXR0ZXI7XG5cdFx0aWYgKCFoYXNGdXR1cmVHZXR0ZXIgJiYgIWhhc0Z1dHVyZVNldHRlcikge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ3doZW4gdGhlIGBnZXRgIG9yIGBzZXRgIG9wdGlvbnMgYXJlIHByb3ZpZGVkLCB0aGUgbW9ja2VkIG9iamVjdCBwcm9wZXJ0eSBtdXN0IGVuZCB1cCB3aXRoIGF0IGxlYXN0IG9uZSBvZiBhIGdldHRlciBvciBhIHNldHRlciBmdW5jdGlvbicpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBpc0NoYW5naW5nRW51bWVyYWJpbGl0eSA9IGhhcyhvcHRpb25zLCAnbm9uRW51bWVyYWJsZScpID8gIW9wdGlvbnMubm9uRW51bWVyYWJsZSAhPT0gb3JpZ0VudW1lcmFibGUgOiBmYWxzZTtcblx0aWYgKG9yaWdEZXNjcmlwdG9yICYmICFvcmlnRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcblx0XHRpZiAoaXNDaGFuZ2luZ0VudW1lcmFiaWxpdHkpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgJyArIHByb3AgKyAnYCBpcyBub25jb25maWd1cmFibGUsIGFuZCBjYW4gbm90IGJlIGNoYW5nZWQnKTtcblx0XHR9XG5cdFx0aWYgKHdhbnRzQWNjZXNzb3IpIHtcblx0XHRcdGlmIChoYXMob3JpZ0Rlc2NyaXB0b3IsICd2YWx1ZScpKSB7XG5cdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgJyArIHByb3AgKyAnYCBpcyBhIG5vbmNvbmZpZ3VyYWJsZSBkYXRhIHByb3BlcnR5LCBhbmQgY2FuIG5vdCBiZSBjaGFuZ2VkIHRvIGFuIGFjY2Vzc29yJyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpc0NoYW5naW5nR2V0dGVyID0gaGFzKG9wdGlvbnMsICdnZXQnKSAmJiBoYXMob3JpZ0Rlc2NyaXB0b3IsICdnZXQnKSAmJiBvcHRpb25zLmdldCAhPT0gb3JpZ0Rlc2NyaXB0b3IuZ2V0O1xuXHRcdFx0dmFyIGlzQ2hhbmdpbmdTZXR0ZXIgPSBoYXMob3B0aW9ucywgJ3NldCcpICYmIGhhcyhvcmlnRGVzY3JpcHRvciwgJ3NldCcpICYmIG9wdGlvbnMuc2V0ICE9PSBvcmlnRGVzY3JpcHRvci5zZXQ7XG5cblx0XHRcdGlmIChpc0NoYW5naW5nR2V0dGVyIHx8IGlzQ2hhbmdpbmdTZXR0ZXIpIHtcblx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2AnICsgcHJvcCArICdgIGlzIG5vbmNvbmZpZ3VyYWJsZSwgYW5kIGNhbiBub3QgYmUgY2hhbmdlZCcpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJlc3RvcmUoKSB7fTtcblx0XHR9XG5cdFx0aWYgKGhhcyhvcmlnRGVzY3JpcHRvciwgJ2dldCcpIHx8IGhhcyhvcmlnRGVzY3JpcHRvciwgJ3NldCcpKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYCcgKyBwcm9wICsgJ2AgaXMgYSBub25jb25maWd1cmFibGUgYWNjZXNzb3IgcHJvcGVydHksIGFuZCBjYW4gbm90IGJlIGNoYW5nZWQgdG8gYSBkYXRhIHByb3BlcnR5Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGlzQ2hhbmdpbmdWYWx1ZSA9IGhhcyhvcHRpb25zLCAndmFsdWUnKSAmJiBoYXMob3JpZ0Rlc2NyaXB0b3IsICd2YWx1ZScpICYmIG9wdGlvbnMudmFsdWUgIT09IG9yaWdEZXNjcmlwdG9yLnZhbHVlO1xuXHRcdHZhciBpc0NoYW5naW5nV3JpdGVhYmlsaXR5ID0gaGFzKG9wdGlvbnMsICdub25Xcml0YWJsZScpICYmICFvcHRpb25zLm5vbldyaXRhYmxlICE9PSBvcmlnRGVzY3JpcHRvci53cml0YWJsZTtcblxuXHRcdGlmICgoIW9yaWdEZXNjcmlwdG9yLndyaXRhYmxlICYmIGlzQ2hhbmdpbmdWYWx1ZSkgfHwgaXNDaGFuZ2luZ0VudW1lcmFiaWxpdHkgfHwgaXNDaGFuZ2luZ1dyaXRlYWJpbGl0eSkge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2AnICsgcHJvcCArICdgIGlzIG5vbmNvbmZpZ3VyYWJsZSwgYW5kIGNhbiBub3QgYmUgY2hhbmdlZCcpO1xuXHRcdH1cblx0XHRpZiAoIWlzQ2hhbmdpbmdXcml0ZWFiaWxpdHkgJiYgIWlzQ2hhbmdpbmdWYWx1ZSkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJlc3RvcmUoKSB7fTtcblx0XHR9XG5cdH1cblxuXHRpZiAob3B0aW9uc1snZGVsZXRlJ10pIHtcblx0XHRkZWxldGUgb2JqW3Byb3BdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdH0gZWxzZSBpZiAoXG5cdFx0d2FudHNEYXRhXG4gICAgICAgICAgICAmJiAhaXNDaGFuZ2luZ0VudW1lcmFiaWxpdHlcbiAgICAgICAgICAgICYmICghb3JpZ0Rlc2NyaXB0b3IgfHwgb3JpZ0Rlc2NyaXB0b3IuZW51bWVyYWJsZSlcbiAgICAgICAgICAgICYmICghaGFzKG9wdGlvbnMsICdub25Xcml0YWJsZScpIHx8ICFvcHRpb25zLm5vbldyaXRhYmxlKVxuICAgICAgICAgICAgJiYgKCFvcmlnRGVzY3JpcHRvciB8fCBvcmlnRGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAgICAgICAgICYmICghZ09QRCB8fCAhKHByb3AgaW4gb2JqKSlcblx0KSB7XG5cdFx0b2JqW3Byb3BdID0gb3B0aW9ucy52YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHR9IGVsc2Uge1xuXHRcdGlmIChvYmpJc0FycmF5ICYmIHByb3AgPT09ICdsZW5ndGgnICYmIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCd0aGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgRGVmaW5lIG9uIGFuIGFycmF54oCZcyBsZW5ndGgnKTtcblx0XHR9XG5cblx0XHR2YXIgbmV3RW51bWVyYWJsZSA9IGhhcyhvcHRpb25zLCAnbm9uRW51bWVyYWJsZScpID8gIW9wdGlvbnMubm9uRW51bWVyYWJsZSA6IG9yaWdFbnVtZXJhYmxlO1xuXG5cdFx0aWYgKHdhbnRzRGF0YSkge1xuXHRcdFx0JGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IG9yaWdDb25maWd1cmFibGUsXG5cdFx0XHRcdGVudW1lcmFibGU6IG5ld0VudW1lcmFibGUsXG5cdFx0XHRcdHZhbHVlOiBoYXMob3B0aW9ucywgJ3ZhbHVlJykgPyBvcHRpb25zLnZhbHVlIDogb3JpZ0Rlc2NyaXB0b3IudmFsdWUsXG5cdFx0XHRcdHdyaXRhYmxlOiBoYXMob3B0aW9ucywgJ25vbldyaXRhYmxlJykgPyAhb3B0aW9ucy5ub25Xcml0YWJsZSA6IGhhcyhvcmlnRGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgPyBvcmlnRGVzY3JpcHRvci53cml0YWJsZSA6IHRydWVcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAod2FudHNBY2Nlc3Nvcikge1xuXHRcdFx0dmFyIGdldHRlciA9IGhhcyhvcHRpb25zLCAnZ2V0JykgPyBvcHRpb25zLmdldCA6IG9yaWdEZXNjcmlwdG9yICYmIG9yaWdEZXNjcmlwdG9yLmdldDtcblx0XHRcdHZhciBzZXR0ZXIgPSBoYXMob3B0aW9ucywgJ3NldCcpID8gb3B0aW9ucy5zZXQgOiBvcmlnRGVzY3JpcHRvciAmJiBvcmlnRGVzY3JpcHRvci5zZXQ7XG5cblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiBvcmlnQ29uZmlndXJhYmxlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBuZXdFbnVtZXJhYmxlLFxuXHRcdFx0XHRnZXQ6IGdldHRlcixcblx0XHRcdFx0c2V0OiBzZXR0ZXJcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogb3JpZ0NvbmZpZ3VyYWJsZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogbmV3RW51bWVyYWJsZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG5cdFx0aWYgKCFvcmlnRGVzY3JpcHRvcikge1xuXHRcdFx0ZGVsZXRlIG9ialtwcm9wXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdH0gZWxzZSBpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0XHRpZiAoaGFzKG9yaWdEZXNjcmlwdG9yLCAnd3JpdGFibGUnKSkge1xuXHRcdFx0XHQkZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiBvcmlnRGVzY3JpcHRvci5jb25maWd1cmFibGUsXG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogb3JpZ0Rlc2NyaXB0b3IuZW51bWVyYWJsZSxcblx0XHRcdFx0XHR2YWx1ZTogb3JpZ0Rlc2NyaXB0b3IudmFsdWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IG9yaWdEZXNjcmlwdG9yLndyaXRhYmxlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG9sZEdldHRlciA9IG9yaWdEZXNjcmlwdG9yICYmIG9yaWdEZXNjcmlwdG9yLmdldDtcblx0XHRcdFx0dmFyIG9sZFNldHRlciA9IG9yaWdEZXNjcmlwdG9yICYmIG9yaWdEZXNjcmlwdG9yLnNldDtcblxuXHRcdFx0XHQkZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiBvcmlnRGVzY3JpcHRvci5jb25maWd1cmFibGUsXG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogb3JpZ0Rlc2NyaXB0b3IuZW51bWVyYWJsZSxcblx0XHRcdFx0XHRnZXQ6IG9sZEdldHRlcixcblx0XHRcdFx0XHRzZXQ6IG9sZFNldHRlclxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2JqW3Byb3BdID0gb3JpZ0Rlc2NyaXB0b3IudmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHR9XG5cdH07XG59O1xuIiwidmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgTWFwLnByb3RvdHlwZTtcbnZhciBtYXBTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzTWFwID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNYXAucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBtYXBTaXplID0gaGFzTWFwICYmIG1hcFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBtYXBTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBtYXBTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIG1hcEZvckVhY2ggPSBoYXNNYXAgJiYgTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZTtcbnZhciBzZXRTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzU2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTZXQucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcbnZhciBzZXRTaXplID0gaGFzU2V0ICYmIHNldFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBzZXRTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBzZXRTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xudmFyIHNldEZvckVhY2ggPSBoYXNTZXQgJiYgU2V0LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIGhhc1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrTWFwLnByb3RvdHlwZTtcbnZhciB3ZWFrTWFwSGFzID0gaGFzV2Vha01hcCA/IFdlYWtNYXAucHJvdG90eXBlLmhhcyA6IG51bGw7XG52YXIgaGFzV2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nICYmIFdlYWtTZXQucHJvdG90eXBlO1xudmFyIHdlYWtTZXRIYXMgPSBoYXNXZWFrU2V0ID8gV2Vha1NldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrUmVmID0gdHlwZW9mIFdlYWtSZWYgPT09ICdmdW5jdGlvbicgJiYgV2Vha1JlZi5wcm90b3R5cGU7XG52YXIgd2Vha1JlZkRlcmVmID0gaGFzV2Vha1JlZiA/IFdlYWtSZWYucHJvdG90eXBlLmRlcmVmIDogbnVsbDtcbnZhciBib29sZWFuVmFsdWVPZiA9IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgJG1hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaDtcbnZhciAkc2xpY2UgPSBTdHJpbmcucHJvdG90eXBlLnNsaWNlO1xudmFyICRyZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyICR0b1VwcGVyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2U7XG52YXIgJHRvTG93ZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZTtcbnZhciAkdGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbnZhciAkY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciAkam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xudmFyICRhcnJTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGJpZ0ludFZhbHVlT2YgPSB0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nID8gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mIDogbnVsbDtcbnZhciBnT1BTID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBzeW1Ub1N0cmluZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogbnVsbDtcbnZhciBoYXNTaGFtbWVkU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ29iamVjdCc7XG4vLyBpZSwgYGhhcy10b3N0cmluZ3RhZy9zaGFtc1xudmFyIHRvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IGhhc1NoYW1tZWRTeW1ib2xzID8gJ29iamVjdCcgOiAnc3ltYm9sJylcbiAgICA/IFN5bWJvbC50b1N0cmluZ1RhZ1xuICAgIDogbnVsbDtcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgZ1BPID0gKHR5cGVvZiBSZWZsZWN0ID09PSAnZnVuY3Rpb24nID8gUmVmbGVjdC5nZXRQcm90b3R5cGVPZiA6IE9iamVjdC5nZXRQcm90b3R5cGVPZikgfHwgKFxuICAgIFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgPyBmdW5jdGlvbiAoTykge1xuICAgICAgICAgICAgcmV0dXJuIE8uX19wcm90b19fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsXG4pO1xuXG5mdW5jdGlvbiBhZGROdW1lcmljU2VwYXJhdG9yKG51bSwgc3RyKSB7XG4gICAgaWYgKFxuICAgICAgICBudW0gPT09IEluZmluaXR5XG4gICAgICAgIHx8IG51bSA9PT0gLUluZmluaXR5XG4gICAgICAgIHx8IG51bSAhPT0gbnVtXG4gICAgICAgIHx8IChudW0gJiYgbnVtID4gLTEwMDAgJiYgbnVtIDwgMTAwMClcbiAgICAgICAgfHwgJHRlc3QuY2FsbCgvZS8sIHN0cilcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgdmFyIHNlcFJlZ2V4ID0gL1swLTldKD89KD86WzAtOV17M30pKyg/IVswLTldKSkvZztcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGludCA9IG51bSA8IDAgPyAtJGZsb29yKC1udW0pIDogJGZsb29yKG51bSk7IC8vIHRydW5jKG51bSlcbiAgICAgICAgaWYgKGludCAhPT0gbnVtKSB7XG4gICAgICAgICAgICB2YXIgaW50U3RyID0gU3RyaW5nKGludCk7XG4gICAgICAgICAgICB2YXIgZGVjID0gJHNsaWNlLmNhbGwoc3RyLCBpbnRTdHIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChpbnRTdHIsIHNlcFJlZ2V4LCAnJCZfJykgKyAnLicgKyAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoZGVjLCAvKFswLTldezN9KS9nLCAnJCZfJyksIC9fJC8sICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChzdHIsIHNlcFJlZ2V4LCAnJCZfJyk7XG59XG5cbnZhciBpbnNwZWN0Q3VzdG9tID0gcmVxdWlyZSgnLi91dGlsLmluc3BlY3QnKS5jdXN0b207XG52YXIgaW5zcGVjdFN5bWJvbCA9IGluc3BlY3RDdXN0b20gJiYgaXNTeW1ib2woaW5zcGVjdEN1c3RvbSkgPyBpbnNwZWN0Q3VzdG9tIDogbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnNwZWN0XyhvYmosIG9wdGlvbnMsIGRlcHRoLCBzZWVuKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpICYmIChvcHRzLnF1b3RlU3R5bGUgIT09ICdzaW5nbGUnICYmIG9wdHMucXVvdGVTdHlsZSAhPT0gJ2RvdWJsZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcInF1b3RlU3R5bGVcIiBtdXN0IGJlIFwic2luZ2xlXCIgb3IgXCJkb3VibGVcIicpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnbWF4U3RyaW5nTGVuZ3RoJykgJiYgKHR5cGVvZiBvcHRzLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gb3B0cy5tYXhTdHJpbmdMZW5ndGggPCAwICYmIG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBJbmZpbml0eVxuICAgICAgICAgICAgOiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gbnVsbFxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm1heFN0cmluZ0xlbmd0aFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIEluZmluaXR5LCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbUluc3BlY3QgPSBoYXMob3B0cywgJ2N1c3RvbUluc3BlY3QnKSA/IG9wdHMuY3VzdG9tSW5zcGVjdCA6IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0ICE9PSAnYm9vbGVhbicgJiYgY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiY3VzdG9tSW5zcGVjdFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBgdHJ1ZWAsIGBmYWxzZWAsIG9yIGBcXCdzeW1ib2xcXCdgJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSAnXFx0J1xuICAgICAgICAmJiAhKHBhcnNlSW50KG9wdHMuaW5kZW50LCAxMCkgPT09IG9wdHMuaW5kZW50ICYmIG9wdHMuaW5kZW50ID4gMClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiaW5kZW50XCIgbXVzdCBiZSBcIlxcXFx0XCIsIGFuIGludGVnZXIgPiAwLCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgaWYgKGhhcyhvcHRzLCAnbnVtZXJpY1NlcGFyYXRvcicpICYmIHR5cGVvZiBvcHRzLm51bWVyaWNTZXBhcmF0b3IgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJudW1lcmljU2VwYXJhdG9yXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCBvciBgZmFsc2VgJyk7XG4gICAgfVxuICAgIHZhciBudW1lcmljU2VwYXJhdG9yID0gb3B0cy5udW1lcmljU2VwYXJhdG9yO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvYmogPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmosIG9wdHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhvYmopO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBzdHIpIDogc3RyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFyIGJpZ0ludFN0ciA9IFN0cmluZyhvYmopICsgJ24nO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBiaWdJbnRTdHIpIDogYmlnSW50U3RyO1xuICAgIH1cblxuICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnKSB7IGRlcHRoID0gMDsgfVxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdbQXJyYXldJyA6ICdbT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlZW4gPSBbXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSAkYXJyU2xpY2UuY2FsbChzZWVuKTtcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9JbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xuICAgICAgICAgICAgICAgIGRlcHRoOiBvcHRzLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0cy5xdW90ZVN0eWxlID0gb3B0cy5xdW90ZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgb3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xuICAgICAgICB2YXIga2V5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgcmV0dXJuICdbRnVuY3Rpb24nICsgKG5hbWUgPyAnOiAnICsgbmFtZSA6ICcgKGFub255bW91cyknKSArICddJyArIChrZXlzLmxlbmd0aCA+IDAgPyAnIHsgJyArICRqb2luLmNhbGwoa2V5cywgJywgJykgKyAnIH0nIDogJycpO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gaGFzU2hhbW1lZFN5bWJvbHMgPyAkcmVwbGFjZS5jYWxsKFN0cmluZyhvYmopLCAvXihTeW1ib2xcXCguKlxcKSlfW14pXSokLywgJyQxJykgOiBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaGFzU2hhbW1lZFN5bWJvbHMgPyBtYXJrQm94ZWQoc3ltU3RyaW5nKSA6IHN5bVN0cmluZztcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgICAgIHZhciBzID0gJzwnICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz0nICsgd3JhcFF1b3RlcyhxdW90ZShhdHRyc1tpXS52YWx1ZSksICdkb3VibGUnLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgeyBzICs9ICcuLi4nOyB9XG4gICAgICAgIHMgKz0gJzwvJyArICR0b0xvd2VyQ2FzZS5jYWxsKFN0cmluZyhvYmoubm9kZU5hbWUpKSArICc+JztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbXSc7IH1cbiAgICAgICAgdmFyIHhzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICBpZiAoaW5kZW50ICYmICFzaW5nbGVMaW5lVmFsdWVzKHhzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGluZGVudGVkSm9pbih4cywgaW5kZW50KSArICddJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1sgJyArICRqb2luLmNhbGwoeHMsICcsICcpICsgJyBdJztcbiAgICB9XG4gICAgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmICgnY2F1c2UnIGluIG9iaiAmJiAhaXNFbnVtZXJhYmxlLmNhbGwob2JqLCAnY2F1c2UnKSkge1xuICAgICAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoJ1tjYXVzZV06ICcgKyBpbnNwZWN0KG9iai5jYXVzZSksIHBhcnRzKSwgJywgJykgKyAnIH0nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XG4gICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArICRqb2luLmNhbGwocGFydHMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGN1c3RvbUluc3BlY3QpIHtcbiAgICAgICAgaWYgKGluc3BlY3RTeW1ib2wgJiYgdHlwZW9mIG9ialtpbnNwZWN0U3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtpbnNwZWN0U3ltYm9sXSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbUluc3BlY3QgIT09ICdzeW1ib2wnICYmIHR5cGVvZiBvYmouaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5pbnNwZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWFwKG9iaikpIHtcbiAgICAgICAgdmFyIG1hcFBhcnRzID0gW107XG4gICAgICAgIG1hcEZvckVhY2guY2FsbChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBtYXBQYXJ0cy5wdXNoKGluc3BlY3Qoa2V5LCBvYmosIHRydWUpICsgJyA9PiAnICsgaW5zcGVjdCh2YWx1ZSwgb2JqKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbk9mKCdNYXAnLCBtYXBTaXplLmNhbGwob2JqKSwgbWFwUGFydHMsIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChpc1NldChvYmopKSB7XG4gICAgICAgIHZhciBzZXRQYXJ0cyA9IFtdO1xuICAgICAgICBzZXRGb3JFYWNoLmNhbGwob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNldFBhcnRzLnB1c2goaW5zcGVjdCh2YWx1ZSwgb2JqKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbk9mKCdTZXQnLCBzZXRTaXplLmNhbGwob2JqKSwgc2V0UGFydHMsIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtNYXAob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha01hcCcpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrU2V0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtTZXQnKTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha1JlZihvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrUmVmJyk7XG4gICAgfVxuICAgIGlmIChpc051bWJlcihvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChOdW1iZXIob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoaXNCaWdJbnQob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoYmlnSW50VmFsdWVPZi5jYWxsKG9iaikpKTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbihvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoYm9vbGVhblZhbHVlT2YuY2FsbChvYmopKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KFN0cmluZyhvYmopKSk7XG4gICAgfVxuICAgIGlmICghaXNEYXRlKG9iaikgJiYgIWlzUmVnRXhwKG9iaikpIHtcbiAgICAgICAgdmFyIHlzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICB2YXIgaXNQbGFpbk9iamVjdCA9IGdQTyA/IGdQTyhvYmopID09PSBPYmplY3QucHJvdG90eXBlIDogb2JqIGluc3RhbmNlb2YgT2JqZWN0IHx8IG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgICAgICB2YXIgcHJvdG9UYWcgPSBvYmogaW5zdGFuY2VvZiBPYmplY3QgPyAnJyA6ICdudWxsIHByb3RvdHlwZSc7XG4gICAgICAgIHZhciBzdHJpbmdUYWcgPSAhaXNQbGFpbk9iamVjdCAmJiB0b1N0cmluZ1RhZyAmJiBPYmplY3Qob2JqKSA9PT0gb2JqICYmIHRvU3RyaW5nVGFnIGluIG9iaiA/ICRzbGljZS5jYWxsKHRvU3RyKG9iaiksIDgsIC0xKSA6IHByb3RvVGFnID8gJ09iamVjdCcgOiAnJztcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yVGFnID0gaXNQbGFpbk9iamVjdCB8fCB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nID8gJycgOiBvYmouY29uc3RydWN0b3IubmFtZSA/IG9iai5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnIDogJyc7XG4gICAgICAgIHZhciB0YWcgPSBjb25zdHJ1Y3RvclRhZyArIChzdHJpbmdUYWcgfHwgcHJvdG9UYWcgPyAnWycgKyAkam9pbi5jYWxsKCRjb25jYXQuY2FsbChbXSwgc3RyaW5nVGFnIHx8IFtdLCBwcm90b1RhZyB8fCBbXSksICc6ICcpICsgJ10gJyA6ICcnKTtcbiAgICAgICAgaWYgKHlzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gdGFnICsgJ3t9JzsgfVxuICAgICAgICBpZiAoaW5kZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnICsgJ3snICsgaW5kZW50ZWRKb2luKHlzLCBpbmRlbnQpICsgJ30nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWcgKyAneyAnICsgJGpvaW4uY2FsbCh5cywgJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKG9iaik7XG59O1xuXG5mdW5jdGlvbiB3cmFwUXVvdGVzKHMsIGRlZmF1bHRTdHlsZSwgb3B0cykge1xuICAgIHZhciBxdW90ZUNoYXIgPSAob3B0cy5xdW90ZVN0eWxlIHx8IGRlZmF1bHRTdHlsZSkgPT09ICdkb3VibGUnID8gJ1wiJyA6IFwiJ1wiO1xuICAgIHJldHVybiBxdW90ZUNoYXIgKyBzICsgcXVvdGVDaGFyO1xufVxuXG5mdW5jdGlvbiBxdW90ZShzKSB7XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwoU3RyaW5nKHMpLCAvXCIvZywgJyZxdW90OycpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc0Vycm9yKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuXG4vLyBTeW1ib2wgYW5kIEJpZ0ludCBkbyBoYXZlIFN5bWJvbC50b1N0cmluZ1RhZyBieSBzcGVjLCBzbyB0aGF0IGNhbid0IGJlIHVzZWQgdG8gZWxpbWluYXRlIGZhbHNlIHBvc2l0aXZlc1xuZnVuY3Rpb24gaXNTeW1ib2wob2JqKSB7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqIGluc3RhbmNlb2YgU3ltYm9sO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFzeW1Ub1N0cmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmlnSW50KG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFiaWdJbnRWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYmlnSW50VmFsdWVPZi5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gdGhpczsgfTtcbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIGtleSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyKG9iaikge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5hbWVPZihmKSB7XG4gICAgaWYgKGYubmFtZSkgeyByZXR1cm4gZi5uYW1lOyB9XG4gICAgdmFyIG0gPSAkbWF0Y2guY2FsbChmdW5jdGlvblRvU3RyaW5nLmNhbGwoZiksIC9eZnVuY3Rpb25cXHMqKFtcXHckXSspLyk7XG4gICAgaWYgKG0pIHsgcmV0dXJuIG1bMV07IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSB7IHJldHVybiB4cy5pbmRleE9mKHgpOyB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSB7IHJldHVybiBpOyB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gaXNNYXAoeCkge1xuICAgIGlmICghbWFwU2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBtYXBTaXplLmNhbGwoeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXRTaXplLmNhbGwoeCk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrTWFwKHgpIHtcbiAgICBpZiAoIXdlYWtNYXBIYXMgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha01hcEhhcy5jYWxsKHgsIHdlYWtNYXBIYXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2Vha1NldEhhcy5jYWxsKHgsIHdlYWtTZXRIYXMpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYWtNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtSZWYoeCkge1xuICAgIGlmICghd2Vha1JlZkRlcmVmIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdlYWtSZWZEZXJlZi5jYWxsKHgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTZXQoeCkge1xuICAgIGlmICghc2V0U2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzZXRTaXplLmNhbGwoeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXBTaXplLmNhbGwoeCk7XG4gICAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgU2V0OyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXZWFrU2V0KHgpIHtcbiAgICBpZiAoIXdlYWtTZXRIYXMgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha1NldEhhcy5jYWxsKHgsIHdlYWtTZXRIYXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2Vha01hcEhhcy5jYWxsKHgsIHdlYWtNYXBIYXMpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYWtTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQoeCkge1xuICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHgubm9kZU5hbWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB4LmdldEF0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFN0cmluZyhzdHIsIG9wdHMpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IG9wdHMubWF4U3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBzdHIubGVuZ3RoIC0gb3B0cy5tYXhTdHJpbmdMZW5ndGg7XG4gICAgICAgIHZhciB0cmFpbGVyID0gJy4uLiAnICsgcmVtYWluaW5nICsgJyBtb3JlIGNoYXJhY3RlcicgKyAocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIGluc3BlY3RTdHJpbmcoJHNsaWNlLmNhbGwoc3RyLCAwLCBvcHRzLm1heFN0cmluZ0xlbmd0aCksIG9wdHMpICsgdHJhaWxlcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICB2YXIgcyA9ICRyZXBsYWNlLmNhbGwoJHJlcGxhY2UuY2FsbChzdHIsIC8oWydcXFxcXSkvZywgJ1xcXFwkMScpLCAvW1xceDAwLVxceDFmXS9nLCBsb3dieXRlKTtcbiAgICByZXR1cm4gd3JhcFF1b3RlcyhzLCAnc2luZ2xlJywgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGxvd2J5dGUoYykge1xuICAgIHZhciBuID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB4ID0ge1xuICAgICAgICA4OiAnYicsXG4gICAgICAgIDk6ICd0JyxcbiAgICAgICAgMTA6ICduJyxcbiAgICAgICAgMTI6ICdmJyxcbiAgICAgICAgMTM6ICdyJ1xuICAgIH1bbl07XG4gICAgaWYgKHgpIHsgcmV0dXJuICdcXFxcJyArIHg7IH1cbiAgICByZXR1cm4gJ1xcXFx4JyArIChuIDwgMHgxMCA/ICcwJyA6ICcnKSArICR0b1VwcGVyQ2FzZS5jYWxsKG4udG9TdHJpbmcoMTYpKTtcbn1cblxuZnVuY3Rpb24gbWFya0JveGVkKHN0cikge1xuICAgIHJldHVybiAnT2JqZWN0KCcgKyBzdHIgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHdlYWtDb2xsZWN0aW9uT2YodHlwZSkge1xuICAgIHJldHVybiB0eXBlICsgJyB7ID8gfSc7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25PZih0eXBlLCBzaXplLCBlbnRyaWVzLCBpbmRlbnQpIHtcbiAgICB2YXIgam9pbmVkRW50cmllcyA9IGluZGVudCA/IGluZGVudGVkSm9pbihlbnRyaWVzLCBpbmRlbnQpIDogJGpvaW4uY2FsbChlbnRyaWVzLCAnLCAnKTtcbiAgICByZXR1cm4gdHlwZSArICcgKCcgKyBzaXplICsgJykgeycgKyBqb2luZWRFbnRyaWVzICsgJ30nO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVMaW5lVmFsdWVzKHhzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5kZXhPZih4c1tpXSwgJ1xcbicpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKSB7XG4gICAgdmFyIGJhc2VJbmRlbnQ7XG4gICAgaWYgKG9wdHMuaW5kZW50ID09PSAnXFx0Jykge1xuICAgICAgICBiYXNlSW5kZW50ID0gJ1xcdCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5pbmRlbnQgPT09ICdudW1iZXInICYmIG9wdHMuaW5kZW50ID4gMCkge1xuICAgICAgICBiYXNlSW5kZW50ID0gJGpvaW4uY2FsbChBcnJheShvcHRzLmluZGVudCArIDEpLCAnICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNlOiBiYXNlSW5kZW50LFxuICAgICAgICBwcmV2OiAkam9pbi5jYWxsKEFycmF5KGRlcHRoICsgMSksIGJhc2VJbmRlbnQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZW50ZWRKb2luKHhzLCBpbmRlbnQpIHtcbiAgICBpZiAoeHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIHZhciBsaW5lSm9pbmVyID0gJ1xcbicgKyBpbmRlbnQucHJldiArIGluZGVudC5iYXNlO1xuICAgIHJldHVybiBsaW5lSm9pbmVyICsgJGpvaW4uY2FsbCh4cywgJywnICsgbGluZUpvaW5lcikgKyAnXFxuJyArIGluZGVudC5wcmV2O1xufVxuXG5mdW5jdGlvbiBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCkge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqKTtcbiAgICB2YXIgeHMgPSBbXTtcbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgeHMubGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHhzW2ldID0gaGFzKG9iaiwgaSkgPyBpbnNwZWN0KG9ialtpXSwgb2JqKSA6ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzeW1zID0gdHlwZW9mIGdPUFMgPT09ICdmdW5jdGlvbicgPyBnT1BTKG9iaikgOiBbXTtcbiAgICB2YXIgc3ltTWFwO1xuICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xuICAgICAgICBzeW1NYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzeW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBzeW1NYXBbJyQnICsgc3ltc1trXV0gPSBzeW1zW2tdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGlmICghaGFzKG9iaiwga2V5KSkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaXNBcnIgJiYgU3RyaW5nKE51bWJlcihrZXkpKSA9PT0ga2V5ICYmIGtleSA8IG9iai5sZW5ndGgpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzICYmIHN5bU1hcFsnJCcgKyBrZXldIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRvIHByZXZlbnQgc2hhbW1lZCBTeW1ib2xzLCB3aGljaCBhcmUgc3RvcmVkIGFzIHN0cmluZ3MsIGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gdGhlIHN0cmluZyBrZXkgc2VjdGlvblxuICAgICAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoJHRlc3QuY2FsbCgvW15cXHckXS8sIGtleSkpIHtcbiAgICAgICAgICAgIHhzLnB1c2goaW5zcGVjdChrZXksIG9iaikgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4cy5wdXNoKGtleSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGdPUFMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzeW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW1zW2pdKSkge1xuICAgICAgICAgICAgICAgIHhzLnB1c2goJ1snICsgaW5zcGVjdChzeW1zW2pdKSArICddOiAnICsgaW5zcGVjdChvYmpbc3ltc1tqXV0sIG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4cztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlcklzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcblx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuXHRcdHJldHVybiAxIC8gYSA9PT0gMSAvIGI7XG5cdH1cblx0aWYgKGEgPT09IGIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAobnVtYmVySXNOYU4oYSkgJiYgbnVtYmVySXNOYU4oYikpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE9iamVjdCk7XG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0dmFyIGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPT09IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM2LXNoaW1cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBjYW5CZU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnICYmIG9iaiAhPT0gbnVsbDtcbn07XG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgdG9PYmplY3QgPSBPYmplY3Q7XG52YXIgJHB1c2ggPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5wdXNoJyk7XG52YXIgJHByb3BJc0VudW1lcmFibGUgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUnKTtcbnZhciBvcmlnaW5hbEdldFN5bWJvbHMgPSBoYXNTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA6IG51bGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UxKSB7XG5cdGlmICghY2FuQmVPYmplY3QodGFyZ2V0KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTsgfVxuXHR2YXIgb2JqVGFyZ2V0ID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHMsIHNvdXJjZSwgaSwgcHJvcHMsIHN5bXMsIHZhbHVlLCBrZXk7XG5cdGZvciAocyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyArK3MpIHtcblx0XHRzb3VyY2UgPSB0b09iamVjdChhcmd1bWVudHNbc10pO1xuXHRcdHByb3BzID0ga2V5cyhzb3VyY2UpO1xuXHRcdHZhciBnZXRTeW1ib2xzID0gaGFzU3ltYm9scyAmJiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyB8fCBvcmlnaW5hbEdldFN5bWJvbHMpO1xuXHRcdGlmIChnZXRTeW1ib2xzKSB7XG5cdFx0XHRzeW1zID0gZ2V0U3ltYm9scyhzb3VyY2UpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHN5bXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0a2V5ID0gc3ltc1tpXTtcblx0XHRcdFx0aWYgKCRwcm9wSXNFbnVtZXJhYmxlKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0XHRcdCRwdXNoKHByb3BzLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0a2V5ID0gcHJvcHNbaV07XG5cdFx0XHR2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0aWYgKCRwcm9wSXNFbnVtZXJhYmxlKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0XHRvYmpUYXJnZXRba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gb2JqVGFyZ2V0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgbGFja3NQcm9wZXJFbnVtZXJhdGlvbk9yZGVyID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Lypcblx0ICogdjgsIHNwZWNpZmljYWxseSBpbiBub2RlIDQueCwgaGFzIGEgYnVnIHdpdGggaW5jb3JyZWN0IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyXG5cdCAqIG5vdGU6IHRoaXMgZG9lcyBub3QgZGV0ZWN0IHRoZSBidWcgdW5sZXNzIHRoZXJlJ3MgMjAgY2hhcmFjdGVyc1xuXHQgKi9cblx0dmFyIHN0ciA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdHZhciBsZXR0ZXJzID0gc3RyLnNwbGl0KCcnKTtcblx0dmFyIG1hcCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyArK2kpIHtcblx0XHRtYXBbbGV0dGVyc1tpXV0gPSBsZXR0ZXJzW2ldO1xuXHR9XG5cdHZhciBvYmogPSBPYmplY3QuYXNzaWduKHt9LCBtYXApO1xuXHR2YXIgYWN0dWFsID0gJyc7XG5cdGZvciAodmFyIGsgaW4gb2JqKSB7XG5cdFx0YWN0dWFsICs9IGs7XG5cdH1cblx0cmV0dXJuIHN0ciAhPT0gYWN0dWFsO1xufTtcblxudmFyIGFzc2lnbkhhc1BlbmRpbmdFeGNlcHRpb25zID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24gfHwgIU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvKlxuXHQgKiBGaXJlZm94IDM3IHN0aWxsIGhhcyBcInBlbmRpbmcgZXhjZXB0aW9uXCIgbG9naWMgaW4gaXRzIE9iamVjdC5hc3NpZ24gaW1wbGVtZW50YXRpb24sXG5cdCAqIHdoaWNoIGlzIDcyJSBzbG93ZXIgdGhhbiBvdXIgc2hpbSwgYW5kIEZpcmVmb3ggNDAncyBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG5cdCAqL1xuXHR2YXIgdGhyb3dlciA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7IDE6IDIgfSk7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aHJvd2VyLCAneHknKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiB0aHJvd2VyWzFdID09PSAneSc7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xuXHR9XG5cdGlmIChsYWNrc1Byb3BlckVudW1lcmF0aW9uT3JkZXIoKSkge1xuXHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0fVxuXHRpZiAoYXNzaWduSGFzUGVuZGluZ0V4Y2VwdGlvbnMoKSkge1xuXHRcdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1Bc3NpZ24oKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShcblx0XHRPYmplY3QsXG5cdFx0eyBhc3NpZ246IHBvbHlmaWxsIH0sXG5cdFx0eyBhc3NpZ246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24gIT09IHBvbHlmaWxsOyB9IH1cblx0KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmxhZ3MoKSB7XG5cdGlmICh0aGlzICE9IG51bGwgJiYgdGhpcyAhPT0gJE9iamVjdCh0aGlzKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdSZWdFeHAucHJvdG90eXBlLmZsYWdzIGdldHRlciBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSAnJztcblx0aWYgKHRoaXMuZ2xvYmFsKSB7XG5cdFx0cmVzdWx0ICs9ICdnJztcblx0fVxuXHRpZiAodGhpcy5pZ25vcmVDYXNlKSB7XG5cdFx0cmVzdWx0ICs9ICdpJztcblx0fVxuXHRpZiAodGhpcy5tdWx0aWxpbmUpIHtcblx0XHRyZXN1bHQgKz0gJ20nO1xuXHR9XG5cdGlmICh0aGlzLmRvdEFsbCkge1xuXHRcdHJlc3VsdCArPSAncyc7XG5cdH1cblx0aWYgKHRoaXMudW5pY29kZSkge1xuXHRcdHJlc3VsdCArPSAndSc7XG5cdH1cblx0aWYgKHRoaXMuc3RpY2t5KSB7XG5cdFx0cmVzdWx0ICs9ICd5Jztcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIGZsYWdzQm91bmQgPSBjYWxsQmluZChpbXBsZW1lbnRhdGlvbik7XG5cbmRlZmluZShmbGFnc0JvdW5kLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbGFnc0JvdW5kO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKS5zdXBwb3J0c0Rlc2NyaXB0b3JzO1xudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoIXN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignUmVnRXhwLnByb3RvdHlwZS5mbGFncyByZXF1aXJlcyBhIHRydWUgRVM1IGVudmlyb25tZW50IHRoYXQgc3VwcG9ydHMgcHJvcGVydHkgZGVzY3JpcHRvcnMnKTtcblx0fVxuXHRpZiAoKC9hL21pZykuZmxhZ3MgPT09ICdnaW0nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSAkZ09QRChSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnKTtcblx0XHRpZiAoZGVzY3JpcHRvciAmJiB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mICgvYS8pLmRvdEFsbCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRyZXR1cm4gZGVzY3JpcHRvci5nZXQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKS5zdXBwb3J0c0Rlc2NyaXB0b3JzO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFR5cGVFcnIgPSBUeXBlRXJyb3I7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgcmVnZXggPSAvYS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbUZsYWdzKCkge1xuXHRpZiAoIXN1cHBvcnRzRGVzY3JpcHRvcnMgfHwgIWdldFByb3RvKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnIoJ1JlZ0V4cC5wcm90b3R5cGUuZmxhZ3MgcmVxdWlyZXMgYSB0cnVlIEVTNSBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIHByb3BlcnR5IGRlc2NyaXB0b3JzJyk7XG5cdH1cblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0dmFyIHByb3RvID0gZ2V0UHJvdG8ocmVnZXgpO1xuXHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sICdmbGFncycpO1xuXHRpZiAoIWRlc2NyaXB0b3IgfHwgZGVzY3JpcHRvci5nZXQgIT09IHBvbHlmaWxsKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkocHJvdG8sICdmbGFncycsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiBwb2x5ZmlsbFxuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCJ2YXIgdGhyb3VnaCA9IHJlcXVpcmUoJ3Rocm91Z2gnKTtcbnZhciBuZXh0VGljayA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyBzZXRJbW1lZGlhdGVcbiAgICA6IHByb2Nlc3MubmV4dFRpY2tcbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAod3JpdGUsIGVuZCkge1xuICAgIHZhciB0ciA9IHRocm91Z2god3JpdGUsIGVuZCk7XG4gICAgdHIucGF1c2UoKTtcbiAgICB2YXIgcmVzdW1lID0gdHIucmVzdW1lO1xuICAgIHZhciBwYXVzZSA9IHRyLnBhdXNlO1xuICAgIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgICBcbiAgICB0ci5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHBhdXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBcbiAgICB0ci5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmVzdW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBcbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcGF1c2VkKSB0ci5yZXN1bWUoKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWluc3BlY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG52YXIgJFdlYWtNYXAgPSBHZXRJbnRyaW5zaWMoJyVXZWFrTWFwJScsIHRydWUpO1xudmFyICRNYXAgPSBHZXRJbnRyaW5zaWMoJyVNYXAlJywgdHJ1ZSk7XG5cbnZhciAkd2Vha01hcEdldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuZ2V0JywgdHJ1ZSk7XG52YXIgJHdlYWtNYXBTZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xudmFyICR3ZWFrTWFwSGFzID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcbnZhciAkbWFwR2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xudmFyICRtYXBTZXQgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuc2V0JywgdHJ1ZSk7XG52YXIgJG1hcEhhcyA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gdHJhdmVyc2VzIHRoZSBsaXN0IHJldHVybmluZyB0aGUgbm9kZSBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogZ2l2ZW4ga2V5LlxuICpcbiAqIFRoYXQgbm9kZSBpcyBhbHNvIG1vdmVkIHRvIHRoZSBoZWFkIG9mIHRoZSBsaXN0LCBzbyB0aGF0IGlmIGl0J3MgYWNjZXNzZWRcbiAqIGFnYWluIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHdob2xlIGxpc3QuIEJ5IGRvaW5nIHNvLCBhbGwgdGhlIHJlY2VudGx5XG4gKiB1c2VkIG5vZGVzIGNhbiBiZSBhY2Nlc3NlZCByZWxhdGl2ZWx5IHF1aWNrbHkuXG4gKi9cbnZhciBsaXN0R2V0Tm9kZSA9IGZ1bmN0aW9uIChsaXN0LCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRmb3IgKHZhciBwcmV2ID0gbGlzdCwgY3VycjsgKGN1cnIgPSBwcmV2Lm5leHQpICE9PSBudWxsOyBwcmV2ID0gY3Vycikge1xuXHRcdGlmIChjdXJyLmtleSA9PT0ga2V5KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBjdXJyLm5leHQ7XG5cdFx0XHRjdXJyLm5leHQgPSBsaXN0Lm5leHQ7XG5cdFx0XHRsaXN0Lm5leHQgPSBjdXJyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdFx0XHRyZXR1cm4gY3Vycjtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBsaXN0R2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdHJldHVybiBub2RlICYmIG5vZGUudmFsdWU7XG59O1xudmFyIGxpc3RTZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5LCB2YWx1ZSkge1xuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdGlmIChub2RlKSB7XG5cdFx0bm9kZS52YWx1ZSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFByZXBlbmQgdGhlIG5ldyBub2RlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3Rcblx0XHRvYmplY3RzLm5leHQgPSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHRcdGtleToga2V5LFxuXHRcdFx0bmV4dDogb2JqZWN0cy5uZXh0LFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxufTtcbnZhciBsaXN0SGFzID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHRyZXR1cm4gISFsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTaWRlQ2hhbm5lbCgpIHtcblx0dmFyICR3bTtcblx0dmFyICRtO1xuXHR2YXIgJG87XG5cdHZhciBjaGFubmVsID0ge1xuXHRcdGFzc2VydDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCFjaGFubmVsLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdTaWRlIGNoYW5uZWwgZG9lcyBub3QgY29udGFpbiAnICsgaW5zcGVjdChrZXkpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldDogZnVuY3Rpb24gKGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwR2V0KCR3bSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwR2V0KCRtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRyZXR1cm4gbGlzdEdldCgkbywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGFzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwSGFzKCR3bSwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRcdHJldHVybiAkbWFwSGFzKCRtLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRyZXR1cm4gbGlzdEhhcygkbywga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0aWYgKCEkd20pIHtcblx0XHRcdFx0XHQkd20gPSBuZXcgJFdlYWtNYXAoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkd2Vha01hcFNldCgkd20sIGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdGlmICghJG0pIHtcblx0XHRcdFx0XHQkbSA9IG5ldyAkTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JG1hcFNldCgkbSwga2V5LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoISRvKSB7XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiBJbml0aWFsaXplIHRoZSBsaW5rZWQgbGlzdCBhcyBhbiBlbXB0eSBub2RlLCBzbyB0aGF0IHdlIGRvbid0IGhhdmVcblx0XHRcdFx0XHQgKiB0byBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2YgdGhlIGZpcnN0IG5vZGU6IHdlIGNhbiBhbHdheXMgcmVmZXIgdG9cblx0XHRcdFx0XHQgKiBpdCBhcyAocHJldmlvdXMgbm9kZSkubmV4dCwgaW5zdGVhZCBvZiBzb21ldGhpbmcgbGlrZSAobGlzdCkuaGVhZFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdCRvID0geyBrZXk6IHt9LCBuZXh0OiBudWxsIH07XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdFNldCgkbywga2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gY2hhbm5lbDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC8yMDIxL1JlcXVpcmVPYmplY3RDb2VyY2libGUnKTtcbnZhciBUb1N0cmluZyA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0LzIwMjEvVG9TdHJpbmcnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgJHJlcGxhY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUucmVwbGFjZScpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG52YXIgbGVmdFdoaXRlc3BhY2UgPSAvXltcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkZdKy87XG52YXIgcmlnaHRXaGl0ZXNwYWNlID0gL1tcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkZdKyQvO1xuLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJpbSgpIHtcblx0dmFyIFMgPSBUb1N0cmluZyhSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcblx0cmV0dXJuICRyZXBsYWNlKCRyZXBsYWNlKFMsIGxlZnRXaGl0ZXNwYWNlLCAnJyksIHJpZ2h0V2hpdGVzcGFjZSwgJycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIGJvdW5kVHJpbSA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCkpO1xuXG5kZWZpbmUoYm91bmRUcmltLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBib3VuZFRyaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxudmFyIHplcm9XaWR0aFNwYWNlID0gJ1xcdTIwMGInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoU3RyaW5nLnByb3RvdHlwZS50cmltICYmIHplcm9XaWR0aFNwYWNlLnRyaW0oKSA9PT0gemVyb1dpZHRoU3BhY2UpIHtcblx0XHRyZXR1cm4gU3RyaW5nLnByb3RvdHlwZS50cmltO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1TdHJpbmdUcmltKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgeyB0cmltOiBwb2x5ZmlsbCB9LCB7XG5cdFx0dHJpbTogZnVuY3Rpb24gdGVzdFRyaW0oKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nLnByb3RvdHlwZS50cmltICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJ2RlZmluZWQnKTtcbnZhciBjcmVhdGVEZWZhdWx0U3RyZWFtID0gcmVxdWlyZSgnLi9saWIvZGVmYXVsdF9zdHJlYW0nKTtcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi9saWIvdGVzdCcpO1xudmFyIGNyZWF0ZVJlc3VsdCA9IHJlcXVpcmUoJy4vbGliL3Jlc3VsdHMnKTtcbnZhciB0aHJvdWdoID0gcmVxdWlyZSgndGhyb3VnaCcpO1xuXG52YXIgY2FuRW1pdEV4aXQgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzc1xuICAgICYmIHR5cGVvZiBwcm9jZXNzLm9uID09PSAnZnVuY3Rpb24nICYmIHByb2Nlc3MuYnJvd3NlciAhPT0gdHJ1ZTtcbnZhciBjYW5FeGl0ID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3NcbiAgICAmJiB0eXBlb2YgcHJvY2Vzcy5leGl0ID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdhaXQgPSBmYWxzZTtcbiAgICB2YXIgaGFybmVzcztcbiAgICB2YXIgbGF6eUxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgICAgcmV0dXJuIGdldEhhcm5lc3MoKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsYXp5TG9hZC53YWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgbGF6eUxvYWQucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcnVuID0gZ2V0SGFybmVzcygpLnJ1bjtcblxuICAgICAgICBpZiAocnVuKSB7IHJ1bigpOyB9XG4gICAgfTtcblxuICAgIGxhenlMb2FkLm9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRIYXJuZXNzKCkub25seS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsYXp5TG9hZC5jcmVhdGVTdHJlYW0gPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgICAgIGlmICghaGFybmVzcykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRocm91Z2goKTtcbiAgICAgICAgICAgIGdldEhhcm5lc3MoeyBzdHJlYW06IG91dHB1dCwgb2JqZWN0TW9kZTogb3B0aW9ucy5vYmplY3RNb2RlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFybmVzcy5jcmVhdGVTdHJlYW0ob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGxhenlMb2FkLm9uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0SGFybmVzcygpLm9uRmluaXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxhenlMb2FkLm9uRmFpbHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEhhcm5lc3MoKS5vbkZhaWx1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGF6eUxvYWQuZ2V0SGFybmVzcyA9IGdldEhhcm5lc3M7XG5cbiAgICByZXR1cm4gbGF6eUxvYWQ7XG5cbiAgICBmdW5jdGlvbiBnZXRIYXJuZXNzKG9wdHMpIHtcbiAgICAgICAgaWYgKCFvcHRzKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICBvcHRzLmF1dG9jbG9zZSA9ICFjYW5FbWl0RXhpdDtcbiAgICAgICAgaWYgKCFoYXJuZXNzKSB7IGhhcm5lc3MgPSBjcmVhdGVFeGl0SGFybmVzcyhvcHRzLCB3YWl0KTsgfVxuICAgICAgICByZXR1cm4gaGFybmVzcztcbiAgICB9XG59KCkpO1xuXG5mdW5jdGlvbiBjcmVhdGVFeGl0SGFybmVzcyhjb25mLCB3YWl0KSB7XG4gICAgdmFyIGNvbmZpZyA9IGNvbmYgfHwge307XG4gICAgdmFyIGhhcm5lc3MgPSBjcmVhdGVIYXJuZXNzKHtcbiAgICAgICAgYXV0b2Nsb3NlOiBkZWZpbmVkKGNvbmZpZy5hdXRvY2xvc2UsIGZhbHNlKSxcbiAgICAgICAgbm9Pbmx5OiBkZWZpbmVkKGNvbmYubm9Pbmx5LCBkZWZpbmVkKHByb2Nlc3MuZW52Lk5PREVfVEFQRV9OT19PTkxZX1RFU1QsIGZhbHNlKSlcbiAgICB9KTtcbiAgICB2YXIgcnVubmluZyA9IGZhbHNlO1xuICAgIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHdhaXQpIHtcbiAgICAgICAgaGFybmVzcy5ydW4gPSBydW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcnVuKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5leGl0ID09PSBmYWxzZSkgeyByZXR1cm4gaGFybmVzczsgfVxuICAgIGlmICghY2FuRW1pdEV4aXQgfHwgIWNhbkV4aXQpIHsgcmV0dXJuIGhhcm5lc3M7IH1cblxuICAgIHByb2Nlc3Mub24oJ2V4aXQnLCBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAvLyBsZXQgdGhlIHByb2Nlc3MgZXhpdCBjbGVhbmx5LlxuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdudW1iZXInICYmIGNvZGUgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZW5kZWQpIHtcbiAgICAgICAgICAgIHZhciBvbmx5ID0gaGFybmVzcy5fcmVzdWx0cy5fb25seTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFybmVzcy5fdGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGhhcm5lc3MuX3Rlc3RzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghb25seSB8fCB0ID09PSBvbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHQuX2V4aXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFybmVzcy5jbG9zZSgpO1xuXG4gICAgICAgIHByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzKCdleGl0Jyk7IC8vIG5lY2Vzc2FyeSBmb3Igbm9kZSB2MC42XG4gICAgICAgIHByb2Nlc3MuZXhpdChjb2RlIHx8IGhhcm5lc3MuX2V4aXRDb2RlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm9jZXNzLWV4aXRcbiAgICB9KTtcblxuICAgIHJldHVybiBoYXJuZXNzO1xuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICBpZiAocnVubmluZykgeyByZXR1cm47IH1cbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIHZhciBzdHJlYW0gPSBoYXJuZXNzLmNyZWF0ZVN0cmVhbSh7IG9iamVjdE1vZGU6IGNvbmZpZy5vYmplY3RNb2RlIH0pO1xuICAgICAgICB2YXIgZXMgPSBzdHJlYW0ucGlwZShjb25maWcuc3RyZWFtIHx8IGNyZWF0ZURlZmF1bHRTdHJlYW0oKSk7XG4gICAgICAgIGlmIChjYW5FbWl0RXhpdCkge1xuICAgICAgICAgICAgLy8gVE9ETzogdXNlIGBlcnJgIGFyZz9cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgZXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyBoYXJuZXNzLl9leGl0Q29kZSA9IDE7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkgeyBlbmRlZCA9IHRydWU7IH0pO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuY3JlYXRlSGFybmVzcyA9IGNyZWF0ZUhhcm5lc3M7XG5tb2R1bGUuZXhwb3J0cy5UZXN0ID0gVGVzdDtcbm1vZHVsZS5leHBvcnRzLnRlc3QgPSBtb2R1bGUuZXhwb3J0czsgLy8gdGFwIGNvbXBhdFxubW9kdWxlLmV4cG9ydHMudGVzdC5za2lwID0gVGVzdC5za2lwO1xuXG5mdW5jdGlvbiBjcmVhdGVIYXJuZXNzKGNvbmZfKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBjcmVhdGVSZXN1bHQoKTtcbiAgICBpZiAoIWNvbmZfIHx8IGNvbmZfLmF1dG9jbG9zZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmVzdWx0cy5vbmNlKCdkb25lJywgZnVuY3Rpb24gKCkgeyByZXN1bHRzLmNsb3NlKCk7IH0pO1xuICAgIH1cblxuICAgIHZhciB0ZXN0ID0gZnVuY3Rpb24gKG5hbWUsIGNvbmYsIGNiKSB7XG4gICAgICAgIHZhciB0ID0gbmV3IFRlc3QobmFtZSwgY29uZiwgY2IpO1xuICAgICAgICB0ZXN0Ll90ZXN0cy5wdXNoKHQpO1xuXG4gICAgICAgIChmdW5jdGlvbiBpbnNwZWN0Q29kZShzdCkge1xuICAgICAgICAgICAgc3Qub24oJ3Rlc3QnLCBmdW5jdGlvbiBzdWIoc3RfKSB7XG4gICAgICAgICAgICAgICAgaW5zcGVjdENvZGUoc3RfKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3Qub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyLnRvZG8gJiYgIXIub2sgJiYgdHlwZW9mIHIgIT09ICdzdHJpbmcnKSB7IHRlc3QuX2V4aXRDb2RlID0gMTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0odCkpO1xuXG4gICAgICAgIHJlc3VsdHMucHVzaCh0KTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICB0ZXN0Ll9yZXN1bHRzID0gcmVzdWx0cztcblxuICAgIHRlc3QuX3Rlc3RzID0gW107XG5cbiAgICB0ZXN0LmNyZWF0ZVN0cmVhbSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzLmNyZWF0ZVN0cmVhbShvcHRzKTtcbiAgICB9O1xuXG4gICAgdGVzdC5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXN1bHRzLm9uKCdkb25lJywgY2IpO1xuICAgIH07XG5cbiAgICB0ZXN0Lm9uRmFpbHVyZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXN1bHRzLm9uKCdmYWlsJywgY2IpO1xuICAgIH07XG5cbiAgICB2YXIgb25seSA9IGZhbHNlO1xuICAgIHRlc3Qub25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9ubHkpIHsgdGhyb3cgbmV3IEVycm9yKCd0aGVyZSBjYW4gb25seSBiZSBvbmUgb25seSB0ZXN0Jyk7IH1cbiAgICAgICAgaWYgKGNvbmZfLm5vT25seSkgeyB0aHJvdyBuZXcgRXJyb3IoJ2Bvbmx5YCB0ZXN0cyBhcmUgcHJvaGliaXRlZCcpOyB9XG4gICAgICAgIG9ubHkgPSB0cnVlO1xuICAgICAgICB2YXIgdCA9IHRlc3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgcmVzdWx0cy5vbmx5KHQpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHRlc3QuX2V4aXRDb2RlID0gMDtcblxuICAgIHRlc3QuY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJlc3VsdHMuY2xvc2UoKTsgfTtcblxuICAgIHJldHVybiB0ZXN0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGhyb3VnaCA9IHJlcXVpcmUoJ3Rocm91Z2gnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5lID0gJyc7XG4gICAgdmFyIHN0cmVhbSA9IHRocm91Z2god3JpdGUsIGZsdXNoKTtcbiAgICByZXR1cm4gc3RyZWFtO1xuXG4gICAgZnVuY3Rpb24gd3JpdGUoYnVmKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHR5cGVvZiBidWYgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBidWYuY2hhckF0KGkpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgaWYgKGZzLndyaXRlU3luYyAmJiAoL153aW4vKS50ZXN0KHByb2Nlc3MucGxhdGZvcm0pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLndyaXRlU3luYygxLCBsaW5lICsgJ1xcbicpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhsaW5lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9ICcnO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnZGVmaW5lZCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgdGhyb3VnaCA9IHJlcXVpcmUoJ3Rocm91Z2gnKTtcbnZhciByZXN1bWVyID0gcmVxdWlyZSgncmVzdW1lcicpO1xudmFyIGluc3BlY3QgPSByZXF1aXJlKCdvYmplY3QtaW5zcGVjdCcpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcbnZhciByZWdleHBUZXN0ID0gY2FsbEJvdW5kKCdSZWdFeHAucHJvdG90eXBlLnRlc3QnKTtcbnZhciAkc3BsaXQgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc3BsaXQnKTtcbnZhciAkcmVwbGFjZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlJyk7XG52YXIgJHNoaWZ0ID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuc2hpZnQnKTtcbnZhciAkcHVzaCA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLnB1c2gnKTtcbnZhciB5YW1sSW5kaWNhdG9ycyA9IC86fC18XFw/LztcbnZhciBuZXh0VGljayA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyBzZXRJbW1lZGlhdGVcbiAgICA6IHByb2Nlc3MubmV4dFRpY2s7XG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VsdHM7XG5pbmhlcml0cyhSZXN1bHRzLCBFdmVudEVtaXR0ZXIpO1xuXG5mdW5jdGlvbiBjb2FsZXNjZVdoaXRlU3BhY2VzKHN0cikge1xuICAgIHJldHVybiAkcmVwbGFjZShTdHJpbmcoc3RyKSwgL1xccysvZywgJyAnKTtcbn1cblxuZnVuY3Rpb24gUmVzdWx0cygpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzdWx0cykpIHsgcmV0dXJuIG5ldyBSZXN1bHRzKCk7IH1cbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLmZhaWwgPSAwO1xuICAgIHRoaXMucGFzcyA9IDA7XG4gICAgdGhpcy50b2RvID0gMDtcbiAgICB0aGlzLl9zdHJlYW0gPSB0aHJvdWdoKCk7XG4gICAgdGhpcy50ZXN0cyA9IFtdO1xuICAgIHRoaXMuX29ubHkgPSBudWxsO1xuICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xufVxuXG5SZXN1bHRzLnByb3RvdHlwZS5jcmVhdGVTdHJlYW0gPSBmdW5jdGlvbiAob3B0cykge1xuICAgIGlmICghb3B0cykgeyBvcHRzID0ge307IH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG91dHB1dDtcbiAgICB2YXIgdGVzdElkID0gMDtcbiAgICBpZiAob3B0cy5vYmplY3RNb2RlKSB7XG4gICAgICAgIG91dHB1dCA9IHRocm91Z2goKTtcbiAgICAgICAgc2VsZi5vbignX3B1c2gnLCBmdW5jdGlvbiBvbnRlc3QodCwgZXh0cmEpIHtcbiAgICAgICAgICAgIGlmICghZXh0cmEpIHsgZXh0cmEgPSB7fTsgfVxuICAgICAgICAgICAgdmFyIGlkID0gdGVzdElkKys7XG4gICAgICAgICAgICB0Lm9uY2UoJ3ByZXJ1bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBza2lwOiB0Ll9za2lwLFxuICAgICAgICAgICAgICAgICAgICB0b2RvOiB0Ll90b2RvXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzKGV4dHJhLCAncGFyZW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnBhcmVudCA9IGV4dHJhLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LnF1ZXVlKHJvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHQub24oJ3Rlc3QnLCBmdW5jdGlvbiAoc3QpIHtcbiAgICAgICAgICAgICAgICBvbnRlc3Qoc3QsIHsgcGFyZW50OiBpZCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdC5vbigncmVzdWx0JywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnRlc3QgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnR5cGUgPSAnYXNzZXJ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LnF1ZXVlKHJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHQub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucXVldWUoeyB0eXBlOiAnZW5kJywgdGVzdDogaWQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYub24oJ2RvbmUnLCBmdW5jdGlvbiAoKSB7IG91dHB1dC5xdWV1ZShudWxsKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gcmVzdW1lcigpO1xuICAgICAgICBvdXRwdXQucXVldWUoJ1RBUCB2ZXJzaW9uIDEzXFxuJyk7XG4gICAgICAgIHNlbGYuX3N0cmVhbS5waXBlKG91dHB1dCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgd2hpbGUgKHQgPSBnZXROZXh0VGVzdChzZWxmKSkge1xuICAgICAgICAgICAgICAgIHQucnVuKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0LmVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQub25jZSgnZW5kJywgZnVuY3Rpb24gKCkgeyBuZXh0VGljayhuZXh0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2RvbmUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cblJlc3VsdHMucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkcHVzaChzZWxmLnRlc3RzLCB0KTtcbiAgICBzZWxmLl93YXRjaCh0KTtcbiAgICBzZWxmLmVtaXQoJ19wdXNoJywgdCk7XG59O1xuXG5SZXN1bHRzLnByb3RvdHlwZS5vbmx5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICB0aGlzLl9vbmx5ID0gdDtcbn07XG5cblJlc3VsdHMucHJvdG90eXBlLl93YXRjaCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3cml0ZSA9IGZ1bmN0aW9uIChzKSB7IHNlbGYuX3N0cmVhbS5xdWV1ZShzKTsgfTtcbiAgICB0Lm9uY2UoJ3ByZXJ1bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZW1zZyA9ICcnO1xuICAgICAgICBpZiAodC5fc2tpcCkge1xuICAgICAgICAgICAgcHJlbXNnID0gJ1NLSVAgJztcbiAgICAgICAgfSBlbHNlIGlmICh0Ll90b2RvKSB7XG4gICAgICAgICAgICBwcmVtc2cgPSAnVE9ETyAnO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlKCcjICcgKyBwcmVtc2cgKyBjb2FsZXNjZVdoaXRlU3BhY2VzKHQubmFtZSkgKyAnXFxuJyk7XG4gICAgfSk7XG5cbiAgICB0Lm9uKCdyZXN1bHQnLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgd3JpdGUoJyMgJyArIHJlcyArICdcXG4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZShlbmNvZGVSZXN1bHQocmVzLCBzZWxmLmNvdW50ICsgMSkpO1xuICAgICAgICBzZWxmLmNvdW50Kys7XG5cbiAgICAgICAgaWYgKHJlcy5vayB8fCByZXMudG9kbykge1xuICAgICAgICAgICAgc2VsZi5wYXNzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmZhaWwrKztcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZmFpbCcpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0Lm9uKCd0ZXN0JywgZnVuY3Rpb24gKHN0KSB7IHNlbGYuX3dhdGNoKHN0KTsgfSk7XG59O1xuXG5SZXN1bHRzLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuY2xvc2VkKSB7IHNlbGYuX3N0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQUxSRUFEWSBDTE9TRUQnKSk7IH1cbiAgICBzZWxmLmNsb3NlZCA9IHRydWU7XG4gICAgdmFyIHdyaXRlID0gZnVuY3Rpb24gKHMpIHsgc2VsZi5fc3RyZWFtLnF1ZXVlKHMpOyB9O1xuXG4gICAgd3JpdGUoJ1xcbjEuLicgKyBzZWxmLmNvdW50ICsgJ1xcbicpO1xuICAgIHdyaXRlKCcjIHRlc3RzICcgKyBzZWxmLmNvdW50ICsgJ1xcbicpO1xuICAgIHdyaXRlKCcjIHBhc3MgICcgKyAoc2VsZi5wYXNzICsgc2VsZi50b2RvKSArICdcXG4nKTtcbiAgICBpZiAoc2VsZi50b2RvKSB7IHdyaXRlKCcjIHRvZG8gICcgKyBzZWxmLnRvZG8gKyAnXFxuJyk7IH1cbiAgICBpZiAoc2VsZi5mYWlsKSB7XG4gICAgICAgIHdyaXRlKCcjIGZhaWwgICcgKyBzZWxmLmZhaWwgKyAnXFxuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGUoJ1xcbiMgb2tcXG4nKTtcbiAgICB9XG5cbiAgICBzZWxmLl9zdHJlYW0ucXVldWUobnVsbCk7XG59O1xuXG5mdW5jdGlvbiBlbmNvZGVSZXN1bHQocmVzLCBjb3VudCkge1xuICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICBvdXRwdXQgKz0gKHJlcy5vayA/ICdvayAnIDogJ25vdCBvayAnKSArIGNvdW50O1xuICAgIG91dHB1dCArPSByZXMubmFtZSA/ICcgJyArIGNvYWxlc2NlV2hpdGVTcGFjZXMocmVzLm5hbWUpIDogJyc7XG5cbiAgICBpZiAocmVzLnNraXApIHtcbiAgICAgICAgb3V0cHV0ICs9ICcgIyBTS0lQJyArICh0eXBlb2YgcmVzLnNraXAgPT09ICdzdHJpbmcnID8gJyAnICsgY29hbGVzY2VXaGl0ZVNwYWNlcyhyZXMuc2tpcCkgOiAnJyk7XG4gICAgfSBlbHNlIGlmIChyZXMudG9kbykge1xuICAgICAgICBvdXRwdXQgKz0gJyAjIFRPRE8nICsgKHR5cGVvZiByZXMudG9kbyA9PT0gJ3N0cmluZycgPyAnICcgKyBjb2FsZXNjZVdoaXRlU3BhY2VzKHJlcy50b2RvKSA6ICcnKTtcbiAgICB9XG5cbiAgICBvdXRwdXQgKz0gJ1xcbic7XG4gICAgaWYgKHJlcy5vaykgeyByZXR1cm4gb3V0cHV0OyB9XG5cbiAgICB2YXIgb3V0ZXIgPSAnICAnO1xuICAgIHZhciBpbm5lciA9IG91dGVyICsgJyAgJztcbiAgICBvdXRwdXQgKz0gb3V0ZXIgKyAnLS0tXFxuJztcbiAgICBvdXRwdXQgKz0gaW5uZXIgKyAnb3BlcmF0b3I6ICcgKyByZXMub3BlcmF0b3IgKyAnXFxuJztcblxuICAgIGlmIChoYXMocmVzLCAnZXhwZWN0ZWQnKSB8fCBoYXMocmVzLCAnYWN0dWFsJykpIHtcbiAgICAgICAgdmFyIGV4ID0gaW5zcGVjdChyZXMuZXhwZWN0ZWQsIHsgZGVwdGg6IHJlcy5vYmplY3RQcmludERlcHRoIH0pO1xuICAgICAgICB2YXIgYWMgPSBpbnNwZWN0KHJlcy5hY3R1YWwsIHsgZGVwdGg6IHJlcy5vYmplY3RQcmludERlcHRoIH0pO1xuXG4gICAgICAgIGlmIChNYXRoLm1heChleC5sZW5ndGgsIGFjLmxlbmd0aCkgPiA2NSB8fCBpbnZhbGlkWWFtbChleCkgfHwgaW52YWxpZFlhbWwoYWMpKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaW5uZXIgKyAnZXhwZWN0ZWQ6IHwtXFxuJyArIGlubmVyICsgJyAgJyArIGV4ICsgJ1xcbic7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaW5uZXIgKyAnYWN0dWFsOiB8LVxcbicgKyBpbm5lciArICcgICcgKyBhYyArICdcXG4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGlubmVyICsgJ2V4cGVjdGVkOiAnICsgZXggKyAnXFxuJztcbiAgICAgICAgICAgIG91dHB1dCArPSBpbm5lciArICdhY3R1YWw6ICAgJyArIGFjICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlcy5hdCkge1xuICAgICAgICBvdXRwdXQgKz0gaW5uZXIgKyAnYXQ6ICcgKyByZXMuYXQgKyAnXFxuJztcbiAgICB9XG5cbiAgICB2YXIgYWN0dWFsU3RhY2sgPSByZXMuYWN0dWFsICYmICh0eXBlb2YgcmVzLmFjdHVhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcy5hY3R1YWwgPT09ICdmdW5jdGlvbicpID8gcmVzLmFjdHVhbC5zdGFjayA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXJyb3JTdGFjayA9IHJlcy5lcnJvciAmJiByZXMuZXJyb3Iuc3RhY2s7XG4gICAgdmFyIHN0YWNrID0gZGVmaW5lZChhY3R1YWxTdGFjaywgZXJyb3JTdGFjayk7XG4gICAgaWYgKHN0YWNrKSB7XG4gICAgICAgIHZhciBsaW5lcyA9ICRzcGxpdChTdHJpbmcoc3RhY2spLCAnXFxuJyk7XG4gICAgICAgIG91dHB1dCArPSBpbm5lciArICdzdGFjazogfC1cXG4nO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaW5uZXIgKyAnICAnICsgbGluZXNbaV0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dCArPSBvdXRlciArICcuLi5cXG4nO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRUZXN0KHJlc3VsdHMpIHtcbiAgICBpZiAoIXJlc3VsdHMuX29ubHkpIHtcbiAgICAgICAgcmV0dXJuICRzaGlmdChyZXN1bHRzLnRlc3RzKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICAgIHZhciB0ID0gJHNoaWZ0KHJlc3VsdHMudGVzdHMpO1xuICAgICAgICBpZiAodCAmJiByZXN1bHRzLl9vbmx5ID09PSB0KSB7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKHJlc3VsdHMudGVzdHMubGVuZ3RoICE9PSAwKTtcblxuICAgIHJldHVybiB2b2lkIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaW52YWxpZFlhbWwoc3RyKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRlc3QoeWFtbEluZGljYXRvcnMsIHN0cik7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJ2RlZmluZWQnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaGFzID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCdpcy1yZWdleCcpO1xudmFyIHRyaW0gPSByZXF1aXJlKCdzdHJpbmcucHJvdG90eXBlLnRyaW0nKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJyk7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG52YXIgaXMgPSByZXF1aXJlKCdvYmplY3QtaXMnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBldmVyeSA9IHJlcXVpcmUoJ2FycmF5LnByb3RvdHlwZS5ldmVyeScpO1xuXG52YXIgaXNFbnVtZXJhYmxlID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlJyk7XG52YXIgdG9Mb3dlckNhc2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UnKTtcbnZhciBpc1Byb3RvID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YnKTtcbnZhciAkZXhlYyA9IGNhbGxCb3VuZCgnUmVnRXhwLnByb3RvdHlwZS5leGVjJyk7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciAkc3BsaXQgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc3BsaXQnKTtcbnZhciAkcmVwbGFjZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlJyk7XG52YXIgJHN0clNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgJHB1c2ggPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5wdXNoJyk7XG52YXIgJHNoaWZ0ID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuc2hpZnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXN0O1xuXG52YXIgbmV4dFRpY2sgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJ1xuICAgID8gc2V0SW1tZWRpYXRlXG4gICAgOiBwcm9jZXNzLm5leHRUaWNrO1xudmFyIHNhZmVTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbnZhciBzYWZlQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXG5pbmhlcml0cyhUZXN0LCBFdmVudEVtaXR0ZXIpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBnZXRUZXN0QXJncyA9IGZ1bmN0aW9uIChuYW1lXywgb3B0c18sIGNiXykge1xuICAgIHZhciBuYW1lID0gJyhhbm9ueW1vdXMpJztcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIHZhciBjYjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHZhciB0ID0gdHlwZW9mIGFyZztcbiAgICAgICAgaWYgKHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRzID0gYXJnIHx8IG9wdHM7XG4gICAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBhcmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3B0czogb3B0cyxcbiAgICAgICAgY2I6IGNiXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIFRlc3QobmFtZV8sIG9wdHNfLCBjYl8pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGVzdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXN0KG5hbWVfLCBvcHRzXywgY2JfKTtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IGdldFRlc3RBcmdzKG5hbWVfLCBvcHRzXywgY2JfKTtcblxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IGFyZ3MubmFtZSB8fCAnKGFub255bW91cyknO1xuICAgIHRoaXMuYXNzZXJ0Q291bnQgPSAwO1xuICAgIHRoaXMucGVuZGluZ0NvdW50ID0gMDtcbiAgICB0aGlzLl9za2lwID0gYXJncy5vcHRzLnNraXAgfHwgZmFsc2U7XG4gICAgdGhpcy5fdG9kbyA9IGFyZ3Mub3B0cy50b2RvIHx8IGZhbHNlO1xuICAgIHRoaXMuX3RpbWVvdXQgPSBhcmdzLm9wdHMudGltZW91dDtcbiAgICB0aGlzLl9wbGFuID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NiID0gYXJncy5jYjtcbiAgICB0aGlzLl9wcm9nZW55ID0gW107XG4gICAgdGhpcy5fdGVhcmRvd24gPSBbXTtcbiAgICB0aGlzLl9vayA9IHRydWU7XG4gICAgdmFyIGRlcHRoRW52VmFyID0gcHJvY2Vzcy5lbnYuTk9ERV9UQVBFX09CSkVDVF9QUklOVF9ERVBUSDtcbiAgICBpZiAoYXJncy5vcHRzLm9iamVjdFByaW50RGVwdGgpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UHJpbnREZXB0aCA9IGFyZ3Mub3B0cy5vYmplY3RQcmludERlcHRoO1xuICAgIH0gZWxzZSBpZiAoZGVwdGhFbnZWYXIpIHtcbiAgICAgICAgaWYgKHRvTG93ZXJDYXNlKGRlcHRoRW52VmFyKSA9PT0gJ2luZmluaXR5Jykge1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0UHJpbnREZXB0aCA9IEluZmluaXR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0UHJpbnREZXB0aCA9IGRlcHRoRW52VmFyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UHJpbnREZXB0aCA9IDU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSAoZnVuY3Rpb24gYmluZChzZWxmLCB2YWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0odGhpcywgdGhpc1twcm9wXSkpO1xuICAgIH1cbn1cblxuVGVzdC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgIHRoaXMuZW1pdCgncHJlcnVuJyk7XG4gICAgaWYgKCF0aGlzLl9jYiB8fCB0aGlzLl9za2lwKSB7XG4gICAgICAgIHRoaXMuX2VuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl90aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0QWZ0ZXIodGhpcy5fdGltZW91dCk7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrUmV0dXJuID0gdGhpcy5fY2IodGhpcyk7XG5cbiAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICYmIGNhbGxiYWNrUmV0dXJuXG4gICAgICAgICYmIHR5cGVvZiBjYWxsYmFja1JldHVybi50aGVuID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrUmV0dXJuKS50aGVuKGZ1bmN0aW9uIG9uUmVzb2x2ZSgpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5jYWxsZWRFbmQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IG9iamVjdFRvU3RyaW5nKGVycikgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlmRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5mYWlsKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgncnVuJyk7XG59O1xuXG5UZXN0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdChuYW1lLCBvcHRzLCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdCA9IG5ldyBUZXN0KG5hbWUsIG9wdHMsIGNiKTtcbiAgICAkcHVzaCh0aGlzLl9wcm9nZW55LCB0KTtcbiAgICB0aGlzLnBlbmRpbmdDb3VudCsrO1xuICAgIHRoaXMuZW1pdCgndGVzdCcsIHQpO1xuICAgIHQub24oJ3ByZXJ1bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5hc3NlcnRDb3VudCsrO1xuICAgIH0pO1xuXG4gICAgaWYgKCFzZWxmLl9wZW5kaW5nQXNzZXJ0cygpKSB7XG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuX2VuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2VsZi5fcGxhbiAmJiBzZWxmLnBlbmRpbmdDb3VudCA9PSBzZWxmLl9wcm9nZW55Lmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5fZW5kKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblRlc3QucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KG1zZykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBmb3JFYWNoKCRzcGxpdCh0cmltKG1zZyksICdcXG4nKSwgZnVuY3Rpb24gKGFNc2cpIHtcbiAgICAgICAgdGhhdC5lbWl0KCdyZXN1bHQnLCAkcmVwbGFjZSh0cmltKGFNc2cpLCAvXiNcXHMqLywgJycpKTtcbiAgICB9KTtcbn07XG5cblRlc3QucHJvdG90eXBlLnBsYW4gPSBmdW5jdGlvbiBwbGFuKG4pIHtcbiAgICB0aGlzLl9wbGFuID0gbjtcbiAgICB0aGlzLmVtaXQoJ3BsYW4nLCBuKTtcbn07XG5cblRlc3QucHJvdG90eXBlLnRpbWVvdXRBZnRlciA9IGZ1bmN0aW9uIHRpbWVvdXRBZnRlcihtcykge1xuICAgIGlmICghbXMpIHsgdGhyb3cgbmV3IEVycm9yKCd0aW1lb3V0QWZ0ZXIgcmVxdWlyZXMgYSB0aW1lc3BhbicpOyB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aW1lb3V0ID0gc2FmZVNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmZhaWwoc2VsZi5uYW1lICsgJyB0aW1lZCBvdXQgYWZ0ZXIgJyArIG1zICsgJ21zJyk7XG4gICAgICAgIHNlbGYuZW5kKCk7XG4gICAgfSwgbXMpO1xuICAgIHRoaXMub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzYWZlQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH0pO1xufTtcblxuVGVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVycikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDEgJiYgISFlcnIpIHtcbiAgICAgICAgdGhpcy5pZkVycm9yKGVycik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FsbGVkRW5kKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnLmVuZCgpIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgfVxuICAgIHRoaXMuY2FsbGVkRW5kID0gdHJ1ZTtcbiAgICB0aGlzLl9lbmQoKTtcbn07XG5cblRlc3QucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZmFpbCgndGVhcmRvd246ICcgKyBpbnNwZWN0KGZuKSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90ZWFyZG93bi5wdXNoKGZuKTtcbiAgICB9XG59O1xuXG5UZXN0LnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24gX2VuZChlcnIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuX2NiICYmICF0aGlzLl90b2RvICYmICF0aGlzLl9za2lwKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnIyBUT0RPICcgKyB0aGlzLm5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcm9nZW55Lmxlbmd0aCkge1xuICAgICAgICB2YXIgdCA9ICRzaGlmdCh0aGlzLl9wcm9nZW55KTtcbiAgICAgICAgdC5vbignZW5kJywgZnVuY3Rpb24gKCkgeyBzZWxmLl9lbmQoKTsgfSk7XG4gICAgICAgIHQucnVuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAoc2VsZi5fdGVhcmRvd24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wbGV0ZUVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9IHNlbGYuX3RlYXJkb3duLnNoaWZ0KCk7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBmbigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZWxmLmZhaWwoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKG5leHQsIGZ1bmN0aW9uIChfZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd3RoP1xuICAgICAgICAgICAgICAgIGVyciA9IGVyciB8fCBfZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0KCk7XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUVuZCgpIHtcbiAgICAgICAgaWYgKCFzZWxmLmVuZGVkKSB7IHNlbGYuZW1pdCgnZW5kJyk7IH1cbiAgICAgICAgdmFyIHBlbmRpbmdBc3NlcnRzID0gc2VsZi5fcGVuZGluZ0Fzc2VydHMoKTtcbiAgICAgICAgaWYgKCFzZWxmLl9wbGFuRXJyb3IgJiYgc2VsZi5fcGxhbiAhPT0gdW5kZWZpbmVkICYmIHBlbmRpbmdBc3NlcnRzKSB7XG4gICAgICAgICAgICBzZWxmLl9wbGFuRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5mYWlsKCdwbGFuICE9IGNvdW50Jywge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBzZWxmLl9wbGFuLFxuICAgICAgICAgICAgICAgIGFjdHVhbDogc2VsZi5hc3NlcnRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lbmRlZCA9IHRydWU7XG4gICAgfVxufTtcblxuVGVzdC5wcm90b3R5cGUuX2V4aXQgPSBmdW5jdGlvbiBfZXhpdCgpIHtcbiAgICBpZiAodGhpcy5fcGxhbiAhPT0gdW5kZWZpbmVkICYmICF0aGlzLl9wbGFuRXJyb3IgJiYgdGhpcy5hc3NlcnRDb3VudCAhPT0gdGhpcy5fcGxhbikge1xuICAgICAgICB0aGlzLl9wbGFuRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmZhaWwoJ3BsYW4gIT0gY291bnQnLCB7XG4gICAgICAgICAgICBleHBlY3RlZDogdGhpcy5fcGxhbixcbiAgICAgICAgICAgIGFjdHVhbDogdGhpcy5hc3NlcnRDb3VudCxcbiAgICAgICAgICAgIGV4aXRpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5lbmRlZCkge1xuICAgICAgICB0aGlzLmZhaWwoJ3Rlc3QgZXhpdGVkIHdpdGhvdXQgZW5kaW5nOiAnICsgdGhpcy5uYW1lLCB7XG4gICAgICAgICAgICBleGl0aW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblRlc3QucHJvdG90eXBlLl9wZW5kaW5nQXNzZXJ0cyA9IGZ1bmN0aW9uIF9wZW5kaW5nQXNzZXJ0cygpIHtcbiAgICBpZiAodGhpcy5fcGxhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGxhbiAtICh0aGlzLl9wcm9nZW55Lmxlbmd0aCArIHRoaXMuYXNzZXJ0Q291bnQpO1xufTtcblxuVGVzdC5wcm90b3R5cGUuX2Fzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChvaywgb3B0cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXh0cmEgPSBvcHRzLmV4dHJhIHx8IHt9O1xuXG4gICAgb2sgPSAhIW9rIHx8ICEhZXh0cmEuc2tpcDtcblxuICAgIHZhciBuYW1lID0gZGVmaW5lZChleHRyYS5tZXNzYWdlLCBvcHRzLm1lc3NhZ2UsICcodW5uYW1lZCBhc3NlcnQpJyk7XG4gICAgaWYgKHRoaXMuY2FsbGVkRW5kICYmIG9wdHMub3BlcmF0b3IgIT09ICdmYWlsJykge1xuICAgICAgICB0aGlzLmZhaWwoJy5lbmQoKSBhbHJlYWR5IGNhbGxlZDogJyArIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgaWQ6IHNlbGYuYXNzZXJ0Q291bnQrKyxcbiAgICAgICAgb2s6IG9rLFxuICAgICAgICBza2lwOiBkZWZpbmVkKGV4dHJhLnNraXAsIG9wdHMuc2tpcCksXG4gICAgICAgIHRvZG86IGRlZmluZWQoZXh0cmEudG9kbywgb3B0cy50b2RvLCBzZWxmLl90b2RvKSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3BlcmF0b3I6IGRlZmluZWQoZXh0cmEub3BlcmF0b3IsIG9wdHMub3BlcmF0b3IpLFxuICAgICAgICBvYmplY3RQcmludERlcHRoOiBzZWxmLl9vYmplY3RQcmludERlcHRoXG4gICAgfTtcbiAgICBpZiAoaGFzKG9wdHMsICdhY3R1YWwnKSB8fCBoYXMoZXh0cmEsICdhY3R1YWwnKSkge1xuICAgICAgICByZXMuYWN0dWFsID0gZGVmaW5lZChleHRyYS5hY3R1YWwsIG9wdHMuYWN0dWFsKTtcbiAgICB9XG4gICAgaWYgKGhhcyhvcHRzLCAnZXhwZWN0ZWQnKSB8fCBoYXMoZXh0cmEsICdleHBlY3RlZCcpKSB7XG4gICAgICAgIHJlcy5leHBlY3RlZCA9IGRlZmluZWQoZXh0cmEuZXhwZWN0ZWQsIG9wdHMuZXhwZWN0ZWQpO1xuICAgIH1cbiAgICB0aGlzLl9vayA9ICEhKHRoaXMuX29rICYmIG9rKTtcblxuICAgIGlmICghb2sgJiYgIXJlcy50b2RvKSB7XG4gICAgICAgIHJlcy5lcnJvciA9IGRlZmluZWQoZXh0cmEuZXJyb3IsIG9wdHMuZXJyb3IsIG5ldyBFcnJvcihyZXMubmFtZSkpO1xuICAgIH1cblxuICAgIGlmICghb2spIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2V4Y2VwdGlvbicpO1xuICAgICAgICB2YXIgZXJyID0gJHNwbGl0KGUuc3RhY2sgfHwgJycsICdcXG4nKTtcbiAgICAgICAgdmFyIGRpciA9IF9fZGlybmFtZSArIHBhdGguc2VwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIFN0YWNrIHRyYWNlIGxpbmVzIG1heSByZXNlbWJsZSBvbmUgb2YgdGhlIGZvbGxvd2luZy4gV2UgbmVlZFxuICAgICAgICAgICAgICAgIHRvIGNvcnJlY3RseSBleHRyYWN0IGEgZnVuY3Rpb24gbmFtZSAoaWYgYW55KSBhbmQgcGF0aCAvIGxpbmVcbiAgICAgICAgICAgICAgICBudW1iZXIgZm9yIGVhY2ggbGluZS5cblxuICAgICAgICAgICAgICAgICAgICBhdCBteUZ1bmN0aW9uICgvcGF0aC90by9maWxlLmpzOjEyMzo0NSlcbiAgICAgICAgICAgICAgICAgICAgYXQgbXlGdW5jdGlvbiAoL3BhdGgvdG8vZmlsZS5vdGhlci1leHQ6MTIzOjQ1KVxuICAgICAgICAgICAgICAgICAgICBhdCBteUZ1bmN0aW9uICgvcGF0aCB0by9maWxlLmpzOjEyMzo0NSlcbiAgICAgICAgICAgICAgICAgICAgYXQgbXlGdW5jdGlvbiAoQzpcXHBhdGhcXHRvXFxmaWxlLmpzOjEyMzo0NSlcbiAgICAgICAgICAgICAgICAgICAgYXQgbXlGdW5jdGlvbiAoL3BhdGgvdG8vZmlsZS5qczoxMjMpXG4gICAgICAgICAgICAgICAgICAgIGF0IFRlc3QuPGFub255bW91cz4gKC9wYXRoL3RvL2ZpbGUuanM6MTIzOjQ1KVxuICAgICAgICAgICAgICAgICAgICBhdCBUZXN0LmJvdW5kIFthcyBydW5dICgvcGF0aC90by9maWxlLmpzOjEyMzo0NSlcbiAgICAgICAgICAgICAgICAgICAgYXQgL3BhdGgvdG8vZmlsZS5qczoxMjM6NDVcblxuICAgICAgICAgICAgICAgIFJlZ2V4IGhhcyB0aHJlZSBwYXJ0cy4gRmlyc3QgaXMgbm9uLWNhcHR1cmluZyBncm91cCBmb3IgJ2F0ICdcbiAgICAgICAgICAgICAgICAocGx1cyBhbnl0aGluZyBwcmVjZWRpbmcgaXQpLlxuXG4gICAgICAgICAgICAgICAgICAgIC9eKD86W15cXHNdKlxccypcXGJhdFxccyspL1xuXG4gICAgICAgICAgICAgICAgU2Vjb25kIGNhcHR1cmVzIGZ1bmN0aW9uIGNhbGwgZGVzY3JpcHRpb24gKG9wdGlvbmFsKS4gVGhpcyBpc1xuICAgICAgICAgICAgICAgIG5vdCBuZWNlc3NhcmlseSBhIHZhbGlkIEpTIGZ1bmN0aW9uIG5hbWUsIGJ1dCBqdXN0IHdoYXQgdGhlXG4gICAgICAgICAgICAgICAgc3RhY2sgdHJhY2UgaXMgdXNpbmcgdG8gcmVwcmVzZW50IGEgZnVuY3Rpb24gY2FsbC4gSXQgbWF5IGxvb2tcbiAgICAgICAgICAgICAgICBsaWtlIGA8YW5vbnltb3VzPmAgb3IgJ1Rlc3QuYm91bmQgW2FzIHJ1bl0nLlxuXG4gICAgICAgICAgICAgICAgRm9yIG91ciBwdXJwb3Nlcywgd2UgYXNzdW1lIHRoYXQsIGlmIHRoZXJlIGlzIGEgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBuYW1lLCBpdCdzIGV2ZXJ5dGhpbmcgbGVhZGluZyB1cCB0byB0aGUgZmlyc3Qgb3BlblxuICAgICAgICAgICAgICAgIHBhcmVudGhlc2VzICh0cmltbWVkKSBiZWZvcmUgb3VyIHBhdGhuYW1lLlxuXG4gICAgICAgICAgICAgICAgICAgIC8oPzooLiopXFxzK1xcKCk/L1xuXG4gICAgICAgICAgICAgICAgTGFzdCBwYXJ0IGNhcHR1cmVzIGZpbGUgcGF0aCBwbHVzIGxpbmUgbm8gKGFuZCBvcHRpb25hbFxuICAgICAgICAgICAgICAgIGNvbHVtbiBubykuXG5cbiAgICAgICAgICAgICAgICAgICAgLygoPzpcXC98W2EtekEtWl06XFxcXClbXjpcXCldKzooXFxkKykoPzo6KFxcZCspKT8pXFwpPy9cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgcmUgPSAvXig/OlteXFxzXSpcXHMqXFxiYXRcXHMrKSg/OiguKilcXHMrXFwoKT8oKD86XFwvfFthLXpBLVpdOlxcXFwpW146KV0rOihcXGQrKSg/OjooXFxkKykpPylcXCk/JC87XG4gICAgICAgICAgICB2YXIgbGluZVdpdGhUb2tlbnMgPSAkcmVwbGFjZSgkcmVwbGFjZShlcnJbaV0sIHByb2Nlc3MuY3dkKCksICcvJENXRCcpLCBfX2Rpcm5hbWUsICcvJFRFU1QnKTtcbiAgICAgICAgICAgIHZhciBtID0gcmUuZXhlYyhsaW5lV2l0aFRva2Vucyk7XG5cbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FsbERlc2NyaXB0aW9uID0gbVsxXSB8fCAnPGFub255bW91cz4nO1xuICAgICAgICAgICAgdmFyIGZpbGVQYXRoID0gJHJlcGxhY2UoJHJlcGxhY2UobVsyXSwgJy8kQ1dEJywgcHJvY2Vzcy5jd2QoKSksICcvJFRFU1QnLCBfX2Rpcm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoJHN0clNsaWNlKGZpbGVQYXRoLCAwLCBkaXIubGVuZ3RoKSA9PT0gZGlyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNhbGwgZGVzY3JpcHRpb24gbWF5IG5vdCAoanVzdCkgYmUgYSBmdW5jdGlvbiBuYW1lLlxuICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZSBieSBsb29raW5nIGF0IGZpcnN0IFwid29yZFwiIG9ubHkuXG4gICAgICAgICAgICByZXMuZnVuY3Rpb25OYW1lID0gJHNwbGl0KGNhbGxEZXNjcmlwdGlvbiwgL1xccysvKVswXTtcbiAgICAgICAgICAgIHJlcy5maWxlID0gZmlsZVBhdGg7XG4gICAgICAgICAgICByZXMubGluZSA9IE51bWJlcihtWzNdKTtcbiAgICAgICAgICAgIGlmIChtWzRdKSB7IHJlcy5jb2x1bW4gPSBOdW1iZXIobVs0XSk7IH1cblxuICAgICAgICAgICAgcmVzLmF0ID0gY2FsbERlc2NyaXB0aW9uICsgJyAoJyArIGZpbGVQYXRoICsgJyknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3VsdCcsIHJlcyk7XG5cbiAgICB2YXIgcGVuZGluZ0Fzc2VydHMgPSBzZWxmLl9wZW5kaW5nQXNzZXJ0cygpO1xuICAgIGlmICghcGVuZGluZ0Fzc2VydHMpIHtcbiAgICAgICAgaWYgKGV4dHJhLmV4aXRpbmcpIHtcbiAgICAgICAgICAgIHNlbGYuX2VuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2VuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNlbGYuX3BsYW5FcnJvciAmJiBwZW5kaW5nQXNzZXJ0cyA8IDApIHtcbiAgICAgICAgc2VsZi5fcGxhbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5mYWlsKCdwbGFuICE9IGNvdW50Jywge1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IHNlbGYuX3BsYW4sXG4gICAgICAgICAgICBhY3R1YWw6IHNlbGYuX3BsYW4gLSBwZW5kaW5nQXNzZXJ0c1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5UZXN0LnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gZmFpbChtc2csIGV4dHJhKSB7XG4gICAgdGhpcy5fYXNzZXJ0KGZhbHNlLCB7XG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgb3BlcmF0b3I6ICdmYWlsJyxcbiAgICAgICAgZXh0cmE6IGV4dHJhXG4gICAgfSk7XG59O1xuXG5UZXN0LnByb3RvdHlwZS5wYXNzID0gZnVuY3Rpb24gcGFzcyhtc2csIGV4dHJhKSB7XG4gICAgdGhpcy5fYXNzZXJ0KHRydWUsIHtcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBvcGVyYXRvcjogJ3Bhc3MnLFxuICAgICAgICBleHRyYTogZXh0cmFcbiAgICB9KTtcbn07XG5cblRlc3QucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKG1zZywgZXh0cmEpIHtcbiAgICB0aGlzLl9hc3NlcnQodHJ1ZSwge1xuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnc2tpcCcsXG4gICAgICAgIHNraXA6IHRydWUsXG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgIH0pO1xufTtcblxudmFyIHRlc3RBc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1zZywgZXh0cmEpIHtcbiAgICB0aGlzLl9hc3NlcnQodmFsdWUsIHtcbiAgICAgICAgbWVzc2FnZTogZGVmaW5lZChtc2csICdzaG91bGQgYmUgdHJ1dGh5JyksXG4gICAgICAgIG9wZXJhdG9yOiAnb2snLFxuICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgYWN0dWFsOiB2YWx1ZSxcbiAgICAgICAgZXh0cmE6IGV4dHJhXG4gICAgfSk7XG59O1xuVGVzdC5wcm90b3R5cGUub2tcbj0gVGVzdC5wcm90b3R5cGVbJ3RydWUnXVxuPSBUZXN0LnByb3RvdHlwZS5hc3NlcnRcbj0gdGVzdEFzc2VydDtcblxuZnVuY3Rpb24gbm90T0sodmFsdWUsIG1zZywgZXh0cmEpIHtcbiAgICB0aGlzLl9hc3NlcnQoIXZhbHVlLCB7XG4gICAgICAgIG1lc3NhZ2U6IGRlZmluZWQobXNnLCAnc2hvdWxkIGJlIGZhbHN5JyksXG4gICAgICAgIG9wZXJhdG9yOiAnbm90T2snLFxuICAgICAgICBleHBlY3RlZDogZmFsc2UsXG4gICAgICAgIGFjdHVhbDogdmFsdWUsXG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgIH0pO1xufVxuVGVzdC5wcm90b3R5cGUubm90T2tcbj0gVGVzdC5wcm90b3R5cGVbJ2ZhbHNlJ11cbj0gVGVzdC5wcm90b3R5cGUubm90b2tcbj0gbm90T0s7XG5cbmZ1bmN0aW9uIGVycm9yKGVyciwgbXNnLCBleHRyYSkge1xuICAgIHRoaXMuX2Fzc2VydCghZXJyLCB7XG4gICAgICAgIG1lc3NhZ2U6IGRlZmluZWQobXNnLCBTdHJpbmcoZXJyKSksXG4gICAgICAgIG9wZXJhdG9yOiAnZXJyb3InLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICBleHRyYTogZXh0cmFcbiAgICB9KTtcbn1cblRlc3QucHJvdG90eXBlLmVycm9yXG49IFRlc3QucHJvdG90eXBlLmlmRXJyb3Jcbj0gVGVzdC5wcm90b3R5cGUuaWZFcnJcbj0gVGVzdC5wcm90b3R5cGUuaWZlcnJvclxuPSBlcnJvcjtcblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYiwgbXNnLCBleHRyYSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0d28gYXJndW1lbnRzIG11c3QgYmUgcHJvdmlkZWQgdG8gY29tcGFyZScpO1xuICAgIH1cbiAgICB0aGlzLl9hc3NlcnQoaXMoYSwgYiksIHtcbiAgICAgICAgbWVzc2FnZTogZGVmaW5lZChtc2csICdzaG91bGQgYmUgc3RyaWN0bHkgZXF1YWwnKSxcbiAgICAgICAgb3BlcmF0b3I6ICdlcXVhbCcsXG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgIH0pO1xufVxuVGVzdC5wcm90b3R5cGUuZXF1YWxcbj0gVGVzdC5wcm90b3R5cGUuZXF1YWxzXG49IFRlc3QucHJvdG90eXBlLmlzRXF1YWxcbj0gVGVzdC5wcm90b3R5cGUuc3RyaWN0RXF1YWxcbj0gVGVzdC5wcm90b3R5cGUuc3RyaWN0RXF1YWxzXG49IFRlc3QucHJvdG90eXBlLmlzXG49IHN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhLCBiLCBtc2csIGV4dHJhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R3byBhcmd1bWVudHMgbXVzdCBiZSBwcm92aWRlZCB0byBjb21wYXJlJyk7XG4gICAgfVxuICAgIHRoaXMuX2Fzc2VydCghaXMoYSwgYiksIHtcbiAgICAgICAgbWVzc2FnZTogZGVmaW5lZChtc2csICdzaG91bGQgbm90IGJlIHN0cmljdGx5IGVxdWFsJyksXG4gICAgICAgIG9wZXJhdG9yOiAnbm90RXF1YWwnLFxuICAgICAgICBhY3R1YWw6IGEsXG4gICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICBleHRyYTogZXh0cmFcbiAgICB9KTtcbn1cblxuVGVzdC5wcm90b3R5cGUubm90RXF1YWxcbj0gVGVzdC5wcm90b3R5cGUubm90RXF1YWxzXG49IFRlc3QucHJvdG90eXBlLmlzTm90RXF1YWxcbj0gVGVzdC5wcm90b3R5cGUuZG9lc05vdEVxdWFsXG49IFRlc3QucHJvdG90eXBlLmlzSW5lcXVhbFxuPSBUZXN0LnByb3RvdHlwZS5ub3RTdHJpY3RFcXVhbFxuPSBUZXN0LnByb3RvdHlwZS5ub3RTdHJpY3RFcXVhbHNcbj0gVGVzdC5wcm90b3R5cGUuaXNOb3Rcbj0gVGVzdC5wcm90b3R5cGUubm90XG49IG5vdFN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIsIG1zZywgZXh0cmEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHdvIGFyZ3VtZW50cyBtdXN0IGJlIHByb3ZpZGVkIHRvIGNvbXBhcmUnKTtcbiAgICB9XG4gICAgdGhpcy5fYXNzZXJ0KGEgPT0gYiwge1xuICAgICAgICBtZXNzYWdlOiBkZWZpbmVkKG1zZywgJ3Nob3VsZCBiZSBsb29zZWx5IGVxdWFsJyksXG4gICAgICAgIG9wZXJhdG9yOiAnbG9vc2VFcXVhbCcsXG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgIH0pO1xufVxuXG5UZXN0LnByb3RvdHlwZS5sb29zZUVxdWFsXG49IFRlc3QucHJvdG90eXBlLmxvb3NlRXF1YWxzXG49IGxvb3NlRXF1YWw7XG5cbmZ1bmN0aW9uIG5vdExvb3NlRXF1YWwoYSwgYiwgbXNnLCBleHRyYSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0d28gYXJndW1lbnRzIG11c3QgYmUgcHJvdmlkZWQgdG8gY29tcGFyZScpO1xuICAgIH1cbiAgICB0aGlzLl9hc3NlcnQoYSAhPSBiLCB7XG4gICAgICAgIG1lc3NhZ2U6IGRlZmluZWQobXNnLCAnc2hvdWxkIG5vdCBiZSBsb29zZWx5IGVxdWFsJyksXG4gICAgICAgIG9wZXJhdG9yOiAnbm90TG9vc2VFcXVhbCcsXG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgIH0pO1xufVxuVGVzdC5wcm90b3R5cGUubm90TG9vc2VFcXVhbFxuPSBUZXN0LnByb3RvdHlwZS5ub3RMb29zZUVxdWFsc1xuPSBub3RMb29zZUVxdWFsO1xuXG5mdW5jdGlvbiB0YXBlRGVlcEVxdWFsKGEsIGIsIG1zZywgZXh0cmEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHdvIGFyZ3VtZW50cyBtdXN0IGJlIHByb3ZpZGVkIHRvIGNvbXBhcmUnKTtcbiAgICB9XG4gICAgdGhpcy5fYXNzZXJ0KGRlZXBFcXVhbChhLCBiLCB7IHN0cmljdDogdHJ1ZSB9KSwge1xuICAgICAgICBtZXNzYWdlOiBkZWZpbmVkKG1zZywgJ3Nob3VsZCBiZSBkZWVwbHkgZXF1aXZhbGVudCcpLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgIH0pO1xufVxuVGVzdC5wcm90b3R5cGUuZGVlcEVxdWFsXG49IFRlc3QucHJvdG90eXBlLmRlZXBFcXVhbHNcbj0gVGVzdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50XG49IFRlc3QucHJvdG90eXBlLnNhbWVcbj0gdGFwZURlZXBFcXVhbDtcblxuZnVuY3Rpb24gbm90RGVlcEVxdWFsKGEsIGIsIG1zZywgZXh0cmEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHdvIGFyZ3VtZW50cyBtdXN0IGJlIHByb3ZpZGVkIHRvIGNvbXBhcmUnKTtcbiAgICB9XG4gICAgdGhpcy5fYXNzZXJ0KCFkZWVwRXF1YWwoYSwgYiwgeyBzdHJpY3Q6IHRydWUgfSksIHtcbiAgICAgICAgbWVzc2FnZTogZGVmaW5lZChtc2csICdzaG91bGQgbm90IGJlIGRlZXBseSBlcXVpdmFsZW50JyksXG4gICAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgZXh0cmE6IGV4dHJhXG4gICAgfSk7XG59XG5UZXN0LnByb3RvdHlwZS5ub3REZWVwRXF1YWxcbj0gVGVzdC5wcm90b3R5cGUubm90RGVlcEVxdWFsc1xuPSBUZXN0LnByb3RvdHlwZS5ub3RFcXVpdmFsZW50XG49IFRlc3QucHJvdG90eXBlLm5vdERlZXBseVxuPSBUZXN0LnByb3RvdHlwZS5ub3RTYW1lXG49IFRlc3QucHJvdG90eXBlLmlzTm90RGVlcEVxdWFsXG49IFRlc3QucHJvdG90eXBlLmlzTm90RGVlcGx5XG49IFRlc3QucHJvdG90eXBlLmlzTm90RXF1aXZhbGVudFxuPSBUZXN0LnByb3RvdHlwZS5pc0luZXF1aXZhbGVudFxuPSBub3REZWVwRXF1YWw7XG5cbmZ1bmN0aW9uIGRlZXBMb29zZUVxdWFsKGEsIGIsIG1zZywgZXh0cmEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHdvIGFyZ3VtZW50cyBtdXN0IGJlIHByb3ZpZGVkIHRvIGNvbXBhcmUnKTtcbiAgICB9XG4gICAgdGhpcy5fYXNzZXJ0KGRlZXBFcXVhbChhLCBiKSwge1xuICAgICAgICBtZXNzYWdlOiBkZWZpbmVkKG1zZywgJ3Nob3VsZCBiZSBsb29zZWx5IGRlZXBseSBlcXVpdmFsZW50JyksXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcExvb3NlRXF1YWwnLFxuICAgICAgICBhY3R1YWw6IGEsXG4gICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICBleHRyYTogZXh0cmFcbiAgICB9KTtcbn1cblxuVGVzdC5wcm90b3R5cGUuZGVlcExvb3NlRXF1YWxcbj0gZGVlcExvb3NlRXF1YWw7XG5cbmZ1bmN0aW9uIG5vdERlZXBMb29zZUVxdWFsKGEsIGIsIG1zZywgZXh0cmEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHdvIGFyZ3VtZW50cyBtdXN0IGJlIHByb3ZpZGVkIHRvIGNvbXBhcmUnKTtcbiAgICB9XG4gICAgdGhpcy5fYXNzZXJ0KCFkZWVwRXF1YWwoYSwgYiksIHtcbiAgICAgICAgbWVzc2FnZTogZGVmaW5lZChtc2csICdzaG91bGQgbm90IGJlIGxvb3NlbHkgZGVlcGx5IGVxdWl2YWxlbnQnKSxcbiAgICAgICAgb3BlcmF0b3I6ICdub3REZWVwTG9vc2VFcXVhbCcsXG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgIH0pO1xufVxuVGVzdC5wcm90b3R5cGUubm90RGVlcExvb3NlRXF1YWxcbj0gbm90RGVlcExvb3NlRXF1YWw7XG5cblRlc3QucHJvdG90eXBlWyd0aHJvd3MnXSA9IGZ1bmN0aW9uIChmbiwgZXhwZWN0ZWQsIG1zZywgZXh0cmEpIHtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICBtc2cgPSBleHBlY3RlZDtcbiAgICAgICAgZXhwZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNhdWdodDtcblxuICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNhdWdodCA9IHsgZXJyb3I6IGVyciB9O1xuICAgICAgICBpZiAoT2JqZWN0KGVycikgPT09IGVyciAmJiAoIWlzRW51bWVyYWJsZShlcnIsICdtZXNzYWdlJykgfHwgIWhhcyhlcnIsICdtZXNzYWdlJykpKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgZGVsZXRlIGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhc3NlZCA9IGNhdWdodDtcblxuICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgY2F1Z2h0LmVycm9yICYmIGNhdWdodC5lcnJvci5tZXNzYWdlID09PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZXJyb3IvbWVzc2FnZVwiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gVGhlIGVycm9yIG1lc3NhZ2UgJyArIGluc3BlY3QoZXhwZWN0ZWQpICsgJyBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZC5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIGNhdWdodC5lcnJvciBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQcm90byhFcnJvciwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhc3NlZCA9IGV4cGVjdGVkLmNhbGwoe30sIGNhdWdodC5lcnJvcikgPT09IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICBwYXNzZWQgPSAkZXhlYyhleHBlY3RlZCwgY2F1Z2h0LmVycm9yKSAhPT0gbnVsbDtcbiAgICAgICAgICAgIGV4cGVjdGVkID0gaW5zcGVjdChleHBlY3RlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgJiYgdHlwZW9mIGV4cGVjdGVkID09PSAnb2JqZWN0JykgeyAvLyBIYW5kbGUgdmFsaWRhdGlvbiBvYmplY3RzLlxuICAgICAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV4cGVjdGVkKTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxlIGVycm9ycyB0byBtYWtlIHN1cmUgdGhlIG5hbWUgYW5kIHRoZSBtZXNzYWdlIGFyZSBjb21wYXJlZCBhcyB3ZWxsLlxuICAgICAgICAgICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkcHVzaChrZXlzLCAnbmFtZScsICdtZXNzYWdlJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHRocm93c2AgdmFsaWRhdGlvbiBvYmplY3QgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhc3NlZCA9IGV2ZXJ5KGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhdWdodC5lcnJvcltrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiAkZXhlYyhleHBlY3RlZFtrZXldLCBjYXVnaHQuZXJyb3Jba2V5XSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gY2F1Z2h0LmVycm9yICYmIGRlZXBFcXVhbChjYXVnaHQuZXJyb3Jba2V5XSwgZXhwZWN0ZWRba2V5XSwgeyBzdHJpY3Q6IHRydWUgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fYXNzZXJ0KCEhcGFzc2VkLCB7XG4gICAgICAgIG1lc3NhZ2U6IGRlZmluZWQobXNnLCAnc2hvdWxkIHRocm93JyksXG4gICAgICAgIG9wZXJhdG9yOiAndGhyb3dzJyxcbiAgICAgICAgYWN0dWFsOiBjYXVnaHQgJiYgY2F1Z2h0LmVycm9yLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIGVycm9yOiAhcGFzc2VkICYmIGNhdWdodCAmJiBjYXVnaHQuZXJyb3IsXG4gICAgICAgIGV4dHJhOiBleHRyYVxuICAgIH0pO1xufTtcblxuVGVzdC5wcm90b3R5cGUuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gZG9lc05vdFRocm93KGZuLCBleHBlY3RlZCwgbXNnLCBleHRyYSkge1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1zZyA9IGV4cGVjdGVkO1xuICAgICAgICBleHBlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGNhdWdodDtcbiAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjYXVnaHQgPSB7IGVycm9yOiBlcnIgfTtcbiAgICB9XG4gICAgdGhpcy5fYXNzZXJ0KCFjYXVnaHQsIHtcbiAgICAgICAgbWVzc2FnZTogZGVmaW5lZChtc2csICdzaG91bGQgbm90IHRocm93JyksXG4gICAgICAgIG9wZXJhdG9yOiAndGhyb3dzJyxcbiAgICAgICAgYWN0dWFsOiBjYXVnaHQgJiYgY2F1Z2h0LmVycm9yLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIGVycm9yOiBjYXVnaHQgJiYgY2F1Z2h0LmVycm9yLFxuICAgICAgICBleHRyYTogZXh0cmFcbiAgICB9KTtcbn07XG5cblRlc3QucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2goc3RyaW5nLCByZWdleHAsIG1zZywgZXh0cmEpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHJlZ2V4cCkpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0KGZhbHNlLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBkZWZpbmVkKG1zZywgJ1RoZSBcInJlZ2V4cFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVnRXhwLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgcmVnZXhwICsgJyAoJyArIGluc3BlY3QocmVnZXhwKSArICcpJyksXG4gICAgICAgICAgICBvcGVyYXRvcjogJ21hdGNoJyxcbiAgICAgICAgICAgIGFjdHVhbDogb2JqZWN0VG9TdHJpbmcocmVnZXhwKSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYVxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydChmYWxzZSwge1xuICAgICAgICAgICAgbWVzc2FnZTogZGVmaW5lZChtc2csICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nICsgJyAoJyArIGluc3BlY3Qoc3RyaW5nKSArICcpJyksXG4gICAgICAgICAgICBvcGVyYXRvcjogJ21hdGNoJyxcbiAgICAgICAgICAgIGFjdHVhbDogc3RyaW5nID09PSBudWxsID8gbnVsbCA6IHR5cGVvZiBzdHJpbmcsXG4gICAgICAgICAgICBleHBlY3RlZDogJ3N0cmluZycsXG4gICAgICAgICAgICBleHRyYTogZXh0cmFcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAkZXhlYyhyZWdleHAsIHN0cmluZykgIT09IG51bGw7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZGVmaW5lZChcbiAgICAgICAgICAgIG1zZyxcbiAgICAgICAgICAgICdUaGUgaW5wdXQgJyArIChtYXRjaGVzID8gJ21hdGNoZWQnIDogJ2RpZCBub3QgbWF0Y2gnKSArICcgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAnICsgaW5zcGVjdChyZWdleHApICsgJy4gSW5wdXQ6ICcgKyBpbnNwZWN0KHN0cmluZylcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fYXNzZXJ0KG1hdGNoZXMsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBvcGVyYXRvcjogJ21hdGNoJyxcbiAgICAgICAgICAgIGFjdHVhbDogc3RyaW5nLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IHJlZ2V4cCxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5UZXN0LnByb3RvdHlwZS5kb2VzTm90TWF0Y2ggPSBmdW5jdGlvbiBkb2VzTm90TWF0Y2goc3RyaW5nLCByZWdleHAsIG1zZywgZXh0cmEpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHJlZ2V4cCkpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0KGZhbHNlLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiBkZWZpbmVkKG1zZywgJ1RoZSBcInJlZ2V4cFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVnRXhwLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgcmVnZXhwICsgJyAoJyArIGluc3BlY3QocmVnZXhwKSArICcpJyksXG4gICAgICAgICAgICBvcGVyYXRvcjogJ2RvZXNOb3RNYXRjaCcsXG4gICAgICAgICAgICBhY3R1YWw6IG9iamVjdFRvU3RyaW5nKHJlZ2V4cCksXG4gICAgICAgICAgICBleHBlY3RlZDogJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICAgICAgICBleHRyYTogZXh0cmFcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9hc3NlcnQoZmFsc2UsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmluZWQobXNnLCAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZyArICcgKCcgKyBpbnNwZWN0KHN0cmluZykgKyAnKScpLFxuICAgICAgICAgICAgb3BlcmF0b3I6ICdkb2VzTm90TWF0Y2gnLFxuICAgICAgICAgICAgYWN0dWFsOiBzdHJpbmcgPT09IG51bGwgPyBudWxsIDogdHlwZW9mIHN0cmluZyxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICRleGVjKHJlZ2V4cCwgc3RyaW5nKSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBkZWZpbmVkKFxuICAgICAgICAgICAgbXNnLFxuICAgICAgICAgICAgJ1RoZSBpbnB1dCAnICsgKG1hdGNoZXMgPyAnd2FzIGV4cGVjdGVkIHRvIG5vdCBtYXRjaCcgOiAnZGlkIG5vdCBtYXRjaCcpICsgJyB0aGUgcmVndWxhciBleHByZXNzaW9uICcgKyBpbnNwZWN0KHJlZ2V4cCkgKyAnLiBJbnB1dDogJyArIGluc3BlY3Qoc3RyaW5nKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9hc3NlcnQoIW1hdGNoZXMsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBvcGVyYXRvcjogJ2RvZXNOb3RNYXRjaCcsXG4gICAgICAgICAgICBhY3R1YWw6IHN0cmluZyxcbiAgICAgICAgICAgIGV4cGVjdGVkOiByZWdleHAsXG4gICAgICAgICAgICBleHRyYTogZXh0cmFcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5UZXN0LnNraXAgPSBmdW5jdGlvbiBza2lwKG5hbWVfLCBfb3B0cywgX2NiKSB7XG4gICAgdmFyIGFyZ3MgPSBnZXRUZXN0QXJncy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGFyZ3Mub3B0cy5za2lwID0gdHJ1ZTtcbiAgICByZXR1cm4gbmV3IFRlc3QoYXJncy5uYW1lLCBhcmdzLm9wdHMsIGFyZ3MuY2IpO1xufTtcblxuLy8gdmltOiBzZXQgc29mdHRhYnN0b3A9NCBzaGlmdHdpZHRoPTQ6XG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcblxuLy8gdGhyb3VnaFxuLy9cbi8vIGEgc3RyZWFtIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCByZS1lbWl0IHRoZSBpbnB1dC5cbi8vIHVzZWZ1bCBmb3IgYWdncmVnYXRpbmcgYSBzZXJpZXMgb2YgY2hhbmdpbmcgYnV0IG5vdCBlbmRpbmcgc3RyZWFtcyBpbnRvIG9uZSBzdHJlYW0pXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRocm91Z2hcbnRocm91Z2gudGhyb3VnaCA9IHRocm91Z2hcblxuLy9jcmVhdGUgYSByZWFkYWJsZSB3cml0YWJsZSBzdHJlYW0uXG5cbmZ1bmN0aW9uIHRocm91Z2ggKHdyaXRlLCBlbmQsIG9wdHMpIHtcbiAgd3JpdGUgPSB3cml0ZSB8fCBmdW5jdGlvbiAoZGF0YSkgeyB0aGlzLnF1ZXVlKGRhdGEpIH1cbiAgZW5kID0gZW5kIHx8IGZ1bmN0aW9uICgpIHsgdGhpcy5xdWV1ZShudWxsKSB9XG5cbiAgdmFyIGVuZGVkID0gZmFsc2UsIGRlc3Ryb3llZCA9IGZhbHNlLCBidWZmZXIgPSBbXSwgX2VuZGVkID0gZmFsc2VcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJlYW0oKVxuICBzdHJlYW0ucmVhZGFibGUgPSBzdHJlYW0ud3JpdGFibGUgPSB0cnVlXG4gIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuXG4vLyAgc3RyZWFtLmF1dG9QYXVzZSAgID0gIShvcHRzICYmIG9wdHMuYXV0b1BhdXNlICAgPT09IGZhbHNlKVxuICBzdHJlYW0uYXV0b0Rlc3Ryb3kgPSAhKG9wdHMgJiYgb3B0cy5hdXRvRGVzdHJveSA9PT0gZmFsc2UpXG5cbiAgc3RyZWFtLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB3cml0ZS5jYWxsKHRoaXMsIGRhdGEpXG4gICAgcmV0dXJuICFzdHJlYW0ucGF1c2VkXG4gIH1cblxuICBmdW5jdGlvbiBkcmFpbigpIHtcbiAgICB3aGlsZShidWZmZXIubGVuZ3RoICYmICFzdHJlYW0ucGF1c2VkKSB7XG4gICAgICB2YXIgZGF0YSA9IGJ1ZmZlci5zaGlmdCgpXG4gICAgICBpZihudWxsID09PSBkYXRhKVxuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2VuZCcpXG4gICAgICBlbHNlXG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICBzdHJlYW0ucXVldWUgPSBzdHJlYW0ucHVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4vLyAgICBjb25zb2xlLmVycm9yKGVuZGVkKVxuICAgIGlmKF9lbmRlZCkgcmV0dXJuIHN0cmVhbVxuICAgIGlmKGRhdGEgPT09IG51bGwpIF9lbmRlZCA9IHRydWVcbiAgICBidWZmZXIucHVzaChkYXRhKVxuICAgIGRyYWluKClcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICAvL3RoaXMgd2lsbCBiZSByZWdpc3RlcmVkIGFzIHRoZSBmaXJzdCAnZW5kJyBsaXN0ZW5lclxuICAvL211c3QgY2FsbCBkZXN0cm95IG5leHQgdGljaywgdG8gbWFrZSBzdXJlIHdlJ3JlIGFmdGVyIGFueVxuICAvL3N0cmVhbSBwaXBlZCBmcm9tIGhlcmUuXG4gIC8vdGhpcyBpcyBvbmx5IGEgcHJvYmxlbSBpZiBlbmQgaXMgbm90IGVtaXR0ZWQgc3luY2hyb25vdXNseS5cbiAgLy9hIG5pY2VyIHdheSB0byBkbyB0aGlzIGlzIHRvIG1ha2Ugc3VyZSB0aGlzIGlzIHRoZSBsYXN0IGxpc3RlbmVyIGZvciAnZW5kJ1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgaWYoIXN0cmVhbS53cml0YWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICAgICAgfSlcbiAgfSlcblxuICBmdW5jdGlvbiBfZW5kICgpIHtcbiAgICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZVxuICAgIGVuZC5jYWxsKHN0cmVhbSlcbiAgICBpZighc3RyZWFtLnJlYWRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgfVxuXG4gIHN0cmVhbS5lbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmKGVuZGVkKSByZXR1cm5cbiAgICBlbmRlZCA9IHRydWVcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoKSBzdHJlYW0ud3JpdGUoZGF0YSlcbiAgICBfZW5kKCkgLy8gd2lsbCBlbWl0IG9yIHF1ZXVlXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgc3RyZWFtLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoZGVzdHJveWVkKSByZXR1cm5cbiAgICBkZXN0cm95ZWQgPSB0cnVlXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgICBzdHJlYW0ud3JpdGFibGUgPSBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIHN0cmVhbS5lbWl0KCdjbG9zZScpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHJldHVyblxuICAgIHN0cmVhbS5wYXVzZWQgPSB0cnVlXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSB7XG4gICAgICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcbiAgICAgIHN0cmVhbS5lbWl0KCdyZXN1bWUnKVxuICAgIH1cbiAgICBkcmFpbigpXG4gICAgLy9tYXkgaGF2ZSBiZWNvbWUgcGF1c2VkIGFnYWluLFxuICAgIC8vYXMgZHJhaW4gZW1pdHMgJ2RhdGEnLlxuICAgIGlmKCFzdHJlYW0ucGF1c2VkKVxuICAgICAgc3RyZWFtLmVtaXQoJ2RyYWluJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJ2lzLXN0cmluZycpO1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnaXMtbnVtYmVyLW9iamVjdCcpO1xudmFyIGlzQm9vbGVhbiA9IHJlcXVpcmUoJ2lzLWJvb2xlYW4tb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcbnZhciBpc0JpZ0ludCA9IHJlcXVpcmUoJ2lzLWJpZ2ludCcpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICh2YWx1ZSA9PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG5cdFx0cmV0dXJuICdTdHJpbmcnO1xuXHR9XG5cdGlmIChpc051bWJlcih2YWx1ZSkpIHtcblx0XHRyZXR1cm4gJ051bWJlcic7XG5cdH1cblx0aWYgKGlzQm9vbGVhbih2YWx1ZSkpIHtcblx0XHRyZXR1cm4gJ0Jvb2xlYW4nO1xuXHR9XG5cdGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gJ1N5bWJvbCc7XG5cdH1cblx0aWYgKGlzQmlnSW50KHZhbHVlKSkge1xuXHRcdHJldHVybiAnQmlnSW50Jztcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWFwID0gcmVxdWlyZSgnaXMtbWFwJyk7XG52YXIgaXNTZXQgPSByZXF1aXJlKCdpcy1zZXQnKTtcbnZhciBpc1dlYWtNYXAgPSByZXF1aXJlKCdpcy13ZWFrbWFwJyk7XG52YXIgaXNXZWFrU2V0ID0gcmVxdWlyZSgnaXMtd2Vha3NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoQ29sbGVjdGlvbih2YWx1ZSkge1xuXHRpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdGlmIChpc01hcCh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiAnTWFwJztcblx0XHR9XG5cdFx0aWYgKGlzU2V0KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuICdTZXQnO1xuXHRcdH1cblx0XHRpZiAoaXNXZWFrTWFwKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuICdXZWFrTWFwJztcblx0XHR9XG5cdFx0aWYgKGlzV2Vha1NldCh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiAnV2Vha1NldCc7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kTmFtZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmROYW1lO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghaXNUeXBlZEFycmF5KHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuLi8nKTtcbnZhciB0ZXN0ID0gcmVxdWlyZSgndGFwZScpO1xudmFyIHJ1blRlc3RzID0gcmVxdWlyZSgnLi90ZXN0cycpO1xuXG50ZXN0KCdhcyBhIGZ1bmN0aW9uJywgZnVuY3Rpb24gKHQpIHtcblx0dC50ZXN0KCdiYWQgYXJyYXkvdGhpcyB2YWx1ZScsIGZ1bmN0aW9uIChzdCkge1xuXHRcdHN0Wyd0aHJvd3MnXShmdW5jdGlvbiAoKSB7IGFzc2lnbih1bmRlZmluZWQpOyB9LCBUeXBlRXJyb3IsICd1bmRlZmluZWQgaXMgbm90IGFuIG9iamVjdCcpO1xuXHRcdHN0Wyd0aHJvd3MnXShmdW5jdGlvbiAoKSB7IGFzc2lnbihudWxsKTsgfSwgVHlwZUVycm9yLCAnbnVsbCBpcyBub3QgYW4gb2JqZWN0Jyk7XG5cdFx0c3QuZW5kKCk7XG5cdH0pO1xuXG5cdHJ1blRlc3RzKGFzc2lnbiwgdCk7XG5cblx0dC5lbmQoKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJykoKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKTtcbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcbnZhciBtb2NrUHJvcGVydHkgPSByZXF1aXJlKCdtb2NrLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFzc2lnbiwgdCkge1xuXHR0LnRlc3QoJ2Vycm9yIGNhc2VzJywgZnVuY3Rpb24gKHN0KSB7XG5cdFx0c3RbJ3Rocm93cyddKGZ1bmN0aW9uICgpIHsgYXNzaWduKG51bGwpOyB9LCBUeXBlRXJyb3IsICd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTtcblx0XHRzdFsndGhyb3dzJ10oZnVuY3Rpb24gKCkgeyBhc3NpZ24odW5kZWZpbmVkKTsgfSwgVHlwZUVycm9yLCAndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cdFx0c3RbJ3Rocm93cyddKGZ1bmN0aW9uICgpIHsgYXNzaWduKG51bGwsIHt9KTsgfSwgVHlwZUVycm9yLCAndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cdFx0c3RbJ3Rocm93cyddKGZ1bmN0aW9uICgpIHsgYXNzaWduKHVuZGVmaW5lZCwge30pOyB9LCBUeXBlRXJyb3IsICd0YXJnZXQgbXVzdCBiZSBhbiBvYmplY3QnKTtcblx0XHRzdC5lbmQoKTtcblx0fSk7XG5cblx0dC50ZXN0KCdub24tb2JqZWN0IHRhcmdldCwgbm8gc291cmNlcycsIGZ1bmN0aW9uIChzdCkge1xuXHRcdHZhciBib29sID0gYXNzaWduKHRydWUpO1xuXHRcdHN0LmVxdWFsKHR5cGVvZiBib29sLCAnb2JqZWN0JywgJ2Jvb2wgaXMgb2JqZWN0Jyk7XG5cdFx0c3QuZXF1YWwoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGJvb2wpLCB0cnVlLCAnYm9vbCBjb2VyY2VzIHRvIGB0cnVlYCcpO1xuXG5cdFx0dmFyIG51bWJlciA9IGFzc2lnbigxKTtcblx0XHRzdC5lcXVhbCh0eXBlb2YgbnVtYmVyLCAnb2JqZWN0JywgJ251bWJlciBpcyBvYmplY3QnKTtcblx0XHRzdC5lcXVhbChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbChudW1iZXIpLCAxLCAnbnVtYmVyIGNvZXJjZXMgdG8gYDFgJyk7XG5cblx0XHR2YXIgc3RyaW5nID0gYXNzaWduKCcxJyk7XG5cdFx0c3QuZXF1YWwodHlwZW9mIHN0cmluZywgJ29iamVjdCcsICdudW1iZXIgaXMgb2JqZWN0Jyk7XG5cdFx0c3QuZXF1YWwoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoc3RyaW5nKSwgJzEnLCAnbnVtYmVyIGNvZXJjZXMgdG8gYFwiMVwiYCcpO1xuXG5cdFx0c3QuZW5kKCk7XG5cdH0pO1xuXG5cdHQudGVzdCgnbm9uLW9iamVjdCB0YXJnZXQsIHdpdGggc291cmNlcycsIGZ1bmN0aW9uIChzdCkge1xuXHRcdHZhciBzaWduYWwgPSB7fTtcblxuXHRcdHN0LnRlc3QoJ2Jvb2xlYW4nLCBmdW5jdGlvbiAoc3QyKSB7XG5cdFx0XHR2YXIgYm9vbCA9IGFzc2lnbih0cnVlLCB7IGE6IHNpZ25hbCB9KTtcblx0XHRcdHN0Mi5lcXVhbCh0eXBlb2YgYm9vbCwgJ29iamVjdCcsICdib29sIGlzIG9iamVjdCcpO1xuXHRcdFx0c3QyLmVxdWFsKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChib29sKSwgdHJ1ZSwgJ2Jvb2wgY29lcmNlcyB0byBgdHJ1ZWAnKTtcblx0XHRcdHN0Mi5lcXVhbChib29sLmEsIHNpZ25hbCwgJ3NvdXJjZSBwcm9wZXJ0aWVzIGNvcGllZCcpO1xuXHRcdFx0c3QyLmVuZCgpO1xuXHRcdH0pO1xuXG5cdFx0c3QudGVzdCgnbnVtYmVyJywgZnVuY3Rpb24gKHN0Mikge1xuXHRcdFx0dmFyIG51bWJlciA9IGFzc2lnbigxLCB7IGE6IHNpZ25hbCB9KTtcblx0XHRcdHN0Mi5lcXVhbCh0eXBlb2YgbnVtYmVyLCAnb2JqZWN0JywgJ251bWJlciBpcyBvYmplY3QnKTtcblx0XHRcdHN0Mi5lcXVhbChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbChudW1iZXIpLCAxLCAnbnVtYmVyIGNvZXJjZXMgdG8gYDFgJyk7XG5cdFx0XHRzdDIuZXF1YWwobnVtYmVyLmEsIHNpZ25hbCwgJ3NvdXJjZSBwcm9wZXJ0aWVzIGNvcGllZCcpO1xuXHRcdFx0c3QyLmVuZCgpO1xuXHRcdH0pO1xuXG5cdFx0c3QudGVzdCgnc3RyaW5nJywgZnVuY3Rpb24gKHN0Mikge1xuXHRcdFx0dmFyIHN0cmluZyA9IGFzc2lnbignMScsIHsgYTogc2lnbmFsIH0pO1xuXHRcdFx0c3QyLmVxdWFsKHR5cGVvZiBzdHJpbmcsICdvYmplY3QnLCAnbnVtYmVyIGlzIG9iamVjdCcpO1xuXHRcdFx0c3QyLmVxdWFsKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHN0cmluZyksICcxJywgJ251bWJlciBjb2VyY2VzIHRvIGBcIjFcImAnKTtcblx0XHRcdHN0Mi5lcXVhbChzdHJpbmcuYSwgc2lnbmFsLCAnc291cmNlIHByb3BlcnRpZXMgY29waWVkJyk7XG5cdFx0XHRzdDIuZW5kKCk7XG5cdFx0fSk7XG5cblx0XHRzdC5lbmQoKTtcblx0fSk7XG5cblx0dC50ZXN0KCdub24tb2JqZWN0IHNvdXJjZXMnLCBmdW5jdGlvbiAoc3QpIHtcblx0XHRzdC5kZWVwRXF1YWwoYXNzaWduKHsgYTogMSB9LCBudWxsLCB7IGI6IDIgfSksIHsgYTogMSwgYjogMiB9LCAnaWdub3JlcyBudWxsIHNvdXJjZScpO1xuXHRcdHN0LmRlZXBFcXVhbChhc3NpZ24oeyBhOiAxIH0sIHsgYjogMiB9LCB1bmRlZmluZWQpLCB7IGE6IDEsIGI6IDIgfSwgJ2lnbm9yZXMgdW5kZWZpbmVkIHNvdXJjZScpO1xuXHRcdHN0LmVuZCgpO1xuXHR9KTtcblxuXHR0LnRlc3QoJ3JldHVybnMgdGhlIG1vZGlmaWVkIHRhcmdldCBvYmplY3QnLCBmdW5jdGlvbiAoc3QpIHtcblx0XHR2YXIgdGFyZ2V0ID0ge307XG5cdFx0dmFyIHJldHVybmVkID0gYXNzaWduKHRhcmdldCwgeyBhOiAxIH0pO1xuXHRcdHN0LmVxdWFsKHJldHVybmVkLCB0YXJnZXQsICdyZXR1cm5lZCBvYmplY3QgaXMgdGhlIHNhbWUgcmVmZXJlbmNlIGFzIHRoZSB0YXJnZXQgb2JqZWN0Jyk7XG5cdFx0c3QuZW5kKCk7XG5cdH0pO1xuXG5cdHQudGVzdCgnaGFzIHRoZSByaWdodCBsZW5ndGgnLCBmdW5jdGlvbiAoc3QpIHtcblx0XHRzdC5lcXVhbChhc3NpZ24ubGVuZ3RoLCAyLCAnbGVuZ3RoIGlzIDIgPT4gMiByZXF1aXJlZCBhcmd1bWVudHMnKTtcblx0XHRzdC5lbmQoKTtcblx0fSk7XG5cblx0dC50ZXN0KCdtZXJnZSB0d28gb2JqZWN0cycsIGZ1bmN0aW9uIChzdCkge1xuXHRcdHZhciB0YXJnZXQgPSB7IGE6IDEgfTtcblx0XHR2YXIgcmV0dXJuZWQgPSBhc3NpZ24odGFyZ2V0LCB7IGI6IDIgfSk7XG5cdFx0c3QuZGVlcEVxdWFsKHJldHVybmVkLCB7IGE6IDEsIGI6IDIgfSwgJ3JldHVybmVkIG9iamVjdCBoYXMgcHJvcGVydGllcyBmcm9tIGJvdGgnKTtcblx0XHRzdC5lbmQoKTtcblx0fSk7XG5cblx0dC50ZXN0KCd3b3JrcyB3aXRoIGZ1bmN0aW9ucycsIGZ1bmN0aW9uIChzdCkge1xuXHRcdHZhciB0YXJnZXQgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHR0YXJnZXQuYSA9IDE7XG5cdFx0dmFyIHJldHVybmVkID0gYXNzaWduKHRhcmdldCwgeyBiOiAyIH0pO1xuXHRcdHN0LmVxdWFsKHRhcmdldCwgcmV0dXJuZWQsICdyZXR1cm5lZCBvYmplY3QgaXMgdGFyZ2V0Jyk7XG5cdFx0c3QuZXF1YWwocmV0dXJuZWQuYSwgMSk7XG5cdFx0c3QuZXF1YWwocmV0dXJuZWQuYiwgMik7XG5cdFx0c3QuZW5kKCk7XG5cdH0pO1xuXG5cdHQudGVzdCgnd29ya3Mgd2l0aCBwcmltaXRpdmVzJywgZnVuY3Rpb24gKHN0KSB7XG5cdFx0dmFyIHRhcmdldCA9IDI7XG5cdFx0dmFyIHNvdXJjZSA9IHsgYjogNDIgfTtcblx0XHR2YXIgcmV0dXJuZWQgPSBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpO1xuXHRcdHN0LmVxdWFsKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXR1cm5lZCksICdbb2JqZWN0IE51bWJlcl0nLCAncmV0dXJuZWQgaXMgb2JqZWN0IGZvcm0gb2YgbnVtYmVyIHByaW1pdGl2ZScpO1xuXHRcdHN0LmVxdWFsKE51bWJlcihyZXR1cm5lZCksIHRhcmdldCwgJ3JldHVybmVkIGFuZCB0YXJnZXQgaGF2ZSBzYW1lIHZhbHVlT2YnKTtcblx0XHRzdC5lcXVhbChyZXR1cm5lZC5iLCBzb3VyY2UuYik7XG5cdFx0c3QuZW5kKCk7XG5cdH0pO1xuXG5cdC8qIGdsb2JhbHMgd2luZG93ICovXG5cdHQudGVzdCgnd29ya3Mgd2l0aCB3aW5kb3cubG9jYXRpb24nLCB7IHNraXA6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIH0sIGZ1bmN0aW9uIChzdCkge1xuXHRcdHZhciB0YXJnZXQgPSB7fTtcblx0XHRhc3NpZ24odGFyZ2V0LCB3aW5kb3cubG9jYXRpb24pO1xuXHRcdGZvciAodmFyIHByb3AgaW4gd2luZG93LmxvY2F0aW9uKSB7XG5cdFx0XHRpZiAoaGFzKHdpbmRvdy5sb2NhdGlvbiwgcHJvcCkpIHtcblx0XHRcdFx0c3QuZGVlcEVxdWFsKHRhcmdldFtwcm9wXSwgd2luZG93LmxvY2F0aW9uW3Byb3BdLCBwcm9wICsgJyBpcyBjb3BpZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0c3QuZW5kKCk7XG5cdH0pO1xuXG5cdHQudGVzdCgnbWVyZ2UgTiBvYmplY3RzJywgZnVuY3Rpb24gKHN0KSB7XG5cdFx0dmFyIHRhcmdldCA9IHsgYTogMSB9O1xuXHRcdHZhciBzb3VyY2UxID0geyBiOiAyIH07XG5cdFx0dmFyIHNvdXJjZTIgPSB7IGM6IDMgfTtcblx0XHR2YXIgcmV0dXJuZWQgPSBhc3NpZ24odGFyZ2V0LCBzb3VyY2UxLCBzb3VyY2UyKTtcblx0XHRzdC5kZWVwRXF1YWwocmV0dXJuZWQsIHsgYTogMSwgYjogMiwgYzogMyB9LCAncmV0dXJuZWQgb2JqZWN0IGhhcyBwcm9wZXJ0aWVzIGZyb20gYWxsIHNvdXJjZXMnKTtcblx0XHRzdC5lbmQoKTtcblx0fSk7XG5cblx0dC50ZXN0KCdvbmx5IGl0ZXJhdGVzIG92ZXIgb3duIGtleXMnLCBmdW5jdGlvbiAoc3QpIHtcblx0XHR2YXIgRm9vID0gZnVuY3Rpb24gKCkge307XG5cdFx0Rm9vLnByb3RvdHlwZS5iYXIgPSB0cnVlO1xuXHRcdHZhciBmb28gPSBuZXcgRm9vKCk7XG5cdFx0Zm9vLmJheiA9IHRydWU7XG5cdFx0dmFyIHRhcmdldCA9IHsgYTogMSB9O1xuXHRcdHZhciByZXR1cm5lZCA9IGFzc2lnbih0YXJnZXQsIGZvbyk7XG5cdFx0c3QuZXF1YWwocmV0dXJuZWQsIHRhcmdldCwgJ3JldHVybmVkIG9iamVjdCBpcyB0aGUgc2FtZSByZWZlcmVuY2UgYXMgdGhlIHRhcmdldCBvYmplY3QnKTtcblx0XHRzdC5kZWVwRXF1YWwodGFyZ2V0LCB7IGE6IDEsIGJhejogdHJ1ZSB9LCAncmV0dXJuZWQgb2JqZWN0IGhhcyBvbmx5IG93biBwcm9wZXJ0aWVzIGZyb20gYm90aCcpO1xuXHRcdHN0LmVuZCgpO1xuXHR9KTtcblxuXHR0LnRlc3QoJ2luY2x1ZGVzIGVudW1lcmFibGUgc3ltYm9scywgYWZ0ZXIga2V5cycsIHsgc2tpcDogIWhhc1N5bWJvbHMgfSwgZnVuY3Rpb24gKHN0KSB7XG5cdFx0dmFyIHZpc2l0ZWQgPSBbXTtcblx0XHR2YXIgb2JqID0ge307XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ2EnLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyB2aXNpdGVkLnB1c2goJ2EnKTsgcmV0dXJuIDQyOyB9IH0pO1xuXHRcdHZhciBzeW1ib2wgPSBTeW1ib2woJ2VudW1lcmFibGUnKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBzeW1ib2wsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgdmlzaXRlZC5wdXNoKHN5bWJvbCk7IHJldHVybiBJbmZpbml0eTsgfVxuXHRcdH0pO1xuXHRcdHZhciBub25FbnVtU3ltYm9sID0gU3ltYm9sKCdub24tZW51bWVyYWJsZScpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5vbkVudW1TeW1ib2wsIHtcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHZpc2l0ZWQucHVzaChub25FbnVtU3ltYm9sKTsgcmV0dXJuIC1JbmZpbml0eTsgfVxuXHRcdH0pO1xuXHRcdHZhciB0YXJnZXQgPSBhc3NpZ24oe30sIG9iaik7XG5cdFx0c3QuZGVlcEVxdWFsKHZpc2l0ZWQsIFsnYScsIHN5bWJvbF0sICdrZXkgaXMgdmlzaXRlZCBmaXJzdCwgdGhlbiBzeW1ib2wnKTtcblx0XHRzdC5lcXVhbCh0YXJnZXQuYSwgNDIsICd0YXJnZXQuYSBpcyA0MicpO1xuXHRcdHN0LmVxdWFsKHRhcmdldFtzeW1ib2xdLCBJbmZpbml0eSwgJ3RhcmdldFtzeW1ib2xdIGlzIEluZmluaXR5Jyk7XG5cdFx0c3Qubm90RXF1YWwodGFyZ2V0W25vbkVudW1TeW1ib2xdLCAtSW5maW5pdHksICd0YXJnZXRbbm9uRW51bVN5bWJvbF0gaXMgbm90IC1JbmZpbml0eScpO1xuXHRcdHN0LmVuZCgpO1xuXHR9KTtcblxuXHR0LnRlc3QoJ2RvZXMgbm90IGZhaWwgd2hlbiBzeW1ib2xzIGFyZSBub3QgcHJlc2VudCcsIHsgc2tpcDogIU9iamVjdC5pc0Zyb3plbiB8fCBPYmplY3QuaXNGcm96ZW4oT2JqZWN0KSB9LCBmdW5jdGlvbiAoc3QpIHtcblx0XHRzdC50ZWFyZG93bihtb2NrUHJvcGVydHkoT2JqZWN0LCAnZ2V0T3duUHJvcGVydHlTeW1ib2xzJywgeyAnZGVsZXRlJzogdHJ1ZSB9KSk7XG5cblx0XHR2YXIgdmlzaXRlZCA9IFtdO1xuXHRcdHZhciBvYmogPSB7fTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnYScsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHZpc2l0ZWQucHVzaCgnYScpOyByZXR1cm4gNDI7IH0gfSk7XG5cdFx0dmFyIGtleXMgPSBbJ2EnXTtcblx0XHRpZiAoaGFzU3ltYm9scykge1xuXHRcdFx0dmFyIHN5bWJvbCA9IFN5bWJvbCgnc3ltJyk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBzeW1ib2wsIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHZpc2l0ZWQucHVzaChzeW1ib2wpOyByZXR1cm4gSW5maW5pdHk7IH1cblx0XHRcdH0pO1xuXHRcdFx0a2V5cy5wdXNoKHN5bWJvbCk7XG5cdFx0fVxuXHRcdHZhciB0YXJnZXQgPSBhc3NpZ24oe30sIG9iaik7XG5cdFx0c3QuZGVlcEVxdWFsKHZpc2l0ZWQsIGtleXMsICdhc3NpZ24gdmlzaXRzIGV4cGVjdGVkIGtleXMnKTtcblx0XHRzdC5lcXVhbCh0YXJnZXQuYSwgNDIsICd0YXJnZXQuYSBpcyA0MicpO1xuXG5cdFx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRcdHN0LmVxdWFsKHRhcmdldFtzeW1ib2xdLCBJbmZpbml0eSk7XG5cdFx0fVxuXHRcdHN0LmVuZCgpO1xuXHR9KTtcblxuXHR0LnRlc3QoJ3ByZXNlcnZlcyBjb3JyZWN0IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyJywgZnVuY3Rpb24gKHN0KSB7XG5cdFx0dmFyIHN0ciA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdFx0dmFyIGxldHRlcnMgPSB7fTtcblx0XHRmb3JFYWNoKHN0ci5zcGxpdCgnJyksIGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdGxldHRlcnNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblxuXHRcdHZhciBuID0gNTtcblx0XHRzdC5jb21tZW50KCdydW4gdGhlIG5leHQgdGVzdCAnICsgbiArICcgdGltZXMnKTtcblx0XHR2YXIgb2JqZWN0ID0gYXNzaWduKHt9LCBsZXR0ZXJzKTtcblx0XHR2YXIgYWN0dWFsID0gJyc7XG5cdFx0Zm9yICh2YXIgayBpbiBvYmplY3QpIHtcblx0XHRcdGFjdHVhbCArPSBrO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdFx0c3QuZXF1YWwoYWN0dWFsLCBzdHIsICdwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBzaG91bGQgYmUgZm9sbG93ZWQnKTtcblx0XHR9XG5cdFx0c3QuZW5kKCk7XG5cdH0pO1xuXG5cdHQudGVzdCgnY2hlY2tzIGVudW1lcmFiaWxpdHkgYW5kIGV4aXN0ZW5jZSwgaW4gY2FzZSBvZiBtb2RpZmljYXRpb24gZHVyaW5nIFtbR2V0XV0nLCB7IHNraXA6ICFPYmplY3QuZGVmaW5lUHJvcGVydHkgfSwgZnVuY3Rpb24gKHN0KSB7XG5cdFx0dmFyIHRhcmdldEJ2YWx1ZSA9IHt9O1xuXHRcdHZhciB0YXJnZXRDdmFsdWUgPSB7fTtcblx0XHR2YXIgdGFyZ2V0ID0geyBiOiB0YXJnZXRCdmFsdWUsIGM6IHRhcmdldEN2YWx1ZSB9O1xuXHRcdHZhciBzb3VyY2UgPSB7fTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc291cmNlLCAnYScsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuYjtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjJywgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcblx0XHRcdFx0cmV0dXJuICdhJztcblx0XHRcdH1cblx0XHR9KTtcblx0XHR2YXIgc291cmNlQnZhbHVlID0ge307XG5cdFx0dmFyIHNvdXJjZUN2YWx1ZSA9IHt9O1xuXHRcdHNvdXJjZS5iID0gc291cmNlQnZhbHVlO1xuXHRcdHNvdXJjZS5jID0gc291cmNlQ3ZhbHVlO1xuXHRcdHZhciByZXN1bHQgPSBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpO1xuXHRcdHN0LmVxdWFsKHJlc3VsdCwgdGFyZ2V0LCAnc2FuaXR5IGNoZWNrOiByZXN1bHQgaXMgPT09IHRhcmdldCcpO1xuXHRcdHN0LmVxdWFsKHJlc3VsdC5iLCB0YXJnZXRCdmFsdWUsICd0YXJnZXQga2V5IG5vdCBvdmVyd3JpdHRlbiBieSBkZWxldGVkIHNvdXJjZSBrZXknKTtcblx0XHRzdC5lcXVhbChyZXN1bHQuYywgdGFyZ2V0Q3ZhbHVlLCAndGFyZ2V0IGtleSBub3Qgb3ZlcndyaXR0ZW4gYnkgbm9uLWVudW1lcmFibGUgc291cmNlIGtleScpO1xuXG5cdFx0c3QuZW5kKCk7XG5cdH0pO1xufTtcbiJdfQ==</span>
<span class="s0">&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre>
</body>
</html>
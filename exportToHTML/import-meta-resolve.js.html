<html>
<head>
<title>import-meta-resolve.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #4646f1;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
import-meta-resolve.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.moduleResolve = moduleResolve;</span>
<span class="s1">exports.resolve = resolve;</span>
<span class="s2">function </span><span class="s1">_assert() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;assert&quot;</span><span class="s1">);</span>
  <span class="s1">_assert = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_fs() {</span>
  <span class="s1">const data = _interopRequireWildcard(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">), </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">_fs = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_process() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;process&quot;</span><span class="s1">);</span>
  <span class="s1">_process = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_url() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;url&quot;</span><span class="s1">);</span>
  <span class="s1">_url = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_path() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
  <span class="s1">_path = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_module() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;module&quot;</span><span class="s1">);</span>
  <span class="s1">_module = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_v() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;v8&quot;</span><span class="s1">);</span>
  <span class="s1">_v = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_util() {</span>
  <span class="s1">const data = require(</span><span class="s0">&quot;util&quot;</span><span class="s1">);</span>
  <span class="s1">_util = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) { </span><span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">; </span><span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap(); </span><span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap(); </span><span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) { </span><span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) { </span><span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) { </span><span class="s2">return </span><span class="s1">obj; } </span><span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj }; } </span><span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop); </span><span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s2">return </span><span class="s1">cache.get(obj); } </span><span class="s2">var </span><span class="s1">newObj = {}; </span><span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) { </span><span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) { </span><span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } </span><span class="s2">else </span><span class="s1">{ newObj[key] = obj[key]; } } } newObj.</span><span class="s2">default </span><span class="s1">= obj; </span><span class="s2">if </span><span class="s1">(cache) { cache.set(obj, newObj); } </span><span class="s2">return </span><span class="s1">newObj; }</span>
<span class="s1">const isWindows = _process().platform === </span><span class="s0">'win32'</span><span class="s1">;</span>
<span class="s1">const own$1 = {}.hasOwnProperty;</span>
<span class="s1">const classRegExp = /^([A-Z][a-z\d]*)+$/;</span>
<span class="s1">const kTypes = </span><span class="s2">new </span><span class="s1">Set([</span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'function'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'object'</span><span class="s1">, </span><span class="s0">'Function'</span><span class="s1">, </span><span class="s0">'Object'</span><span class="s1">, </span><span class="s0">'boolean'</span><span class="s1">, </span><span class="s0">'bigint'</span><span class="s1">, </span><span class="s0">'symbol'</span><span class="s1">]);</span>
<span class="s1">const codes = {};</span>
<span class="s2">function </span><span class="s1">formatList(array, type = </span><span class="s0">'and'</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s1">array.length &lt; </span><span class="s3">3 </span><span class="s1">? array.join(` ${type} `) : `${array.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">).join(</span><span class="s0">', '</span><span class="s1">)}, ${type} ${array[array.length - </span><span class="s3">1</span><span class="s1">]}`;</span>
<span class="s1">}</span>
<span class="s1">const messages = </span><span class="s2">new </span><span class="s1">Map();</span>
<span class="s1">const nodeInternalPrefix = </span><span class="s0">'__node_internal_'</span><span class="s1">;</span>
<span class="s1">let userStackTraceLimit;</span>
<span class="s1">codes.ERR_INVALID_ARG_TYPE = createError(</span><span class="s0">'ERR_INVALID_ARG_TYPE'</span><span class="s1">, (name, expected, actual) =&gt; {</span>
  <span class="s1">_assert()(</span><span class="s2">typeof </span><span class="s1">name === </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">&quot;'name' must be a string&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(!Array.isArray(expected)) {</span>
    <span class="s1">expected = [expected];</span>
  <span class="s1">}</span>
  <span class="s1">let message = </span><span class="s0">'The '</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(name.endsWith(</span><span class="s0">' argument'</span><span class="s1">)) {</span>
    <span class="s1">message += `${name} `;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">const type = name.includes(</span><span class="s0">'.'</span><span class="s1">) ? </span><span class="s0">'property' </span><span class="s1">: </span><span class="s0">'argument'</span><span class="s1">;</span>
    <span class="s1">message += `</span><span class="s0">&quot;${name}&quot; </span><span class="s1">${type} `;</span>
  <span class="s1">}</span>
  <span class="s1">message += </span><span class="s0">'must be '</span><span class="s1">;</span>
  <span class="s1">const types = [];</span>
  <span class="s1">const instances = [];</span>
  <span class="s1">const other = [];</span>
  <span class="s2">for </span><span class="s1">(const value of expected) {</span>
    <span class="s1">_assert()(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'All expected entries have to be of type string'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(kTypes.has(value)) {</span>
      <span class="s1">types.push(value.toLowerCase());</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(classRegExp.exec(value) === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">_assert()(value !== </span><span class="s0">'object'</span><span class="s1">, </span><span class="s0">'The value &quot;object&quot; should be written as &quot;Object&quot;'</span><span class="s1">);</span>
      <span class="s1">other.push(value);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">instances.push(value);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(instances.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">const pos = types.indexOf(</span><span class="s0">'object'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(pos !== -</span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s1">types.slice(pos, </span><span class="s3">1</span><span class="s1">);</span>
      <span class="s1">instances.push(</span><span class="s0">'Object'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(types.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">message += `${types.length &gt; </span><span class="s3">1 </span><span class="s1">? </span><span class="s0">'one of type' </span><span class="s1">: </span><span class="s0">'of type'</span><span class="s1">} ${formatList(types, </span><span class="s0">'or'</span><span class="s1">)}`;</span>
    <span class="s2">if </span><span class="s1">(instances.length &gt; </span><span class="s3">0 </span><span class="s1">|| other.length &gt; </span><span class="s3">0</span><span class="s1">) message += </span><span class="s0">' or '</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(instances.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">message += `an instance of ${formatList(instances, </span><span class="s0">'or'</span><span class="s1">)}`;</span>
    <span class="s2">if </span><span class="s1">(other.length &gt; </span><span class="s3">0</span><span class="s1">) message += </span><span class="s0">' or '</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(other.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(other.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s1">message += `one of ${formatList(other, </span><span class="s0">'or'</span><span class="s1">)}`;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(other[</span><span class="s3">0</span><span class="s1">].toLowerCase() !== other[</span><span class="s3">0</span><span class="s1">]) message += </span><span class="s0">'an '</span><span class="s1">;</span>
      <span class="s1">message += `${other[</span><span class="s3">0</span><span class="s1">]}`;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">message += `. Received ${determineSpecificType(actual)}`;</span>
  <span class="s2">return </span><span class="s1">message;</span>
<span class="s1">}, TypeError);</span>
<span class="s1">codes.ERR_INVALID_MODULE_SPECIFIER = createError(</span><span class="s0">'ERR_INVALID_MODULE_SPECIFIER'</span><span class="s1">, (request, reason, base = undefined) =&gt; {</span>
  <span class="s2">return </span><span class="s1">`Invalid module </span><span class="s0">&quot;${request}&quot; </span><span class="s1">${reason}${base ? ` imported from ${base}` : </span><span class="s0">''</span><span class="s1">}`;</span>
<span class="s1">}, TypeError);</span>
<span class="s1">codes.ERR_INVALID_PACKAGE_CONFIG = createError(</span><span class="s0">'ERR_INVALID_PACKAGE_CONFIG'</span><span class="s1">, (path, base, message) =&gt; {</span>
  <span class="s2">return </span><span class="s1">`Invalid package config ${path}${base ? ` </span><span class="s2">while </span><span class="s1">importing ${base}` : </span><span class="s0">''</span><span class="s1">}${message ? `. ${message}` : </span><span class="s0">''</span><span class="s1">}`;</span>
<span class="s1">}, Error);</span>
<span class="s1">codes.ERR_INVALID_PACKAGE_TARGET = createError(</span><span class="s0">'ERR_INVALID_PACKAGE_TARGET'</span><span class="s1">, (pkgPath, key, target, isImport = </span><span class="s2">false</span><span class="s1">, base = undefined) =&gt; {</span>
  <span class="s1">const relError = </span><span class="s2">typeof </span><span class="s1">target === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; !isImport &amp;&amp; target.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; !target.startsWith(</span><span class="s0">'./'</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(key === </span><span class="s0">'.'</span><span class="s1">) {</span>
    <span class="s1">_assert()(isImport === </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">`Invalid </span><span class="s0">&quot;exports&quot; </span><span class="s1">main target ${JSON.stringify(target)} defined ` + `</span><span class="s2">in </span><span class="s1">the package config ${pkgPath}package.json${base ? ` imported from ${base}` : </span><span class="s0">''</span><span class="s1">}${relError ? </span><span class="s0">'; targets must start with &quot;./&quot;' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}`;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">`Invalid </span><span class="s0">&quot;${isImport ? 'imports' : 'exports'}&quot; </span><span class="s1">target ${JSON.stringify(target)} defined </span><span class="s2">for </span><span class="s0">'${key}' </span><span class="s2">in </span><span class="s1">the package config ${pkgPath}package.json${base ? ` imported from ${base}` : </span><span class="s0">''</span><span class="s1">}${relError ? </span><span class="s0">'; targets must start with &quot;./&quot;' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}`;</span>
<span class="s1">}, Error);</span>
<span class="s1">codes.ERR_MODULE_NOT_FOUND = createError(</span><span class="s0">'ERR_MODULE_NOT_FOUND'</span><span class="s1">, (path, base, type = </span><span class="s0">'package'</span><span class="s1">) =&gt; {</span>
  <span class="s2">return </span><span class="s1">`Cannot find ${type} </span><span class="s0">'${path}' </span><span class="s1">imported from ${base}`;</span>
<span class="s1">}, Error);</span>
<span class="s1">codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(</span><span class="s0">'ERR_NETWORK_IMPORT_DISALLOWED'</span><span class="s1">, </span><span class="s0">&quot;import of '%s' by %s is not supported: %s&quot;</span><span class="s1">, Error);</span>
<span class="s1">codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(</span><span class="s0">'ERR_PACKAGE_IMPORT_NOT_DEFINED'</span><span class="s1">, (specifier, packagePath, base) =&gt; {</span>
  <span class="s2">return </span><span class="s1">`Package import specifier </span><span class="s0">&quot;${specifier}&quot; </span><span class="s1">is not defined${packagePath ? ` </span><span class="s2">in </span><span class="s1">package ${packagePath}package.json` : </span><span class="s0">''</span><span class="s1">} imported from ${base}`;</span>
<span class="s1">}, TypeError);</span>
<span class="s1">codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(</span><span class="s0">'ERR_PACKAGE_PATH_NOT_EXPORTED'</span><span class="s1">, (pkgPath, subpath, base = undefined) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(subpath === </span><span class="s0">'.'</span><span class="s1">) </span><span class="s2">return </span><span class="s1">`No </span><span class="s0">&quot;exports&quot; </span><span class="s1">main defined </span><span class="s2">in </span><span class="s1">${pkgPath}package.json${base ? ` imported from ${base}` : </span><span class="s0">''</span><span class="s1">}`;</span>
  <span class="s2">return </span><span class="s1">`Package subpath </span><span class="s0">'${subpath}' </span><span class="s1">is not defined by </span><span class="s0">&quot;exports&quot; </span><span class="s2">in </span><span class="s1">${pkgPath}package.json${base ? ` imported from ${base}` : </span><span class="s0">''</span><span class="s1">}`;</span>
<span class="s1">}, Error);</span>
<span class="s1">codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(</span><span class="s0">'ERR_UNSUPPORTED_DIR_IMPORT'</span><span class="s1">, </span><span class="s0">&quot;Directory import '%s' is not supported &quot; </span><span class="s1">+ </span><span class="s0">'resolving ES modules imported from %s'</span><span class="s1">, Error);</span>
<span class="s1">codes.ERR_UNKNOWN_FILE_EXTENSION = createError(</span><span class="s0">'ERR_UNKNOWN_FILE_EXTENSION'</span><span class="s1">, (ext, path) =&gt; {</span>
  <span class="s2">return </span><span class="s1">`Unknown file extension </span><span class="s0">&quot;${ext}&quot; </span><span class="s2">for </span><span class="s1">${path}`;</span>
<span class="s1">}, TypeError);</span>
<span class="s1">codes.ERR_INVALID_ARG_VALUE = createError(</span><span class="s0">'ERR_INVALID_ARG_VALUE'</span><span class="s1">, (name, value, reason = </span><span class="s0">'is invalid'</span><span class="s1">) =&gt; {</span>
  <span class="s1">let inspected = (</span><span class="s3">0</span><span class="s1">, _util().inspect)(value);</span>
  <span class="s2">if </span><span class="s1">(inspected.length &gt; </span><span class="s3">128</span><span class="s1">) {</span>
    <span class="s1">inspected = `${inspected.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">128</span><span class="s1">)}...`;</span>
  <span class="s1">}</span>
  <span class="s1">const type = name.includes(</span><span class="s0">'.'</span><span class="s1">) ? </span><span class="s0">'property' </span><span class="s1">: </span><span class="s0">'argument'</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">`The ${type} </span><span class="s0">'${name}' </span><span class="s1">${reason}. Received ${inspected}`;</span>
<span class="s1">}, TypeError);</span>
<span class="s1">codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError(</span><span class="s0">'ERR_UNSUPPORTED_ESM_URL_SCHEME'</span><span class="s1">, (url, supported) =&gt; {</span>
  <span class="s1">let message = `Only URLs </span><span class="s2">with </span><span class="s1">a scheme </span><span class="s2">in</span><span class="s1">: ${formatList(supported)} are supported by the </span><span class="s2">default </span><span class="s1">ESM loader`;</span>
  <span class="s2">if </span><span class="s1">(isWindows &amp;&amp; url.protocol.length === </span><span class="s3">2</span><span class="s1">) {</span>
    <span class="s1">message += </span><span class="s0">'. On Windows, absolute paths must be valid file:// URLs'</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">message += `. Received protocol </span><span class="s0">'${url.protocol}'</span><span class="s1">`;</span>
  <span class="s2">return </span><span class="s1">message;</span>
<span class="s1">}, Error);</span>
<span class="s2">function </span><span class="s1">createError(sym, value, def) {</span>
  <span class="s1">messages.set(sym, value);</span>
  <span class="s2">return </span><span class="s1">makeNodeErrorWithCode(def, sym);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeNodeErrorWithCode(Base, key) {</span>
  <span class="s2">return </span><span class="s1">NodeError;</span>
  <span class="s2">function </span><span class="s1">NodeError(...args) {</span>
    <span class="s1">const limit = Error.stackTraceLimit;</span>
    <span class="s2">if </span><span class="s1">(isErrorStackTraceLimitWritable()) Error.stackTraceLimit = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">const error = </span><span class="s2">new </span><span class="s1">Base();</span>
    <span class="s2">if </span><span class="s1">(isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;</span>
    <span class="s1">const message = getMessage(key, args, error);</span>
    <span class="s1">Object.defineProperties(error, {</span>
      <span class="s1">message: {</span>
        <span class="s1">value: message,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
      <span class="s1">},</span>
      <span class="s1">toString: {</span>
        <span class="s1">value() {</span>
          <span class="s2">return </span><span class="s1">`${</span><span class="s2">this</span><span class="s1">.name} [${key}]: ${</span><span class="s2">this</span><span class="s1">.message}`;</span>
        <span class="s1">},</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">captureLargerStackTrace(error);</span>
    <span class="s1">error.code = key;</span>
    <span class="s2">return </span><span class="s1">error;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isErrorStackTraceLimitWritable() {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(_v().startupSnapshot.isBuildingSnapshot()) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_unused) {}</span>
  <span class="s1">const desc = Object.getOwnPropertyDescriptor(Error, </span><span class="s0">'stackTraceLimit'</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(desc === undefined) {</span>
    <span class="s2">return </span><span class="s1">Object.isExtensible(Error);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">own$1.call(desc, </span><span class="s0">'writable'</span><span class="s1">) &amp;&amp; desc.writable !== undefined ? desc.writable : desc.set !== undefined;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hideStackFrames(fn) {</span>
  <span class="s1">const hidden = nodeInternalPrefix + fn.name;</span>
  <span class="s1">Object.defineProperty(fn, </span><span class="s0">'name'</span><span class="s1">, {</span>
    <span class="s1">value: hidden</span>
  <span class="s1">});</span>
  <span class="s2">return </span><span class="s1">fn;</span>
<span class="s1">}</span>
<span class="s1">const captureLargerStackTrace = hideStackFrames(</span><span class="s2">function </span><span class="s1">(error) {</span>
  <span class="s1">const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();</span>
  <span class="s2">if </span><span class="s1">(stackTraceLimitIsWritable) {</span>
    <span class="s1">userStackTraceLimit = Error.stackTraceLimit;</span>
    <span class="s1">Error.stackTraceLimit = Number.POSITIVE_INFINITY;</span>
  <span class="s1">}</span>
  <span class="s1">Error.captureStackTrace(error);</span>
  <span class="s2">if </span><span class="s1">(stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;</span>
  <span class="s2">return </span><span class="s1">error;</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">getMessage(key, args, self) {</span>
  <span class="s1">const message = messages.get(key);</span>
  <span class="s1">_assert()(message !== undefined, </span><span class="s0">'expected `message` to be found'</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">message === </span><span class="s0">'function'</span><span class="s1">) {</span>
    <span class="s1">_assert()(message.length &lt;= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${message.length}).`);</span>
    <span class="s2">return </span><span class="s1">Reflect.apply(message, self, args);</span>
  <span class="s1">}</span>
  <span class="s1">const regex = /%[dfijoOs]/g;</span>
  <span class="s1">let expectedLength = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(regex.exec(message) !== </span><span class="s2">null</span><span class="s1">) expectedLength++;</span>
  <span class="s1">_assert()(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);</span>
  <span class="s2">if </span><span class="s1">(args.length === </span><span class="s3">0</span><span class="s1">) </span><span class="s2">return </span><span class="s1">message;</span>
  <span class="s1">args.unshift(message);</span>
  <span class="s2">return </span><span class="s1">Reflect.apply(_util().format, </span><span class="s2">null</span><span class="s1">, args);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">determineSpecificType(value) {</span>
  <span class="s2">if </span><span class="s1">(value === </span><span class="s2">null </span><span class="s1">|| value === undefined) {</span>
    <span class="s2">return </span><span class="s1">String(value);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'function' </span><span class="s1">&amp;&amp; value.name) {</span>
    <span class="s2">return </span><span class="s1">`</span><span class="s2">function </span><span class="s1">${value.name}`;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'object'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(value.constructor &amp;&amp; value.constructor.name) {</span>
      <span class="s2">return </span><span class="s1">`an instance of ${value.constructor.name}`;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">`${(</span><span class="s3">0</span><span class="s1">, _util().inspect)(value, {</span>
      <span class="s1">depth: -</span><span class="s3">1</span>
    <span class="s1">})}`;</span>
  <span class="s1">}</span>
  <span class="s1">let inspected = (</span><span class="s3">0</span><span class="s1">, _util().inspect)(value, {</span>
    <span class="s1">colors: </span><span class="s2">false</span>
  <span class="s1">});</span>
  <span class="s2">if </span><span class="s1">(inspected.length &gt; </span><span class="s3">28</span><span class="s1">) {</span>
    <span class="s1">inspected = `${inspected.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">25</span><span class="s1">)}...`;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">`type ${</span><span class="s2">typeof </span><span class="s1">value} (${inspected})`;</span>
<span class="s1">}</span>
<span class="s1">const reader = {</span>
  <span class="s1">read</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">packageJsonReader = reader;</span>
<span class="s2">function </span><span class="s1">read(jsonPath) {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">const string = _fs().</span><span class="s2">default</span><span class="s1">.readFileSync(_path().toNamespacedPath(_path().join(_path().dirname(jsonPath), </span><span class="s0">'package.json'</span><span class="s1">)), </span><span class="s0">'utf8'</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">string</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
    <span class="s1">const exception = error;</span>
    <span class="s2">if </span><span class="s1">(exception.code === </span><span class="s0">'ENOENT'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">string: undefined</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">throw </span><span class="s1">exception;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">const {</span>
  <span class="s1">ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1</span>
<span class="s1">} = codes;</span>
<span class="s1">const packageJsonCache = </span><span class="s2">new </span><span class="s1">Map();</span>
<span class="s2">function </span><span class="s1">getPackageConfig(path, specifier, base) {</span>
  <span class="s1">const existing = packageJsonCache.get(path);</span>
  <span class="s2">if </span><span class="s1">(existing !== undefined) {</span>
    <span class="s2">return </span><span class="s1">existing;</span>
  <span class="s1">}</span>
  <span class="s1">const source = packageJsonReader.read(path).string;</span>
  <span class="s2">if </span><span class="s1">(source === undefined) {</span>
    <span class="s1">const packageConfig = {</span>
      <span class="s1">pjsonPath: path,</span>
      <span class="s1">exists: </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">main: undefined,</span>
      <span class="s1">name: undefined,</span>
      <span class="s1">type: </span><span class="s0">'none'</span><span class="s1">,</span>
      <span class="s1">exports: undefined,</span>
      <span class="s1">imports: undefined</span>
    <span class="s1">};</span>
    <span class="s1">packageJsonCache.set(path, packageConfig);</span>
    <span class="s2">return </span><span class="s1">packageConfig;</span>
  <span class="s1">}</span>
  <span class="s1">let packageJson;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">packageJson = JSON.parse(source);</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
    <span class="s1">const exception = error;</span>
    <span class="s2">throw new </span><span class="s1">ERR_INVALID_PACKAGE_CONFIG$1(path, (base ? `</span><span class="s0">&quot;${specifier}&quot; </span><span class="s1">from ` : </span><span class="s0">''</span><span class="s1">) + (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base || specifier), exception.message);</span>
  <span class="s1">}</span>
  <span class="s1">const {</span>
    <span class="s1">exports,</span>
    <span class="s1">imports,</span>
    <span class="s1">main,</span>
    <span class="s1">name,</span>
    <span class="s1">type</span>
  <span class="s1">} = packageJson;</span>
  <span class="s1">const packageConfig = {</span>
    <span class="s1">pjsonPath: path,</span>
    <span class="s1">exists: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">main: </span><span class="s2">typeof </span><span class="s1">main === </span><span class="s0">'string' </span><span class="s1">? main : undefined,</span>
    <span class="s1">name: </span><span class="s2">typeof </span><span class="s1">name === </span><span class="s0">'string' </span><span class="s1">? name : undefined,</span>
    <span class="s1">type: type === </span><span class="s0">'module' </span><span class="s1">|| type === </span><span class="s0">'commonjs' </span><span class="s1">? type : </span><span class="s0">'none'</span><span class="s1">,</span>
    <span class="s1">exports,</span>
    <span class="s1">imports: imports &amp;&amp; </span><span class="s2">typeof </span><span class="s1">imports === </span><span class="s0">'object' </span><span class="s1">? imports : undefined</span>
  <span class="s1">};</span>
  <span class="s1">packageJsonCache.set(path, packageConfig);</span>
  <span class="s2">return </span><span class="s1">packageConfig;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPackageScopeConfig(resolved) {</span>
  <span class="s1">let packageJsonUrl = </span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'package.json'</span><span class="s1">, resolved);</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">const packageJsonPath = packageJsonUrl.pathname;</span>
    <span class="s2">if </span><span class="s1">(packageJsonPath.endsWith(</span><span class="s0">'node_modules/package.json'</span><span class="s1">)) </span><span class="s2">break</span><span class="s1">;</span>
    <span class="s1">const packageConfig = getPackageConfig((</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(packageJsonUrl), resolved);</span>
    <span class="s2">if </span><span class="s1">(packageConfig.exists) </span><span class="s2">return </span><span class="s1">packageConfig;</span>
    <span class="s1">const lastPackageJsonUrl = packageJsonUrl;</span>
    <span class="s1">packageJsonUrl = </span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'../package.json'</span><span class="s1">, packageJsonUrl);</span>
    <span class="s2">if </span><span class="s1">(packageJsonUrl.pathname === lastPackageJsonUrl.pathname) </span><span class="s2">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">const packageJsonPath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(packageJsonUrl);</span>
  <span class="s1">const packageConfig = {</span>
    <span class="s1">pjsonPath: packageJsonPath,</span>
    <span class="s1">exists: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">main: undefined,</span>
    <span class="s1">name: undefined,</span>
    <span class="s1">type: </span><span class="s0">'none'</span><span class="s1">,</span>
    <span class="s1">exports: undefined,</span>
    <span class="s1">imports: undefined</span>
  <span class="s1">};</span>
  <span class="s1">packageJsonCache.set(packageJsonPath, packageConfig);</span>
  <span class="s2">return </span><span class="s1">packageConfig;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPackageType(url) {</span>
  <span class="s1">const packageConfig = getPackageScopeConfig(url);</span>
  <span class="s2">return </span><span class="s1">packageConfig.type;</span>
<span class="s1">}</span>
<span class="s1">const {</span>
  <span class="s1">ERR_UNKNOWN_FILE_EXTENSION</span>
<span class="s1">} = codes;</span>
<span class="s1">const hasOwnProperty = {}.hasOwnProperty;</span>
<span class="s1">const extensionFormatMap = {</span>
  <span class="s1">__proto__: </span><span class="s2">null</span><span class="s1">,</span>
  <span class="s0">'.cjs'</span><span class="s1">: </span><span class="s0">'commonjs'</span><span class="s1">,</span>
  <span class="s0">'.js'</span><span class="s1">: </span><span class="s0">'module'</span><span class="s1">,</span>
  <span class="s0">'.json'</span><span class="s1">: </span><span class="s0">'json'</span><span class="s1">,</span>
  <span class="s0">'.mjs'</span><span class="s1">: </span><span class="s0">'module'</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">mimeToFormat(mime) {</span>
  <span class="s2">if </span><span class="s1">(mime &amp;&amp; /\s*(text|application)\/javascript\s*(;\s*charset=utf-?</span><span class="s3">8</span><span class="s1">\s*)?/i.test(mime)) </span><span class="s2">return </span><span class="s0">'module'</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(mime === </span><span class="s0">'application/json'</span><span class="s1">) </span><span class="s2">return </span><span class="s0">'json'</span><span class="s1">;</span>
  <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">const protocolHandlers = {</span>
  <span class="s1">__proto__: </span><span class="s2">null</span><span class="s1">,</span>
  <span class="s0">'data:'</span><span class="s1">: getDataProtocolModuleFormat,</span>
  <span class="s0">'file:'</span><span class="s1">: getFileProtocolModuleFormat,</span>
  <span class="s0">'http:'</span><span class="s1">: getHttpProtocolModuleFormat,</span>
  <span class="s0">'https:'</span><span class="s1">: getHttpProtocolModuleFormat,</span>
  <span class="s0">'node:'</span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s0">'builtin'</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">getDataProtocolModuleFormat(parsed) {</span>
  <span class="s1">const {</span>
    <span class="s3">1</span><span class="s1">: mime</span>
  <span class="s1">} = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [</span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">];</span>
  <span class="s2">return </span><span class="s1">mimeToFormat(mime);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">extname(url) {</span>
  <span class="s1">const pathname = url.pathname;</span>
  <span class="s1">let index = pathname.length;</span>
  <span class="s2">while </span><span class="s1">(index--) {</span>
    <span class="s1">const code = pathname.codePointAt(index);</span>
    <span class="s2">if </span><span class="s1">(code === </span><span class="s3">47</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(code === </span><span class="s3">46</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">pathname.codePointAt(index - </span><span class="s3">1</span><span class="s1">) === </span><span class="s3">47 </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: pathname.slice(index);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getFileProtocolModuleFormat(url, _context, ignoreErrors) {</span>
  <span class="s1">const ext = extname(url);</span>
  <span class="s2">if </span><span class="s1">(ext === </span><span class="s0">'.js'</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">getPackageType(url) === </span><span class="s0">'module' </span><span class="s1">? </span><span class="s0">'module' </span><span class="s1">: </span><span class="s0">'commonjs'</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">const format = extensionFormatMap[ext];</span>
  <span class="s2">if </span><span class="s1">(format) </span><span class="s2">return </span><span class="s1">format;</span>
  <span class="s2">if </span><span class="s1">(ignoreErrors) {</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>
  <span class="s1">const filepath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(url);</span>
  <span class="s2">throw new </span><span class="s1">ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getHttpProtocolModuleFormat() {}</span>
<span class="s2">function </span><span class="s1">defaultGetFormatWithoutErrors(url, context) {</span>
  <span class="s2">if </span><span class="s1">(!hasOwnProperty.call(protocolHandlers, url.protocol)) {</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">protocolHandlers[url.protocol](url, context, </span><span class="s2">true</span><span class="s1">) || </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">const {</span>
  <span class="s1">ERR_INVALID_ARG_VALUE</span>
<span class="s1">} = codes;</span>
<span class="s1">const DEFAULT_CONDITIONS = Object.freeze([</span><span class="s0">'node'</span><span class="s1">, </span><span class="s0">'import'</span><span class="s1">]);</span>
<span class="s1">const DEFAULT_CONDITIONS_SET = </span><span class="s2">new </span><span class="s1">Set(DEFAULT_CONDITIONS);</span>
<span class="s2">function </span><span class="s1">getDefaultConditions() {</span>
  <span class="s2">return </span><span class="s1">DEFAULT_CONDITIONS;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getDefaultConditionsSet() {</span>
  <span class="s2">return </span><span class="s1">DEFAULT_CONDITIONS_SET;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getConditionsSet(conditions) {</span>
  <span class="s2">if </span><span class="s1">(conditions !== undefined &amp;&amp; conditions !== getDefaultConditions()) {</span>
    <span class="s2">if </span><span class="s1">(!Array.isArray(conditions)) {</span>
      <span class="s2">throw new </span><span class="s1">ERR_INVALID_ARG_VALUE(</span><span class="s0">'conditions'</span><span class="s1">, conditions, </span><span class="s0">'expected an array'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return new </span><span class="s1">Set(conditions);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">getDefaultConditionsSet();</span>
<span class="s1">}</span>
<span class="s1">const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];</span>
<span class="s1">const experimentalNetworkImports = </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">const {</span>
  <span class="s1">ERR_NETWORK_IMPORT_DISALLOWED,</span>
  <span class="s1">ERR_INVALID_MODULE_SPECIFIER,</span>
  <span class="s1">ERR_INVALID_PACKAGE_CONFIG,</span>
  <span class="s1">ERR_INVALID_PACKAGE_TARGET,</span>
  <span class="s1">ERR_MODULE_NOT_FOUND,</span>
  <span class="s1">ERR_PACKAGE_IMPORT_NOT_DEFINED,</span>
  <span class="s1">ERR_PACKAGE_PATH_NOT_EXPORTED,</span>
  <span class="s1">ERR_UNSUPPORTED_DIR_IMPORT,</span>
  <span class="s1">ERR_UNSUPPORTED_ESM_URL_SCHEME</span>
<span class="s1">} = codes;</span>
<span class="s1">const own = {}.hasOwnProperty;</span>
<span class="s1">const invalidSegmentRegEx = /(^|\\|\/)((\.|%</span><span class="s3">2</span><span class="s1">e)(\.|%</span><span class="s3">2</span><span class="s1">e)?|(n|%</span><span class="s3">6</span><span class="s1">e|%</span><span class="s3">4</span><span class="s1">e)(o|%</span><span class="s3">6</span><span class="s1">f|%</span><span class="s3">4</span><span class="s1">f)(d|%</span><span class="s3">64</span><span class="s1">|%</span><span class="s3">44</span><span class="s1">)(e|%</span><span class="s3">65</span><span class="s1">|%</span><span class="s3">45</span><span class="s1">)(_|%</span><span class="s3">5</span><span class="s1">f)(m|%</span><span class="s3">6</span><span class="s1">d|%</span><span class="s3">4</span><span class="s1">d)(o|%</span><span class="s3">6</span><span class="s1">f|%</span><span class="s3">4</span><span class="s1">f)(d|%</span><span class="s3">64</span><span class="s1">|%</span><span class="s3">44</span><span class="s1">)(u|%</span><span class="s3">75</span><span class="s1">|%</span><span class="s3">55</span><span class="s1">)(l|%</span><span class="s3">6</span><span class="s1">c|%</span><span class="s3">4</span><span class="s1">c)(e|%</span><span class="s3">65</span><span class="s1">|%</span><span class="s3">45</span><span class="s1">)(s|%</span><span class="s3">73</span><span class="s1">|%</span><span class="s3">53</span><span class="s1">))?(\\|\/|$)/i;</span>
<span class="s1">const deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%</span><span class="s3">2</span><span class="s1">e)(\.|%</span><span class="s3">2</span><span class="s1">e)?|(n|%</span><span class="s3">6</span><span class="s1">e|%</span><span class="s3">4</span><span class="s1">e)(o|%</span><span class="s3">6</span><span class="s1">f|%</span><span class="s3">4</span><span class="s1">f)(d|%</span><span class="s3">64</span><span class="s1">|%</span><span class="s3">44</span><span class="s1">)(e|%</span><span class="s3">65</span><span class="s1">|%</span><span class="s3">45</span><span class="s1">)(_|%</span><span class="s3">5</span><span class="s1">f)(m|%</span><span class="s3">6</span><span class="s1">d|%</span><span class="s3">4</span><span class="s1">d)(o|%</span><span class="s3">6</span><span class="s1">f|%</span><span class="s3">4</span><span class="s1">f)(d|%</span><span class="s3">64</span><span class="s1">|%</span><span class="s3">44</span><span class="s1">)(u|%</span><span class="s3">75</span><span class="s1">|%</span><span class="s3">55</span><span class="s1">)(l|%</span><span class="s3">6</span><span class="s1">c|%</span><span class="s3">4</span><span class="s1">c)(e|%</span><span class="s3">65</span><span class="s1">|%</span><span class="s3">45</span><span class="s1">)(s|%</span><span class="s3">73</span><span class="s1">|%</span><span class="s3">53</span><span class="s1">))(\\|\/|$)/i;</span>
<span class="s1">const invalidPackageNameRegEx = /^\.|%|\\/;</span>
<span class="s1">const patternRegEx = /\*/g;</span>
<span class="s1">const encodedSepRegEx = /%</span><span class="s3">2</span><span class="s1">f|%</span><span class="s3">5</span><span class="s1">c/i;</span>
<span class="s1">const emittedPackageWarnings = </span><span class="s2">new </span><span class="s1">Set();</span>
<span class="s1">const doubleSlashRegEx = /[/\\]{</span><span class="s3">2</span><span class="s1">}/;</span>
<span class="s2">function </span><span class="s1">emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {</span>
  <span class="s1">const pjsonPath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(packageJsonUrl);</span>
  <span class="s1">const double = doubleSlashRegEx.exec(isTarget ? target : request) !== </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">_process().emitWarning(`Use of deprecated ${double ? </span><span class="s0">'double slash' </span><span class="s1">: </span><span class="s0">'leading or trailing slash matching'</span><span class="s1">} resolving </span><span class="s0">&quot;${target}&quot; </span><span class="s2">for </span><span class="s1">module ` + `request </span><span class="s0">&quot;${request}&quot; </span><span class="s1">${request === match ? </span><span class="s0">'' </span><span class="s1">: `matched to </span><span class="s0">&quot;${match}&quot; </span><span class="s1">`}</span><span class="s2">in </span><span class="s1">the </span><span class="s0">&quot;${internal ? 'imports' : 'exports'}&quot; </span><span class="s1">field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base)}` : </span><span class="s0">''</span><span class="s1">}.`, </span><span class="s0">'DeprecationWarning'</span><span class="s1">, </span><span class="s0">'DEP0166'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {</span>
  <span class="s1">const format = defaultGetFormatWithoutErrors(url, {</span>
    <span class="s1">parentURL: base.href</span>
  <span class="s1">});</span>
  <span class="s2">if </span><span class="s1">(format !== </span><span class="s0">'module'</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
  <span class="s1">const path = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(url.href);</span>
  <span class="s1">const pkgPath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(</span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'.'</span><span class="s1">, packageJsonUrl));</span>
  <span class="s1">const basePath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base);</span>
  <span class="s2">if </span><span class="s1">(main) _process().emitWarning(`Package ${pkgPath} has a </span><span class="s0">&quot;main&quot; </span><span class="s1">field set to ${JSON.stringify(main)}, ` + `excluding the full filename and extension to the resolved file at </span><span class="s0">&quot;${path.slice(pkgPath.length)}&quot;</span><span class="s1">, imported from ${basePath}.\n Automatic extension resolution of the </span><span class="s0">&quot;main&quot; </span><span class="s1">field is` + </span><span class="s0">'deprecated for ES modules.'</span><span class="s1">, </span><span class="s0">'DeprecationWarning'</span><span class="s1">, </span><span class="s0">'DEP0151'</span><span class="s1">);</span><span class="s2">else </span><span class="s1">_process().emitWarning(`No </span><span class="s0">&quot;main&quot; </span><span class="s1">or </span><span class="s0">&quot;exports&quot; </span><span class="s1">field defined </span><span class="s2">in </span><span class="s1">the package.json </span><span class="s2">for </span><span class="s1">${pkgPath} resolving the main entry point </span><span class="s0">&quot;${path.slice(pkgPath.length)}&quot;</span><span class="s1">, imported from ${basePath}.\nDefault </span><span class="s0">&quot;index&quot; </span><span class="s1">lookups </span><span class="s2">for </span><span class="s1">the main are deprecated </span><span class="s2">for </span><span class="s1">ES modules.`, </span><span class="s0">'DeprecationWarning'</span><span class="s1">, </span><span class="s0">'DEP0151'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">tryStatSync(path) {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _fs().statSync)(path);</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_unused2) {</span>
    <span class="s2">return new </span><span class="s1">(_fs().Stats)();</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">fileExists(url) {</span>
  <span class="s1">const stats = (</span><span class="s3">0</span><span class="s1">, _fs().statSync)(url, {</span>
    <span class="s1">throwIfNoEntry: </span><span class="s2">false</span>
  <span class="s1">});</span>
  <span class="s1">const isFile = stats ? stats.isFile() : undefined;</span>
  <span class="s2">return </span><span class="s1">isFile === </span><span class="s2">null </span><span class="s1">|| isFile === undefined ? </span><span class="s2">false </span><span class="s1">: isFile;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">legacyMainResolve(packageJsonUrl, packageConfig, base) {</span>
  <span class="s1">let guess;</span>
  <span class="s2">if </span><span class="s1">(packageConfig.main !== undefined) {</span>
    <span class="s1">guess = </span><span class="s2">new </span><span class="s1">(_url().URL)(packageConfig.main, packageJsonUrl);</span>
    <span class="s2">if </span><span class="s1">(fileExists(guess)) </span><span class="s2">return </span><span class="s1">guess;</span>
    <span class="s1">const tries = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];</span>
    <span class="s1">let i = -</span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(++i &lt; tries.length) {</span>
      <span class="s1">guess = </span><span class="s2">new </span><span class="s1">(_url().URL)(tries[i], packageJsonUrl);</span>
      <span class="s2">if </span><span class="s1">(fileExists(guess)) </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s1">guess = undefined;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(guess) {</span>
      <span class="s1">emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);</span>
      <span class="s2">return </span><span class="s1">guess;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const tries = [</span><span class="s0">'./index.js'</span><span class="s1">, </span><span class="s0">'./index.json'</span><span class="s1">, </span><span class="s0">'./index.node'</span><span class="s1">];</span>
  <span class="s1">let i = -</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(++i &lt; tries.length) {</span>
    <span class="s1">guess = </span><span class="s2">new </span><span class="s1">(_url().URL)(tries[i], packageJsonUrl);</span>
    <span class="s2">if </span><span class="s1">(fileExists(guess)) </span><span class="s2">break</span><span class="s1">;</span>
    <span class="s1">guess = undefined;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(guess) {</span>
    <span class="s1">emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);</span>
    <span class="s2">return </span><span class="s1">guess;</span>
  <span class="s1">}</span>
  <span class="s2">throw new </span><span class="s1">ERR_MODULE_NOT_FOUND((</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(</span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'.'</span><span class="s1">, packageJsonUrl)), (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">finalizeResolution(resolved, base, preserveSymlinks) {</span>
  <span class="s2">if </span><span class="s1">(encodedSepRegEx.exec(resolved.pathname) !== </span><span class="s2">null</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, </span><span class="s0">'must not include encoded &quot;/&quot; or &quot;</span><span class="s4">\\</span><span class="s0">&quot; characters'</span><span class="s1">, (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
  <span class="s1">const filePath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(resolved);</span>
  <span class="s1">const stats = tryStatSync(filePath.endsWith(</span><span class="s0">'/'</span><span class="s1">) ? filePath.slice(-</span><span class="s3">1</span><span class="s1">) : filePath);</span>
  <span class="s2">if </span><span class="s1">(stats.isDirectory()) {</span>
    <span class="s1">const error = </span><span class="s2">new </span><span class="s1">ERR_UNSUPPORTED_DIR_IMPORT(filePath, (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
    <span class="s1">error.url = String(resolved);</span>
    <span class="s2">throw </span><span class="s1">error;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!stats.isFile()) {</span>
    <span class="s2">throw new </span><span class="s1">ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base), </span><span class="s0">'module'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!preserveSymlinks) {</span>
    <span class="s1">const real = (</span><span class="s3">0</span><span class="s1">, _fs().realpathSync)(filePath);</span>
    <span class="s1">const {</span>
      <span class="s1">search,</span>
      <span class="s1">hash</span>
    <span class="s1">} = resolved;</span>
    <span class="s1">resolved = (</span><span class="s3">0</span><span class="s1">, _url().pathToFileURL)(real + (filePath.endsWith(_path().sep) ? </span><span class="s0">'/' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">));</span>
    <span class="s1">resolved.search = search;</span>
    <span class="s1">resolved.hash = hash;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">resolved;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">importNotDefined(specifier, packageJsonUrl, base) {</span>
  <span class="s2">return new </span><span class="s1">ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(</span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'.'</span><span class="s1">, packageJsonUrl)), (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">exportsNotFound(subpath, packageJsonUrl, base) {</span>
  <span class="s2">return new </span><span class="s1">ERR_PACKAGE_PATH_NOT_EXPORTED((</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(</span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'.'</span><span class="s1">, packageJsonUrl)), subpath, base &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {</span>
  <span class="s1">const reason = `request is not a valid match </span><span class="s2">in </span><span class="s1">pattern </span><span class="s0">&quot;${match}&quot; </span><span class="s2">for </span><span class="s1">the </span><span class="s0">&quot;${internal ? 'imports' : 'exports'}&quot; </span><span class="s1">resolution of ${(</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(packageJsonUrl)}`;</span>
  <span class="s2">throw new </span><span class="s1">ERR_INVALID_MODULE_SPECIFIER(request, reason, base &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {</span>
  <span class="s1">target = </span><span class="s2">typeof </span><span class="s1">target === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; target !== </span><span class="s2">null </span><span class="s1">? JSON.stringify(target, </span><span class="s2">null</span><span class="s1">, </span><span class="s0">''</span><span class="s1">) : `${target}`;</span>
  <span class="s2">return new </span><span class="s1">ERR_INVALID_PACKAGE_TARGET((</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(</span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'.'</span><span class="s1">, packageJsonUrl)), subpath, target, internal, base &amp;&amp; (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {</span>
  <span class="s2">if </span><span class="s1">(subpath !== </span><span class="s0">'' </span><span class="s1">&amp;&amp; !pattern &amp;&amp; target[target.length - </span><span class="s3">1</span><span class="s1">] !== </span><span class="s0">'/'</span><span class="s1">) </span><span class="s2">throw </span><span class="s1">invalidPackageTarget(match, target, packageJsonUrl, internal, base);</span>
  <span class="s2">if </span><span class="s1">(!target.startsWith(</span><span class="s0">'./'</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(internal &amp;&amp; !target.startsWith(</span><span class="s0">'../'</span><span class="s1">) &amp;&amp; !target.startsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
      <span class="s1">let isURL = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">new </span><span class="s1">(_url().URL)(target);</span>
        <span class="s1">isURL = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_unused3) {}</span>
      <span class="s2">if </span><span class="s1">(!isURL) {</span>
        <span class="s1">const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () =&gt; subpath) : target + subpath;</span>
        <span class="s2">return </span><span class="s1">packageResolve(exportTarget, packageJsonUrl, conditions);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">throw </span><span class="s1">invalidPackageTarget(match, target, packageJsonUrl, internal, base);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(invalidSegmentRegEx.exec(target.slice(</span><span class="s3">2</span><span class="s1">)) !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(deprecatedInvalidSegmentRegEx.exec(target.slice(</span><span class="s3">2</span><span class="s1">)) === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!isPathMap) {</span>
        <span class="s1">const request = pattern ? match.replace(</span><span class="s0">'*'</span><span class="s1">, () =&gt; subpath) : match + subpath;</span>
        <span class="s1">const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () =&gt; subpath) : target;</span>
        <span class="s1">emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw </span><span class="s1">invalidPackageTarget(match, target, packageJsonUrl, internal, base);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const resolved = </span><span class="s2">new </span><span class="s1">(_url().URL)(target, packageJsonUrl);</span>
  <span class="s1">const resolvedPath = resolved.pathname;</span>
  <span class="s1">const packagePath = </span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'.'</span><span class="s1">, packageJsonUrl).pathname;</span>
  <span class="s2">if </span><span class="s1">(!resolvedPath.startsWith(packagePath)) </span><span class="s2">throw </span><span class="s1">invalidPackageTarget(match, target, packageJsonUrl, internal, base);</span>
  <span class="s2">if </span><span class="s1">(subpath === </span><span class="s0">''</span><span class="s1">) </span><span class="s2">return </span><span class="s1">resolved;</span>
  <span class="s2">if </span><span class="s1">(invalidSegmentRegEx.exec(subpath) !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">const request = pattern ? match.replace(</span><span class="s0">'*'</span><span class="s1">, () =&gt; subpath) : match + subpath;</span>
    <span class="s2">if </span><span class="s1">(deprecatedInvalidSegmentRegEx.exec(subpath) === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!isPathMap) {</span>
        <span class="s1">const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () =&gt; subpath) : target;</span>
        <span class="s1">emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">throwInvalidSubpath(request, match, packageJsonUrl, internal, base);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(pattern) {</span>
    <span class="s2">return new </span><span class="s1">(_url().URL)(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () =&gt; subpath));</span>
  <span class="s1">}</span>
  <span class="s2">return new </span><span class="s1">(_url().URL)(subpath, resolved);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isArrayIndex(key) {</span>
  <span class="s1">const keyNumber = Number(key);</span>
  <span class="s2">if </span><span class="s1">(`${keyNumber}` !== key) </span><span class="s2">return false</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">keyNumber &gt;= </span><span class="s3">0 </span><span class="s1">&amp;&amp; keyNumber &lt; </span><span class="s3">0</span><span class="s1">xffffffff;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">target === </span><span class="s0">'string'</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(target)) {</span>
    <span class="s1">const targetList = target;</span>
    <span class="s2">if </span><span class="s1">(targetList.length === </span><span class="s3">0</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">let lastException;</span>
    <span class="s1">let i = -</span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(++i &lt; targetList.length) {</span>
      <span class="s1">const targetItem = targetList[i];</span>
      <span class="s1">let resolveResult;</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
        <span class="s1">const exception = error;</span>
        <span class="s1">lastException = exception;</span>
        <span class="s2">if </span><span class="s1">(exception.code === </span><span class="s0">'ERR_INVALID_PACKAGE_TARGET'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">throw </span><span class="s1">error;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(resolveResult === undefined) </span><span class="s2">continue</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(resolveResult === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">lastException = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">resolveResult;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(lastException === undefined || lastException === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">throw </span><span class="s1">lastException;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">target === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; target !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">const keys = Object.getOwnPropertyNames(target);</span>
    <span class="s1">let i = -</span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(++i &lt; keys.length) {</span>
      <span class="s1">const key = keys[i];</span>
      <span class="s2">if </span><span class="s1">(isArrayIndex(key)) {</span>
        <span class="s2">throw new </span><span class="s1">ERR_INVALID_PACKAGE_CONFIG((</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(packageJsonUrl), base, </span><span class="s0">'&quot;exports&quot; cannot contain numeric property keys.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">i = -</span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(++i &lt; keys.length) {</span>
      <span class="s1">const key = keys[i];</span>
      <span class="s2">if </span><span class="s1">(key === </span><span class="s0">'default' </span><span class="s1">|| conditions &amp;&amp; conditions.has(key)) {</span>
        <span class="s1">const conditionalTarget = target[key];</span>
        <span class="s1">const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);</span>
        <span class="s2">if </span><span class="s1">(resolveResult === undefined) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">resolveResult;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(target === </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">return null</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">throw </span><span class="s1">invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isConditionalExportsMainSugar(exports, packageJsonUrl, base) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">exports === </span><span class="s0">'string' </span><span class="s1">|| Array.isArray(exports)) </span><span class="s2">return true</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">exports !== </span><span class="s0">'object' </span><span class="s1">|| exports === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">const keys = Object.getOwnPropertyNames(exports);</span>
  <span class="s1">let isConditionalSugar = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">let i = </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">let j = -</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(++j &lt; keys.length) {</span>
    <span class="s1">const key = keys[j];</span>
    <span class="s1">const curIsConditionalSugar = key === </span><span class="s0">'' </span><span class="s1">|| key[</span><span class="s3">0</span><span class="s1">] !== </span><span class="s0">'.'</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(i++ === </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s1">isConditionalSugar = curIsConditionalSugar;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isConditionalSugar !== curIsConditionalSugar) {</span>
      <span class="s2">throw new </span><span class="s1">ERR_INVALID_PACKAGE_CONFIG((</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(packageJsonUrl), base, </span><span class="s0">'&quot;exports&quot; cannot contain some keys starting with </span><span class="s4">\'</span><span class="s0">.</span><span class="s4">\' </span><span class="s0">and some not.' </span><span class="s1">+ </span><span class="s0">' The exports object must either be an object of package subpath keys' </span><span class="s1">+ </span><span class="s0">' or an object of main entry condition name keys only.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">isConditionalSugar;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {</span>
  <span class="s1">const pjsonPath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(pjsonUrl);</span>
  <span class="s2">if </span><span class="s1">(emittedPackageWarnings.has(pjsonPath + </span><span class="s0">'|' </span><span class="s1">+ match)) </span><span class="s2">return</span><span class="s1">;</span>
  <span class="s1">emittedPackageWarnings.add(pjsonPath + </span><span class="s0">'|' </span><span class="s1">+ match);</span>
  <span class="s1">_process().emitWarning(`Use of deprecated trailing slash pattern mapping </span><span class="s0">&quot;${match}&quot; </span><span class="s2">in </span><span class="s1">the ` + `</span><span class="s0">&quot;exports&quot; </span><span class="s1">field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base)}` : </span><span class="s0">''</span><span class="s1">}. Mapping specifiers ending </span><span class="s2">in </span><span class="s0">&quot;/&quot; </span><span class="s1">is no longer supported.`, </span><span class="s0">'DeprecationWarning'</span><span class="s1">, </span><span class="s0">'DEP0155'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {</span>
  <span class="s1">let exports = packageConfig.exports;</span>
  <span class="s2">if </span><span class="s1">(isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {</span>
    <span class="s1">exports = {</span>
      <span class="s0">'.'</span><span class="s1">: exports</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(own.call(exports, packageSubpath) &amp;&amp; !packageSubpath.includes(</span><span class="s0">'*'</span><span class="s1">) &amp;&amp; !packageSubpath.endsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
    <span class="s1">const target = exports[packageSubpath];</span>
    <span class="s1">const resolveResult = resolvePackageTarget(packageJsonUrl, target, </span><span class="s0">''</span><span class="s1">, packageSubpath, base, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, conditions);</span>
    <span class="s2">if </span><span class="s1">(resolveResult === </span><span class="s2">null </span><span class="s1">|| resolveResult === undefined) {</span>
      <span class="s2">throw </span><span class="s1">exportsNotFound(packageSubpath, packageJsonUrl, base);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolveResult;</span>
  <span class="s1">}</span>
  <span class="s1">let bestMatch = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s1">let bestMatchSubpath = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s1">const keys = Object.getOwnPropertyNames(exports);</span>
  <span class="s1">let i = -</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">while </span><span class="s1">(++i &lt; keys.length) {</span>
    <span class="s1">const key = keys[i];</span>
    <span class="s1">const patternIndex = key.indexOf(</span><span class="s0">'*'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(patternIndex !== -</span><span class="s3">1 </span><span class="s1">&amp;&amp; packageSubpath.startsWith(key.slice(</span><span class="s3">0</span><span class="s1">, patternIndex))) {</span>
      <span class="s2">if </span><span class="s1">(packageSubpath.endsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
        <span class="s1">emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);</span>
      <span class="s1">}</span>
      <span class="s1">const patternTrailer = key.slice(patternIndex + </span><span class="s3">1</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(packageSubpath.length &gt;= key.length &amp;&amp; packageSubpath.endsWith(patternTrailer) &amp;&amp; patternKeyCompare(bestMatch, key) === </span><span class="s3">1 </span><span class="s1">&amp;&amp; key.lastIndexOf(</span><span class="s0">'*'</span><span class="s1">) === patternIndex) {</span>
        <span class="s1">bestMatch = key;</span>
        <span class="s1">bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(bestMatch) {</span>
    <span class="s1">const target = exports[bestMatch];</span>
    <span class="s1">const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, packageSubpath.endsWith(</span><span class="s0">'/'</span><span class="s1">), conditions);</span>
    <span class="s2">if </span><span class="s1">(resolveResult === </span><span class="s2">null </span><span class="s1">|| resolveResult === undefined) {</span>
      <span class="s2">throw </span><span class="s1">exportsNotFound(packageSubpath, packageJsonUrl, base);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolveResult;</span>
  <span class="s1">}</span>
  <span class="s2">throw </span><span class="s1">exportsNotFound(packageSubpath, packageJsonUrl, base);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patternKeyCompare(a, b) {</span>
  <span class="s1">const aPatternIndex = a.indexOf(</span><span class="s0">'*'</span><span class="s1">);</span>
  <span class="s1">const bPatternIndex = b.indexOf(</span><span class="s0">'*'</span><span class="s1">);</span>
  <span class="s1">const baseLengthA = aPatternIndex === -</span><span class="s3">1 </span><span class="s1">? a.length : aPatternIndex + </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s1">const baseLengthB = bPatternIndex === -</span><span class="s3">1 </span><span class="s1">? b.length : bPatternIndex + </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(baseLengthA &gt; baseLengthB) </span><span class="s2">return </span><span class="s1">-</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(baseLengthB &gt; baseLengthA) </span><span class="s2">return </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(aPatternIndex === -</span><span class="s3">1</span><span class="s1">) </span><span class="s2">return </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(bPatternIndex === -</span><span class="s3">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">-</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(a.length &gt; b.length) </span><span class="s2">return </span><span class="s1">-</span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(b.length &gt; a.length) </span><span class="s2">return </span><span class="s3">1</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">packageImportsResolve(name, base, conditions) {</span>
  <span class="s2">if </span><span class="s1">(name === </span><span class="s0">'#' </span><span class="s1">|| name.startsWith(</span><span class="s0">'#/'</span><span class="s1">) || name.endsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
    <span class="s1">const reason = </span><span class="s0">'is not a valid internal imports specifier name'</span><span class="s1">;</span>
    <span class="s2">throw new </span><span class="s1">ERR_INVALID_MODULE_SPECIFIER(name, reason, (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
  <span class="s1">}</span>
  <span class="s1">let packageJsonUrl;</span>
  <span class="s1">const packageConfig = getPackageScopeConfig(base);</span>
  <span class="s2">if </span><span class="s1">(packageConfig.exists) {</span>
    <span class="s1">packageJsonUrl = (</span><span class="s3">0</span><span class="s1">, _url().pathToFileURL)(packageConfig.pjsonPath);</span>
    <span class="s1">const imports = packageConfig.imports;</span>
    <span class="s2">if </span><span class="s1">(imports) {</span>
      <span class="s2">if </span><span class="s1">(own.call(imports, name) &amp;&amp; !name.includes(</span><span class="s0">'*'</span><span class="s1">)) {</span>
        <span class="s1">const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], </span><span class="s0">''</span><span class="s1">, name, base, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, conditions);</span>
        <span class="s2">if </span><span class="s1">(resolveResult !== </span><span class="s2">null </span><span class="s1">&amp;&amp; resolveResult !== undefined) {</span>
          <span class="s2">return </span><span class="s1">resolveResult;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">let bestMatch = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s1">let bestMatchSubpath = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s1">const keys = Object.getOwnPropertyNames(imports);</span>
        <span class="s1">let i = -</span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">while </span><span class="s1">(++i &lt; keys.length) {</span>
          <span class="s1">const key = keys[i];</span>
          <span class="s1">const patternIndex = key.indexOf(</span><span class="s0">'*'</span><span class="s1">);</span>
          <span class="s2">if </span><span class="s1">(patternIndex !== -</span><span class="s3">1 </span><span class="s1">&amp;&amp; name.startsWith(key.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">))) {</span>
            <span class="s1">const patternTrailer = key.slice(patternIndex + </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(name.length &gt;= key.length &amp;&amp; name.endsWith(patternTrailer) &amp;&amp; patternKeyCompare(bestMatch, key) === </span><span class="s3">1 </span><span class="s1">&amp;&amp; key.lastIndexOf(</span><span class="s0">'*'</span><span class="s1">) === patternIndex) {</span>
              <span class="s1">bestMatch = key;</span>
              <span class="s1">bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(bestMatch) {</span>
          <span class="s1">const target = imports[bestMatch];</span>
          <span class="s1">const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, conditions);</span>
          <span class="s2">if </span><span class="s1">(resolveResult !== </span><span class="s2">null </span><span class="s1">&amp;&amp; resolveResult !== undefined) {</span>
            <span class="s2">return </span><span class="s1">resolveResult;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">throw </span><span class="s1">importNotDefined(name, packageJsonUrl, base);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parsePackageName(specifier, base) {</span>
  <span class="s1">let separatorIndex = specifier.indexOf(</span><span class="s0">'/'</span><span class="s1">);</span>
  <span class="s1">let validPackageName = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">let isScoped = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(specifier[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'@'</span><span class="s1">) {</span>
    <span class="s1">isScoped = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(separatorIndex === -</span><span class="s3">1 </span><span class="s1">|| specifier.length === </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s1">validPackageName = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">separatorIndex = specifier.indexOf(</span><span class="s0">'/'</span><span class="s1">, separatorIndex + </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">const packageName = separatorIndex === -</span><span class="s3">1 </span><span class="s1">? specifier : specifier.slice(</span><span class="s3">0</span><span class="s1">, separatorIndex);</span>
  <span class="s2">if </span><span class="s1">(invalidPackageNameRegEx.exec(packageName) !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">validPackageName = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!validPackageName) {</span>
    <span class="s2">throw new </span><span class="s1">ERR_INVALID_MODULE_SPECIFIER(specifier, </span><span class="s0">'is not a valid package name'</span><span class="s1">, (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
  <span class="s1">}</span>
  <span class="s1">const packageSubpath = </span><span class="s0">'.' </span><span class="s1">+ (separatorIndex === -</span><span class="s3">1 </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: specifier.slice(separatorIndex));</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">packageName,</span>
    <span class="s1">packageSubpath,</span>
    <span class="s1">isScoped</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">packageResolve(specifier, base, conditions) {</span>
  <span class="s2">if </span><span class="s1">(_module().builtinModules.includes(specifier)) {</span>
    <span class="s2">return new </span><span class="s1">(_url().URL)(</span><span class="s0">'node:' </span><span class="s1">+ specifier);</span>
  <span class="s1">}</span>
  <span class="s1">const {</span>
    <span class="s1">packageName,</span>
    <span class="s1">packageSubpath,</span>
    <span class="s1">isScoped</span>
  <span class="s1">} = parsePackageName(specifier, base);</span>
  <span class="s1">const packageConfig = getPackageScopeConfig(base);</span>
  <span class="s2">if </span><span class="s1">(packageConfig.exists) {</span>
    <span class="s1">const packageJsonUrl = (</span><span class="s3">0</span><span class="s1">, _url().pathToFileURL)(packageConfig.pjsonPath);</span>
    <span class="s2">if </span><span class="s1">(packageConfig.name === packageName &amp;&amp; packageConfig.exports !== undefined &amp;&amp; packageConfig.exports !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">let packageJsonUrl = </span><span class="s2">new </span><span class="s1">(_url().URL)(</span><span class="s0">'./node_modules/' </span><span class="s1">+ packageName + </span><span class="s0">'/package.json'</span><span class="s1">, base);</span>
  <span class="s1">let packageJsonPath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(packageJsonUrl);</span>
  <span class="s1">let lastPath;</span>
  <span class="s2">do </span><span class="s1">{</span>
    <span class="s1">const stat = tryStatSync(packageJsonPath.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s3">13</span><span class="s1">));</span>
    <span class="s2">if </span><span class="s1">(!stat.isDirectory()) {</span>
      <span class="s1">lastPath = packageJsonPath;</span>
      <span class="s1">packageJsonUrl = </span><span class="s2">new </span><span class="s1">(_url().URL)((isScoped ? </span><span class="s0">'../../../../node_modules/' </span><span class="s1">: </span><span class="s0">'../../../node_modules/'</span><span class="s1">) + packageName + </span><span class="s0">'/package.json'</span><span class="s1">, packageJsonUrl);</span>
      <span class="s1">packageJsonPath = (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(packageJsonUrl);</span>
      <span class="s2">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const packageConfig = getPackageConfig(packageJsonPath, specifier, base);</span>
    <span class="s2">if </span><span class="s1">(packageConfig.exports !== undefined &amp;&amp; packageConfig.exports !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(packageSubpath === </span><span class="s0">'.'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">legacyMainResolve(packageJsonUrl, packageConfig, base);</span>
    <span class="s1">}</span>
    <span class="s2">return new </span><span class="s1">(_url().URL)(packageSubpath, packageJsonUrl);</span>
  <span class="s1">} </span><span class="s2">while </span><span class="s1">(packageJsonPath.length !== lastPath.length);</span>
  <span class="s2">throw new </span><span class="s1">ERR_MODULE_NOT_FOUND(packageName, (</span><span class="s3">0</span><span class="s1">, _url().fileURLToPath)(base));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isRelativeSpecifier(specifier) {</span>
  <span class="s2">if </span><span class="s1">(specifier[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'.'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(specifier.length === </span><span class="s3">1 </span><span class="s1">|| specifier[</span><span class="s3">1</span><span class="s1">] === </span><span class="s0">'/'</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(specifier[</span><span class="s3">1</span><span class="s1">] === </span><span class="s0">'.' </span><span class="s1">&amp;&amp; (specifier.length === </span><span class="s3">2 </span><span class="s1">|| specifier[</span><span class="s3">2</span><span class="s1">] === </span><span class="s0">'/'</span><span class="s1">)) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {</span>
  <span class="s2">if </span><span class="s1">(specifier === </span><span class="s0">''</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(specifier[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'/'</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">isRelativeSpecifier(specifier);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">moduleResolve(specifier, base, conditions, preserveSymlinks) {</span>
  <span class="s1">const protocol = base.protocol;</span>
  <span class="s1">const isRemote = protocol === </span><span class="s0">'http:' </span><span class="s1">|| protocol === </span><span class="s0">'https:'</span><span class="s1">;</span>
  <span class="s1">let resolved;</span>
  <span class="s2">if </span><span class="s1">(shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {</span>
    <span class="s1">resolved = </span><span class="s2">new </span><span class="s1">(_url().URL)(specifier, base);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isRemote &amp;&amp; specifier[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'#'</span><span class="s1">) {</span>
    <span class="s1">resolved = packageImportsResolve(specifier, base, conditions);</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">resolved = </span><span class="s2">new </span><span class="s1">(_url().URL)(specifier);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_unused4) {</span>
      <span class="s2">if </span><span class="s1">(!isRemote) {</span>
        <span class="s1">resolved = packageResolve(specifier, base, conditions);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_assert()(resolved !== undefined, </span><span class="s0">'expected to be defined'</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(resolved.protocol !== </span><span class="s0">'file:'</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">resolved;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">finalizeResolution(resolved, base, preserveSymlinks);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">checkIfDisallowedImport(specifier, parsed, parsedParentURL) {</span>
  <span class="s2">if </span><span class="s1">(parsedParentURL) {</span>
    <span class="s1">const parentProtocol = parsedParentURL.protocol;</span>
    <span class="s2">if </span><span class="s1">(parentProtocol === </span><span class="s0">'http:' </span><span class="s1">|| parentProtocol === </span><span class="s0">'https:'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {</span>
        <span class="s1">const parsedProtocol = parsed == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: parsed.protocol;</span>
        <span class="s2">if </span><span class="s1">(parsedProtocol &amp;&amp; parsedProtocol !== </span><span class="s0">'https:' </span><span class="s1">&amp;&amp; parsedProtocol !== </span><span class="s0">'http:'</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, </span><span class="s0">'remote imports cannot import from a local location.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
          <span class="s1">url: (parsed == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: parsed.href) || </span><span class="s0">''</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(_module().builtinModules.includes(specifier)) {</span>
        <span class="s2">throw new </span><span class="s1">ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, </span><span class="s0">'remote imports cannot import from a local location.'</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s2">throw new </span><span class="s1">ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, </span><span class="s0">'only relative and absolute specifiers are supported.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isURL(self) {</span>
  <span class="s2">return </span><span class="s1">Boolean(self &amp;&amp; </span><span class="s2">typeof </span><span class="s1">self === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s0">'href' </span><span class="s2">in </span><span class="s1">self &amp;&amp; </span><span class="s2">typeof </span><span class="s1">self.href === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; </span><span class="s0">'protocol' </span><span class="s2">in </span><span class="s1">self &amp;&amp; </span><span class="s2">typeof </span><span class="s1">self.protocol === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; self.href &amp;&amp; self.protocol);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">throwIfInvalidParentURL(parentURL) {</span>
  <span class="s2">if </span><span class="s1">(parentURL === undefined) {</span>
    <span class="s2">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">parentURL !== </span><span class="s0">'string' </span><span class="s1">&amp;&amp; !isURL(parentURL)) {</span>
    <span class="s2">throw new </span><span class="s1">codes.ERR_INVALID_ARG_TYPE(</span><span class="s0">'parentURL'</span><span class="s1">, [</span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'URL'</span><span class="s1">], parentURL);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">throwIfUnsupportedURLProtocol(url) {</span>
  <span class="s1">const protocol = url.protocol;</span>
  <span class="s2">if </span><span class="s1">(protocol !== </span><span class="s0">'file:' </span><span class="s1">&amp;&amp; protocol !== </span><span class="s0">'data:' </span><span class="s1">&amp;&amp; protocol !== </span><span class="s0">'node:'</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">ERR_UNSUPPORTED_ESM_URL_SCHEME(url);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports) {</span>
  <span class="s1">const protocol = parsed == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: parsed.protocol;</span>
  <span class="s2">if </span><span class="s1">(protocol &amp;&amp; protocol !== </span><span class="s0">'file:' </span><span class="s1">&amp;&amp; protocol !== </span><span class="s0">'data:' </span><span class="s1">&amp;&amp; (!experimentalNetworkImports || protocol !== </span><span class="s0">'https:' </span><span class="s1">&amp;&amp; protocol !== </span><span class="s0">'http:'</span><span class="s1">)) {</span>
    <span class="s2">throw new </span><span class="s1">ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed, [</span><span class="s0">'file'</span><span class="s1">, </span><span class="s0">'data'</span><span class="s1">].concat(experimentalNetworkImports ? [</span><span class="s0">'https'</span><span class="s1">, </span><span class="s0">'http'</span><span class="s1">] : []));</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">defaultResolve(specifier, context = {}) {</span>
  <span class="s1">const {</span>
    <span class="s1">parentURL</span>
  <span class="s1">} = context;</span>
  <span class="s1">_assert()(parentURL !== undefined, </span><span class="s0">'expected `parentURL` to be defined'</span><span class="s1">);</span>
  <span class="s1">throwIfInvalidParentURL(parentURL);</span>
  <span class="s1">let parsedParentURL;</span>
  <span class="s2">if </span><span class="s1">(parentURL) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">parsedParentURL = </span><span class="s2">new </span><span class="s1">(_url().URL)(parentURL);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_unused5) {}</span>
  <span class="s1">}</span>
  <span class="s1">let parsed;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? </span><span class="s2">new </span><span class="s1">(_url().URL)(specifier, parsedParentURL) : </span><span class="s2">new </span><span class="s1">(_url().URL)(specifier);</span>
    <span class="s1">const protocol = parsed.protocol;</span>
    <span class="s2">if </span><span class="s1">(protocol === </span><span class="s0">'data:' </span><span class="s1">|| experimentalNetworkImports &amp;&amp; (protocol === </span><span class="s0">'https:' </span><span class="s1">|| protocol === </span><span class="s0">'http:'</span><span class="s1">)) {</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">url: parsed.href,</span>
        <span class="s1">format: </span><span class="s2">null</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(_unused6) {}</span>
  <span class="s1">const maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);</span>
  <span class="s2">if </span><span class="s1">(maybeReturn) </span><span class="s2">return </span><span class="s1">maybeReturn;</span>
  <span class="s2">if </span><span class="s1">(parsed &amp;&amp; parsed.protocol === </span><span class="s0">'node:'</span><span class="s1">) </span><span class="s2">return </span><span class="s1">{</span>
    <span class="s1">url: specifier</span>
  <span class="s1">};</span>
  <span class="s1">throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports);</span>
  <span class="s1">const conditions = getConditionsSet(context.conditions);</span>
  <span class="s1">const url = moduleResolve(specifier, </span><span class="s2">new </span><span class="s1">(_url().URL)(parentURL), conditions, </span><span class="s2">false</span><span class="s1">);</span>
  <span class="s1">throwIfUnsupportedURLProtocol(url);</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">url: url.href,</span>
    <span class="s1">format: defaultGetFormatWithoutErrors(url, {</span>
      <span class="s1">parentURL</span>
    <span class="s1">})</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolve(specifier, parent) {</span>
  <span class="s2">if </span><span class="s1">(!parent) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Please pass `parent`: `import-meta-resolve` cannot ponyfill that'</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">defaultResolve(specifier, {</span>
      <span class="s1">parentURL: parent</span>
    <span class="s1">}).url;</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
    <span class="s1">const exception = error;</span>
    <span class="s2">if </span><span class="s1">(exception.code === </span><span class="s0">'ERR_UNSUPPORTED_DIR_IMPORT' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">exception.url === </span><span class="s0">'string'</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">exception.url;</span>
    <span class="s1">}</span>
    <span class="s2">throw </span><span class="s1">error;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; </span><span class="s3">0</span><span class="s1">;</span>

<span class="s5">//# sourceMappingURL=import-meta-resolve.js.map</span>
</pre>
</body>
</html>
<html>
<head>
<title>VirtualizedSectionList.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
VirtualizedSectionList.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @flow 
 * @format 
 */</span>

<span class="s1">import type {ViewToken} from </span><span class="s2">'./ViewabilityHelper'</span><span class="s1">;</span>

<span class="s1">import {View} from </span><span class="s2">'react-native'</span><span class="s1">;</span>
<span class="s1">import VirtualizedList from </span><span class="s2">'./VirtualizedList'</span><span class="s1">;</span>
<span class="s1">import {keyExtractor as defaultKeyExtractor} from </span><span class="s2">'./VirtualizeUtils'</span><span class="s1">;</span>
<span class="s1">import invariant from </span><span class="s2">'invariant'</span><span class="s1">;</span>
<span class="s1">import * as React from </span><span class="s2">'react'</span><span class="s1">;</span>

<span class="s1">type Item = any;</span>

<span class="s1">export type SectionBase&lt;SectionItemT&gt; = {</span>
  <span class="s0">/** 
   * The data for rendering items in this section. 
   */</span>
  <span class="s1">data: $ReadOnlyArray&lt;SectionItemT&gt;,</span>
  <span class="s0">/** 
   * Optional key to keep track of section re-ordering. If you don't plan on re-ordering sections, 
   * the array index will be used by default. 
   */</span>
  <span class="s1">key?: string,</span>
  <span class="s0">// Optional props will override list-wide props just for this section.</span>
  <span class="s1">renderItem?: ?(info: {</span>
    <span class="s1">item: SectionItemT,</span>
    <span class="s1">index: number,</span>
    <span class="s1">section: SectionBase&lt;SectionItemT&gt;,</span>
    <span class="s1">separators: {</span>
      <span class="s1">highlight: () =&gt; </span><span class="s3">void</span><span class="s1">,</span>
      <span class="s1">unhighlight: () =&gt; </span><span class="s3">void</span><span class="s1">,</span>
      <span class="s1">updateProps: (select: </span><span class="s2">'leading' </span><span class="s1">| </span><span class="s2">'trailing'</span><span class="s1">, newProps: Object) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
      <span class="s1">...</span>
    <span class="s1">},</span>
    <span class="s1">...</span>
  <span class="s1">}) =&gt; </span><span class="s3">null </span><span class="s1">| React.Element&lt;any&gt;,</span>
  <span class="s1">ItemSeparatorComponent?: ?React.ComponentType&lt;any&gt;,</span>
  <span class="s1">keyExtractor?: (item: SectionItemT, index?: ?number) =&gt; string,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type RequiredProps&lt;SectionT: SectionBase&lt;any&gt;&gt; = {|</span>
  <span class="s1">sections: $ReadOnlyArray&lt;SectionT&gt;,</span>
<span class="s1">|};</span>

<span class="s1">type OptionalProps&lt;SectionT: SectionBase&lt;any&gt;&gt; = {|</span>
  <span class="s0">/** 
   * Default renderer for every item in every section. 
   */</span>
  <span class="s1">renderItem?: (info: {</span>
    <span class="s1">item: Item,</span>
    <span class="s1">index: number,</span>
    <span class="s1">section: SectionT,</span>
    <span class="s1">separators: {</span>
      <span class="s1">highlight: () =&gt; </span><span class="s3">void</span><span class="s1">,</span>
      <span class="s1">unhighlight: () =&gt; </span><span class="s3">void</span><span class="s1">,</span>
      <span class="s1">updateProps: (select: </span><span class="s2">'leading' </span><span class="s1">| </span><span class="s2">'trailing'</span><span class="s1">, newProps: Object) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
      <span class="s1">...</span>
    <span class="s1">},</span>
    <span class="s1">...</span>
  <span class="s1">}) =&gt; </span><span class="s3">null </span><span class="s1">| React.Element&lt;any&gt;,</span>
  <span class="s0">/** 
   * Rendered at the top of each section. These stick to the top of the `ScrollView` by default on 
   * iOS. See `stickySectionHeadersEnabled`. 
   */</span>
  <span class="s1">renderSectionHeader?: ?(info: {</span>
    <span class="s1">section: SectionT,</span>
    <span class="s1">...</span>
  <span class="s1">}) =&gt; </span><span class="s3">null </span><span class="s1">| React.Element&lt;any&gt;,</span>
  <span class="s0">/** 
   * Rendered at the bottom of each section. 
   */</span>
  <span class="s1">renderSectionFooter?: ?(info: {</span>
    <span class="s1">section: SectionT,</span>
    <span class="s1">...</span>
  <span class="s1">}) =&gt; </span><span class="s3">null </span><span class="s1">| React.Element&lt;any&gt;,</span>
  <span class="s0">/** 
   * Rendered at the top and bottom of each section (note this is different from 
   * `ItemSeparatorComponent` which is only rendered between items). These are intended to separate 
   * sections from the headers above and below and typically have the same highlight response as 
   * `ItemSeparatorComponent`. Also receives `highlighted`, `[leading/trailing][Item/Separator]`, 
   * and any custom props from `separators.updateProps`. 
   */</span>
  <span class="s1">SectionSeparatorComponent?: ?React.ComponentType&lt;any&gt;,</span>
  <span class="s0">/** 
   * Makes section headers stick to the top of the screen until the next one pushes it off. Only 
   * enabled by default on iOS because that is the platform standard there. 
   */</span>
  <span class="s1">stickySectionHeadersEnabled?: boolean,</span>
  <span class="s1">onEndReached?: ?({distanceFromEnd: number, ...}) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
<span class="s1">|};</span>

<span class="s1">type VirtualizedListProps = React.ElementConfig&lt;</span><span class="s3">typeof </span><span class="s1">VirtualizedList&gt;;</span>

<span class="s1">export type Props&lt;SectionT&gt; = {|</span>
  <span class="s1">...RequiredProps&lt;SectionT&gt;,</span>
  <span class="s1">...OptionalProps&lt;SectionT&gt;,</span>
  <span class="s1">...$Diff&lt;</span>
    <span class="s1">VirtualizedListProps,</span>
    <span class="s1">{</span>
      <span class="s1">renderItem: $PropertyType&lt;VirtualizedListProps, </span><span class="s2">'renderItem'</span><span class="s1">&gt;,</span>
      <span class="s1">data: $PropertyType&lt;VirtualizedListProps, </span><span class="s2">'data'</span><span class="s1">&gt;,</span>
      <span class="s1">...</span>
    <span class="s1">},</span>
  <span class="s1">&gt;,</span>
<span class="s1">|};</span>
<span class="s1">export type ScrollToLocationParamsType = {|</span>
  <span class="s1">animated?: ?boolean,</span>
  <span class="s1">itemIndex: number,</span>
  <span class="s1">sectionIndex: number,</span>
  <span class="s1">viewOffset?: number,</span>
  <span class="s1">viewPosition?: number,</span>
<span class="s1">|};</span>

<span class="s1">type State = {childProps: VirtualizedListProps, ...};</span>

<span class="s0">/** 
 * Right now this just flattens everything into one list and uses VirtualizedList under the 
 * hood. The only operation that might not scale well is concatting the data arrays of all the 
 * sections when new props are received, which should be plenty fast for up to ~10,000 items. 
 */</span>
<span class="s1">class VirtualizedSectionList&lt;</span>
  <span class="s1">SectionT: SectionBase&lt;any&gt;,</span>
<span class="s1">&gt; extends React.PureComponent&lt;Props&lt;SectionT&gt;, State&gt; {</span>
  <span class="s1">scrollToLocation(params: ScrollToLocationParamsType) {</span>
    <span class="s1">let index = params.itemIndex;</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; params.sectionIndex; i++) {</span>
      <span class="s1">index += </span><span class="s3">this</span><span class="s1">.props.getItemCount(</span><span class="s3">this</span><span class="s1">.props.sections[i].data) + </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">let viewOffset = params.viewOffset || </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._listRef == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(params.itemIndex &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.props.stickySectionHeadersEnabled) {</span>
      <span class="s1">const frame = </span><span class="s3">this</span><span class="s1">._listRef.__getFrameMetricsApprox(</span>
        <span class="s1">index - params.itemIndex,</span>
        <span class="s3">this</span><span class="s1">._listRef.props,</span>
      <span class="s1">);</span>
      <span class="s1">viewOffset += frame.length;</span>
    <span class="s1">}</span>
    <span class="s1">const toIndexParams = {</span>
      <span class="s1">...params,</span>
      <span class="s1">viewOffset,</span>
      <span class="s1">index,</span>
    <span class="s1">};</span>
    <span class="s0">// $FlowFixMe[incompatible-use]</span>
    <span class="s3">this</span><span class="s1">._listRef.scrollToIndex(toIndexParams);</span>
  <span class="s1">}</span>

  <span class="s1">getListRef(): ?React.ElementRef&lt;</span><span class="s3">typeof </span><span class="s1">VirtualizedList&gt; {</span>
    <span class="s3">return this</span><span class="s1">._listRef;</span>
  <span class="s1">}</span>

  <span class="s1">render(): React.Node {</span>
    <span class="s1">const {</span>
      <span class="s1">ItemSeparatorComponent, </span><span class="s0">// don't pass through, rendered with renderItem</span>
      <span class="s1">SectionSeparatorComponent,</span>
      <span class="s1">renderItem: _renderItem,</span>
      <span class="s1">renderSectionFooter,</span>
      <span class="s1">renderSectionHeader,</span>
      <span class="s1">sections: _sections,</span>
      <span class="s1">stickySectionHeadersEnabled,</span>
      <span class="s1">...passThroughProps</span>
    <span class="s1">} = </span><span class="s3">this</span><span class="s1">.props;</span>

    <span class="s1">const listHeaderOffset = </span><span class="s3">this</span><span class="s1">.props.ListHeaderComponent ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s1">const stickyHeaderIndices = </span><span class="s3">this</span><span class="s1">.props.stickySectionHeadersEnabled</span>
      <span class="s1">? ([]: Array&lt;number&gt;)</span>
      <span class="s1">: undefined;</span>

    <span class="s1">let itemCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(const section of </span><span class="s3">this</span><span class="s1">.props.sections) {</span>
      <span class="s0">// Track the section header indices</span>
      <span class="s3">if </span><span class="s1">(stickyHeaderIndices != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">stickyHeaderIndices.push(itemCount + listHeaderOffset);</span>
      <span class="s1">}</span>

      <span class="s0">// Add two for the section header and footer.</span>
      <span class="s1">itemCount += </span><span class="s4">2</span><span class="s1">;</span>
      <span class="s1">itemCount += </span><span class="s3">this</span><span class="s1">.props.getItemCount(section.data);</span>
    <span class="s1">}</span>
    <span class="s1">const renderItem = </span><span class="s3">this</span><span class="s1">._renderItem(itemCount);</span>

    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">&lt;VirtualizedList</span>
        <span class="s1">{...passThroughProps}</span>
        <span class="s1">keyExtractor={</span><span class="s3">this</span><span class="s1">._keyExtractor}</span>
        <span class="s1">stickyHeaderIndices={stickyHeaderIndices}</span>
        <span class="s1">renderItem={renderItem}</span>
        <span class="s1">data={</span><span class="s3">this</span><span class="s1">.props.sections}</span>
        <span class="s1">getItem={(sections, index) =&gt;</span>
          <span class="s3">this</span><span class="s1">._getItem(</span><span class="s3">this</span><span class="s1">.props, sections, index)</span>
        <span class="s1">}</span>
        <span class="s1">getItemCount={() =&gt; itemCount}</span>
        <span class="s1">onViewableItemsChanged={</span>
          <span class="s3">this</span><span class="s1">.props.onViewableItemsChanged</span>
            <span class="s1">? </span><span class="s3">this</span><span class="s1">._onViewableItemsChanged</span>
            <span class="s1">: undefined</span>
        <span class="s1">}</span>
        <span class="s1">ref={</span><span class="s3">this</span><span class="s1">._captureRef}</span>
      <span class="s1">/&gt;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">_getItem(</span>
    <span class="s1">props: Props&lt;SectionT&gt;,</span>
    <span class="s1">sections: ?$ReadOnlyArray&lt;Item&gt;,</span>
    <span class="s1">index: number,</span>
  <span class="s1">): ?Item {</span>
    <span class="s3">if </span><span class="s1">(!sections) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">let itemIdx = index - </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; sections.length; i++) {</span>
      <span class="s1">const section = sections[i];</span>
      <span class="s1">const sectionData = section.data;</span>
      <span class="s1">const itemCount = props.getItemCount(sectionData);</span>
      <span class="s3">if </span><span class="s1">(itemIdx === -</span><span class="s4">1 </span><span class="s1">|| itemIdx === itemCount) {</span>
        <span class="s0">// We intend for there to be overflow by one on both ends of the list.</span>
        <span class="s0">// This will be for headers and footers. When returning a header or footer</span>
        <span class="s0">// item the section itself is the item.</span>
        <span class="s3">return </span><span class="s1">section;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(itemIdx &lt; itemCount) {</span>
        <span class="s0">// If we are in the bounds of the list's data then return the item.</span>
        <span class="s3">return </span><span class="s1">props.getItem(sectionData, itemIdx);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">itemIdx -= itemCount + </span><span class="s4">2</span><span class="s1">; </span><span class="s0">// Add two for the header and footer</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// $FlowFixMe[missing-local-annot]</span>
  <span class="s1">_keyExtractor = (item: Item, index: number) =&gt; {</span>
    <span class="s1">const info = </span><span class="s3">this</span><span class="s1">._subExtractor(index);</span>
    <span class="s3">return </span><span class="s1">(info &amp;&amp; info.key) || String(index);</span>
  <span class="s1">};</span>

  <span class="s1">_subExtractor(index: number): ?{</span>
    <span class="s1">section: SectionT,</span>
    <span class="s0">// Key of the section or combined key for section + item</span>
    <span class="s1">key: string,</span>
    <span class="s0">// Relative index within the section</span>
    <span class="s1">index: ?number,</span>
    <span class="s0">// True if this is the section header</span>
    <span class="s1">header?: ?boolean,</span>
    <span class="s1">leadingItem?: ?Item,</span>
    <span class="s1">leadingSection?: ?SectionT,</span>
    <span class="s1">trailingItem?: ?Item,</span>
    <span class="s1">trailingSection?: ?SectionT,</span>
    <span class="s1">...</span>
  <span class="s1">} {</span>
    <span class="s1">let itemIndex = index;</span>
    <span class="s1">const {getItem, getItemCount, keyExtractor, sections} = </span><span class="s3">this</span><span class="s1">.props;</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; sections.length; i++) {</span>
      <span class="s1">const section = sections[i];</span>
      <span class="s1">const sectionData = section.data;</span>
      <span class="s1">const key = section.key || String(i);</span>
      <span class="s1">itemIndex -= </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// The section adds an item for the header</span>
      <span class="s3">if </span><span class="s1">(itemIndex &gt;= getItemCount(sectionData) + </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">itemIndex -= getItemCount(sectionData) + </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// The section adds an item for the footer.</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(itemIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">{</span>
          <span class="s1">section,</span>
          <span class="s1">key: key + </span><span class="s2">':header'</span><span class="s1">,</span>
          <span class="s1">index: </span><span class="s3">null</span><span class="s1">,</span>
          <span class="s1">header: </span><span class="s3">true</span><span class="s1">,</span>
          <span class="s1">trailingSection: sections[i + </span><span class="s4">1</span><span class="s1">],</span>
        <span class="s1">};</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(itemIndex === getItemCount(sectionData)) {</span>
        <span class="s3">return </span><span class="s1">{</span>
          <span class="s1">section,</span>
          <span class="s1">key: key + </span><span class="s2">':footer'</span><span class="s1">,</span>
          <span class="s1">index: </span><span class="s3">null</span><span class="s1">,</span>
          <span class="s1">header: </span><span class="s3">false</span><span class="s1">,</span>
          <span class="s1">trailingSection: sections[i + </span><span class="s4">1</span><span class="s1">],</span>
        <span class="s1">};</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">const extractor =</span>
          <span class="s1">section.keyExtractor || keyExtractor || defaultKeyExtractor;</span>
        <span class="s3">return </span><span class="s1">{</span>
          <span class="s1">section,</span>
          <span class="s1">key:</span>
            <span class="s1">key + </span><span class="s2">':' </span><span class="s1">+ extractor(getItem(sectionData, itemIndex), itemIndex),</span>
          <span class="s1">index: itemIndex,</span>
          <span class="s1">leadingItem: getItem(sectionData, itemIndex - </span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">leadingSection: sections[i - </span><span class="s4">1</span><span class="s1">],</span>
          <span class="s1">trailingItem: getItem(sectionData, itemIndex + </span><span class="s4">1</span><span class="s1">),</span>
          <span class="s1">trailingSection: sections[i + </span><span class="s4">1</span><span class="s1">],</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_convertViewable = (viewable: ViewToken): ?ViewToken =&gt; {</span>
    <span class="s1">invariant(viewable.index != </span><span class="s3">null</span><span class="s1">, </span><span class="s2">'Received a broken ViewToken'</span><span class="s1">);</span>
    <span class="s1">const info = </span><span class="s3">this</span><span class="s1">._subExtractor(viewable.index);</span>
    <span class="s3">if </span><span class="s1">(!info) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const keyExtractorWithNullableIndex = info.section.keyExtractor;</span>
    <span class="s1">const keyExtractorWithNonNullableIndex =</span>
      <span class="s3">this</span><span class="s1">.props.keyExtractor || defaultKeyExtractor;</span>
    <span class="s1">const key =</span>
      <span class="s1">keyExtractorWithNullableIndex != </span><span class="s3">null</span>
        <span class="s1">? keyExtractorWithNullableIndex(viewable.item, info.index)</span>
        <span class="s1">: keyExtractorWithNonNullableIndex(viewable.item, info.index ?? </span><span class="s4">0</span><span class="s1">);</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">...viewable,</span>
      <span class="s1">index: info.index,</span>
      <span class="s1">key,</span>
      <span class="s1">section: info.section,</span>
    <span class="s1">};</span>
  <span class="s1">};</span>

  <span class="s1">_onViewableItemsChanged = ({</span>
    <span class="s1">viewableItems,</span>
    <span class="s1">changed,</span>
  <span class="s1">}: {</span>
    <span class="s1">viewableItems: Array&lt;ViewToken&gt;,</span>
    <span class="s1">changed: Array&lt;ViewToken&gt;,</span>
    <span class="s1">...</span>
  <span class="s1">}) =&gt; {</span>
    <span class="s1">const onViewableItemsChanged = </span><span class="s3">this</span><span class="s1">.props.onViewableItemsChanged;</span>
    <span class="s3">if </span><span class="s1">(onViewableItemsChanged != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">onViewableItemsChanged({</span>
        <span class="s1">viewableItems: viewableItems</span>
          <span class="s1">.map(</span><span class="s3">this</span><span class="s1">._convertViewable, </span><span class="s3">this</span><span class="s1">)</span>
          <span class="s1">.filter(Boolean),</span>
        <span class="s1">changed: changed.map(</span><span class="s3">this</span><span class="s1">._convertViewable, </span><span class="s3">this</span><span class="s1">).filter(Boolean),</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_renderItem =</span>
    <span class="s1">(listItemCount: number): $FlowFixMe =&gt;</span>
    <span class="s0">// eslint-disable-next-line react/no-unstable-nested-components</span>
    <span class="s1">({item, index}: {item: Item, index: number, ...}) =&gt; {</span>
      <span class="s1">const info = </span><span class="s3">this</span><span class="s1">._subExtractor(index);</span>
      <span class="s3">if </span><span class="s1">(!info) {</span>
        <span class="s3">return null</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const infoIndex = info.index;</span>
      <span class="s3">if </span><span class="s1">(infoIndex == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">const {section} = info;</span>
        <span class="s3">if </span><span class="s1">(info.header === </span><span class="s3">true</span><span class="s1">) {</span>
          <span class="s1">const {renderSectionHeader} = </span><span class="s3">this</span><span class="s1">.props;</span>
          <span class="s3">return </span><span class="s1">renderSectionHeader ? renderSectionHeader({section}) : </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">const {renderSectionFooter} = </span><span class="s3">this</span><span class="s1">.props;</span>
          <span class="s3">return </span><span class="s1">renderSectionFooter ? renderSectionFooter({section}) : </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">const renderItem = info.section.renderItem || </span><span class="s3">this</span><span class="s1">.props.renderItem;</span>
        <span class="s1">const SeparatorComponent = </span><span class="s3">this</span><span class="s1">._getSeparatorComponent(</span>
          <span class="s1">index,</span>
          <span class="s1">info,</span>
          <span class="s1">listItemCount,</span>
        <span class="s1">);</span>
        <span class="s1">invariant(renderItem, </span><span class="s2">'no renderItem!'</span><span class="s1">);</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">&lt;ItemWithSeparator</span>
            <span class="s1">SeparatorComponent={SeparatorComponent}</span>
            <span class="s1">LeadingSeparatorComponent={</span>
              <span class="s1">infoIndex === </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">this</span><span class="s1">.props.SectionSeparatorComponent : undefined</span>
            <span class="s1">}</span>
            <span class="s1">cellKey={info.key}</span>
            <span class="s1">index={infoIndex}</span>
            <span class="s1">item={item}</span>
            <span class="s1">leadingItem={info.leadingItem}</span>
            <span class="s1">leadingSection={info.leadingSection}</span>
            <span class="s1">prevCellKey={(</span><span class="s3">this</span><span class="s1">._subExtractor(index - </span><span class="s4">1</span><span class="s1">) || {}).key}</span>
            <span class="s0">// Callback to provide updateHighlight for this item</span>
            <span class="s1">setSelfHighlightCallback={</span><span class="s3">this</span><span class="s1">._setUpdateHighlightFor}</span>
            <span class="s1">setSelfUpdatePropsCallback={</span><span class="s3">this</span><span class="s1">._setUpdatePropsFor}</span>
            <span class="s0">// Provide child ability to set highlight/updateProps for previous item using prevCellKey</span>
            <span class="s1">updateHighlightFor={</span><span class="s3">this</span><span class="s1">._updateHighlightFor}</span>
            <span class="s1">updatePropsFor={</span><span class="s3">this</span><span class="s1">._updatePropsFor}</span>
            <span class="s1">renderItem={renderItem}</span>
            <span class="s1">section={info.section}</span>
            <span class="s1">trailingItem={info.trailingItem}</span>
            <span class="s1">trailingSection={info.trailingSection}</span>
            <span class="s1">inverted={!!</span><span class="s3">this</span><span class="s1">.props.inverted}</span>
          <span class="s1">/&gt;</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

  <span class="s1">_updatePropsFor = (cellKey: string, value: any) =&gt; {</span>
    <span class="s1">const updateProps = </span><span class="s3">this</span><span class="s1">._updatePropsMap[cellKey];</span>
    <span class="s3">if </span><span class="s1">(updateProps != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">updateProps(value);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_updateHighlightFor = (cellKey: string, value: boolean) =&gt; {</span>
    <span class="s1">const updateHighlight = </span><span class="s3">this</span><span class="s1">._updateHighlightMap[cellKey];</span>
    <span class="s3">if </span><span class="s1">(updateHighlight != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">updateHighlight(value);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_setUpdateHighlightFor = (</span>
    <span class="s1">cellKey: string,</span>
    <span class="s1">updateHighlightFn: ?(boolean) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s3">if </span><span class="s1">(updateHighlightFn != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._updateHighlightMap[cellKey] = updateHighlightFn;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// $FlowFixMe[prop-missing]</span>
      <span class="s3">delete this</span><span class="s1">._updateHighlightFor[cellKey];</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_setUpdatePropsFor = (cellKey: string, updatePropsFn: ?(boolean) =&gt; </span><span class="s3">void</span><span class="s1">) =&gt; {</span>
    <span class="s3">if </span><span class="s1">(updatePropsFn != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._updatePropsMap[cellKey] = updatePropsFn;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">delete this</span><span class="s1">._updatePropsMap[cellKey];</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_getSeparatorComponent(</span>
    <span class="s1">index: number,</span>
    <span class="s1">info?: ?Object,</span>
    <span class="s1">listItemCount: number,</span>
  <span class="s1">): ?React.ComponentType&lt;any&gt; {</span>
    <span class="s1">info = info || </span><span class="s3">this</span><span class="s1">._subExtractor(index);</span>
    <span class="s3">if </span><span class="s1">(!info) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const ItemSeparatorComponent =</span>
      <span class="s1">info.section.ItemSeparatorComponent || </span><span class="s3">this</span><span class="s1">.props.ItemSeparatorComponent;</span>
    <span class="s1">const {SectionSeparatorComponent} = </span><span class="s3">this</span><span class="s1">.props;</span>
    <span class="s1">const isLastItemInList = index === listItemCount - </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">const isLastItemInSection =</span>
      <span class="s1">info.index === </span><span class="s3">this</span><span class="s1">.props.getItemCount(info.section.data) - </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(SectionSeparatorComponent &amp;&amp; isLastItemInSection) {</span>
      <span class="s3">return </span><span class="s1">SectionSeparatorComponent;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(ItemSeparatorComponent &amp;&amp; !isLastItemInSection &amp;&amp; !isLastItemInList) {</span>
      <span class="s3">return </span><span class="s1">ItemSeparatorComponent;</span>
    <span class="s1">}</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">_updateHighlightMap: {[string]: (boolean) =&gt; </span><span class="s3">void</span><span class="s1">} = {};</span>
  <span class="s1">_updatePropsMap: {[string]: </span><span class="s3">void </span><span class="s1">| (boolean =&gt; </span><span class="s3">void</span><span class="s1">)} = {};</span>
  <span class="s1">_listRef: ?React.ElementRef&lt;</span><span class="s3">typeof </span><span class="s1">VirtualizedList&gt;;</span>
  <span class="s1">_captureRef = (ref: </span><span class="s3">null </span><span class="s1">| React$ElementRef&lt;Class&lt;VirtualizedList&gt;&gt;) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._listRef = ref;</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">type ItemWithSeparatorCommonProps = $ReadOnly&lt;{|</span>
  <span class="s1">leadingItem: ?Item,</span>
  <span class="s1">leadingSection: ?Object,</span>
  <span class="s1">section: Object,</span>
  <span class="s1">trailingItem: ?Item,</span>
  <span class="s1">trailingSection: ?Object,</span>
<span class="s1">|}&gt;;</span>

<span class="s1">type ItemWithSeparatorProps = $ReadOnly&lt;{|</span>
  <span class="s1">...ItemWithSeparatorCommonProps,</span>
  <span class="s1">LeadingSeparatorComponent: ?React.ComponentType&lt;any&gt;,</span>
  <span class="s1">SeparatorComponent: ?React.ComponentType&lt;any&gt;,</span>
  <span class="s1">cellKey: string,</span>
  <span class="s1">index: number,</span>
  <span class="s1">item: Item,</span>
  <span class="s1">setSelfHighlightCallback: (</span>
    <span class="s1">cellKey: string,</span>
    <span class="s1">updateFn: ?(boolean) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">setSelfUpdatePropsCallback: (</span>
    <span class="s1">cellKey: string,</span>
    <span class="s1">updateFn: ?(boolean) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">prevCellKey?: ?string,</span>
  <span class="s1">updateHighlightFor: (prevCellKey: string, value: boolean) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">updatePropsFor: (prevCellKey: string, value: Object) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">renderItem: Function,</span>
  <span class="s1">inverted: boolean,</span>
<span class="s1">|}&gt;;</span>

<span class="s3">function </span><span class="s1">ItemWithSeparator(props: ItemWithSeparatorProps): React.Node {</span>
  <span class="s1">const {</span>
    <span class="s1">LeadingSeparatorComponent,</span>
    <span class="s0">// this is the trailing separator and is associated with this item</span>
    <span class="s1">SeparatorComponent,</span>
    <span class="s1">cellKey,</span>
    <span class="s1">prevCellKey,</span>
    <span class="s1">setSelfHighlightCallback,</span>
    <span class="s1">updateHighlightFor,</span>
    <span class="s1">setSelfUpdatePropsCallback,</span>
    <span class="s1">updatePropsFor,</span>
    <span class="s1">item,</span>
    <span class="s1">index,</span>
    <span class="s1">section,</span>
    <span class="s1">inverted,</span>
  <span class="s1">} = props;</span>

  <span class="s1">const [leadingSeparatorHiglighted, setLeadingSeparatorHighlighted] =</span>
    <span class="s1">React.useState(</span><span class="s3">false</span><span class="s1">);</span>

  <span class="s1">const [separatorHighlighted, setSeparatorHighlighted] = React.useState(</span><span class="s3">false</span><span class="s1">);</span>

  <span class="s1">const [leadingSeparatorProps, setLeadingSeparatorProps] = React.useState({</span>
    <span class="s1">leadingItem: props.leadingItem,</span>
    <span class="s1">leadingSection: props.leadingSection,</span>
    <span class="s1">section: props.section,</span>
    <span class="s1">trailingItem: props.item,</span>
    <span class="s1">trailingSection: props.trailingSection,</span>
  <span class="s1">});</span>
  <span class="s1">const [separatorProps, setSeparatorProps] = React.useState({</span>
    <span class="s1">leadingItem: props.item,</span>
    <span class="s1">leadingSection: props.leadingSection,</span>
    <span class="s1">section: props.section,</span>
    <span class="s1">trailingItem: props.trailingItem,</span>
    <span class="s1">trailingSection: props.trailingSection,</span>
  <span class="s1">});</span>

  <span class="s1">React.useEffect(() =&gt; {</span>
    <span class="s1">setSelfHighlightCallback(cellKey, setSeparatorHighlighted);</span>
    <span class="s0">// $FlowFixMe[incompatible-call]</span>
    <span class="s1">setSelfUpdatePropsCallback(cellKey, setSeparatorProps);</span>

    <span class="s3">return </span><span class="s1">() =&gt; {</span>
      <span class="s1">setSelfUpdatePropsCallback(cellKey, </span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">setSelfHighlightCallback(cellKey, </span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">};</span>
  <span class="s1">}, [</span>
    <span class="s1">cellKey,</span>
    <span class="s1">setSelfHighlightCallback,</span>
    <span class="s1">setSeparatorProps,</span>
    <span class="s1">setSelfUpdatePropsCallback,</span>
  <span class="s1">]);</span>

  <span class="s1">const separators = {</span>
    <span class="s1">highlight: () =&gt; {</span>
      <span class="s1">setLeadingSeparatorHighlighted(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">setSeparatorHighlighted(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(prevCellKey != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">updateHighlightFor(prevCellKey, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">unhighlight: () =&gt; {</span>
      <span class="s1">setLeadingSeparatorHighlighted(</span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">setSeparatorHighlighted(</span><span class="s3">false</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(prevCellKey != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">updateHighlightFor(prevCellKey, </span><span class="s3">false</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">updateProps: (</span>
      <span class="s1">select: </span><span class="s2">'leading' </span><span class="s1">| </span><span class="s2">'trailing'</span><span class="s1">,</span>
      <span class="s1">newProps: $Shape&lt;ItemWithSeparatorCommonProps&gt;,</span>
    <span class="s1">) =&gt; {</span>
      <span class="s3">if </span><span class="s1">(select === </span><span class="s2">'leading'</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(LeadingSeparatorComponent != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">setLeadingSeparatorProps({...leadingSeparatorProps, ...newProps});</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(prevCellKey != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// update the previous item's separator</span>
          <span class="s1">updatePropsFor(prevCellKey, {...leadingSeparatorProps, ...newProps});</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(select === </span><span class="s2">'trailing' </span><span class="s1">&amp;&amp; SeparatorComponent != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">setSeparatorProps({...separatorProps, ...newProps});</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
  <span class="s1">};</span>
  <span class="s1">const element = props.renderItem({</span>
    <span class="s1">item,</span>
    <span class="s1">index,</span>
    <span class="s1">section,</span>
    <span class="s1">separators,</span>
  <span class="s1">});</span>
  <span class="s1">const leadingSeparator = LeadingSeparatorComponent != </span><span class="s3">null </span><span class="s1">&amp;&amp; (</span>
    <span class="s1">&lt;LeadingSeparatorComponent</span>
      <span class="s1">highlighted={leadingSeparatorHiglighted}</span>
      <span class="s1">{...leadingSeparatorProps}</span>
    <span class="s1">/&gt;</span>
  <span class="s1">);</span>
  <span class="s1">const separator = SeparatorComponent != </span><span class="s3">null </span><span class="s1">&amp;&amp; (</span>
    <span class="s1">&lt;SeparatorComponent</span>
      <span class="s1">highlighted={separatorHighlighted}</span>
      <span class="s1">{...separatorProps}</span>
    <span class="s1">/&gt;</span>
  <span class="s1">);</span>
  <span class="s3">return </span><span class="s1">leadingSeparator || separator ? (</span>
    <span class="s1">&lt;View&gt;</span>
      <span class="s1">{inverted === </span><span class="s3">false </span><span class="s1">? leadingSeparator : separator}</span>
      <span class="s1">{element}</span>
      <span class="s1">{inverted === </span><span class="s3">false </span><span class="s1">? separator : leadingSeparator}</span>
    <span class="s1">&lt;/View&gt;</span>
  <span class="s1">) : (</span>
    <span class="s1">element</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/* $FlowFixMe[class-object-subtyping] added when improving typing for this 
 * parameters */</span>
<span class="s0">// $FlowFixMe[method-unbinding]</span>
<span class="s1">module.exports = (VirtualizedSectionList: React.AbstractComponent&lt;</span>
  <span class="s1">React.ElementConfig&lt;</span><span class="s3">typeof </span><span class="s1">VirtualizedSectionList&gt;,</span>
  <span class="s1">$ReadOnly&lt;{</span>
    <span class="s1">getListRef: () =&gt; ?React.ElementRef&lt;</span><span class="s3">typeof </span><span class="s1">VirtualizedList&gt;,</span>
    <span class="s1">scrollToLocation: (params: ScrollToLocationParamsType) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
    <span class="s1">...</span>
  <span class="s1">}&gt;,</span>
<span class="s1">&gt;);</span>
</pre>
</body>
</html>
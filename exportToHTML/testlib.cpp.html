<html>
<head>
<title>testlib.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
testlib.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#include </span><span class="s3">&lt;jsi/test/testlib.h&gt;</span>

<span class="s2">#include </span><span class="s3">&lt;gtest/gtest.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;jsi/decorator.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;jsi/jsi.h&gt;</span>

<span class="s2">#include </span><span class="s3">&lt;stdlib.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;chrono&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;functional&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;thread&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;unordered_map&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;unordered_set&gt;</span>

<span class="s4">using namespace </span><span class="s1">facebook::jsi</span><span class="s4">;</span>

<span class="s4">class </span><span class="s1">JSITest : </span><span class="s4">public </span><span class="s1">JSITestBase {}</span><span class="s4">;</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">RuntimeTest) {</span>
  <span class="s4">auto </span><span class="s1">v = rt.evaluateJavaScript(std::make_unique&lt;StringBuffer&gt;(</span><span class="s3">&quot;1&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(v.getNumber()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">rt.evaluateJavaScript(std::make_unique&lt;StringBuffer&gt;(</span><span class="s3">&quot;x = 1&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(rt.global().getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;x&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">PropNameIDTest) {</span>
  <span class="s0">// This is a little weird to test, because it doesn't really exist</span>
  <span class="s0">// in JS yet.  All I can do is create them, compare them, and</span>
  <span class="s0">// receive one as an argument to a HostObject.</span>

  <span class="s1">PropNameID quux = PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;quux1&quot;</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">PropNameID movedQuux = std::move(quux)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(movedQuux.utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;quux&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">movedQuux = PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;quux2&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(movedQuux.utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;quux2&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">PropNameID copiedQuux = PropNameID(rt</span><span class="s4">, </span><span class="s1">movedQuux)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(PropNameID::compare(rt</span><span class="s4">, </span><span class="s1">movedQuux</span><span class="s4">, </span><span class="s1">copiedQuux))</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(PropNameID::compare(rt</span><span class="s4">, </span><span class="s1">movedQuux</span><span class="s4">, </span><span class="s1">movedQuux))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(PropNameID::compare(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s1">movedQuux</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s1">std::string(</span><span class="s3">&quot;quux2&quot;</span><span class="s1">))))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(PropNameID::compare(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s1">movedQuux</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s1">std::string(</span><span class="s3">&quot;foo&quot;</span><span class="s1">))))</span><span class="s4">;</span>
  <span class="s1">uint8_t utf8[] = {</span><span class="s5">0xF0</span><span class="s4">, </span><span class="s5">0x9F</span><span class="s4">, </span><span class="s5">0x86</span><span class="s4">, </span><span class="s5">0x97</span><span class="s1">}</span><span class="s4">;</span>
  <span class="s1">PropNameID utf8PropNameID = PropNameID::forUtf8(rt</span><span class="s4">, </span><span class="s1">utf8</span><span class="s4">, sizeof</span><span class="s1">(utf8))</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(utf8PropNameID.utf8(rt)</span><span class="s4">, u8</span><span class="s3">&quot;</span><span class="s4">\U0001F197</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(PropNameID::compare(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s1">utf8PropNameID</span><span class="s4">, </span><span class="s1">PropNameID::forUtf8(rt</span><span class="s4">, </span><span class="s1">utf8</span><span class="s4">, sizeof</span><span class="s1">(utf8))))</span><span class="s4">;</span>
  <span class="s1">PropNameID nonUtf8PropNameID = PropNameID::forUtf8(rt</span><span class="s4">, </span><span class="s3">&quot;meow&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(PropNameID::compare(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s1">nonUtf8PropNameID</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;meow&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(nonUtf8PropNameID.utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;meow&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">PropNameID strPropNameID =</span>
      <span class="s1">PropNameID::forString(rt</span><span class="s4">, </span><span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;meow&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(PropNameID::compare(rt</span><span class="s4">, </span><span class="s1">nonUtf8PropNameID</span><span class="s4">, </span><span class="s1">strPropNameID))</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">names = PropNameID::names(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;Ala&quot;</span><span class="s4">, </span><span class="s1">std::string(</span><span class="s3">&quot;ma&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;kota&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(names.size()</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">PropNameID::compare(rt</span><span class="s4">, </span><span class="s1">names[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;Ala&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">PropNameID::compare(rt</span><span class="s4">, </span><span class="s1">names[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;ma&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">PropNameID::compare(rt</span><span class="s4">, </span><span class="s1">names[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;kota&quot;</span><span class="s1">)))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">StringTest) {</span>
  <span class="s1">EXPECT_TRUE(checkValue(String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;foobar&quot;</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;'foo'&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;foobar&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;'foobar'&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">std::string baz = </span><span class="s3">&quot;baz&quot;</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(String::createFromAscii(rt</span><span class="s4">, </span><span class="s1">baz)</span><span class="s4">, </span><span class="s3">&quot;'baz'&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">uint8_t utf8[] = {</span><span class="s5">0xF0</span><span class="s4">, </span><span class="s5">0x9F</span><span class="s4">, </span><span class="s5">0x86</span><span class="s4">, </span><span class="s5">0x97</span><span class="s1">}</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(</span>
      <span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">utf8</span><span class="s4">, sizeof</span><span class="s1">(utf8))</span><span class="s4">, </span><span class="s3">&quot;'</span><span class="s4">\\</span><span class="s3">uD83C</span><span class="s4">\\</span><span class="s3">uDD97'&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(eval(</span><span class="s3">&quot;'quux'&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;quux&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(eval(</span><span class="s3">&quot;'</span><span class="s4">\\</span><span class="s3">u20AC'&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;</span><span class="s4">\xe2\x82\xac</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">String quux = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;quux&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">String movedQuux = std::move(quux)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(movedQuux.utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;quux&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">movedQuux = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;quux2&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(movedQuux.utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;quux2&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">ObjectTest) {</span>
  <span class="s1">eval(</span><span class="s3">&quot;x = {1:2, '3':4, 5:'six', 'seven':['eight', 'nine']}&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Object x = rt.global().getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;x&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(x.getPropertyNames(rt).size(rt)</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(x.hasProperty(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(x.hasProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(x.hasProperty(rt</span><span class="s4">, </span><span class="s3">&quot;2&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(x.hasProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;2&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(x.hasProperty(rt</span><span class="s4">, </span><span class="s3">&quot;3&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(x.hasProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;3&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(x.hasProperty(rt</span><span class="s4">, </span><span class="s3">&quot;seven&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(x.hasProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;seven&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(x.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(x.getProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">)).getNumber()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(x.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;3&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Value five = </span><span class="s5">5</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">x.getProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forString(rt</span><span class="s4">, </span><span class="s1">five.toString(rt)))</span>
          <span class="s1">.getString(rt)</span>
          <span class="s1">.utf8(rt)</span><span class="s4">,</span>
      <span class="s3">&quot;six&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">x.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;ten&quot;</span><span class="s4">, </span><span class="s5">11</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(x.getPropertyNames(rt).size(rt)</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;x.ten == 11&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>

  <span class="s1">x.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;e_as_float&quot;</span><span class="s4">, </span><span class="s5">2.71f</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;Math.abs(x.e_as_float - 2.71) &lt; 0.001&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>

  <span class="s1">x.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;e_as_double&quot;</span><span class="s4">, </span><span class="s5">2.71</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;x.e_as_double == 2.71&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>

  <span class="s1">uint8_t utf8[] = {</span><span class="s5">0xF0</span><span class="s4">, </span><span class="s5">0x9F</span><span class="s4">, </span><span class="s5">0x86</span><span class="s4">, </span><span class="s5">0x97</span><span class="s1">}</span><span class="s4">;</span>
  <span class="s1">String nonAsciiName = String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">utf8</span><span class="s4">, sizeof</span><span class="s1">(utf8))</span><span class="s4">;</span>
  <span class="s1">x.setProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forString(rt</span><span class="s4">, </span><span class="s1">nonAsciiName)</span><span class="s4">, </span><span class="s3">&quot;emoji&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(x.getPropertyNames(rt).size(rt)</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;x['</span><span class="s4">\\</span><span class="s3">uD83C</span><span class="s4">\\</span><span class="s3">uDD97'] == 'emoji'&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>

  <span class="s1">Object seven = x.getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;seven&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(seven.isArray(rt))</span><span class="s4">;</span>
  <span class="s1">Object evalf = rt.global().getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;eval&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(evalf.isFunction(rt))</span><span class="s4">;</span>

  <span class="s1">Object movedX = Object(rt)</span><span class="s4">;</span>
  <span class="s1">movedX = std::move(x)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(movedX.getPropertyNames(rt).size(rt)</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(movedX.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">Object obj = Object(rt)</span><span class="s4">;</span>
  <span class="s1">obj.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;roses&quot;</span><span class="s4">, </span><span class="s3">&quot;red&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">obj.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;violets&quot;</span><span class="s4">, </span><span class="s3">&quot;blue&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Object oprop = Object(rt)</span><span class="s4">;</span>
  <span class="s1">obj.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;oprop&quot;</span><span class="s4">, </span><span class="s1">oprop)</span><span class="s4">;</span>
  <span class="s1">obj.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;aprop&quot;</span><span class="s4">, </span><span class="s1">Array(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return &quot;</span>
                       <span class="s3">&quot;obj.roses == 'red' &amp;&amp; &quot;</span>
                       <span class="s3">&quot;obj['violets'] == 'blue' &amp;&amp; &quot;</span>
                       <span class="s3">&quot;typeof obj.oprop == 'object' &amp;&amp; &quot;</span>
                       <span class="s3">&quot;Array.isArray(obj.aprop); }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">obj)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s0">// Check that getPropertyNames doesn't return non-enumerable</span>
  <span class="s0">// properties.</span>
  <span class="s1">obj = function(</span>
            <span class="s3">&quot;function () {&quot;</span>
            <span class="s3">&quot;  obj = {};&quot;</span>
            <span class="s3">&quot;  obj.a = 1;&quot;</span>
            <span class="s3">&quot;  Object.defineProperty(obj, 'b', {&quot;</span>
            <span class="s3">&quot;    enumerable: false,&quot;</span>
            <span class="s3">&quot;    value: 2&quot;</span>
            <span class="s3">&quot;  });&quot;</span>
            <span class="s3">&quot;  return obj;&quot;</span>
            <span class="s3">&quot;}&quot;</span><span class="s1">)</span>
            <span class="s1">.call(rt)</span>
            <span class="s1">.getObject(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(obj.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;a&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(obj.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;b&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Array names = obj.getPropertyNames(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(names.size(rt)</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(names.getValueAtIndex(rt</span><span class="s4">, </span><span class="s5">0</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;a&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">HostObjectTest) {</span>
  <span class="s4">class </span><span class="s1">ConstantHostObject : </span><span class="s4">public </span><span class="s1">HostObject {</span>
    <span class="s1">Value get(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym) override {</span>
      <span class="s4">return </span><span class="s5">9000</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">set(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp;</span><span class="s4">, const </span><span class="s1">Value&amp;) override {}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Object cho =</span>
      <span class="s1">Object::createFromHostObject(rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;ConstantHostObject&gt;())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return obj.someRandomProp == 9000; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">cho)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(cho.isHostObject(rt))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(cho.getHostObject&lt;ConstantHostObject&gt;(rt).get() != </span><span class="s4">nullptr</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s4">struct </span><span class="s1">SameRuntimeHostObject : HostObject {</span>
    <span class="s1">SameRuntimeHostObject(Runtime&amp; rt) : rt_(rt){}</span><span class="s4">;</span>

    <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym) override {</span>
      <span class="s1">EXPECT_EQ(&amp;rt</span><span class="s4">, </span><span class="s1">&amp;rt_)</span><span class="s4">;</span>
      <span class="s4">return </span><span class="s1">Value()</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">set(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name</span><span class="s4">, const </span><span class="s1">Value&amp; value) override {</span>
      <span class="s1">EXPECT_EQ(&amp;rt</span><span class="s4">, </span><span class="s1">&amp;rt_)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">std::vector&lt;PropNameID&gt; getPropertyNames(Runtime&amp; rt) override {</span>
      <span class="s1">EXPECT_EQ(&amp;rt</span><span class="s4">, </span><span class="s1">&amp;rt_)</span><span class="s4">;</span>
      <span class="s4">return </span><span class="s1">{}</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">Runtime&amp; rt_</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Object srho = Object::createFromHostObject(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;SameRuntimeHostObject&gt;(rt))</span><span class="s4">;</span>
  <span class="s0">// Test get's Runtime is as expected</span>
  <span class="s1">function(</span><span class="s3">&quot;function (obj) { return obj.isSame; }&quot;</span><span class="s1">).call(rt</span><span class="s4">, </span><span class="s1">srho)</span><span class="s4">;</span>
  <span class="s0">// ... and set</span>
  <span class="s1">function(</span><span class="s3">&quot;function (obj) { obj['k'] = 'v'; }&quot;</span><span class="s1">).call(rt</span><span class="s4">, </span><span class="s1">srho)</span><span class="s4">;</span>
  <span class="s0">// ... and getPropertyNames</span>
  <span class="s1">function(</span><span class="s3">&quot;function (obj) { for (k in obj) {} }&quot;</span><span class="s1">).call(rt</span><span class="s4">, </span><span class="s1">srho)</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">TwiceHostObject : </span><span class="s4">public </span><span class="s1">HostObject {</span>
    <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym) override {</span>
      <span class="s4">return </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">sym.utf8(rt) + sym.utf8(rt))</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">set(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp;</span><span class="s4">, const </span><span class="s1">Value&amp;) override {}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Object tho =</span>
      <span class="s1">Object::createFromHostObject(rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;TwiceHostObject&gt;())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return obj.abc == 'abcabc'; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">tho)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return obj['def'] == 'defdef'; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">tho)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return obj[12] === '1212'; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">tho)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(tho.isHostObject(rt))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">std::dynamic_pointer_cast&lt;ConstantHostObject&gt;(tho.getHostObject(rt)) ==</span>
      <span class="s4">nullptr</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(tho.getHostObject&lt;TwiceHostObject&gt;(rt).get() != </span><span class="s4">nullptr</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">PropNameIDHostObject : </span><span class="s4">public </span><span class="s1">HostObject {</span>
    <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym) override {</span>
      <span class="s4">if </span><span class="s1">(PropNameID::compare(rt</span><span class="s4">, </span><span class="s1">sym</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;undef&quot;</span><span class="s1">))) {</span>
        <span class="s4">return </span><span class="s1">Value::undefined()</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s4">return </span><span class="s1">PropNameID::compare(</span>
            <span class="s1">rt</span><span class="s4">, </span><span class="s1">sym</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;somesymbol&quot;</span><span class="s1">))</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">set(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp;</span><span class="s4">, const </span><span class="s1">Value&amp;) override {}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Object sho = Object::createFromHostObject(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;PropNameIDHostObject&gt;())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(sho.isHostObject(rt))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return obj.undef; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">sho)</span>
                  <span class="s1">.isUndefined())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return obj.somesymbol; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">sho)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(function(</span><span class="s3">&quot;function (obj) { return obj.notsomuch; }&quot;</span><span class="s1">)</span>
                   <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">sho)</span>
                   <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">BagHostObject : </span><span class="s4">public </span><span class="s1">HostObject {</span>
   <span class="s4">public</span><span class="s1">:</span>
    <span class="s4">const </span><span class="s1">std::string&amp; getThing() {</span>
      <span class="s4">return </span><span class="s1">bag_[</span><span class="s3">&quot;thing&quot;</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">}</span>

   <span class="s4">private</span><span class="s1">:</span>
    <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym) override {</span>
      <span class="s4">if </span><span class="s1">(sym.utf8(rt) == </span><span class="s3">&quot;thing&quot;</span><span class="s1">) {</span>
        <span class="s4">return </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">bag_[sym.utf8(rt)])</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s4">return </span><span class="s1">Value::undefined()</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">set(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym</span><span class="s4">, const </span><span class="s1">Value&amp; val) override {</span>
      <span class="s1">std::string key(sym.utf8(rt))</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(key == </span><span class="s3">&quot;thing&quot;</span><span class="s1">) {</span>
        <span class="s1">bag_[key] = val.toString(rt).utf8(rt)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">std::unordered_map&lt;std::string</span><span class="s4">, </span><span class="s1">std::string&gt; bag_</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">std::shared_ptr&lt;BagHostObject&gt; shbho = std::make_shared&lt;BagHostObject&gt;()</span><span class="s4">;</span>
  <span class="s1">Object bho = Object::createFromHostObject(rt</span><span class="s4">, </span><span class="s1">shbho)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(bho.isHostObject(rt))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return obj.undef; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">bho)</span>
                  <span class="s1">.isUndefined())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">function(</span><span class="s3">&quot;function (obj) { obj.thing = 'hello'; return obj.thing; }&quot;</span><span class="s1">)</span>
          <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">bho)</span>
          <span class="s1">.toString(rt)</span>
          <span class="s1">.utf8(rt)</span><span class="s4">,</span>
      <span class="s3">&quot;hello&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(shbho-&gt;getThing()</span><span class="s4">, </span><span class="s3">&quot;hello&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">ThrowingHostObject : </span><span class="s4">public </span><span class="s1">HostObject {</span>
    <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym) override {</span>
      <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;Cannot get&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">set(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym</span><span class="s4">, const </span><span class="s1">Value&amp; val) override {</span>
      <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;Cannot set&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Object thro =</span>
      <span class="s1">Object::createFromHostObject(rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;ThrowingHostObject&gt;())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(thro.isHostObject(rt))</span><span class="s4">;</span>
  <span class="s1">std::string exc</span><span class="s4">;</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">function(</span><span class="s3">&quot;function (obj) { return obj.thing; }&quot;</span><span class="s1">).call(rt</span><span class="s4">, </span><span class="s1">thro)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSError&amp; ex) {</span>
    <span class="s1">exc = ex.what()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">EXPECT_NE(exc.find(</span><span class="s3">&quot;Cannot get&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">std::string::npos)</span><span class="s4">;</span>
  <span class="s1">exc = </span><span class="s3">&quot;&quot;</span><span class="s4">;</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">function(</span><span class="s3">&quot;function (obj) { obj.thing = 'hello'; }&quot;</span><span class="s1">).call(rt</span><span class="s4">, </span><span class="s1">thro)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSError&amp; ex) {</span>
    <span class="s1">exc = ex.what()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">EXPECT_NE(exc.find(</span><span class="s3">&quot;Cannot set&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">std::string::npos)</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">NopHostObject : </span><span class="s4">public </span><span class="s1">HostObject {}</span><span class="s4">;</span>
  <span class="s1">Object nopHo =</span>
      <span class="s1">Object::createFromHostObject(rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;NopHostObject&gt;())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(nopHo.isHostObject(rt))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function (obj) { return obj.thing; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">nopHo)</span>
                  <span class="s1">.isUndefined())</span><span class="s4">;</span>

  <span class="s1">std::string nopExc</span><span class="s4">;</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">function(</span><span class="s3">&quot;function (obj) { obj.thing = 'pika'; }&quot;</span><span class="s1">).call(rt</span><span class="s4">, </span><span class="s1">nopHo)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSError&amp; ex) {</span>
    <span class="s1">nopExc = ex.what()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">EXPECT_NE(nopExc.find(</span><span class="s3">&quot;TypeError: &quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">std::string::npos)</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">HostObjectWithPropertyNames : </span><span class="s4">public </span><span class="s1">HostObject {</span>
    <span class="s1">std::vector&lt;PropNameID&gt; getPropertyNames(Runtime&amp; rt) override {</span>
      <span class="s4">return </span><span class="s1">PropNameID::names(</span>
          <span class="s1">rt</span><span class="s4">, </span><span class="s3">&quot;a_prop&quot;</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s4">, </span><span class="s3">&quot;false&quot;</span><span class="s4">, </span><span class="s3">&quot;a_prop&quot;</span><span class="s4">, </span><span class="s3">&quot;3&quot;</span><span class="s4">, </span><span class="s3">&quot;c_prop&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Object howpn = Object::createFromHostObject(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;HostObjectWithPropertyNames&gt;())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">function(</span>
          <span class="s3">&quot;function (o) { return Object.getOwnPropertyNames(o).length == 5 }&quot;</span><span class="s1">)</span>
          <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">howpn)</span>
          <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">hasOwnPropertyName = function(</span>
      <span class="s3">&quot;function (o, p) {&quot;</span>
      <span class="s3">&quot;  return Object.getOwnPropertyNames(o).indexOf(p) &gt;= 0&quot;</span>
      <span class="s3">&quot;}&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">hasOwnPropertyName.call(rt</span><span class="s4">, </span><span class="s1">howpn</span><span class="s4">, </span><span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;a_prop&quot;</span><span class="s1">))</span>
          <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">hasOwnPropertyName.call(rt</span><span class="s4">, </span><span class="s1">howpn</span><span class="s4">, </span><span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">))</span>
          <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">hasOwnPropertyName.call(rt</span><span class="s4">, </span><span class="s1">howpn</span><span class="s4">, </span><span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;false&quot;</span><span class="s1">))</span>
          <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">hasOwnPropertyName.call(rt</span><span class="s4">, </span><span class="s1">howpn</span><span class="s4">, </span><span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;3&quot;</span><span class="s1">))</span>
          <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">hasOwnPropertyName.call(rt</span><span class="s4">, </span><span class="s1">howpn</span><span class="s4">, </span><span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;c_prop&quot;</span><span class="s1">))</span>
          <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(hasOwnPropertyName</span>
                   <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">howpn</span><span class="s4">, </span><span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;not_existing&quot;</span><span class="s1">))</span>
                   <span class="s1">.getBool())</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">HostObjectProtoTest) {</span>
  <span class="s4">class </span><span class="s1">ProtoHostObject : </span><span class="s4">public </span><span class="s1">HostObject {</span>
    <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp;) override {</span>
      <span class="s4">return </span><span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;phoprop&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">rt.global().setProperty(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s3">&quot;pho&quot;</span><span class="s4">,</span>
      <span class="s1">Object::createFromHostObject(rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;ProtoHostObject&gt;()))</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">eval(</span><span class="s3">&quot;({__proto__: pho})[Symbol.toPrimitive]&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">,</span>
      <span class="s3">&quot;phoprop&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">ArrayTest) {</span>
  <span class="s1">eval(</span><span class="s3">&quot;x = {1:2, '3':4, 5:'six', 'seven':['eight', 'nine']}&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">Object x = rt.global().getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;x&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Array names = x.getPropertyNames(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(names.size(rt)</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">std::unordered_set&lt;std::string&gt; strNames</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(size_t i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; names.size(rt)</span><span class="s4">; </span><span class="s1">++i) {</span>
    <span class="s1">Value n = names.getValueAtIndex(rt</span><span class="s4">, </span><span class="s1">i)</span><span class="s4">;</span>
    <span class="s1">EXPECT_TRUE(n.isString())</span><span class="s4">;</span>
    <span class="s1">strNames.insert(n.getString(rt).utf8(rt))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">EXPECT_EQ(strNames.size()</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(strNames.count(</span><span class="s3">&quot;1&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(strNames.count(</span><span class="s3">&quot;3&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(strNames.count(</span><span class="s3">&quot;5&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(strNames.count(</span><span class="s3">&quot;seven&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">Object seven = x.getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;seven&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Array arr = seven.getArray(rt)</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(arr.size(rt)</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(arr.getValueAtIndex(rt</span><span class="s4">, </span><span class="s5">0</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;eight&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(arr.getValueAtIndex(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;nine&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s0">// TODO: test out of range</span>

  <span class="s1">EXPECT_EQ(x.getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;seven&quot;</span><span class="s1">).getArray(rt).size(rt)</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s0">// Check that property access with both symbols and strings can access</span>
  <span class="s0">// array values.</span>
  <span class="s1">EXPECT_EQ(seven.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;0&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;eight&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(seven.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;nine&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">seven.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s4">, </span><span class="s3">&quot;modified&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(seven.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;modified&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(arr.getValueAtIndex(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;modified&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">seven.getProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;0&quot;</span><span class="s1">))</span>
          <span class="s1">.getString(rt)</span>
          <span class="s1">.utf8(rt)</span><span class="s4">,</span>
      <span class="s3">&quot;eight&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">seven.setProperty(rt</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;0&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;modified2&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(arr.getValueAtIndex(rt</span><span class="s4">, </span><span class="s5">0</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;modified2&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">Array alpha = Array(rt</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(alpha.getValueAtIndex(rt</span><span class="s4">, </span><span class="s5">0</span><span class="s1">).isUndefined())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(alpha.getValueAtIndex(rt</span><span class="s4">, </span><span class="s5">3</span><span class="s1">).isUndefined())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(alpha.size(rt)</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">alpha.setValueAtIndex(rt</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s3">&quot;a&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">alpha.setValueAtIndex(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(alpha.length(rt)</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">alpha.setValueAtIndex(rt</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">alpha.setValueAtIndex(rt</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s3">&quot;d&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(alpha.size(rt)</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">function(</span>
          <span class="s3">&quot;function (arr) { return &quot;</span>
          <span class="s3">&quot;arr.length == 4 &amp;&amp; &quot;</span>
          <span class="s3">&quot;['a','b','c','d'].every(function(v,i) { return v === arr[i]}); }&quot;</span><span class="s1">)</span>
          <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">alpha)</span>
          <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s1">Array alpha2 = Array(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">alpha2 = std::move(alpha)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(alpha2.size(rt)</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">FunctionTest) {</span>
  <span class="s0">// test move ctor</span>
  <span class="s1">Function fmove = function(</span><span class="s3">&quot;function() { return 1 }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">{</span>
    <span class="s1">Function g = function(</span><span class="s3">&quot;function() { return 2 }&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">fmove = std::move(g)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">EXPECT_EQ(fmove.call(rt).getNumber()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s0">// This tests all the function argument converters, and all the</span>
  <span class="s0">// non-lvalue overloads of call().</span>
  <span class="s1">Function f = function(</span>
      <span class="s3">&quot;function(n, b, d, df, i, s1, s2, s3, s_sun, s_bad, o, a, f, v) { &quot;</span>
      <span class="s3">&quot;return &quot;</span>
      <span class="s3">&quot;n === null &amp;&amp; &quot;</span>
      <span class="s3">&quot;b === true &amp;&amp; &quot;</span>
      <span class="s3">&quot;d === 3.14 &amp;&amp; &quot;</span>
      <span class="s3">&quot;Math.abs(df - 2.71) &lt; 0.001 &amp;&amp; &quot;</span>
      <span class="s3">&quot;i === 17 &amp;&amp; &quot;</span>
      <span class="s3">&quot;s1 == 's1' &amp;&amp; &quot;</span>
      <span class="s3">&quot;s2 == 's2' &amp;&amp; &quot;</span>
      <span class="s3">&quot;s3 == 's3' &amp;&amp; &quot;</span>
      <span class="s3">&quot;s_sun == 's</span><span class="s4">\\</span><span class="s3">u2600' &amp;&amp; &quot;</span>
      <span class="s3">&quot;typeof s_bad == 'string' &amp;&amp; &quot;</span>
      <span class="s3">&quot;typeof o == 'object' &amp;&amp; &quot;</span>
      <span class="s3">&quot;Array.isArray(a) &amp;&amp; &quot;</span>
      <span class="s3">&quot;typeof f == 'function' &amp;&amp; &quot;</span>
      <span class="s3">&quot;v == 42 }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(f.call(</span>
                   <span class="s1">rt</span><span class="s4">,</span>
                   <span class="s4">nullptr,</span>
                   <span class="s4">true,</span>
                   <span class="s5">3.14</span><span class="s4">,</span>
                   <span class="s5">2.71f</span><span class="s4">,</span>
                   <span class="s5">17</span><span class="s4">,</span>
                   <span class="s3">&quot;s1&quot;</span><span class="s4">,</span>
                   <span class="s1">String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;s2&quot;</span><span class="s1">)</span><span class="s4">,</span>
                   <span class="s1">std::string{</span><span class="s3">&quot;s3&quot;</span><span class="s1">}</span><span class="s4">,</span>
                   <span class="s1">std::string{</span><span class="s4">u8</span><span class="s3">&quot;s</span><span class="s4">\u2600</span><span class="s3">&quot;</span><span class="s1">}</span><span class="s4">,</span>
                   <span class="s0">// invalid UTF8 sequence due to unexpected continuation byte</span>
                   <span class="s1">std::string{</span><span class="s3">&quot;s</span><span class="s4">\x80</span><span class="s3">&quot;</span><span class="s1">}</span><span class="s4">,</span>
                   <span class="s1">Object(rt)</span><span class="s4">,</span>
                   <span class="s1">Array(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
                   <span class="s1">function(</span><span class="s3">&quot;function(){}&quot;</span><span class="s1">)</span><span class="s4">,</span>
                   <span class="s1">Value(</span><span class="s5">42</span><span class="s1">))</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s0">// lvalue overloads of call()</span>
  <span class="s1">Function flv = function(</span>
      <span class="s3">&quot;function(s, o, a, f, v) { return &quot;</span>
      <span class="s3">&quot;s == 's' &amp;&amp; &quot;</span>
      <span class="s3">&quot;typeof o == 'object' &amp;&amp; &quot;</span>
      <span class="s3">&quot;Array.isArray(a) &amp;&amp; &quot;</span>
      <span class="s3">&quot;typeof f == 'function' &amp;&amp; &quot;</span>
      <span class="s3">&quot;v == 42 }&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">String s = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;s&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Object o = Object(rt)</span><span class="s4">;</span>
  <span class="s1">Array a = Array(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Value v = </span><span class="s5">42</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(flv.call(rt</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">o</span><span class="s4">, </span><span class="s1">a</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">v).getBool())</span><span class="s4">;</span>

  <span class="s1">Function f1 = function(</span><span class="s3">&quot;function() { return 1; }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Function f2 = function(</span><span class="s3">&quot;function() { return 2; }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">f2 = std::move(f1)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(f2.call(rt).getNumber()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">FunctionThisTest) {</span>
  <span class="s1">Function checkPropertyFunction =</span>
      <span class="s1">function(</span><span class="s3">&quot;function() { return this.a === 'a_property' }&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">Object jsObject = Object(rt)</span><span class="s4">;</span>
  <span class="s1">jsObject.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;a&quot;</span><span class="s4">, </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s3">&quot;a_property&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">APropertyHostObject : </span><span class="s4">public </span><span class="s1">HostObject {</span>
    <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; sym) override {</span>
      <span class="s4">return </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s3">&quot;a_property&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">set(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp;</span><span class="s4">, const </span><span class="s1">Value&amp;) override {}</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">Object hostObject =</span>
      <span class="s1">Object::createFromHostObject(rt</span><span class="s4">, </span><span class="s1">std::make_shared&lt;APropertyHostObject&gt;())</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(checkPropertyFunction.callWithThis(rt</span><span class="s4">, </span><span class="s1">jsObject).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkPropertyFunction.callWithThis(rt</span><span class="s4">, </span><span class="s1">hostObject).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(checkPropertyFunction.callWithThis(rt</span><span class="s4">, </span><span class="s1">Array(rt</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(checkPropertyFunction.call(rt).getBool())</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">FunctionConstructorTest) {</span>
  <span class="s1">Function ctor = function(</span>
      <span class="s3">&quot;function (a) {&quot;</span>
      <span class="s3">&quot;  if (typeof a !== 'undefined') {&quot;</span>
      <span class="s3">&quot;   this.pika = a;&quot;</span>
      <span class="s3">&quot;  }&quot;</span>
      <span class="s3">&quot;}&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">ctor.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;prototype&quot;</span><span class="s1">)</span>
      <span class="s1">.getObject(rt)</span>
      <span class="s1">.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;pika&quot;</span><span class="s4">, </span><span class="s3">&quot;chu&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">empty = ctor.callAsConstructor(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(empty.isObject())</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">emptyObj = std::move(empty).getObject(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(emptyObj.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;pika&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;chu&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">who = ctor.callAsConstructor(rt</span><span class="s4">, </span><span class="s3">&quot;who&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(who.isObject())</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">whoObj = std::move(who).getObject(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(whoObj.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;pika&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;who&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">instanceof = function(</span><span class="s3">&quot;function (o, b) { return o instanceof b; }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(instanceof.call(rt</span><span class="s4">, </span><span class="s1">emptyObj</span><span class="s4">, </span><span class="s1">ctor).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(instanceof.call(rt</span><span class="s4">, </span><span class="s1">whoObj</span><span class="s4">, </span><span class="s1">ctor).getBool())</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">dateCtor = rt.global().getPropertyAsFunction(rt</span><span class="s4">, </span><span class="s3">&quot;Date&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">date = dateCtor.callAsConstructor(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(date.isObject())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(instanceof.call(rt</span><span class="s4">, </span><span class="s1">date</span><span class="s4">, </span><span class="s1">dateCtor).getBool())</span><span class="s4">;</span>
  <span class="s0">// Sleep for 50 milliseconds</span>
  <span class="s1">std::this_thread::sleep_for(std::chrono::milliseconds(</span><span class="s5">50</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_GE(</span>
      <span class="s1">function(</span><span class="s3">&quot;function (d) { return (new Date()).getTime() - d.getTime(); }&quot;</span><span class="s1">)</span>
          <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">date)</span>
          <span class="s1">.getNumber()</span><span class="s4">,</span>
      <span class="s5">50</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">InstanceOfTest) {</span>
  <span class="s4">auto </span><span class="s1">ctor = function(</span><span class="s3">&quot;function Rick() { this.say = 'wubalubadubdub'; }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">newObj = function(</span><span class="s3">&quot;function (ctor) { return new ctor(); }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">instance = newObj.call(rt</span><span class="s4">, </span><span class="s1">ctor).getObject(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(instance.instanceOf(rt</span><span class="s4">, </span><span class="s1">ctor))</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">instance.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;say&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;wubalubadubdub&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Object(rt).instanceOf(rt</span><span class="s4">, </span><span class="s1">ctor))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(ctor.callAsConstructor(rt</span><span class="s4">, nullptr, </span><span class="s5">0</span><span class="s1">)</span>
                  <span class="s1">.getObject(rt)</span>
                  <span class="s1">.instanceOf(rt</span><span class="s4">, </span><span class="s1">ctor))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">HostFunctionTest) {</span>
  <span class="s4">auto </span><span class="s1">one = std::make_shared&lt;</span><span class="s4">int</span><span class="s1">&gt;(</span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Function plusOne = Function::createFromHostFunction(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;plusOne&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">2</span><span class="s4">,</span>
      <span class="s1">[one</span><span class="s4">, </span><span class="s1">savedRt = &amp;rt](</span>
          <span class="s1">Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp; thisVal</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) {</span>
        <span class="s1">EXPECT_EQ(savedRt</span><span class="s4">, </span><span class="s1">&amp;rt)</span><span class="s4">;</span>
        <span class="s0">// We don't know if we're in strict mode or not, so it's either global</span>
        <span class="s0">// or undefined.</span>
        <span class="s1">EXPECT_TRUE(</span>
            <span class="s1">Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">thisVal</span><span class="s4">, </span><span class="s1">rt.global()) ||</span>
            <span class="s1">thisVal.isUndefined())</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">*one + args[</span><span class="s5">0</span><span class="s1">].getNumber() + args[</span><span class="s5">1</span><span class="s1">].getNumber()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(plusOne.call(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(plusOne.call(rt</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;9&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">rt.global().setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;plusOne&quot;</span><span class="s4">, </span><span class="s1">plusOne)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;plusOne(20, 300) == 321&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>

  <span class="s1">Function dot = Function::createFromHostFunction(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;dot&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">2</span><span class="s4">,</span>
      <span class="s1">[](Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp; thisVal</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) {</span>
        <span class="s1">EXPECT_TRUE(</span>
            <span class="s1">Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">thisVal</span><span class="s4">, </span><span class="s1">rt.global()) ||</span>
            <span class="s1">thisVal.isUndefined())</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(count != </span><span class="s5">2</span><span class="s1">) {</span>
          <span class="s4">throw </span><span class="s1">std::runtime_error(</span><span class="s3">&quot;expected 2 args&quot;</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s1">std::string ret = args[</span><span class="s5">0</span><span class="s1">].getString(rt).utf8(rt) + </span><span class="s3">&quot;.&quot; </span><span class="s1">+</span>
            <span class="s1">args[</span><span class="s5">1</span><span class="s1">].getString(rt).utf8(rt)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">String::createFromUtf8(</span>
            <span class="s1">rt</span><span class="s4">, reinterpret_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">uint8_t*&gt;(ret.data())</span><span class="s4">, </span><span class="s1">ret.size())</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">rt.global().setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;cons&quot;</span><span class="s4">, </span><span class="s1">dot)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;cons('left', 'right') == 'left.right'&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;cons.name == 'dot'&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;cons.length == 2&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;cons instanceof Function&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;(function() {&quot;</span>
                   <span class="s3">&quot;  try {&quot;</span>
                   <span class="s3">&quot;    cons('fail'); return false;&quot;</span>
                   <span class="s3">&quot;  } catch (e) {&quot;</span>
                   <span class="s3">&quot;    return ((e instanceof Error) &amp;&amp;&quot;</span>
                   <span class="s3">&quot;            (e.message == 'Exception in HostFunction: ' +&quot;</span>
                   <span class="s3">&quot;                          'expected 2 args'));&quot;</span>
                   <span class="s3">&quot;  }})()&quot;</span><span class="s1">)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s1">Function coolify = Function::createFromHostFunction(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;coolify&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">0</span><span class="s4">,</span>
      <span class="s1">[](Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp; thisVal</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) {</span>
        <span class="s1">EXPECT_EQ(count</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">std::string ret = thisVal.toString(rt).utf8(rt) + </span><span class="s3">&quot; is cool&quot;</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">String::createFromUtf8(</span>
            <span class="s1">rt</span><span class="s4">, reinterpret_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">uint8_t*&gt;(ret.data())</span><span class="s4">, </span><span class="s1">ret.size())</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">rt.global().setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;coolify&quot;</span><span class="s4">, </span><span class="s1">coolify)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;coolify.name == 'coolify'&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;coolify.length == 0&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;coolify.bind('R&amp;M')() == 'R&amp;M is cool'&quot;</span><span class="s1">).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;(function() {&quot;</span>
                   <span class="s3">&quot;  var s = coolify.bind(function(){})();&quot;</span>
                   <span class="s3">&quot;  return s.lastIndexOf(' is cool') == (s.length - 8);&quot;</span>
                   <span class="s3">&quot;})()&quot;</span><span class="s1">)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s1">Function lookAtMe = Function::createFromHostFunction(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;lookAtMe&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">0</span><span class="s4">,</span>
      <span class="s1">[](Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp; thisVal</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count)</span>
          <span class="s1">-&gt; Value {</span>
        <span class="s1">EXPECT_TRUE(thisVal.isObject())</span><span class="s4">;</span>
        <span class="s1">EXPECT_EQ(</span>
            <span class="s1">thisVal.getObject(rt)</span>
                <span class="s1">.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
                <span class="s1">.getString(rt)</span>
                <span class="s1">.utf8(rt)</span><span class="s4">,</span>
            <span class="s3">&quot;mr.meeseeks&quot;</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">Value()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">rt.global().setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;lookAtMe&quot;</span><span class="s4">, </span><span class="s1">lookAtMe)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;lookAtMe.bind({'name': 'mr.meeseeks'})()&quot;</span><span class="s1">).isUndefined())</span><span class="s4">;</span>

  <span class="s4">struct </span><span class="s1">Callable {</span>
    <span class="s1">Callable(std::string s) : str(s) {}</span>

    <span class="s1">Value</span>
    <span class="s4">operator</span><span class="s1">()(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp;</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) {</span>
      <span class="s4">if </span><span class="s1">(count != </span><span class="s5">1</span><span class="s1">) {</span>
        <span class="s4">return </span><span class="s1">Value()</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s4">return </span><span class="s1">String::createFromUtf8(</span>
          <span class="s1">rt</span><span class="s4">, </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">].toString(rt).utf8(rt) + </span><span class="s3">&quot; was called with &quot; </span><span class="s1">+ str)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">std::string str</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Function callable = Function::createFromHostFunction(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;callable&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">1</span><span class="s4">,</span>
      <span class="s1">Callable(</span><span class="s3">&quot;std::function::target&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">function(</span><span class="s3">&quot;function (f) { return f('A cat'); }&quot;</span><span class="s1">)</span>
          <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">callable)</span>
          <span class="s1">.getString(rt)</span>
          <span class="s1">.utf8(rt)</span><span class="s4">,</span>
      <span class="s3">&quot;A cat was called with std::function::target&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(callable.isHostFunction(rt))</span><span class="s4">;</span>
  <span class="s1">EXPECT_NE(callable.getHostFunction(rt).target&lt;Callable&gt;()</span><span class="s4">, nullptr</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">std::string strval = </span><span class="s3">&quot;strval1&quot;</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">getter = Object(rt)</span><span class="s4">;</span>
  <span class="s1">getter.setProperty(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s3">&quot;get&quot;</span><span class="s4">,</span>
      <span class="s1">Function::createFromHostFunction(</span>
          <span class="s1">rt</span><span class="s4">,</span>
          <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;getter&quot;</span><span class="s1">)</span><span class="s4">,</span>
          <span class="s5">1</span><span class="s4">,</span>
          <span class="s1">[&amp;strval](</span>
              <span class="s1">Runtime&amp; rt</span><span class="s4">,</span>
              <span class="s4">const </span><span class="s1">Value&amp; thisVal</span><span class="s4">,</span>
              <span class="s4">const </span><span class="s1">Value* args</span><span class="s4">,</span>
              <span class="s1">size_t count) -&gt; Value {</span>
            <span class="s4">return </span><span class="s1">String::createFromUtf8(rt</span><span class="s4">, </span><span class="s1">strval)</span><span class="s4">;</span>
          <span class="s1">}))</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">obj = Object(rt)</span><span class="s4">;</span>
  <span class="s1">rt.global()</span>
      <span class="s1">.getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;Object&quot;</span><span class="s1">)</span>
      <span class="s1">.getPropertyAsFunction(rt</span><span class="s4">, </span><span class="s3">&quot;defineProperty&quot;</span><span class="s1">)</span>
      <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s3">&quot;prop&quot;</span><span class="s4">, </span><span class="s1">getter)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function(value) { return value.prop == 'strval1'; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">obj)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>
  <span class="s1">strval = </span><span class="s3">&quot;strval2&quot;</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function(value) { return value.prop == 'strval2'; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">obj)</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">ValueTest) {</span>
  <span class="s1">EXPECT_TRUE(checkValue(Value::undefined()</span><span class="s4">, </span><span class="s3">&quot;undefined&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(Value()</span><span class="s4">, </span><span class="s3">&quot;undefined&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(Value::null()</span><span class="s4">, </span><span class="s3">&quot;null&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(</span><span class="s4">nullptr, </span><span class="s3">&quot;null&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(checkValue(Value(</span><span class="s4">false</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;false&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(</span><span class="s4">false, </span><span class="s3">&quot;false&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(</span><span class="s4">true, </span><span class="s3">&quot;true&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(checkValue(Value(</span><span class="s5">1.5</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;1.5&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(</span><span class="s5">2.5</span><span class="s4">, </span><span class="s3">&quot;2.5&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(checkValue(Value(</span><span class="s5">10</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;10&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(</span><span class="s5">20</span><span class="s4">, </span><span class="s3">&quot;20&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(</span><span class="s5">30</span><span class="s4">, </span><span class="s3">&quot;30&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s0">// rvalue implicit conversion</span>
  <span class="s1">EXPECT_TRUE(checkValue(String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;one&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;'one'&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s0">// lvalue explicit copy</span>
  <span class="s1">String s = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;two&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkValue(Value(rt</span><span class="s4">, </span><span class="s1">s)</span><span class="s4">, </span><span class="s3">&quot;'two'&quot;</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">{</span>
    <span class="s0">// rvalue assignment of trivial value</span>
    <span class="s1">Value v1 = </span><span class="s5">100</span><span class="s4">;</span>
    <span class="s1">Value v2 = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;hundred&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">v2 = std::move(v1)</span><span class="s4">;</span>
    <span class="s1">EXPECT_TRUE(v2.isNumber())</span><span class="s4">;</span>
    <span class="s1">EXPECT_EQ(v2.getNumber()</span><span class="s4">, </span><span class="s5">100</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s0">// rvalue assignment of js heap value</span>
    <span class="s1">Value v1 = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;hundred&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">Value v2 = </span><span class="s5">100</span><span class="s4">;</span>
    <span class="s1">v2 = std::move(v1)</span><span class="s4">;</span>
    <span class="s1">EXPECT_TRUE(v2.isString())</span><span class="s4">;</span>
    <span class="s1">EXPECT_EQ(v2.getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;hundred&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Object o = Object(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(function(</span><span class="s3">&quot;function(value) { return typeof(value) == 'object'; }&quot;</span><span class="s1">)</span>
                  <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">o))</span>
                  <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s1">uint8_t utf8[] = </span><span class="s3">&quot;[null, 2, </span><span class="s4">\&quot;</span><span class="s3">c</span><span class="s4">\&quot;</span><span class="s3">, </span><span class="s4">\&quot;</span><span class="s3">emoji: </span><span class="s4">\xf0\x9f\x86\x97\&quot;</span><span class="s3">, {}]&quot;</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(</span>
      <span class="s1">function(</span><span class="s3">&quot;function (arr) { return &quot;</span>
               <span class="s3">&quot;Array.isArray(arr) &amp;&amp; &quot;</span>
               <span class="s3">&quot;arr.length == 5 &amp;&amp; &quot;</span>
               <span class="s3">&quot;arr[0] === null &amp;&amp; &quot;</span>
               <span class="s3">&quot;arr[1] == 2 &amp;&amp; &quot;</span>
               <span class="s3">&quot;arr[2] == 'c' &amp;&amp; &quot;</span>
               <span class="s3">&quot;arr[3] == 'emoji: </span><span class="s4">\\</span><span class="s3">uD83C</span><span class="s4">\\</span><span class="s3">uDD97' &amp;&amp; &quot;</span>
               <span class="s3">&quot;typeof arr[4] == 'object'; }&quot;</span><span class="s1">)</span>
          <span class="s1">.call(rt</span><span class="s4">, </span><span class="s1">Value::createFromJsonUtf8(rt</span><span class="s4">, </span><span class="s1">utf8</span><span class="s4">, sizeof</span><span class="s1">(utf8) - </span><span class="s5">1</span><span class="s1">))</span>
          <span class="s1">.getBool())</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;undefined&quot;</span><span class="s1">).isUndefined())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;null&quot;</span><span class="s1">).isNull())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;true&quot;</span><span class="s1">).isBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;false&quot;</span><span class="s1">).isBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;123&quot;</span><span class="s1">).isNumber())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;123.4&quot;</span><span class="s1">).isNumber())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;'str'&quot;</span><span class="s1">).isString())</span><span class="s4">;</span>
  <span class="s0">// &quot;{}&quot; returns undefined.  empty code block?</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;({})&quot;</span><span class="s1">).isObject())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;[]&quot;</span><span class="s1">).isObject())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;(function(){})&quot;</span><span class="s1">).isObject())</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(eval(</span><span class="s3">&quot;123&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">123</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(eval(</span><span class="s3">&quot;123.4&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">123.4</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(eval(</span><span class="s3">&quot;'str'&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;str&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;[]&quot;</span><span class="s1">).getObject(rt).isArray(rt))</span><span class="s4">;</span>

  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;true&quot;</span><span class="s1">).asBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_THROW(eval(</span><span class="s3">&quot;123&quot;</span><span class="s1">).asBool()</span><span class="s4">, </span><span class="s1">JSIException)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(eval(</span><span class="s3">&quot;456&quot;</span><span class="s1">).asNumber()</span><span class="s4">, </span><span class="s5">456</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_THROW(eval(</span><span class="s3">&quot;'word'&quot;</span><span class="s1">).asNumber()</span><span class="s4">, </span><span class="s1">JSIException)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">eval(</span><span class="s3">&quot;({1:2, 3:4})&quot;</span><span class="s1">).asObject(rt).getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;1&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_THROW(eval(</span><span class="s3">&quot;'oops'&quot;</span><span class="s1">).asObject(rt)</span><span class="s4">, </span><span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(eval(</span><span class="s3">&quot;['zero',1,2,3]&quot;</span><span class="s1">).toString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;zero,1,2,3&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">EqualsTest) {</span>
  <span class="s1">EXPECT_TRUE(Object::strictEquals(rt</span><span class="s4">, </span><span class="s1">rt.global()</span><span class="s4">, </span><span class="s1">rt.global()))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Value::strictEquals(rt</span><span class="s4">, true, </span><span class="s5">1</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Value::strictEquals(rt</span><span class="s4">, true, false</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, false, false</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Value::strictEquals(rt</span><span class="s4">, nullptr, </span><span class="s5">1</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, nullptr, nullptr</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">Value::undefined()</span><span class="s4">, </span><span class="s1">Value()))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">rt.global()</span><span class="s4">, </span><span class="s1">Value(rt.global())))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Value::strictEquals(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">std::numeric_limits&lt;</span><span class="s4">double</span><span class="s1">&gt;::quiet_NaN()</span><span class="s4">,</span>
      <span class="s1">std::numeric_limits&lt;</span><span class="s4">double</span><span class="s1">&gt;::quiet_NaN()))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Value::strictEquals(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">std::numeric_limits&lt;</span><span class="s4">double</span><span class="s1">&gt;::signaling_NaN()</span><span class="s4">,</span>
      <span class="s1">std::numeric_limits&lt;</span><span class="s4">double</span><span class="s1">&gt;::signaling_NaN()))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">+</span><span class="s5">0.0</span><span class="s4">, </span><span class="s1">-</span><span class="s5">0.0</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">-</span><span class="s5">0.0</span><span class="s4">, </span><span class="s1">+</span><span class="s5">0.0</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">Function noop = Function::createFromHostFunction(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;noop&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">0</span><span class="s4">,</span>
      <span class="s1">[](</span><span class="s4">const </span><span class="s1">Runtime&amp;</span><span class="s4">, const </span><span class="s1">Value&amp;</span><span class="s4">, const </span><span class="s1">Value*</span><span class="s4">, </span><span class="s1">size_t) {</span>
        <span class="s4">return </span><span class="s1">Value()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">noopDup = Value(rt</span><span class="s4">, </span><span class="s1">noop).getObject(rt)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Object::strictEquals(rt</span><span class="s4">, </span><span class="s1">noop</span><span class="s4">, </span><span class="s1">noopDup))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Object::strictEquals(rt</span><span class="s4">, </span><span class="s1">noopDup</span><span class="s4">, </span><span class="s1">noop))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Object::strictEquals(rt</span><span class="s4">, </span><span class="s1">noop</span><span class="s4">, </span><span class="s1">rt.global()))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Object::strictEquals(rt</span><span class="s4">, </span><span class="s1">noop</span><span class="s4">, </span><span class="s1">noop))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">noop)</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">noop)))</span><span class="s4">;</span>

  <span class="s1">String str = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;rick&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">String strDup = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;rick&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">String otherStr = String::createFromAscii(rt</span><span class="s4">, </span><span class="s3">&quot;morty&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(String::strictEquals(rt</span><span class="s4">, </span><span class="s1">str</span><span class="s4">, </span><span class="s1">str))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(String::strictEquals(rt</span><span class="s4">, </span><span class="s1">str</span><span class="s4">, </span><span class="s1">strDup))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(String::strictEquals(rt</span><span class="s4">, </span><span class="s1">strDup</span><span class="s4">, </span><span class="s1">str))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(String::strictEquals(rt</span><span class="s4">, </span><span class="s1">str</span><span class="s4">, </span><span class="s1">otherStr))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">str)</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">str)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">str)</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">noop)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">str)</span><span class="s4">, </span><span class="s5">1.0</span><span class="s1">))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">ExceptionStackTraceTest) {</span>
  <span class="s4">static const char </span><span class="s1">invokeUndefinedScript[] =</span>
      <span class="s3">&quot;function hello() {&quot;</span>
      <span class="s3">&quot;  var a = {}; a.log(); }&quot;</span>
      <span class="s3">&quot;function world() { hello(); }&quot;</span>
      <span class="s3">&quot;world()&quot;</span><span class="s4">;</span>
  <span class="s1">std::string stack</span><span class="s4">;</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">rt.evaluateJavaScript(</span>
        <span class="s1">std::make_unique&lt;StringBuffer&gt;(invokeUndefinedScript)</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(JSError&amp; e) {</span>
    <span class="s1">stack = e.getStack()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">EXPECT_NE(stack.find(</span><span class="s3">&quot;world&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">std::string::npos)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">PreparedJavaScriptSourceTest) {</span>
  <span class="s1">rt.evaluateJavaScript(std::make_unique&lt;StringBuffer&gt;(</span><span class="s3">&quot;var q = 0;&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">prep = rt.prepareJavaScript(std::make_unique&lt;StringBuffer&gt;(</span><span class="s3">&quot;q++;&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(rt.global().getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;q&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">rt.evaluatePreparedJavaScript(prep)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(rt.global().getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;q&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">rt.evaluatePreparedJavaScript(prep)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(rt.global().getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;q&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">PreparedJavaScriptURLInBacktrace) {</span>
  <span class="s1">std::string sourceURL = </span><span class="s3">&quot;//PreparedJavaScriptURLInBacktrace/Test/URL&quot;</span><span class="s4">;</span>
  <span class="s1">std::string throwingSource =</span>
      <span class="s3">&quot;function thrower() { throw new Error('oops')}&quot;</span>
      <span class="s3">&quot;thrower();&quot;</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">prep = rt.prepareJavaScript(</span>
      <span class="s1">std::make_unique&lt;StringBuffer&gt;(throwingSource)</span><span class="s4">, </span><span class="s1">sourceURL)</span><span class="s4">;</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">rt.evaluatePreparedJavaScript(prep)</span><span class="s4">;</span>
    <span class="s1">FAIL() &lt;&lt; </span><span class="s3">&quot;prepareJavaScript should have thrown an exception&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(facebook::jsi::JSError err) {</span>
    <span class="s1">EXPECT_NE(std::string::npos</span><span class="s4">, </span><span class="s1">err.getStack().find(sourceURL))</span>
        <span class="s1">&lt;&lt; </span><span class="s3">&quot;Backtrace should contain source URL&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">namespace </span><span class="s1">{</span>

<span class="s4">unsigned </span><span class="s1">countOccurences(</span><span class="s4">const </span><span class="s1">std::string&amp; of</span><span class="s4">, const </span><span class="s1">std::string&amp; in) {</span>
  <span class="s4">unsigned </span><span class="s1">occurences = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">std::string::size_type lastOccurence = -</span><span class="s5">1</span><span class="s4">;</span>
  <span class="s4">while </span><span class="s1">((lastOccurence = in.find(of</span><span class="s4">, </span><span class="s1">lastOccurence + </span><span class="s5">1</span><span class="s1">)) !=</span>
         <span class="s1">std::string::npos) {</span>
    <span class="s1">occurences++</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">occurences</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">JSErrorsArePropagatedNicely) {</span>
  <span class="s4">unsigned </span><span class="s1">callsBeforeError = </span><span class="s5">5</span><span class="s4">;</span>

  <span class="s1">Function sometimesThrows = function(</span>
      <span class="s3">&quot;function sometimesThrows(shouldThrow, callback) {&quot;</span>
      <span class="s3">&quot;  if (shouldThrow) {&quot;</span>
      <span class="s3">&quot;    throw Error('Omg, what a nasty exception')&quot;</span>
      <span class="s3">&quot;  }&quot;</span>
      <span class="s3">&quot;  callback(callback);&quot;</span>
      <span class="s3">&quot;}&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">Function callback = Function::createFromHostFunction(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;callback&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">0</span><span class="s4">,</span>
      <span class="s1">[&amp;sometimesThrows</span><span class="s4">, </span><span class="s1">&amp;callsBeforeError](</span>
          <span class="s1">Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp; thisVal</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) {</span>
        <span class="s4">return </span><span class="s1">sometimesThrows.call(rt</span><span class="s4">, </span><span class="s1">--callsBeforeError == </span><span class="s5">0</span><span class="s4">, </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">])</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">sometimesThrows.call(rt</span><span class="s4">, false, </span><span class="s1">callback)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(JSError&amp; error) {</span>
    <span class="s1">EXPECT_EQ(error.getMessage()</span><span class="s4">, </span><span class="s3">&quot;Omg, what a nasty exception&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">EXPECT_EQ(countOccurences(</span><span class="s3">&quot;sometimesThrows&quot;</span><span class="s4">, </span><span class="s1">error.getStack())</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span><span class="s4">;</span>

    <span class="s0">// system JSC JSI does not implement host function names</span>
    <span class="s0">// EXPECT_EQ(countOccurences(&quot;callback&quot;, error.getStack(rt)), 5);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">JSErrorsCanBeConstructedWithStack) {</span>
  <span class="s4">auto </span><span class="s1">err = JSError(rt</span><span class="s4">, </span><span class="s3">&quot;message&quot;</span><span class="s4">, </span><span class="s3">&quot;stack&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(err.getMessage()</span><span class="s4">, </span><span class="s3">&quot;message&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(err.getStack()</span><span class="s4">, </span><span class="s3">&quot;stack&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">JSErrorDoesNotInfinitelyRecurse) {</span>
  <span class="s1">Value globalError = rt.global().getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;Error&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">rt.global().setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;Error&quot;</span><span class="s4">, </span><span class="s1">Value::undefined())</span><span class="s4">;</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">rt.global().getPropertyAsFunction(rt</span><span class="s4">, </span><span class="s3">&quot;NotAFunction&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">FAIL() &lt;&lt; </span><span class="s3">&quot;expected exception&quot;</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSError&amp; ex) {</span>
    <span class="s1">EXPECT_EQ(</span>
        <span class="s1">ex.getMessage()</span><span class="s4">,</span>
        <span class="s3">&quot;callGlobalFunction: JS global property 'Error' is undefined, &quot;</span>
        <span class="s3">&quot;expected a Function (while raising getPropertyAsObject: &quot;</span>
        <span class="s3">&quot;property 'NotAFunction' is undefined, expected an Object)&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// If Error is missing, this is fundamentally a problem with JS code</span>
  <span class="s0">// messing up the global object, so it should present in JS code as</span>
  <span class="s0">// a catchable string.  Not an Error (because that's broken), or as</span>
  <span class="s0">// a C++ failure.</span>

  <span class="s4">auto </span><span class="s1">fails = [](Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp;</span><span class="s4">, const </span><span class="s1">Value*</span><span class="s4">, </span><span class="s1">size_t) -&gt; Value {</span>
    <span class="s4">return </span><span class="s1">rt.global().getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;NotAProperty&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">function(</span><span class="s3">&quot;function (f) { try { f(); return 'undefined'; }&quot;</span>
               <span class="s3">&quot;catch (e) { return typeof e; } }&quot;</span><span class="s1">)</span>
          <span class="s1">.call(</span>
              <span class="s1">rt</span><span class="s4">,</span>
              <span class="s1">Function::createFromHostFunction(</span>
                  <span class="s1">rt</span><span class="s4">, </span><span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;fails&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">fails))</span>
          <span class="s1">.getString(rt)</span>
          <span class="s1">.utf8(rt)</span><span class="s4">,</span>
      <span class="s3">&quot;string&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">rt.global().setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;Error&quot;</span><span class="s4">, </span><span class="s1">globalError)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">JSErrorStackOverflowHandling) {</span>
  <span class="s1">rt.global().setProperty(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s3">&quot;callSomething&quot;</span><span class="s4">,</span>
      <span class="s1">Function::createFromHostFunction(</span>
          <span class="s1">rt</span><span class="s4">,</span>
          <span class="s1">PropNameID::forAscii(rt</span><span class="s4">, </span><span class="s3">&quot;callSomething&quot;</span><span class="s1">)</span><span class="s4">,</span>
          <span class="s5">0</span><span class="s4">,</span>
          <span class="s1">[</span><span class="s4">this</span><span class="s1">](</span>
              <span class="s1">Runtime&amp; rt2</span><span class="s4">,</span>
              <span class="s4">const </span><span class="s1">Value&amp; thisVal</span><span class="s4">,</span>
              <span class="s4">const </span><span class="s1">Value* args</span><span class="s4">,</span>
              <span class="s1">size_t count) {</span>
            <span class="s1">EXPECT_EQ(&amp;rt</span><span class="s4">, </span><span class="s1">&amp;rt2)</span><span class="s4">;</span>
            <span class="s4">return </span><span class="s1">function(</span><span class="s3">&quot;function() { return 0; }&quot;</span><span class="s1">).call(rt)</span><span class="s4">;</span>
          <span class="s1">}))</span><span class="s4">;</span>
  <span class="s4">try </span><span class="s1">{</span>
    <span class="s1">eval(</span><span class="s3">&quot;(function f() { callSomething(); f.apply(); })()&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">FAIL()</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s4">const </span><span class="s1">JSError&amp; ex) {</span>
    <span class="s1">EXPECT_NE(std::string(ex.what()).find(</span><span class="s3">&quot;exceeded&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">std::string::npos)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">ScopeDoesNotCrashTest) {</span>
  <span class="s1">Scope scope(rt)</span><span class="s4">;</span>
  <span class="s1">Object o(rt)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">ScopeDoesNotCrashWhenValueEscapes) {</span>
  <span class="s1">Value v</span><span class="s4">;</span>
  <span class="s1">Scope::callInNewScope(rt</span><span class="s4">, </span><span class="s1">[&amp;]() {</span>
    <span class="s1">Object o(rt)</span><span class="s4">;</span>
    <span class="s1">o.setProperty(rt</span><span class="s4">, </span><span class="s3">&quot;a&quot;</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">v = std::move(o)</span><span class="s4">;</span>
  <span class="s1">})</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(v.getObject(rt).getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;a&quot;</span><span class="s1">).getNumber()</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">// Verifies you can have a host object that emulates a normal object</span>
<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">HostObjectWithValueMembers) {</span>
  <span class="s4">class </span><span class="s1">Bag : </span><span class="s4">public </span><span class="s1">HostObject {</span>
   <span class="s4">public</span><span class="s1">:</span>
    <span class="s1">Bag() = </span><span class="s4">default;</span>

    <span class="s4">const </span><span class="s1">Value&amp; </span><span class="s4">operator</span><span class="s1">[](</span><span class="s4">const </span><span class="s1">std::string&amp; name) </span><span class="s4">const </span><span class="s1">{</span>
      <span class="s4">auto </span><span class="s1">iter = data_.find(name)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(iter == data_.end()) {</span>
        <span class="s4">return </span><span class="s1">undef_</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s4">return </span><span class="s1">iter-&gt;second</span><span class="s4">;</span>
    <span class="s1">}</span>

   <span class="s4">protected</span><span class="s1">:</span>
    <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
      <span class="s4">return </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">(*</span><span class="s4">this</span><span class="s1">)[name.utf8(rt)])</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">set(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name</span><span class="s4">, const </span><span class="s1">Value&amp; val) override {</span>
      <span class="s1">data_.emplace(name.utf8(rt)</span><span class="s4">, </span><span class="s1">Value(rt</span><span class="s4">, </span><span class="s1">val))</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">Value undef_</span><span class="s4">;</span>
    <span class="s1">std::map&lt;std::string</span><span class="s4">, </span><span class="s1">Value&gt; data_</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">auto </span><span class="s1">sharedBag = std::make_shared&lt;Bag&gt;()</span><span class="s4">;</span>
  <span class="s4">auto</span><span class="s1">&amp; bag = *sharedBag</span><span class="s4">;</span>
  <span class="s1">Object jsbag = Object::createFromHostObject(rt</span><span class="s4">, </span><span class="s1">std::move(sharedBag))</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">set = function(</span>
      <span class="s3">&quot;function (o) {&quot;</span>
      <span class="s3">&quot;  o.foo = 'bar';&quot;</span>
      <span class="s3">&quot;  o.count = 37;&quot;</span>
      <span class="s3">&quot;  o.nul = null;&quot;</span>
      <span class="s3">&quot;  o.iscool = true;&quot;</span>
      <span class="s3">&quot;  o.obj = { 'foo': 'bar' };&quot;</span>
      <span class="s3">&quot;}&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">set.call(rt</span><span class="s4">, </span><span class="s1">jsbag)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">checkFoo = function(</span><span class="s3">&quot;function (o) { return o.foo === 'bar'; }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">checkCount = function(</span><span class="s3">&quot;function (o) { return o.count === 37; }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">checkNul = function(</span><span class="s3">&quot;function (o) { return o.nul === null; }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">checkIsCool = function(</span><span class="s3">&quot;function (o) { return o.iscool === true; }&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">checkObj = function(</span>
      <span class="s3">&quot;function (o) {&quot;</span>
      <span class="s3">&quot;  return (typeof o.obj) === 'object' &amp;&amp; o.obj.foo === 'bar';&quot;</span>
      <span class="s3">&quot;}&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s0">// Check this looks good from js</span>
  <span class="s1">EXPECT_TRUE(checkFoo.call(rt</span><span class="s4">, </span><span class="s1">jsbag).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkCount.call(rt</span><span class="s4">, </span><span class="s1">jsbag).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkNul.call(rt</span><span class="s4">, </span><span class="s1">jsbag).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkIsCool.call(rt</span><span class="s4">, </span><span class="s1">jsbag).getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(checkObj.call(rt</span><span class="s4">, </span><span class="s1">jsbag).getBool())</span><span class="s4">;</span>

  <span class="s0">// Check this looks good from c++</span>
  <span class="s1">EXPECT_EQ(bag[</span><span class="s3">&quot;foo&quot;</span><span class="s1">].getString(rt).utf8(rt)</span><span class="s4">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(bag[</span><span class="s3">&quot;count&quot;</span><span class="s1">].getNumber()</span><span class="s4">, </span><span class="s5">37</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(bag[</span><span class="s3">&quot;nul&quot;</span><span class="s1">].isNull())</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(bag[</span><span class="s3">&quot;iscool&quot;</span><span class="s1">].getBool())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">bag[</span><span class="s3">&quot;obj&quot;</span><span class="s1">].getObject(rt).getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;foo&quot;</span><span class="s1">).getString(rt).utf8(rt)</span><span class="s4">,</span>
      <span class="s3">&quot;bar&quot;</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">DecoratorTest) {</span>
  <span class="s4">struct </span><span class="s1">Count {</span>
    <span class="s0">// init here is just to show that a With type does not need to be</span>
    <span class="s0">// default constructible.</span>
    <span class="s4">explicit </span><span class="s1">Count(</span><span class="s4">int </span><span class="s1">init) : count(init) {}</span>

    <span class="s0">// Test optional before method.</span>

    <span class="s4">void </span><span class="s1">after() {</span>
      <span class="s1">++count</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">int </span><span class="s1">count</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">static constexpr int </span><span class="s1">kInit = </span><span class="s5">17</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">CountRuntime final : </span><span class="s4">public </span><span class="s1">WithRuntimeDecorator&lt;Count&gt; {</span>
   <span class="s4">public</span><span class="s1">:</span>
    <span class="s4">explicit </span><span class="s1">CountRuntime(std::unique_ptr&lt;Runtime&gt; rt)</span>
        <span class="s1">: WithRuntimeDecorator&lt;Count&gt;(*rt</span><span class="s4">, </span><span class="s1">count_)</span><span class="s4">,</span>
          <span class="s1">rt_(std::move(rt))</span><span class="s4">,</span>
          <span class="s1">count_(kInit) {}</span>

    <span class="s4">int </span><span class="s1">count() {</span>
      <span class="s4">return </span><span class="s1">count_.count</span><span class="s4">;</span>
    <span class="s1">}</span>

   <span class="s4">private</span><span class="s1">:</span>
    <span class="s1">std::unique_ptr&lt;Runtime&gt; rt_</span><span class="s4">;</span>
    <span class="s1">Count count_</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">CountRuntime crt(factory())</span><span class="s4">;</span>

  <span class="s1">crt.description()</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(crt.count()</span><span class="s4">, </span><span class="s1">kInit + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">crt.global().setProperty(crt</span><span class="s4">, </span><span class="s3">&quot;o&quot;</span><span class="s4">, </span><span class="s1">Object(crt))</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(crt.count()</span><span class="s4">, </span><span class="s1">kInit + </span><span class="s5">6</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">MultiDecoratorTest) {</span>
  <span class="s4">struct </span><span class="s1">Inc {</span>
    <span class="s4">void </span><span class="s1">before() {</span>
      <span class="s1">++count</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s0">// Test optional after method.</span>

    <span class="s4">int </span><span class="s1">count = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">struct </span><span class="s1">Nest {</span>
    <span class="s4">void </span><span class="s1">before() {</span>
      <span class="s1">++nest</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">void </span><span class="s1">after() {</span>
      <span class="s1">--nest</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">int </span><span class="s1">nest = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">class </span><span class="s1">MultiRuntime final</span>
      <span class="s1">: </span><span class="s4">public </span><span class="s1">WithRuntimeDecorator&lt;std::tuple&lt;Inc</span><span class="s4">, </span><span class="s1">Nest&gt;&gt; {</span>
   <span class="s4">public</span><span class="s1">:</span>
    <span class="s4">explicit </span><span class="s1">MultiRuntime(std::unique_ptr&lt;Runtime&gt; rt)</span>
        <span class="s1">: WithRuntimeDecorator&lt;std::tuple&lt;Inc</span><span class="s4">, </span><span class="s1">Nest&gt;&gt;(*rt</span><span class="s4">, </span><span class="s1">tuple_)</span><span class="s4">,</span>
          <span class="s1">rt_(std::move(rt)) {}</span>

    <span class="s4">int </span><span class="s1">count() {</span>
      <span class="s4">return </span><span class="s1">std::get&lt;</span><span class="s5">0</span><span class="s1">&gt;(tuple_).count</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">int </span><span class="s1">nest() {</span>
      <span class="s4">return </span><span class="s1">std::get&lt;</span><span class="s5">1</span><span class="s1">&gt;(tuple_).nest</span><span class="s4">;</span>
    <span class="s1">}</span>

   <span class="s4">private</span><span class="s1">:</span>
    <span class="s1">std::unique_ptr&lt;Runtime&gt; rt_</span><span class="s4">;</span>
    <span class="s1">std::tuple&lt;Inc</span><span class="s4">, </span><span class="s1">Nest&gt; tuple_</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">MultiRuntime mrt(factory())</span><span class="s4">;</span>

  <span class="s1">Function expectNestOne = Function::createFromHostFunction(</span>
      <span class="s1">mrt</span><span class="s4">,</span>
      <span class="s1">PropNameID::forAscii(mrt</span><span class="s4">, </span><span class="s3">&quot;expectNestOne&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s5">0</span><span class="s4">,</span>
      <span class="s1">[](Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp; thisVal</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) {</span>
        <span class="s1">MultiRuntime* funcmrt = </span><span class="s4">dynamic_cast</span><span class="s1">&lt;MultiRuntime*&gt;(&amp;rt)</span><span class="s4">;</span>
        <span class="s1">EXPECT_NE(funcmrt</span><span class="s4">, nullptr</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">EXPECT_EQ(funcmrt-&gt;count()</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">EXPECT_EQ(funcmrt-&gt;nest()</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">Value::undefined()</span><span class="s4">;</span>
      <span class="s1">})</span><span class="s4">;</span>

  <span class="s1">expectNestOne.call(mrt)</span><span class="s4">;</span>

  <span class="s1">EXPECT_EQ(mrt.count()</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(mrt.nest()</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">SymbolTest) {</span>
  <span class="s4">if </span><span class="s1">(!rt.global().hasProperty(rt</span><span class="s4">, </span><span class="s3">&quot;Symbol&quot;</span><span class="s1">)) {</span>
    <span class="s0">// Symbol is an es6 feature which doesn't exist in older VMs.  So</span>
    <span class="s0">// the tests which might be elsewhere are all here so they can be</span>
    <span class="s0">// skipped.</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s0">// ObjectTest</span>
  <span class="s1">eval(</span><span class="s3">&quot;x = {1:2, 'three':Symbol('four')}&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">Object x = rt.global().getPropertyAsObject(rt</span><span class="s4">, </span><span class="s3">&quot;x&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(x.getPropertyNames(rt).size(rt)</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(x.hasProperty(rt</span><span class="s4">, </span><span class="s3">&quot;three&quot;</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span>
      <span class="s1">x.getProperty(rt</span><span class="s4">, </span><span class="s3">&quot;three&quot;</span><span class="s1">).getSymbol(rt).toString(rt)</span><span class="s4">, </span><span class="s3">&quot;Symbol(four)&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s0">// ValueTest</span>
  <span class="s1">EXPECT_TRUE(eval(</span><span class="s3">&quot;Symbol('sym')&quot;</span><span class="s1">).isSymbol())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(eval(</span><span class="s3">&quot;Symbol('sym')&quot;</span><span class="s1">).getSymbol(rt).toString(rt)</span><span class="s4">, </span><span class="s3">&quot;Symbol(sym)&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s0">// EqualsTest</span>
  <span class="s1">EXPECT_FALSE(Symbol::strictEquals(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">eval(</span><span class="s3">&quot;Symbol('a')&quot;</span><span class="s1">).getSymbol(rt)</span><span class="s4">,</span>
      <span class="s1">eval(</span><span class="s3">&quot;Symbol('a')&quot;</span><span class="s1">).getSymbol(rt)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Symbol::strictEquals(</span>
      <span class="s1">rt</span><span class="s4">,</span>
      <span class="s1">eval(</span><span class="s3">&quot;Symbol.for('a')&quot;</span><span class="s1">).getSymbol(rt)</span><span class="s4">,</span>
      <span class="s1">eval(</span><span class="s3">&quot;Symbol.for('a')&quot;</span><span class="s1">).getSymbol(rt)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(</span>
      <span class="s1">Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">eval(</span><span class="s3">&quot;Symbol('a')&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">eval(</span><span class="s3">&quot;Symbol('a')&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(Value::strictEquals(</span>
      <span class="s1">rt</span><span class="s4">, </span><span class="s1">eval(</span><span class="s3">&quot;Symbol.for('a')&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">eval(</span><span class="s3">&quot;Symbol.for('a')&quot;</span><span class="s1">)))</span><span class="s4">;</span>
  <span class="s1">EXPECT_FALSE(Value::strictEquals(rt</span><span class="s4">, </span><span class="s1">eval(</span><span class="s3">&quot;Symbol('a')&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">eval(</span><span class="s3">&quot;'a'&quot;</span><span class="s1">)))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">JSErrorTest) {</span>
  <span class="s0">// JSError creation can lead to further errors.  Make sure these</span>
  <span class="s0">// cases are handled and don't cause weird crashes or other issues.</span>
  <span class="s0">//</span>
  <span class="s0">// Getting message property can throw</span>

  <span class="s1">EXPECT_THROW(</span>
      <span class="s1">eval(</span><span class="s3">&quot;var GetMessageThrows = {get message() { throw Error('ex'); }};&quot;</span>
           <span class="s3">&quot;throw GetMessageThrows;&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s1">EXPECT_THROW(</span>
      <span class="s1">eval(</span><span class="s3">&quot;var GetMessageThrows = {get message() { throw GetMessageThrows; }};&quot;</span>
           <span class="s3">&quot;throw GetMessageThrows;&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s0">// Converting exception message to String can throw</span>

  <span class="s1">EXPECT_THROW(</span>
      <span class="s1">eval(</span>
          <span class="s3">&quot;Object.defineProperty(&quot;</span>
          <span class="s3">&quot;  globalThis, 'String', {configurable:true, get() { var e = Error(); e.message = 23; throw e; }});&quot;</span>
          <span class="s3">&quot;var e = Error();&quot;</span>
          <span class="s3">&quot;e.message = 17;&quot;</span>
          <span class="s3">&quot;throw e;&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s1">EXPECT_THROW(</span>
      <span class="s1">eval(</span>
          <span class="s3">&quot;var e = Error();&quot;</span>
          <span class="s3">&quot;Object.defineProperty(&quot;</span>
          <span class="s3">&quot;  e, 'message', {configurable:true, get() { throw Error('getter'); }});&quot;</span>
          <span class="s3">&quot;throw e;&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s1">EXPECT_THROW(</span>
      <span class="s1">eval(</span><span class="s3">&quot;var e = Error();&quot;</span>
           <span class="s3">&quot;String = function() { throw Error('ctor'); };&quot;</span>
           <span class="s3">&quot;throw e;&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s0">// Converting an exception message to String can return a non-String</span>

  <span class="s1">EXPECT_THROW(</span>
      <span class="s1">eval(</span><span class="s3">&quot;String = function() { return 42; };&quot;</span>
           <span class="s3">&quot;var e = Error();&quot;</span>
           <span class="s3">&quot;e.message = 17;&quot;</span>
           <span class="s3">&quot;throw e;&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s0">// Exception can be non-Object</span>

  <span class="s1">EXPECT_THROW(eval(</span><span class="s3">&quot;throw 17;&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s1">EXPECT_THROW(eval(</span><span class="s3">&quot;throw undefined;&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">JSIException)</span><span class="s4">;</span>

  <span class="s0">// Converting exception with no message or stack property to String can throw</span>

  <span class="s1">EXPECT_THROW(</span>
      <span class="s1">eval(</span><span class="s3">&quot;var e = {toString() { throw new Error('errstr'); }};&quot;</span>
           <span class="s3">&quot;throw e;&quot;</span><span class="s1">)</span><span class="s4">,</span>
      <span class="s1">JSIException)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">//----------------------------------------------------------------------</span>
<span class="s0">// Test that multiple levels of delegation in DecoratedHostObjects works.</span>

<span class="s4">class </span><span class="s1">RD1 : </span><span class="s4">public </span><span class="s1">RuntimeDecorator&lt;Runtime</span><span class="s4">, </span><span class="s1">Runtime&gt; {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">RD1(Runtime&amp; plain) : RuntimeDecorator(plain) {}</span>

  <span class="s1">Object createObject(std::shared_ptr&lt;HostObject&gt; ho) {</span>
    <span class="s4">class </span><span class="s1">DHO1 : </span><span class="s4">public </span><span class="s1">DecoratedHostObject {</span>
     <span class="s4">public</span><span class="s1">:</span>
      <span class="s4">using </span><span class="s1">DecoratedHostObject::DecoratedHostObject</span><span class="s4">;</span>

      <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
        <span class="s1">numGets++</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">DecoratedHostObject::get(rt</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">Object::createFromHostObject(</span>
        <span class="s1">plain()</span><span class="s4">, </span><span class="s1">std::make_shared&lt;DHO1&gt;(*</span><span class="s4">this, </span><span class="s1">ho))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">static unsigned </span><span class="s1">numGets</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">class </span><span class="s1">RD2 : </span><span class="s4">public </span><span class="s1">RuntimeDecorator&lt;Runtime</span><span class="s4">, </span><span class="s1">Runtime&gt; {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">RD2(Runtime&amp; plain) : RuntimeDecorator(plain) {}</span>

  <span class="s1">Object createObject(std::shared_ptr&lt;HostObject&gt; ho) {</span>
    <span class="s4">class </span><span class="s1">DHO2 : </span><span class="s4">public </span><span class="s1">DecoratedHostObject {</span>
     <span class="s4">public</span><span class="s1">:</span>
      <span class="s4">using </span><span class="s1">DecoratedHostObject::DecoratedHostObject</span><span class="s4">;</span>

      <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
        <span class="s1">numGets++</span><span class="s4">;</span>
        <span class="s4">return </span><span class="s1">DecoratedHostObject::get(rt</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">Object::createFromHostObject(</span>
        <span class="s1">plain()</span><span class="s4">, </span><span class="s1">std::make_shared&lt;DHO2&gt;(*</span><span class="s4">this, </span><span class="s1">ho))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">static unsigned </span><span class="s1">numGets</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">class </span><span class="s1">HO : </span><span class="s4">public </span><span class="s1">HostObject {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">explicit </span><span class="s1">HO(Runtime* expectedRT) : expectedRT_(expectedRT) {}</span>

  <span class="s1">Value get(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) override {</span>
    <span class="s1">EXPECT_EQ(expectedRT_</span><span class="s4">, </span><span class="s1">&amp;rt)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">Value(</span><span class="s5">17.0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s0">// The runtime we expect to be called with.</span>
  <span class="s1">Runtime* expectedRT_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">unsigned </span><span class="s1">RD1::numGets = </span><span class="s5">0</span><span class="s4">;</span>
<span class="s4">unsigned </span><span class="s1">RD2::numGets = </span><span class="s5">0</span><span class="s4">;</span>

<span class="s1">TEST_P(JSITest</span><span class="s4">, </span><span class="s1">MultilevelDecoratedHostObject) {</span>
  <span class="s0">// This test will be run for various test instantiations, so initialize these</span>
  <span class="s0">// counters.</span>
  <span class="s1">RD1::numGets = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">RD2::numGets = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s1">RD1 rd1(rt)</span><span class="s4">;</span>
  <span class="s1">RD2 rd2(rd1)</span><span class="s4">;</span>
  <span class="s0">// We expect the &quot;get&quot; operation of ho to be called with rd2.</span>
  <span class="s4">auto </span><span class="s1">ho = std::make_shared&lt;HO&gt;(&amp;rd2)</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">obj = Object::createFromHostObject(rd2</span><span class="s4">, </span><span class="s1">ho)</span><span class="s4">;</span>
  <span class="s1">Value v = obj.getProperty(rd2</span><span class="s4">, </span><span class="s3">&quot;p&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">EXPECT_TRUE(v.isNumber())</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span><span class="s5">17.0</span><span class="s4">, </span><span class="s1">v.asNumber())</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">ho2 = obj.getHostObject(rd2)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(ho</span><span class="s4">, </span><span class="s1">ho2)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">RD1::numGets)</span><span class="s4">;</span>
  <span class="s1">EXPECT_EQ(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">RD2::numGets)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">INSTANTIATE_TEST_SUITE_P(</span>
    <span class="s1">Runtimes</span><span class="s4">,</span>
    <span class="s1">JSITest</span><span class="s4">,</span>
    <span class="s1">::testing::ValuesIn(runtimeGenerators()))</span><span class="s4">;</span>
</pre>
</body>
</html>
<html>
<head>
<title>ReactShadowNodeImpl.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #77b767; font-style: italic;}
.s6 { color: #6897bb;}
.s7 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactShadowNodeImpl.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.uimanager</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.infer.annotation.Assertions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.annotations.ReactPropertyHolder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaAlign</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaBaselineFunction</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaConfig</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaDirection</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaDisplay</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaEdge</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaFlexDirection</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaGutter</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaJustify</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaMeasureFunction</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaNode</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaNodeFactory</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaOverflow</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaPositionType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaValue</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaWrap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Arrays</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Base node class for representing virtual tree of React nodes. Shadow nodes are used primarily for</span>
 <span class="s3">* layouting therefore it extends {</span><span class="s4">@link </span><span class="s3">YogaNode} to allow that. They also help with handling</span>
 <span class="s3">* Common base subclass of {</span><span class="s4">@link </span><span class="s3">YogaNode} for all layout nodes for react-based view. It extends</span>
 <span class="s3">* {</span><span class="s4">@link </span><span class="s3">YogaNode} by adding additional capabilities.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Instances of this class receive property updates from JS via @{link UIManagerModule}.</span>
 <span class="s3">* Subclasses may use {</span><span class="s4">@link </span><span class="s3">#updateShadowNode} to persist some of the updated fields in the node</span>
 <span class="s3">* instance that corresponds to a particular view type.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Subclasses of {</span><span class="s4">@link </span><span class="s3">ReactShadowNodeImpl} should be created only from {</span><span class="s4">@link </span><span class="s3">ViewManager} that</span>
 <span class="s3">* corresponds to a certain type of native view. They will be updated and accessed only from JS</span>
 <span class="s3">* thread. Subclasses of {</span><span class="s4">@link </span><span class="s3">ViewManager} may choose to use base class {</span><span class="s4">@link</span>
 <span class="s3">* ReactShadowNodeImpl} or custom subclass of it if necessary.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">The primary use-case for {</span><span class="s4">@link </span><span class="s3">ReactShadowNodeImpl} nodes is to calculate layouting. Although</span>
 <span class="s3">* this might be extended. For some examples please refer to ARTGroupYogaNode or ReactTextYogaNode.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">This class allows for the native view hierarchy to not be an exact copy of the hierarchy</span>
 <span class="s3">* received from JS by keeping track of both JS children (e.g. {</span><span class="s4">@link </span><span class="s3">#getChildCount()} and</span>
 <span class="s3">* separately native children (e.g. {</span><span class="s4">@link </span><span class="s3">#getNativeChildCount()}). See {</span><span class="s4">@link</span>
 <span class="s3">* NativeViewHierarchyOptimizer} for more information.</span>
 <span class="s3">*/</span>
<span class="s1">@ReactPropertyHolder</span>
<span class="s2">public class </span><span class="s1">ReactShadowNodeImpl </span><span class="s2">implements </span><span class="s1">ReactShadowNode&lt;ReactShadowNodeImpl&gt; {</span>

  <span class="s2">private static final </span><span class="s1">YogaConfig sYogaConfig</span><span class="s2">;</span>

  <span class="s2">static </span><span class="s1">{</span>
    <span class="s1">sYogaConfig = ReactYogaConfigProvider.get()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private int </span><span class="s1">mReactTag</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable String mViewClassName</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mRootTag</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ThemedReactContext mThemedContext</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mShouldNotifyOnLayout</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mNodeUpdated = </span><span class="s2">true;</span>
  <span class="s2">private </span><span class="s1">@Nullable ArrayList&lt;ReactShadowNodeImpl&gt; mChildren</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ReactShadowNodeImpl mParent</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ReactShadowNodeImpl mLayoutParent</span><span class="s2">;</span>

  <span class="s0">// layout-only nodes</span>
  <span class="s2">private boolean </span><span class="s1">mIsLayoutOnly</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mTotalNativeChildren = </span><span class="s6">0</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ReactShadowNodeImpl mNativeParent</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ArrayList&lt;ReactShadowNodeImpl&gt; mNativeChildren</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mScreenX</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mScreenY</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mScreenWidth</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mScreenHeight</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">Spacing mDefaultPadding</span><span class="s2">;</span>
  <span class="s2">private final float</span><span class="s1">[] mPadding = </span><span class="s2">new float</span><span class="s1">[Spacing.ALL + </span><span class="s6">1</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">private final boolean</span><span class="s1">[] mPaddingIsPercent = </span><span class="s2">new boolean</span><span class="s1">[Spacing.ALL + </span><span class="s6">1</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">YogaNode mYogaNode</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">Integer mWidthMeasureSpec</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">Integer mHeightMeasureSpec</span><span class="s2">;</span>

  <span class="s2">public </span><span class="s1">ReactShadowNodeImpl() {</span>
    <span class="s1">mDefaultPadding = </span><span class="s2">new </span><span class="s1">Spacing(</span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isVirtual()) {</span>
      <span class="s1">YogaNode node = YogaNodePool.get().acquire()</span><span class="s2">;</span>
      <span class="s1">mYogaNode = node == </span><span class="s2">null </span><span class="s1">? YogaNodeFactory.create(sYogaConfig) : node</span><span class="s2">;</span>
      <span class="s1">mYogaNode.setData(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">Arrays.fill(mPadding</span><span class="s2">, </span><span class="s1">YogaConstants.UNDEFINED)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mYogaNode = </span><span class="s2">null;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Nodes that return {</span><span class="s4">@code </span><span class="s3">true} will be treated as &quot;virtual&quot; nodes. That is, nodes that are not</span>
   <span class="s3">* mapped into native views or Yoga nodes (e.g. nested text node). By default this method returns</span>
   <span class="s3">* {</span><span class="s4">@code </span><span class="s3">false}.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">isVirtual() {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Nodes that return {</span><span class="s4">@code </span><span class="s3">true} will be treated as a root view for the virtual nodes tree. It</span>
   <span class="s3">* means that all of its descendants will be &quot;virtual&quot; nodes. Good example is {</span><span class="s4">@code </span><span class="s3">InputText}</span>
   <span class="s3">* view that may have children {</span><span class="s4">@code </span><span class="s3">Text} nodes but this whole hierarchy will be mapped to a</span>
   <span class="s3">* single android {</span><span class="s4">@link </span><span class="s3">EditText} view.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">isVirtualAnchor() {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Nodes that return {</span><span class="s4">@code </span><span class="s3">true} will not manage (and and remove) child Yoga nodes. For example</span>
   <span class="s3">* {</span><span class="s4">@link </span><span class="s3">ReactTextInputShadowNode} or {</span><span class="s4">@link </span><span class="s3">ReactTextShadowNode} have child nodes, which do not</span>
   <span class="s3">* want Yoga to lay out, so in the eyes of Yoga it is a leaf node. Override this method in</span>
   <span class="s3">* subclass to enforce this requirement.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">isYogaLeafNode() {</span>
    <span class="s2">return </span><span class="s1">isMeasureDefined()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* When constructing the native tree, nodes that return {</span><span class="s4">@code </span><span class="s3">true} will be treated as leaves.</span>
   <span class="s3">* Instead of adding this view's native children as subviews of it, they will be added as subviews</span>
   <span class="s3">* of an ancestor. In other words, this view wants to support native children but it cannot host</span>
   <span class="s3">* them itself (e.g. it isn't a ViewGroup).</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">hoistNativeChildren() {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">String getViewClass() {</span>
    <span class="s2">return </span><span class="s1">Assertions.assertNotNull(mViewClassName)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final boolean </span><span class="s1">hasUpdates() {</span>
    <span class="s2">return </span><span class="s1">mNodeUpdated || hasNewLayout() || isDirty()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">markUpdateSeen() {</span>
    <span class="s1">mNodeUpdated = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(hasNewLayout()) {</span>
      <span class="s1">markLayoutSeen()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">markUpdated() {</span>
    <span class="s2">if </span><span class="s1">(mNodeUpdated) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">mNodeUpdated = </span><span class="s2">true;</span>
    <span class="s1">ReactShadowNodeImpl parent = getParent()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parent != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">parent.markUpdated()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final boolean </span><span class="s1">hasUnseenUpdates() {</span>
    <span class="s2">return </span><span class="s1">mNodeUpdated</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">dirty() {</span>
    <span class="s2">if </span><span class="s1">(!isVirtual()) {</span>
      <span class="s1">mYogaNode.dirty()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(getParent() != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s0">// Virtual nodes aren't involved in layout but they need to have the dirty signal</span>
      <span class="s0">// propagated to their ancestors.</span>
      <span class="s0">//</span>
      <span class="s0">// TODO: There are some edge cases that currently aren't supported. For example, if the size</span>
      <span class="s0">//   of your inline image/view changes, its size on-screen is not be updated. Similarly,</span>
      <span class="s0">//   if the size of a view inside of an inline view changes, its size on-screen is not</span>
      <span class="s0">//   updated. The problem may be that dirty propagation stops at inline views because the</span>
      <span class="s0">//   parent of each inline view is null. A possible fix would be to implement an `onDirty`</span>
      <span class="s0">//   handler in Yoga that will propagate the dirty signal to the ancestors of the inline view.</span>
      <span class="s0">//</span>
      <span class="s1">getParent().dirty()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final boolean </span><span class="s1">isDirty() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode != </span><span class="s2">null </span><span class="s1">&amp;&amp; mYogaNode.isDirty()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">addChildAt(ReactShadowNodeImpl child</span><span class="s2">, int </span><span class="s1">i) {</span>
    <span class="s2">if </span><span class="s1">(mChildren == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mChildren = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;(</span><span class="s6">4</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mChildren.add(i</span><span class="s2">, </span><span class="s1">child)</span><span class="s2">;</span>
    <span class="s1">child.mParent = </span><span class="s2">this;</span>

    <span class="s0">// If a CSS node has measure defined, the layout algorithm will not visit its children. Even</span>
    <span class="s0">// more, it asserts that you don't add children to nodes with measure functions.</span>
    <span class="s2">if </span><span class="s1">(mYogaNode != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isYogaLeafNode()) {</span>
      <span class="s1">YogaNode childYogaNode = child.mYogaNode</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(childYogaNode == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">RuntimeException(</span>
            <span class="s7">&quot;Cannot add a child that doesn't have a YogaNode to a parent without a measure &quot;</span>
                <span class="s1">+ </span><span class="s7">&quot;function! (Trying to add a '&quot;</span>
                <span class="s1">+ child.toString()</span>
                <span class="s1">+ </span><span class="s7">&quot;' to a '&quot;</span>
                <span class="s1">+ toString()</span>
                <span class="s1">+ </span><span class="s7">&quot;')&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">mYogaNode.addChildAt(childYogaNode</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">increase = child.getTotalNativeNodeContributionToParent()</span><span class="s2">;</span>
    <span class="s1">mTotalNativeChildren += increase</span><span class="s2">;</span>

    <span class="s1">updateNativeChildrenCountInParent(increase)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">ReactShadowNodeImpl removeChildAt(</span><span class="s2">int </span><span class="s1">i) {</span>
    <span class="s2">if </span><span class="s1">(mChildren == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">ArrayIndexOutOfBoundsException(</span>
          <span class="s7">&quot;Index &quot; </span><span class="s1">+ i + </span><span class="s7">&quot; out of bounds: node has no children&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ReactShadowNodeImpl removed = mChildren.remove(i)</span><span class="s2">;</span>
    <span class="s1">removed.mParent = </span><span class="s2">null;</span>

    <span class="s2">if </span><span class="s1">(mYogaNode != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isYogaLeafNode()) {</span>
      <span class="s1">mYogaNode.removeChildAt(i)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>

    <span class="s2">int </span><span class="s1">decrease = removed.getTotalNativeNodeContributionToParent()</span><span class="s2">;</span>
    <span class="s1">mTotalNativeChildren -= decrease</span><span class="s2">;</span>
    <span class="s1">updateNativeChildrenCountInParent(-decrease)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">removed</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final int </span><span class="s1">getChildCount() {</span>
    <span class="s2">return </span><span class="s1">mChildren == </span><span class="s2">null </span><span class="s1">? </span><span class="s6">0 </span><span class="s1">: mChildren.size()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">ReactShadowNodeImpl getChildAt(</span><span class="s2">int </span><span class="s1">i) {</span>
    <span class="s2">if </span><span class="s1">(mChildren == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">ArrayIndexOutOfBoundsException(</span>
          <span class="s7">&quot;Index &quot; </span><span class="s1">+ i + </span><span class="s7">&quot; out of bounds: node has no children&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mChildren.get(i)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final int </span><span class="s1">indexOf(ReactShadowNodeImpl child) {</span>
    <span class="s2">return </span><span class="s1">mChildren == </span><span class="s2">null </span><span class="s1">? -</span><span class="s6">1 </span><span class="s1">: mChildren.indexOf(child)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">removeAndDisposeAllChildren() {</span>
    <span class="s2">if </span><span class="s1">(getChildCount() == </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">int </span><span class="s1">decrease = </span><span class="s6">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = getChildCount() - </span><span class="s6">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i--) {</span>
      <span class="s2">if </span><span class="s1">(mYogaNode != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isYogaLeafNode()) {</span>
        <span class="s1">mYogaNode.removeChildAt(i)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">ReactShadowNodeImpl toRemove = getChildAt(i)</span><span class="s2">;</span>
      <span class="s1">toRemove.mParent = </span><span class="s2">null;</span>
      <span class="s1">decrease += toRemove.getTotalNativeNodeContributionToParent()</span><span class="s2">;</span>
      <span class="s1">toRemove.dispose()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">Assertions.assertNotNull(mChildren).clear()</span><span class="s2">;</span>
    <span class="s1">markUpdated()</span><span class="s2">;</span>

    <span class="s1">mTotalNativeChildren -= decrease</span><span class="s2">;</span>
    <span class="s1">updateNativeChildrenCountInParent(-decrease)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updateNativeChildrenCountInParent(</span><span class="s2">int </span><span class="s1">delta) {</span>
    <span class="s2">if </span><span class="s1">(getNativeKind() != NativeKind.PARENT) {</span>
      <span class="s1">ReactShadowNodeImpl parent = getParent()</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">(parent != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">parent.mTotalNativeChildren += delta</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(parent.getNativeKind() == NativeKind.PARENT) {</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s1">parent = parent.getParent()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* This method will be called by {</span><span class="s4">@link </span><span class="s3">UIManagerModule} once per batch, before calculating</span>
   <span class="s3">* layout. Will be only called for nodes that are marked as updated with {</span><span class="s4">@link </span><span class="s3">#markUpdated()} or</span>
   <span class="s3">* require layouting (marked with {</span><span class="s4">@link </span><span class="s3">#dirty()}).</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onBeforeLayout(NativeViewHierarchyOptimizer nativeViewHierarchyOptimizer) {}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">updateProperties(ReactStylesDiffMap props) {</span>
    <span class="s1">ViewManagerPropertyUpdater.updateProps(</span><span class="s2">this, </span><span class="s1">props)</span><span class="s2">;</span>
    <span class="s1">onAfterUpdateTransaction()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onAfterUpdateTransaction() {</span>
    <span class="s0">// no-op</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Called after layout step at the end of the UI batch from {</span><span class="s4">@link </span><span class="s3">UIManagerModule}. May be used</span>
   <span class="s3">* to enqueue additional ui operations for the native view. Will only be called on nodes marked as</span>
   <span class="s3">* updated either with {</span><span class="s4">@link </span><span class="s3">#dirty()} or {</span><span class="s4">@link </span><span class="s3">#markUpdated()}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">uiViewOperationQueue interface for enqueueing UI operations</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">onCollectExtraUpdates(UIViewOperationQueue uiViewOperationQueue) {}</span>

  <span class="s3">/** </span><span class="s4">@return </span><span class="s3">true if layout (position or dimensions) changed, false otherwise. */</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">dispatchUpdates(</span>
      <span class="s2">float </span><span class="s1">absoluteX</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">absoluteY</span><span class="s2">,</span>
      <span class="s1">UIViewOperationQueue uiViewOperationQueue</span><span class="s2">,</span>
      <span class="s1">@Nullable NativeViewHierarchyOptimizer nativeViewHierarchyOptimizer) {</span>
    <span class="s2">if </span><span class="s1">(mNodeUpdated) {</span>
      <span class="s1">onCollectExtraUpdates(uiViewOperationQueue)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(hasNewLayout()) {</span>
      <span class="s2">float </span><span class="s1">layoutX = getLayoutX()</span><span class="s2">;</span>
      <span class="s2">float </span><span class="s1">layoutY = getLayoutY()</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">newAbsoluteLeft = Math.round(absoluteX + layoutX)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">newAbsoluteTop = Math.round(absoluteY + layoutY)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">newAbsoluteRight = Math.round(absoluteX + layoutX + getLayoutWidth())</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">newAbsoluteBottom = Math.round(absoluteY + layoutY + getLayoutHeight())</span><span class="s2">;</span>

      <span class="s2">int </span><span class="s1">newScreenX = Math.round(layoutX)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">newScreenY = Math.round(layoutY)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">newScreenWidth = newAbsoluteRight - newAbsoluteLeft</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">newScreenHeight = newAbsoluteBottom - newAbsoluteTop</span><span class="s2">;</span>

      <span class="s2">boolean </span><span class="s1">layoutHasChanged =</span>
          <span class="s1">newScreenX != mScreenX</span>
              <span class="s1">|| newScreenY != mScreenY</span>
              <span class="s1">|| newScreenWidth != mScreenWidth</span>
              <span class="s1">|| newScreenHeight != mScreenHeight</span><span class="s2">;</span>

      <span class="s1">mScreenX = newScreenX</span><span class="s2">;</span>
      <span class="s1">mScreenY = newScreenY</span><span class="s2">;</span>
      <span class="s1">mScreenWidth = newScreenWidth</span><span class="s2">;</span>
      <span class="s1">mScreenHeight = newScreenHeight</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(layoutHasChanged) {</span>
        <span class="s0">// TODO: T26400974 ReactShadowNode should not depend on nativeViewHierarchyOptimizer</span>
        <span class="s2">if </span><span class="s1">(nativeViewHierarchyOptimizer != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">nativeViewHierarchyOptimizer.handleUpdateLayout(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">uiViewOperationQueue.enqueueUpdateLayout(</span>
              <span class="s1">getParent().getReactTag()</span><span class="s2">,</span>
              <span class="s1">getReactTag()</span><span class="s2">,</span>
              <span class="s1">getScreenX()</span><span class="s2">,</span>
              <span class="s1">getScreenY()</span><span class="s2">,</span>
              <span class="s1">getScreenWidth()</span><span class="s2">,</span>
              <span class="s1">getScreenHeight())</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">layoutHasChanged</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final int </span><span class="s1">getReactTag() {</span>
    <span class="s2">return </span><span class="s1">mReactTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setReactTag(</span><span class="s2">int </span><span class="s1">reactTag) {</span>
    <span class="s1">mReactTag = reactTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final int </span><span class="s1">getRootTag() {</span>
    <span class="s1">Assertions.assertCondition(mRootTag != </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">mRootTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">setRootTag(</span><span class="s2">int </span><span class="s1">rootTag) {</span>
    <span class="s1">mRootTag = rootTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">setViewClassName(String viewClassName) {</span>
    <span class="s1">mViewClassName = viewClassName</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">@Nullable ReactShadowNodeImpl getParent() {</span>
    <span class="s2">return </span><span class="s1">mParent</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Returns the node that is responsible for laying out this node.</span>
  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">@Nullable ReactShadowNodeImpl getLayoutParent() {</span>
    <span class="s2">return </span><span class="s1">mLayoutParent != </span><span class="s2">null </span><span class="s1">? mLayoutParent : getNativeParent()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">setLayoutParent(@Nullable ReactShadowNodeImpl layoutParent) {</span>
    <span class="s1">mLayoutParent = layoutParent</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Get the {</span><span class="s4">@link </span><span class="s3">ThemedReactContext} associated with this {</span><span class="s4">@link </span><span class="s3">ReactShadowNodeImpl}. This will</span>
   <span class="s3">* never change during the lifetime of a {</span><span class="s4">@link </span><span class="s3">ReactShadowNodeImpl} instance, but different</span>
   <span class="s3">* instances can have different contexts; don't cache any calculations based on theme values</span>
   <span class="s3">* globally.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">ThemedReactContext getThemedContext() {</span>
    <span class="s2">return </span><span class="s1">Assertions.assertNotNull(mThemedContext)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setThemedContext(ThemedReactContext themedContext) {</span>
    <span class="s1">mThemedContext = themedContext</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final boolean </span><span class="s1">shouldNotifyOnLayout() {</span>
    <span class="s2">return </span><span class="s1">mShouldNotifyOnLayout</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">calculateLayout() {</span>
    <span class="s1">calculateLayout(YogaConstants.UNDEFINED</span><span class="s2">, </span><span class="s1">YogaConstants.UNDEFINED)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">calculateLayout(</span><span class="s2">float </span><span class="s1">width</span><span class="s2">, float </span><span class="s1">height) {</span>
    <span class="s1">mYogaNode.calculateLayout(width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final boolean </span><span class="s1">hasNewLayout() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode != </span><span class="s2">null </span><span class="s1">&amp;&amp; mYogaNode.hasNewLayout()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">markLayoutSeen() {</span>
    <span class="s2">if </span><span class="s1">(mYogaNode != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mYogaNode.markLayoutSeen()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Adds a child that the native view hierarchy will have at this index in the native view</span>
   <span class="s3">* corresponding to this node.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">addNativeChildAt(ReactShadowNodeImpl child</span><span class="s2">, int </span><span class="s1">nativeIndex) {</span>
    <span class="s1">Assertions.assertCondition(getNativeKind() == NativeKind.PARENT)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertCondition(child.getNativeKind() != NativeKind.NONE)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mNativeChildren == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mNativeChildren = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;(</span><span class="s6">4</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mNativeChildren.add(nativeIndex</span><span class="s2">, </span><span class="s1">child)</span><span class="s2">;</span>
    <span class="s1">child.mNativeParent = </span><span class="s2">this;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">ReactShadowNodeImpl removeNativeChildAt(</span><span class="s2">int </span><span class="s1">i) {</span>
    <span class="s1">Assertions.assertNotNull(mNativeChildren)</span><span class="s2">;</span>
    <span class="s1">ReactShadowNodeImpl removed = mNativeChildren.remove(i)</span><span class="s2">;</span>
    <span class="s1">removed.mNativeParent = </span><span class="s2">null;</span>
    <span class="s2">return </span><span class="s1">removed</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">removeAllNativeChildren() {</span>
    <span class="s2">if </span><span class="s1">(mNativeChildren != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = mNativeChildren.size() - </span><span class="s6">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i--) {</span>
        <span class="s1">mNativeChildren.get(i).mNativeParent = </span><span class="s2">null;</span>
      <span class="s1">}</span>
      <span class="s1">mNativeChildren.clear()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final int </span><span class="s1">getNativeChildCount() {</span>
    <span class="s2">return </span><span class="s1">mNativeChildren == </span><span class="s2">null </span><span class="s1">? </span><span class="s6">0 </span><span class="s1">: mNativeChildren.size()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final int </span><span class="s1">indexOfNativeChild(ReactShadowNodeImpl nativeChild) {</span>
    <span class="s1">Assertions.assertNotNull(mNativeChildren)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">mNativeChildren.indexOf(nativeChild)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">@Nullable ReactShadowNodeImpl getNativeParent() {</span>
    <span class="s2">return </span><span class="s1">mNativeParent</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Sets whether this node only contributes to the layout of its children without doing any drawing</span>
   <span class="s3">* or functionality itself.</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public final void </span><span class="s1">setIsLayoutOnly(</span><span class="s2">boolean </span><span class="s1">isLayoutOnly) {</span>
    <span class="s1">Assertions.assertCondition(getParent() == </span><span class="s2">null, </span><span class="s7">&quot;Must remove from no opt parent first&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertCondition(mNativeParent == </span><span class="s2">null, </span><span class="s7">&quot;Must remove from native parent first&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">Assertions.assertCondition(getNativeChildCount() == </span><span class="s6">0</span><span class="s2">, </span><span class="s7">&quot;Must remove all native children first&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">mIsLayoutOnly = isLayoutOnly</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final boolean </span><span class="s1">isLayoutOnly() {</span>
    <span class="s2">return </span><span class="s1">mIsLayoutOnly</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">NativeKind getNativeKind() {</span>
    <span class="s2">return </span><span class="s1">isVirtual() || isLayoutOnly()</span>
        <span class="s1">? NativeKind.NONE</span>
        <span class="s1">: hoistNativeChildren() ? NativeKind.LEAF : NativeKind.PARENT</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final int </span><span class="s1">getTotalNativeChildren() {</span>
    <span class="s2">return </span><span class="s1">mTotalNativeChildren</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">isDescendantOf(ReactShadowNodeImpl ancestorNode) {</span>
    <span class="s1">ReactShadowNodeImpl parentNode = getParent()</span><span class="s2">;</span>

    <span class="s2">boolean </span><span class="s1">isDescendant = </span><span class="s2">false;</span>

    <span class="s2">while </span><span class="s1">(parentNode != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(parentNode == ancestorNode) {</span>
        <span class="s1">isDescendant = </span><span class="s2">true;</span>
        <span class="s2">break;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">parentNode = parentNode.getParent()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">isDescendant</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private int </span><span class="s1">getTotalNativeNodeContributionToParent() {</span>
    <span class="s1">NativeKind kind = getNativeKind()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">kind == NativeKind.NONE</span>
        <span class="s1">? mTotalNativeChildren</span>
        <span class="s1">: kind == NativeKind.LEAF ? </span><span class="s6">1 </span><span class="s1">+ mTotalNativeChildren : </span><span class="s6">1</span><span class="s2">; </span><span class="s0">// kind == NativeKind.PARENT</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">String toString() {</span>
    <span class="s2">return </span><span class="s7">&quot;[&quot; </span><span class="s1">+ mViewClassName + </span><span class="s7">&quot; &quot; </span><span class="s1">+ getReactTag() + </span><span class="s7">&quot;]&quot;</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">/* 
   * In some cases we need a way to specify some environmental data to shadow node 
   * to improve layout (or do something similar), so {@code localData} serves these needs. 
   * For example, any stateful embedded native views may benefit from this. 
   * Have in mind that this data is not supposed to interfere with the state of 
   * the shadow node. 
   * Please respect one-directional data flow of React. 
   * Use  {@link ReactUIManagerModule#setViewLocalData} to set this property 
   * (to provide local/environmental data for a shadow node) from the main thread. 
   */</span>
  <span class="s2">public void </span><span class="s1">setLocalData(Object data) {}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns the offset within the native children owned by all layout-only nodes in the subtree</span>
   <span class="s3">* rooted at this node for the given child. Put another way, this returns the number of native</span>
   <span class="s3">* nodes (nodes not optimized out of the native tree) that are a) to the left (visited before by a</span>
   <span class="s3">* DFS) of the given child in the subtree rooted at this node and b) do not have a native parent</span>
   <span class="s3">* in this subtree (which means that the given child will be a sibling of theirs in the final</span>
   <span class="s3">* native hierarchy since they'll get attached to the same native parent).</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Basically, a view might have children that have been optimized away by {</span><span class="s4">@link</span>
   <span class="s3">* NativeViewHierarchyOptimizer}. Since those children will then add their native children to this</span>
   <span class="s3">* view, we now have ranges of native children that correspond to single unoptimized children. The</span>
   <span class="s3">* purpose of this method is to return the index within the native children that corresponds to</span>
   <span class="s3">* the **start** of the native children that belong to the given child. Also, note that all of the</span>
   <span class="s3">* children of a view might be optimized away, so this could return the same value for multiple</span>
   <span class="s3">* different children.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Example. Native children are represented by (N) where N is the no-opt child they came from.</span>
   <span class="s3">* If no children are optimized away it'd look like this: (0) (1) (2) (3) ... (n)</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">In case some children are optimized away, it might look like this: (0) (1) (1) (1) (3) (3)</span>
   <span class="s3">* (4)</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">In that case: getNativeOffsetForChild(Node 0) =&gt; 0 getNativeOffsetForChild(Node 1) =&gt; 1</span>
   <span class="s3">* getNativeOffsetForChild(Node 2) =&gt; 4 getNativeOffsetForChild(Node 3) =&gt; 4</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">getNativeOffsetForChild(Node 4) =&gt; 6</span>
   <span class="s3">*/</span>
  <span class="s1">@Override</span>
  <span class="s2">public final int </span><span class="s1">getNativeOffsetForChild(ReactShadowNodeImpl child) {</span>
    <span class="s2">int </span><span class="s1">index = </span><span class="s6">0</span><span class="s2">;</span>
    <span class="s2">boolean </span><span class="s1">found = </span><span class="s2">false;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; getChildCount()</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">ReactShadowNodeImpl current = getChildAt(i)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(child == current) {</span>
        <span class="s1">found = </span><span class="s2">true;</span>
        <span class="s2">break;</span>
      <span class="s1">}</span>
      <span class="s1">index += current.getTotalNativeNodeContributionToParent()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!found) {</span>
      <span class="s2">throw new </span><span class="s1">RuntimeException(</span>
          <span class="s7">&quot;Child &quot; </span><span class="s1">+ child.getReactTag() + </span><span class="s7">&quot; was not a child of &quot; </span><span class="s1">+ mReactTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">index</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final float </span><span class="s1">getLayoutX() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getLayoutX()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final float </span><span class="s1">getLayoutY() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getLayoutY()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final float </span><span class="s1">getLayoutWidth() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getLayoutWidth()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final float </span><span class="s1">getLayoutHeight() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getLayoutHeight()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@return </span><span class="s3">the x position of the corresponding view on the screen, rounded to pixels */</span>
  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getScreenX() {</span>
    <span class="s2">return </span><span class="s1">mScreenX</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@return </span><span class="s3">the y position of the corresponding view on the screen, rounded to pixels */</span>
  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getScreenY() {</span>
    <span class="s2">return </span><span class="s1">mScreenY</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@return </span><span class="s3">width corrected for rounding to pixels. */</span>
  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getScreenWidth() {</span>
    <span class="s2">return </span><span class="s1">mScreenWidth</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** </span><span class="s4">@return </span><span class="s3">height corrected for rounding to pixels. */</span>
  <span class="s1">@Override</span>
  <span class="s2">public int </span><span class="s1">getScreenHeight() {</span>
    <span class="s2">return </span><span class="s1">mScreenHeight</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">YogaDirection getLayoutDirection() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getLayoutDirection()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setLayoutDirection(YogaDirection direction) {</span>
    <span class="s1">mYogaNode.setDirection(direction)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">YogaValue getStyleWidth() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getWidth()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleWidth(</span><span class="s2">float </span><span class="s1">widthPx) {</span>
    <span class="s1">mYogaNode.setWidth(widthPx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleWidthPercent(</span><span class="s2">float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setWidthPercent(percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleWidthAuto() {</span>
    <span class="s1">mYogaNode.setWidthAuto()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleMinWidth(</span><span class="s2">float </span><span class="s1">widthPx) {</span>
    <span class="s1">mYogaNode.setMinWidth(widthPx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleMinWidthPercent(</span><span class="s2">float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setMinWidthPercent(percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleMaxWidth(</span><span class="s2">float </span><span class="s1">widthPx) {</span>
    <span class="s1">mYogaNode.setMaxWidth(widthPx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleMaxWidthPercent(</span><span class="s2">float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setMaxWidthPercent(percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">YogaValue getStyleHeight() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getHeight()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleHeight(</span><span class="s2">float </span><span class="s1">heightPx) {</span>
    <span class="s1">mYogaNode.setHeight(heightPx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleHeightPercent(</span><span class="s2">float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setHeightPercent(percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleHeightAuto() {</span>
    <span class="s1">mYogaNode.setHeightAuto()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleMinHeight(</span><span class="s2">float </span><span class="s1">widthPx) {</span>
    <span class="s1">mYogaNode.setMinHeight(widthPx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleMinHeightPercent(</span><span class="s2">float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setMinHeightPercent(percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleMaxHeight(</span><span class="s2">float </span><span class="s1">widthPx) {</span>
    <span class="s1">mYogaNode.setMaxHeight(widthPx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleMaxHeightPercent(</span><span class="s2">float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setMaxHeightPercent(percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public float </span><span class="s1">getFlex() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getFlex()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFlex(</span><span class="s2">float </span><span class="s1">flex) {</span>
    <span class="s1">mYogaNode.setFlex(flex)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFlexGrow(</span><span class="s2">float </span><span class="s1">flexGrow) {</span>
    <span class="s1">mYogaNode.setFlexGrow(flexGrow)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setRowGap(</span><span class="s2">float </span><span class="s1">rowGap) {</span>
    <span class="s1">mYogaNode.setGap(YogaGutter.ROW</span><span class="s2">, </span><span class="s1">rowGap)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setColumnGap(</span><span class="s2">float </span><span class="s1">columnGap) {</span>
    <span class="s1">mYogaNode.setGap(YogaGutter.COLUMN</span><span class="s2">, </span><span class="s1">columnGap)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setGap(</span><span class="s2">float </span><span class="s1">gap) {</span>
    <span class="s1">mYogaNode.setGap(YogaGutter.ALL</span><span class="s2">, </span><span class="s1">gap)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFlexShrink(</span><span class="s2">float </span><span class="s1">flexShrink) {</span>
    <span class="s1">mYogaNode.setFlexShrink(flexShrink)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFlexBasis(</span><span class="s2">float </span><span class="s1">flexBasis) {</span>
    <span class="s1">mYogaNode.setFlexBasis(flexBasis)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFlexBasisAuto() {</span>
    <span class="s1">mYogaNode.setFlexBasisAuto()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFlexBasisPercent(</span><span class="s2">float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setFlexBasisPercent(percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setStyleAspectRatio(</span><span class="s2">float </span><span class="s1">aspectRatio) {</span>
    <span class="s1">mYogaNode.setAspectRatio(aspectRatio)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFlexDirection(YogaFlexDirection flexDirection) {</span>
    <span class="s1">mYogaNode.setFlexDirection(flexDirection)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setFlexWrap(YogaWrap wrap) {</span>
    <span class="s1">mYogaNode.setWrap(wrap)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setAlignSelf(YogaAlign alignSelf) {</span>
    <span class="s1">mYogaNode.setAlignSelf(alignSelf)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setAlignItems(YogaAlign alignItems) {</span>
    <span class="s1">mYogaNode.setAlignItems(alignItems)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setAlignContent(YogaAlign alignContent) {</span>
    <span class="s1">mYogaNode.setAlignContent(alignContent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setJustifyContent(YogaJustify justifyContent) {</span>
    <span class="s1">mYogaNode.setJustifyContent(justifyContent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setOverflow(YogaOverflow overflow) {</span>
    <span class="s1">mYogaNode.setOverflow(overflow)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setDisplay(YogaDisplay display) {</span>
    <span class="s1">mYogaNode.setDisplay(display)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setMargin(</span><span class="s2">int </span><span class="s1">spacingType</span><span class="s2">, float </span><span class="s1">margin) {</span>
    <span class="s1">mYogaNode.setMargin(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">margin)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setMarginPercent(</span><span class="s2">int </span><span class="s1">spacingType</span><span class="s2">, float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setMarginPercent(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setMarginAuto(</span><span class="s2">int </span><span class="s1">spacingType) {</span>
    <span class="s1">mYogaNode.setMarginAuto(YogaEdge.fromInt(spacingType))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final float </span><span class="s1">getPadding(</span><span class="s2">int </span><span class="s1">spacingType) {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getLayoutPadding(YogaEdge.fromInt(spacingType))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public final </span><span class="s1">YogaValue getStylePadding(</span><span class="s2">int </span><span class="s1">spacingType) {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.getPadding(YogaEdge.fromInt(spacingType))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setDefaultPadding(</span><span class="s2">int </span><span class="s1">spacingType</span><span class="s2">, float </span><span class="s1">padding) {</span>
    <span class="s1">mDefaultPadding.set(spacingType</span><span class="s2">, </span><span class="s1">padding)</span><span class="s2">;</span>
    <span class="s1">updatePadding()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setPadding(</span><span class="s2">int </span><span class="s1">spacingType</span><span class="s2">, float </span><span class="s1">padding) {</span>
    <span class="s1">mPadding[spacingType] = padding</span><span class="s2">;</span>
    <span class="s1">mPaddingIsPercent[spacingType] = </span><span class="s2">false;</span>
    <span class="s1">updatePadding()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setPaddingPercent(</span><span class="s2">int </span><span class="s1">spacingType</span><span class="s2">, float </span><span class="s1">percent) {</span>
    <span class="s1">mPadding[spacingType] = percent</span><span class="s2">;</span>
    <span class="s1">mPaddingIsPercent[spacingType] = !YogaConstants.isUndefined(percent)</span><span class="s2">;</span>
    <span class="s1">updatePadding()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">updatePadding() {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">spacingType = Spacing.LEFT</span><span class="s2">; </span><span class="s1">spacingType &lt;= Spacing.ALL</span><span class="s2">; </span><span class="s1">spacingType++) {</span>
      <span class="s2">if </span><span class="s1">(spacingType == Spacing.LEFT</span>
          <span class="s1">|| spacingType == Spacing.RIGHT</span>
          <span class="s1">|| spacingType == Spacing.START</span>
          <span class="s1">|| spacingType == Spacing.END) {</span>
        <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(mPadding[spacingType])</span>
            <span class="s1">&amp;&amp; YogaConstants.isUndefined(mPadding[Spacing.HORIZONTAL])</span>
            <span class="s1">&amp;&amp; YogaConstants.isUndefined(mPadding[Spacing.ALL])) {</span>
          <span class="s1">mYogaNode.setPadding(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">mDefaultPadding.getRaw(spacingType))</span><span class="s2">;</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(spacingType == Spacing.TOP || spacingType == Spacing.BOTTOM) {</span>
        <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(mPadding[spacingType])</span>
            <span class="s1">&amp;&amp; YogaConstants.isUndefined(mPadding[Spacing.VERTICAL])</span>
            <span class="s1">&amp;&amp; YogaConstants.isUndefined(mPadding[Spacing.ALL])) {</span>
          <span class="s1">mYogaNode.setPadding(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">mDefaultPadding.getRaw(spacingType))</span><span class="s2">;</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(YogaConstants.isUndefined(mPadding[spacingType])) {</span>
          <span class="s1">mYogaNode.setPadding(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">mDefaultPadding.getRaw(spacingType))</span><span class="s2">;</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(mPaddingIsPercent[spacingType]) {</span>
        <span class="s1">mYogaNode.setPaddingPercent(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">mPadding[spacingType])</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">mYogaNode.setPadding(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">mPadding[spacingType])</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setBorder(</span><span class="s2">int </span><span class="s1">spacingType</span><span class="s2">, float </span><span class="s1">borderWidth) {</span>
    <span class="s1">mYogaNode.setBorder(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">borderWidth)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setPosition(</span><span class="s2">int </span><span class="s1">spacingType</span><span class="s2">, float </span><span class="s1">position) {</span>
    <span class="s1">mYogaNode.setPosition(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">position)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setPositionPercent(</span><span class="s2">int </span><span class="s1">spacingType</span><span class="s2">, float </span><span class="s1">percent) {</span>
    <span class="s1">mYogaNode.setPositionPercent(YogaEdge.fromInt(spacingType)</span><span class="s2">, </span><span class="s1">percent)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setPositionType(YogaPositionType positionType) {</span>
    <span class="s1">mYogaNode.setPositionType(positionType)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setShouldNotifyOnLayout(</span><span class="s2">boolean </span><span class="s1">shouldNotifyOnLayout) {</span>
    <span class="s1">mShouldNotifyOnLayout = shouldNotifyOnLayout</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setBaselineFunction(YogaBaselineFunction baselineFunction) {</span>
    <span class="s1">mYogaNode.setBaselineFunction(baselineFunction)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setMeasureFunction(YogaMeasureFunction measureFunction) {</span>
    <span class="s1">mYogaNode.setMeasureFunction(measureFunction)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">isMeasureDefined() {</span>
    <span class="s2">return </span><span class="s1">mYogaNode.isMeasureDefined()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">String getHierarchyInfo() {</span>
    <span class="s1">StringBuilder sb = </span><span class="s2">new </span><span class="s1">StringBuilder()</span><span class="s2">;</span>
    <span class="s1">getHierarchyInfoWithIndentation(sb</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">sb.toString()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">getHierarchyInfoWithIndentation(StringBuilder result</span><span class="s2">, int </span><span class="s1">level) {</span>
    <span class="s0">// Spaces and tabs are dropped by IntelliJ logcat integration, so rely on __ instead.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; level</span><span class="s2">; </span><span class="s1">++i) {</span>
      <span class="s1">result.append(</span><span class="s7">&quot;  &quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">result</span>
        <span class="s1">.append(</span><span class="s7">&quot;&lt;&quot;</span><span class="s1">)</span>
        <span class="s1">.append(getClass().getSimpleName())</span>
        <span class="s1">.append(</span><span class="s7">&quot; view='&quot;</span><span class="s1">)</span>
        <span class="s1">.append(getViewClass())</span>
        <span class="s1">.append(</span><span class="s7">&quot;' tag=&quot;</span><span class="s1">)</span>
        <span class="s1">.append(getReactTag())</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mYogaNode != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">result</span>
          <span class="s1">.append(</span><span class="s7">&quot; layout='x:&quot;</span><span class="s1">)</span>
          <span class="s1">.append(getScreenX())</span>
          <span class="s1">.append(</span><span class="s7">&quot; y:&quot;</span><span class="s1">)</span>
          <span class="s1">.append(getScreenY())</span>
          <span class="s1">.append(</span><span class="s7">&quot; w:&quot;</span><span class="s1">)</span>
          <span class="s1">.append(getLayoutWidth())</span>
          <span class="s1">.append(</span><span class="s7">&quot; h:&quot;</span><span class="s1">)</span>
          <span class="s1">.append(getLayoutHeight())</span>
          <span class="s1">.append(</span><span class="s7">&quot;'&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">result.append(</span><span class="s7">&quot;(virtual node)&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">result.append(</span><span class="s7">&quot;&gt;</span><span class="s2">\n</span><span class="s7">&quot;</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(getChildCount() == </span><span class="s6">0</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; getChildCount()</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">getChildAt(i).getHierarchyInfoWithIndentation(result</span><span class="s2">, </span><span class="s1">level + </span><span class="s6">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">dispose() {</span>
    <span class="s2">if </span><span class="s1">(mYogaNode != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mYogaNode.reset()</span><span class="s2">;</span>
      <span class="s1">YogaNodePool.get().release(mYogaNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setMeasureSpecs(</span><span class="s2">int </span><span class="s1">widthMeasureSpec</span><span class="s2">, int </span><span class="s1">heightMeasureSpec) {</span>
    <span class="s1">mWidthMeasureSpec = widthMeasureSpec</span><span class="s2">;</span>
    <span class="s1">mHeightMeasureSpec = heightMeasureSpec</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">Integer getWidthMeasureSpec() {</span>
    <span class="s2">return </span><span class="s1">mWidthMeasureSpec</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">Integer getHeightMeasureSpec() {</span>
    <span class="s2">return </span><span class="s1">mHeightMeasureSpec</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public </span><span class="s1">Iterable&lt;? </span><span class="s2">extends </span><span class="s1">ReactShadowNode&gt; calculateLayoutOnChildren() {</span>
    <span class="s2">return </span><span class="s1">isVirtualAnchor()</span>
        <span class="s1">?</span>
        <span class="s0">// All of the descendants are virtual so none of them are involved in layout.</span>
        <span class="s2">null</span>
        <span class="s1">:</span>
        <span class="s0">// Just return the children. Flexbox calculations have already been run on them.</span>
        <span class="s1">mChildren</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>ScopeManager.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ScopeManager.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import type </span><span class="s1">{ </span><span class="s2">TSESTree </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'@typescript-eslint/types'</span><span class="s1">;</span>
<span class="s0">import type </span><span class="s1">{ </span><span class="s2">Scope </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'./scope'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">BlockScope</span><span class="s1">, </span><span class="s2">CatchScope</span><span class="s1">, </span><span class="s2">ClassScope</span><span class="s1">, </span><span class="s2">ConditionalTypeScope</span><span class="s1">, </span><span class="s2">ForScope</span><span class="s1">, </span><span class="s2">FunctionExpressionNameScope</span><span class="s1">, </span><span class="s2">FunctionScope</span><span class="s1">, </span><span class="s2">FunctionTypeScope</span><span class="s1">, </span><span class="s2">GlobalScope</span><span class="s1">, </span><span class="s2">MappedTypeScope</span><span class="s1">, </span><span class="s2">ModuleScope</span><span class="s1">, </span><span class="s2">SwitchScope</span><span class="s1">, </span><span class="s2">TSEnumScope</span><span class="s1">, </span><span class="s2">TSModuleScope</span><span class="s1">, </span><span class="s2">TypeScope</span><span class="s1">, </span><span class="s2">WithScope </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'./scope'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">ClassFieldInitializerScope </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'./scope/ClassFieldInitializerScope'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">ClassStaticBlockScope </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'./scope/ClassStaticBlockScope'</span><span class="s1">;</span>
<span class="s0">import type </span><span class="s1">{ </span><span class="s2">Variable </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'./variable'</span><span class="s1">;</span>
<span class="s0">interface </span><span class="s2">ScopeManagerOptions </span><span class="s1">{</span>
    <span class="s1">globalReturn</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">sourceType</span><span class="s0">?: </span><span class="s3">'module' </span><span class="s0">| </span><span class="s3">'script'</span><span class="s1">;</span>
    <span class="s1">impliedStrict</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">ecmaVersion</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">declare class </span><span class="s2">ScopeManager </span><span class="s1">{</span>
    <span class="s1">#private;</span>
    <span class="s1">currentScope</span><span class="s0">: </span><span class="s2">Scope </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">readonly </span><span class="s1">declaredVariables</span><span class="s0">: </span><span class="s2">WeakMap</span><span class="s1">&lt;</span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">Variable</span><span class="s1">[]&gt;;</span>
    <span class="s4">/**</span>
     <span class="s4">* The root scope 
     * </span><span class="s0">@public</span>
     <span class="s4">*/</span>
    <span class="s1">globalScope</span><span class="s0">: </span><span class="s2">GlobalScope </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">readonly </span><span class="s1">nodeToScope</span><span class="s0">: </span><span class="s2">WeakMap</span><span class="s1">&lt;</span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">Scope</span><span class="s1">[]&gt;;</span>
    <span class="s4">/**</span>
     <span class="s4">* All scopes 
     * </span><span class="s0">@public</span>
     <span class="s4">*/</span>
    <span class="s0">readonly </span><span class="s1">scopes</span><span class="s0">: </span><span class="s2">Scope</span><span class="s1">[];</span>
    <span class="s0">get </span><span class="s1">variables()</span><span class="s0">: </span><span class="s2">Variable</span><span class="s1">[];</span>
    <span class="s0">constructor</span><span class="s1">(</span><span class="s2">options</span><span class="s0">: </span><span class="s2">ScopeManagerOptions</span><span class="s1">);</span>
    <span class="s1">isGlobalReturn()</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">isModule()</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">isImpliedStrict()</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">isStrictModeSupported()</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">isES6()</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Get the variables that a given AST node defines. The gotten variables' `def[].node`/`def[].parent` property is the node. 
     * If the node does not define any variable, this returns an empty array. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">An AST node to get their variables. 
     * </span><span class="s0">@public</span>
     <span class="s4">*/</span>
    <span class="s1">getDeclaredVariables(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">)</span><span class="s0">: </span><span class="s2">Variable</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Get the scope of a given AST node. The gotten scope's `block` property is the node. 
     * This method never returns `function-expression-name` scope. If the node does not have their scope, this returns `null`. 
     * 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">An AST node to get their scope. 
     * </span><span class="s0">@param </span><span class="s2">inner </span><span class="s4">If the node has multiple scopes, this returns the outermost scope normally. 
     *                If `inner` is `true` then this returns the innermost scope. 
     * </span><span class="s0">@public</span>
     <span class="s4">*/</span>
    <span class="s1">acquire(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">inner</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">)</span><span class="s0">: </span><span class="s2">Scope </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s0">protected </span><span class="s1">nestScope&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">Scope</span><span class="s1">&gt;(</span><span class="s2">scope</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">T</span><span class="s1">;</span>
    <span class="s1">nestBlockScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">BlockScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">BlockScope</span><span class="s1">;</span>
    <span class="s1">nestCatchScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">CatchScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">CatchScope</span><span class="s1">;</span>
    <span class="s1">nestClassScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">ClassScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">ClassScope</span><span class="s1">;</span>
    <span class="s1">nestClassFieldInitializerScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">ClassFieldInitializerScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">ClassFieldInitializerScope</span><span class="s1">;</span>
    <span class="s1">nestClassStaticBlockScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">ClassStaticBlockScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">ClassStaticBlockScope</span><span class="s1">;</span>
    <span class="s1">nestConditionalTypeScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">ConditionalTypeScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">ConditionalTypeScope</span><span class="s1">;</span>
    <span class="s1">nestForScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">ForScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">ForScope</span><span class="s1">;</span>
    <span class="s1">nestFunctionExpressionNameScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">FunctionExpressionNameScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">FunctionExpressionNameScope</span><span class="s1">;</span>
    <span class="s1">nestFunctionScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">FunctionScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">], </span><span class="s2">isMethodDefinition</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">)</span><span class="s0">: </span><span class="s2">FunctionScope</span><span class="s1">;</span>
    <span class="s1">nestFunctionTypeScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">FunctionTypeScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">FunctionTypeScope</span><span class="s1">;</span>
    <span class="s1">nestGlobalScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">GlobalScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">GlobalScope</span><span class="s1">;</span>
    <span class="s1">nestMappedTypeScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">MappedTypeScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">MappedTypeScope</span><span class="s1">;</span>
    <span class="s1">nestModuleScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">ModuleScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">ModuleScope</span><span class="s1">;</span>
    <span class="s1">nestSwitchScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">SwitchScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">SwitchScope</span><span class="s1">;</span>
    <span class="s1">nestTSEnumScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSEnumScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">TSEnumScope</span><span class="s1">;</span>
    <span class="s1">nestTSModuleScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSModuleScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">TSModuleScope</span><span class="s1">;</span>
    <span class="s1">nestTypeScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TypeScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">TypeScope</span><span class="s1">;</span>
    <span class="s1">nestWithScope(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">WithScope</span><span class="s1">[</span><span class="s3">'block'</span><span class="s1">])</span><span class="s0">: </span><span class="s2">WithScope</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">{ </span><span class="s2">ScopeManager </span><span class="s1">};</span>
<span class="s4">//# sourceMappingURL=ScopeManager.d.ts.map</span></pre>
</body>
</html>
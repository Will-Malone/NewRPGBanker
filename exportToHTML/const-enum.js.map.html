<html>
<head>
<title>const-enum.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
const-enum.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_enum&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;transpileConstEnum&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;parentIsExport&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExported&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;stmt&quot;</span><span class="s0">,</span><span class="s1">&quot;exportKind&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;spec&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;enumValues&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;translateEnumValues&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;entriesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/const-enum.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { translateEnumValues } from </span><span class="s3">\&quot;</span><span class="s1">./enum</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type NodePathConstEnum = NodePath&lt;t.TSEnumDeclaration &amp; { const: true }&gt;;</span><span class="s3">\n</span><span class="s1">export default function transpileConstEnum(</span><span class="s3">\n  </span><span class="s1">path: NodePathConstEnum,</span><span class="s3">\n  </span><span class="s1">t: typeof import(</span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { name } = path.node.id;</span><span class="s3">\n\n  </span><span class="s1">const parentIsExport = path.parentPath.isExportNamedDeclaration();</span><span class="s3">\n  </span><span class="s1">let isExported = parentIsExport;</span><span class="s3">\n  </span><span class="s1">if (!isExported &amp;&amp; t.isProgram(path.parent)) {</span><span class="s3">\n    </span><span class="s1">isExported = path.parent.body.some(</span><span class="s3">\n      </span><span class="s1">stmt =&gt;</span><span class="s3">\n        </span><span class="s1">t.isExportNamedDeclaration(stmt) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">stmt.exportKind !== </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">!stmt.source &amp;&amp;</span><span class="s3">\n        </span><span class="s1">stmt.specifiers.some(</span><span class="s3">\n          </span><span class="s1">spec =&gt;</span><span class="s3">\n            </span><span class="s1">t.isExportSpecifier(spec) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">spec.exportKind !== </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">spec.local.name === name,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { enumValues: entries } = translateEnumValues(path, t);</span><span class="s3">\n\n  </span><span class="s1">if (isExported) {</span><span class="s3">\n    </span><span class="s1">const obj = t.objectExpression(</span><span class="s3">\n      </span><span class="s1">entries.map(([name, value]) =&gt;</span><span class="s3">\n        </span><span class="s1">t.objectProperty(</span><span class="s3">\n          </span><span class="s1">t.isValidIdentifier(name)</span><span class="s3">\n            </span><span class="s1">? t.identifier(name)</span><span class="s3">\n            </span><span class="s1">: t.stringLiteral(name),</span><span class="s3">\n          </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (path.scope.hasOwnBinding(name)) {</span><span class="s3">\n      </span><span class="s1">(parentIsExport ? path.parentPath : path).replaceWith(</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.callExpression(</span><span class="s3">\n            </span><span class="s1">t.memberExpression(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">Object</span><span class="s3">\&quot;</span><span class="s1">), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">assign</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n            </span><span class="s1">[path.node.id, obj],</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(</span><span class="s3">\n        </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [t.variableDeclarator(path.node.id, obj)]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">path.scope.registerDeclaration(path);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const entriesMap = new Map(entries);</span><span class="s3">\n\n  </span><span class="s1">// TODO: After fixing https://github.com/babel/babel/pull/11065, we can</span><span class="s3">\n  </span><span class="s1">// use path.scope.getBinding(name).referencePaths rather than doing</span><span class="s3">\n  </span><span class="s1">// a full traversal.</span><span class="s3">\n  </span><span class="s1">path.scope.path.traverse({</span><span class="s3">\n    </span><span class="s1">Scope(path) {</span><span class="s3">\n      </span><span class="s1">if (path.scope.hasOwnBinding(name)) path.skip();</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">MemberExpression(path) {</span><span class="s3">\n      </span><span class="s1">if (!t.isIdentifier(path.node.object, { name })) return;</span><span class="s3">\n\n      </span><span class="s1">let key: string;</span><span class="s3">\n      </span><span class="s1">if (path.node.computed) {</span><span class="s3">\n        </span><span class="s1">if (t.isStringLiteral(path.node.property)) {</span><span class="s3">\n          </span><span class="s1">key = path.node.property.value;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (t.isIdentifier(path.node.property)) {</span><span class="s3">\n        </span><span class="s1">key = path.node.property.name;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!entriesMap.has(key)) return;</span><span class="s3">\n\n      </span><span class="s1">path.replaceWith(t.cloneNode(entriesMap.get(key)));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">path.remove();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>
<html>
<head>
<title>Server.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Server.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * 
 * @format 
 * @oncall react_native 
 */</span>

<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">const { getAsset } = require(</span><span class="s2">&quot;./Assets&quot;</span><span class="s1">);</span>
<span class="s1">const baseJSBundle = require(</span><span class="s2">&quot;./DeltaBundler/Serializers/baseJSBundle&quot;</span><span class="s1">);</span>
<span class="s1">const getAllFiles = require(</span><span class="s2">&quot;./DeltaBundler/Serializers/getAllFiles&quot;</span><span class="s1">);</span>
<span class="s1">const getAssets = require(</span><span class="s2">&quot;./DeltaBundler/Serializers/getAssets&quot;</span><span class="s1">);</span>
<span class="s1">const {</span>
  <span class="s1">getExplodedSourceMap,</span>
<span class="s1">} = require(</span><span class="s2">&quot;./DeltaBundler/Serializers/getExplodedSourceMap&quot;</span><span class="s1">);</span>
<span class="s1">const getRamBundleInfo = require(</span><span class="s2">&quot;./DeltaBundler/Serializers/getRamBundleInfo&quot;</span><span class="s1">);</span>
<span class="s1">const sourceMapString = require(</span><span class="s2">&quot;./DeltaBundler/Serializers/sourceMapString&quot;</span><span class="s1">);</span>
<span class="s1">const IncrementalBundler = require(</span><span class="s2">&quot;./IncrementalBundler&quot;</span><span class="s1">);</span>
<span class="s1">const ResourceNotFoundError = require(</span><span class="s2">&quot;./IncrementalBundler/ResourceNotFoundError&quot;</span><span class="s1">);</span>
<span class="s1">const bundleToString = require(</span><span class="s2">&quot;./lib/bundleToString&quot;</span><span class="s1">);</span>
<span class="s1">const formatBundlingError = require(</span><span class="s2">&quot;./lib/formatBundlingError&quot;</span><span class="s1">);</span>
<span class="s1">const getGraphId = require(</span><span class="s2">&quot;./lib/getGraphId&quot;</span><span class="s1">);</span>
<span class="s1">const parseOptionsFromUrl = require(</span><span class="s2">&quot;./lib/parseOptionsFromUrl&quot;</span><span class="s1">);</span>
<span class="s1">const splitBundleOptions = require(</span><span class="s2">&quot;./lib/splitBundleOptions&quot;</span><span class="s1">);</span>
<span class="s1">const transformHelpers = require(</span><span class="s2">&quot;./lib/transformHelpers&quot;</span><span class="s1">);</span>
<span class="s1">const parsePlatformFilePath = require(</span><span class="s2">&quot;./node-haste/lib/parsePlatformFilePath&quot;</span><span class="s1">);</span>
<span class="s1">const symbolicate = require(</span><span class="s2">&quot;./Server/symbolicate&quot;</span><span class="s1">);</span>
<span class="s1">const { codeFrameColumns } = require(</span><span class="s2">&quot;@babel/code-frame&quot;</span><span class="s1">);</span>
<span class="s1">const MultipartResponse = require(</span><span class="s2">&quot;./Server/MultipartResponse&quot;</span><span class="s1">);</span>
<span class="s1">const debug = require(</span><span class="s2">&quot;debug&quot;</span><span class="s1">)(</span><span class="s2">&quot;Metro:Server&quot;</span><span class="s1">);</span>
<span class="s1">const fs = require(</span><span class="s2">&quot;graceful-fs&quot;</span><span class="s1">);</span>
<span class="s1">const invariant = require(</span><span class="s2">&quot;invariant&quot;</span><span class="s1">);</span>
<span class="s1">const jscSafeUrl = require(</span><span class="s2">&quot;jsc-safe-url&quot;</span><span class="s1">);</span>
<span class="s1">const {</span>
  <span class="s1">Logger,</span>
  <span class="s1">Logger: { createActionStartEntry, createActionEndEntry, log },</span>
<span class="s1">} = require(</span><span class="s2">&quot;metro-core&quot;</span><span class="s1">);</span>
<span class="s1">const mime = require(</span><span class="s2">&quot;mime-types&quot;</span><span class="s1">);</span>
<span class="s1">const nullthrows = require(</span><span class="s2">&quot;nullthrows&quot;</span><span class="s1">);</span>
<span class="s1">const path = require(</span><span class="s2">&quot;path&quot;</span><span class="s1">);</span>
<span class="s1">const querystring = require(</span><span class="s2">&quot;querystring&quot;</span><span class="s1">);</span>
<span class="s1">const url = require(</span><span class="s2">&quot;url&quot;</span><span class="s1">);</span>
<span class="s1">const noopLogger = {</span>
  <span class="s1">start: () =&gt; {},</span>
  <span class="s1">point: () =&gt; {},</span>
  <span class="s1">annotate: () =&gt; {},</span>
  <span class="s1">subSpan: () =&gt; noopLogger,</span>
  <span class="s1">end: () =&gt; {},</span>
<span class="s1">};</span>
<span class="s1">const DELTA_ID_HEADER = </span><span class="s2">&quot;X-Metro-Delta-ID&quot;</span><span class="s1">;</span>
<span class="s1">const FILES_CHANGED_COUNT_HEADER = </span><span class="s2">&quot;X-Metro-Files-Changed-Count&quot;</span><span class="s1">;</span>
<span class="s1">class Server {</span>
  <span class="s1">constructor(config, options) {</span>
    <span class="s3">this</span><span class="s1">._config = config;</span>
    <span class="s3">this</span><span class="s1">._serverOptions = options;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._config.resetCache) {</span>
      <span class="s3">this</span><span class="s1">._config.cacheStores.forEach((store) =&gt; store.clear());</span>
      <span class="s3">this</span><span class="s1">._config.reporter.update({</span>
        <span class="s1">type: </span><span class="s2">&quot;transform_cache_reset&quot;</span><span class="s1">,</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._reporter = config.reporter;</span>
    <span class="s3">this</span><span class="s1">._logger = Logger;</span>
    <span class="s3">this</span><span class="s1">._platforms = </span><span class="s3">new </span><span class="s1">Set(</span><span class="s3">this</span><span class="s1">._config.resolver.platforms);</span>
    <span class="s3">this</span><span class="s1">._isEnded = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s0">// TODO(T34760917): These two properties should eventually be instantiated</span>
    <span class="s0">// elsewhere and passed as parameters, since they are also needed by</span>
    <span class="s0">// the HmrServer.</span>
    <span class="s0">// The whole bundling/serializing logic should follow as well.</span>
    <span class="s3">this</span><span class="s1">._createModuleId = config.serializer.createModuleIdFactory();</span>
    <span class="s3">this</span><span class="s1">._bundler = </span><span class="s3">new </span><span class="s1">IncrementalBundler(config, {</span>
      <span class="s1">hasReducedPerformance: options &amp;&amp; options.hasReducedPerformance,</span>
      <span class="s1">watch: options ? options.watch : undefined,</span>
    <span class="s1">});</span>
    <span class="s3">this</span><span class="s1">._nextBundleBuildNumber = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">end() {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">._isEnded) {</span>
      <span class="s3">this</span><span class="s1">._bundler.end();</span>
      <span class="s3">this</span><span class="s1">._isEnded = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">getBundler() {</span>
    <span class="s3">return this</span><span class="s1">._bundler;</span>
  <span class="s1">}</span>
  <span class="s1">getCreateModuleId() {</span>
    <span class="s3">return this</span><span class="s1">._createModuleId;</span>
  <span class="s1">}</span>
  <span class="s1">async build(options) {</span>
    <span class="s1">const {</span>
      <span class="s1">entryFile,</span>
      <span class="s1">graphOptions,</span>
      <span class="s1">onProgress,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">serializerOptions,</span>
      <span class="s1">transformOptions,</span>
    <span class="s1">} = splitBundleOptions(options);</span>
    <span class="s1">const { prepend, graph } = await </span><span class="s3">this</span><span class="s1">._bundler.buildGraph(</span>
      <span class="s1">entryFile,</span>
      <span class="s1">transformOptions,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">{</span>
        <span class="s1">onProgress,</span>
        <span class="s1">shallow: graphOptions.shallow,</span>
        <span class="s1">lazy: graphOptions.lazy,</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
    <span class="s1">const entryPoint = </span><span class="s3">this</span><span class="s1">._getEntryPointAbsolutePath(entryFile);</span>
    <span class="s1">const bundleOptions = {</span>
      <span class="s1">asyncRequireModulePath: await </span><span class="s3">this</span><span class="s1">._resolveRelativePath(</span>
        <span class="s3">this</span><span class="s1">._config.transformer.asyncRequireModulePath,</span>
        <span class="s1">{</span>
          <span class="s1">relativeTo: </span><span class="s2">&quot;project&quot;</span><span class="s1">,</span>
          <span class="s1">resolverOptions,</span>
          <span class="s1">transformOptions,</span>
        <span class="s1">}</span>
      <span class="s1">),</span>
      <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
      <span class="s1">createModuleId: </span><span class="s3">this</span><span class="s1">._createModuleId,</span>
      <span class="s1">getRunModuleStatement: </span><span class="s3">this</span><span class="s1">._config.serializer.getRunModuleStatement,</span>
      <span class="s1">dev: transformOptions.dev,</span>
      <span class="s1">includeAsyncPaths: graphOptions.lazy,</span>
      <span class="s1">projectRoot: </span><span class="s3">this</span><span class="s1">._config.projectRoot,</span>
      <span class="s1">modulesOnly: serializerOptions.modulesOnly,</span>
      <span class="s1">runBeforeMainModule:</span>
        <span class="s3">this</span><span class="s1">._config.serializer.getModulesRunBeforeMainModule(</span>
          <span class="s1">path.relative(</span><span class="s3">this</span><span class="s1">._config.projectRoot, entryPoint)</span>
        <span class="s1">),</span>
      <span class="s1">runModule: serializerOptions.runModule,</span>
      <span class="s1">sourceMapUrl: serializerOptions.sourceMapUrl,</span>
      <span class="s1">sourceUrl: serializerOptions.sourceUrl,</span>
      <span class="s1">inlineSourceMap: serializerOptions.inlineSourceMap,</span>
      <span class="s1">serverRoot:</span>
        <span class="s3">this</span><span class="s1">._config.server.unstable_serverRoot ?? </span><span class="s3">this</span><span class="s1">._config.projectRoot,</span>
      <span class="s1">shouldAddToIgnoreList: (module) =&gt;</span>
        <span class="s3">this</span><span class="s1">._shouldAddModuleToIgnoreList(module),</span>
    <span class="s1">};</span>
    <span class="s1">let bundleCode = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">let bundleMap = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._config.serializer.customSerializer) {</span>
      <span class="s1">const bundle = await </span><span class="s3">this</span><span class="s1">._config.serializer.customSerializer(</span>
        <span class="s1">entryPoint,</span>
        <span class="s1">prepend,</span>
        <span class="s1">graph,</span>
        <span class="s1">bundleOptions</span>
      <span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">bundle === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">bundleCode = bundle;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">bundleCode = bundle.code;</span>
        <span class="s1">bundleMap = bundle.map;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">bundleCode = bundleToString(</span>
        <span class="s1">baseJSBundle(entryPoint, prepend, graph, bundleOptions)</span>
      <span class="s1">).code;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!bundleMap) {</span>
      <span class="s1">bundleMap = sourceMapString(</span>
        <span class="s1">[...prepend, ...</span><span class="s3">this</span><span class="s1">._getSortedModules(graph)],</span>
        <span class="s1">{</span>
          <span class="s1">excludeSource: serializerOptions.excludeSource,</span>
          <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
          <span class="s1">shouldAddToIgnoreList: bundleOptions.shouldAddToIgnoreList,</span>
        <span class="s1">}</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">code: bundleCode,</span>
      <span class="s1">map: bundleMap,</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">async getRamBundleInfo(options) {</span>
    <span class="s1">const {</span>
      <span class="s1">entryFile,</span>
      <span class="s1">graphOptions,</span>
      <span class="s1">onProgress,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">serializerOptions,</span>
      <span class="s1">transformOptions,</span>
    <span class="s1">} = splitBundleOptions(options);</span>
    <span class="s1">const { prepend, graph } = await </span><span class="s3">this</span><span class="s1">._bundler.buildGraph(</span>
      <span class="s1">entryFile,</span>
      <span class="s1">transformOptions,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">{</span>
        <span class="s1">onProgress,</span>
        <span class="s1">shallow: graphOptions.shallow,</span>
        <span class="s1">lazy: graphOptions.lazy,</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
    <span class="s1">const entryPoint = </span><span class="s3">this</span><span class="s1">._getEntryPointAbsolutePath(entryFile);</span>
    <span class="s3">return </span><span class="s1">await getRamBundleInfo(entryPoint, prepend, graph, {</span>
      <span class="s1">asyncRequireModulePath: await </span><span class="s3">this</span><span class="s1">._resolveRelativePath(</span>
        <span class="s3">this</span><span class="s1">._config.transformer.asyncRequireModulePath,</span>
        <span class="s1">{</span>
          <span class="s1">relativeTo: </span><span class="s2">&quot;project&quot;</span><span class="s1">,</span>
          <span class="s1">resolverOptions,</span>
          <span class="s1">transformOptions,</span>
        <span class="s1">}</span>
      <span class="s1">),</span>
      <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
      <span class="s1">createModuleId: </span><span class="s3">this</span><span class="s1">._createModuleId,</span>
      <span class="s1">dev: transformOptions.dev,</span>
      <span class="s1">excludeSource: serializerOptions.excludeSource,</span>
      <span class="s1">getRunModuleStatement: </span><span class="s3">this</span><span class="s1">._config.serializer.getRunModuleStatement,</span>
      <span class="s1">getTransformOptions: </span><span class="s3">this</span><span class="s1">._config.transformer.getTransformOptions,</span>
      <span class="s1">includeAsyncPaths: graphOptions.lazy,</span>
      <span class="s1">platform: transformOptions.platform,</span>
      <span class="s1">projectRoot: </span><span class="s3">this</span><span class="s1">._config.projectRoot,</span>
      <span class="s1">modulesOnly: serializerOptions.modulesOnly,</span>
      <span class="s1">runBeforeMainModule:</span>
        <span class="s3">this</span><span class="s1">._config.serializer.getModulesRunBeforeMainModule(</span>
          <span class="s1">path.relative(</span><span class="s3">this</span><span class="s1">._config.projectRoot, entryPoint)</span>
        <span class="s1">),</span>
      <span class="s1">runModule: serializerOptions.runModule,</span>
      <span class="s1">sourceMapUrl: serializerOptions.sourceMapUrl,</span>
      <span class="s1">sourceUrl: serializerOptions.sourceUrl,</span>
      <span class="s1">inlineSourceMap: serializerOptions.inlineSourceMap,</span>
      <span class="s1">serverRoot:</span>
        <span class="s3">this</span><span class="s1">._config.server.unstable_serverRoot ?? </span><span class="s3">this</span><span class="s1">._config.projectRoot,</span>
      <span class="s1">shouldAddToIgnoreList: (module) =&gt;</span>
        <span class="s3">this</span><span class="s1">._shouldAddModuleToIgnoreList(module),</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s1">async getAssets(options) {</span>
    <span class="s1">const { entryFile, onProgress, resolverOptions, transformOptions } =</span>
      <span class="s1">splitBundleOptions(options);</span>
    <span class="s1">const dependencies = await </span><span class="s3">this</span><span class="s1">._bundler.getDependencies(</span>
      <span class="s1">[entryFile],</span>
      <span class="s1">transformOptions,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">{</span>
        <span class="s1">onProgress,</span>
        <span class="s1">shallow: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">lazy: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
    <span class="s3">return </span><span class="s1">await getAssets(dependencies, {</span>
      <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
      <span class="s1">assetPlugins: </span><span class="s3">this</span><span class="s1">._config.transformer.assetPlugins,</span>
      <span class="s1">platform: transformOptions.platform,</span>
      <span class="s1">projectRoot: </span><span class="s3">this</span><span class="s1">._getServerRootDir(),</span>
      <span class="s1">publicPath: </span><span class="s3">this</span><span class="s1">._config.transformer.publicPath,</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s1">async getOrderedDependencyPaths(options) {</span>
    <span class="s1">const {</span>
      <span class="s1">entryFile,</span>
      <span class="s1">onProgress,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">transformOptions,</span>
      <span class="s0">/* $FlowFixMe(&gt;=0.122.0 site=react_native_fb) This comment suppresses an 
       * error found when Flow v0.122.0 was deployed. To see the error, delete 
       * this comment and run Flow. */</span>
    <span class="s1">} = splitBundleOptions({</span>
      <span class="s1">...Server.DEFAULT_BUNDLE_OPTIONS,</span>
      <span class="s1">...options,</span>
      <span class="s1">bundleType: </span><span class="s2">&quot;bundle&quot;</span><span class="s1">,</span>
    <span class="s1">});</span>
    <span class="s1">const { prepend, graph } = await </span><span class="s3">this</span><span class="s1">._bundler.buildGraph(</span>
      <span class="s1">entryFile,</span>
      <span class="s1">transformOptions,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">{</span>
        <span class="s1">onProgress,</span>
        <span class="s1">shallow: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">lazy: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
    <span class="s1">const platform =</span>
      <span class="s1">transformOptions.platform ||</span>
      <span class="s1">parsePlatformFilePath(entryFile, </span><span class="s3">this</span><span class="s1">._platforms).platform;</span>

    <span class="s0">// $FlowFixMe[incompatible-return]</span>
    <span class="s3">return </span><span class="s1">await getAllFiles(prepend, graph, {</span>
      <span class="s1">platform,</span>
      <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s1">_rangeRequestMiddleware(req, res, data, assetPath) {</span>
    <span class="s3">if </span><span class="s1">(req.headers &amp;&amp; req.headers.range) {</span>
      <span class="s1">const [rangeStart, rangeEnd] = req.headers.range</span>
        <span class="s1">.replace(/bytes=/, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">.split(</span><span class="s2">&quot;-&quot;</span><span class="s1">);</span>
      <span class="s1">const dataStart = parseInt(rangeStart, </span><span class="s4">10</span><span class="s1">);</span>
      <span class="s1">const dataEnd = rangeEnd ? parseInt(rangeEnd, </span><span class="s4">10</span><span class="s1">) : data.length - </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">const chunksize = dataEnd - dataStart + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">res.writeHead(</span><span class="s4">206</span><span class="s1">, {</span>
        <span class="s2">&quot;Accept-Ranges&quot;</span><span class="s1">: </span><span class="s2">&quot;bytes&quot;</span><span class="s1">,</span>
        <span class="s2">&quot;Content-Length&quot;</span><span class="s1">: chunksize.toString(),</span>
        <span class="s2">&quot;Content-Range&quot;</span><span class="s1">: `bytes ${dataStart}-${dataEnd}/${data.length}`,</span>
      <span class="s1">});</span>
      <span class="s3">return </span><span class="s1">data.slice(dataStart, dataEnd + </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">res.setHeader(</span><span class="s2">&quot;Content-Length&quot;</span><span class="s1">, String(Buffer.byteLength(data)));</span>
    <span class="s3">return </span><span class="s1">data;</span>
  <span class="s1">}</span>
  <span class="s1">async _processSingleAssetRequest(req, res) {</span>
    <span class="s1">const urlObj = url.parse(decodeURI(req.url), </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">let [, assetPath] =</span>
      <span class="s1">(urlObj &amp;&amp;</span>
        <span class="s1">urlObj.pathname &amp;&amp;</span>
        <span class="s1">urlObj.pathname.match(/^\/assets\/(.+)$/)) ||</span>
      <span class="s1">[];</span>
    <span class="s3">if </span><span class="s1">(!assetPath &amp;&amp; urlObj &amp;&amp; urlObj.query &amp;&amp; urlObj.query.unstable_path) {</span>
      <span class="s1">const [, actualPath, secondaryQuery] = nullthrows(</span>
        <span class="s1">urlObj.query.unstable_path.match(/^([^?]*)\??(.*)$/)</span>
      <span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(secondaryQuery) {</span>
        <span class="s1">Object.assign(urlObj.query, querystring.parse(secondaryQuery));</span>
      <span class="s1">}</span>
      <span class="s1">assetPath = actualPath;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!assetPath) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Could not extract asset path from URL&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const processingAssetRequestLogEntry = log(</span>
      <span class="s1">createActionStartEntry({</span>
        <span class="s1">action_name: </span><span class="s2">&quot;Processing asset request&quot;</span><span class="s1">,</span>
        <span class="s1">asset: assetPath[</span><span class="s4">1</span><span class="s1">],</span>
      <span class="s1">})</span>
    <span class="s1">);</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">const data = await getAsset(</span>
        <span class="s1">assetPath,</span>
        <span class="s3">this</span><span class="s1">._config.projectRoot,</span>
        <span class="s3">this</span><span class="s1">._config.watchFolders,</span>
        <span class="s1">urlObj.query.platform,</span>
        <span class="s3">this</span><span class="s1">._config.resolver.assetExts</span>
      <span class="s1">);</span>
      <span class="s0">// Tell clients to cache this for 1 year.</span>
      <span class="s0">// This is safe as the asset url contains a hash of the asset.</span>
      <span class="s3">if </span><span class="s1">(process.env.REACT_NATIVE_ENABLE_ASSET_CACHING === </span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s1">res.setHeader(</span><span class="s2">&quot;Cache-Control&quot;</span><span class="s1">, </span><span class="s2">&quot;max-age=31536000&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s1">res.setHeader(</span><span class="s2">&quot;Content-Type&quot;</span><span class="s1">, mime.lookup(path.basename(assetPath)));</span>
      <span class="s1">res.end(</span><span class="s3">this</span><span class="s1">._rangeRequestMiddleware(req, res, data, assetPath));</span>
      <span class="s1">process.nextTick(() =&gt; {</span>
        <span class="s1">log(createActionEndEntry(processingAssetRequestLogEntry));</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s1">console.error(error.stack);</span>
      <span class="s1">res.writeHead(</span><span class="s4">404</span><span class="s1">);</span>
      <span class="s1">res.end(</span><span class="s2">&quot;Asset not found&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">processRequest = (req, res, next) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._processRequest(req, res, next).</span><span class="s3">catch</span><span class="s1">(next);</span>
  <span class="s1">};</span>
  <span class="s1">_parseOptions(url) {</span>
    <span class="s3">return </span><span class="s1">parseOptionsFromUrl(url, </span><span class="s3">new </span><span class="s1">Set(</span><span class="s3">this</span><span class="s1">._config.resolver.platforms));</span>
  <span class="s1">}</span>
  <span class="s1">_rewriteAndNormalizeUrl(requestUrl) {</span>
    <span class="s3">return </span><span class="s1">jscSafeUrl.toNormalUrl(</span>
      <span class="s3">this</span><span class="s1">._config.server.rewriteRequestUrl(jscSafeUrl.toNormalUrl(requestUrl))</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">async _processRequest(req, res, next) {</span>
    <span class="s1">const originalUrl = req.url;</span>
    <span class="s1">req.url = </span><span class="s3">this</span><span class="s1">._rewriteAndNormalizeUrl(req.url);</span>
    <span class="s1">const urlObj = url.parse(req.url, </span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">const { host } = req.headers;</span>
    <span class="s1">debug(</span>
      <span class="s1">`Handling request: ${host ? </span><span class="s2">&quot;http://&quot; </span><span class="s1">+ host : </span><span class="s2">&quot;&quot;</span><span class="s1">}${req.url}` +</span>
        <span class="s1">(originalUrl !== req.url ? ` (rewritten from ${originalUrl})` : </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">);</span>
    <span class="s1">const formattedUrl = url.format({</span>
      <span class="s1">...urlObj,</span>
      <span class="s1">host,</span>
      <span class="s1">protocol: </span><span class="s2">&quot;http&quot;</span><span class="s1">,</span>
    <span class="s1">});</span>
    <span class="s1">const pathname = urlObj.pathname || </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">const buildNumber = </span><span class="s3">this</span><span class="s1">.getNewBuildNumber();</span>
    <span class="s3">if </span><span class="s1">(pathname.endsWith(</span><span class="s2">&quot;.bundle&quot;</span><span class="s1">)) {</span>
      <span class="s1">const options = </span><span class="s3">this</span><span class="s1">._parseOptions(formattedUrl);</span>
      <span class="s1">await </span><span class="s3">this</span><span class="s1">._processBundleRequest(req, res, options, {</span>
        <span class="s1">buildNumber,</span>
        <span class="s1">bundlePerfLogger:</span>
          <span class="s3">this</span><span class="s1">._config.unstable_perfLoggerFactory?.(</span><span class="s2">&quot;BUNDLING_REQUEST&quot;</span><span class="s1">, {</span>
            <span class="s1">key: buildNumber,</span>
          <span class="s1">}) ?? noopLogger,</span>
      <span class="s1">});</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._serverOptions &amp;&amp; </span><span class="s3">this</span><span class="s1">._serverOptions.onBundleBuilt) {</span>
        <span class="s3">this</span><span class="s1">._serverOptions.onBundleBuilt(pathname);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(pathname.endsWith(</span><span class="s2">&quot;.map&quot;</span><span class="s1">)) {</span>
      <span class="s0">// Chrome dev tools may need to access the source maps.</span>
      <span class="s1">res.setHeader(</span><span class="s2">&quot;Access-Control-Allow-Origin&quot;</span><span class="s1">, </span><span class="s2">&quot;devtools://devtools&quot;</span><span class="s1">);</span>
      <span class="s1">await </span><span class="s3">this</span><span class="s1">._processSourceMapRequest(</span>
        <span class="s1">req,</span>
        <span class="s1">res,</span>
        <span class="s3">this</span><span class="s1">._parseOptions(formattedUrl),</span>
        <span class="s1">{</span>
          <span class="s1">buildNumber,</span>
          <span class="s1">bundlePerfLogger: noopLogger,</span>
        <span class="s1">}</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(pathname.endsWith(</span><span class="s2">&quot;.assets&quot;</span><span class="s1">)) {</span>
      <span class="s1">await </span><span class="s3">this</span><span class="s1">._processAssetsRequest(</span>
        <span class="s1">req,</span>
        <span class="s1">res,</span>
        <span class="s3">this</span><span class="s1">._parseOptions(formattedUrl),</span>
        <span class="s1">{</span>
          <span class="s1">buildNumber,</span>
          <span class="s1">bundlePerfLogger: noopLogger,</span>
        <span class="s1">}</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(pathname.startsWith(</span><span class="s2">&quot;/assets/&quot;</span><span class="s1">) || pathname === </span><span class="s2">&quot;/assets&quot;</span><span class="s1">) {</span>
      <span class="s1">await </span><span class="s3">this</span><span class="s1">._processSingleAssetRequest(req, res);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(pathname === </span><span class="s2">&quot;/symbolicate&quot;</span><span class="s1">) {</span>
      <span class="s1">await </span><span class="s3">this</span><span class="s1">._symbolicate(req, res);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">next();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_createRequestProcessor({</span>
    <span class="s1">createStartEntry,</span>
    <span class="s1">createEndEntry,</span>
    <span class="s1">build,</span>
    <span class="s3">delete</span><span class="s1">: deleteFn,</span>
    <span class="s1">finish,</span>
  <span class="s1">}) {</span>
    <span class="s3">return </span><span class="s1">async </span><span class="s3">function </span><span class="s1">requestProcessor(</span>
      <span class="s1">req,</span>
      <span class="s1">res,</span>
      <span class="s1">bundleOptions,</span>
      <span class="s1">buildContext</span>
    <span class="s1">) {</span>
      <span class="s1">const { buildNumber } = buildContext;</span>
      <span class="s1">const {</span>
        <span class="s1">entryFile,</span>
        <span class="s1">graphOptions,</span>
        <span class="s1">resolverOptions,</span>
        <span class="s1">serializerOptions,</span>
        <span class="s1">transformOptions,</span>
      <span class="s1">} = splitBundleOptions(bundleOptions);</span>

      <span class="s0">/** 
       * `entryFile` is relative to projectRoot, we need to use resolution function 
       * to find the appropriate file with supported extensions. 
       */</span>
      <span class="s1">const resolvedEntryFilePath = await </span><span class="s3">this</span><span class="s1">._resolveRelativePath(entryFile, {</span>
        <span class="s1">relativeTo: </span><span class="s2">&quot;server&quot;</span><span class="s1">,</span>
        <span class="s1">resolverOptions,</span>
        <span class="s1">transformOptions,</span>
      <span class="s1">});</span>
      <span class="s1">const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {</span>
        <span class="s1">unstable_allowRequireContext:</span>
          <span class="s3">this</span><span class="s1">._config.transformer.unstable_allowRequireContext,</span>
        <span class="s1">resolverOptions,</span>
        <span class="s1">shallow: graphOptions.shallow,</span>
        <span class="s1">lazy: graphOptions.lazy,</span>
      <span class="s1">});</span>

      <span class="s0">// For resources that support deletion, handle the DELETE method.</span>
      <span class="s3">if </span><span class="s1">(deleteFn &amp;&amp; req.method === </span><span class="s2">&quot;DELETE&quot;</span><span class="s1">) {</span>
        <span class="s1">const deleteContext = {</span>
          <span class="s1">graphId,</span>
          <span class="s1">req,</span>
          <span class="s1">res,</span>
        <span class="s1">};</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">await deleteFn(deleteContext);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s1">const formattedError = formatBundlingError(error);</span>
          <span class="s1">const status = error </span><span class="s3">instanceof </span><span class="s1">ResourceNotFoundError ? </span><span class="s4">404 </span><span class="s1">: </span><span class="s4">500</span><span class="s1">;</span>
          <span class="s1">res.writeHead(status, {</span>
            <span class="s2">&quot;Content-Type&quot;</span><span class="s1">: </span><span class="s2">&quot;application/json; charset=UTF-8&quot;</span><span class="s1">,</span>
          <span class="s1">});</span>
          <span class="s1">res.end(JSON.stringify(formattedError));</span>
        <span class="s1">}</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const mres = MultipartResponse.wrapIfSupported(req, res);</span>
      <span class="s1">let onProgress = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">let lastProgress = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._config.reporter) {</span>
        <span class="s1">onProgress = (transformedFileCount, totalFileCount) =&gt; {</span>
          <span class="s1">const currentProgress = parseInt(</span>
            <span class="s1">(transformedFileCount / totalFileCount) * </span><span class="s4">100</span><span class="s1">,</span>
            <span class="s4">10</span>
          <span class="s1">);</span>

          <span class="s0">// We want to throttle the updates so that we only show meaningful</span>
          <span class="s0">// UI updates slow enough for the client to actually handle them. For</span>
          <span class="s0">// that, we check the percentage, and only send percentages that are</span>
          <span class="s0">// actually different and that have increased from the last one we sent.</span>
          <span class="s3">if </span><span class="s1">(currentProgress &gt; lastProgress || totalFileCount &lt; </span><span class="s4">10</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(mres </span><span class="s3">instanceof </span><span class="s1">MultipartResponse) {</span>
              <span class="s1">mres.writeChunk(</span>
                <span class="s1">{</span>
                  <span class="s2">&quot;Content-Type&quot;</span><span class="s1">: </span><span class="s2">&quot;application/json&quot;</span><span class="s1">,</span>
                <span class="s1">},</span>
                <span class="s1">JSON.stringify({</span>
                  <span class="s1">done: transformedFileCount,</span>
                  <span class="s1">total: totalFileCount,</span>
                <span class="s1">})</span>
              <span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s0">// The `uncork` called internally in Node via `promise.nextTick()` may not fire</span>
            <span class="s0">// until all of the Promises are resolved because the microtask queue we're</span>
            <span class="s0">// in could be starving the event loop. This can cause a bug where the progress</span>
            <span class="s0">// is not actually sent in the response until after bundling is complete. This</span>
            <span class="s0">// would defeat the purpose of sending progress, so we `uncork` the stream now</span>
            <span class="s0">// which will force the response to flush to the client immediately.</span>
            <span class="s0">// $FlowFixMe[method-unbinding] added when improving typing for this parameters</span>
            <span class="s3">if </span><span class="s1">(res.socket != </span><span class="s3">null </span><span class="s1">&amp;&amp; res.socket.uncork != </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">res.socket.uncork();</span>
            <span class="s1">}</span>
            <span class="s1">lastProgress = currentProgress;</span>
          <span class="s1">}</span>
          <span class="s3">this</span><span class="s1">._reporter.update({</span>
            <span class="s1">buildID: getBuildID(buildNumber),</span>
            <span class="s1">type: </span><span class="s2">&quot;bundle_transform_progressed&quot;</span><span class="s1">,</span>
            <span class="s1">transformedFileCount,</span>
            <span class="s1">totalFileCount,</span>
          <span class="s1">});</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
      <span class="s3">this</span><span class="s1">._reporter.update({</span>
        <span class="s1">buildID: getBuildID(buildNumber),</span>
        <span class="s1">bundleDetails: {</span>
          <span class="s1">bundleType: bundleOptions.bundleType,</span>
          <span class="s1">dev: transformOptions.dev,</span>
          <span class="s1">entryFile: resolvedEntryFilePath,</span>
          <span class="s1">minify: transformOptions.minify,</span>
          <span class="s1">platform: transformOptions.platform,</span>
        <span class="s1">},</span>
        <span class="s1">isPrefetch: req.method === </span><span class="s2">&quot;HEAD&quot;</span><span class="s1">,</span>
        <span class="s1">type: </span><span class="s2">&quot;bundle_build_started&quot;</span><span class="s1">,</span>
      <span class="s1">});</span>
      <span class="s1">const startContext = {</span>
        <span class="s1">buildNumber,</span>
        <span class="s1">bundleOptions,</span>
        <span class="s1">entryFile: resolvedEntryFilePath,</span>
        <span class="s1">graphId,</span>
        <span class="s1">graphOptions,</span>
        <span class="s1">mres,</span>
        <span class="s1">onProgress,</span>
        <span class="s1">req,</span>
        <span class="s1">resolverOptions,</span>
        <span class="s1">serializerOptions,</span>
        <span class="s1">transformOptions,</span>
        <span class="s1">bundlePerfLogger: buildContext.bundlePerfLogger,</span>
      <span class="s1">};</span>
      <span class="s1">const logEntry = log(</span>
        <span class="s1">createActionStartEntry(createStartEntry(startContext))</span>
      <span class="s1">);</span>
      <span class="s1">let result;</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">result = await build(startContext);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s1">const formattedError = formatBundlingError(error);</span>
        <span class="s1">const status = error </span><span class="s3">instanceof </span><span class="s1">ResourceNotFoundError ? </span><span class="s4">404 </span><span class="s1">: </span><span class="s4">500</span><span class="s1">;</span>
        <span class="s1">mres.writeHead(status, {</span>
          <span class="s2">&quot;Content-Type&quot;</span><span class="s1">: </span><span class="s2">&quot;application/json; charset=UTF-8&quot;</span><span class="s1">,</span>
        <span class="s1">});</span>
        <span class="s1">mres.end(JSON.stringify(formattedError));</span>
        <span class="s3">this</span><span class="s1">._reporter.update({</span>
          <span class="s1">buildID: getBuildID(buildNumber),</span>
          <span class="s1">type: </span><span class="s2">&quot;bundle_build_failed&quot;</span><span class="s1">,</span>
          <span class="s1">bundleOptions,</span>
        <span class="s1">});</span>
        <span class="s3">this</span><span class="s1">._reporter.update({</span>
          <span class="s1">error,</span>
          <span class="s1">type: </span><span class="s2">&quot;bundling_error&quot;</span><span class="s1">,</span>
        <span class="s1">});</span>
        <span class="s1">log({</span>
          <span class="s1">action_name: </span><span class="s2">&quot;bundling_error&quot;</span><span class="s1">,</span>
          <span class="s1">error_type: formattedError.type,</span>
          <span class="s1">log_entry_label: </span><span class="s2">&quot;bundling_error&quot;</span><span class="s1">,</span>
          <span class="s1">bundle_id: graphId,</span>
          <span class="s1">build_id: getBuildID(buildNumber),</span>
          <span class="s1">stack: formattedError.message,</span>
        <span class="s1">});</span>
        <span class="s1">debug(</span><span class="s2">&quot;Bundling error&quot;</span><span class="s1">, error);</span>
        <span class="s1">buildContext.bundlePerfLogger.end(</span><span class="s2">&quot;FAIL&quot;</span><span class="s1">);</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const endContext = {</span>
        <span class="s1">...startContext,</span>
        <span class="s1">result,</span>
      <span class="s1">};</span>
      <span class="s1">finish(endContext);</span>
      <span class="s3">this</span><span class="s1">._reporter.update({</span>
        <span class="s1">buildID: getBuildID(buildNumber),</span>
        <span class="s1">type: </span><span class="s2">&quot;bundle_build_done&quot;</span><span class="s1">,</span>
      <span class="s1">});</span>
      <span class="s1">log(</span>
        <span class="s0">/* $FlowFixMe(&gt;=0.122.0 site=react_native_fb) This comment suppresses 
         * an error found when Flow v0.122.0 was deployed. To see the error, 
         * delete this comment and run Flow. */</span>
        <span class="s1">createActionEndEntry({</span>
          <span class="s1">...logEntry,</span>
          <span class="s1">...createEndEntry(endContext),</span>
        <span class="s1">})</span>
      <span class="s1">);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">_processBundleRequest = </span><span class="s3">this</span><span class="s1">._createRequestProcessor({</span>
    <span class="s1">createStartEntry(context) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">action_name: </span><span class="s2">&quot;Requesting bundle&quot;</span><span class="s1">,</span>
        <span class="s1">bundle_url: context.req.url,</span>
        <span class="s1">entry_point: context.entryFile,</span>
        <span class="s1">bundler: </span><span class="s2">&quot;delta&quot;</span><span class="s1">,</span>
        <span class="s1">build_id: getBuildID(context.buildNumber),</span>
        <span class="s1">bundle_options: context.bundleOptions,</span>
        <span class="s1">bundle_hash: context.graphId,</span>
        <span class="s1">user_agent: context.req.headers[</span><span class="s2">&quot;user-agent&quot;</span><span class="s1">] ?? </span><span class="s2">&quot;unknown&quot;</span><span class="s1">,</span>
      <span class="s1">};</span>
    <span class="s1">},</span>
    <span class="s1">createEndEntry(context) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">outdated_modules: context.result.numModifiedFiles,</span>
      <span class="s1">};</span>
    <span class="s1">},</span>
    <span class="s1">build: async ({</span>
      <span class="s1">entryFile,</span>
      <span class="s1">graphId,</span>
      <span class="s1">graphOptions,</span>
      <span class="s1">onProgress,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">serializerOptions,</span>
      <span class="s1">transformOptions,</span>
      <span class="s1">bundlePerfLogger,</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s1">bundlePerfLogger.start();</span>
      <span class="s1">bundlePerfLogger.annotate({</span>
        <span class="s1">string: {</span>
          <span class="s1">bundle_url: entryFile,</span>
        <span class="s1">},</span>
      <span class="s1">});</span>
      <span class="s1">const revPromise = </span><span class="s3">this</span><span class="s1">._bundler.getRevisionByGraphId(graphId);</span>
      <span class="s1">bundlePerfLogger.point(</span><span class="s2">&quot;resolvingAndTransformingDependencies_start&quot;</span><span class="s1">);</span>
      <span class="s1">bundlePerfLogger.annotate({</span>
        <span class="s1">bool: {</span>
          <span class="s1">initial_build: revPromise == </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">},</span>
      <span class="s1">});</span>
      <span class="s1">const { delta, revision } = await (revPromise != </span><span class="s3">null</span>
        <span class="s1">? </span><span class="s3">this</span><span class="s1">._bundler.updateGraph(await revPromise, </span><span class="s3">false</span><span class="s1">)</span>
        <span class="s1">: </span><span class="s3">this</span><span class="s1">._bundler.initializeGraph(</span>
            <span class="s1">entryFile,</span>
            <span class="s1">transformOptions,</span>
            <span class="s1">resolverOptions,</span>
            <span class="s1">{</span>
              <span class="s1">onProgress,</span>
              <span class="s1">shallow: graphOptions.shallow,</span>
              <span class="s1">lazy: graphOptions.lazy,</span>
            <span class="s1">}</span>
          <span class="s1">));</span>
      <span class="s1">bundlePerfLogger.point(</span><span class="s2">&quot;resolvingAndTransformingDependencies_end&quot;</span><span class="s1">);</span>
      <span class="s1">bundlePerfLogger.point(</span><span class="s2">&quot;serializingBundle_start&quot;</span><span class="s1">);</span>
      <span class="s1">const serializer =</span>
        <span class="s3">this</span><span class="s1">._config.serializer.customSerializer ||</span>
        <span class="s1">((entryPoint, preModules, graph, options) =&gt;</span>
          <span class="s1">bundleToString(baseJSBundle(entryPoint, preModules, graph, options))</span>
            <span class="s1">.code);</span>
      <span class="s1">const bundle = await serializer(</span>
        <span class="s1">entryFile,</span>
        <span class="s1">revision.prepend,</span>
        <span class="s1">revision.graph,</span>
        <span class="s1">{</span>
          <span class="s1">asyncRequireModulePath: await </span><span class="s3">this</span><span class="s1">._resolveRelativePath(</span>
            <span class="s3">this</span><span class="s1">._config.transformer.asyncRequireModulePath,</span>
            <span class="s1">{</span>
              <span class="s1">relativeTo: </span><span class="s2">&quot;project&quot;</span><span class="s1">,</span>
              <span class="s1">resolverOptions,</span>
              <span class="s1">transformOptions,</span>
            <span class="s1">}</span>
          <span class="s1">),</span>
          <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
          <span class="s1">createModuleId: </span><span class="s3">this</span><span class="s1">._createModuleId,</span>
          <span class="s1">getRunModuleStatement: </span><span class="s3">this</span><span class="s1">._config.serializer.getRunModuleStatement,</span>
          <span class="s1">includeAsyncPaths: graphOptions.lazy,</span>
          <span class="s1">dev: transformOptions.dev,</span>
          <span class="s1">projectRoot: </span><span class="s3">this</span><span class="s1">._config.projectRoot,</span>
          <span class="s1">modulesOnly: serializerOptions.modulesOnly,</span>
          <span class="s1">runBeforeMainModule:</span>
            <span class="s3">this</span><span class="s1">._config.serializer.getModulesRunBeforeMainModule(</span>
              <span class="s1">path.relative(</span><span class="s3">this</span><span class="s1">._config.projectRoot, entryFile)</span>
            <span class="s1">),</span>
          <span class="s1">runModule: serializerOptions.runModule,</span>
          <span class="s1">sourceMapUrl: serializerOptions.sourceMapUrl,</span>
          <span class="s1">sourceUrl: serializerOptions.sourceUrl,</span>
          <span class="s1">inlineSourceMap: serializerOptions.inlineSourceMap,</span>
          <span class="s1">serverRoot:</span>
            <span class="s3">this</span><span class="s1">._config.server.unstable_serverRoot ?? </span><span class="s3">this</span><span class="s1">._config.projectRoot,</span>
          <span class="s1">shouldAddToIgnoreList: (module) =&gt;</span>
            <span class="s3">this</span><span class="s1">._shouldAddModuleToIgnoreList(module),</span>
        <span class="s1">}</span>
      <span class="s1">);</span>
      <span class="s1">bundlePerfLogger.point(</span><span class="s2">&quot;serializingBundle_end&quot;</span><span class="s1">);</span>
      <span class="s1">const bundleCode = </span><span class="s3">typeof </span><span class="s1">bundle === </span><span class="s2">&quot;string&quot; </span><span class="s1">? bundle : bundle.code;</span>
      <span class="s1">bundlePerfLogger.end(</span><span class="s2">&quot;SUCCESS&quot;</span><span class="s1">);</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">numModifiedFiles: delta.reset</span>
          <span class="s1">? delta.added.size + revision.prepend.length</span>
          <span class="s1">: delta.added.size + delta.modified.size + delta.deleted.size,</span>
        <span class="s1">lastModifiedDate: revision.date,</span>
        <span class="s1">nextRevId: revision.id,</span>
        <span class="s1">bundle: bundleCode,</span>
      <span class="s1">};</span>
    <span class="s1">},</span>
    <span class="s1">finish({ req, mres, serializerOptions, result }) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s0">// We avoid parsing the dates since the client should never send a more</span>
        <span class="s0">// recent date than the one returned by the Delta Bundler (if that's the</span>
        <span class="s0">// case it's fine to return the whole bundle).</span>
        <span class="s1">req.headers[</span><span class="s2">&quot;if-modified-since&quot;</span><span class="s1">] ===</span>
        <span class="s1">result.lastModifiedDate.toUTCString()</span>
      <span class="s1">) {</span>
        <span class="s1">debug(</span><span class="s2">&quot;Responding with 304&quot;</span><span class="s1">);</span>
        <span class="s1">mres.writeHead(</span><span class="s4">304</span><span class="s1">);</span>
        <span class="s1">mres.end();</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">mres.setHeader(</span>
          <span class="s1">FILES_CHANGED_COUNT_HEADER,</span>
          <span class="s1">String(result.numModifiedFiles)</span>
        <span class="s1">);</span>
        <span class="s1">mres.setHeader(DELTA_ID_HEADER, String(result.nextRevId));</span>
        <span class="s3">if </span><span class="s1">(serializerOptions?.sourceUrl != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">mres.setHeader(</span><span class="s2">&quot;Content-Location&quot;</span><span class="s1">, serializerOptions.sourceUrl);</span>
        <span class="s1">}</span>
        <span class="s1">mres.setHeader(</span><span class="s2">&quot;Content-Type&quot;</span><span class="s1">, </span><span class="s2">&quot;application/javascript; charset=UTF-8&quot;</span><span class="s1">);</span>
        <span class="s1">mres.setHeader(</span><span class="s2">&quot;Last-Modified&quot;</span><span class="s1">, result.lastModifiedDate.toUTCString());</span>
        <span class="s1">mres.setHeader(</span>
          <span class="s2">&quot;Content-Length&quot;</span><span class="s1">,</span>
          <span class="s1">String(Buffer.byteLength(result.bundle))</span>
        <span class="s1">);</span>
        <span class="s1">mres.end(result.bundle);</span>
      <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s3">delete</span><span class="s1">: async ({ graphId, res }) =&gt; {</span>
      <span class="s1">await </span><span class="s3">this</span><span class="s1">._bundler.endGraph(graphId);</span>
      <span class="s1">res.statusCode = </span><span class="s4">204</span><span class="s1">;</span>
      <span class="s1">res.end();</span>
    <span class="s1">},</span>
  <span class="s1">});</span>

  <span class="s0">// This function ensures that modules in source maps are sorted in the same</span>
  <span class="s0">// order as in a plain JS bundle.</span>
  <span class="s1">_getSortedModules(graph) {</span>
    <span class="s1">const modules = [...graph.dependencies.values()];</span>
    <span class="s0">// Assign IDs to modules in a consistent order</span>
    <span class="s3">for </span><span class="s1">(const module of modules) {</span>
      <span class="s3">this</span><span class="s1">._createModuleId(module.path);</span>
    <span class="s1">}</span>
    <span class="s0">// Sort by IDs</span>
    <span class="s3">return </span><span class="s1">modules.sort(</span>
      <span class="s1">(a, b) =&gt; </span><span class="s3">this</span><span class="s1">._createModuleId(a.path) - </span><span class="s3">this</span><span class="s1">._createModuleId(b.path)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">_processSourceMapRequest = </span><span class="s3">this</span><span class="s1">._createRequestProcessor({</span>
    <span class="s1">createStartEntry(context) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">action_name: </span><span class="s2">&quot;Requesting sourcemap&quot;</span><span class="s1">,</span>
        <span class="s1">bundle_url: context.req.url,</span>
        <span class="s1">entry_point: context.entryFile,</span>
        <span class="s1">bundler: </span><span class="s2">&quot;delta&quot;</span><span class="s1">,</span>
      <span class="s1">};</span>
    <span class="s1">},</span>
    <span class="s1">createEndEntry(context) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">bundler: </span><span class="s2">&quot;delta&quot;</span><span class="s1">,</span>
      <span class="s1">};</span>
    <span class="s1">},</span>
    <span class="s1">build: async ({</span>
      <span class="s1">entryFile,</span>
      <span class="s1">graphId,</span>
      <span class="s1">graphOptions,</span>
      <span class="s1">onProgress,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">serializerOptions,</span>
      <span class="s1">transformOptions,</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s1">let revision;</span>
      <span class="s1">const revPromise = </span><span class="s3">this</span><span class="s1">._bundler.getRevisionByGraphId(graphId);</span>
      <span class="s3">if </span><span class="s1">(revPromise == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">({ revision } = await </span><span class="s3">this</span><span class="s1">._bundler.initializeGraph(</span>
          <span class="s1">entryFile,</span>
          <span class="s1">transformOptions,</span>
          <span class="s1">resolverOptions,</span>
          <span class="s1">{</span>
            <span class="s1">onProgress,</span>
            <span class="s1">shallow: graphOptions.shallow,</span>
            <span class="s1">lazy: graphOptions.lazy,</span>
          <span class="s1">}</span>
        <span class="s1">));</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">({ revision } = await </span><span class="s3">this</span><span class="s1">._bundler.updateGraph(</span>
          <span class="s1">await revPromise,</span>
          <span class="s3">false</span>
        <span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s1">let { prepend, graph } = revision;</span>
      <span class="s3">if </span><span class="s1">(serializerOptions.modulesOnly) {</span>
        <span class="s1">prepend = [];</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">sourceMapString([...prepend, ...</span><span class="s3">this</span><span class="s1">._getSortedModules(graph)], {</span>
        <span class="s1">excludeSource: serializerOptions.excludeSource,</span>
        <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
        <span class="s1">shouldAddToIgnoreList: (module) =&gt;</span>
          <span class="s3">this</span><span class="s1">._shouldAddModuleToIgnoreList(module),</span>
      <span class="s1">});</span>
    <span class="s1">},</span>
    <span class="s1">finish({ mres, result }) {</span>
      <span class="s1">mres.setHeader(</span><span class="s2">&quot;Content-Type&quot;</span><span class="s1">, </span><span class="s2">&quot;application/json&quot;</span><span class="s1">);</span>
      <span class="s1">mres.end(result.toString());</span>
    <span class="s1">},</span>
  <span class="s1">});</span>
  <span class="s1">_processAssetsRequest = </span><span class="s3">this</span><span class="s1">._createRequestProcessor({</span>
    <span class="s1">createStartEntry(context) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">action_name: </span><span class="s2">&quot;Requesting assets&quot;</span><span class="s1">,</span>
        <span class="s1">bundle_url: context.req.url,</span>
        <span class="s1">entry_point: context.entryFile,</span>
        <span class="s1">bundler: </span><span class="s2">&quot;delta&quot;</span><span class="s1">,</span>
      <span class="s1">};</span>
    <span class="s1">},</span>
    <span class="s1">createEndEntry(context) {</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">bundler: </span><span class="s2">&quot;delta&quot;</span><span class="s1">,</span>
      <span class="s1">};</span>
    <span class="s1">},</span>
    <span class="s1">build: async ({</span>
      <span class="s1">entryFile,</span>
      <span class="s1">onProgress,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">transformOptions,</span>
    <span class="s1">}) =&gt; {</span>
      <span class="s1">const dependencies = await </span><span class="s3">this</span><span class="s1">._bundler.getDependencies(</span>
        <span class="s1">[entryFile],</span>
        <span class="s1">transformOptions,</span>
        <span class="s1">resolverOptions,</span>
        <span class="s1">{</span>
          <span class="s1">onProgress,</span>
          <span class="s1">shallow: </span><span class="s3">false</span><span class="s1">,</span>
          <span class="s1">lazy: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">}</span>
      <span class="s1">);</span>
      <span class="s3">return </span><span class="s1">await getAssets(dependencies, {</span>
        <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
        <span class="s1">assetPlugins: </span><span class="s3">this</span><span class="s1">._config.transformer.assetPlugins,</span>
        <span class="s1">platform: transformOptions.platform,</span>
        <span class="s1">publicPath: </span><span class="s3">this</span><span class="s1">._config.transformer.publicPath,</span>
        <span class="s1">projectRoot: </span><span class="s3">this</span><span class="s1">._config.projectRoot,</span>
      <span class="s1">});</span>
    <span class="s1">},</span>
    <span class="s1">finish({ mres, result }) {</span>
      <span class="s1">mres.setHeader(</span><span class="s2">&quot;Content-Type&quot;</span><span class="s1">, </span><span class="s2">&quot;application/json&quot;</span><span class="s1">);</span>
      <span class="s1">mres.end(JSON.stringify(result));</span>
    <span class="s1">},</span>
  <span class="s1">});</span>
  <span class="s1">async _symbolicate(req, res) {</span>
    <span class="s1">const getCodeFrame = (urls, symbolicatedStack) =&gt; {</span>
      <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; symbolicatedStack.length; i++) {</span>
        <span class="s1">const { collapse, column, file, lineNumber } = symbolicatedStack[i];</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">collapse ||</span>
          <span class="s1">lineNumber == </span><span class="s3">null </span><span class="s1">||</span>
          <span class="s1">(file != </span><span class="s3">null </span><span class="s1">&amp;&amp; urls.has(file))</span>
        <span class="s1">) {</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const fileAbsolute = path.resolve(</span><span class="s3">this</span><span class="s1">._config.projectRoot, file ?? </span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">content: codeFrameColumns(</span>
              <span class="s1">fs.readFileSync(fileAbsolute, </span><span class="s2">&quot;utf8&quot;</span><span class="s1">),</span>
              <span class="s1">{</span>
                <span class="s0">// Metro returns 0 based columns but codeFrameColumns expects 1-based columns</span>
                <span class="s0">// $FlowFixMe[unsafe-addition]</span>
                <span class="s1">start: {</span>
                  <span class="s1">column: column + </span><span class="s4">1</span><span class="s1">,</span>
                  <span class="s1">line: lineNumber,</span>
                <span class="s1">},</span>
              <span class="s1">},</span>
              <span class="s1">{</span>
                <span class="s1">forceColor: </span><span class="s3">true</span><span class="s1">,</span>
              <span class="s1">}</span>
            <span class="s1">),</span>
            <span class="s1">location: {</span>
              <span class="s1">row: lineNumber,</span>
              <span class="s1">column,</span>
            <span class="s1">},</span>
            <span class="s1">fileName: file,</span>
          <span class="s1">};</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s1">console.error(error);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s3">try </span><span class="s1">{</span>
      <span class="s1">const symbolicatingLogEntry = log(</span>
        <span class="s1">createActionStartEntry(</span><span class="s2">&quot;Symbolicating&quot;</span><span class="s1">)</span>
      <span class="s1">);</span>
      <span class="s1">debug(</span><span class="s2">&quot;Start symbolication&quot;</span><span class="s1">);</span>
      <span class="s0">/* $FlowFixMe: where is `rawBody` defined? Is it added by the `connect` framework? */</span>
      <span class="s1">const body = await req.rawBody;</span>
      <span class="s1">const parsedBody = JSON.parse(body);</span>
      <span class="s1">const rewriteAndNormalizeStackFrame = (frame, lineNumber) =&gt; {</span>
        <span class="s1">invariant(</span>
          <span class="s1">frame != </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">frame === </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
          <span class="s2">&quot;Bad stack frame at line %d, expected object, received: %s&quot;</span><span class="s1">,</span>
          <span class="s1">lineNumber,</span>
          <span class="s3">typeof </span><span class="s1">frame</span>
        <span class="s1">);</span>
        <span class="s1">const frameFile = frame.file;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">frameFile === </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp; frameFile.includes(</span><span class="s2">&quot;://&quot;</span><span class="s1">)) {</span>
          <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">...frame,</span>
            <span class="s1">file: </span><span class="s3">this</span><span class="s1">._rewriteAndNormalizeUrl(frameFile),</span>
          <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">frame;</span>
      <span class="s1">};</span>
      <span class="s1">const stack = parsedBody.stack.map(rewriteAndNormalizeStackFrame);</span>
      <span class="s0">// In case of multiple bundles / HMR, some stack frames can have different URLs from others</span>
      <span class="s1">const urls = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s1">stack.forEach((frame) =&gt; {</span>
        <span class="s0">// These urls have been rewritten and normalized above.</span>
        <span class="s1">const sourceUrl = frame.file;</span>
        <span class="s0">// Skip `/debuggerWorker.js` which does not need symbolication.</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">sourceUrl != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!urls.has(sourceUrl) &amp;&amp;</span>
          <span class="s1">!sourceUrl.endsWith(</span><span class="s2">&quot;/debuggerWorker.js&quot;</span><span class="s1">) &amp;&amp;</span>
          <span class="s1">sourceUrl.startsWith(</span><span class="s2">&quot;http&quot;</span><span class="s1">)</span>
        <span class="s1">) {</span>
          <span class="s1">urls.add(sourceUrl);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s1">debug(</span><span class="s2">&quot;Getting source maps for symbolication&quot;</span><span class="s1">);</span>
      <span class="s1">const sourceMaps = await Promise.all(</span>
        <span class="s1">Array.from(urls.values()).map((normalizedUrl) =&gt;</span>
          <span class="s3">this</span><span class="s1">._explodedSourceMapForBundleOptions(</span>
            <span class="s3">this</span><span class="s1">._parseOptions(normalizedUrl)</span>
          <span class="s1">)</span>
        <span class="s1">)</span>
      <span class="s1">);</span>
      <span class="s1">debug(</span><span class="s2">&quot;Performing fast symbolication&quot;</span><span class="s1">);</span>
      <span class="s1">const symbolicatedStack = await symbolicate(</span>
        <span class="s1">stack,</span>
        <span class="s1">zip(urls.values(), sourceMaps),</span>
        <span class="s3">this</span><span class="s1">._config,</span>
        <span class="s1">parsedBody.extraData ?? {}</span>
      <span class="s1">);</span>
      <span class="s1">debug(</span><span class="s2">&quot;Symbolication done&quot;</span><span class="s1">);</span>
      <span class="s1">res.end(</span>
        <span class="s1">JSON.stringify({</span>
          <span class="s1">codeFrame: getCodeFrame(urls, symbolicatedStack),</span>
          <span class="s1">stack: symbolicatedStack,</span>
        <span class="s1">})</span>
      <span class="s1">);</span>
      <span class="s1">process.nextTick(() =&gt; {</span>
        <span class="s1">log(createActionEndEntry(symbolicatingLogEntry));</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
      <span class="s1">console.error(error.stack || error);</span>
      <span class="s1">res.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
      <span class="s1">res.end(</span>
        <span class="s1">JSON.stringify({</span>
          <span class="s1">error: error.message,</span>
        <span class="s1">})</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">async _explodedSourceMapForBundleOptions(bundleOptions) {</span>
    <span class="s1">const {</span>
      <span class="s1">entryFile,</span>
      <span class="s1">graphOptions,</span>
      <span class="s1">onProgress,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">serializerOptions,</span>
      <span class="s1">transformOptions,</span>
    <span class="s1">} = splitBundleOptions(bundleOptions);</span>

    <span class="s0">/** 
     * `entryFile` is relative to projectRoot, we need to use resolution function 
     * to find the appropriate file with supported extensions. 
     */</span>
    <span class="s1">const resolvedEntryFilePath = await </span><span class="s3">this</span><span class="s1">._resolveRelativePath(entryFile, {</span>
      <span class="s1">relativeTo: </span><span class="s2">&quot;server&quot;</span><span class="s1">,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">transformOptions,</span>
    <span class="s1">});</span>
    <span class="s1">const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {</span>
      <span class="s1">unstable_allowRequireContext:</span>
        <span class="s3">this</span><span class="s1">._config.transformer.unstable_allowRequireContext,</span>
      <span class="s1">resolverOptions,</span>
      <span class="s1">shallow: graphOptions.shallow,</span>
      <span class="s1">lazy: graphOptions.lazy,</span>
    <span class="s1">});</span>
    <span class="s1">let revision;</span>
    <span class="s1">const revPromise = </span><span class="s3">this</span><span class="s1">._bundler.getRevisionByGraphId(graphId);</span>
    <span class="s3">if </span><span class="s1">(revPromise == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">({ revision } = await </span><span class="s3">this</span><span class="s1">._bundler.initializeGraph(</span>
        <span class="s1">resolvedEntryFilePath,</span>
        <span class="s1">transformOptions,</span>
        <span class="s1">resolverOptions,</span>
        <span class="s1">{</span>
          <span class="s1">onProgress,</span>
          <span class="s1">shallow: graphOptions.shallow,</span>
          <span class="s1">lazy: graphOptions.lazy,</span>
        <span class="s1">}</span>
      <span class="s1">));</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">({ revision } = await </span><span class="s3">this</span><span class="s1">._bundler.updateGraph(await revPromise, </span><span class="s3">false</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s1">let { prepend, graph } = revision;</span>
    <span class="s3">if </span><span class="s1">(serializerOptions.modulesOnly) {</span>
      <span class="s1">prepend = [];</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">getExplodedSourceMap(</span>
      <span class="s1">[...prepend, ...</span><span class="s3">this</span><span class="s1">._getSortedModules(graph)],</span>
      <span class="s1">{</span>
        <span class="s1">processModuleFilter: </span><span class="s3">this</span><span class="s1">._config.serializer.processModuleFilter,</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">async _resolveRelativePath(</span>
    <span class="s1">filePath,</span>
    <span class="s1">{ relativeTo, resolverOptions, transformOptions }</span>
  <span class="s1">) {</span>
    <span class="s1">const resolutionFn = await transformHelpers.getResolveDependencyFn(</span>
      <span class="s3">this</span><span class="s1">._bundler.getBundler(),</span>
      <span class="s1">transformOptions.platform,</span>
      <span class="s1">resolverOptions</span>
    <span class="s1">);</span>
    <span class="s1">const rootDir =</span>
      <span class="s1">relativeTo === </span><span class="s2">&quot;server&quot;</span>
        <span class="s1">? </span><span class="s3">this</span><span class="s1">._getServerRootDir()</span>
        <span class="s1">: </span><span class="s3">this</span><span class="s1">._config.projectRoot;</span>
    <span class="s3">return </span><span class="s1">resolutionFn(`${rootDir}/.`, filePath).filePath;</span>
  <span class="s1">}</span>
  <span class="s1">getNewBuildNumber() {</span>
    <span class="s3">return this</span><span class="s1">._nextBundleBuildNumber++;</span>
  <span class="s1">}</span>
  <span class="s1">getPlatforms() {</span>
    <span class="s3">return this</span><span class="s1">._config.resolver.platforms;</span>
  <span class="s1">}</span>
  <span class="s1">getWatchFolders() {</span>
    <span class="s3">return this</span><span class="s1">._config.watchFolders;</span>
  <span class="s1">}</span>
  <span class="s1">static DEFAULT_GRAPH_OPTIONS = {</span>
    <span class="s1">customResolverOptions: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
    <span class="s1">customTransformOptions: Object.create(</span><span class="s3">null</span><span class="s1">),</span>
    <span class="s1">dev: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">hot: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">minify: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">unstable_transformProfile: </span><span class="s2">&quot;default&quot;</span><span class="s1">,</span>
  <span class="s1">};</span>
  <span class="s1">static DEFAULT_BUNDLE_OPTIONS = {</span>
    <span class="s1">...Server.DEFAULT_GRAPH_OPTIONS,</span>
    <span class="s1">excludeSource: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">inlineSourceMap: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">lazy: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">modulesOnly: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">onProgress: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">runModule: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">shallow: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">sourceMapUrl: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">sourceUrl: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">};</span>
  <span class="s1">_getServerRootDir() {</span>
    <span class="s3">return this</span><span class="s1">._config.server.unstable_serverRoot ?? </span><span class="s3">this</span><span class="s1">._config.projectRoot;</span>
  <span class="s1">}</span>
  <span class="s1">_getEntryPointAbsolutePath(entryFile) {</span>
    <span class="s3">return </span><span class="s1">path.resolve(</span><span class="s3">this</span><span class="s1">._getServerRootDir(), entryFile);</span>
  <span class="s1">}</span>

  <span class="s0">// Wait for the server to finish initializing.</span>
  <span class="s1">async ready() {</span>
    <span class="s1">await </span><span class="s3">this</span><span class="s1">._bundler.ready();</span>
  <span class="s1">}</span>
  <span class="s1">_shouldAddModuleToIgnoreList(module) {</span>
    <span class="s0">// TODO: Add flag to Module signifying whether it represents generated code</span>
    <span class="s0">// and clean up these heuristics.</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s0">// Prelude code, see getPrependedScripts.js</span>
      <span class="s1">module.path === </span><span class="s2">&quot;__prelude__&quot; </span><span class="s1">||</span>
      <span class="s0">// Generated require.context() module, see contextModule.js</span>
      <span class="s1">module.path.includes(</span><span class="s2">&quot;?ctx=&quot;</span><span class="s1">) ||</span>
      <span class="s3">this</span><span class="s1">._config.serializer.isThirdPartyModule(module)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function</span><span class="s1">* zip(xs, ys) {</span>
  <span class="s0">//$FlowIssue #9324959</span>
  <span class="s1">const ysIter = ys[Symbol.iterator]();</span>
  <span class="s3">for </span><span class="s1">(const x of xs) {</span>
    <span class="s1">const y = ysIter.next();</span>
    <span class="s3">if </span><span class="s1">(y.done) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">yield [x, y.value];</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">getBuildID(buildNumber) {</span>
  <span class="s3">return </span><span class="s1">buildNumber.toString(</span><span class="s4">36</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">module.exports = Server;</span>
</pre>
</body>
</html>
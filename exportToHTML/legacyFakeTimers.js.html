<html>
<head>
<title>legacyFakeTimers.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
legacyFakeTimers.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">_util() {</span>
  <span class="s1">const data = require(</span><span class="s0">'util'</span><span class="s1">);</span>
  <span class="s1">_util = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestMessageUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-message-util'</span><span class="s1">);</span>
  <span class="s1">_jestMessageUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_jestUtil() {</span>
  <span class="s1">const data = require(</span><span class="s0">'jest-util'</span><span class="s1">);</span>
  <span class="s1">_jestUtil = </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s1">data;</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">data;</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s4">/* eslint-disable local/prefer-spread-eventually */</span>

<span class="s1">const MS_IN_A_YEAR = </span><span class="s3">31536000000</span><span class="s1">;</span>
<span class="s1">class FakeTimers {</span>
  <span class="s1">_cancelledTicks;</span>
  <span class="s1">_config;</span>
  <span class="s1">_disposed;</span>
  <span class="s1">_fakeTimerAPIs;</span>
  <span class="s1">_fakingTime = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">_global;</span>
  <span class="s1">_immediates;</span>
  <span class="s1">_maxLoops;</span>
  <span class="s1">_moduleMocker;</span>
  <span class="s1">_now;</span>
  <span class="s1">_ticks;</span>
  <span class="s1">_timerAPIs;</span>
  <span class="s1">_timers;</span>
  <span class="s1">_uuidCounter;</span>
  <span class="s1">_timerConfig;</span>
  <span class="s1">constructor({global, moduleMocker, timerConfig, config, maxLoops}) {</span>
    <span class="s2">this</span><span class="s1">._global = global;</span>
    <span class="s2">this</span><span class="s1">._timerConfig = timerConfig;</span>
    <span class="s2">this</span><span class="s1">._config = config;</span>
    <span class="s2">this</span><span class="s1">._maxLoops = maxLoops || </span><span class="s3">100000</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">._uuidCounter = </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">._moduleMocker = moduleMocker;</span>

    <span class="s4">// Store original timer APIs for future reference</span>
    <span class="s2">this</span><span class="s1">._timerAPIs = {</span>
      <span class="s1">cancelAnimationFrame: global.cancelAnimationFrame,</span>
      <span class="s1">clearImmediate: global.clearImmediate,</span>
      <span class="s1">clearInterval: global.clearInterval,</span>
      <span class="s1">clearTimeout: global.clearTimeout,</span>
      <span class="s1">nextTick: global.process &amp;&amp; global.process.nextTick,</span>
      <span class="s1">requestAnimationFrame: global.requestAnimationFrame,</span>
      <span class="s1">setImmediate: global.setImmediate,</span>
      <span class="s1">setInterval: global.setInterval,</span>
      <span class="s1">setTimeout: global.setTimeout</span>
    <span class="s1">};</span>
    <span class="s2">this</span><span class="s1">._disposed = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.reset();</span>
  <span class="s1">}</span>
  <span class="s1">clearAllTimers() {</span>
    <span class="s2">this</span><span class="s1">._immediates = [];</span>
    <span class="s2">this</span><span class="s1">._timers.clear();</span>
  <span class="s1">}</span>
  <span class="s1">dispose() {</span>
    <span class="s2">this</span><span class="s1">._disposed = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">.clearAllTimers();</span>
  <span class="s1">}</span>
  <span class="s1">reset() {</span>
    <span class="s2">this</span><span class="s1">._cancelledTicks = {};</span>
    <span class="s2">this</span><span class="s1">._now = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">._ticks = [];</span>
    <span class="s2">this</span><span class="s1">._immediates = [];</span>
    <span class="s2">this</span><span class="s1">._timers = </span><span class="s2">new </span><span class="s1">Map();</span>
  <span class="s1">}</span>
  <span class="s1">now() {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._fakingTime) {</span>
      <span class="s2">return this</span><span class="s1">._now;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Date.now();</span>
  <span class="s1">}</span>
  <span class="s1">runAllTicks() {</span>
    <span class="s2">this</span><span class="s1">._checkFakeTimers();</span>
    <span class="s4">// Only run a generous number of ticks and then bail.</span>
    <span class="s4">// This is just to help avoid recursive loops</span>
    <span class="s1">let i;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">._maxLoops; i++) {</span>
      <span class="s1">const tick = </span><span class="s2">this</span><span class="s1">._ticks.shift();</span>
      <span class="s2">if </span><span class="s1">(tick === undefined) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">!Object.prototype.hasOwnProperty.call(</span><span class="s2">this</span><span class="s1">._cancelledTicks, tick.uuid)</span>
      <span class="s1">) {</span>
        <span class="s4">// Callback may throw, so update the map prior calling.</span>
        <span class="s2">this</span><span class="s1">._cancelledTicks[tick.uuid] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">tick.callback();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(i === </span><span class="s2">this</span><span class="s1">._maxLoops) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s1">`Ran ${</span><span class="s2">this</span><span class="s1">._maxLoops} ticks, and there are still more! ` +</span>
          <span class="s0">&quot;Assuming we've hit an infinite recursion and bailing out...&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">runAllImmediates() {</span>
    <span class="s2">this</span><span class="s1">._checkFakeTimers();</span>
    <span class="s4">// Only run a generous number of immediates and then bail.</span>
    <span class="s1">let i;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">._maxLoops; i++) {</span>
      <span class="s1">const immediate = </span><span class="s2">this</span><span class="s1">._immediates.shift();</span>
      <span class="s2">if </span><span class="s1">(immediate === undefined) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._runImmediate(immediate);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(i === </span><span class="s2">this</span><span class="s1">._maxLoops) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s1">`Ran ${</span><span class="s2">this</span><span class="s1">._maxLoops} immediates, and there are still more! Assuming ` +</span>
          <span class="s0">&quot;we've hit an infinite recursion and bailing out...&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_runImmediate(immediate) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">immediate.callback();</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">._fakeClearImmediate(immediate.uuid);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">runAllTimers() {</span>
    <span class="s2">this</span><span class="s1">._checkFakeTimers();</span>
    <span class="s2">this</span><span class="s1">.runAllTicks();</span>
    <span class="s2">this</span><span class="s1">.runAllImmediates();</span>

    <span class="s4">// Only run a generous number of timers and then bail.</span>
    <span class="s4">// This is just to help avoid recursive loops</span>
    <span class="s1">let i;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">._maxLoops; i++) {</span>
      <span class="s1">const nextTimerHandleAndExpiry = </span><span class="s2">this</span><span class="s1">._getNextTimerHandleAndExpiry();</span>

      <span class="s4">// If there are no more timer handles, stop!</span>
      <span class="s2">if </span><span class="s1">(nextTimerHandleAndExpiry === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const [nextTimerHandle, expiry] = nextTimerHandleAndExpiry;</span>
      <span class="s2">this</span><span class="s1">._now = expiry;</span>
      <span class="s2">this</span><span class="s1">._runTimerHandle(nextTimerHandle);</span>

      <span class="s4">// Some of the immediate calls could be enqueued</span>
      <span class="s4">// during the previous handling of the timers, we should</span>
      <span class="s4">// run them as well.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._immediates.length) {</span>
        <span class="s2">this</span><span class="s1">.runAllImmediates();</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._ticks.length) {</span>
        <span class="s2">this</span><span class="s1">.runAllTicks();</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(i === </span><span class="s2">this</span><span class="s1">._maxLoops) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s1">`Ran ${</span><span class="s2">this</span><span class="s1">._maxLoops} timers, and there are still more! ` +</span>
          <span class="s0">&quot;Assuming we've hit an infinite recursion and bailing out...&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">runOnlyPendingTimers() {</span>
    <span class="s4">// We need to hold the current shape of `this._timers` because existing</span>
    <span class="s4">// timers can add new ones to the map and hence would run more than necessary.</span>
    <span class="s4">// See https://github.com/facebook/jest/pull/4608 for details</span>
    <span class="s1">const timerEntries = Array.from(</span><span class="s2">this</span><span class="s1">._timers.entries());</span>
    <span class="s2">this</span><span class="s1">._checkFakeTimers();</span>
    <span class="s2">this</span><span class="s1">._immediates.forEach(</span><span class="s2">this</span><span class="s1">._runImmediate, </span><span class="s2">this</span><span class="s1">);</span>
    <span class="s1">timerEntries</span>
      <span class="s1">.sort(([, left], [, right]) =&gt; left.expiry - right.expiry)</span>
      <span class="s1">.forEach(([timerHandle, timer]) =&gt; {</span>
        <span class="s2">this</span><span class="s1">._now = timer.expiry;</span>
        <span class="s2">this</span><span class="s1">._runTimerHandle(timerHandle);</span>
      <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s1">advanceTimersToNextTimer(steps = </span><span class="s3">1</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(steps &lt; </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const nextExpiry = Array.from(</span><span class="s2">this</span><span class="s1">._timers.values()).reduce(</span>
      <span class="s1">(minExpiry, timer) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(minExpiry === </span><span class="s2">null </span><span class="s1">|| timer.expiry &lt; minExpiry) </span><span class="s2">return </span><span class="s1">timer.expiry;</span>
        <span class="s2">return </span><span class="s1">minExpiry;</span>
      <span class="s1">},</span>
      <span class="s2">null</span>
    <span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(nextExpiry !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.advanceTimersByTime(nextExpiry - </span><span class="s2">this</span><span class="s1">._now);</span>
      <span class="s2">this</span><span class="s1">.advanceTimersToNextTimer(steps - </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">advanceTimersByTime(msToRun) {</span>
    <span class="s2">this</span><span class="s1">._checkFakeTimers();</span>
    <span class="s4">// Only run a generous number of timers and then bail.</span>
    <span class="s4">// This is just to help avoid recursive loops</span>
    <span class="s1">let i;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">._maxLoops; i++) {</span>
      <span class="s1">const timerHandleAndExpiry = </span><span class="s2">this</span><span class="s1">._getNextTimerHandleAndExpiry();</span>

      <span class="s4">// If there are no more timer handles, stop!</span>
      <span class="s2">if </span><span class="s1">(timerHandleAndExpiry === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">const [timerHandle, nextTimerExpiry] = timerHandleAndExpiry;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._now + msToRun &lt; nextTimerExpiry) {</span>
        <span class="s4">// There are no timers between now and the target we're running to</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">msToRun -= nextTimerExpiry - </span><span class="s2">this</span><span class="s1">._now;</span>
        <span class="s2">this</span><span class="s1">._now = nextTimerExpiry;</span>
        <span class="s2">this</span><span class="s1">._runTimerHandle(timerHandle);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">// Advance the clock by whatever time we still have left to run</span>
    <span class="s2">this</span><span class="s1">._now += msToRun;</span>
    <span class="s2">if </span><span class="s1">(i === </span><span class="s2">this</span><span class="s1">._maxLoops) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span>
        <span class="s1">`Ran ${</span><span class="s2">this</span><span class="s1">._maxLoops} timers, and there are still more! ` +</span>
          <span class="s0">&quot;Assuming we've hit an infinite recursion and bailing out...&quot;</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">runWithRealTimers(cb) {</span>
    <span class="s1">const prevClearImmediate = </span><span class="s2">this</span><span class="s1">._global.clearImmediate;</span>
    <span class="s1">const prevClearInterval = </span><span class="s2">this</span><span class="s1">._global.clearInterval;</span>
    <span class="s1">const prevClearTimeout = </span><span class="s2">this</span><span class="s1">._global.clearTimeout;</span>
    <span class="s1">const prevNextTick = </span><span class="s2">this</span><span class="s1">._global.process.nextTick;</span>
    <span class="s1">const prevSetImmediate = </span><span class="s2">this</span><span class="s1">._global.setImmediate;</span>
    <span class="s1">const prevSetInterval = </span><span class="s2">this</span><span class="s1">._global.setInterval;</span>
    <span class="s1">const prevSetTimeout = </span><span class="s2">this</span><span class="s1">._global.setTimeout;</span>
    <span class="s2">this</span><span class="s1">.useRealTimers();</span>
    <span class="s1">let cbErr = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">let errThrown = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">cb();</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
      <span class="s1">errThrown = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">cbErr = e;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">._global.clearImmediate = prevClearImmediate;</span>
    <span class="s2">this</span><span class="s1">._global.clearInterval = prevClearInterval;</span>
    <span class="s2">this</span><span class="s1">._global.clearTimeout = prevClearTimeout;</span>
    <span class="s2">this</span><span class="s1">._global.process.nextTick = prevNextTick;</span>
    <span class="s2">this</span><span class="s1">._global.setImmediate = prevSetImmediate;</span>
    <span class="s2">this</span><span class="s1">._global.setInterval = prevSetInterval;</span>
    <span class="s2">this</span><span class="s1">._global.setTimeout = prevSetTimeout;</span>
    <span class="s2">if </span><span class="s1">(errThrown) {</span>
      <span class="s2">throw </span><span class="s1">cbErr;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">useRealTimers() {</span>
    <span class="s1">const global = </span><span class="s2">this</span><span class="s1">._global;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global.cancelAnimationFrame === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
        <span class="s1">global,</span>
        <span class="s0">'cancelAnimationFrame'</span><span class="s1">,</span>
        <span class="s2">this</span><span class="s1">._timerAPIs.cancelAnimationFrame</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global.clearImmediate === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
        <span class="s1">global,</span>
        <span class="s0">'clearImmediate'</span><span class="s1">,</span>
        <span class="s2">this</span><span class="s1">._timerAPIs.clearImmediate</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
      <span class="s1">global,</span>
      <span class="s0">'clearInterval'</span><span class="s1">,</span>
      <span class="s2">this</span><span class="s1">._timerAPIs.clearInterval</span>
    <span class="s1">);</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
      <span class="s1">global,</span>
      <span class="s0">'clearTimeout'</span><span class="s1">,</span>
      <span class="s2">this</span><span class="s1">._timerAPIs.clearTimeout</span>
    <span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global.requestAnimationFrame === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
        <span class="s1">global,</span>
        <span class="s0">'requestAnimationFrame'</span><span class="s1">,</span>
        <span class="s2">this</span><span class="s1">._timerAPIs.requestAnimationFrame</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global.setImmediate === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
        <span class="s1">global,</span>
        <span class="s0">'setImmediate'</span><span class="s1">,</span>
        <span class="s2">this</span><span class="s1">._timerAPIs.setImmediate</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
      <span class="s1">global,</span>
      <span class="s0">'setInterval'</span><span class="s1">,</span>
      <span class="s2">this</span><span class="s1">._timerAPIs.setInterval</span>
    <span class="s1">);</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
      <span class="s1">global,</span>
      <span class="s0">'setTimeout'</span><span class="s1">,</span>
      <span class="s2">this</span><span class="s1">._timerAPIs.setTimeout</span>
    <span class="s1">);</span>
    <span class="s1">global.process.nextTick = </span><span class="s2">this</span><span class="s1">._timerAPIs.nextTick;</span>
    <span class="s2">this</span><span class="s1">._fakingTime = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">useFakeTimers() {</span>
    <span class="s2">this</span><span class="s1">._createMocks();</span>
    <span class="s1">const global = </span><span class="s2">this</span><span class="s1">._global;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global.cancelAnimationFrame === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
        <span class="s1">global,</span>
        <span class="s0">'cancelAnimationFrame'</span><span class="s1">,</span>
        <span class="s2">this</span><span class="s1">._fakeTimerAPIs.cancelAnimationFrame</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global.clearImmediate === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
        <span class="s1">global,</span>
        <span class="s0">'clearImmediate'</span><span class="s1">,</span>
        <span class="s2">this</span><span class="s1">._fakeTimerAPIs.clearImmediate</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
      <span class="s1">global,</span>
      <span class="s0">'clearInterval'</span><span class="s1">,</span>
      <span class="s2">this</span><span class="s1">._fakeTimerAPIs.clearInterval</span>
    <span class="s1">);</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
      <span class="s1">global,</span>
      <span class="s0">'clearTimeout'</span><span class="s1">,</span>
      <span class="s2">this</span><span class="s1">._fakeTimerAPIs.clearTimeout</span>
    <span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global.requestAnimationFrame === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
        <span class="s1">global,</span>
        <span class="s0">'requestAnimationFrame'</span><span class="s1">,</span>
        <span class="s2">this</span><span class="s1">._fakeTimerAPIs.requestAnimationFrame</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global.setImmediate === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
        <span class="s1">global,</span>
        <span class="s0">'setImmediate'</span><span class="s1">,</span>
        <span class="s2">this</span><span class="s1">._fakeTimerAPIs.setImmediate</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
      <span class="s1">global,</span>
      <span class="s0">'setInterval'</span><span class="s1">,</span>
      <span class="s2">this</span><span class="s1">._fakeTimerAPIs.setInterval</span>
    <span class="s1">);</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _jestUtil().setGlobal)(</span>
      <span class="s1">global,</span>
      <span class="s0">'setTimeout'</span><span class="s1">,</span>
      <span class="s2">this</span><span class="s1">._fakeTimerAPIs.setTimeout</span>
    <span class="s1">);</span>
    <span class="s1">global.process.nextTick = </span><span class="s2">this</span><span class="s1">._fakeTimerAPIs.nextTick;</span>
    <span class="s2">this</span><span class="s1">._fakingTime = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s1">getTimerCount() {</span>
    <span class="s2">this</span><span class="s1">._checkFakeTimers();</span>
    <span class="s2">return this</span><span class="s1">._timers.size + </span><span class="s2">this</span><span class="s1">._immediates.length + </span><span class="s2">this</span><span class="s1">._ticks.length;</span>
  <span class="s1">}</span>
  <span class="s1">_checkFakeTimers() {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._fakingTime) {</span>
      <span class="s2">this</span><span class="s1">._global.console.warn(</span>
        <span class="s0">'A function to advance timers was called but the timers APIs are not mocked ' </span><span class="s1">+</span>
          <span class="s0">'with fake timers. Call `jest.useFakeTimers({legacyFakeTimers: true})` ' </span><span class="s1">+</span>
          <span class="s0">'in this test file or enable fake timers for all tests by setting ' </span><span class="s1">+</span>
          <span class="s0">&quot;{'enableGlobally': true, 'legacyFakeTimers': true} in &quot; </span><span class="s1">+</span>
          <span class="s1">`Jest configuration file.\nStack Trace:\n${(</span><span class="s3">0</span><span class="s1">,</span>
          <span class="s1">_jestMessageUtil().formatStackTrace)(</span>
            <span class="s2">new </span><span class="s1">Error().stack,</span>
            <span class="s2">this</span><span class="s1">._config,</span>
            <span class="s1">{</span>
              <span class="s1">noStackTrace: </span><span class="s2">false</span>
            <span class="s1">}</span>
          <span class="s1">)}`</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_createMocks() {</span>
    <span class="s1">const fn = implementation =&gt; </span><span class="s2">this</span><span class="s1">._moduleMocker.fn(implementation);</span>
    <span class="s1">const promisifiableFakeSetTimeout = fn(</span><span class="s2">this</span><span class="s1">._fakeSetTimeout.bind(</span><span class="s2">this</span><span class="s1">));</span>
    <span class="s4">// @ts-expect-error: no index</span>
    <span class="s1">promisifiableFakeSetTimeout[_util().promisify.custom] = (delay, arg) =&gt;</span>
      <span class="s2">new </span><span class="s1">Promise(resolve =&gt; promisifiableFakeSetTimeout(resolve, delay, arg));</span>
    <span class="s2">this</span><span class="s1">._fakeTimerAPIs = {</span>
      <span class="s1">cancelAnimationFrame: fn(</span><span class="s2">this</span><span class="s1">._fakeClearTimer.bind(</span><span class="s2">this</span><span class="s1">)),</span>
      <span class="s1">clearImmediate: fn(</span><span class="s2">this</span><span class="s1">._fakeClearImmediate.bind(</span><span class="s2">this</span><span class="s1">)),</span>
      <span class="s1">clearInterval: fn(</span><span class="s2">this</span><span class="s1">._fakeClearTimer.bind(</span><span class="s2">this</span><span class="s1">)),</span>
      <span class="s1">clearTimeout: fn(</span><span class="s2">this</span><span class="s1">._fakeClearTimer.bind(</span><span class="s2">this</span><span class="s1">)),</span>
      <span class="s1">nextTick: fn(</span><span class="s2">this</span><span class="s1">._fakeNextTick.bind(</span><span class="s2">this</span><span class="s1">)),</span>
      <span class="s1">requestAnimationFrame: fn(</span><span class="s2">this</span><span class="s1">._fakeRequestAnimationFrame.bind(</span><span class="s2">this</span><span class="s1">)),</span>
      <span class="s1">setImmediate: fn(</span><span class="s2">this</span><span class="s1">._fakeSetImmediate.bind(</span><span class="s2">this</span><span class="s1">)),</span>
      <span class="s1">setInterval: fn(</span><span class="s2">this</span><span class="s1">._fakeSetInterval.bind(</span><span class="s2">this</span><span class="s1">)),</span>
      <span class="s1">setTimeout: promisifiableFakeSetTimeout</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">_fakeClearTimer(timerRef) {</span>
    <span class="s1">const uuid = </span><span class="s2">this</span><span class="s1">._timerConfig.refToId(timerRef);</span>
    <span class="s2">if </span><span class="s1">(uuid) {</span>
      <span class="s2">this</span><span class="s1">._timers.</span><span class="s2">delete</span><span class="s1">(String(uuid));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_fakeClearImmediate(uuid) {</span>
    <span class="s2">this</span><span class="s1">._immediates = </span><span class="s2">this</span><span class="s1">._immediates.filter(</span>
      <span class="s1">immediate =&gt; immediate.uuid !== uuid</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">_fakeNextTick(callback, ...args) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._disposed) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const uuid = String(</span><span class="s2">this</span><span class="s1">._uuidCounter++);</span>
    <span class="s2">this</span><span class="s1">._ticks.push({</span>
      <span class="s1">callback: () =&gt; callback.apply(</span><span class="s2">null</span><span class="s1">, args),</span>
      <span class="s1">uuid</span>
    <span class="s1">});</span>
    <span class="s1">const cancelledTicks = </span><span class="s2">this</span><span class="s1">._cancelledTicks;</span>
    <span class="s2">this</span><span class="s1">._timerAPIs.nextTick(() =&gt; {</span>
      <span class="s2">if </span><span class="s1">(!Object.prototype.hasOwnProperty.call(cancelledTicks, uuid)) {</span>
        <span class="s4">// Callback may throw, so update the map prior calling.</span>
        <span class="s1">cancelledTicks[uuid] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">callback.apply(</span><span class="s2">null</span><span class="s1">, args);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>
  <span class="s1">_fakeRequestAnimationFrame(callback) {</span>
    <span class="s2">return this</span><span class="s1">._fakeSetTimeout(() =&gt; {</span>
      <span class="s4">// TODO: Use performance.now() once it's mocked</span>
      <span class="s1">callback(</span><span class="s2">this</span><span class="s1">._now);</span>
    <span class="s1">}, </span><span class="s3">1000 </span><span class="s1">/ </span><span class="s3">60</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">_fakeSetImmediate(callback, ...args) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._disposed) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const uuid = String(</span><span class="s2">this</span><span class="s1">._uuidCounter++);</span>
    <span class="s2">this</span><span class="s1">._immediates.push({</span>
      <span class="s1">callback: () =&gt; callback.apply(</span><span class="s2">null</span><span class="s1">, args),</span>
      <span class="s1">uuid</span>
    <span class="s1">});</span>
    <span class="s2">this</span><span class="s1">._timerAPIs.setImmediate(() =&gt; {</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._disposed) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._immediates.find(x =&gt; x.uuid === uuid)) {</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">callback.apply(</span><span class="s2">null</span><span class="s1">, args);</span>
          <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">._fakeClearImmediate(uuid);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">uuid;</span>
  <span class="s1">}</span>
  <span class="s1">_fakeSetInterval(callback, intervalDelay, ...args) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._disposed) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(intervalDelay == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">intervalDelay = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const uuid = </span><span class="s2">this</span><span class="s1">._uuidCounter++;</span>
    <span class="s2">this</span><span class="s1">._timers.set(String(uuid), {</span>
      <span class="s1">callback: () =&gt; callback.apply(</span><span class="s2">null</span><span class="s1">, args),</span>
      <span class="s1">expiry: </span><span class="s2">this</span><span class="s1">._now + intervalDelay,</span>
      <span class="s1">interval: intervalDelay,</span>
      <span class="s1">type: </span><span class="s0">'interval'</span>
    <span class="s1">});</span>
    <span class="s2">return this</span><span class="s1">._timerConfig.idToRef(uuid);</span>
  <span class="s1">}</span>
  <span class="s1">_fakeSetTimeout(callback, delay, ...args) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._disposed) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s4">// eslint-disable-next-line no-bitwise</span>
    <span class="s1">delay = Number(delay) | </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">const uuid = </span><span class="s2">this</span><span class="s1">._uuidCounter++;</span>
    <span class="s2">this</span><span class="s1">._timers.set(String(uuid), {</span>
      <span class="s1">callback: () =&gt; callback.apply(</span><span class="s2">null</span><span class="s1">, args),</span>
      <span class="s1">expiry: </span><span class="s2">this</span><span class="s1">._now + delay,</span>
      <span class="s1">interval: undefined,</span>
      <span class="s1">type: </span><span class="s0">'timeout'</span>
    <span class="s1">});</span>
    <span class="s2">return this</span><span class="s1">._timerConfig.idToRef(uuid);</span>
  <span class="s1">}</span>
  <span class="s1">_getNextTimerHandleAndExpiry() {</span>
    <span class="s1">let nextTimerHandle = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">let soonestTime = MS_IN_A_YEAR;</span>
    <span class="s2">this</span><span class="s1">._timers.forEach((timer, uuid) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(timer.expiry &lt; soonestTime) {</span>
        <span class="s1">soonestTime = timer.expiry;</span>
        <span class="s1">nextTimerHandle = uuid;</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">if </span><span class="s1">(nextTimerHandle === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[nextTimerHandle, soonestTime];</span>
  <span class="s1">}</span>
  <span class="s1">_runTimerHandle(timerHandle) {</span>
    <span class="s1">const timer = </span><span class="s2">this</span><span class="s1">._timers.get(timerHandle);</span>
    <span class="s2">if </span><span class="s1">(!timer) {</span>
      <span class="s4">// Timer has been cleared - we'll hit this when a timer is cleared within</span>
      <span class="s4">// another timer in runOnlyPendingTimers</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">switch </span><span class="s1">(timer.type) {</span>
      <span class="s2">case </span><span class="s0">'timeout'</span><span class="s1">:</span>
        <span class="s2">this</span><span class="s1">._timers.</span><span class="s2">delete</span><span class="s1">(timerHandle);</span>
        <span class="s1">timer.callback();</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s0">'interval'</span><span class="s1">:</span>
        <span class="s1">timer.expiry = </span><span class="s2">this</span><span class="s1">._now + (timer.interval || </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s1">timer.callback();</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw new </span><span class="s1">Error(`Unexpected timer type: ${timer.type}`);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= FakeTimers;</span>
</pre>
</body>
</html>
<html>
<head>
<title>tsserverlibrary.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #ffc66d;}
.s6 { color: #6897bb; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tsserverlibrary.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/*! ***************************************************************************** 
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use 
this file except in compliance with the License. You may obtain a copy of the 
License at http://www.apache.org/licenses/LICENSE-2.0 
</span>
<span class="s0">THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED 
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
</span>
<span class="s0">See the Apache Version 2.0 License for specific language governing permissions 
and limitations under the License. 
***************************************************************************** */</span>

<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">versionMajorMinor </span><span class="s2">= </span><span class="s4">&quot;4.8&quot;</span><span class="s1">;</span>
    <span class="s0">/** The version of the TypeScript compiler release */</span>
    <span class="s2">const </span><span class="s1">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Type of objects whose values are all of the same type. 
     * The `in` and `for-in` operators can *not* be safely used, 
     * since `Object.prototype` may be modified by outside code. 
     */</span>
    <span class="s2">interface </span><span class="s3">MapLike</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">[</span><span class="s3">index</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SortedReadonlyArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s4">&quot; __sortedArrayBrand&quot;</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SortedArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">Array</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s4">&quot; __sortedArrayBrand&quot;</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** Common read methods for ES6 Map/Set. */</span>
    <span class="s2">interface </span><span class="s3">ReadonlyCollection</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">&gt; {</span>
        <span class="s2">readonly </span><span class="s1">size</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">has(</span><span class="s3">key</span><span class="s2">: </span><span class="s3">K</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">keys()</span><span class="s2">: </span><span class="s3">Iterator</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s0">/** Common write methods for ES6 Map/Set. */</span>
    <span class="s2">interface </span><span class="s3">Collection</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyCollection</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">&gt; {</span>
        <span class="s1">delete(</span><span class="s3">key</span><span class="s2">: </span><span class="s3">K</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">clear()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** ES6 Map interface, only read methods included. */</span>
    <span class="s2">interface </span><span class="s3">ReadonlyESMap</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">, </span><span class="s3">V</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyCollection</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">&gt; {</span>
        <span class="s1">get(</span><span class="s3">key</span><span class="s2">: </span><span class="s3">K</span><span class="s1">)</span><span class="s2">: </span><span class="s3">V </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">values()</span><span class="s2">: </span><span class="s3">Iterator</span><span class="s1">&lt;</span><span class="s3">V</span><span class="s1">&gt;;</span>
        <span class="s1">entries()</span><span class="s2">: </span><span class="s3">Iterator</span><span class="s1">&lt;[</span><span class="s3">K</span><span class="s1">, </span><span class="s3">V</span><span class="s1">]&gt;;</span>
        <span class="s1">forEach(</span><span class="s5">action</span><span class="s2">: </span><span class="s1">(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">V</span><span class="s1">, </span><span class="s3">key</span><span class="s2">: </span><span class="s3">K</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* ES6 Map interface, only read methods included. 
     */</span>
    <span class="s2">interface </span><span class="s3">ReadonlyMap</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyESMap</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">, </span><span class="s3">T</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s0">/** ES6 Map interface. */</span>
    <span class="s2">interface </span><span class="s3">ESMap</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">, </span><span class="s3">V</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyESMap</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">, </span><span class="s3">V</span><span class="s1">&gt;, </span><span class="s3">Collection</span><span class="s1">&lt;</span><span class="s3">K</span><span class="s1">&gt; {</span>
        <span class="s1">set(</span><span class="s3">key</span><span class="s2">: </span><span class="s3">K</span><span class="s1">, </span><span class="s3">value</span><span class="s2">: </span><span class="s3">V</span><span class="s1">)</span><span class="s2">: </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* ES6 Map interface. 
     */</span>
    <span class="s2">interface </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ESMap</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">, </span><span class="s3">T</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s0">/** ES6 Set interface, only read methods included. */</span>
    <span class="s2">interface </span><span class="s3">ReadonlySet</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyCollection</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">has(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">values()</span><span class="s2">: </span><span class="s3">Iterator</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
        <span class="s1">entries()</span><span class="s2">: </span><span class="s3">Iterator</span><span class="s1">&lt;[</span><span class="s3">T</span><span class="s1">, </span><span class="s3">T</span><span class="s1">]&gt;;</span>
        <span class="s1">forEach(</span><span class="s5">action</span><span class="s2">: </span><span class="s1">(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">key</span><span class="s2">: </span><span class="s3">T</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** ES6 Set interface. */</span>
    <span class="s2">interface </span><span class="s3">Set</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlySet</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">Collection</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">add(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s1">delete(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** ES6 Iterator type. */</span>
    <span class="s2">interface </span><span class="s3">Iterator</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">next()</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">value</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
            <span class="s1">done</span><span class="s2">?: </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">| </span><span class="s1">{</span>
            <span class="s1">value</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
            <span class="s1">done</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}; 
    }</span>
    <span class="s0">/** Array that is only intended to be pushed to, never read. */</span>
    <span class="s2">interface </span><span class="s3">Push</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">push(</span><span class="s2">...</span><span class="s3">values</span><span class="s2">: </span><span class="s3">T</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">export type </span><span class="s3">Path </span><span class="s2">= </span><span class="s3">string </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">__pathBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">export interface </span><span class="s3">TextRange </span><span class="s1">{</span>
        <span class="s1">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ReadonlyTextRange </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">SyntaxKind </span><span class="s1">{</span>
        <span class="s3">Unknown </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">EndOfFileToken </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">SingleLineCommentTrivia </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">MultiLineCommentTrivia </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">NewLineTrivia </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">WhitespaceTrivia </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">ShebangTrivia </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s3">ConflictMarkerTrivia </span><span class="s2">= </span><span class="s6">7</span><span class="s1">,</span>
        <span class="s3">NumericLiteral </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">BigIntLiteral </span><span class="s2">= </span><span class="s6">9</span><span class="s1">,</span>
        <span class="s3">StringLiteral </span><span class="s2">= </span><span class="s6">10</span><span class="s1">,</span>
        <span class="s3">JsxText </span><span class="s2">= </span><span class="s6">11</span><span class="s1">,</span>
        <span class="s3">JsxTextAllWhiteSpaces </span><span class="s2">= </span><span class="s6">12</span><span class="s1">,</span>
        <span class="s3">RegularExpressionLiteral </span><span class="s2">= </span><span class="s6">13</span><span class="s1">,</span>
        <span class="s3">NoSubstitutionTemplateLiteral </span><span class="s2">= </span><span class="s6">14</span><span class="s1">,</span>
        <span class="s3">TemplateHead </span><span class="s2">= </span><span class="s6">15</span><span class="s1">,</span>
        <span class="s3">TemplateMiddle </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">TemplateTail </span><span class="s2">= </span><span class="s6">17</span><span class="s1">,</span>
        <span class="s3">OpenBraceToken </span><span class="s2">= </span><span class="s6">18</span><span class="s1">,</span>
        <span class="s3">CloseBraceToken </span><span class="s2">= </span><span class="s6">19</span><span class="s1">,</span>
        <span class="s3">OpenParenToken </span><span class="s2">= </span><span class="s6">20</span><span class="s1">,</span>
        <span class="s3">CloseParenToken </span><span class="s2">= </span><span class="s6">21</span><span class="s1">,</span>
        <span class="s3">OpenBracketToken </span><span class="s2">= </span><span class="s6">22</span><span class="s1">,</span>
        <span class="s3">CloseBracketToken </span><span class="s2">= </span><span class="s6">23</span><span class="s1">,</span>
        <span class="s3">DotToken </span><span class="s2">= </span><span class="s6">24</span><span class="s1">,</span>
        <span class="s3">DotDotDotToken </span><span class="s2">= </span><span class="s6">25</span><span class="s1">,</span>
        <span class="s3">SemicolonToken </span><span class="s2">= </span><span class="s6">26</span><span class="s1">,</span>
        <span class="s3">CommaToken </span><span class="s2">= </span><span class="s6">27</span><span class="s1">,</span>
        <span class="s3">QuestionDotToken </span><span class="s2">= </span><span class="s6">28</span><span class="s1">,</span>
        <span class="s3">LessThanToken </span><span class="s2">= </span><span class="s6">29</span><span class="s1">,</span>
        <span class="s3">LessThanSlashToken </span><span class="s2">= </span><span class="s6">30</span><span class="s1">,</span>
        <span class="s3">GreaterThanToken </span><span class="s2">= </span><span class="s6">31</span><span class="s1">,</span>
        <span class="s3">LessThanEqualsToken </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">GreaterThanEqualsToken </span><span class="s2">= </span><span class="s6">33</span><span class="s1">,</span>
        <span class="s3">EqualsEqualsToken </span><span class="s2">= </span><span class="s6">34</span><span class="s1">,</span>
        <span class="s3">ExclamationEqualsToken </span><span class="s2">= </span><span class="s6">35</span><span class="s1">,</span>
        <span class="s3">EqualsEqualsEqualsToken </span><span class="s2">= </span><span class="s6">36</span><span class="s1">,</span>
        <span class="s3">ExclamationEqualsEqualsToken </span><span class="s2">= </span><span class="s6">37</span><span class="s1">,</span>
        <span class="s3">EqualsGreaterThanToken </span><span class="s2">= </span><span class="s6">38</span><span class="s1">,</span>
        <span class="s3">PlusToken </span><span class="s2">= </span><span class="s6">39</span><span class="s1">,</span>
        <span class="s3">MinusToken </span><span class="s2">= </span><span class="s6">40</span><span class="s1">,</span>
        <span class="s3">AsteriskToken </span><span class="s2">= </span><span class="s6">41</span><span class="s1">,</span>
        <span class="s3">AsteriskAsteriskToken </span><span class="s2">= </span><span class="s6">42</span><span class="s1">,</span>
        <span class="s3">SlashToken </span><span class="s2">= </span><span class="s6">43</span><span class="s1">,</span>
        <span class="s3">PercentToken </span><span class="s2">= </span><span class="s6">44</span><span class="s1">,</span>
        <span class="s3">PlusPlusToken </span><span class="s2">= </span><span class="s6">45</span><span class="s1">,</span>
        <span class="s3">MinusMinusToken </span><span class="s2">= </span><span class="s6">46</span><span class="s1">,</span>
        <span class="s3">LessThanLessThanToken </span><span class="s2">= </span><span class="s6">47</span><span class="s1">,</span>
        <span class="s3">GreaterThanGreaterThanToken </span><span class="s2">= </span><span class="s6">48</span><span class="s1">,</span>
        <span class="s3">GreaterThanGreaterThanGreaterThanToken </span><span class="s2">= </span><span class="s6">49</span><span class="s1">,</span>
        <span class="s3">AmpersandToken </span><span class="s2">= </span><span class="s6">50</span><span class="s1">,</span>
        <span class="s3">BarToken </span><span class="s2">= </span><span class="s6">51</span><span class="s1">,</span>
        <span class="s3">CaretToken </span><span class="s2">= </span><span class="s6">52</span><span class="s1">,</span>
        <span class="s3">ExclamationToken </span><span class="s2">= </span><span class="s6">53</span><span class="s1">,</span>
        <span class="s3">TildeToken </span><span class="s2">= </span><span class="s6">54</span><span class="s1">,</span>
        <span class="s3">AmpersandAmpersandToken </span><span class="s2">= </span><span class="s6">55</span><span class="s1">,</span>
        <span class="s3">BarBarToken </span><span class="s2">= </span><span class="s6">56</span><span class="s1">,</span>
        <span class="s3">QuestionToken </span><span class="s2">= </span><span class="s6">57</span><span class="s1">,</span>
        <span class="s3">ColonToken </span><span class="s2">= </span><span class="s6">58</span><span class="s1">,</span>
        <span class="s3">AtToken </span><span class="s2">= </span><span class="s6">59</span><span class="s1">,</span>
        <span class="s3">QuestionQuestionToken </span><span class="s2">= </span><span class="s6">60</span><span class="s1">,</span>
        <span class="s0">/** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */</span>
        <span class="s3">BacktickToken </span><span class="s2">= </span><span class="s6">61</span><span class="s1">,</span>
        <span class="s0">/** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */</span>
        <span class="s3">HashToken </span><span class="s2">= </span><span class="s6">62</span><span class="s1">,</span>
        <span class="s3">EqualsToken </span><span class="s2">= </span><span class="s6">63</span><span class="s1">,</span>
        <span class="s3">PlusEqualsToken </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">MinusEqualsToken </span><span class="s2">= </span><span class="s6">65</span><span class="s1">,</span>
        <span class="s3">AsteriskEqualsToken </span><span class="s2">= </span><span class="s6">66</span><span class="s1">,</span>
        <span class="s3">AsteriskAsteriskEqualsToken </span><span class="s2">= </span><span class="s6">67</span><span class="s1">,</span>
        <span class="s3">SlashEqualsToken </span><span class="s2">= </span><span class="s6">68</span><span class="s1">,</span>
        <span class="s3">PercentEqualsToken </span><span class="s2">= </span><span class="s6">69</span><span class="s1">,</span>
        <span class="s3">LessThanLessThanEqualsToken </span><span class="s2">= </span><span class="s6">70</span><span class="s1">,</span>
        <span class="s3">GreaterThanGreaterThanEqualsToken </span><span class="s2">= </span><span class="s6">71</span><span class="s1">,</span>
        <span class="s3">GreaterThanGreaterThanGreaterThanEqualsToken </span><span class="s2">= </span><span class="s6">72</span><span class="s1">,</span>
        <span class="s3">AmpersandEqualsToken </span><span class="s2">= </span><span class="s6">73</span><span class="s1">,</span>
        <span class="s3">BarEqualsToken </span><span class="s2">= </span><span class="s6">74</span><span class="s1">,</span>
        <span class="s3">BarBarEqualsToken </span><span class="s2">= </span><span class="s6">75</span><span class="s1">,</span>
        <span class="s3">AmpersandAmpersandEqualsToken </span><span class="s2">= </span><span class="s6">76</span><span class="s1">,</span>
        <span class="s3">QuestionQuestionEqualsToken </span><span class="s2">= </span><span class="s6">77</span><span class="s1">,</span>
        <span class="s3">CaretEqualsToken </span><span class="s2">= </span><span class="s6">78</span><span class="s1">,</span>
        <span class="s3">Identifier </span><span class="s2">= </span><span class="s6">79</span><span class="s1">,</span>
        <span class="s3">PrivateIdentifier </span><span class="s2">= </span><span class="s6">80</span><span class="s1">,</span>
        <span class="s3">BreakKeyword </span><span class="s2">= </span><span class="s6">81</span><span class="s1">,</span>
        <span class="s3">CaseKeyword </span><span class="s2">= </span><span class="s6">82</span><span class="s1">,</span>
        <span class="s3">CatchKeyword </span><span class="s2">= </span><span class="s6">83</span><span class="s1">,</span>
        <span class="s3">ClassKeyword </span><span class="s2">= </span><span class="s6">84</span><span class="s1">,</span>
        <span class="s3">ConstKeyword </span><span class="s2">= </span><span class="s6">85</span><span class="s1">,</span>
        <span class="s3">ContinueKeyword </span><span class="s2">= </span><span class="s6">86</span><span class="s1">,</span>
        <span class="s3">DebuggerKeyword </span><span class="s2">= </span><span class="s6">87</span><span class="s1">,</span>
        <span class="s3">DefaultKeyword </span><span class="s2">= </span><span class="s6">88</span><span class="s1">,</span>
        <span class="s3">DeleteKeyword </span><span class="s2">= </span><span class="s6">89</span><span class="s1">,</span>
        <span class="s3">DoKeyword </span><span class="s2">= </span><span class="s6">90</span><span class="s1">,</span>
        <span class="s3">ElseKeyword </span><span class="s2">= </span><span class="s6">91</span><span class="s1">,</span>
        <span class="s3">EnumKeyword </span><span class="s2">= </span><span class="s6">92</span><span class="s1">,</span>
        <span class="s3">ExportKeyword </span><span class="s2">= </span><span class="s6">93</span><span class="s1">,</span>
        <span class="s3">ExtendsKeyword </span><span class="s2">= </span><span class="s6">94</span><span class="s1">,</span>
        <span class="s3">FalseKeyword </span><span class="s2">= </span><span class="s6">95</span><span class="s1">,</span>
        <span class="s3">FinallyKeyword </span><span class="s2">= </span><span class="s6">96</span><span class="s1">,</span>
        <span class="s3">ForKeyword </span><span class="s2">= </span><span class="s6">97</span><span class="s1">,</span>
        <span class="s3">FunctionKeyword </span><span class="s2">= </span><span class="s6">98</span><span class="s1">,</span>
        <span class="s3">IfKeyword </span><span class="s2">= </span><span class="s6">99</span><span class="s1">,</span>
        <span class="s3">ImportKeyword </span><span class="s2">= </span><span class="s6">100</span><span class="s1">,</span>
        <span class="s3">InKeyword </span><span class="s2">= </span><span class="s6">101</span><span class="s1">,</span>
        <span class="s3">InstanceOfKeyword </span><span class="s2">= </span><span class="s6">102</span><span class="s1">,</span>
        <span class="s3">NewKeyword </span><span class="s2">= </span><span class="s6">103</span><span class="s1">,</span>
        <span class="s3">NullKeyword </span><span class="s2">= </span><span class="s6">104</span><span class="s1">,</span>
        <span class="s3">ReturnKeyword </span><span class="s2">= </span><span class="s6">105</span><span class="s1">,</span>
        <span class="s3">SuperKeyword </span><span class="s2">= </span><span class="s6">106</span><span class="s1">,</span>
        <span class="s3">SwitchKeyword </span><span class="s2">= </span><span class="s6">107</span><span class="s1">,</span>
        <span class="s3">ThisKeyword </span><span class="s2">= </span><span class="s6">108</span><span class="s1">,</span>
        <span class="s3">ThrowKeyword </span><span class="s2">= </span><span class="s6">109</span><span class="s1">,</span>
        <span class="s3">TrueKeyword </span><span class="s2">= </span><span class="s6">110</span><span class="s1">,</span>
        <span class="s3">TryKeyword </span><span class="s2">= </span><span class="s6">111</span><span class="s1">,</span>
        <span class="s3">TypeOfKeyword </span><span class="s2">= </span><span class="s6">112</span><span class="s1">,</span>
        <span class="s3">VarKeyword </span><span class="s2">= </span><span class="s6">113</span><span class="s1">,</span>
        <span class="s3">VoidKeyword </span><span class="s2">= </span><span class="s6">114</span><span class="s1">,</span>
        <span class="s3">WhileKeyword </span><span class="s2">= </span><span class="s6">115</span><span class="s1">,</span>
        <span class="s3">WithKeyword </span><span class="s2">= </span><span class="s6">116</span><span class="s1">,</span>
        <span class="s3">ImplementsKeyword </span><span class="s2">= </span><span class="s6">117</span><span class="s1">,</span>
        <span class="s3">InterfaceKeyword </span><span class="s2">= </span><span class="s6">118</span><span class="s1">,</span>
        <span class="s3">LetKeyword </span><span class="s2">= </span><span class="s6">119</span><span class="s1">,</span>
        <span class="s3">PackageKeyword </span><span class="s2">= </span><span class="s6">120</span><span class="s1">,</span>
        <span class="s3">PrivateKeyword </span><span class="s2">= </span><span class="s6">121</span><span class="s1">,</span>
        <span class="s3">ProtectedKeyword </span><span class="s2">= </span><span class="s6">122</span><span class="s1">,</span>
        <span class="s3">PublicKeyword </span><span class="s2">= </span><span class="s6">123</span><span class="s1">,</span>
        <span class="s3">StaticKeyword </span><span class="s2">= </span><span class="s6">124</span><span class="s1">,</span>
        <span class="s3">YieldKeyword </span><span class="s2">= </span><span class="s6">125</span><span class="s1">,</span>
        <span class="s3">AbstractKeyword </span><span class="s2">= </span><span class="s6">126</span><span class="s1">,</span>
        <span class="s3">AsKeyword </span><span class="s2">= </span><span class="s6">127</span><span class="s1">,</span>
        <span class="s3">AssertsKeyword </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">AssertKeyword </span><span class="s2">= </span><span class="s6">129</span><span class="s1">,</span>
        <span class="s3">AnyKeyword </span><span class="s2">= </span><span class="s6">130</span><span class="s1">,</span>
        <span class="s3">AsyncKeyword </span><span class="s2">= </span><span class="s6">131</span><span class="s1">,</span>
        <span class="s3">AwaitKeyword </span><span class="s2">= </span><span class="s6">132</span><span class="s1">,</span>
        <span class="s3">BooleanKeyword </span><span class="s2">= </span><span class="s6">133</span><span class="s1">,</span>
        <span class="s3">ConstructorKeyword </span><span class="s2">= </span><span class="s6">134</span><span class="s1">,</span>
        <span class="s3">DeclareKeyword </span><span class="s2">= </span><span class="s6">135</span><span class="s1">,</span>
        <span class="s3">GetKeyword </span><span class="s2">= </span><span class="s6">136</span><span class="s1">,</span>
        <span class="s3">InferKeyword </span><span class="s2">= </span><span class="s6">137</span><span class="s1">,</span>
        <span class="s3">IntrinsicKeyword </span><span class="s2">= </span><span class="s6">138</span><span class="s1">,</span>
        <span class="s3">IsKeyword </span><span class="s2">= </span><span class="s6">139</span><span class="s1">,</span>
        <span class="s3">KeyOfKeyword </span><span class="s2">= </span><span class="s6">140</span><span class="s1">,</span>
        <span class="s3">ModuleKeyword </span><span class="s2">= </span><span class="s6">141</span><span class="s1">,</span>
        <span class="s3">NamespaceKeyword </span><span class="s2">= </span><span class="s6">142</span><span class="s1">,</span>
        <span class="s3">NeverKeyword </span><span class="s2">= </span><span class="s6">143</span><span class="s1">,</span>
        <span class="s3">OutKeyword </span><span class="s2">= </span><span class="s6">144</span><span class="s1">,</span>
        <span class="s3">ReadonlyKeyword </span><span class="s2">= </span><span class="s6">145</span><span class="s1">,</span>
        <span class="s3">RequireKeyword </span><span class="s2">= </span><span class="s6">146</span><span class="s1">,</span>
        <span class="s3">NumberKeyword </span><span class="s2">= </span><span class="s6">147</span><span class="s1">,</span>
        <span class="s3">ObjectKeyword </span><span class="s2">= </span><span class="s6">148</span><span class="s1">,</span>
        <span class="s3">SetKeyword </span><span class="s2">= </span><span class="s6">149</span><span class="s1">,</span>
        <span class="s3">StringKeyword </span><span class="s2">= </span><span class="s6">150</span><span class="s1">,</span>
        <span class="s3">SymbolKeyword </span><span class="s2">= </span><span class="s6">151</span><span class="s1">,</span>
        <span class="s3">TypeKeyword </span><span class="s2">= </span><span class="s6">152</span><span class="s1">,</span>
        <span class="s3">UndefinedKeyword </span><span class="s2">= </span><span class="s6">153</span><span class="s1">,</span>
        <span class="s3">UniqueKeyword </span><span class="s2">= </span><span class="s6">154</span><span class="s1">,</span>
        <span class="s3">UnknownKeyword </span><span class="s2">= </span><span class="s6">155</span><span class="s1">,</span>
        <span class="s3">FromKeyword </span><span class="s2">= </span><span class="s6">156</span><span class="s1">,</span>
        <span class="s3">GlobalKeyword </span><span class="s2">= </span><span class="s6">157</span><span class="s1">,</span>
        <span class="s3">BigIntKeyword </span><span class="s2">= </span><span class="s6">158</span><span class="s1">,</span>
        <span class="s3">OverrideKeyword </span><span class="s2">= </span><span class="s6">159</span><span class="s1">,</span>
        <span class="s3">OfKeyword </span><span class="s2">= </span><span class="s6">160</span><span class="s1">,</span>
        <span class="s3">QualifiedName </span><span class="s2">= </span><span class="s6">161</span><span class="s1">,</span>
        <span class="s3">ComputedPropertyName </span><span class="s2">= </span><span class="s6">162</span><span class="s1">,</span>
        <span class="s3">TypeParameter </span><span class="s2">= </span><span class="s6">163</span><span class="s1">,</span>
        <span class="s3">Parameter </span><span class="s2">= </span><span class="s6">164</span><span class="s1">,</span>
        <span class="s3">Decorator </span><span class="s2">= </span><span class="s6">165</span><span class="s1">,</span>
        <span class="s3">PropertySignature </span><span class="s2">= </span><span class="s6">166</span><span class="s1">,</span>
        <span class="s3">PropertyDeclaration </span><span class="s2">= </span><span class="s6">167</span><span class="s1">,</span>
        <span class="s3">MethodSignature </span><span class="s2">= </span><span class="s6">168</span><span class="s1">,</span>
        <span class="s3">MethodDeclaration </span><span class="s2">= </span><span class="s6">169</span><span class="s1">,</span>
        <span class="s3">ClassStaticBlockDeclaration </span><span class="s2">= </span><span class="s6">170</span><span class="s1">,</span>
        <span class="s3">Constructor </span><span class="s2">= </span><span class="s6">171</span><span class="s1">,</span>
        <span class="s3">GetAccessor </span><span class="s2">= </span><span class="s6">172</span><span class="s1">,</span>
        <span class="s3">SetAccessor </span><span class="s2">= </span><span class="s6">173</span><span class="s1">,</span>
        <span class="s3">CallSignature </span><span class="s2">= </span><span class="s6">174</span><span class="s1">,</span>
        <span class="s3">ConstructSignature </span><span class="s2">= </span><span class="s6">175</span><span class="s1">,</span>
        <span class="s3">IndexSignature </span><span class="s2">= </span><span class="s6">176</span><span class="s1">,</span>
        <span class="s3">TypePredicate </span><span class="s2">= </span><span class="s6">177</span><span class="s1">,</span>
        <span class="s3">TypeReference </span><span class="s2">= </span><span class="s6">178</span><span class="s1">,</span>
        <span class="s3">FunctionType </span><span class="s2">= </span><span class="s6">179</span><span class="s1">,</span>
        <span class="s3">ConstructorType </span><span class="s2">= </span><span class="s6">180</span><span class="s1">,</span>
        <span class="s3">TypeQuery </span><span class="s2">= </span><span class="s6">181</span><span class="s1">,</span>
        <span class="s3">TypeLiteral </span><span class="s2">= </span><span class="s6">182</span><span class="s1">,</span>
        <span class="s3">ArrayType </span><span class="s2">= </span><span class="s6">183</span><span class="s1">,</span>
        <span class="s3">TupleType </span><span class="s2">= </span><span class="s6">184</span><span class="s1">,</span>
        <span class="s3">OptionalType </span><span class="s2">= </span><span class="s6">185</span><span class="s1">,</span>
        <span class="s3">RestType </span><span class="s2">= </span><span class="s6">186</span><span class="s1">,</span>
        <span class="s3">UnionType </span><span class="s2">= </span><span class="s6">187</span><span class="s1">,</span>
        <span class="s3">IntersectionType </span><span class="s2">= </span><span class="s6">188</span><span class="s1">,</span>
        <span class="s3">ConditionalType </span><span class="s2">= </span><span class="s6">189</span><span class="s1">,</span>
        <span class="s3">InferType </span><span class="s2">= </span><span class="s6">190</span><span class="s1">,</span>
        <span class="s3">ParenthesizedType </span><span class="s2">= </span><span class="s6">191</span><span class="s1">,</span>
        <span class="s3">ThisType </span><span class="s2">= </span><span class="s6">192</span><span class="s1">,</span>
        <span class="s3">TypeOperator </span><span class="s2">= </span><span class="s6">193</span><span class="s1">,</span>
        <span class="s3">IndexedAccessType </span><span class="s2">= </span><span class="s6">194</span><span class="s1">,</span>
        <span class="s3">MappedType </span><span class="s2">= </span><span class="s6">195</span><span class="s1">,</span>
        <span class="s3">LiteralType </span><span class="s2">= </span><span class="s6">196</span><span class="s1">,</span>
        <span class="s3">NamedTupleMember </span><span class="s2">= </span><span class="s6">197</span><span class="s1">,</span>
        <span class="s3">TemplateLiteralType </span><span class="s2">= </span><span class="s6">198</span><span class="s1">,</span>
        <span class="s3">TemplateLiteralTypeSpan </span><span class="s2">= </span><span class="s6">199</span><span class="s1">,</span>
        <span class="s3">ImportType </span><span class="s2">= </span><span class="s6">200</span><span class="s1">,</span>
        <span class="s3">ObjectBindingPattern </span><span class="s2">= </span><span class="s6">201</span><span class="s1">,</span>
        <span class="s3">ArrayBindingPattern </span><span class="s2">= </span><span class="s6">202</span><span class="s1">,</span>
        <span class="s3">BindingElement </span><span class="s2">= </span><span class="s6">203</span><span class="s1">,</span>
        <span class="s3">ArrayLiteralExpression </span><span class="s2">= </span><span class="s6">204</span><span class="s1">,</span>
        <span class="s3">ObjectLiteralExpression </span><span class="s2">= </span><span class="s6">205</span><span class="s1">,</span>
        <span class="s3">PropertyAccessExpression </span><span class="s2">= </span><span class="s6">206</span><span class="s1">,</span>
        <span class="s3">ElementAccessExpression </span><span class="s2">= </span><span class="s6">207</span><span class="s1">,</span>
        <span class="s3">CallExpression </span><span class="s2">= </span><span class="s6">208</span><span class="s1">,</span>
        <span class="s3">NewExpression </span><span class="s2">= </span><span class="s6">209</span><span class="s1">,</span>
        <span class="s3">TaggedTemplateExpression </span><span class="s2">= </span><span class="s6">210</span><span class="s1">,</span>
        <span class="s3">TypeAssertionExpression </span><span class="s2">= </span><span class="s6">211</span><span class="s1">,</span>
        <span class="s3">ParenthesizedExpression </span><span class="s2">= </span><span class="s6">212</span><span class="s1">,</span>
        <span class="s3">FunctionExpression </span><span class="s2">= </span><span class="s6">213</span><span class="s1">,</span>
        <span class="s3">ArrowFunction </span><span class="s2">= </span><span class="s6">214</span><span class="s1">,</span>
        <span class="s3">DeleteExpression </span><span class="s2">= </span><span class="s6">215</span><span class="s1">,</span>
        <span class="s3">TypeOfExpression </span><span class="s2">= </span><span class="s6">216</span><span class="s1">,</span>
        <span class="s3">VoidExpression </span><span class="s2">= </span><span class="s6">217</span><span class="s1">,</span>
        <span class="s3">AwaitExpression </span><span class="s2">= </span><span class="s6">218</span><span class="s1">,</span>
        <span class="s3">PrefixUnaryExpression </span><span class="s2">= </span><span class="s6">219</span><span class="s1">,</span>
        <span class="s3">PostfixUnaryExpression </span><span class="s2">= </span><span class="s6">220</span><span class="s1">,</span>
        <span class="s3">BinaryExpression </span><span class="s2">= </span><span class="s6">221</span><span class="s1">,</span>
        <span class="s3">ConditionalExpression </span><span class="s2">= </span><span class="s6">222</span><span class="s1">,</span>
        <span class="s3">TemplateExpression </span><span class="s2">= </span><span class="s6">223</span><span class="s1">,</span>
        <span class="s3">YieldExpression </span><span class="s2">= </span><span class="s6">224</span><span class="s1">,</span>
        <span class="s3">SpreadElement </span><span class="s2">= </span><span class="s6">225</span><span class="s1">,</span>
        <span class="s3">ClassExpression </span><span class="s2">= </span><span class="s6">226</span><span class="s1">,</span>
        <span class="s3">OmittedExpression </span><span class="s2">= </span><span class="s6">227</span><span class="s1">,</span>
        <span class="s3">ExpressionWithTypeArguments </span><span class="s2">= </span><span class="s6">228</span><span class="s1">,</span>
        <span class="s3">AsExpression </span><span class="s2">= </span><span class="s6">229</span><span class="s1">,</span>
        <span class="s3">NonNullExpression </span><span class="s2">= </span><span class="s6">230</span><span class="s1">,</span>
        <span class="s3">MetaProperty </span><span class="s2">= </span><span class="s6">231</span><span class="s1">,</span>
        <span class="s3">SyntheticExpression </span><span class="s2">= </span><span class="s6">232</span><span class="s1">,</span>
        <span class="s3">TemplateSpan </span><span class="s2">= </span><span class="s6">233</span><span class="s1">,</span>
        <span class="s3">SemicolonClassElement </span><span class="s2">= </span><span class="s6">234</span><span class="s1">,</span>
        <span class="s3">Block </span><span class="s2">= </span><span class="s6">235</span><span class="s1">,</span>
        <span class="s3">EmptyStatement </span><span class="s2">= </span><span class="s6">236</span><span class="s1">,</span>
        <span class="s3">VariableStatement </span><span class="s2">= </span><span class="s6">237</span><span class="s1">,</span>
        <span class="s3">ExpressionStatement </span><span class="s2">= </span><span class="s6">238</span><span class="s1">,</span>
        <span class="s3">IfStatement </span><span class="s2">= </span><span class="s6">239</span><span class="s1">,</span>
        <span class="s3">DoStatement </span><span class="s2">= </span><span class="s6">240</span><span class="s1">,</span>
        <span class="s3">WhileStatement </span><span class="s2">= </span><span class="s6">241</span><span class="s1">,</span>
        <span class="s3">ForStatement </span><span class="s2">= </span><span class="s6">242</span><span class="s1">,</span>
        <span class="s3">ForInStatement </span><span class="s2">= </span><span class="s6">243</span><span class="s1">,</span>
        <span class="s3">ForOfStatement </span><span class="s2">= </span><span class="s6">244</span><span class="s1">,</span>
        <span class="s3">ContinueStatement </span><span class="s2">= </span><span class="s6">245</span><span class="s1">,</span>
        <span class="s3">BreakStatement </span><span class="s2">= </span><span class="s6">246</span><span class="s1">,</span>
        <span class="s3">ReturnStatement </span><span class="s2">= </span><span class="s6">247</span><span class="s1">,</span>
        <span class="s3">WithStatement </span><span class="s2">= </span><span class="s6">248</span><span class="s1">,</span>
        <span class="s3">SwitchStatement </span><span class="s2">= </span><span class="s6">249</span><span class="s1">,</span>
        <span class="s3">LabeledStatement </span><span class="s2">= </span><span class="s6">250</span><span class="s1">,</span>
        <span class="s3">ThrowStatement </span><span class="s2">= </span><span class="s6">251</span><span class="s1">,</span>
        <span class="s3">TryStatement </span><span class="s2">= </span><span class="s6">252</span><span class="s1">,</span>
        <span class="s3">DebuggerStatement </span><span class="s2">= </span><span class="s6">253</span><span class="s1">,</span>
        <span class="s3">VariableDeclaration </span><span class="s2">= </span><span class="s6">254</span><span class="s1">,</span>
        <span class="s3">VariableDeclarationList </span><span class="s2">= </span><span class="s6">255</span><span class="s1">,</span>
        <span class="s3">FunctionDeclaration </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">ClassDeclaration </span><span class="s2">= </span><span class="s6">257</span><span class="s1">,</span>
        <span class="s3">InterfaceDeclaration </span><span class="s2">= </span><span class="s6">258</span><span class="s1">,</span>
        <span class="s3">TypeAliasDeclaration </span><span class="s2">= </span><span class="s6">259</span><span class="s1">,</span>
        <span class="s3">EnumDeclaration </span><span class="s2">= </span><span class="s6">260</span><span class="s1">,</span>
        <span class="s3">ModuleDeclaration </span><span class="s2">= </span><span class="s6">261</span><span class="s1">,</span>
        <span class="s3">ModuleBlock </span><span class="s2">= </span><span class="s6">262</span><span class="s1">,</span>
        <span class="s3">CaseBlock </span><span class="s2">= </span><span class="s6">263</span><span class="s1">,</span>
        <span class="s3">NamespaceExportDeclaration </span><span class="s2">= </span><span class="s6">264</span><span class="s1">,</span>
        <span class="s3">ImportEqualsDeclaration </span><span class="s2">= </span><span class="s6">265</span><span class="s1">,</span>
        <span class="s3">ImportDeclaration </span><span class="s2">= </span><span class="s6">266</span><span class="s1">,</span>
        <span class="s3">ImportClause </span><span class="s2">= </span><span class="s6">267</span><span class="s1">,</span>
        <span class="s3">NamespaceImport </span><span class="s2">= </span><span class="s6">268</span><span class="s1">,</span>
        <span class="s3">NamedImports </span><span class="s2">= </span><span class="s6">269</span><span class="s1">,</span>
        <span class="s3">ImportSpecifier </span><span class="s2">= </span><span class="s6">270</span><span class="s1">,</span>
        <span class="s3">ExportAssignment </span><span class="s2">= </span><span class="s6">271</span><span class="s1">,</span>
        <span class="s3">ExportDeclaration </span><span class="s2">= </span><span class="s6">272</span><span class="s1">,</span>
        <span class="s3">NamedExports </span><span class="s2">= </span><span class="s6">273</span><span class="s1">,</span>
        <span class="s3">NamespaceExport </span><span class="s2">= </span><span class="s6">274</span><span class="s1">,</span>
        <span class="s3">ExportSpecifier </span><span class="s2">= </span><span class="s6">275</span><span class="s1">,</span>
        <span class="s3">MissingDeclaration </span><span class="s2">= </span><span class="s6">276</span><span class="s1">,</span>
        <span class="s3">ExternalModuleReference </span><span class="s2">= </span><span class="s6">277</span><span class="s1">,</span>
        <span class="s3">JsxElement </span><span class="s2">= </span><span class="s6">278</span><span class="s1">,</span>
        <span class="s3">JsxSelfClosingElement </span><span class="s2">= </span><span class="s6">279</span><span class="s1">,</span>
        <span class="s3">JsxOpeningElement </span><span class="s2">= </span><span class="s6">280</span><span class="s1">,</span>
        <span class="s3">JsxClosingElement </span><span class="s2">= </span><span class="s6">281</span><span class="s1">,</span>
        <span class="s3">JsxFragment </span><span class="s2">= </span><span class="s6">282</span><span class="s1">,</span>
        <span class="s3">JsxOpeningFragment </span><span class="s2">= </span><span class="s6">283</span><span class="s1">,</span>
        <span class="s3">JsxClosingFragment </span><span class="s2">= </span><span class="s6">284</span><span class="s1">,</span>
        <span class="s3">JsxAttribute </span><span class="s2">= </span><span class="s6">285</span><span class="s1">,</span>
        <span class="s3">JsxAttributes </span><span class="s2">= </span><span class="s6">286</span><span class="s1">,</span>
        <span class="s3">JsxSpreadAttribute </span><span class="s2">= </span><span class="s6">287</span><span class="s1">,</span>
        <span class="s3">JsxExpression </span><span class="s2">= </span><span class="s6">288</span><span class="s1">,</span>
        <span class="s3">CaseClause </span><span class="s2">= </span><span class="s6">289</span><span class="s1">,</span>
        <span class="s3">DefaultClause </span><span class="s2">= </span><span class="s6">290</span><span class="s1">,</span>
        <span class="s3">HeritageClause </span><span class="s2">= </span><span class="s6">291</span><span class="s1">,</span>
        <span class="s3">CatchClause </span><span class="s2">= </span><span class="s6">292</span><span class="s1">,</span>
        <span class="s3">AssertClause </span><span class="s2">= </span><span class="s6">293</span><span class="s1">,</span>
        <span class="s3">AssertEntry </span><span class="s2">= </span><span class="s6">294</span><span class="s1">,</span>
        <span class="s3">ImportTypeAssertionContainer </span><span class="s2">= </span><span class="s6">295</span><span class="s1">,</span>
        <span class="s3">PropertyAssignment </span><span class="s2">= </span><span class="s6">296</span><span class="s1">,</span>
        <span class="s3">ShorthandPropertyAssignment </span><span class="s2">= </span><span class="s6">297</span><span class="s1">,</span>
        <span class="s3">SpreadAssignment </span><span class="s2">= </span><span class="s6">298</span><span class="s1">,</span>
        <span class="s3">EnumMember </span><span class="s2">= </span><span class="s6">299</span><span class="s1">,</span>
        <span class="s3">UnparsedPrologue </span><span class="s2">= </span><span class="s6">300</span><span class="s1">,</span>
        <span class="s3">UnparsedPrepend </span><span class="s2">= </span><span class="s6">301</span><span class="s1">,</span>
        <span class="s3">UnparsedText </span><span class="s2">= </span><span class="s6">302</span><span class="s1">,</span>
        <span class="s3">UnparsedInternalText </span><span class="s2">= </span><span class="s6">303</span><span class="s1">,</span>
        <span class="s3">UnparsedSyntheticReference </span><span class="s2">= </span><span class="s6">304</span><span class="s1">,</span>
        <span class="s3">SourceFile </span><span class="s2">= </span><span class="s6">305</span><span class="s1">,</span>
        <span class="s3">Bundle </span><span class="s2">= </span><span class="s6">306</span><span class="s1">,</span>
        <span class="s3">UnparsedSource </span><span class="s2">= </span><span class="s6">307</span><span class="s1">,</span>
        <span class="s3">InputFiles </span><span class="s2">= </span><span class="s6">308</span><span class="s1">,</span>
        <span class="s3">JSDocTypeExpression </span><span class="s2">= </span><span class="s6">309</span><span class="s1">,</span>
        <span class="s3">JSDocNameReference </span><span class="s2">= </span><span class="s6">310</span><span class="s1">,</span>
        <span class="s3">JSDocMemberName </span><span class="s2">= </span><span class="s6">311</span><span class="s1">,</span>
        <span class="s3">JSDocAllType </span><span class="s2">= </span><span class="s6">312</span><span class="s1">,</span>
        <span class="s3">JSDocUnknownType </span><span class="s2">= </span><span class="s6">313</span><span class="s1">,</span>
        <span class="s3">JSDocNullableType </span><span class="s2">= </span><span class="s6">314</span><span class="s1">,</span>
        <span class="s3">JSDocNonNullableType </span><span class="s2">= </span><span class="s6">315</span><span class="s1">,</span>
        <span class="s3">JSDocOptionalType </span><span class="s2">= </span><span class="s6">316</span><span class="s1">,</span>
        <span class="s3">JSDocFunctionType </span><span class="s2">= </span><span class="s6">317</span><span class="s1">,</span>
        <span class="s3">JSDocVariadicType </span><span class="s2">= </span><span class="s6">318</span><span class="s1">,</span>
        <span class="s3">JSDocNamepathType </span><span class="s2">= </span><span class="s6">319</span><span class="s1">,</span>
        <span class="s3">JSDoc </span><span class="s2">= </span><span class="s6">320</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use SyntaxKind.JSDoc */</span>
        <span class="s3">JSDocComment </span><span class="s2">= </span><span class="s6">320</span><span class="s1">,</span>
        <span class="s3">JSDocText </span><span class="s2">= </span><span class="s6">321</span><span class="s1">,</span>
        <span class="s3">JSDocTypeLiteral </span><span class="s2">= </span><span class="s6">322</span><span class="s1">,</span>
        <span class="s3">JSDocSignature </span><span class="s2">= </span><span class="s6">323</span><span class="s1">,</span>
        <span class="s3">JSDocLink </span><span class="s2">= </span><span class="s6">324</span><span class="s1">,</span>
        <span class="s3">JSDocLinkCode </span><span class="s2">= </span><span class="s6">325</span><span class="s1">,</span>
        <span class="s3">JSDocLinkPlain </span><span class="s2">= </span><span class="s6">326</span><span class="s1">,</span>
        <span class="s3">JSDocTag </span><span class="s2">= </span><span class="s6">327</span><span class="s1">,</span>
        <span class="s3">JSDocAugmentsTag </span><span class="s2">= </span><span class="s6">328</span><span class="s1">,</span>
        <span class="s3">JSDocImplementsTag </span><span class="s2">= </span><span class="s6">329</span><span class="s1">,</span>
        <span class="s3">JSDocAuthorTag </span><span class="s2">= </span><span class="s6">330</span><span class="s1">,</span>
        <span class="s3">JSDocDeprecatedTag </span><span class="s2">= </span><span class="s6">331</span><span class="s1">,</span>
        <span class="s3">JSDocClassTag </span><span class="s2">= </span><span class="s6">332</span><span class="s1">,</span>
        <span class="s3">JSDocPublicTag </span><span class="s2">= </span><span class="s6">333</span><span class="s1">,</span>
        <span class="s3">JSDocPrivateTag </span><span class="s2">= </span><span class="s6">334</span><span class="s1">,</span>
        <span class="s3">JSDocProtectedTag </span><span class="s2">= </span><span class="s6">335</span><span class="s1">,</span>
        <span class="s3">JSDocReadonlyTag </span><span class="s2">= </span><span class="s6">336</span><span class="s1">,</span>
        <span class="s3">JSDocOverrideTag </span><span class="s2">= </span><span class="s6">337</span><span class="s1">,</span>
        <span class="s3">JSDocCallbackTag </span><span class="s2">= </span><span class="s6">338</span><span class="s1">,</span>
        <span class="s3">JSDocEnumTag </span><span class="s2">= </span><span class="s6">339</span><span class="s1">,</span>
        <span class="s3">JSDocParameterTag </span><span class="s2">= </span><span class="s6">340</span><span class="s1">,</span>
        <span class="s3">JSDocReturnTag </span><span class="s2">= </span><span class="s6">341</span><span class="s1">,</span>
        <span class="s3">JSDocThisTag </span><span class="s2">= </span><span class="s6">342</span><span class="s1">,</span>
        <span class="s3">JSDocTypeTag </span><span class="s2">= </span><span class="s6">343</span><span class="s1">,</span>
        <span class="s3">JSDocTemplateTag </span><span class="s2">= </span><span class="s6">344</span><span class="s1">,</span>
        <span class="s3">JSDocTypedefTag </span><span class="s2">= </span><span class="s6">345</span><span class="s1">,</span>
        <span class="s3">JSDocSeeTag </span><span class="s2">= </span><span class="s6">346</span><span class="s1">,</span>
        <span class="s3">JSDocPropertyTag </span><span class="s2">= </span><span class="s6">347</span><span class="s1">,</span>
        <span class="s3">SyntaxList </span><span class="s2">= </span><span class="s6">348</span><span class="s1">,</span>
        <span class="s3">NotEmittedStatement </span><span class="s2">= </span><span class="s6">349</span><span class="s1">,</span>
        <span class="s3">PartiallyEmittedExpression </span><span class="s2">= </span><span class="s6">350</span><span class="s1">,</span>
        <span class="s3">CommaListExpression </span><span class="s2">= </span><span class="s6">351</span><span class="s1">,</span>
        <span class="s3">MergeDeclarationMarker </span><span class="s2">= </span><span class="s6">352</span><span class="s1">,</span>
        <span class="s3">EndOfDeclarationMarker </span><span class="s2">= </span><span class="s6">353</span><span class="s1">,</span>
        <span class="s3">SyntheticReferenceExpression </span><span class="s2">= </span><span class="s6">354</span><span class="s1">,</span>
        <span class="s3">Count </span><span class="s2">= </span><span class="s6">355</span><span class="s1">,</span>
        <span class="s3">FirstAssignment </span><span class="s2">= </span><span class="s6">63</span><span class="s1">,</span>
        <span class="s3">LastAssignment </span><span class="s2">= </span><span class="s6">78</span><span class="s1">,</span>
        <span class="s3">FirstCompoundAssignment </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">LastCompoundAssignment </span><span class="s2">= </span><span class="s6">78</span><span class="s1">,</span>
        <span class="s3">FirstReservedWord </span><span class="s2">= </span><span class="s6">81</span><span class="s1">,</span>
        <span class="s3">LastReservedWord </span><span class="s2">= </span><span class="s6">116</span><span class="s1">,</span>
        <span class="s3">FirstKeyword </span><span class="s2">= </span><span class="s6">81</span><span class="s1">,</span>
        <span class="s3">LastKeyword </span><span class="s2">= </span><span class="s6">160</span><span class="s1">,</span>
        <span class="s3">FirstFutureReservedWord </span><span class="s2">= </span><span class="s6">117</span><span class="s1">,</span>
        <span class="s3">LastFutureReservedWord </span><span class="s2">= </span><span class="s6">125</span><span class="s1">,</span>
        <span class="s3">FirstTypeNode </span><span class="s2">= </span><span class="s6">177</span><span class="s1">,</span>
        <span class="s3">LastTypeNode </span><span class="s2">= </span><span class="s6">200</span><span class="s1">,</span>
        <span class="s3">FirstPunctuation </span><span class="s2">= </span><span class="s6">18</span><span class="s1">,</span>
        <span class="s3">LastPunctuation </span><span class="s2">= </span><span class="s6">78</span><span class="s1">,</span>
        <span class="s3">FirstToken </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">LastToken </span><span class="s2">= </span><span class="s6">160</span><span class="s1">,</span>
        <span class="s3">FirstTriviaToken </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">LastTriviaToken </span><span class="s2">= </span><span class="s6">7</span><span class="s1">,</span>
        <span class="s3">FirstLiteralToken </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">LastLiteralToken </span><span class="s2">= </span><span class="s6">14</span><span class="s1">,</span>
        <span class="s3">FirstTemplateToken </span><span class="s2">= </span><span class="s6">14</span><span class="s1">,</span>
        <span class="s3">LastTemplateToken </span><span class="s2">= </span><span class="s6">17</span><span class="s1">,</span>
        <span class="s3">FirstBinaryOperator </span><span class="s2">= </span><span class="s6">29</span><span class="s1">,</span>
        <span class="s3">LastBinaryOperator </span><span class="s2">= </span><span class="s6">78</span><span class="s1">,</span>
        <span class="s3">FirstStatement </span><span class="s2">= </span><span class="s6">237</span><span class="s1">,</span>
        <span class="s3">LastStatement </span><span class="s2">= </span><span class="s6">253</span><span class="s1">,</span>
        <span class="s3">FirstNode </span><span class="s2">= </span><span class="s6">161</span><span class="s1">,</span>
        <span class="s3">FirstJSDocNode </span><span class="s2">= </span><span class="s6">309</span><span class="s1">,</span>
        <span class="s3">LastJSDocNode </span><span class="s2">= </span><span class="s6">347</span><span class="s1">,</span>
        <span class="s3">FirstJSDocTagNode </span><span class="s2">= </span><span class="s6">327</span><span class="s1">,</span>
        <span class="s3">LastJSDocTagNode </span><span class="s2">= </span><span class="s6">347</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">TriviaSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SingleLineCommentTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MultiLineCommentTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NewLineTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">WhitespaceTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ShebangTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConflictMarkerTrivia</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">LiteralSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NumericLiteral </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BigIntLiteral </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxText </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxTextAllWhiteSpaces </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">RegularExpressionLiteral </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">PseudoLiteralSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateHead </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateTail</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">PunctuationSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenBraceToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CloseBraceToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenParenToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CloseParenToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenBracketToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CloseBracketToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SemicolonToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CommaToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanSlashToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsEqualsEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationEqualsEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsGreaterThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskAsteriskToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SlashToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PercentToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusPlusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusMinusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanLessThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanGreaterThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaretToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TildeToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandAmpersandToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarBarToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionQuestionToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ColonToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AtToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BacktickToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">HashToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskAsteriskEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SlashEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PercentEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanLessThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanGreaterThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaretEqualsToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">KeywordSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AbstractKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AnyKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AssertsKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AssertKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsyncKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AwaitKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BigIntKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BooleanKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BreakKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaseKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CatchKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ClassKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConstKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConstructorKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ContinueKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DebuggerKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DeclareKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DefaultKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DeleteKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DoKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ElseKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EnumKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExportKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExtendsKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FalseKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FinallyKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ForKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FromKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FunctionKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GetKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GlobalKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">IfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImplementsKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InferKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InstanceOfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InterfaceKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">IntrinsicKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">IsKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">KeyOfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LetKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ModuleKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NamespaceKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NeverKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NewKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NullKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NumberKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ObjectKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PackageKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PrivateKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ProtectedKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PublicKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OutKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OverrideKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">RequireKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ReturnKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SetKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">StaticKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">StringKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SuperKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SwitchKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SymbolKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ThisKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ThrowKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TrueKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TryKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeOfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UndefinedKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UniqueKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnknownKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">VarKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">VoidKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">WhileKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">WithKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">YieldKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ModifierSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AbstractKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsyncKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConstKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DeclareKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DefaultKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExportKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PrivateKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ProtectedKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PublicKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OutKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OverrideKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">StaticKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">KeywordTypeSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AnyKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BigIntKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BooleanKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">IntrinsicKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NeverKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NumberKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ObjectKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">StringKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SymbolKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UndefinedKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnknownKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">VoidKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">TokenSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Unknown </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EndOfFileToken </span><span class="s2">| </span><span class="s3">TriviaSyntaxKind </span><span class="s2">| </span><span class="s3">LiteralSyntaxKind </span><span class="s2">| </span><span class="s3">PseudoLiteralSyntaxKind </span><span class="s2">| </span><span class="s3">PunctuationSyntaxKind </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">KeywordSyntaxKind</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">JsxTokenSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanSlashToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EndOfFileToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConflictMarkerTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxText </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxTextAllWhiteSpaces </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenBraceToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">JSDocSyntaxKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EndOfFileToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">WhitespaceTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AtToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NewLineTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenBraceToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CloseBraceToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenBracketToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CloseBracketToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CommaToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BacktickToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">HashToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Unknown </span><span class="s2">| </span><span class="s3">KeywordSyntaxKind</span><span class="s1">;</span>
    <span class="s2">export enum </span><span class="s3">NodeFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Let </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Const </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">NestedNamespace </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">Synthesized </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Namespace </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">OptionalChain </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">ExportContext </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">ContainsThis </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">HasImplicitReturn </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">HasExplicitReturn </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">GlobalAugmentation </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">HasAsyncFunctions </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">DisallowInContext </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">YieldContext </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">DecoratorContext </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">AwaitContext </span><span class="s2">= </span><span class="s6">32768</span><span class="s1">,</span>
        <span class="s3">DisallowConditionalTypesContext </span><span class="s2">= </span><span class="s6">65536</span><span class="s1">,</span>
        <span class="s3">ThisNodeHasError </span><span class="s2">= </span><span class="s6">131072</span><span class="s1">,</span>
        <span class="s3">JavaScriptFile </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">ThisNodeOrAnySubNodesHasError </span><span class="s2">= </span><span class="s6">524288</span><span class="s1">,</span>
        <span class="s3">HasAggregatedChildData </span><span class="s2">= </span><span class="s6">1048576</span><span class="s1">,</span>
        <span class="s3">JSDoc </span><span class="s2">= </span><span class="s6">8388608</span><span class="s1">,</span>
        <span class="s3">JsonFile </span><span class="s2">= </span><span class="s6">67108864</span><span class="s1">,</span>
        <span class="s3">BlockScoped </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">ReachabilityCheckFlags </span><span class="s2">= </span><span class="s6">768</span><span class="s1">,</span>
        <span class="s3">ReachabilityAndEmitFlags </span><span class="s2">= </span><span class="s6">2816</span><span class="s1">,</span>
        <span class="s3">ContextFlags </span><span class="s2">= </span><span class="s6">50720768</span><span class="s1">,</span>
        <span class="s3">TypeExcludesFlags </span><span class="s2">= </span><span class="s6">40960</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ModifierFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Export </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Ambient </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">Public </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">Private </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Protected </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">Static </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">Readonly </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">Abstract </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">Async </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">Default </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">Const </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">HasComputedJSDocModifiers </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">Deprecated </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">Override </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">In </span><span class="s2">= </span><span class="s6">32768</span><span class="s1">,</span>
        <span class="s3">Out </span><span class="s2">= </span><span class="s6">65536</span><span class="s1">,</span>
        <span class="s3">Decorator </span><span class="s2">= </span><span class="s6">131072</span><span class="s1">,</span>
        <span class="s3">HasComputedFlags </span><span class="s2">= </span><span class="s6">536870912</span><span class="s1">,</span>
        <span class="s3">AccessibilityModifier </span><span class="s2">= </span><span class="s6">28</span><span class="s1">,</span>
        <span class="s3">ParameterPropertyModifier </span><span class="s2">= </span><span class="s6">16476</span><span class="s1">,</span>
        <span class="s3">NonPublicAccessibilityModifier </span><span class="s2">= </span><span class="s6">24</span><span class="s1">,</span>
        <span class="s3">TypeScriptModifier </span><span class="s2">= </span><span class="s6">116958</span><span class="s1">,</span>
        <span class="s3">ExportDefault </span><span class="s2">= </span><span class="s6">513</span><span class="s1">,</span>
        <span class="s3">All </span><span class="s2">= </span><span class="s6">257023</span><span class="s1">,</span>
        <span class="s3">Modifier </span><span class="s2">= </span><span class="s6">125951</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">JsxFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s0">/** An element from a named property of the JSX.IntrinsicElements interface */</span>
        <span class="s3">IntrinsicNamedElement </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s0">/** An element inferred from the string index signature of the JSX.IntrinsicElements interface */</span>
        <span class="s3">IntrinsicIndexedElement </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">IntrinsicElement </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Node </span><span class="s2">extends </span><span class="s3">ReadonlyTextRange </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">flags</span><span class="s2">: </span><span class="s3">NodeFlags</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">HasJSDoc </span><span class="s2">= </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">CallSignatureDeclaration </span><span class="s2">| </span><span class="s3">ClassStaticBlockDeclaration </span><span class="s2">| </span><span class="s3">ConstructSignatureDeclaration </span><span class="s2">| </span><span class="s3">MethodSignature </span><span class="s2">| </span><span class="s3">PropertySignature </span><span class="s2">| </span><span class="s3">ArrowFunction </span><span class="s2">| </span><span class="s3">ParenthesizedExpression </span><span class="s2">| </span><span class="s3">SpreadAssignment </span><span class="s2">| </span><span class="s3">ShorthandPropertyAssignment </span><span class="s2">| </span><span class="s3">PropertyAssignment </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">EmptyStatement </span><span class="s2">| </span><span class="s3">DebuggerStatement </span><span class="s2">| </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">VariableStatement </span><span class="s2">| </span><span class="s3">ExpressionStatement </span><span class="s2">| </span><span class="s3">IfStatement </span><span class="s2">| </span><span class="s3">DoStatement </span><span class="s2">| </span><span class="s3">WhileStatement </span><span class="s2">| </span><span class="s3">ForStatement </span><span class="s2">| </span><span class="s3">ForInStatement </span><span class="s2">| </span><span class="s3">ForOfStatement </span><span class="s2">| </span><span class="s3">BreakStatement </span><span class="s2">| </span><span class="s3">ContinueStatement </span><span class="s2">| </span><span class="s3">ReturnStatement </span><span class="s2">| </span><span class="s3">WithStatement </span><span class="s2">| </span><span class="s3">SwitchStatement </span><span class="s2">| </span><span class="s3">LabeledStatement </span><span class="s2">| </span><span class="s3">ThrowStatement </span><span class="s2">| </span><span class="s3">TryStatement </span><span class="s2">| </span><span class="s3">FunctionDeclaration </span><span class="s2">| </span><span class="s3">ConstructorDeclaration </span><span class="s2">| </span><span class="s3">MethodDeclaration </span><span class="s2">| </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">PropertyDeclaration </span><span class="s2">| </span><span class="s3">AccessorDeclaration </span><span class="s2">| </span><span class="s3">ClassLikeDeclaration </span><span class="s2">| </span><span class="s3">InterfaceDeclaration </span><span class="s2">| </span><span class="s3">TypeAliasDeclaration </span><span class="s2">| </span><span class="s3">EnumMember </span><span class="s2">| </span><span class="s3">EnumDeclaration </span><span class="s2">| </span><span class="s3">ModuleDeclaration </span><span class="s2">| </span><span class="s3">ImportEqualsDeclaration </span><span class="s2">| </span><span class="s3">ImportDeclaration </span><span class="s2">| </span><span class="s3">NamespaceExportDeclaration </span><span class="s2">| </span><span class="s3">ExportAssignment </span><span class="s2">| </span><span class="s3">IndexSignatureDeclaration </span><span class="s2">| </span><span class="s3">FunctionTypeNode </span><span class="s2">| </span><span class="s3">ConstructorTypeNode </span><span class="s2">| </span><span class="s3">JSDocFunctionType </span><span class="s2">| </span><span class="s3">ExportDeclaration </span><span class="s2">| </span><span class="s3">NamedTupleMember </span><span class="s2">| </span><span class="s3">ExportSpecifier </span><span class="s2">| </span><span class="s3">CaseClause </span><span class="s2">| </span><span class="s3">EndOfFileToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">HasType </span><span class="s2">= </span><span class="s3">SignatureDeclaration </span><span class="s2">| </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">PropertySignature </span><span class="s2">| </span><span class="s3">PropertyDeclaration </span><span class="s2">| </span><span class="s3">TypePredicateNode </span><span class="s2">| </span><span class="s3">ParenthesizedTypeNode </span><span class="s2">| </span><span class="s3">TypeOperatorNode </span><span class="s2">| </span><span class="s3">MappedTypeNode </span><span class="s2">| </span><span class="s3">AssertionExpression </span><span class="s2">| </span><span class="s3">TypeAliasDeclaration </span><span class="s2">| </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">JSDocNonNullableType </span><span class="s2">| </span><span class="s3">JSDocNullableType </span><span class="s2">| </span><span class="s3">JSDocOptionalType </span><span class="s2">| </span><span class="s3">JSDocVariadicType</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">HasTypeArguments </span><span class="s2">= </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">NewExpression </span><span class="s2">| </span><span class="s3">TaggedTemplateExpression </span><span class="s2">| </span><span class="s3">JsxOpeningElement </span><span class="s2">| </span><span class="s3">JsxSelfClosingElement</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">HasInitializer </span><span class="s2">= </span><span class="s3">HasExpressionInitializer </span><span class="s2">| </span><span class="s3">ForStatement </span><span class="s2">| </span><span class="s3">ForInStatement </span><span class="s2">| </span><span class="s3">ForOfStatement </span><span class="s2">| </span><span class="s3">JsxAttribute</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">HasExpressionInitializer </span><span class="s2">= </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">BindingElement </span><span class="s2">| </span><span class="s3">PropertyDeclaration </span><span class="s2">| </span><span class="s3">PropertyAssignment </span><span class="s2">| </span><span class="s3">EnumMember</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">HasDecorators </span><span class="s2">= </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">PropertyDeclaration </span><span class="s2">| </span><span class="s3">MethodDeclaration </span><span class="s2">| </span><span class="s3">GetAccessorDeclaration </span><span class="s2">| </span><span class="s3">SetAccessorDeclaration </span><span class="s2">| </span><span class="s3">ClassExpression </span><span class="s2">| </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">HasModifiers </span><span class="s2">= </span><span class="s3">TypeParameterDeclaration </span><span class="s2">| </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">ConstructorTypeNode </span><span class="s2">| </span><span class="s3">PropertySignature </span><span class="s2">| </span><span class="s3">PropertyDeclaration </span><span class="s2">| </span><span class="s3">MethodSignature </span><span class="s2">| </span><span class="s3">MethodDeclaration </span><span class="s2">| </span><span class="s3">ConstructorDeclaration </span><span class="s2">| </span><span class="s3">GetAccessorDeclaration </span><span class="s2">| </span><span class="s3">SetAccessorDeclaration </span><span class="s2">| </span><span class="s3">IndexSignatureDeclaration </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">ArrowFunction </span><span class="s2">| </span><span class="s3">ClassExpression </span><span class="s2">| </span><span class="s3">VariableStatement </span><span class="s2">| </span><span class="s3">FunctionDeclaration </span><span class="s2">| </span><span class="s3">ClassDeclaration </span><span class="s2">| </span><span class="s3">InterfaceDeclaration </span><span class="s2">| </span><span class="s3">TypeAliasDeclaration </span><span class="s2">| </span><span class="s3">EnumDeclaration </span><span class="s2">| </span><span class="s3">ModuleDeclaration </span><span class="s2">| </span><span class="s3">ImportEqualsDeclaration </span><span class="s2">| </span><span class="s3">ImportDeclaration </span><span class="s2">| </span><span class="s3">ExportAssignment </span><span class="s2">| </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">ReadonlyTextRange </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">hasTrailingComma</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">SyntaxKind</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">EndOfFileToken </span><span class="s2">= </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EndOfFileToken</span><span class="s1">&gt; </span><span class="s2">&amp; </span><span class="s3">JSDocContainer</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">PunctuationSyntaxKind</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">DotToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">DotDotDotToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotDotDotToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">QuestionToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">ExclamationToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">ColonToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ColonToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">EqualsToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">AsteriskToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">EqualsGreaterThanToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsGreaterThanToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">PlusToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">MinusToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusToken</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">QuestionDotToken </span><span class="s2">= </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionDotToken</span><span class="s1">&gt;;</span>
    <span class="s2">export interface </span><span class="s3">KeywordToken</span><span class="s1">&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">KeywordSyntaxKind</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">AssertsKeyword </span><span class="s2">= </span><span class="s3">KeywordToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AssertsKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">AssertKeyword </span><span class="s2">= </span><span class="s3">KeywordToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AssertKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">AwaitKeyword </span><span class="s2">= </span><span class="s3">KeywordToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AwaitKeyword</span><span class="s1">&gt;;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `AwaitKeyword` instead. */</span>
    <span class="s2">export type </span><span class="s3">AwaitKeywordToken </span><span class="s2">= </span><span class="s3">AwaitKeyword</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `AssertsKeyword` instead. */</span>
    <span class="s2">export type </span><span class="s3">AssertsToken </span><span class="s2">= </span><span class="s3">AssertsKeyword</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">ModifierSyntaxKind</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">KeywordToken</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">AbstractKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AbstractKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">AsyncKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsyncKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">ConstKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConstKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">DeclareKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DeclareKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">DefaultKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DefaultKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">ExportKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExportKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">InKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">PrivateKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PrivateKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">ProtectedKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ProtectedKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">PublicKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PublicKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">ReadonlyKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ReadonlyKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">OutKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OutKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">OverrideKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OverrideKeyword</span><span class="s1">&gt;;</span>
    <span class="s2">export type </span><span class="s3">StaticKeyword </span><span class="s2">= </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">StaticKeyword</span><span class="s1">&gt;;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `ReadonlyKeyword` instead. */</span>
    <span class="s2">export type </span><span class="s3">ReadonlyToken </span><span class="s2">= </span><span class="s3">ReadonlyKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">Modifier </span><span class="s2">= </span><span class="s3">AbstractKeyword </span><span class="s2">| </span><span class="s3">AsyncKeyword </span><span class="s2">| </span><span class="s3">ConstKeyword </span><span class="s2">| </span><span class="s3">DeclareKeyword </span><span class="s2">| </span><span class="s3">DefaultKeyword </span><span class="s2">| </span><span class="s3">ExportKeyword </span><span class="s2">| </span><span class="s3">InKeyword </span><span class="s2">| </span><span class="s3">PrivateKeyword </span><span class="s2">| </span><span class="s3">ProtectedKeyword </span><span class="s2">| </span><span class="s3">PublicKeyword </span><span class="s2">| </span><span class="s3">OutKeyword </span><span class="s2">| </span><span class="s3">OverrideKeyword </span><span class="s2">| </span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">StaticKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ModifierLike </span><span class="s2">= </span><span class="s3">Modifier </span><span class="s2">| </span><span class="s3">Decorator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">AccessibilityModifier </span><span class="s2">= </span><span class="s3">PublicKeyword </span><span class="s2">| </span><span class="s3">PrivateKeyword </span><span class="s2">| </span><span class="s3">ProtectedKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ParameterPropertyModifier </span><span class="s2">= </span><span class="s3">AccessibilityModifier </span><span class="s2">| </span><span class="s3">ReadonlyKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ClassMemberModifier </span><span class="s2">= </span><span class="s3">AccessibilityModifier </span><span class="s2">| </span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">StaticKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ModifiersArray </span><span class="s2">= </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
    <span class="s2">export enum </span><span class="s3">GeneratedIdentifierFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">ReservedInNestedScopes </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Optimistic </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">FileLevel </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">AllowNameSubstitution </span><span class="s2">= </span><span class="s6">64</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Identifier </span><span class="s2">extends </span><span class="s3">PrimaryExpression</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.) 
         * Text of identifier, but if the identifier begins with two underscores, this will begin with three. 
         */</span>
        <span class="s2">readonly </span><span class="s1">escapedText</span><span class="s2">: </span><span class="s3">__String</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">originalKeywordKind</span><span class="s2">?: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">isInJSDocNamespace</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TransientIdentifier </span><span class="s2">extends </span><span class="s3">Identifier </span><span class="s1">{</span>
        <span class="s1">resolvedSymbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">QualifiedName </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QualifiedName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">left</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">right</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">EntityName </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">QualifiedName</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">PropertyName </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">NumericLiteral </span><span class="s2">| </span><span class="s3">ComputedPropertyName </span><span class="s2">| </span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">MemberName </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">DeclarationName </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PrivateIdentifier </span><span class="s2">| </span><span class="s3">StringLiteralLike </span><span class="s2">| </span><span class="s3">NumericLiteral </span><span class="s2">| </span><span class="s3">ComputedPropertyName </span><span class="s2">| </span><span class="s3">ElementAccessExpression </span><span class="s2">| </span><span class="s3">BindingPattern </span><span class="s2">| </span><span class="s3">EntityNameExpression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">Declaration </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s1">_declarationBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NamedDeclaration </span><span class="s2">extends </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">DeclarationName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DeclarationStatement </span><span class="s2">extends </span><span class="s3">NamedDeclaration</span><span class="s1">, </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">NumericLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ComputedPropertyName </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ComputedPropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">Declaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PrivateIdentifier </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">escapedText</span><span class="s2">: </span><span class="s3">__String</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Decorator </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Decorator</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">NamedDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeParameterDeclaration </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeParameter</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">DeclarationWithTypeParameterChildren </span><span class="s2">| </span><span class="s3">InferTypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s0">/** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */</span>
        <span class="s2">readonly </span><span class="s1">constraint</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">default</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s1">expression</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SignatureDeclarationBase </span><span class="s2">extends </span><span class="s3">NamedDeclaration</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SignatureDeclaration</span><span class="s1">[</span><span class="s4">&quot;kind&quot;</span><span class="s1">];</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">?: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">SignatureDeclaration </span><span class="s2">= </span><span class="s3">CallSignatureDeclaration </span><span class="s2">| </span><span class="s3">ConstructSignatureDeclaration </span><span class="s2">| </span><span class="s3">MethodSignature </span><span class="s2">| </span><span class="s3">IndexSignatureDeclaration </span><span class="s2">| </span><span class="s3">FunctionTypeNode </span><span class="s2">| </span><span class="s3">ConstructorTypeNode </span><span class="s2">| </span><span class="s3">JSDocFunctionType </span><span class="s2">| </span><span class="s3">FunctionDeclaration </span><span class="s2">| </span><span class="s3">MethodDeclaration </span><span class="s2">| </span><span class="s3">ConstructorDeclaration </span><span class="s2">| </span><span class="s3">AccessorDeclaration </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">CallSignatureDeclaration </span><span class="s2">extends </span><span class="s3">SignatureDeclarationBase</span><span class="s1">, </span><span class="s3">TypeElement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CallSignature</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ConstructSignatureDeclaration </span><span class="s2">extends </span><span class="s3">SignatureDeclarationBase</span><span class="s1">, </span><span class="s3">TypeElement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConstructSignature</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">BindingName </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">BindingPattern</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">VariableDeclaration </span><span class="s2">extends </span><span class="s3">NamedDeclaration</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">VariableDeclarationList </span><span class="s2">| </span><span class="s3">CatchClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">exclamationToken</span><span class="s2">?: </span><span class="s3">ExclamationToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">VariableDeclarationList </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">VariableDeclarationList</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">VariableStatement </span><span class="s2">| </span><span class="s3">ForStatement </span><span class="s2">| </span><span class="s3">ForOfStatement </span><span class="s2">| </span><span class="s3">ForInStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">declarations</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">VariableDeclaration</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ParameterDeclaration </span><span class="s2">extends </span><span class="s3">NamedDeclaration</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Parameter</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">SignatureDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ModifierLike</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">dotDotDotToken</span><span class="s2">?: </span><span class="s3">DotDotDotToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">BindingElement </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BindingElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">BindingPattern</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">propertyName</span><span class="s2">?: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">dotDotDotToken</span><span class="s2">?: </span><span class="s3">DotDotDotToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PropertySignature </span><span class="s2">extends </span><span class="s3">TypeElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PropertySignature</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PropertyDeclaration </span><span class="s2">extends </span><span class="s3">ClassElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ClassLikeDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ModifierLike</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">exclamationToken</span><span class="s2">?: </span><span class="s3">ExclamationToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ObjectLiteralElement </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s1">_objectLiteralBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */</span>
    <span class="s2">export type </span><span class="s3">ObjectLiteralElementLike </span><span class="s2">= </span><span class="s3">PropertyAssignment </span><span class="s2">| </span><span class="s3">ShorthandPropertyAssignment </span><span class="s2">| </span><span class="s3">SpreadAssignment </span><span class="s2">| </span><span class="s3">MethodDeclaration </span><span class="s2">| </span><span class="s3">AccessorDeclaration</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">PropertyAssignment </span><span class="s2">extends </span><span class="s3">ObjectLiteralElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PropertyAssignment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ShorthandPropertyAssignment </span><span class="s2">extends </span><span class="s3">ObjectLiteralElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ShorthandPropertyAssignment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">equalsToken</span><span class="s2">?: </span><span class="s3">EqualsToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">objectAssignmentInitializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SpreadAssignment </span><span class="s2">extends </span><span class="s3">ObjectLiteralElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SpreadAssignment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">VariableLikeDeclaration </span><span class="s2">= </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">BindingElement </span><span class="s2">| </span><span class="s3">PropertyDeclaration </span><span class="s2">| </span><span class="s3">PropertyAssignment </span><span class="s2">| </span><span class="s3">PropertySignature </span><span class="s2">| </span><span class="s3">JsxAttribute </span><span class="s2">| </span><span class="s3">ShorthandPropertyAssignment </span><span class="s2">| </span><span class="s3">EnumMember </span><span class="s2">| </span><span class="s3">JSDocPropertyTag </span><span class="s2">| </span><span class="s3">JSDocParameterTag</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">PropertyLikeDeclaration </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ObjectBindingPattern </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ObjectBindingPattern</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">BindingElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">BindingElement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ArrayBindingPattern </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ArrayBindingPattern</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">BindingElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ArrayBindingElement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">BindingPattern </span><span class="s2">= </span><span class="s3">ObjectBindingPattern </span><span class="s2">| </span><span class="s3">ArrayBindingPattern</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ArrayBindingElement </span><span class="s2">= </span><span class="s3">BindingElement </span><span class="s2">| </span><span class="s3">OmittedExpression</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Several node kinds share function-like features such as a signature, 
     * a name, and a body. These nodes should extend FunctionLikeDeclarationBase. 
     * Examples: 
     * - FunctionDeclaration 
     * - MethodDeclaration 
     * - AccessorDeclaration 
     */</span>
    <span class="s2">export interface </span><span class="s3">FunctionLikeDeclarationBase </span><span class="s2">extends </span><span class="s3">SignatureDeclarationBase </span><span class="s1">{</span>
        <span class="s1">_functionLikeDeclarationBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">asteriskToken</span><span class="s2">?: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">exclamationToken</span><span class="s2">?: </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">?: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">FunctionLikeDeclaration </span><span class="s2">= </span><span class="s3">FunctionDeclaration </span><span class="s2">| </span><span class="s3">MethodDeclaration </span><span class="s2">| </span><span class="s3">GetAccessorDeclaration </span><span class="s2">| </span><span class="s3">SetAccessorDeclaration </span><span class="s2">| </span><span class="s3">ConstructorDeclaration </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use SignatureDeclaration */</span>
    <span class="s2">export type </span><span class="s3">FunctionLike </span><span class="s2">= </span><span class="s3">SignatureDeclaration</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">FunctionDeclaration </span><span class="s2">extends </span><span class="s3">FunctionLikeDeclarationBase</span><span class="s1">, </span><span class="s3">DeclarationStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">?: </span><span class="s3">FunctionBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">MethodSignature </span><span class="s2">extends </span><span class="s3">SignatureDeclarationBase</span><span class="s1">, </span><span class="s3">TypeElement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MethodSignature</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ObjectTypeDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">MethodDeclaration </span><span class="s2">extends </span><span class="s3">FunctionLikeDeclarationBase</span><span class="s1">, </span><span class="s3">ClassElement</span><span class="s1">, </span><span class="s3">ObjectLiteralElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ClassLikeDeclaration </span><span class="s2">| </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ModifierLike</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">?: </span><span class="s3">FunctionBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ConstructorDeclaration </span><span class="s2">extends </span><span class="s3">FunctionLikeDeclarationBase</span><span class="s1">, </span><span class="s3">ClassElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Constructor</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ClassLikeDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">?: </span><span class="s3">FunctionBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */</span>
    <span class="s2">export interface </span><span class="s3">SemicolonClassElement </span><span class="s2">extends </span><span class="s3">ClassElement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SemicolonClassElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ClassLikeDeclaration</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">GetAccessorDeclaration </span><span class="s2">extends </span><span class="s3">FunctionLikeDeclarationBase</span><span class="s1">, </span><span class="s3">ClassElement</span><span class="s1">, </span><span class="s3">TypeElement</span><span class="s1">, </span><span class="s3">ObjectLiteralElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GetAccessor</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ClassLikeDeclaration </span><span class="s2">| </span><span class="s3">ObjectLiteralExpression </span><span class="s2">| </span><span class="s3">TypeLiteralNode </span><span class="s2">| </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ModifierLike</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">?: </span><span class="s3">FunctionBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SetAccessorDeclaration </span><span class="s2">extends </span><span class="s3">FunctionLikeDeclarationBase</span><span class="s1">, </span><span class="s3">ClassElement</span><span class="s1">, </span><span class="s3">TypeElement</span><span class="s1">, </span><span class="s3">ObjectLiteralElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SetAccessor</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ClassLikeDeclaration </span><span class="s2">| </span><span class="s3">ObjectLiteralExpression </span><span class="s2">| </span><span class="s3">TypeLiteralNode </span><span class="s2">| </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ModifierLike</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">?: </span><span class="s3">FunctionBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">AccessorDeclaration </span><span class="s2">= </span><span class="s3">GetAccessorDeclaration </span><span class="s2">| </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">IndexSignatureDeclaration </span><span class="s2">extends </span><span class="s3">SignatureDeclarationBase</span><span class="s1">, </span><span class="s3">ClassElement</span><span class="s1">, </span><span class="s3">TypeElement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">IndexSignature</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ObjectTypeDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ClassStaticBlockDeclaration </span><span class="s2">extends </span><span class="s3">ClassElement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ClassStaticBlockDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ClassDeclaration </span><span class="s2">| </span><span class="s3">ClassExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeNode </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s1">_typeNodeBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">KeywordTypeNode</span><span class="s1">&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">KeywordTypeSyntaxKind </span><span class="s2">= </span><span class="s3">KeywordTypeSyntaxKind</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">KeywordToken</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;, </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ImportTypeAssertionContainer </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportTypeAssertionContainer</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">assertClause</span><span class="s2">: </span><span class="s3">AssertClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ImportTypeNode </span><span class="s2">extends </span><span class="s3">NodeWithTypeArguments </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isTypeOf</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">assertions</span><span class="s2">?: </span><span class="s3">ImportTypeAssertionContainer</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">qualifier</span><span class="s2">?: </span><span class="s3">EntityName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ThisTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ThisType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">FunctionOrConstructorTypeNode </span><span class="s2">= </span><span class="s3">FunctionTypeNode </span><span class="s2">| </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">FunctionOrConstructorTypeNodeBase </span><span class="s2">extends </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">SignatureDeclarationBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FunctionType </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConstructorType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FunctionTypeNode </span><span class="s2">extends </span><span class="s3">FunctionOrConstructorTypeNodeBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FunctionType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ConstructorTypeNode </span><span class="s2">extends </span><span class="s3">FunctionOrConstructorTypeNodeBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConstructorType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NodeWithTypeArguments </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">TypeReferenceType </span><span class="s2">= </span><span class="s3">TypeReferenceNode </span><span class="s2">| </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">TypeReferenceNode </span><span class="s2">extends </span><span class="s3">NodeWithTypeArguments </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeReference</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypePredicateNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypePredicate</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">SignatureDeclaration </span><span class="s2">| </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">assertsModifier</span><span class="s2">?: </span><span class="s3">AssertsKeyword</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parameterName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisTypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeQueryNode </span><span class="s2">extends </span><span class="s3">NodeWithTypeArguments </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeQuery</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">exprName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeLiteralNode </span><span class="s2">extends </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeLiteral</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ArrayTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ArrayType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elementType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TupleTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TupleType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">NamedTupleMember</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NamedTupleMember </span><span class="s2">extends </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">JSDocContainer</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NamedTupleMember</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">dotDotDotToken</span><span class="s2">?: </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotDotDotToken</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionToken</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">OptionalTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OptionalType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">RestTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">RestType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">UnionOrIntersectionTypeNode </span><span class="s2">= </span><span class="s3">UnionTypeNode </span><span class="s2">| </span><span class="s3">IntersectionTypeNode</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">UnionTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnionType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">types</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">IntersectionTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">IntersectionType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">types</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ConditionalTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConditionalType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">checkType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">extendsType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">trueType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">falseType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">InferTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InferType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ParenthesizedTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ParenthesizedType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeOperatorNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeOperator</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operator</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">KeyOfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UniqueKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ReadonlyKeyword</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">IndexedAccessTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">IndexedAccessType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">objectType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">indexType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">MappedTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MappedType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">readonlyToken</span><span class="s2">?: </span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">nameType</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s0">/** Used only to produce grammar errors */</span>
        <span class="s2">readonly </span><span class="s1">members</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">LiteralTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LiteralType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">literal</span><span class="s2">: </span><span class="s3">NullLiteral </span><span class="s2">| </span><span class="s3">BooleanLiteral </span><span class="s2">| </span><span class="s3">LiteralExpression </span><span class="s2">| </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">StringLiteral </span><span class="s2">extends </span><span class="s3">LiteralExpression</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">StringLiteralLike </span><span class="s2">= </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">PropertyNameLiteral </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">StringLiteralLike </span><span class="s2">| </span><span class="s3">NumericLiteral</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">TemplateLiteralTypeNode </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateLiteralType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">head</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">templateSpans</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TemplateLiteralTypeSpan </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">TemplateLiteralTypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">literal</span><span class="s2">: </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Expression </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s1">_expressionBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">OmittedExpression </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OmittedExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PartiallyEmittedExpression </span><span class="s2">extends </span><span class="s3">LeftHandSideExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PartiallyEmittedExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnaryExpression </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s1">_unaryExpressionBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** Deprecated, please use UpdateExpression */</span>
    <span class="s2">export type </span><span class="s3">IncrementExpression </span><span class="s2">= </span><span class="s3">UpdateExpression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">UpdateExpression </span><span class="s2">extends </span><span class="s3">UnaryExpression </span><span class="s1">{</span>
        <span class="s1">_updateExpressionBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">PrefixUnaryOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusPlusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusMinusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TildeToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationToken</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">PrefixUnaryExpression </span><span class="s2">extends </span><span class="s3">UpdateExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operator</span><span class="s2">: </span><span class="s3">PrefixUnaryOperator</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operand</span><span class="s2">: </span><span class="s3">UnaryExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">PostfixUnaryOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusPlusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusMinusToken</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">PostfixUnaryExpression </span><span class="s2">extends </span><span class="s3">UpdateExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operand</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operator</span><span class="s2">: </span><span class="s3">PostfixUnaryOperator</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">LeftHandSideExpression </span><span class="s2">extends </span><span class="s3">UpdateExpression </span><span class="s1">{</span>
        <span class="s1">_leftHandSideExpressionBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">MemberExpression </span><span class="s2">extends </span><span class="s3">LeftHandSideExpression </span><span class="s1">{</span>
        <span class="s1">_memberExpressionBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PrimaryExpression </span><span class="s2">extends </span><span class="s3">MemberExpression </span><span class="s1">{</span>
        <span class="s1">_primaryExpressionBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NullLiteral </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NullKeyword</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TrueLiteral </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TrueKeyword</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FalseLiteral </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FalseKeyword</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">BooleanLiteral </span><span class="s2">= </span><span class="s3">TrueLiteral </span><span class="s2">| </span><span class="s3">FalseLiteral</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ThisExpression </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ThisKeyword</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SuperExpression </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SuperKeyword</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ImportExpression </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportKeyword</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DeleteExpression </span><span class="s2">extends </span><span class="s3">UnaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DeleteExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">UnaryExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeOfExpression </span><span class="s2">extends </span><span class="s3">UnaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeOfExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">UnaryExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">VoidExpression </span><span class="s2">extends </span><span class="s3">UnaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">VoidExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">UnaryExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">AwaitExpression </span><span class="s2">extends </span><span class="s3">UnaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AwaitExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">UnaryExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">YieldExpression </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">YieldExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">asteriskToken</span><span class="s2">?: </span><span class="s3">AsteriskToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SyntheticExpression </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SyntheticExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isSpread</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tupleNameSource</span><span class="s2">?: </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">NamedTupleMember</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ExponentiationOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskAsteriskToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">MultiplicativeOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SlashToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PercentToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">MultiplicativeOperatorOrHigher </span><span class="s2">= </span><span class="s3">ExponentiationOperator </span><span class="s2">| </span><span class="s3">MultiplicativeOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">AdditiveOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">AdditiveOperatorOrHigher </span><span class="s2">= </span><span class="s3">MultiplicativeOperatorOrHigher </span><span class="s2">| </span><span class="s3">AdditiveOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ShiftOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanLessThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanGreaterThanToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ShiftOperatorOrHigher </span><span class="s2">= </span><span class="s3">AdditiveOperatorOrHigher </span><span class="s2">| </span><span class="s3">ShiftOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">RelationalOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InstanceOfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InKeyword</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">RelationalOperatorOrHigher </span><span class="s2">= </span><span class="s3">ShiftOperatorOrHigher </span><span class="s2">| </span><span class="s3">RelationalOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">EqualityOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsEqualsEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationEqualsEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationEqualsToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">EqualityOperatorOrHigher </span><span class="s2">= </span><span class="s3">RelationalOperatorOrHigher </span><span class="s2">| </span><span class="s3">EqualityOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">BitwiseOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaretToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">BitwiseOperatorOrHigher </span><span class="s2">= </span><span class="s3">EqualityOperatorOrHigher </span><span class="s2">| </span><span class="s3">BitwiseOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">LogicalOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandAmpersandToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarBarToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">LogicalOperatorOrHigher </span><span class="s2">= </span><span class="s3">BitwiseOperatorOrHigher </span><span class="s2">| </span><span class="s3">LogicalOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">CompoundAssignmentOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskAsteriskEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SlashEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PercentEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaretEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanLessThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanGreaterThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarBarEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandAmpersandEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionQuestionEqualsToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">AssignmentOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsToken </span><span class="s2">| </span><span class="s3">CompoundAssignmentOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">AssignmentOperatorOrHigher </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionQuestionToken </span><span class="s2">| </span><span class="s3">LogicalOperatorOrHigher </span><span class="s2">| </span><span class="s3">AssignmentOperator</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">BinaryOperator </span><span class="s2">= </span><span class="s3">AssignmentOperatorOrHigher </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CommaToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">LogicalOrCoalescingAssignmentOperator </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandAmpersandEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarBarEqualsToken </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionQuestionEqualsToken</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">BinaryOperatorToken </span><span class="s2">= </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">BinaryOperator</span><span class="s1">&gt;;</span>
    <span class="s2">export interface </span><span class="s3">BinaryExpression </span><span class="s2">extends </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operatorToken</span><span class="s2">: </span><span class="s3">BinaryOperatorToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">AssignmentOperatorToken </span><span class="s2">= </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">AssignmentOperator</span><span class="s1">&gt;;</span>
    <span class="s2">export interface </span><span class="s3">AssignmentExpression</span><span class="s1">&lt;</span><span class="s3">TOperator </span><span class="s2">extends </span><span class="s3">AssignmentOperatorToken</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">BinaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">left</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operatorToken</span><span class="s2">: </span><span class="s3">TOperator</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ObjectDestructuringAssignment </span><span class="s2">extends </span><span class="s3">AssignmentExpression</span><span class="s1">&lt;</span><span class="s3">EqualsToken</span><span class="s1">&gt; {</span>
        <span class="s2">readonly </span><span class="s1">left</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ArrayDestructuringAssignment </span><span class="s2">extends </span><span class="s3">AssignmentExpression</span><span class="s1">&lt;</span><span class="s3">EqualsToken</span><span class="s1">&gt; {</span>
        <span class="s2">readonly </span><span class="s1">left</span><span class="s2">: </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">DestructuringAssignment </span><span class="s2">= </span><span class="s3">ObjectDestructuringAssignment </span><span class="s2">| </span><span class="s3">ArrayDestructuringAssignment</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">BindingOrAssignmentElement </span><span class="s2">= </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">ObjectBindingOrAssignmentElement </span><span class="s2">| </span><span class="s3">ArrayBindingOrAssignmentElement</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ObjectBindingOrAssignmentElement </span><span class="s2">= </span><span class="s3">BindingElement </span><span class="s2">| </span><span class="s3">PropertyAssignment </span><span class="s2">| </span><span class="s3">ShorthandPropertyAssignment </span><span class="s2">| </span><span class="s3">SpreadAssignment</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ArrayBindingOrAssignmentElement </span><span class="s2">= </span><span class="s3">BindingElement </span><span class="s2">| </span><span class="s3">OmittedExpression </span><span class="s2">| </span><span class="s3">SpreadElement </span><span class="s2">| </span><span class="s3">ArrayLiteralExpression </span><span class="s2">| </span><span class="s3">ObjectLiteralExpression </span><span class="s2">| </span><span class="s3">AssignmentExpression</span><span class="s1">&lt;</span><span class="s3">EqualsToken</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PropertyAccessExpression </span><span class="s2">| </span><span class="s3">ElementAccessExpression</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">BindingOrAssignmentElementRestIndicator </span><span class="s2">= </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">SpreadElement </span><span class="s2">| </span><span class="s3">SpreadAssignment</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">BindingOrAssignmentElementTarget </span><span class="s2">= </span><span class="s3">BindingOrAssignmentPattern </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PropertyAccessExpression </span><span class="s2">| </span><span class="s3">ElementAccessExpression </span><span class="s2">| </span><span class="s3">OmittedExpression</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ObjectBindingOrAssignmentPattern </span><span class="s2">= </span><span class="s3">ObjectBindingPattern </span><span class="s2">| </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ArrayBindingOrAssignmentPattern </span><span class="s2">= </span><span class="s3">ArrayBindingPattern </span><span class="s2">| </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">AssignmentPattern </span><span class="s2">= </span><span class="s3">ObjectLiteralExpression </span><span class="s2">| </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">BindingOrAssignmentPattern </span><span class="s2">= </span><span class="s3">ObjectBindingOrAssignmentPattern </span><span class="s2">| </span><span class="s3">ArrayBindingOrAssignmentPattern</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ConditionalExpression </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ConditionalExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">condition</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">whenTrue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">colonToken</span><span class="s2">: </span><span class="s3">ColonToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">whenFalse</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">FunctionBody </span><span class="s2">= </span><span class="s3">Block</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ConciseBody </span><span class="s2">= </span><span class="s3">FunctionBody </span><span class="s2">| </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">FunctionExpression </span><span class="s2">extends </span><span class="s3">PrimaryExpression</span><span class="s1">, </span><span class="s3">FunctionLikeDeclarationBase</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FunctionExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">FunctionBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ArrowFunction </span><span class="s2">extends </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">FunctionLikeDeclarationBase</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ArrowFunction</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">equalsGreaterThanToken</span><span class="s2">: </span><span class="s3">EqualsGreaterThanToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">never</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">LiteralLikeNode </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">isUnterminated</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">hasExtendedUnicodeEscape</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TemplateLiteralLikeNode </span><span class="s2">extends </span><span class="s3">LiteralLikeNode </span><span class="s1">{</span>
        <span class="s1">rawText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">LiteralExpression </span><span class="s2">extends </span><span class="s3">LiteralLikeNode</span><span class="s1">, </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s1">_literalExpressionBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">RegularExpressionLiteral </span><span class="s2">extends </span><span class="s3">LiteralExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">RegularExpressionLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NoSubstitutionTemplateLiteral </span><span class="s2">extends </span><span class="s3">LiteralExpression</span><span class="s1">, </span><span class="s3">TemplateLiteralLikeNode</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">TokenFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Scientific </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">Octal </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">HexSpecifier </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">BinarySpecifier </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">OctalSpecifier </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NumericLiteral </span><span class="s2">extends </span><span class="s3">LiteralExpression</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NumericLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">BigIntLiteral </span><span class="s2">extends </span><span class="s3">LiteralExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BigIntLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">LiteralToken </span><span class="s2">= </span><span class="s3">NumericLiteral </span><span class="s2">| </span><span class="s3">BigIntLiteral </span><span class="s2">| </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">JsxText </span><span class="s2">| </span><span class="s3">RegularExpressionLiteral </span><span class="s2">| </span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">TemplateHead </span><span class="s2">extends </span><span class="s3">TemplateLiteralLikeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateHead</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">TemplateExpression </span><span class="s2">| </span><span class="s3">TemplateLiteralTypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TemplateMiddle </span><span class="s2">extends </span><span class="s3">TemplateLiteralLikeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateMiddle</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">TemplateSpan </span><span class="s2">| </span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TemplateTail </span><span class="s2">extends </span><span class="s3">TemplateLiteralLikeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateTail</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">TemplateSpan </span><span class="s2">| </span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">PseudoLiteralToken </span><span class="s2">= </span><span class="s3">TemplateHead </span><span class="s2">| </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">TemplateLiteralToken </span><span class="s2">= </span><span class="s3">NoSubstitutionTemplateLiteral </span><span class="s2">| </span><span class="s3">PseudoLiteralToken</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">TemplateExpression </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">head</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">templateSpans</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TemplateSpan</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">TemplateLiteral </span><span class="s2">= </span><span class="s3">TemplateExpression </span><span class="s2">| </span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">TemplateSpan </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TemplateSpan</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">TemplateExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">literal</span><span class="s2">: </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ParenthesizedExpression </span><span class="s2">extends </span><span class="s3">PrimaryExpression</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ParenthesizedExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ArrayLiteralExpression </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Expression</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SpreadElement </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SpreadElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ArrayLiteralExpression </span><span class="s2">| </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">NewExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to 
     * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be 
     * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type 
     * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.) 
     */</span>
    <span class="s2">export interface </span><span class="s3">ObjectLiteralExpressionBase</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">ObjectLiteralElement</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">PrimaryExpression</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">properties</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ObjectLiteralExpression </span><span class="s2">extends </span><span class="s3">ObjectLiteralExpressionBase</span><span class="s1">&lt;</span><span class="s3">ObjectLiteralElementLike</span><span class="s1">&gt; {</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">EntityNameExpression </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PropertyAccessEntityNameExpression</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">EntityNameOrEntityNameExpression </span><span class="s2">= </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">EntityNameExpression</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">AccessExpression </span><span class="s2">= </span><span class="s3">PropertyAccessExpression </span><span class="s2">| </span><span class="s3">ElementAccessExpression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">PropertyAccessExpression </span><span class="s2">extends </span><span class="s3">MemberExpression</span><span class="s1">, </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PropertyAccessExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionDotToken</span><span class="s2">?: </span><span class="s3">QuestionDotToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">MemberName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PropertyAccessChain </span><span class="s2">extends </span><span class="s3">PropertyAccessExpression </span><span class="s1">{</span>
        <span class="s1">_optionalChainBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">MemberName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SuperPropertyAccessExpression </span><span class="s2">extends </span><span class="s3">PropertyAccessExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">SuperExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */</span>
    <span class="s2">export interface </span><span class="s3">PropertyAccessEntityNameExpression </span><span class="s2">extends </span><span class="s3">PropertyAccessExpression </span><span class="s1">{</span>
        <span class="s1">_propertyAccessExpressionLikeQualifiedNameBrand</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">EntityNameExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ElementAccessExpression </span><span class="s2">extends </span><span class="s3">MemberExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ElementAccessExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionDotToken</span><span class="s2">?: </span><span class="s3">QuestionDotToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">argumentExpression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ElementAccessChain </span><span class="s2">extends </span><span class="s3">ElementAccessExpression </span><span class="s1">{</span>
        <span class="s1">_optionalChainBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SuperElementAccessExpression </span><span class="s2">extends </span><span class="s3">ElementAccessExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">SuperExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">SuperProperty </span><span class="s2">= </span><span class="s3">SuperPropertyAccessExpression </span><span class="s2">| </span><span class="s3">SuperElementAccessExpression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">CallExpression </span><span class="s2">extends </span><span class="s3">LeftHandSideExpression</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionDotToken</span><span class="s2">?: </span><span class="s3">QuestionDotToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">arguments</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Expression</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CallChain </span><span class="s2">extends </span><span class="s3">CallExpression </span><span class="s1">{</span>
        <span class="s1">_optionalChainBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">OptionalChain </span><span class="s2">= </span><span class="s3">PropertyAccessChain </span><span class="s2">| </span><span class="s3">ElementAccessChain </span><span class="s2">| </span><span class="s3">CallChain </span><span class="s2">| </span><span class="s3">NonNullChain</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">SuperCall </span><span class="s2">extends </span><span class="s3">CallExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">SuperExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ImportCall </span><span class="s2">extends </span><span class="s3">CallExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">ImportExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ExpressionWithTypeArguments </span><span class="s2">extends </span><span class="s3">MemberExpression</span><span class="s1">, </span><span class="s3">NodeWithTypeArguments </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NewExpression </span><span class="s2">extends </span><span class="s3">PrimaryExpression</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NewExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">arguments</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Expression</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TaggedTemplateExpression </span><span class="s2">extends </span><span class="s3">MemberExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tag</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">template</span><span class="s2">: </span><span class="s3">TemplateLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">CallLikeExpression </span><span class="s2">= </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">NewExpression </span><span class="s2">| </span><span class="s3">TaggedTemplateExpression </span><span class="s2">| </span><span class="s3">Decorator </span><span class="s2">| </span><span class="s3">JsxOpeningLikeElement</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">AsExpression </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeAssertion </span><span class="s2">extends </span><span class="s3">UnaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeAssertionExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">UnaryExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">AssertionExpression </span><span class="s2">= </span><span class="s3">TypeAssertion </span><span class="s2">| </span><span class="s3">AsExpression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">NonNullExpression </span><span class="s2">extends </span><span class="s3">LeftHandSideExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NonNullExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NonNullChain </span><span class="s2">extends </span><span class="s3">NonNullExpression </span><span class="s1">{</span>
        <span class="s1">_optionalChainBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">MetaProperty </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MetaProperty</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">keywordToken</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NewKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportKeyword</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxElement </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">openingElement</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">children</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JsxChild</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">closingElement</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">JsxOpeningLikeElement </span><span class="s2">= </span><span class="s3">JsxSelfClosingElement </span><span class="s2">| </span><span class="s3">JsxOpeningElement</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">JsxAttributeLike </span><span class="s2">= </span><span class="s3">JsxAttribute </span><span class="s2">| </span><span class="s3">JsxSpreadAttribute</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">JsxTagNameExpression </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisExpression </span><span class="s2">| </span><span class="s3">JsxTagNamePropertyAccess</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">JsxTagNamePropertyAccess </span><span class="s2">extends </span><span class="s3">PropertyAccessExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxAttributes </span><span class="s2">extends </span><span class="s3">ObjectLiteralExpressionBase</span><span class="s1">&lt;</span><span class="s3">JsxAttributeLike</span><span class="s1">&gt; {</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxAttributes</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxOpeningLikeElement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxOpeningElement </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxOpeningElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxSelfClosingElement </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxSelfClosingElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxFragment </span><span class="s2">extends </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxFragment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">openingFragment</span><span class="s2">: </span><span class="s3">JsxOpeningFragment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">children</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JsxChild</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">closingFragment</span><span class="s2">: </span><span class="s3">JsxClosingFragment</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxOpeningFragment </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxOpeningFragment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxFragment</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxClosingFragment </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxClosingFragment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxFragment</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxAttribute </span><span class="s2">extends </span><span class="s3">ObjectLiteralElement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxAttribute</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s3">JsxAttributeValue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">JsxAttributeValue </span><span class="s2">= </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">JsxExpression </span><span class="s2">| </span><span class="s3">JsxElement </span><span class="s2">| </span><span class="s3">JsxSelfClosingElement </span><span class="s2">| </span><span class="s3">JsxFragment</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">JsxSpreadAttribute </span><span class="s2">extends </span><span class="s3">ObjectLiteralElement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxSpreadAttribute</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxClosingElement </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxClosingElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxElement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxExpression </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxElement </span><span class="s2">| </span><span class="s3">JsxFragment </span><span class="s2">| </span><span class="s3">JsxAttributeLike</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">dotDotDotToken</span><span class="s2">?: </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotDotDotToken</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsxText </span><span class="s2">extends </span><span class="s3">LiteralLikeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JsxText</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JsxElement </span><span class="s2">| </span><span class="s3">JsxFragment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">containsOnlyTriviaWhiteSpaces</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">JsxChild </span><span class="s2">= </span><span class="s3">JsxText </span><span class="s2">| </span><span class="s3">JsxExpression </span><span class="s2">| </span><span class="s3">JsxElement </span><span class="s2">| </span><span class="s3">JsxSelfClosingElement </span><span class="s2">| </span><span class="s3">JsxFragment</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">Statement </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s1">_statementBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NotEmittedStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NotEmittedStatement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A list of comma-separated expressions. This node is only created by transformations. 
     */</span>
    <span class="s2">export interface </span><span class="s3">CommaListExpression </span><span class="s2">extends </span><span class="s3">Expression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CommaListExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Expression</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">EmptyStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EmptyStatement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DebuggerStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DebuggerStatement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">MissingDeclaration </span><span class="s2">extends </span><span class="s3">DeclarationStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MissingDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">BlockLike </span><span class="s2">= </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">ModuleBlock </span><span class="s2">| </span><span class="s3">CaseOrDefaultClause</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">Block </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Block</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">statements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Statement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">VariableStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">VariableStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">declarationList</span><span class="s2">: </span><span class="s3">VariableDeclarationList</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ExpressionStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">IfStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">IfStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">thenStatement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elseStatement</span><span class="s2">?: </span><span class="s3">Statement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">IterationStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DoStatement </span><span class="s2">extends </span><span class="s3">IterationStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DoStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">WhileStatement </span><span class="s2">extends </span><span class="s3">IterationStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">WhileStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ForInitializer </span><span class="s2">= </span><span class="s3">VariableDeclarationList </span><span class="s2">| </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ForStatement </span><span class="s2">extends </span><span class="s3">IterationStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ForStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s3">ForInitializer</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">condition</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">incrementor</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ForInOrOfStatement </span><span class="s2">= </span><span class="s3">ForInStatement </span><span class="s2">| </span><span class="s3">ForOfStatement</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ForInStatement </span><span class="s2">extends </span><span class="s3">IterationStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ForInStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ForOfStatement </span><span class="s2">extends </span><span class="s3">IterationStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ForOfStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">awaitModifier</span><span class="s2">?: </span><span class="s3">AwaitKeyword</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">BreakStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BreakStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">label</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ContinueStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ContinueStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">label</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">BreakOrContinueStatement </span><span class="s2">= </span><span class="s3">BreakStatement </span><span class="s2">| </span><span class="s3">ContinueStatement</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ReturnStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ReturnStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">WithStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">WithStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SwitchStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SwitchStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">caseBlock</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">;</span>
        <span class="s1">possiblyExhaustive</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CaseBlock </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaseBlock</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">SwitchStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">clauses</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">CaseOrDefaultClause</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CaseClause </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaseClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">statements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Statement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DefaultClause </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DefaultClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">statements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Statement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">CaseOrDefaultClause </span><span class="s2">= </span><span class="s3">CaseClause </span><span class="s2">| </span><span class="s3">DefaultClause</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">LabeledStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LabeledStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">label</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ThrowStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ThrowStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TryStatement </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TryStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tryBlock</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">catchClause</span><span class="s2">?: </span><span class="s3">CatchClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">finallyBlock</span><span class="s2">?: </span><span class="s3">Block</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CatchClause </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CatchClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">TryStatement</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">variableDeclaration</span><span class="s2">?: </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">block</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ObjectTypeDeclaration </span><span class="s2">= </span><span class="s3">ClassLikeDeclaration </span><span class="s2">| </span><span class="s3">InterfaceDeclaration </span><span class="s2">| </span><span class="s3">TypeLiteralNode</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">DeclarationWithTypeParameters </span><span class="s2">= </span><span class="s3">DeclarationWithTypeParameterChildren </span><span class="s2">| </span><span class="s3">JSDocTypedefTag </span><span class="s2">| </span><span class="s3">JSDocCallbackTag </span><span class="s2">| </span><span class="s3">JSDocSignature</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">DeclarationWithTypeParameterChildren </span><span class="s2">= </span><span class="s3">SignatureDeclaration </span><span class="s2">| </span><span class="s3">ClassLikeDeclaration </span><span class="s2">| </span><span class="s3">InterfaceDeclaration </span><span class="s2">| </span><span class="s3">TypeAliasDeclaration </span><span class="s2">| </span><span class="s3">JSDocTemplateTag</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ClassLikeDeclarationBase </span><span class="s2">extends </span><span class="s3">NamedDeclaration</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ClassDeclaration </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ClassExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">heritageClauses</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">HeritageClause</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ClassElement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ClassDeclaration </span><span class="s2">extends </span><span class="s3">ClassLikeDeclarationBase</span><span class="s1">, </span><span class="s3">DeclarationStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ModifierLike</span><span class="s1">&gt;;</span>
        <span class="s0">/** May be undefined in `export default class { ... }`. */</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ClassExpression </span><span class="s2">extends </span><span class="s3">ClassLikeDeclarationBase</span><span class="s1">, </span><span class="s3">PrimaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ClassExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ModifierLike</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ClassLikeDeclaration </span><span class="s2">= </span><span class="s3">ClassDeclaration </span><span class="s2">| </span><span class="s3">ClassExpression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ClassElement </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s1">_classElementBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeElement </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s1">_typeElementBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">InterfaceDeclaration </span><span class="s2">extends </span><span class="s3">DeclarationStatement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">heritageClauses</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">HeritageClause</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">HeritageClause </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">HeritageClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">InterfaceDeclaration </span><span class="s2">| </span><span class="s3">ClassLikeDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExtendsKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImplementsKeyword</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">types</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeAliasDeclaration </span><span class="s2">extends </span><span class="s3">DeclarationStatement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">EnumMember </span><span class="s2">extends </span><span class="s3">NamedDeclaration</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EnumMember</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">EnumDeclaration </span><span class="s2">extends </span><span class="s3">DeclarationStatement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">EnumMember</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ModuleName </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ModuleBody </span><span class="s2">= </span><span class="s3">NamespaceBody </span><span class="s2">| </span><span class="s3">JSDocNamespaceBody</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ModuleDeclaration </span><span class="s2">extends </span><span class="s3">DeclarationStatement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">?: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">JSDocNamespaceDeclaration</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">NamespaceBody </span><span class="s2">= </span><span class="s3">ModuleBlock </span><span class="s2">| </span><span class="s3">NamespaceDeclaration</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">NamespaceDeclaration </span><span class="s2">extends </span><span class="s3">ModuleDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">NamespaceBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">JSDocNamespaceBody </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSDocNamespaceDeclaration</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">JSDocNamespaceDeclaration </span><span class="s2">extends </span><span class="s3">ModuleDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">?: </span><span class="s3">JSDocNamespaceBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ModuleBlock </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ModuleBlock</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">statements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Statement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ModuleReference </span><span class="s2">= </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">ExternalModuleReference</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* One of: 
     * - import x = require(&quot;mod&quot;); 
     * - import x = M.x; 
     */</span>
    <span class="s2">export interface </span><span class="s3">ImportEqualsDeclaration </span><span class="s2">extends </span><span class="s3">DeclarationStatement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">ModuleBlock</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ExternalModuleReference </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExternalModuleReference</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ImportDeclaration </span><span class="s2">extends </span><span class="s3">Statement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">ModuleBlock</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">importClause</span><span class="s2">?: </span><span class="s3">ImportClause</span><span class="s1">;</span>
        <span class="s0">/** If this is not a StringLiteral it will be a grammar error. */</span>
        <span class="s2">readonly </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">assertClause</span><span class="s2">?: </span><span class="s3">AssertClause</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">NamedImportBindings </span><span class="s2">= </span><span class="s3">NamespaceImport </span><span class="s2">| </span><span class="s3">NamedImports</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">NamedExportBindings </span><span class="s2">= </span><span class="s3">NamespaceExport </span><span class="s2">| </span><span class="s3">NamedExports</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ImportClause </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">namedBindings</span><span class="s2">?: </span><span class="s3">NamedImportBindings</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">AssertionKey </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">AssertEntry </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AssertEntry</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">AssertClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">AssertionKey</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">value</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">AssertClause </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AssertClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ImportDeclaration </span><span class="s2">| </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">AssertEntry</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NamespaceImport </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NamespaceImport</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ImportClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NamespaceExport </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NamespaceExport</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NamespaceExportDeclaration </span><span class="s2">extends </span><span class="s3">DeclarationStatement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NamespaceExportDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ExportDeclaration </span><span class="s2">extends </span><span class="s3">DeclarationStatement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">ModuleBlock</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** Will not be assigned in the case of `export * from &quot;foo&quot;;` */</span>
        <span class="s2">readonly </span><span class="s1">exportClause</span><span class="s2">?: </span><span class="s3">NamedExportBindings</span><span class="s1">;</span>
        <span class="s0">/** If this is not a StringLiteral it will be a grammar error. */</span>
        <span class="s2">readonly </span><span class="s1">moduleSpecifier</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">assertClause</span><span class="s2">?: </span><span class="s3">AssertClause</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NamedImports </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NamedImports</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ImportClause</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ImportSpecifier</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NamedExports </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NamedExports</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ExportSpecifier</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">NamedImportsOrExports </span><span class="s2">= </span><span class="s3">NamedImports </span><span class="s2">| </span><span class="s3">NamedExports</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ImportSpecifier </span><span class="s2">extends </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportSpecifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">NamedImports</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">propertyName</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ExportSpecifier </span><span class="s2">extends </span><span class="s3">NamedDeclaration</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">NamedExports</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">propertyName</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ImportOrExportSpecifier </span><span class="s2">= </span><span class="s3">ImportSpecifier </span><span class="s2">| </span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">TypeOnlyCompatibleAliasDeclaration </span><span class="s2">= </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">ImportEqualsDeclaration </span><span class="s2">| </span><span class="s3">NamespaceImport </span><span class="s2">| </span><span class="s3">ImportOrExportSpecifier</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">TypeOnlyAliasDeclaration </span><span class="s2">= </span><span class="s3">ImportClause </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">| </span><span class="s3">ImportEqualsDeclaration </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">| </span><span class="s3">NamespaceImport </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">&amp; </span><span class="s1">{</span>
            <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">} </span><span class="s2">| </span><span class="s3">ImportSpecifier </span><span class="s2">&amp; </span><span class="s1">({</span>
        <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">| </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">NamedImports </span><span class="s2">&amp; </span><span class="s1">{</span>
            <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">&amp; </span><span class="s1">{</span>
                <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">};</span>
        <span class="s1">};</span>
    <span class="s1">}) | ExportSpecifier &amp; ({ 
        </span><span class="s2">readonly </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s1">; 
    } </span><span class="s2">| </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">NamedExports </span><span class="s2">&amp; </span><span class="s1">{</span>
            <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">ExportDeclaration </span><span class="s2">&amp; </span><span class="s1">{</span>
                <span class="s2">readonly </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">};</span>
        <span class="s1">};</span>
    <span class="s1">});</span>
    <span class="s0">/**</span>
     <span class="s0">* This is either an `export =` or an `export default` declaration. 
     * Unless `isExportEquals` is set, this node was parsed as an `export default`. 
     */</span>
    <span class="s2">export interface </span><span class="s3">ExportAssignment </span><span class="s2">extends </span><span class="s3">DeclarationStatement</span><span class="s1">, </span><span class="s3">JSDocContainer </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExportAssignment</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">isExportEquals</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FileReference </span><span class="s2">extends </span><span class="s3">TextRange </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">resolutionMode</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CheckJsDirective </span><span class="s2">extends </span><span class="s3">TextRange </span><span class="s1">{</span>
        <span class="s1">enabled</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">CommentKind </span><span class="s2">= </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SingleLineCommentTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MultiLineCommentTrivia</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">CommentRange </span><span class="s2">extends </span><span class="s3">TextRange </span><span class="s1">{</span>
        <span class="s1">hasTrailingNewLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">CommentKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SynthesizedComment </span><span class="s2">extends </span><span class="s3">CommentRange </span><span class="s1">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">pos</span><span class="s2">: </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">end</span><span class="s2">: </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">hasLeadingNewline</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocTypeExpression </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocNameReference </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocNameReference</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** Class#method reference in JSDoc */</span>
    <span class="s2">export interface </span><span class="s3">JSDocMemberName </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">left</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">right</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocType </span><span class="s2">extends </span><span class="s3">TypeNode </span><span class="s1">{</span>
        <span class="s1">_jsDocTypeBrand</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocAllType </span><span class="s2">extends </span><span class="s3">JSDocType </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocAllType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocUnknownType </span><span class="s2">extends </span><span class="s3">JSDocType </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocUnknownType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocNonNullableType </span><span class="s2">extends </span><span class="s3">JSDocType </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocNonNullableType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">postfix</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocNullableType </span><span class="s2">extends </span><span class="s3">JSDocType </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocNullableType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">postfix</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocOptionalType </span><span class="s2">extends </span><span class="s3">JSDocType </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocOptionalType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocFunctionType </span><span class="s2">extends </span><span class="s3">JSDocType</span><span class="s1">, </span><span class="s3">SignatureDeclarationBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocFunctionType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocVariadicType </span><span class="s2">extends </span><span class="s3">JSDocType </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocVariadicType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocNamepathType </span><span class="s2">extends </span><span class="s3">JSDocType </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocNamepathType</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">JSDocTypeReferencingNode </span><span class="s2">= </span><span class="s3">JSDocVariadicType </span><span class="s2">| </span><span class="s3">JSDocOptionalType </span><span class="s2">| </span><span class="s3">JSDocNullableType </span><span class="s2">| </span><span class="s3">JSDocNonNullableType</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">JSDoc </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDoc</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">HasJSDoc</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tags</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocTag</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocTag </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JSDoc </span><span class="s2">| </span><span class="s3">JSDocTypeLiteral</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tagName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocLink </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocLink</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocLinkCode </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocLinkCode</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocLinkPlain </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocLinkPlain</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">JSDocComment </span><span class="s2">= </span><span class="s3">JSDocText </span><span class="s2">| </span><span class="s3">JSDocLink </span><span class="s2">| </span><span class="s3">JSDocLinkCode </span><span class="s2">| </span><span class="s3">JSDocLinkPlain</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">JSDocText </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocText</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocUnknownTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Note that `</span><span class="s2">@extends</span><span class="s0">` is a synonym of `</span><span class="s2">@augments</span><span class="s0">`. 
     * Both tags are represented by this interface. 
     */</span>
    <span class="s2">export interface </span><span class="s3">JSDocAugmentsTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocAugmentsTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">class</span><span class="s2">: </span><span class="s3">ExpressionWithTypeArguments </span><span class="s2">&amp; </span><span class="s1">{</span>
            <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PropertyAccessEntityNameExpression</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocImplementsTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocImplementsTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">class</span><span class="s2">: </span><span class="s3">ExpressionWithTypeArguments </span><span class="s2">&amp; </span><span class="s1">{</span>
            <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PropertyAccessEntityNameExpression</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocAuthorTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocAuthorTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocDeprecatedTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocDeprecatedTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocClassTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocClassTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocPublicTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocPublicTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocPrivateTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocPrivateTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocProtectedTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocProtectedTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocReadonlyTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocReadonlyTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocOverrideTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocOverrideTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocEnumTag </span><span class="s2">extends </span><span class="s3">JSDocTag</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocEnumTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JSDoc</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocThisTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocThisTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocTemplateTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocTemplateTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">constraint</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocSeeTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocSeeTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">JSDocNameReference</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocReturnTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocReturnTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocTypeTag </span><span class="s2">extends </span><span class="s3">JSDocTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocTypeTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocTypedefTag </span><span class="s2">extends </span><span class="s3">JSDocTag</span><span class="s1">, </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocTypedefTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JSDoc</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">fullName</span><span class="s2">?: </span><span class="s3">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">JSDocTypeLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocCallbackTag </span><span class="s2">extends </span><span class="s3">JSDocTag</span><span class="s1">, </span><span class="s3">NamedDeclaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocCallbackTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JSDoc</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">fullName</span><span class="s2">?: </span><span class="s3">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">?: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s3">JSDocSignature</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocSignature </span><span class="s2">extends </span><span class="s3">JSDocType</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocSignature</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeParameters</span><span class="s2">?: readonly </span><span class="s3">JSDocTemplateTag</span><span class="s1">[];</span>
        <span class="s2">readonly </span><span class="s1">parameters</span><span class="s2">: readonly </span><span class="s3">JSDocParameterTag</span><span class="s1">[];</span>
        <span class="s2">readonly </span><span class="s1">type</span><span class="s2">: </span><span class="s3">JSDocReturnTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocPropertyLikeTag </span><span class="s2">extends </span><span class="s3">JSDocTag</span><span class="s1">, </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">JSDoc</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
        <span class="s0">/** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */</span>
        <span class="s2">readonly </span><span class="s1">isNameFirst</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isBracketed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocPropertyTag </span><span class="s2">extends </span><span class="s3">JSDocPropertyLikeTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocPropertyTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocParameterTag </span><span class="s2">extends </span><span class="s3">JSDocPropertyLikeTag </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocParameterTag</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JSDocTypeLiteral </span><span class="s2">extends </span><span class="s3">JSDocType </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">JSDocTypeLiteral</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">jsDocPropertyTags</span><span class="s2">?: readonly </span><span class="s3">JSDocPropertyLikeTag</span><span class="s1">[];</span>
        <span class="s0">/** If true, then this type literal represents an *array* of its type. */</span>
        <span class="s2">readonly </span><span class="s1">isArrayType</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">FlowFlags </span><span class="s1">{</span>
        <span class="s3">Unreachable </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Start </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">BranchLabel </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">LoopLabel </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Assignment </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">TrueCondition </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">FalseCondition </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">SwitchClause </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">ArrayMutation </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">Call </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">ReduceLabel </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">Referenced </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">Shared </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">Label </span><span class="s2">= </span><span class="s6">12</span><span class="s1">,</span>
        <span class="s3">Condition </span><span class="s2">= </span><span class="s6">96</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">FlowNode </span><span class="s2">= </span><span class="s3">FlowStart </span><span class="s2">| </span><span class="s3">FlowLabel </span><span class="s2">| </span><span class="s3">FlowAssignment </span><span class="s2">| </span><span class="s3">FlowCondition </span><span class="s2">| </span><span class="s3">FlowSwitchClause </span><span class="s2">| </span><span class="s3">FlowArrayMutation </span><span class="s2">| </span><span class="s3">FlowCall </span><span class="s2">| </span><span class="s3">FlowReduceLabel</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s3">FlowFlags</span><span class="s1">;</span>
        <span class="s1">id</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FlowStart </span><span class="s2">extends </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">node</span><span class="s2">?: </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">ArrowFunction </span><span class="s2">| </span><span class="s3">MethodDeclaration </span><span class="s2">| </span><span class="s3">GetAccessorDeclaration </span><span class="s2">| </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FlowLabel </span><span class="s2">extends </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">antecedents</span><span class="s2">: </span><span class="s3">FlowNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FlowAssignment </span><span class="s2">extends </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">BindingElement</span><span class="s1">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s3">FlowNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FlowCall </span><span class="s2">extends </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s3">FlowNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FlowCondition </span><span class="s2">extends </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s3">FlowNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FlowSwitchClause </span><span class="s2">extends </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">switchStatement</span><span class="s2">: </span><span class="s3">SwitchStatement</span><span class="s1">;</span>
        <span class="s1">clauseStart</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">clauseEnd</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s3">FlowNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FlowArrayMutation </span><span class="s2">extends </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s3">FlowNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FlowReduceLabel </span><span class="s2">extends </span><span class="s3">FlowNodeBase </span><span class="s1">{</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s3">FlowLabel</span><span class="s1">;</span>
        <span class="s1">antecedents</span><span class="s2">: </span><span class="s3">FlowNode</span><span class="s1">[];</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s3">FlowNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">FlowType </span><span class="s2">= </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">IncompleteType</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">IncompleteType </span><span class="s1">{</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s3">TypeFlags</span><span class="s1">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">AmdDependency </span><span class="s1">{</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">name</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Subset of properties from SourceFile that are used in multiple utility functions 
     */</span>
    <span class="s2">export interface </span><span class="s3">SourceFileLike </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SourceFile </span><span class="s2">extends </span><span class="s3">Declaration </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">statements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Statement</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">endOfFileToken</span><span class="s2">: </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EndOfFileToken</span><span class="s1">&gt;;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">amdDependencies</span><span class="s2">: readonly </span><span class="s3">AmdDependency</span><span class="s1">[];</span>
        <span class="s1">moduleName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">referencedFiles</span><span class="s2">: readonly </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">typeReferenceDirectives</span><span class="s2">: readonly </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">libReferenceDirectives</span><span class="s2">: readonly </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">languageVariant</span><span class="s2">: </span><span class="s3">LanguageVariant</span><span class="s1">;</span>
        <span class="s1">isDeclarationFile</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* lib.d.ts should have a reference comment like 
         * 
         *  /// &lt;reference no-default-lib=&quot;true&quot;/&gt; 
         * 
         * If any other file has this comment, it signals not to include lib.d.ts 
         * because this containing file is intended to act as a default library. 
         */</span>
        <span class="s1">hasNoDefaultLib</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">languageVersion</span><span class="s2">: </span><span class="s3">ScriptTarget</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* When `module` is `Node16` or `NodeNext`, this field controls whether the 
         * source file in question is an ESNext-output-format file, or a CommonJS-output-format 
         * module. This is derived by the module resolver as it looks up the file, since 
         * it is derived from either the file extension of the module, or the containing 
         * `package.json` context, and affects both checking and emit. 
         * 
         * It is _public_ so that (pre)transformers can set this field, 
         * since it switches the builtin `node` module transform. Generally speaking, if unset, 
         * the field is treated as though it is `ModuleKind.CommonJS`. 
         * 
         * Note that this field is only set by the module resolution process when 
         * `moduleResolution` is `Node16` or `NodeNext`, which is implied by the `module` setting 
         * of `Node16` or `NodeNext`, respectively, but may be overriden (eg, by a `moduleResolution` 
         * of `node`). If so, this field will be unset and source files will be considered to be 
         * CommonJS-output-format by the node module transformer and type checker, regardless of extension or context. 
         */</span>
        <span class="s1">impliedNodeFormat</span><span class="s2">?: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Bundle </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Bundle</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">prepends</span><span class="s2">: readonly </span><span class="s1">(</span><span class="s3">InputFiles </span><span class="s2">| </span><span class="s3">UnparsedSource</span><span class="s1">)[];</span>
        <span class="s2">readonly </span><span class="s1">sourceFiles</span><span class="s2">: readonly </span><span class="s3">SourceFile</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">InputFiles </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">InputFiles</span><span class="s1">;</span>
        <span class="s1">javascriptPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">javascriptText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">javascriptMapPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">javascriptMapText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">declarationPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">declarationText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">declarationMapPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">declarationMapText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnparsedSource </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnparsedSource</span><span class="s1">;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">prologues</span><span class="s2">: readonly </span><span class="s3">UnparsedPrologue</span><span class="s1">[];</span>
        <span class="s1">helpers</span><span class="s2">: readonly </span><span class="s3">UnscopedEmitHelper</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">referencedFiles</span><span class="s2">: readonly </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">typeReferenceDirectives</span><span class="s2">: readonly </span><span class="s3">FileReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">libReferenceDirectives</span><span class="s2">: readonly </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">hasNoDefaultLib</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">sourceMapPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">sourceMapText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">syntheticReferences</span><span class="s2">?: readonly </span><span class="s3">UnparsedSyntheticReference</span><span class="s1">[];</span>
        <span class="s2">readonly </span><span class="s1">texts</span><span class="s2">: readonly </span><span class="s3">UnparsedSourceText</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">UnparsedSourceText </span><span class="s2">= </span><span class="s3">UnparsedPrepend </span><span class="s2">| </span><span class="s3">UnparsedTextLike</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">UnparsedNode </span><span class="s2">= </span><span class="s3">UnparsedPrologue </span><span class="s2">| </span><span class="s3">UnparsedSourceText </span><span class="s2">| </span><span class="s3">UnparsedSyntheticReference</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">UnparsedSection </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">data</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnparsedPrologue </span><span class="s2">extends </span><span class="s3">UnparsedSection </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnparsedPrologue</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnparsedPrepend </span><span class="s2">extends </span><span class="s3">UnparsedSection </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnparsedPrepend</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">texts</span><span class="s2">: readonly </span><span class="s3">UnparsedTextLike</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnparsedTextLike </span><span class="s2">extends </span><span class="s3">UnparsedSection </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnparsedText </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnparsedInternalText</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnparsedSyntheticReference </span><span class="s2">extends </span><span class="s3">UnparsedSection </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UnparsedSyntheticReference</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">parent</span><span class="s2">: </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsonSourceFile </span><span class="s2">extends </span><span class="s3">SourceFile </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">statements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JsonObjectExpressionStatement</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TsConfigSourceFile </span><span class="s2">extends </span><span class="s3">JsonSourceFile </span><span class="s1">{</span>
        <span class="s1">extendedSourceFiles</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">JsonMinusNumericLiteral </span><span class="s2">extends </span><span class="s3">PrefixUnaryExpression </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operator</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">operand</span><span class="s2">: </span><span class="s3">NumericLiteral</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">JsonObjectExpression </span><span class="s2">= </span><span class="s3">ObjectLiteralExpression </span><span class="s2">| </span><span class="s3">ArrayLiteralExpression </span><span class="s2">| </span><span class="s3">JsonMinusNumericLiteral </span><span class="s2">| </span><span class="s3">NumericLiteral </span><span class="s2">| </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">BooleanLiteral </span><span class="s2">| </span><span class="s3">NullLiteral</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">JsonObjectExpressionStatement </span><span class="s2">extends </span><span class="s3">ExpressionStatement </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">JsonObjectExpression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ScriptReferenceHost </span><span class="s1">{</span>
        <span class="s1">getCompilerOptions()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">getSourceFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSourceFileByPath(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ParseConfigHost </span><span class="s1">{</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">readDirectory(</span><span class="s3">rootDir</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">extensions</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">excludes</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">includes</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">depth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets a value indicating whether the specified path exists and is a file. 
         * </span><span class="s2">@param </span><span class="s3">path </span><span class="s0">The path to test. 
         */</span>
        <span class="s1">fileExists(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">readFile(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">trace</span><span class="s2">?</span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Branded string for keeping track of when we've turned an ambiguous path 
     * specified like &quot;./blah&quot; to an absolute path to an actual 
     * tsconfig file, e.g. &quot;/root/blah/tsconfig.json&quot; 
     */</span>
    <span class="s2">export type </span><span class="s3">ResolvedConfigFileName </span><span class="s2">= </span><span class="s3">string </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">_isResolvedConfigFileName</span><span class="s2">: </span><span class="s3">never</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">export interface </span><span class="s3">WriteFileCallbackData </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">WriteFileCallback </span><span class="s2">= </span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">writeByteOrderMark</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s5">onError</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s3">sourceFiles</span><span class="s2">?: readonly </span><span class="s3">SourceFile</span><span class="s1">[], </span><span class="s3">data</span><span class="s2">?: </span><span class="s3">WriteFileCallbackData</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s2">export class </span><span class="s3">OperationCanceledException </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CancellationToken </span><span class="s1">{</span>
        <span class="s1">isCancellationRequested()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@throws </span><span class="s0">OperationCanceledException if isCancellationRequested is true */</span>
        <span class="s1">throwIfCancellationRequested()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Program </span><span class="s2">extends </span><span class="s3">ScriptReferenceHost </span><span class="s1">{</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get a list of root file names that were passed to a 'createProgram' 
         */</span>
        <span class="s1">getRootFileNames()</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get a list of files in the program 
         */</span>
        <span class="s1">getSourceFiles()</span><span class="s2">: readonly </span><span class="s3">SourceFile</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then 
         * the JavaScript and declaration files will be produced for all the files in this program. 
         * If targetSourceFile is specified, then only the JavaScript and declaration for that 
         * specific file will be generated. 
         * 
         * If writeFile is not specified then the writeFile callback from the compiler host will be 
         * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter 
         * will be invoked when writing the JavaScript and declaration files. 
         */</span>
        <span class="s1">emit(</span><span class="s3">targetSourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s3">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">customTransformers</span><span class="s2">?: </span><span class="s3">CustomTransformers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EmitResult</span><span class="s1">;</span>
        <span class="s1">getOptionsDiagnostics(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">getGlobalDiagnostics(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">getSyntacticDiagnostics(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">DiagnosticWithLocation</span><span class="s1">[];</span>
        <span class="s0">/** The first time this is called, it will return global diagnostics (no location). */</span>
        <span class="s1">getSemanticDiagnostics(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">getDeclarationDiagnostics(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">DiagnosticWithLocation</span><span class="s1">[];</span>
        <span class="s1">getConfigFileParsingDiagnostics()</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets a type checker that can be used to semantically analyze source files in the program. 
         */</span>
        <span class="s1">getTypeChecker()</span><span class="s2">: </span><span class="s3">TypeChecker</span><span class="s1">;</span>
        <span class="s1">getNodeCount()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getIdentifierCount()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getSymbolCount()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getTypeCount()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getInstantiationCount()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getRelationCacheSizes()</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">assignable</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
            <span class="s1">identity</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
            <span class="s1">subtype</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
            <span class="s1">strictSubtype</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s1">isSourceFileFromExternalLibrary(</span><span class="s3">file</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isSourceFileDefaultLibrary(</span><span class="s3">file</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getProjectReferences()</span><span class="s2">: readonly </span><span class="s3">ProjectReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getResolvedProjectReferences()</span><span class="s2">: readonly </span><span class="s1">(</span><span class="s3">ResolvedProjectReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ResolvedProjectReference </span><span class="s1">{</span>
        <span class="s1">commandLine</span><span class="s2">: </span><span class="s3">ParsedCommandLine</span><span class="s1">;</span>
        <span class="s1">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">references</span><span class="s2">?: readonly </span><span class="s1">(</span><span class="s3">ResolvedProjectReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">CustomTransformerFactory </span><span class="s2">= </span><span class="s1">(</span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CustomTransformer</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">CustomTransformer </span><span class="s1">{</span>
        <span class="s1">transformSourceFile(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">transformBundle(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Bundle</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Bundle</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CustomTransformers </span><span class="s1">{</span>
        <span class="s0">/** Custom transformers to evaluate before built-in .js transformations. */</span>
        <span class="s1">before</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">TransformerFactory</span><span class="s1">&lt;</span><span class="s3">SourceFile</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">CustomTransformerFactory</span><span class="s1">)[];</span>
        <span class="s0">/** Custom transformers to evaluate after built-in .js transformations. */</span>
        <span class="s1">after</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">TransformerFactory</span><span class="s1">&lt;</span><span class="s3">SourceFile</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">CustomTransformerFactory</span><span class="s1">)[];</span>
        <span class="s0">/** Custom transformers to evaluate after built-in .d.ts transformations. */</span>
        <span class="s1">afterDeclarations</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">TransformerFactory</span><span class="s1">&lt;</span><span class="s3">Bundle </span><span class="s2">| </span><span class="s3">SourceFile</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">CustomTransformerFactory</span><span class="s1">)[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SourceMapSpan </span><span class="s1">{</span>
        <span class="s0">/** Line number in the .js file. */</span>
        <span class="s1">emittedLine</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/** Column number in the .js file. */</span>
        <span class="s1">emittedColumn</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/** Line number in the .ts file. */</span>
        <span class="s1">sourceLine</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/** Column number in the .ts file. */</span>
        <span class="s1">sourceColumn</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/** Optional name (index into names array) associated with this span. */</span>
        <span class="s1">nameIndex</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/** .ts file (index into sources array) associated with this span */</span>
        <span class="s1">sourceIndex</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** Return code used by getEmitOutput function to indicate status of the function */</span>
    <span class="s2">export enum </span><span class="s3">ExitStatus </span><span class="s1">{</span>
        <span class="s3">Success </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">DiagnosticsPresent_OutputsSkipped </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">DiagnosticsPresent_OutputsGenerated </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">InvalidProject_OutputsSkipped </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">ProjectReferenceCycle_OutputsSkipped </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use ProjectReferenceCycle_OutputsSkipped instead. */</span>
        <span class="s3">ProjectReferenceCycle_OutputsSkupped </span><span class="s2">= </span><span class="s6">4</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">EmitResult </span><span class="s1">{</span>
        <span class="s1">emitSkipped</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** Contains declaration emit diagnostics */</span>
        <span class="s1">diagnostics</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">emittedFiles</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeChecker </span><span class="s1">{</span>
        <span class="s1">getTypeOfSymbolAtLocation(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getDeclaredTypeOfSymbol(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getPropertiesOfType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">getPropertyOfType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getPrivateIdentifierPropertyOfType(</span><span class="s3">leftType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">location</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getIndexInfoOfType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">IndexKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getIndexInfosOfType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">IndexInfo</span><span class="s1">[];</span>
        <span class="s1">getSignaturesOfType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SignatureKind</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Signature</span><span class="s1">[];</span>
        <span class="s1">getIndexTypeOfType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">IndexKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getBaseTypes(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">InterfaceType</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BaseType</span><span class="s1">[];</span>
        <span class="s1">getBaseTypeOfLiteralType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getWidenedType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getReturnTypeOfSignature(</span><span class="s3">signature</span><span class="s2">: </span><span class="s3">Signature</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getNullableType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">TypeFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getNonNullableType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getTypeArguments(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeReference</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Type</span><span class="s1">[];</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">typeToTypeNode(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeBuilderFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">signatureToSignatureDeclaration(</span><span class="s3">signature</span><span class="s2">: </span><span class="s3">Signature</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeBuilderFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SignatureDeclaration </span><span class="s2">&amp; </span><span class="s1">{</span>
            <span class="s1">typeArguments</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;;</span>
        <span class="s1">} </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">indexInfoToIndexSignatureDeclaration(</span><span class="s3">indexInfo</span><span class="s2">: </span><span class="s3">IndexInfo</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeBuilderFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToEntityName(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">, </span><span class="s3">meaning</span><span class="s2">: </span><span class="s3">SymbolFlags</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeBuilderFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToExpression(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">, </span><span class="s3">meaning</span><span class="s2">: </span><span class="s3">SymbolFlags</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeBuilderFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToTypeParameterDeclarations(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeBuilderFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToParameterDeclaration(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeBuilderFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">typeParameterToDeclaration(</span><span class="s3">parameter</span><span class="s2">: </span><span class="s3">TypeParameter</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeBuilderFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSymbolsInScope(</span><span class="s3">location</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">meaning</span><span class="s2">: </span><span class="s3">SymbolFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">getSymbolAtLocation(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSymbolsOfParameterPropertyDeclaration(</span><span class="s3">parameter</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">parameterName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The function returns the value (local variable) symbol of an identifier in the short-hand property assignment. 
         * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value. 
         */</span>
        <span class="s1">getShorthandAssignmentValueSymbol(</span><span class="s3">location</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getExportSpecifierLocalTargetSymbol(</span><span class="s3">location</span><span class="s2">: </span><span class="s3">ExportSpecifier </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If a symbol is a local symbol with an associated exported symbol, returns the exported symbol. 
         * Otherwise returns its input. 
         * For example, at `export type T = number;`: 
         *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`. 
         *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol. 
         *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol. 
         */</span>
        <span class="s1">getExportSymbolOfSymbol(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">;</span>
        <span class="s1">getPropertySymbolOfDestructuringAssignment(</span><span class="s3">location</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getTypeOfAssignmentPattern(</span><span class="s3">pattern</span><span class="s2">: </span><span class="s3">AssignmentPattern</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getTypeAtLocation(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getTypeFromTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">signatureToString(</span><span class="s3">signature</span><span class="s2">: </span><span class="s3">Signature</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">?: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">TypeFormatFlags</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">?: </span><span class="s3">SignatureKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">typeToString(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">?: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">TypeFormatFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">symbolToString(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">?: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">meaning</span><span class="s2">?: </span><span class="s3">SymbolFlags</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">SymbolFormatFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">typePredicateToString(</span><span class="s3">predicate</span><span class="s2">: </span><span class="s3">TypePredicate</span><span class="s1">, </span><span class="s3">enclosingDeclaration</span><span class="s2">?: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">TypeFormatFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getFullyQualifiedName(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getAugmentedPropertiesOfType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">getRootSymbols(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">getSymbolOfExpando(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">allowDeclaration</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getContextualType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* returns unknownSignature in the case of an error. 
         * returns undefined if the node is not valid. 
         * </span><span class="s2">@param </span><span class="s3">argumentCount </span><span class="s0">Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`. 
         */</span>
        <span class="s1">getResolvedSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CallLikeExpression</span><span class="s1">, </span><span class="s3">candidatesOutArray</span><span class="s2">?: </span><span class="s3">Signature</span><span class="s1">[], </span><span class="s3">argumentCount</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Signature </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSignatureFromDeclaration(</span><span class="s3">declaration</span><span class="s2">: </span><span class="s3">SignatureDeclaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Signature </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">isImplementationOfOverload(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SignatureDeclaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">isUndefinedSymbol(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isArgumentsSymbol(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isUnknownSymbol(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getConstantValue(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">EnumMember </span><span class="s2">| </span><span class="s3">PropertyAccessExpression </span><span class="s2">| </span><span class="s3">ElementAccessExpression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">number </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">isValidPropertyAccess(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyAccessExpression </span><span class="s2">| </span><span class="s3">QualifiedName </span><span class="s2">| </span><span class="s3">ImportTypeNode</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** Follow all aliases to get the original symbol. */</span>
        <span class="s1">getAliasedSymbol(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">;</span>
        <span class="s0">/** Follow a *single* alias to get the immediately aliased symbol. */</span>
        <span class="s1">getImmediateAliasedSymbol(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getExportsOfModule(</span><span class="s3">moduleSymbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">getJsxIntrinsicTagNamesAt(</span><span class="s3">location</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">isOptionalParameter(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getAmbientModules()</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">tryGetMemberInModuleExports(</span><span class="s3">memberName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">moduleSymbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getApparentType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getBaseConstraintOfType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getDefaultFromTypeParameter(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getTypePredicateOfSignature(</span><span class="s3">signature</span><span class="s2">: </span><span class="s3">Signature</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypePredicate </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Depending on the operation performed, it may be appropriate to throw away the checker 
         * if the cancellation token is triggered. Typically, if it is used for error checking 
         * and the operation is cancelled, then it should be discarded, otherwise it is safe to keep. 
         */</span>
        <span class="s1">runWithCancellationToken&lt;</span><span class="s3">T</span><span class="s1">&gt;(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s5">cb</span><span class="s2">: </span><span class="s1">(</span><span class="s3">checker</span><span class="s2">: </span><span class="s3">TypeChecker</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">NodeBuilderFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">NoTruncation </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">WriteArrayAsGenericType </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">GenerateNamesForShadowedTypeParams </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">UseStructuralFallback </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">ForbidIndexedAccessSymbolReferences </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">WriteTypeArgumentsOfSignature </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">UseFullyQualifiedType </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">UseOnlyExternalAliasing </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">SuppressAnyReturnType </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">WriteTypeParametersInQualifiedName </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">MultilineObjectLiterals </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">WriteClassExpressionAsTypeLiteral </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">UseTypeOfFunction </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">OmitParameterModifiers </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">UseAliasDefinedOutsideCurrentScope </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">UseSingleQuotesForStringLiteralType </span><span class="s2">= </span><span class="s6">268435456</span><span class="s1">,</span>
        <span class="s3">NoTypeReduction </span><span class="s2">= </span><span class="s6">536870912</span><span class="s1">,</span>
        <span class="s3">OmitThisParameter </span><span class="s2">= </span><span class="s6">33554432</span><span class="s1">,</span>
        <span class="s3">AllowThisInObjectLiteral </span><span class="s2">= </span><span class="s6">32768</span><span class="s1">,</span>
        <span class="s3">AllowQualifiedNameInPlaceOfIdentifier </span><span class="s2">= </span><span class="s6">65536</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">AllowQualifedNameInPlaceOfIdentifier. Use AllowQualifiedNameInPlaceOfIdentifier instead. */</span>
        <span class="s3">AllowQualifedNameInPlaceOfIdentifier </span><span class="s2">= </span><span class="s6">65536</span><span class="s1">,</span>
        <span class="s3">AllowAnonymousIdentifier </span><span class="s2">= </span><span class="s6">131072</span><span class="s1">,</span>
        <span class="s3">AllowEmptyUnionOrIntersection </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">AllowEmptyTuple </span><span class="s2">= </span><span class="s6">524288</span><span class="s1">,</span>
        <span class="s3">AllowUniqueESSymbolType </span><span class="s2">= </span><span class="s6">1048576</span><span class="s1">,</span>
        <span class="s3">AllowEmptyIndexInfoType </span><span class="s2">= </span><span class="s6">2097152</span><span class="s1">,</span>
        <span class="s3">AllowNodeModulesRelativePaths </span><span class="s2">= </span><span class="s6">67108864</span><span class="s1">,</span>
        <span class="s3">IgnoreErrors </span><span class="s2">= </span><span class="s6">70221824</span><span class="s1">,</span>
        <span class="s3">InObjectTypeLiteral </span><span class="s2">= </span><span class="s6">4194304</span><span class="s1">,</span>
        <span class="s3">InTypeAlias </span><span class="s2">= </span><span class="s6">8388608</span><span class="s1">,</span>
        <span class="s3">InInitialEntityName </span><span class="s2">= </span><span class="s6">16777216</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">TypeFormatFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">NoTruncation </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">WriteArrayAsGenericType </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">UseStructuralFallback </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">WriteTypeArgumentsOfSignature </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">UseFullyQualifiedType </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">SuppressAnyReturnType </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">MultilineObjectLiterals </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">WriteClassExpressionAsTypeLiteral </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">UseTypeOfFunction </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">OmitParameterModifiers </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">UseAliasDefinedOutsideCurrentScope </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">UseSingleQuotesForStringLiteralType </span><span class="s2">= </span><span class="s6">268435456</span><span class="s1">,</span>
        <span class="s3">NoTypeReduction </span><span class="s2">= </span><span class="s6">536870912</span><span class="s1">,</span>
        <span class="s3">OmitThisParameter </span><span class="s2">= </span><span class="s6">33554432</span><span class="s1">,</span>
        <span class="s3">AllowUniqueESSymbolType </span><span class="s2">= </span><span class="s6">1048576</span><span class="s1">,</span>
        <span class="s3">AddUndefined </span><span class="s2">= </span><span class="s6">131072</span><span class="s1">,</span>
        <span class="s3">WriteArrowStyleSignature </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">InArrayType </span><span class="s2">= </span><span class="s6">524288</span><span class="s1">,</span>
        <span class="s3">InElementType </span><span class="s2">= </span><span class="s6">2097152</span><span class="s1">,</span>
        <span class="s3">InFirstTypeArgument </span><span class="s2">= </span><span class="s6">4194304</span><span class="s1">,</span>
        <span class="s3">InTypeAlias </span><span class="s2">= </span><span class="s6">8388608</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">*/ </span><span class="s3">WriteOwnNameForAnyLike </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">NodeBuilderFlagsMask </span><span class="s2">= </span><span class="s6">848330091</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">SymbolFormatFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">WriteTypeParametersOrArguments </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">UseOnlyExternalAliasing </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">AllowAnyNodeKind </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">UseAliasDefinedOutsideCurrentScope </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">TypePredicateKind </span><span class="s1">{</span>
        <span class="s3">This </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Identifier </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">AssertsThis </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">AssertsIdentifier </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypePredicateBase </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">TypePredicateKind</span><span class="s1">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ThisTypePredicate </span><span class="s2">extends </span><span class="s3">TypePredicateBase </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">TypePredicateKind</span><span class="s1">.</span><span class="s3">This</span><span class="s1">;</span>
        <span class="s1">parameterName</span><span class="s2">: </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">parameterIndex</span><span class="s2">: </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">IdentifierTypePredicate </span><span class="s2">extends </span><span class="s3">TypePredicateBase </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">TypePredicateKind</span><span class="s1">.</span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s1">parameterName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">parameterIndex</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">AssertsThisTypePredicate </span><span class="s2">extends </span><span class="s3">TypePredicateBase </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">TypePredicateKind</span><span class="s1">.</span><span class="s3">AssertsThis</span><span class="s1">;</span>
        <span class="s1">parameterName</span><span class="s2">: </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">parameterIndex</span><span class="s2">: </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">AssertsIdentifierTypePredicate </span><span class="s2">extends </span><span class="s3">TypePredicateBase </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">TypePredicateKind</span><span class="s1">.</span><span class="s3">AssertsIdentifier</span><span class="s1">;</span>
        <span class="s1">parameterName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">parameterIndex</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">TypePredicate </span><span class="s2">= </span><span class="s3">ThisTypePredicate </span><span class="s2">| </span><span class="s3">IdentifierTypePredicate </span><span class="s2">| </span><span class="s3">AssertsThisTypePredicate </span><span class="s2">| </span><span class="s3">AssertsIdentifierTypePredicate</span><span class="s1">;</span>
    <span class="s2">export enum </span><span class="s3">SymbolFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">FunctionScopedVariable </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">BlockScopedVariable </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">Property </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">EnumMember </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Function </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">Class </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">Interface </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">ConstEnum </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">RegularEnum </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">ValueModule </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">NamespaceModule </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">TypeLiteral </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">ObjectLiteral </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">Method </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">Constructor </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">GetAccessor </span><span class="s2">= </span><span class="s6">32768</span><span class="s1">,</span>
        <span class="s3">SetAccessor </span><span class="s2">= </span><span class="s6">65536</span><span class="s1">,</span>
        <span class="s3">Signature </span><span class="s2">= </span><span class="s6">131072</span><span class="s1">,</span>
        <span class="s3">TypeParameter </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">TypeAlias </span><span class="s2">= </span><span class="s6">524288</span><span class="s1">,</span>
        <span class="s3">ExportValue </span><span class="s2">= </span><span class="s6">1048576</span><span class="s1">,</span>
        <span class="s3">Alias </span><span class="s2">= </span><span class="s6">2097152</span><span class="s1">,</span>
        <span class="s3">Prototype </span><span class="s2">= </span><span class="s6">4194304</span><span class="s1">,</span>
        <span class="s3">ExportStar </span><span class="s2">= </span><span class="s6">8388608</span><span class="s1">,</span>
        <span class="s3">Optional </span><span class="s2">= </span><span class="s6">16777216</span><span class="s1">,</span>
        <span class="s3">Transient </span><span class="s2">= </span><span class="s6">33554432</span><span class="s1">,</span>
        <span class="s3">Assignment </span><span class="s2">= </span><span class="s6">67108864</span><span class="s1">,</span>
        <span class="s3">ModuleExports </span><span class="s2">= </span><span class="s6">134217728</span><span class="s1">,</span>
        <span class="s3">Enum </span><span class="s2">= </span><span class="s6">384</span><span class="s1">,</span>
        <span class="s3">Variable </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">Value </span><span class="s2">= </span><span class="s6">111551</span><span class="s1">,</span>
        <span class="s3">Type </span><span class="s2">= </span><span class="s6">788968</span><span class="s1">,</span>
        <span class="s3">Namespace </span><span class="s2">= </span><span class="s6">1920</span><span class="s1">,</span>
        <span class="s3">Module </span><span class="s2">= </span><span class="s6">1536</span><span class="s1">,</span>
        <span class="s3">Accessor </span><span class="s2">= </span><span class="s6">98304</span><span class="s1">,</span>
        <span class="s3">FunctionScopedVariableExcludes </span><span class="s2">= </span><span class="s6">111550</span><span class="s1">,</span>
        <span class="s3">BlockScopedVariableExcludes </span><span class="s2">= </span><span class="s6">111551</span><span class="s1">,</span>
        <span class="s3">ParameterExcludes </span><span class="s2">= </span><span class="s6">111551</span><span class="s1">,</span>
        <span class="s3">PropertyExcludes </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">EnumMemberExcludes </span><span class="s2">= </span><span class="s6">900095</span><span class="s1">,</span>
        <span class="s3">FunctionExcludes </span><span class="s2">= </span><span class="s6">110991</span><span class="s1">,</span>
        <span class="s3">ClassExcludes </span><span class="s2">= </span><span class="s6">899503</span><span class="s1">,</span>
        <span class="s3">InterfaceExcludes </span><span class="s2">= </span><span class="s6">788872</span><span class="s1">,</span>
        <span class="s3">RegularEnumExcludes </span><span class="s2">= </span><span class="s6">899327</span><span class="s1">,</span>
        <span class="s3">ConstEnumExcludes </span><span class="s2">= </span><span class="s6">899967</span><span class="s1">,</span>
        <span class="s3">ValueModuleExcludes </span><span class="s2">= </span><span class="s6">110735</span><span class="s1">,</span>
        <span class="s3">NamespaceModuleExcludes </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">MethodExcludes </span><span class="s2">= </span><span class="s6">103359</span><span class="s1">,</span>
        <span class="s3">GetAccessorExcludes </span><span class="s2">= </span><span class="s6">46015</span><span class="s1">,</span>
        <span class="s3">SetAccessorExcludes </span><span class="s2">= </span><span class="s6">78783</span><span class="s1">,</span>
        <span class="s3">TypeParameterExcludes </span><span class="s2">= </span><span class="s6">526824</span><span class="s1">,</span>
        <span class="s3">TypeAliasExcludes </span><span class="s2">= </span><span class="s6">788968</span><span class="s1">,</span>
        <span class="s3">AliasExcludes </span><span class="s2">= </span><span class="s6">2097152</span><span class="s1">,</span>
        <span class="s3">ModuleMember </span><span class="s2">= </span><span class="s6">2623475</span><span class="s1">,</span>
        <span class="s3">ExportHasLocal </span><span class="s2">= </span><span class="s6">944</span><span class="s1">,</span>
        <span class="s3">BlockScoped </span><span class="s2">= </span><span class="s6">418</span><span class="s1">,</span>
        <span class="s3">PropertyOrAccessor </span><span class="s2">= </span><span class="s6">98308</span><span class="s1">,</span>
        <span class="s3">ClassMember </span><span class="s2">= </span><span class="s6">106500</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Symbol </span><span class="s1">{</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s3">SymbolFlags</span><span class="s1">;</span>
        <span class="s1">escapedName</span><span class="s2">: </span><span class="s3">__String</span><span class="s1">;</span>
        <span class="s1">declarations</span><span class="s2">?: </span><span class="s3">Declaration</span><span class="s1">[];</span>
        <span class="s1">valueDeclaration</span><span class="s2">?: </span><span class="s3">Declaration</span><span class="s1">;</span>
        <span class="s1">members</span><span class="s2">?: </span><span class="s3">SymbolTable</span><span class="s1">;</span>
        <span class="s1">exports</span><span class="s2">?: </span><span class="s3">SymbolTable</span><span class="s1">;</span>
        <span class="s1">globalExports</span><span class="s2">?: </span><span class="s3">SymbolTable</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">InternalSymbolName </span><span class="s1">{</span>
        <span class="s3">Call </span><span class="s2">= </span><span class="s4">&quot;__call&quot;</span><span class="s1">,</span>
        <span class="s3">Constructor </span><span class="s2">= </span><span class="s4">&quot;__constructor&quot;</span><span class="s1">,</span>
        <span class="s3">New </span><span class="s2">= </span><span class="s4">&quot;__new&quot;</span><span class="s1">,</span>
        <span class="s3">Index </span><span class="s2">= </span><span class="s4">&quot;__index&quot;</span><span class="s1">,</span>
        <span class="s3">ExportStar </span><span class="s2">= </span><span class="s4">&quot;__export&quot;</span><span class="s1">,</span>
        <span class="s3">Global </span><span class="s2">= </span><span class="s4">&quot;__global&quot;</span><span class="s1">,</span>
        <span class="s3">Missing </span><span class="s2">= </span><span class="s4">&quot;__missing&quot;</span><span class="s1">,</span>
        <span class="s3">Type </span><span class="s2">= </span><span class="s4">&quot;__type&quot;</span><span class="s1">,</span>
        <span class="s3">Object </span><span class="s2">= </span><span class="s4">&quot;__object&quot;</span><span class="s1">,</span>
        <span class="s3">JSXAttributes </span><span class="s2">= </span><span class="s4">&quot;__jsxAttributes&quot;</span><span class="s1">,</span>
        <span class="s3">Class </span><span class="s2">= </span><span class="s4">&quot;__class&quot;</span><span class="s1">,</span>
        <span class="s3">Function </span><span class="s2">= </span><span class="s4">&quot;__function&quot;</span><span class="s1">,</span>
        <span class="s3">Computed </span><span class="s2">= </span><span class="s4">&quot;__computed&quot;</span><span class="s1">,</span>
        <span class="s3">Resolving </span><span class="s2">= </span><span class="s4">&quot;__resolving__&quot;</span><span class="s1">,</span>
        <span class="s3">ExportEquals </span><span class="s2">= </span><span class="s4">&quot;export=&quot;</span><span class="s1">,</span>
        <span class="s3">Default </span><span class="s2">= </span><span class="s4">&quot;default&quot;</span><span class="s1">,</span>
        <span class="s3">This </span><span class="s2">= </span><span class="s4">&quot;this&quot;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This represents a string whose leading underscore have been escaped by adding extra leading underscores. 
     * The shape of this brand is rather unique compared to others we've used. 
     * Instead of just an intersection of a string and an object, it is that union-ed 
     * with an intersection of void and an object. This makes it wholly incompatible 
     * with a normal string (which is good, it cannot be misused on assignment or on usage), 
     * while still being comparable with a normal string via === (also good) and castable from a string. 
     */</span>
    <span class="s2">export type </span><span class="s3">__String </span><span class="s2">= </span><span class="s1">(</span><span class="s3">string </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">__escapedIdentifier</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}) </span><span class="s2">| </span><span class="s1">(</span><span class="s3">void </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">__escapedIdentifier</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}) </span><span class="s2">| </span><span class="s3">InternalSymbolName</span><span class="s1">;</span>
    <span class="s0">/** ReadonlyMap where keys are `__String`s. */</span>
    <span class="s2">export interface </span><span class="s3">ReadonlyUnderscoreEscapedMap</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyESMap</span><span class="s1">&lt;</span><span class="s3">__String</span><span class="s1">, </span><span class="s3">T</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s0">/** Map where keys are `__String`s. */</span>
    <span class="s2">export interface </span><span class="s3">UnderscoreEscapedMap</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ESMap</span><span class="s1">&lt;</span><span class="s3">__String</span><span class="s1">, </span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">ReadonlyUnderscoreEscapedMap</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s0">/** SymbolTable based on ES6 Map interface. */</span>
    <span class="s2">export type </span><span class="s3">SymbolTable </span><span class="s2">= </span><span class="s3">UnderscoreEscapedMap</span><span class="s1">&lt;</span><span class="s3">Symbol</span><span class="s1">&gt;;</span>
    <span class="s2">export enum </span><span class="s3">TypeFlags </span><span class="s1">{</span>
        <span class="s3">Any </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Unknown </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">String </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">Number </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Boolean </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">Enum </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">BigInt </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">StringLiteral </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">NumberLiteral </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">BooleanLiteral </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">EnumLiteral </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">BigIntLiteral </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">ESSymbol </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">UniqueESSymbol </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">Void </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">Undefined </span><span class="s2">= </span><span class="s6">32768</span><span class="s1">,</span>
        <span class="s3">Null </span><span class="s2">= </span><span class="s6">65536</span><span class="s1">,</span>
        <span class="s3">Never </span><span class="s2">= </span><span class="s6">131072</span><span class="s1">,</span>
        <span class="s3">TypeParameter </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">Object </span><span class="s2">= </span><span class="s6">524288</span><span class="s1">,</span>
        <span class="s3">Union </span><span class="s2">= </span><span class="s6">1048576</span><span class="s1">,</span>
        <span class="s3">Intersection </span><span class="s2">= </span><span class="s6">2097152</span><span class="s1">,</span>
        <span class="s3">Index </span><span class="s2">= </span><span class="s6">4194304</span><span class="s1">,</span>
        <span class="s3">IndexedAccess </span><span class="s2">= </span><span class="s6">8388608</span><span class="s1">,</span>
        <span class="s3">Conditional </span><span class="s2">= </span><span class="s6">16777216</span><span class="s1">,</span>
        <span class="s3">Substitution </span><span class="s2">= </span><span class="s6">33554432</span><span class="s1">,</span>
        <span class="s3">NonPrimitive </span><span class="s2">= </span><span class="s6">67108864</span><span class="s1">,</span>
        <span class="s3">TemplateLiteral </span><span class="s2">= </span><span class="s6">134217728</span><span class="s1">,</span>
        <span class="s3">StringMapping </span><span class="s2">= </span><span class="s6">268435456</span><span class="s1">,</span>
        <span class="s3">Literal </span><span class="s2">= </span><span class="s6">2944</span><span class="s1">,</span>
        <span class="s3">Unit </span><span class="s2">= </span><span class="s6">109440</span><span class="s1">,</span>
        <span class="s3">StringOrNumberLiteral </span><span class="s2">= </span><span class="s6">384</span><span class="s1">,</span>
        <span class="s3">PossiblyFalsy </span><span class="s2">= </span><span class="s6">117724</span><span class="s1">,</span>
        <span class="s3">StringLike </span><span class="s2">= </span><span class="s6">402653316</span><span class="s1">,</span>
        <span class="s3">NumberLike </span><span class="s2">= </span><span class="s6">296</span><span class="s1">,</span>
        <span class="s3">BigIntLike </span><span class="s2">= </span><span class="s6">2112</span><span class="s1">,</span>
        <span class="s3">BooleanLike </span><span class="s2">= </span><span class="s6">528</span><span class="s1">,</span>
        <span class="s3">EnumLike </span><span class="s2">= </span><span class="s6">1056</span><span class="s1">,</span>
        <span class="s3">ESSymbolLike </span><span class="s2">= </span><span class="s6">12288</span><span class="s1">,</span>
        <span class="s3">VoidLike </span><span class="s2">= </span><span class="s6">49152</span><span class="s1">,</span>
        <span class="s3">UnionOrIntersection </span><span class="s2">= </span><span class="s6">3145728</span><span class="s1">,</span>
        <span class="s3">StructuredType </span><span class="s2">= </span><span class="s6">3670016</span><span class="s1">,</span>
        <span class="s3">TypeVariable </span><span class="s2">= </span><span class="s6">8650752</span><span class="s1">,</span>
        <span class="s3">InstantiableNonPrimitive </span><span class="s2">= </span><span class="s6">58982400</span><span class="s1">,</span>
        <span class="s3">InstantiablePrimitive </span><span class="s2">= </span><span class="s6">406847488</span><span class="s1">,</span>
        <span class="s3">Instantiable </span><span class="s2">= </span><span class="s6">465829888</span><span class="s1">,</span>
        <span class="s3">StructuredOrInstantiable </span><span class="s2">= </span><span class="s6">469499904</span><span class="s1">,</span>
        <span class="s3">Narrowable </span><span class="s2">= </span><span class="s6">536624127</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">DestructuringPattern </span><span class="s2">= </span><span class="s3">BindingPattern </span><span class="s2">| </span><span class="s3">ObjectLiteralExpression </span><span class="s2">| </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">Type </span><span class="s1">{</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s3">TypeFlags</span><span class="s1">;</span>
        <span class="s1">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">;</span>
        <span class="s1">pattern</span><span class="s2">?: </span><span class="s3">DestructuringPattern</span><span class="s1">;</span>
        <span class="s1">aliasSymbol</span><span class="s2">?: </span><span class="s3">Symbol</span><span class="s1">;</span>
        <span class="s1">aliasTypeArguments</span><span class="s2">?: readonly </span><span class="s3">Type</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">LiteralType </span><span class="s2">extends </span><span class="s3">Type </span><span class="s1">{</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">number </span><span class="s2">| </span><span class="s3">PseudoBigInt</span><span class="s1">;</span>
        <span class="s1">freshType</span><span class="s2">: </span><span class="s3">LiteralType</span><span class="s1">;</span>
        <span class="s1">regularType</span><span class="s2">: </span><span class="s3">LiteralType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UniqueESSymbolType </span><span class="s2">extends </span><span class="s3">Type </span><span class="s1">{</span>
        <span class="s1">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">;</span>
        <span class="s1">escapedName</span><span class="s2">: </span><span class="s3">__String</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">StringLiteralType </span><span class="s2">extends </span><span class="s3">LiteralType </span><span class="s1">{</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NumberLiteralType </span><span class="s2">extends </span><span class="s3">LiteralType </span><span class="s1">{</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">BigIntLiteralType </span><span class="s2">extends </span><span class="s3">LiteralType </span><span class="s1">{</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s3">PseudoBigInt</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">EnumType </span><span class="s2">extends </span><span class="s3">Type </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ObjectFlags </span><span class="s1">{</span>
        <span class="s3">Class </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Interface </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">Reference </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">Tuple </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Anonymous </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">Mapped </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">Instantiated </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">ObjectLiteral </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">EvolvingArray </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">ObjectLiteralPatternWithComputedProperties </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">ReverseMapped </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">JsxAttributes </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">JSLiteral </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">FreshLiteral </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">ArrayLiteral </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">ClassOrInterface </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">ContainsSpread </span><span class="s2">= </span><span class="s6">2097152</span><span class="s1">,</span>
        <span class="s3">ObjectRestType </span><span class="s2">= </span><span class="s6">4194304</span><span class="s1">,</span>
        <span class="s3">InstantiationExpressionType </span><span class="s2">= </span><span class="s6">8388608</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ObjectType </span><span class="s2">extends </span><span class="s3">Type </span><span class="s1">{</span>
        <span class="s1">objectFlags</span><span class="s2">: </span><span class="s3">ObjectFlags</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */</span>
    <span class="s2">export interface </span><span class="s3">InterfaceType </span><span class="s2">extends </span><span class="s3">ObjectType </span><span class="s1">{</span>
        <span class="s1">typeParameters</span><span class="s2">: </span><span class="s3">TypeParameter</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">outerTypeParameters</span><span class="s2">: </span><span class="s3">TypeParameter</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">localTypeParameters</span><span class="s2">: </span><span class="s3">TypeParameter</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">thisType</span><span class="s2">: </span><span class="s3">TypeParameter </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">BaseType </span><span class="s2">= </span><span class="s3">ObjectType </span><span class="s2">| </span><span class="s3">IntersectionType </span><span class="s2">| </span><span class="s3">TypeVariable</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">InterfaceTypeWithDeclaredMembers </span><span class="s2">extends </span><span class="s3">InterfaceType </span><span class="s1">{</span>
        <span class="s1">declaredProperties</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">declaredCallSignatures</span><span class="s2">: </span><span class="s3">Signature</span><span class="s1">[];</span>
        <span class="s1">declaredConstructSignatures</span><span class="s2">: </span><span class="s3">Signature</span><span class="s1">[];</span>
        <span class="s1">declaredIndexInfos</span><span class="s2">: </span><span class="s3">IndexInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Type references (ObjectFlags.Reference). When a class or interface has type parameters or 
     * a &quot;this&quot; type, references to the class or interface are made using type references. The 
     * typeArguments property specifies the types to substitute for the type parameters of the 
     * class or interface and optionally includes an extra element that specifies the type to 
     * substitute for &quot;this&quot; in the resulting instantiation. When no extra argument is present, 
     * the type reference itself is substituted for &quot;this&quot;. The typeArguments property is undefined 
     * if the class or interface has no type parameters and the reference isn't specifying an 
     * explicit &quot;this&quot; argument. 
     */</span>
    <span class="s2">export interface </span><span class="s3">TypeReference </span><span class="s2">extends </span><span class="s3">ObjectType </span><span class="s1">{</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s3">GenericType</span><span class="s1">;</span>
        <span class="s1">node</span><span class="s2">?: </span><span class="s3">TypeReferenceNode </span><span class="s2">| </span><span class="s3">ArrayTypeNode </span><span class="s2">| </span><span class="s3">TupleTypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DeferredTypeReference </span><span class="s2">extends </span><span class="s3">TypeReference </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">GenericType </span><span class="s2">extends </span><span class="s3">InterfaceType</span><span class="s1">, </span><span class="s3">TypeReference </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ElementFlags </span><span class="s1">{</span>
        <span class="s3">Required </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Optional </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">Rest </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">Variadic </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Fixed </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">Variable </span><span class="s2">= </span><span class="s6">12</span><span class="s1">,</span>
        <span class="s3">NonRequired </span><span class="s2">= </span><span class="s6">14</span><span class="s1">,</span>
        <span class="s3">NonRest </span><span class="s2">= </span><span class="s6">11</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TupleType </span><span class="s2">extends </span><span class="s3">GenericType </span><span class="s1">{</span>
        <span class="s1">elementFlags</span><span class="s2">: readonly </span><span class="s3">ElementFlags</span><span class="s1">[];</span>
        <span class="s1">minLength</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">fixedLength</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">hasRestElement</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">combinedFlags</span><span class="s2">: </span><span class="s3">ElementFlags</span><span class="s1">;</span>
        <span class="s1">readonly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">labeledElementDeclarations</span><span class="s2">?: readonly </span><span class="s1">(</span><span class="s3">NamedTupleMember </span><span class="s2">| </span><span class="s3">ParameterDeclaration</span><span class="s1">)[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TupleTypeReference </span><span class="s2">extends </span><span class="s3">TypeReference </span><span class="s1">{</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s3">TupleType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnionOrIntersectionType </span><span class="s2">extends </span><span class="s3">Type </span><span class="s1">{</span>
        <span class="s1">types</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnionType </span><span class="s2">extends </span><span class="s3">UnionOrIntersectionType </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">IntersectionType </span><span class="s2">extends </span><span class="s3">UnionOrIntersectionType </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">StructuredType </span><span class="s2">= </span><span class="s3">ObjectType </span><span class="s2">| </span><span class="s3">UnionType </span><span class="s2">| </span><span class="s3">IntersectionType</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">EvolvingArrayType </span><span class="s2">extends </span><span class="s3">ObjectType </span><span class="s1">{</span>
        <span class="s1">elementType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">finalArrayType</span><span class="s2">?: </span><span class="s3">Type</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">InstantiableType </span><span class="s2">extends </span><span class="s3">Type </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeParameter </span><span class="s2">extends </span><span class="s3">InstantiableType </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">IndexedAccessType </span><span class="s2">extends </span><span class="s3">InstantiableType </span><span class="s1">{</span>
        <span class="s1">objectType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">indexType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">constraint</span><span class="s2">?: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">simplifiedForReading</span><span class="s2">?: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">simplifiedForWriting</span><span class="s2">?: </span><span class="s3">Type</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">TypeVariable </span><span class="s2">= </span><span class="s3">TypeParameter </span><span class="s2">| </span><span class="s3">IndexedAccessType</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">IndexType </span><span class="s2">extends </span><span class="s3">InstantiableType </span><span class="s1">{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">InstantiableType </span><span class="s2">| </span><span class="s3">UnionOrIntersectionType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ConditionalRoot </span><span class="s1">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s3">ConditionalTypeNode</span><span class="s1">;</span>
        <span class="s1">checkType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">extendsType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">isDistributive</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">inferTypeParameters</span><span class="s2">?: </span><span class="s3">TypeParameter</span><span class="s1">[];</span>
        <span class="s1">outerTypeParameters</span><span class="s2">?: </span><span class="s3">TypeParameter</span><span class="s1">[];</span>
        <span class="s1">instantiations</span><span class="s2">?: </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">Type</span><span class="s1">&gt;;</span>
        <span class="s1">aliasSymbol</span><span class="s2">?: </span><span class="s3">Symbol</span><span class="s1">;</span>
        <span class="s1">aliasTypeArguments</span><span class="s2">?: </span><span class="s3">Type</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ConditionalType </span><span class="s2">extends </span><span class="s3">InstantiableType </span><span class="s1">{</span>
        <span class="s1">root</span><span class="s2">: </span><span class="s3">ConditionalRoot</span><span class="s1">;</span>
        <span class="s1">checkType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">extendsType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">resolvedTrueType</span><span class="s2">?: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">resolvedFalseType</span><span class="s2">?: </span><span class="s3">Type</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TemplateLiteralType </span><span class="s2">extends </span><span class="s3">InstantiableType </span><span class="s1">{</span>
        <span class="s1">texts</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">types</span><span class="s2">: readonly </span><span class="s3">Type</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">StringMappingType </span><span class="s2">extends </span><span class="s3">InstantiableType </span><span class="s1">{</span>
        <span class="s1">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SubstitutionType </span><span class="s2">extends </span><span class="s3">InstantiableType </span><span class="s1">{</span>
        <span class="s1">objectFlags</span><span class="s2">: </span><span class="s3">ObjectFlags</span><span class="s1">;</span>
        <span class="s1">baseType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">substitute</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">SignatureKind </span><span class="s1">{</span>
        <span class="s3">Call </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Construct </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Signature </span><span class="s1">{</span>
        <span class="s1">declaration</span><span class="s2">?: </span><span class="s3">SignatureDeclaration </span><span class="s2">| </span><span class="s3">JSDocSignature</span><span class="s1">;</span>
        <span class="s1">typeParameters</span><span class="s2">?: readonly </span><span class="s3">TypeParameter</span><span class="s1">[];</span>
        <span class="s1">parameters</span><span class="s2">: readonly </span><span class="s3">Symbol</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">IndexKind </span><span class="s1">{</span>
        <span class="s3">String </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Number </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">IndexInfo </span><span class="s1">{</span>
        <span class="s1">keyType</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">isReadonly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">declaration</span><span class="s2">?: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">InferencePriority </span><span class="s1">{</span>
        <span class="s3">NakedTypeVariable </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">SpeculativeTuple </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">SubstituteSource </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">HomomorphicMappedType </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">PartialHomomorphicMappedType </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">MappedTypeConstraint </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">ContravariantConditional </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">ReturnType </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">LiteralKeyof </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">NoConstraints </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">AlwaysStrict </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">MaxValue </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">PriorityImpliesCombination </span><span class="s2">= </span><span class="s6">416</span><span class="s1">,</span>
        <span class="s3">Circularity </span><span class="s2">= -</span><span class="s6">1</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use FileExtensionInfo instead. */</span>
    <span class="s2">export type </span><span class="s3">JsFileExtensionInfo </span><span class="s2">= </span><span class="s3">FileExtensionInfo</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">FileExtensionInfo </span><span class="s1">{</span>
        <span class="s1">extension</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">isMixedContent</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DiagnosticMessage </span><span class="s1">{</span>
        <span class="s1">key</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s3">DiagnosticCategory</span><span class="s1">;</span>
        <span class="s1">code</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">reportsUnnecessary</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s1">reportsDeprecated</span><span class="s2">?: </span><span class="s1">{};</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A linked list of formatted diagnostic messages to be used as part of a multiline message. 
     * It is built from the bottom up, leaving the head to be the &quot;main&quot; diagnostic. 
     * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage, 
     * the difference is that messages are all preformatted in DMC. 
     */</span>
    <span class="s2">export interface </span><span class="s3">DiagnosticMessageChain </span><span class="s1">{</span>
        <span class="s1">messageText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s3">DiagnosticCategory</span><span class="s1">;</span>
        <span class="s1">code</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">next</span><span class="s2">?: </span><span class="s3">DiagnosticMessageChain</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">Diagnostic </span><span class="s2">extends </span><span class="s3">DiagnosticRelatedInformation </span><span class="s1">{</span>
        <span class="s0">/** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */</span>
        <span class="s1">reportsUnnecessary</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s1">reportsDeprecated</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">relatedInformation</span><span class="s2">?: </span><span class="s3">DiagnosticRelatedInformation</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DiagnosticRelatedInformation </span><span class="s1">{</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s3">DiagnosticCategory</span><span class="s1">;</span>
        <span class="s1">code</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">messageText</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">DiagnosticMessageChain</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">DiagnosticWithLocation </span><span class="s2">extends </span><span class="s3">Diagnostic </span><span class="s1">{</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">DiagnosticCategory </span><span class="s1">{</span>
        <span class="s3">Warning </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Error </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Suggestion </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">Message </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ModuleResolutionKind </span><span class="s1">{</span>
        <span class="s3">Classic </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">NodeJs </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">Node16 </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">NodeNext </span><span class="s2">= </span><span class="s6">99</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ModuleDetectionKind </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Files with imports, exports and/or import.meta are considered modules 
         */</span>
        <span class="s3">Legacy </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Legacy, but also files with jsx under react-jsx or react-jsxdev and esm mode files under moduleResolution: node16+ 
         */</span>
        <span class="s3">Auto </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Consider all non-declaration files modules, regardless of present syntax 
         */</span>
        <span class="s3">Force </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PluginImport </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ProjectReference </span><span class="s1">{</span>
        <span class="s0">/** A normalized path on disk */</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** The path as the user originally wrote it */</span>
        <span class="s1">originalPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations */</span>
        <span class="s1">prepend</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** True if it is intended that this reference form a circularity */</span>
        <span class="s1">circular</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">WatchFileKind </span><span class="s1">{</span>
        <span class="s3">FixedPollingInterval </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">PriorityPollingInterval </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">DynamicPriorityPolling </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">FixedChunkSizePolling </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">UseFsEvents </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">UseFsEventsOnParentDirectory </span><span class="s2">= </span><span class="s6">5</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">WatchDirectoryKind </span><span class="s1">{</span>
        <span class="s3">UseFsEvents </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">FixedPollingInterval </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">DynamicPriorityPolling </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">FixedChunkSizePolling </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">PollingWatchKind </span><span class="s1">{</span>
        <span class="s3">FixedInterval </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">PriorityInterval </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">DynamicPriority </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">FixedChunkSize </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">CompilerOptionsValue </span><span class="s2">= </span><span class="s3">string </span><span class="s2">| </span><span class="s3">number </span><span class="s2">| </span><span class="s3">boolean </span><span class="s2">| </span><span class="s1">(</span><span class="s3">string </span><span class="s2">| </span><span class="s3">number</span><span class="s1">)[] </span><span class="s2">| </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">MapLike</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">[]&gt; </span><span class="s2">| </span><span class="s3">PluginImport</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">ProjectReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">null </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">CompilerOptions </span><span class="s1">{</span>
        <span class="s1">allowJs</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">allowSyntheticDefaultImports</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">allowUmdGlobalAccess</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">allowUnreachableCode</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">allowUnusedLabels</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">alwaysStrict</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">baseUrl</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">charset</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">checkJs</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">declaration</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">declarationMap</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">emitDeclarationOnly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">declarationDir</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">disableSizeLimit</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">disableSourceOfProjectReferenceRedirect</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">disableSolutionSearching</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">disableReferencedProjectLoad</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">downlevelIteration</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">emitBOM</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">emitDecoratorMetadata</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">exactOptionalPropertyTypes</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">experimentalDecorators</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">forceConsistentCasingInFileNames</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">importHelpers</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">importsNotUsedAsValues</span><span class="s2">?: </span><span class="s3">ImportsNotUsedAsValues</span><span class="s1">;</span>
        <span class="s1">inlineSourceMap</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">inlineSources</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isolatedModules</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">jsx</span><span class="s2">?: </span><span class="s3">JsxEmit</span><span class="s1">;</span>
        <span class="s1">keyofStringsOnly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">lib</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">locale</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">mapRoot</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">maxNodeModuleJsDepth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">module</span><span class="s2">?: </span><span class="s3">ModuleKind</span><span class="s1">;</span>
        <span class="s1">moduleResolution</span><span class="s2">?: </span><span class="s3">ModuleResolutionKind</span><span class="s1">;</span>
        <span class="s1">moduleSuffixes</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">moduleDetection</span><span class="s2">?: </span><span class="s3">ModuleDetectionKind</span><span class="s1">;</span>
        <span class="s1">newLine</span><span class="s2">?: </span><span class="s3">NewLineKind</span><span class="s1">;</span>
        <span class="s1">noEmit</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noEmitHelpers</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noEmitOnError</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noErrorTruncation</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noFallthroughCasesInSwitch</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitAny</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitReturns</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitThis</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noStrictGenericChecks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noUnusedLocals</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noUnusedParameters</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitUseStrict</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noPropertyAccessFromIndexSignature</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">assumeChangesOnlyAffectDirectDependencies</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noLib</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noResolve</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noUncheckedIndexedAccess</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">out</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">outDir</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">outFile</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">paths</span><span class="s2">?: </span><span class="s3">MapLike</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">[]&gt;;</span>
        <span class="s1">preserveConstEnums</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitOverride</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">preserveSymlinks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">preserveValueImports</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">project</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">reactNamespace</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">jsxFactory</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">jsxFragmentFactory</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">jsxImportSource</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">composite</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">incremental</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">tsBuildInfoFile</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">removeComments</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">rootDir</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">rootDirs</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">skipLibCheck</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">skipDefaultLibCheck</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">sourceMap</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">sourceRoot</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">strict</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">strictFunctionTypes</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">strictBindCallApply</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">strictNullChecks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">strictPropertyInitialization</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">stripInternal</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">suppressExcessPropertyErrors</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">suppressImplicitAnyIndexErrors</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">target</span><span class="s2">?: </span><span class="s3">ScriptTarget</span><span class="s1">;</span>
        <span class="s1">traceResolution</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">useUnknownInCatchVariables</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">resolveJsonModule</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">types</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/** Paths used to compute primary types search locations */</span>
        <span class="s1">typeRoots</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">esModuleInterop</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">useDefineForClassFields</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">[</span><span class="s3">option</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s3">CompilerOptionsValue </span><span class="s2">| </span><span class="s3">TsConfigSourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">WatchOptions </span><span class="s1">{</span>
        <span class="s1">watchFile</span><span class="s2">?: </span><span class="s3">WatchFileKind</span><span class="s1">;</span>
        <span class="s1">watchDirectory</span><span class="s2">?: </span><span class="s3">WatchDirectoryKind</span><span class="s1">;</span>
        <span class="s1">fallbackPolling</span><span class="s2">?: </span><span class="s3">PollingWatchKind</span><span class="s1">;</span>
        <span class="s1">synchronousWatchDirectory</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">excludeDirectories</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">excludeFiles</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">[</span><span class="s3">option</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s3">CompilerOptionsValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypeAcquisition </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">typingOptions.enableAutoDiscovery 
         * Use typeAcquisition.enable instead. 
         */</span>
        <span class="s1">enableAutoDiscovery</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">enable</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">include</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">exclude</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">disableFilenameBasedTypeAcquisition</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">[</span><span class="s3">option</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s3">CompilerOptionsValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ModuleKind </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">CommonJS </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">AMD </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">UMD </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">System </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">ES2015 </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">ES2020 </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s3">ES2022 </span><span class="s2">= </span><span class="s6">7</span><span class="s1">,</span>
        <span class="s3">ESNext </span><span class="s2">= </span><span class="s6">99</span><span class="s1">,</span>
        <span class="s3">Node16 </span><span class="s2">= </span><span class="s6">100</span><span class="s1">,</span>
        <span class="s3">NodeNext </span><span class="s2">= </span><span class="s6">199</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">JsxEmit </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Preserve </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">React </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">ReactNative </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">ReactJSX </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">ReactJSXDev </span><span class="s2">= </span><span class="s6">5</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ImportsNotUsedAsValues </span><span class="s1">{</span>
        <span class="s3">Remove </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Preserve </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Error </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">NewLineKind </span><span class="s1">{</span>
        <span class="s3">CarriageReturnLineFeed </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">LineFeed </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">LineAndCharacter </span><span class="s1">{</span>
        <span class="s0">/** 0-based. */</span>
        <span class="s1">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">character</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ScriptKind </span><span class="s1">{</span>
        <span class="s3">Unknown </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">JS </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">JSX </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">TS </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">TSX </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">External </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">JSON </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Used on extensions that doesn't define the ScriptKind but the content defines it. 
         * Deferred extensions are going to be included in all project contexts. 
         */</span>
        <span class="s3">Deferred </span><span class="s2">= </span><span class="s6">7</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ScriptTarget </span><span class="s1">{</span>
        <span class="s3">ES3 </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">ES5 </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">ES2015 </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">ES2016 </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">ES2017 </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">ES2018 </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">ES2019 </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s3">ES2020 </span><span class="s2">= </span><span class="s6">7</span><span class="s1">,</span>
        <span class="s3">ES2021 </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">ES2022 </span><span class="s2">= </span><span class="s6">9</span><span class="s1">,</span>
        <span class="s3">ESNext </span><span class="s2">= </span><span class="s6">99</span><span class="s1">,</span>
        <span class="s3">JSON </span><span class="s2">= </span><span class="s6">100</span><span class="s1">,</span>
        <span class="s3">Latest </span><span class="s2">= </span><span class="s6">99</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">LanguageVariant </span><span class="s1">{</span>
        <span class="s3">Standard </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">JSX </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s1">}</span>
    <span class="s0">/** Either a parsed command line or a parsed tsconfig.json */</span>
    <span class="s2">export interface </span><span class="s3">ParsedCommandLine </span><span class="s1">{</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">typeAcquisition</span><span class="s2">?: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
        <span class="s1">fileNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[];</span>
        <span class="s1">watchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">;</span>
        <span class="s1">raw</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">wildcardDirectories</span><span class="s2">?: </span><span class="s3">MapLike</span><span class="s1">&lt;</span><span class="s3">WatchDirectoryFlags</span><span class="s1">&gt;;</span>
        <span class="s1">compileOnSave</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">WatchDirectoryFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Recursive </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CreateProgramOptions </span><span class="s1">{</span>
        <span class="s1">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[];</span>
        <span class="s1">host</span><span class="s2">?: </span><span class="s3">CompilerHost</span><span class="s1">;</span>
        <span class="s1">oldProgram</span><span class="s2">?: </span><span class="s3">Program</span><span class="s1">;</span>
        <span class="s1">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ModuleResolutionHost </span><span class="s1">{</span>
        <span class="s1">fileExists(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">readFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">trace</span><span class="s2">?</span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">directoryExists</span><span class="s2">?</span><span class="s1">(</span><span class="s3">directoryName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resolve a symbolic link. 
         * </span><span class="s2">@see </span><span class="s3">https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options</span>
         <span class="s0">*/</span>
        <span class="s1">realpath</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getDirectories</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s1">(() </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">) </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Used by services to specify the minimum host area required to set up source files under any compilation settings 
     */</span>
    <span class="s2">export interface </span><span class="s3">MinimalResolutionCacheHost </span><span class="s2">extends </span><span class="s3">ModuleResolutionHost </span><span class="s1">{</span>
        <span class="s1">getCompilationSettings()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">getCompilerHost</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">CompilerHost </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents the result of module resolution. 
     * Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off. 
     * The Program will then filter results based on these flags. 
     * 
     * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred. 
     */</span>
    <span class="s2">export interface </span><span class="s3">ResolvedModule </span><span class="s1">{</span>
        <span class="s0">/** Path of the file the module was resolved to. */</span>
        <span class="s1">resolvedFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** True if `resolvedFileName` comes from `node_modules`. */</span>
        <span class="s1">isExternalLibraryImport</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* ResolvedModule with an explicitly provided `extension` property. 
     * Prefer this over `ResolvedModule`. 
     * If changing this, remember to change `moduleResolutionIsEqualTo`. 
     */</span>
    <span class="s2">export interface </span><span class="s3">ResolvedModuleFull </span><span class="s2">extends </span><span class="s3">ResolvedModule </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Extension of resolvedFileName. This must match what's at the end of resolvedFileName. 
         * This is optional for backwards-compatibility, but will be added if not provided. 
         */</span>
        <span class="s1">extension</span><span class="s2">: </span><span class="s3">Extension</span><span class="s1">;</span>
        <span class="s1">packageId</span><span class="s2">?: </span><span class="s3">PackageId</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Unique identifier with a package name and version. 
     * If changing this, remember to change `packageIdIsEqual`. 
     */</span>
    <span class="s2">export interface </span><span class="s3">PackageId </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of the package. 
         * Should not include `@types`. 
         * If accessing a non-index file, this should include its name e.g. &quot;foo/bar&quot;. 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of a submodule within this package. 
         * May be &quot;&quot;. 
         */</span>
        <span class="s1">subModuleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** Version of the package, e.g. &quot;1.2.3&quot; */</span>
        <span class="s1">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">Extension </span><span class="s1">{</span>
        <span class="s3">Ts </span><span class="s2">= </span><span class="s4">&quot;.ts&quot;</span><span class="s1">,</span>
        <span class="s3">Tsx </span><span class="s2">= </span><span class="s4">&quot;.tsx&quot;</span><span class="s1">,</span>
        <span class="s3">Dts </span><span class="s2">= </span><span class="s4">&quot;.d.ts&quot;</span><span class="s1">,</span>
        <span class="s3">Js </span><span class="s2">= </span><span class="s4">&quot;.js&quot;</span><span class="s1">,</span>
        <span class="s3">Jsx </span><span class="s2">= </span><span class="s4">&quot;.jsx&quot;</span><span class="s1">,</span>
        <span class="s3">Json </span><span class="s2">= </span><span class="s4">&quot;.json&quot;</span><span class="s1">,</span>
        <span class="s3">TsBuildInfo </span><span class="s2">= </span><span class="s4">&quot;.tsbuildinfo&quot;</span><span class="s1">,</span>
        <span class="s3">Mjs </span><span class="s2">= </span><span class="s4">&quot;.mjs&quot;</span><span class="s1">,</span>
        <span class="s3">Mts </span><span class="s2">= </span><span class="s4">&quot;.mts&quot;</span><span class="s1">,</span>
        <span class="s3">Dmts </span><span class="s2">= </span><span class="s4">&quot;.d.mts&quot;</span><span class="s1">,</span>
        <span class="s3">Cjs </span><span class="s2">= </span><span class="s4">&quot;.cjs&quot;</span><span class="s1">,</span>
        <span class="s3">Cts </span><span class="s2">= </span><span class="s4">&quot;.cts&quot;</span><span class="s1">,</span>
        <span class="s3">Dcts </span><span class="s2">= </span><span class="s4">&quot;.d.cts&quot;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ResolvedModuleWithFailedLookupLocations </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">resolvedModule</span><span class="s2">: </span><span class="s3">ResolvedModuleFull </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ResolvedTypeReferenceDirective </span><span class="s1">{</span>
        <span class="s1">primary</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">resolvedFileName</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">packageId</span><span class="s2">?: </span><span class="s3">PackageId</span><span class="s1">;</span>
        <span class="s0">/** True if `resolvedFileName` comes from `node_modules`. */</span>
        <span class="s1">isExternalLibraryImport</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ResolvedTypeReferenceDirectiveWithFailedLookupLocations </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">resolvedTypeReferenceDirective</span><span class="s2">: </span><span class="s3">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">failedLookupLocations</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CompilerHost </span><span class="s2">extends </span><span class="s3">ModuleResolutionHost </span><span class="s1">{</span>
        <span class="s1">getSourceFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">languageVersionOrOptions</span><span class="s2">: </span><span class="s3">ScriptTarget </span><span class="s2">| </span><span class="s3">CreateSourceFileOptions</span><span class="s1">, </span><span class="s5">onError</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s3">shouldCreateNewSourceFile</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSourceFileByPath</span><span class="s2">?</span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">, </span><span class="s3">languageVersionOrOptions</span><span class="s2">: </span><span class="s3">ScriptTarget </span><span class="s2">| </span><span class="s3">CreateSourceFileOptions</span><span class="s1">, </span><span class="s5">onError</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s3">shouldCreateNewSourceFile</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getCancellationToken</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">CancellationToken</span><span class="s1">;</span>
        <span class="s1">getDefaultLibFileName(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getDefaultLibLocation</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">writeFile</span><span class="s2">: </span><span class="s3">WriteFileCallback</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getCanonicalFileName(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">useCaseSensitiveFileNames()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getNewLine()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">readDirectory</span><span class="s2">?</span><span class="s1">(</span><span class="s3">rootDir</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">extensions</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">excludes</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">includes</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">depth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">resolveModuleNames</span><span class="s2">?</span><span class="s1">(</span><span class="s3">moduleNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">reusedNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">: </span><span class="s3">ResolvedProjectReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">containingSourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ResolvedModule </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it 
         */</span>
        <span class="s1">getModuleResolutionCache</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">ModuleResolutionCache </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files 
         */</span>
        <span class="s1">resolveTypeReferenceDirectives</span><span class="s2">?</span><span class="s1">(</span><span class="s3">typeReferenceDirectiveNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| readonly </span><span class="s3">FileReference</span><span class="s1">[], </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">: </span><span class="s3">ResolvedProjectReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">containingFileMode</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
        <span class="s1">getEnvironmentVariable</span><span class="s2">?</span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">createHash</span><span class="s2">?</span><span class="s1">(</span><span class="s3">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getParsedCommandLine</span><span class="s2">?</span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParsedCommandLine </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SourceMapRange </span><span class="s2">extends </span><span class="s3">TextRange </span><span class="s1">{</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s3">SourceMapSource</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SourceMapSource </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">skipTrivia</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">EmitFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">SingleLine </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">AdviseOnEmitNode </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">NoSubstitution </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">CapturesThis </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">NoLeadingSourceMap </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">NoTrailingSourceMap </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">NoSourceMap </span><span class="s2">= </span><span class="s6">48</span><span class="s1">,</span>
        <span class="s3">NoNestedSourceMaps </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">NoTokenLeadingSourceMaps </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">NoTokenTrailingSourceMaps </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">NoTokenSourceMaps </span><span class="s2">= </span><span class="s6">384</span><span class="s1">,</span>
        <span class="s3">NoLeadingComments </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">NoTrailingComments </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">NoComments </span><span class="s2">= </span><span class="s6">1536</span><span class="s1">,</span>
        <span class="s3">NoNestedComments </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">HelperName </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">ExportName </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">LocalName </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">InternalName </span><span class="s2">= </span><span class="s6">32768</span><span class="s1">,</span>
        <span class="s3">Indented </span><span class="s2">= </span><span class="s6">65536</span><span class="s1">,</span>
        <span class="s3">NoIndentation </span><span class="s2">= </span><span class="s6">131072</span><span class="s1">,</span>
        <span class="s3">AsyncFunctionBody </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">ReuseTempVariableScope </span><span class="s2">= </span><span class="s6">524288</span><span class="s1">,</span>
        <span class="s3">CustomPrologue </span><span class="s2">= </span><span class="s6">1048576</span><span class="s1">,</span>
        <span class="s3">NoHoisting </span><span class="s2">= </span><span class="s6">2097152</span><span class="s1">,</span>
        <span class="s3">HasEndOfDeclarationMarker </span><span class="s2">= </span><span class="s6">4194304</span><span class="s1">,</span>
        <span class="s3">Iterator </span><span class="s2">= </span><span class="s6">8388608</span><span class="s1">,</span>
        <span class="s3">NoAsciiEscaping </span><span class="s2">= </span><span class="s6">16777216</span><span class="s1">,</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">EmitHelperBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">scoped</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s1">((</span><span class="s3">node</span><span class="s2">: </span><span class="s3">EmitHelperUniqueNameCallback</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string</span><span class="s1">);</span>
        <span class="s2">readonly </span><span class="s1">priority</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">dependencies</span><span class="s2">?: </span><span class="s3">EmitHelper</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ScopedEmitHelper </span><span class="s2">extends </span><span class="s3">EmitHelperBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">scoped</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UnscopedEmitHelper </span><span class="s2">extends </span><span class="s3">EmitHelperBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">scoped</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">EmitHelper </span><span class="s2">= </span><span class="s3">ScopedEmitHelper </span><span class="s2">| </span><span class="s3">UnscopedEmitHelper</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">EmitHelperUniqueNameCallback </span><span class="s2">= </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">export enum </span><span class="s3">EmitHint </span><span class="s1">{</span>
        <span class="s3">SourceFile </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Expression </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">IdentifierName </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">MappedTypeParameter </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">Unspecified </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">EmbeddedStatement </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">JsxAttributeValue </span><span class="s2">= </span><span class="s6">6</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">OuterExpressionKinds </span><span class="s1">{</span>
        <span class="s3">Parentheses </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">TypeAssertions </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">NonNullAssertions </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">PartiallyEmittedExpressions </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">Assertions </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s3">All </span><span class="s2">= </span><span class="s6">15</span><span class="s1">,</span>
        <span class="s3">ExcludeJSDocTypeAssertion </span><span class="s2">= </span><span class="s6">16</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">TypeOfTag </span><span class="s2">= </span><span class="s4">&quot;undefined&quot; </span><span class="s2">| </span><span class="s4">&quot;number&quot; </span><span class="s2">| </span><span class="s4">&quot;bigint&quot; </span><span class="s2">| </span><span class="s4">&quot;boolean&quot; </span><span class="s2">| </span><span class="s4">&quot;string&quot; </span><span class="s2">| </span><span class="s4">&quot;symbol&quot; </span><span class="s2">| </span><span class="s4">&quot;object&quot; </span><span class="s2">| </span><span class="s4">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">NodeFactory </span><span class="s1">{</span>
        <span class="s1">createNodeArray&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">elements</span><span class="s2">?: readonly </span><span class="s3">T</span><span class="s1">[], </span><span class="s3">hasTrailingComma</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
        <span class="s1">createNumericLiteral(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">number</span><span class="s1">, </span><span class="s3">numericLiteralFlags</span><span class="s2">?: </span><span class="s3">TokenFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NumericLiteral</span><span class="s1">;</span>
        <span class="s1">createBigIntLiteral(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PseudoBigInt</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BigIntLiteral</span><span class="s1">;</span>
        <span class="s1">createStringLiteral(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">isSingleQuote</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
        <span class="s1">createStringLiteralFromNode(</span><span class="s3">sourceNode</span><span class="s2">: </span><span class="s3">PropertyNameLiteral</span><span class="s1">, </span><span class="s3">isSingleQuote</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
        <span class="s1">createRegularExpressionLiteral(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">RegularExpressionLiteral</span><span class="s1">;</span>
        <span class="s1">createIdentifier(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Create a unique temporary variable. 
         * </span><span class="s2">@param </span><span class="s3">recordTempVariable </span><span class="s0">An optional callback used to record the temporary variable name. This 
         * should usually be a reference to `hoistVariableDeclaration` from a `TransformationContext`, but 
         * can be `undefined` if you plan to record the temporary variable manually. 
         * </span><span class="s2">@param </span><span class="s3">reservedInNestedScopes </span><span class="s0">When `true`, reserves the temporary variable name in all nested scopes 
         * during emit so that the variable can be referenced in a nested function body. This is an alternative to 
         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself. 
         */</span>
        <span class="s1">createTempVariable(</span><span class="s3">recordTempVariable</span><span class="s2">: </span><span class="s1">((</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">) </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">reservedInNestedScopes</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Create a unique temporary variable for use in a loop. 
         * </span><span class="s2">@param </span><span class="s3">reservedInNestedScopes </span><span class="s0">When `true`, reserves the temporary variable name in all nested scopes 
         * during emit so that the variable can be referenced in a nested function body. This is an alternative to 
         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself. 
         */</span>
        <span class="s1">createLoopVariable(</span><span class="s3">reservedInNestedScopes</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s0">/** Create a unique name based on the supplied text. */</span>
        <span class="s1">createUniqueName(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">GeneratedIdentifierFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s0">/** Create a unique name generated for a node. */</span>
        <span class="s1">getGeneratedNameForNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">GeneratedIdentifierFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
        <span class="s1">createPrivateIdentifier(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
        <span class="s1">createToken(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SuperKeyword</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SuperExpression</span><span class="s1">;</span>
        <span class="s1">createToken(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ThisKeyword</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ThisExpression</span><span class="s1">;</span>
        <span class="s1">createToken(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NullKeyword</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NullLiteral</span><span class="s1">;</span>
        <span class="s1">createToken(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TrueKeyword</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TrueLiteral</span><span class="s1">;</span>
        <span class="s1">createToken(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">FalseKeyword</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FalseLiteral</span><span class="s1">;</span>
        <span class="s1">createToken&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">PunctuationSyntaxKind</span><span class="s1">&gt;(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PunctuationToken</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;;</span>
        <span class="s1">createToken&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">KeywordTypeSyntaxKind</span><span class="s1">&gt;(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">KeywordTypeNode</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;;</span>
        <span class="s1">createToken&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">ModifierSyntaxKind</span><span class="s1">&gt;(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;;</span>
        <span class="s1">createToken&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">KeywordSyntaxKind</span><span class="s1">&gt;(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">KeywordToken</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;;</span>
        <span class="s1">createToken&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">Unknown </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EndOfFileToken</span><span class="s1">&gt;(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;;</span>
        <span class="s1">createSuper()</span><span class="s2">: </span><span class="s3">SuperExpression</span><span class="s1">;</span>
        <span class="s1">createThis()</span><span class="s2">: </span><span class="s3">ThisExpression</span><span class="s1">;</span>
        <span class="s1">createNull()</span><span class="s2">: </span><span class="s3">NullLiteral</span><span class="s1">;</span>
        <span class="s1">createTrue()</span><span class="s2">: </span><span class="s3">TrueLiteral</span><span class="s1">;</span>
        <span class="s1">createFalse()</span><span class="s2">: </span><span class="s3">FalseLiteral</span><span class="s1">;</span>
        <span class="s1">createModifier&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">ModifierSyntaxKind</span><span class="s1">&gt;(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
        <span class="s1">createModifiersFromModifierFlags(</span><span class="s3">flags</span><span class="s2">: </span><span class="s3">ModifierFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">createQualifiedName(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">QualifiedName</span><span class="s1">;</span>
        <span class="s1">updateQualifiedName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">QualifiedName</span><span class="s1">, </span><span class="s3">left</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">QualifiedName</span><span class="s1">;</span>
        <span class="s1">createComputedPropertyName(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ComputedPropertyName</span><span class="s1">;</span>
        <span class="s1">updateComputedPropertyName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ComputedPropertyName</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ComputedPropertyName</span><span class="s1">;</span>
        <span class="s1">createTypeParameterDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">defaultType</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
        <span class="s1">updateTypeParameterDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">defaultType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
        <span class="s1">createParameterDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken</span><span class="s1">, </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
        <span class="s1">updateParameterDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
        <span class="s1">createDecorator(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Decorator</span><span class="s1">;</span>
        <span class="s1">updateDecorator(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Decorator</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Decorator</span><span class="s1">;</span>
        <span class="s1">createPropertySignature(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName </span><span class="s2">| </span><span class="s3">string</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertySignature</span><span class="s1">;</span>
        <span class="s1">updatePropertySignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertySignature</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertySignature</span><span class="s1">;</span>
        <span class="s1">createPropertyDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionOrExclamationToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
        <span class="s1">updatePropertyDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionOrExclamationToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
        <span class="s1">createMethodSignature(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodSignature</span><span class="s1">;</span>
        <span class="s1">updateMethodSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MethodSignature</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodSignature</span><span class="s1">;</span>
        <span class="s1">createMethodDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
        <span class="s1">updateMethodDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
        <span class="s1">createConstructorDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
        <span class="s1">updateConstructorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
        <span class="s1">createGetAccessorDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s1">updateGetAccessorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s1">createSetAccessorDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s1">updateSetAccessorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s1">createCallSignature(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallSignatureDeclaration</span><span class="s1">;</span>
        <span class="s1">updateCallSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CallSignatureDeclaration</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallSignatureDeclaration</span><span class="s1">;</span>
        <span class="s1">createConstructSignature(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructSignatureDeclaration</span><span class="s1">;</span>
        <span class="s1">updateConstructSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructSignatureDeclaration</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructSignatureDeclaration</span><span class="s1">;</span>
        <span class="s1">createIndexSignature(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
        <span class="s1">updateIndexSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
        <span class="s1">createTemplateLiteralTypeSpan(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">literal</span><span class="s2">: </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">;</span>
        <span class="s1">updateTemplateLiteralTypeSpan(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">literal</span><span class="s2">: </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">;</span>
        <span class="s1">createClassStaticBlockDeclaration(</span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassStaticBlockDeclaration</span><span class="s1">;</span>
        <span class="s1">updateClassStaticBlockDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassStaticBlockDeclaration</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassStaticBlockDeclaration</span><span class="s1">;</span>
        <span class="s1">createKeywordTypeNode&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">KeywordTypeSyntaxKind</span><span class="s1">&gt;(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">KeywordTypeNode</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;;</span>
        <span class="s1">createTypePredicateNode(</span><span class="s3">assertsModifier</span><span class="s2">: </span><span class="s3">AssertsKeyword </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameterName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisTypeNode </span><span class="s2">| </span><span class="s3">string</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypePredicateNode</span><span class="s1">;</span>
        <span class="s1">updateTypePredicateNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypePredicateNode</span><span class="s1">, </span><span class="s3">assertsModifier</span><span class="s2">: </span><span class="s3">AssertsKeyword </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameterName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypePredicateNode</span><span class="s1">;</span>
        <span class="s1">createTypeReferenceNode(</span><span class="s3">typeName</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TypeReferenceNode</span><span class="s1">;</span>
        <span class="s1">updateTypeReferenceNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeReferenceNode</span><span class="s1">, </span><span class="s3">typeName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeReferenceNode</span><span class="s1">;</span>
        <span class="s1">createFunctionTypeNode(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionTypeNode</span><span class="s1">;</span>
        <span class="s1">updateFunctionTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionTypeNode</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionTypeNode</span><span class="s1">;</span>
        <span class="s1">createConstructorTypeNode(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
        <span class="s1">updateConstructorTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructorTypeNode</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
        <span class="s1">createTypeQueryNode(</span><span class="s3">exprName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TypeQueryNode</span><span class="s1">;</span>
        <span class="s1">updateTypeQueryNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeQueryNode</span><span class="s1">, </span><span class="s3">exprName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TypeQueryNode</span><span class="s1">;</span>
        <span class="s1">createTypeLiteralNode(</span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeLiteralNode</span><span class="s1">;</span>
        <span class="s1">updateTypeLiteralNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeLiteralNode</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">TypeLiteralNode</span><span class="s1">;</span>
        <span class="s1">createArrayTypeNode(</span><span class="s3">elementType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrayTypeNode</span><span class="s1">;</span>
        <span class="s1">updateArrayTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrayTypeNode</span><span class="s1">, </span><span class="s3">elementType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrayTypeNode</span><span class="s1">;</span>
        <span class="s1">createTupleTypeNode(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s1">(</span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">NamedTupleMember</span><span class="s1">)[])</span><span class="s2">: </span><span class="s3">TupleTypeNode</span><span class="s1">;</span>
        <span class="s1">updateTupleTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TupleTypeNode</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s1">(</span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">NamedTupleMember</span><span class="s1">)[])</span><span class="s2">: </span><span class="s3">TupleTypeNode</span><span class="s1">;</span>
        <span class="s1">createNamedTupleMember(</span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NamedTupleMember</span><span class="s1">;</span>
        <span class="s1">updateNamedTupleMember(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamedTupleMember</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NamedTupleMember</span><span class="s1">;</span>
        <span class="s1">createOptionalTypeNode(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">OptionalTypeNode</span><span class="s1">;</span>
        <span class="s1">updateOptionalTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">OptionalTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">OptionalTypeNode</span><span class="s1">;</span>
        <span class="s1">createRestTypeNode(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">RestTypeNode</span><span class="s1">;</span>
        <span class="s1">updateRestTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">RestTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">RestTypeNode</span><span class="s1">;</span>
        <span class="s1">createUnionTypeNode(</span><span class="s3">types</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">UnionTypeNode</span><span class="s1">;</span>
        <span class="s1">updateUnionTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">UnionTypeNode</span><span class="s1">, </span><span class="s3">types</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">UnionTypeNode</span><span class="s1">;</span>
        <span class="s1">createIntersectionTypeNode(</span><span class="s3">types</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">IntersectionTypeNode</span><span class="s1">;</span>
        <span class="s1">updateIntersectionTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IntersectionTypeNode</span><span class="s1">, </span><span class="s3">types</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">IntersectionTypeNode</span><span class="s1">;</span>
        <span class="s1">createConditionalTypeNode(</span><span class="s3">checkType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">extendsType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">trueType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">falseType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConditionalTypeNode</span><span class="s1">;</span>
        <span class="s1">updateConditionalTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConditionalTypeNode</span><span class="s1">, </span><span class="s3">checkType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">extendsType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">trueType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">falseType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConditionalTypeNode</span><span class="s1">;</span>
        <span class="s1">createInferTypeNode(</span><span class="s3">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">InferTypeNode</span><span class="s1">;</span>
        <span class="s1">updateInferTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">InferTypeNode</span><span class="s1">, </span><span class="s3">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">InferTypeNode</span><span class="s1">;</span>
        <span class="s1">createImportTypeNode(</span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">assertions</span><span class="s2">?: </span><span class="s3">ImportTypeAssertionContainer</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">?: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[], </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
        <span class="s1">updateImportTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">, </span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">assertions</span><span class="s2">: </span><span class="s3">ImportTypeAssertionContainer </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
        <span class="s1">createParenthesizedType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParenthesizedTypeNode</span><span class="s1">;</span>
        <span class="s1">updateParenthesizedType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParenthesizedTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParenthesizedTypeNode</span><span class="s1">;</span>
        <span class="s1">createThisTypeNode()</span><span class="s2">: </span><span class="s3">ThisTypeNode</span><span class="s1">;</span>
        <span class="s1">createTypeOperatorNode(</span><span class="s3">operator</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">KeyOfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UniqueKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ReadonlyKeyword</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeOperatorNode</span><span class="s1">;</span>
        <span class="s1">updateTypeOperatorNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeOperatorNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeOperatorNode</span><span class="s1">;</span>
        <span class="s1">createIndexedAccessTypeNode(</span><span class="s3">objectType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">indexType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexedAccessTypeNode</span><span class="s1">;</span>
        <span class="s1">updateIndexedAccessTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IndexedAccessTypeNode</span><span class="s1">, </span><span class="s3">objectType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">indexType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexedAccessTypeNode</span><span class="s1">;</span>
        <span class="s1">createMappedTypeNode(</span><span class="s3">readonlyToken</span><span class="s2">: </span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">, </span><span class="s3">nameType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MappedTypeNode</span><span class="s1">;</span>
        <span class="s1">updateMappedTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MappedTypeNode</span><span class="s1">, </span><span class="s3">readonlyToken</span><span class="s2">: </span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">, </span><span class="s3">nameType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MappedTypeNode</span><span class="s1">;</span>
        <span class="s1">createLiteralTypeNode(</span><span class="s3">literal</span><span class="s2">: </span><span class="s3">LiteralTypeNode</span><span class="s1">[</span><span class="s4">&quot;literal&quot;</span><span class="s1">])</span><span class="s2">: </span><span class="s3">LiteralTypeNode</span><span class="s1">;</span>
        <span class="s1">updateLiteralTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">LiteralTypeNode</span><span class="s1">, </span><span class="s3">literal</span><span class="s2">: </span><span class="s3">LiteralTypeNode</span><span class="s1">[</span><span class="s4">&quot;literal&quot;</span><span class="s1">])</span><span class="s2">: </span><span class="s3">LiteralTypeNode</span><span class="s1">;</span>
        <span class="s1">createTemplateLiteralType(</span><span class="s3">head</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">, </span><span class="s3">templateSpans</span><span class="s2">: readonly </span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TemplateLiteralTypeNode</span><span class="s1">;</span>
        <span class="s1">updateTemplateLiteralType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TemplateLiteralTypeNode</span><span class="s1">, </span><span class="s3">head</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">, </span><span class="s3">templateSpans</span><span class="s2">: readonly </span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TemplateLiteralTypeNode</span><span class="s1">;</span>
        <span class="s1">createObjectBindingPattern(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">BindingElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ObjectBindingPattern</span><span class="s1">;</span>
        <span class="s1">updateObjectBindingPattern(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ObjectBindingPattern</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">BindingElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ObjectBindingPattern</span><span class="s1">;</span>
        <span class="s1">createArrayBindingPattern(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ArrayBindingElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ArrayBindingPattern</span><span class="s1">;</span>
        <span class="s1">updateArrayBindingPattern(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrayBindingPattern</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ArrayBindingElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ArrayBindingPattern</span><span class="s1">;</span>
        <span class="s1">createBindingElement(</span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BindingElement</span><span class="s1">;</span>
        <span class="s1">updateBindingElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">BindingElement</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">PropertyName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BindingElement</span><span class="s1">;</span>
        <span class="s1">createArrayLiteralExpression(</span><span class="s3">elements</span><span class="s2">?: readonly </span><span class="s3">Expression</span><span class="s1">[], </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
        <span class="s1">updateArrayLiteralExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrayLiteralExpression</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
        <span class="s1">createObjectLiteralExpression(</span><span class="s3">properties</span><span class="s2">?: readonly </span><span class="s3">ObjectLiteralElementLike</span><span class="s1">[], </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
        <span class="s1">updateObjectLiteralExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression</span><span class="s1">, </span><span class="s3">properties</span><span class="s2">: readonly </span><span class="s3">ObjectLiteralElementLike</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
        <span class="s1">createPropertyAccessExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">MemberName</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyAccessExpression</span><span class="s1">;</span>
        <span class="s1">updatePropertyAccessExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyAccessExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">MemberName</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyAccessExpression</span><span class="s1">;</span>
        <span class="s1">createPropertyAccessChain(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">MemberName</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyAccessChain</span><span class="s1">;</span>
        <span class="s1">updatePropertyAccessChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyAccessChain</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">MemberName</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyAccessChain</span><span class="s1">;</span>
        <span class="s1">createElementAccessExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">index</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ElementAccessExpression</span><span class="s1">;</span>
        <span class="s1">updateElementAccessExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ElementAccessExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">argumentExpression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ElementAccessExpression</span><span class="s1">;</span>
        <span class="s1">createElementAccessChain(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">index</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ElementAccessChain</span><span class="s1">;</span>
        <span class="s1">updateElementAccessChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ElementAccessChain</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentExpression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ElementAccessChain</span><span class="s1">;</span>
        <span class="s1">createCallExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">updateCallExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">createCallChain(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallChain</span><span class="s1">;</span>
        <span class="s1">updateCallChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CallChain</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CallChain</span><span class="s1">;</span>
        <span class="s1">createNewExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NewExpression</span><span class="s1">;</span>
        <span class="s1">updateNewExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NewExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NewExpression</span><span class="s1">;</span>
        <span class="s1">createTaggedTemplateExpression(</span><span class="s3">tag</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">template</span><span class="s2">: </span><span class="s3">TemplateLiteral</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
        <span class="s1">updateTaggedTemplateExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">, </span><span class="s3">tag</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">template</span><span class="s2">: </span><span class="s3">TemplateLiteral</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
        <span class="s1">createTypeAssertion(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAssertion</span><span class="s1">;</span>
        <span class="s1">updateTypeAssertion(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeAssertion</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAssertion</span><span class="s1">;</span>
        <span class="s1">createParenthesizedExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParenthesizedExpression</span><span class="s1">;</span>
        <span class="s1">updateParenthesizedExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParenthesizedExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParenthesizedExpression</span><span class="s1">;</span>
        <span class="s1">createFunctionExpression(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionExpression</span><span class="s1">;</span>
        <span class="s1">updateFunctionExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionExpression</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionExpression</span><span class="s1">;</span>
        <span class="s1">createArrowFunction(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">equalsGreaterThanToken</span><span class="s2">: </span><span class="s3">EqualsGreaterThanToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
        <span class="s1">updateArrowFunction(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">equalsGreaterThanToken</span><span class="s2">: </span><span class="s3">EqualsGreaterThanToken</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
        <span class="s1">createDeleteExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DeleteExpression</span><span class="s1">;</span>
        <span class="s1">updateDeleteExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">DeleteExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DeleteExpression</span><span class="s1">;</span>
        <span class="s1">createTypeOfExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeOfExpression</span><span class="s1">;</span>
        <span class="s1">updateTypeOfExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeOfExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeOfExpression</span><span class="s1">;</span>
        <span class="s1">createVoidExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VoidExpression</span><span class="s1">;</span>
        <span class="s1">updateVoidExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VoidExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VoidExpression</span><span class="s1">;</span>
        <span class="s1">createAwaitExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AwaitExpression</span><span class="s1">;</span>
        <span class="s1">updateAwaitExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">AwaitExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AwaitExpression</span><span class="s1">;</span>
        <span class="s1">createPrefixUnaryExpression(</span><span class="s3">operator</span><span class="s2">: </span><span class="s3">PrefixUnaryOperator</span><span class="s1">, </span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">updatePrefixUnaryExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">, </span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createPostfixUnaryExpression(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">operator</span><span class="s2">: </span><span class="s3">PostfixUnaryOperator</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">updatePostfixUnaryExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PostfixUnaryExpression</span><span class="s1">, </span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createBinaryExpression(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">operator</span><span class="s2">: </span><span class="s3">BinaryOperator </span><span class="s2">| </span><span class="s3">BinaryOperatorToken</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">updateBinaryExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">, </span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">operator</span><span class="s2">: </span><span class="s3">BinaryOperator </span><span class="s2">| </span><span class="s3">BinaryOperatorToken</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createConditionalExpression(</span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">whenTrue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">colonToken</span><span class="s2">: </span><span class="s3">ColonToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">whenFalse</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConditionalExpression</span><span class="s1">;</span>
        <span class="s1">updateConditionalExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConditionalExpression</span><span class="s1">, </span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken</span><span class="s1">, </span><span class="s3">whenTrue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">colonToken</span><span class="s2">: </span><span class="s3">ColonToken</span><span class="s1">, </span><span class="s3">whenFalse</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConditionalExpression</span><span class="s1">;</span>
        <span class="s1">createTemplateExpression(</span><span class="s3">head</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">, </span><span class="s3">templateSpans</span><span class="s2">: readonly </span><span class="s3">TemplateSpan</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TemplateExpression</span><span class="s1">;</span>
        <span class="s1">updateTemplateExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TemplateExpression</span><span class="s1">, </span><span class="s3">head</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">, </span><span class="s3">templateSpans</span><span class="s2">: readonly </span><span class="s3">TemplateSpan</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TemplateExpression</span><span class="s1">;</span>
        <span class="s1">createTemplateHead(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">;</span>
        <span class="s1">createTemplateHead(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">;</span>
        <span class="s1">createTemplateMiddle(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateMiddle</span><span class="s1">;</span>
        <span class="s1">createTemplateMiddle(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateMiddle</span><span class="s1">;</span>
        <span class="s1">createTemplateTail(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateTail</span><span class="s1">;</span>
        <span class="s1">createTemplateTail(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateTail</span><span class="s1">;</span>
        <span class="s1">createNoSubstitutionTemplateLiteral(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
        <span class="s1">createNoSubstitutionTemplateLiteral(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
        <span class="s1">createYieldExpression(</span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">YieldExpression</span><span class="s1">;</span>
        <span class="s1">createYieldExpression(</span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">YieldExpression</span><span class="s1">;</span>
        <span class="s1">updateYieldExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">YieldExpression</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">YieldExpression</span><span class="s1">;</span>
        <span class="s1">createSpreadElement(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SpreadElement</span><span class="s1">;</span>
        <span class="s1">updateSpreadElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SpreadElement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SpreadElement</span><span class="s1">;</span>
        <span class="s1">createClassExpression(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassExpression</span><span class="s1">;</span>
        <span class="s1">updateClassExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassExpression</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassExpression</span><span class="s1">;</span>
        <span class="s1">createOmittedExpression()</span><span class="s2">: </span><span class="s3">OmittedExpression</span><span class="s1">;</span>
        <span class="s1">createExpressionWithTypeArguments(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">;</span>
        <span class="s1">updateExpressionWithTypeArguments(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">;</span>
        <span class="s1">createAsExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AsExpression</span><span class="s1">;</span>
        <span class="s1">updateAsExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">AsExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AsExpression</span><span class="s1">;</span>
        <span class="s1">createNonNullExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NonNullExpression</span><span class="s1">;</span>
        <span class="s1">updateNonNullExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NonNullExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NonNullExpression</span><span class="s1">;</span>
        <span class="s1">createNonNullChain(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NonNullChain</span><span class="s1">;</span>
        <span class="s1">updateNonNullChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NonNullChain</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NonNullChain</span><span class="s1">;</span>
        <span class="s1">createMetaProperty(</span><span class="s3">keywordToken</span><span class="s2">: </span><span class="s3">MetaProperty</span><span class="s1">[</span><span class="s4">&quot;keywordToken&quot;</span><span class="s1">], </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MetaProperty</span><span class="s1">;</span>
        <span class="s1">updateMetaProperty(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MetaProperty</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MetaProperty</span><span class="s1">;</span>
        <span class="s1">createTemplateSpan(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">literal</span><span class="s2">: </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateSpan</span><span class="s1">;</span>
        <span class="s1">updateTemplateSpan(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TemplateSpan</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">literal</span><span class="s2">: </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateSpan</span><span class="s1">;</span>
        <span class="s1">createSemicolonClassElement()</span><span class="s2">: </span><span class="s3">SemicolonClassElement</span><span class="s1">;</span>
        <span class="s1">createBlock(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">;</span>
        <span class="s1">updateBlock(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">;</span>
        <span class="s1">createVariableStatement(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">declarationList</span><span class="s2">: </span><span class="s3">VariableDeclarationList </span><span class="s2">| readonly </span><span class="s3">VariableDeclaration</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">VariableStatement</span><span class="s1">;</span>
        <span class="s1">updateVariableStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VariableStatement</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">declarationList</span><span class="s2">: </span><span class="s3">VariableDeclarationList</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableStatement</span><span class="s1">;</span>
        <span class="s1">createEmptyStatement()</span><span class="s2">: </span><span class="s3">EmptyStatement</span><span class="s1">;</span>
        <span class="s1">createExpressionStatement(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
        <span class="s1">updateExpressionStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExpressionStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
        <span class="s1">createIfStatement(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">thenStatement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">elseStatement</span><span class="s2">?: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IfStatement</span><span class="s1">;</span>
        <span class="s1">updateIfStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IfStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">thenStatement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">elseStatement</span><span class="s2">: </span><span class="s3">Statement </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IfStatement</span><span class="s1">;</span>
        <span class="s1">createDoStatement(</span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DoStatement</span><span class="s1">;</span>
        <span class="s1">updateDoStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">DoStatement</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DoStatement</span><span class="s1">;</span>
        <span class="s1">createWhileStatement(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">WhileStatement</span><span class="s1">;</span>
        <span class="s1">updateWhileStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">WhileStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">WhileStatement</span><span class="s1">;</span>
        <span class="s1">createForStatement(</span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">incrementor</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ForStatement</span><span class="s1">;</span>
        <span class="s1">updateForStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ForStatement</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">incrementor</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ForStatement</span><span class="s1">;</span>
        <span class="s1">createForInStatement(</span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ForInStatement</span><span class="s1">;</span>
        <span class="s1">updateForInStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ForInStatement</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ForInStatement</span><span class="s1">;</span>
        <span class="s1">createForOfStatement(</span><span class="s3">awaitModifier</span><span class="s2">: </span><span class="s3">AwaitKeyword </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ForOfStatement</span><span class="s1">;</span>
        <span class="s1">updateForOfStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ForOfStatement</span><span class="s1">, </span><span class="s3">awaitModifier</span><span class="s2">: </span><span class="s3">AwaitKeyword </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ForOfStatement</span><span class="s1">;</span>
        <span class="s1">createContinueStatement(</span><span class="s3">label</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ContinueStatement</span><span class="s1">;</span>
        <span class="s1">updateContinueStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ContinueStatement</span><span class="s1">, </span><span class="s3">label</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ContinueStatement</span><span class="s1">;</span>
        <span class="s1">createBreakStatement(</span><span class="s3">label</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BreakStatement</span><span class="s1">;</span>
        <span class="s1">updateBreakStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">BreakStatement</span><span class="s1">, </span><span class="s3">label</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BreakStatement</span><span class="s1">;</span>
        <span class="s1">createReturnStatement(</span><span class="s3">expression</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ReturnStatement</span><span class="s1">;</span>
        <span class="s1">updateReturnStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ReturnStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ReturnStatement</span><span class="s1">;</span>
        <span class="s1">createWithStatement(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">WithStatement</span><span class="s1">;</span>
        <span class="s1">updateWithStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">WithStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">WithStatement</span><span class="s1">;</span>
        <span class="s1">createSwitchStatement(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">caseBlock</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SwitchStatement</span><span class="s1">;</span>
        <span class="s1">updateSwitchStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SwitchStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">caseBlock</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SwitchStatement</span><span class="s1">;</span>
        <span class="s1">createLabeledStatement(</span><span class="s3">label</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LabeledStatement</span><span class="s1">;</span>
        <span class="s1">updateLabeledStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">LabeledStatement</span><span class="s1">, </span><span class="s3">label</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LabeledStatement</span><span class="s1">;</span>
        <span class="s1">createThrowStatement(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ThrowStatement</span><span class="s1">;</span>
        <span class="s1">updateThrowStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ThrowStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ThrowStatement</span><span class="s1">;</span>
        <span class="s1">createTryStatement(</span><span class="s3">tryBlock</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">, </span><span class="s3">catchClause</span><span class="s2">: </span><span class="s3">CatchClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">finallyBlock</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TryStatement</span><span class="s1">;</span>
        <span class="s1">updateTryStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TryStatement</span><span class="s1">, </span><span class="s3">tryBlock</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">, </span><span class="s3">catchClause</span><span class="s2">: </span><span class="s3">CatchClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">finallyBlock</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TryStatement</span><span class="s1">;</span>
        <span class="s1">createDebuggerStatement()</span><span class="s2">: </span><span class="s3">DebuggerStatement</span><span class="s1">;</span>
        <span class="s1">createVariableDeclaration(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">exclamationToken</span><span class="s2">?: </span><span class="s3">ExclamationToken</span><span class="s1">, </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
        <span class="s1">updateVariableDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">exclamationToken</span><span class="s2">: </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
        <span class="s1">createVariableDeclarationList(</span><span class="s3">declarations</span><span class="s2">: readonly </span><span class="s3">VariableDeclaration</span><span class="s1">[], </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">NodeFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableDeclarationList</span><span class="s1">;</span>
        <span class="s1">updateVariableDeclarationList(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VariableDeclarationList</span><span class="s1">, </span><span class="s3">declarations</span><span class="s2">: readonly </span><span class="s3">VariableDeclaration</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">VariableDeclarationList</span><span class="s1">;</span>
        <span class="s1">createFunctionDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
        <span class="s1">updateFunctionDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
        <span class="s1">createClassDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
        <span class="s1">updateClassDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
        <span class="s1">createInterfaceDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s1">updateInterfaceDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s1">createTypeAliasDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
        <span class="s1">updateTypeAliasDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
        <span class="s1">createEnumDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">EnumMember</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
        <span class="s1">updateEnumDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">EnumMember</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
        <span class="s1">createModuleDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">NodeFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
        <span class="s1">updateModuleDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
        <span class="s1">createModuleBlock(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ModuleBlock</span><span class="s1">;</span>
        <span class="s1">updateModuleBlock(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ModuleBlock</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ModuleBlock</span><span class="s1">;</span>
        <span class="s1">createCaseBlock(</span><span class="s3">clauses</span><span class="s2">: readonly </span><span class="s3">CaseOrDefaultClause</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">;</span>
        <span class="s1">updateCaseBlock(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">, </span><span class="s3">clauses</span><span class="s2">: readonly </span><span class="s3">CaseOrDefaultClause</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">;</span>
        <span class="s1">createNamespaceExportDeclaration(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NamespaceExportDeclaration</span><span class="s1">;</span>
        <span class="s1">updateNamespaceExportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamespaceExportDeclaration</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NamespaceExportDeclaration</span><span class="s1">;</span>
        <span class="s1">createImportEqualsDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
        <span class="s1">updateImportEqualsDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
        <span class="s1">createImportDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">importClause</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">?: </span><span class="s3">AssertClause</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
        <span class="s1">updateImportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">importClause</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">: </span><span class="s3">AssertClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
        <span class="s1">createImportClause(</span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">namedBindings</span><span class="s2">: </span><span class="s3">NamedImportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportClause</span><span class="s1">;</span>
        <span class="s1">updateImportClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportClause</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">namedBindings</span><span class="s2">: </span><span class="s3">NamedImportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportClause</span><span class="s1">;</span>
        <span class="s1">createAssertClause(</span><span class="s3">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">AssertEntry</span><span class="s1">&gt;, </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AssertClause</span><span class="s1">;</span>
        <span class="s1">updateAssertClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">AssertClause</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">AssertEntry</span><span class="s1">&gt;, </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AssertClause</span><span class="s1">;</span>
        <span class="s1">createAssertEntry(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">AssertionKey</span><span class="s1">, </span><span class="s3">value</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AssertEntry</span><span class="s1">;</span>
        <span class="s1">updateAssertEntry(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">AssertEntry</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">AssertionKey</span><span class="s1">, </span><span class="s3">value</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AssertEntry</span><span class="s1">;</span>
        <span class="s1">createImportTypeAssertionContainer(</span><span class="s3">clause</span><span class="s2">: </span><span class="s3">AssertClause</span><span class="s1">, </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeAssertionContainer</span><span class="s1">;</span>
        <span class="s1">updateImportTypeAssertionContainer(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportTypeAssertionContainer</span><span class="s1">, </span><span class="s3">clause</span><span class="s2">: </span><span class="s3">AssertClause</span><span class="s1">, </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeAssertionContainer</span><span class="s1">;</span>
        <span class="s1">createNamespaceImport(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NamespaceImport</span><span class="s1">;</span>
        <span class="s1">updateNamespaceImport(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamespaceImport</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NamespaceImport</span><span class="s1">;</span>
        <span class="s1">createNamespaceExport(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NamespaceExport</span><span class="s1">;</span>
        <span class="s1">updateNamespaceExport(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamespaceExport</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NamespaceExport</span><span class="s1">;</span>
        <span class="s1">createNamedImports(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ImportSpecifier</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">NamedImports</span><span class="s1">;</span>
        <span class="s1">updateNamedImports(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamedImports</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ImportSpecifier</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">NamedImports</span><span class="s1">;</span>
        <span class="s1">createImportSpecifier(</span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportSpecifier</span><span class="s1">;</span>
        <span class="s1">updateImportSpecifier(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportSpecifier</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportSpecifier</span><span class="s1">;</span>
        <span class="s1">createExportAssignment(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isExportEquals</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
        <span class="s1">updateExportAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
        <span class="s1">createExportDeclaration(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">exportClause</span><span class="s2">: </span><span class="s3">NamedExportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">?: </span><span class="s3">AssertClause</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
        <span class="s1">updateExportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">exportClause</span><span class="s2">: </span><span class="s3">NamedExportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">: </span><span class="s3">AssertClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
        <span class="s1">createNamedExports(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ExportSpecifier</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">NamedExports</span><span class="s1">;</span>
        <span class="s1">updateNamedExports(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamedExports</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ExportSpecifier</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">NamedExports</span><span class="s1">;</span>
        <span class="s1">createExportSpecifier(</span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
        <span class="s1">updateExportSpecifier(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportSpecifier</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
        <span class="s1">createExternalModuleReference(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExternalModuleReference</span><span class="s1">;</span>
        <span class="s1">updateExternalModuleReference(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExternalModuleReference</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExternalModuleReference</span><span class="s1">;</span>
        <span class="s1">createJSDocAllType()</span><span class="s2">: </span><span class="s3">JSDocAllType</span><span class="s1">;</span>
        <span class="s1">createJSDocUnknownType()</span><span class="s2">: </span><span class="s3">JSDocUnknownType</span><span class="s1">;</span>
        <span class="s1">createJSDocNonNullableType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">postfix</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocNonNullableType</span><span class="s1">;</span>
        <span class="s1">updateJSDocNonNullableType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocNonNullableType</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocNonNullableType</span><span class="s1">;</span>
        <span class="s1">createJSDocNullableType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">postfix</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocNullableType</span><span class="s1">;</span>
        <span class="s1">updateJSDocNullableType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocNullableType</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocNullableType</span><span class="s1">;</span>
        <span class="s1">createJSDocOptionalType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocOptionalType</span><span class="s1">;</span>
        <span class="s1">updateJSDocOptionalType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocOptionalType</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocOptionalType</span><span class="s1">;</span>
        <span class="s1">createJSDocFunctionType(</span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocFunctionType</span><span class="s1">;</span>
        <span class="s1">updateJSDocFunctionType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocFunctionType</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocFunctionType</span><span class="s1">;</span>
        <span class="s1">createJSDocVariadicType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocVariadicType</span><span class="s1">;</span>
        <span class="s1">updateJSDocVariadicType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocVariadicType</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocVariadicType</span><span class="s1">;</span>
        <span class="s1">createJSDocNamepathType(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocNamepathType</span><span class="s1">;</span>
        <span class="s1">updateJSDocNamepathType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocNamepathType</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocNamepathType</span><span class="s1">;</span>
        <span class="s1">createJSDocTypeExpression(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
        <span class="s1">updateJSDocTypeExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
        <span class="s1">createJSDocNameReference(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocNameReference</span><span class="s1">;</span>
        <span class="s1">updateJSDocNameReference(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocNameReference</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocNameReference</span><span class="s1">;</span>
        <span class="s1">createJSDocMemberName(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
        <span class="s1">updateJSDocMemberName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocMemberName</span><span class="s1">, </span><span class="s3">left</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
        <span class="s1">createJSDocLink(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocLink</span><span class="s1">;</span>
        <span class="s1">updateJSDocLink(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocLink</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocLink</span><span class="s1">;</span>
        <span class="s1">createJSDocLinkCode(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocLinkCode</span><span class="s1">;</span>
        <span class="s1">updateJSDocLinkCode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocLinkCode</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocLinkCode</span><span class="s1">;</span>
        <span class="s1">createJSDocLinkPlain(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocLinkPlain</span><span class="s1">;</span>
        <span class="s1">updateJSDocLinkPlain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocLinkPlain</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">JSDocMemberName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocLinkPlain</span><span class="s1">;</span>
        <span class="s1">createJSDocTypeLiteral(</span><span class="s3">jsDocPropertyTags</span><span class="s2">?: readonly </span><span class="s3">JSDocPropertyLikeTag</span><span class="s1">[], </span><span class="s3">isArrayType</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTypeLiteral</span><span class="s1">;</span>
        <span class="s1">updateJSDocTypeLiteral(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocTypeLiteral</span><span class="s1">, </span><span class="s3">jsDocPropertyTags</span><span class="s2">: readonly </span><span class="s3">JSDocPropertyLikeTag</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isArrayType</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTypeLiteral</span><span class="s1">;</span>
        <span class="s1">createJSDocSignature(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">JSDocTemplateTag</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">JSDocParameterTag</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">JSDocReturnTag</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocSignature</span><span class="s1">;</span>
        <span class="s1">updateJSDocSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocSignature</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">JSDocTemplateTag</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">JSDocParameterTag</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">JSDocReturnTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocSignature</span><span class="s1">;</span>
        <span class="s1">createJSDocTemplateTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[], </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocTemplateTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocTemplateTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocTemplateTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[], </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTemplateTag</span><span class="s1">;</span>
        <span class="s1">createJSDocTypedefTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">JSDocTypeLiteral</span><span class="s1">, </span><span class="s3">fullName</span><span class="s2">?: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSDocNamespaceDeclaration</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocTypedefTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocTypedefTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocTypedefTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">JSDocTypeLiteral </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">fullName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTypedefTag</span><span class="s1">;</span>
        <span class="s1">createJSDocParameterTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">isBracketed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">isNameFirst</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocParameterTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocParameterTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocParameterTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">isBracketed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isNameFirst</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocParameterTag</span><span class="s1">;</span>
        <span class="s1">createJSDocPropertyTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">isBracketed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">isNameFirst</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocPropertyTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocPropertyTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocPropertyTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">isBracketed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isNameFirst</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocPropertyTag</span><span class="s1">;</span>
        <span class="s1">createJSDocTypeTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocTypeTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocTypeTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocTypeTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTypeTag</span><span class="s1">;</span>
        <span class="s1">createJSDocSeeTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">nameExpression</span><span class="s2">: </span><span class="s3">JSDocNameReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocSeeTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocSeeTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocSeeTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">nameExpression</span><span class="s2">: </span><span class="s3">JSDocNameReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocSeeTag</span><span class="s1">;</span>
        <span class="s1">createJSDocReturnTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocReturnTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocReturnTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocReturnTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocReturnTag</span><span class="s1">;</span>
        <span class="s1">createJSDocThisTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocThisTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocThisTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocThisTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocThisTag</span><span class="s1">;</span>
        <span class="s1">createJSDocEnumTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocEnumTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocEnumTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocEnumTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocEnumTag</span><span class="s1">;</span>
        <span class="s1">createJSDocCallbackTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocSignature</span><span class="s1">, </span><span class="s3">fullName</span><span class="s2">?: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSDocNamespaceDeclaration</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocCallbackTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocCallbackTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocCallbackTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocSignature</span><span class="s1">, </span><span class="s3">fullName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocCallbackTag</span><span class="s1">;</span>
        <span class="s1">createJSDocAugmentsTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">className</span><span class="s2">: </span><span class="s3">JSDocAugmentsTag</span><span class="s1">[</span><span class="s4">&quot;class&quot;</span><span class="s1">], </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocAugmentsTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocAugmentsTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocAugmentsTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">className</span><span class="s2">: </span><span class="s3">JSDocAugmentsTag</span><span class="s1">[</span><span class="s4">&quot;class&quot;</span><span class="s1">], </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocAugmentsTag</span><span class="s1">;</span>
        <span class="s1">createJSDocImplementsTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">className</span><span class="s2">: </span><span class="s3">JSDocImplementsTag</span><span class="s1">[</span><span class="s4">&quot;class&quot;</span><span class="s1">], </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocImplementsTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocImplementsTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocImplementsTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">className</span><span class="s2">: </span><span class="s3">JSDocImplementsTag</span><span class="s1">[</span><span class="s4">&quot;class&quot;</span><span class="s1">], </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocImplementsTag</span><span class="s1">;</span>
        <span class="s1">createJSDocAuthorTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocAuthorTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocAuthorTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocAuthorTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocAuthorTag</span><span class="s1">;</span>
        <span class="s1">createJSDocClassTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocClassTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocClassTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocClassTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocClassTag</span><span class="s1">;</span>
        <span class="s1">createJSDocPublicTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocPublicTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocPublicTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocPublicTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocPublicTag</span><span class="s1">;</span>
        <span class="s1">createJSDocPrivateTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocPrivateTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocPrivateTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocPrivateTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocPrivateTag</span><span class="s1">;</span>
        <span class="s1">createJSDocProtectedTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocProtectedTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocProtectedTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocProtectedTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocProtectedTag</span><span class="s1">;</span>
        <span class="s1">createJSDocReadonlyTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocReadonlyTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocReadonlyTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocReadonlyTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocReadonlyTag</span><span class="s1">;</span>
        <span class="s1">createJSDocUnknownTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocUnknownTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocUnknownTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocUnknownTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocUnknownTag</span><span class="s1">;</span>
        <span class="s1">createJSDocDeprecatedTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocDeprecatedTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocDeprecatedTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocDeprecatedTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocDeprecatedTag</span><span class="s1">;</span>
        <span class="s1">createJSDocOverrideTag(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocOverrideTag</span><span class="s1">;</span>
        <span class="s1">updateJSDocOverrideTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocOverrideTag</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">JSDocOverrideTag</span><span class="s1">;</span>
        <span class="s1">createJSDocText(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocText</span><span class="s1">;</span>
        <span class="s1">updateJSDocText(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDocText</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocText</span><span class="s1">;</span>
        <span class="s1">createJSDocComment(</span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">tags</span><span class="s2">?: readonly </span><span class="s3">JSDocTag</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDoc</span><span class="s1">;</span>
        <span class="s1">updateJSDocComment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JSDoc</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">tags</span><span class="s2">: readonly </span><span class="s3">JSDocTag</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDoc</span><span class="s1">;</span>
        <span class="s1">createJsxElement(</span><span class="s3">openingElement</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">, </span><span class="s3">children</span><span class="s2">: readonly </span><span class="s3">JsxChild</span><span class="s1">[], </span><span class="s3">closingElement</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxElement</span><span class="s1">;</span>
        <span class="s1">updateJsxElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxElement</span><span class="s1">, </span><span class="s3">openingElement</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">, </span><span class="s3">children</span><span class="s2">: readonly </span><span class="s3">JsxChild</span><span class="s1">[], </span><span class="s3">closingElement</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxElement</span><span class="s1">;</span>
        <span class="s1">createJsxSelfClosingElement(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxSelfClosingElement</span><span class="s1">;</span>
        <span class="s1">updateJsxSelfClosingElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxSelfClosingElement</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxSelfClosingElement</span><span class="s1">;</span>
        <span class="s1">createJsxOpeningElement(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">;</span>
        <span class="s1">updateJsxOpeningElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">;</span>
        <span class="s1">createJsxClosingElement(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">;</span>
        <span class="s1">updateJsxClosingElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">;</span>
        <span class="s1">createJsxFragment(</span><span class="s3">openingFragment</span><span class="s2">: </span><span class="s3">JsxOpeningFragment</span><span class="s1">, </span><span class="s3">children</span><span class="s2">: readonly </span><span class="s3">JsxChild</span><span class="s1">[], </span><span class="s3">closingFragment</span><span class="s2">: </span><span class="s3">JsxClosingFragment</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxFragment</span><span class="s1">;</span>
        <span class="s1">createJsxText(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containsOnlyTriviaWhiteSpaces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxText</span><span class="s1">;</span>
        <span class="s1">updateJsxText(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxText</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containsOnlyTriviaWhiteSpaces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxText</span><span class="s1">;</span>
        <span class="s1">createJsxOpeningFragment()</span><span class="s2">: </span><span class="s3">JsxOpeningFragment</span><span class="s1">;</span>
        <span class="s1">createJsxJsxClosingFragment()</span><span class="s2">: </span><span class="s3">JsxClosingFragment</span><span class="s1">;</span>
        <span class="s1">updateJsxFragment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxFragment</span><span class="s1">, </span><span class="s3">openingFragment</span><span class="s2">: </span><span class="s3">JsxOpeningFragment</span><span class="s1">, </span><span class="s3">children</span><span class="s2">: readonly </span><span class="s3">JsxChild</span><span class="s1">[], </span><span class="s3">closingFragment</span><span class="s2">: </span><span class="s3">JsxClosingFragment</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxFragment</span><span class="s1">;</span>
        <span class="s1">createJsxAttribute(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">JsxAttributeValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxAttribute</span><span class="s1">;</span>
        <span class="s1">updateJsxAttribute(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxAttribute</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">JsxAttributeValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxAttribute</span><span class="s1">;</span>
        <span class="s1">createJsxAttributes(</span><span class="s3">properties</span><span class="s2">: readonly </span><span class="s3">JsxAttributeLike</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
        <span class="s1">updateJsxAttributes(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">, </span><span class="s3">properties</span><span class="s2">: readonly </span><span class="s3">JsxAttributeLike</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
        <span class="s1">createJsxSpreadAttribute(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxSpreadAttribute</span><span class="s1">;</span>
        <span class="s1">updateJsxSpreadAttribute(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxSpreadAttribute</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxSpreadAttribute</span><span class="s1">;</span>
        <span class="s1">createJsxExpression(</span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxExpression</span><span class="s1">;</span>
        <span class="s1">updateJsxExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxExpression</span><span class="s1">;</span>
        <span class="s1">createCaseClause(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CaseClause</span><span class="s1">;</span>
        <span class="s1">updateCaseClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CaseClause</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CaseClause</span><span class="s1">;</span>
        <span class="s1">createDefaultClause(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">DefaultClause</span><span class="s1">;</span>
        <span class="s1">updateDefaultClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">DefaultClause</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">DefaultClause</span><span class="s1">;</span>
        <span class="s1">createHeritageClause(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">HeritageClause</span><span class="s1">[</span><span class="s4">&quot;token&quot;</span><span class="s1">], </span><span class="s3">types</span><span class="s2">: readonly </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">HeritageClause</span><span class="s1">;</span>
        <span class="s1">updateHeritageClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">HeritageClause</span><span class="s1">, </span><span class="s3">types</span><span class="s2">: readonly </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">HeritageClause</span><span class="s1">;</span>
        <span class="s1">createCatchClause(</span><span class="s3">variableDeclaration</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName </span><span class="s2">| </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">block</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CatchClause</span><span class="s1">;</span>
        <span class="s1">updateCatchClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CatchClause</span><span class="s1">, </span><span class="s3">variableDeclaration</span><span class="s2">: </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">block</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CatchClause</span><span class="s1">;</span>
        <span class="s1">createPropertyAssignment(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyAssignment</span><span class="s1">;</span>
        <span class="s1">updatePropertyAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyAssignment</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyAssignment</span><span class="s1">;</span>
        <span class="s1">createShorthandPropertyAssignment(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">objectAssignmentInitializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ShorthandPropertyAssignment</span><span class="s1">;</span>
        <span class="s1">updateShorthandPropertyAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ShorthandPropertyAssignment</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">objectAssignmentInitializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ShorthandPropertyAssignment</span><span class="s1">;</span>
        <span class="s1">createSpreadAssignment(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SpreadAssignment</span><span class="s1">;</span>
        <span class="s1">updateSpreadAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SpreadAssignment</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SpreadAssignment</span><span class="s1">;</span>
        <span class="s1">createEnumMember(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EnumMember</span><span class="s1">;</span>
        <span class="s1">updateEnumMember(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">EnumMember</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EnumMember</span><span class="s1">;</span>
        <span class="s1">createSourceFile(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">endOfFileToken</span><span class="s2">: </span><span class="s3">EndOfFileToken</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">: </span><span class="s3">NodeFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">updateSourceFile(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">isDeclarationFile</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">referencedFiles</span><span class="s2">?: readonly </span><span class="s3">FileReference</span><span class="s1">[], </span><span class="s3">typeReferences</span><span class="s2">?: readonly </span><span class="s3">FileReference</span><span class="s1">[], </span><span class="s3">hasNoDefaultLib</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">libReferences</span><span class="s2">?: readonly </span><span class="s3">FileReference</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">createNotEmittedStatement(</span><span class="s3">original</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NotEmittedStatement</span><span class="s1">;</span>
        <span class="s1">createPartiallyEmittedExpression(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">original</span><span class="s2">?: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PartiallyEmittedExpression</span><span class="s1">;</span>
        <span class="s1">updatePartiallyEmittedExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PartiallyEmittedExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PartiallyEmittedExpression</span><span class="s1">;</span>
        <span class="s1">createCommaListExpression(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CommaListExpression</span><span class="s1">;</span>
        <span class="s1">updateCommaListExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CommaListExpression</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CommaListExpression</span><span class="s1">;</span>
        <span class="s1">createBundle(</span><span class="s3">sourceFiles</span><span class="s2">: readonly </span><span class="s3">SourceFile</span><span class="s1">[], </span><span class="s3">prepends</span><span class="s2">?: readonly </span><span class="s1">(</span><span class="s3">UnparsedSource </span><span class="s2">| </span><span class="s3">InputFiles</span><span class="s1">)[])</span><span class="s2">: </span><span class="s3">Bundle</span><span class="s1">;</span>
        <span class="s1">updateBundle(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Bundle</span><span class="s1">, </span><span class="s3">sourceFiles</span><span class="s2">: readonly </span><span class="s3">SourceFile</span><span class="s1">[], </span><span class="s3">prepends</span><span class="s2">?: readonly </span><span class="s1">(</span><span class="s3">UnparsedSource </span><span class="s2">| </span><span class="s3">InputFiles</span><span class="s1">)[])</span><span class="s2">: </span><span class="s3">Bundle</span><span class="s1">;</span>
        <span class="s1">createComma(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createAssignment(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression </span><span class="s2">| </span><span class="s3">ArrayLiteralExpression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DestructuringAssignment</span><span class="s1">;</span>
        <span class="s1">createAssignment(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AssignmentExpression</span><span class="s1">&lt;</span><span class="s3">EqualsToken</span><span class="s1">&gt;;</span>
        <span class="s1">createLogicalOr(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createLogicalAnd(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createBitwiseOr(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createBitwiseXor(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createBitwiseAnd(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createStrictEquality(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createStrictInequality(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createEquality(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createInequality(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createLessThan(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createLessThanEquals(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createGreaterThan(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createGreaterThanEquals(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createLeftShift(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createRightShift(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createUnsignedRightShift(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createAdd(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createSubtract(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createMultiply(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createDivide(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createModulo(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createExponent(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
        <span class="s1">createPrefixPlus(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createPrefixMinus(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createPrefixIncrement(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createPrefixDecrement(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createBitwiseNot(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createLogicalNot(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createPostfixIncrement(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createPostfixDecrement(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
        <span class="s1">createImmediatelyInvokedFunctionExpression(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">createImmediatelyInvokedFunctionExpression(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">param</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">paramValue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">createImmediatelyInvokedArrowFunction(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">createImmediatelyInvokedArrowFunction(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">param</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">paramValue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">createVoidZero()</span><span class="s2">: </span><span class="s3">VoidExpression</span><span class="s1">;</span>
        <span class="s1">createExportDefault(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
        <span class="s1">createExternalModuleExport(</span><span class="s3">exportName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
        <span class="s1">restoreOuterExpressions(</span><span class="s3">outerExpression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">innerExpression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">kinds</span><span class="s2">?: </span><span class="s3">OuterExpressionKinds</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">CoreTransformationContext </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">factory</span><span class="s2">: </span><span class="s3">NodeFactory</span><span class="s1">;</span>
        <span class="s0">/** Gets the compiler options supplied to the transformer. */</span>
        <span class="s1">getCompilerOptions()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s0">/** Starts a new lexical environment. */</span>
        <span class="s1">startLexicalEnvironment()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** Suspends the current lexical environment, usually after visiting a parameter list. */</span>
        <span class="s1">suspendLexicalEnvironment()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** Resumes a suspended lexical environment, usually before visiting a function body. */</span>
        <span class="s1">resumeLexicalEnvironment()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** Ends a lexical environment, returning any declarations. */</span>
        <span class="s1">endLexicalEnvironment()</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Hoists a function declaration to the containing scope. */</span>
        <span class="s1">hoistFunctionDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** Hoists a variable declaration to the containing scope. */</span>
        <span class="s1">hoistVariableDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TransformationContext </span><span class="s2">extends </span><span class="s3">CoreTransformationContext </span><span class="s1">{</span>
        <span class="s0">/** Records a request for a non-scoped emit helper in the current context. */</span>
        <span class="s1">requestEmitHelper(</span><span class="s3">helper</span><span class="s2">: </span><span class="s3">EmitHelper</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** Gets and resets the requested non-scoped emit helpers. */</span>
        <span class="s1">readEmitHelpers()</span><span class="s2">: </span><span class="s3">EmitHelper</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */</span>
        <span class="s1">enableSubstitution(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** Determines whether expression substitutions are enabled for the provided node. */</span>
        <span class="s1">isSubstitutionEnabled(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Hook used by transformers to substitute expressions just before they 
         * are emitted by the pretty printer. 
         * 
         * NOTE: Transformation hooks should only be modified during `Transformer` initialization, 
         * before returning the `NodeTransformer` callback. 
         */</span>
        <span class="s1">onSubstituteNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Node</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables before/after emit notifications in the pretty printer for the provided 
         * SyntaxKind. 
         */</span>
        <span class="s1">enableEmitNotification(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Determines whether before/after emit notifications should be raised in the pretty 
         * printer when it emits a node. 
         */</span>
        <span class="s1">isEmitNotificationEnabled(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Hook used to allow transformers to capture state before or after 
         * the printer emits a node. 
         * 
         * NOTE: Transformation hooks should only be modified during `Transformer` initialization, 
         * before returning the `NodeTransformer` callback. 
         */</span>
        <span class="s1">onEmitNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s5">emitCallback</span><span class="s2">: </span><span class="s1">(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TransformationResult</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt; {</span>
        <span class="s0">/** Gets the transformed source files. */</span>
        <span class="s1">transformed</span><span class="s2">: </span><span class="s3">T</span><span class="s1">[];</span>
        <span class="s0">/** Gets diagnostics for the transformation. */</span>
        <span class="s1">diagnostics</span><span class="s2">?: </span><span class="s3">DiagnosticWithLocation</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets a substitute for a node, if one is available; otherwise, returns the original node. 
         * 
         * </span><span class="s2">@param </span><span class="s3">hint </span><span class="s0">A hint as to the intended usage of the node. 
         * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The node to substitute. 
         */</span>
        <span class="s1">substituteNode(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Emits a node with possible notification. 
         * 
         * </span><span class="s2">@param </span><span class="s3">hint </span><span class="s0">A hint as to the intended usage of the node. 
         * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The node to emit. 
         * </span><span class="s2">@param </span><span class="s3">emitCallback </span><span class="s0">A callback used to emit the node. 
         */</span>
        <span class="s1">emitNodeWithNotification(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s5">emitCallback</span><span class="s2">: </span><span class="s1">(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates if a given node needs an emit notification 
         * 
         * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The node to emit. 
         */</span>
        <span class="s1">isEmitNotificationEnabled</span><span class="s2">?</span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Clean up EmitNode entries on any parse-tree nodes. 
         */</span>
        <span class="s1">dispose()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that is used to initialize and return a `Transformer` callback, which in turn 
     * will be used to transform one or more nodes. 
     */</span>
    <span class="s2">export type </span><span class="s3">TransformerFactory</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s1">(</span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Transformer</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that transforms a node. 
     */</span>
    <span class="s2">export type </span><span class="s3">Transformer</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that accepts and possibly transforms a node. 
     */</span>
    <span class="s2">export type </span><span class="s3">Visitor </span><span class="s2">= </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">VisitResult</span><span class="s1">&lt;</span><span class="s3">Node</span><span class="s1">&gt;;</span>
    <span class="s2">export interface </span><span class="s3">NodeVisitor </span><span class="s1">{</span>
        <span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">test</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s5">lift</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: readonly </span><span class="s3">Node</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
        <span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">test</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s5">lift</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: readonly </span><span class="s3">Node</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">NodesVisitor </span><span class="s1">{</span>
        <span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">test</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">start</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">count</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
        <span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">test</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">start</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">count</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">VisitResult</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s3">T </span><span class="s2">| </span><span class="s3">T</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">Printer </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Print a node and its subtree as-is, without any emit transformations. 
         * </span><span class="s2">@param </span><span class="s3">hint </span><span class="s0">A value indicating the purpose of a node. This is primarily used to 
         * distinguish between an `Identifier` used in an expression position, versus an 
         * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you 
         * should just pass `Unspecified`. 
         * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The node to print. The node and its subtree are printed as-is, without any 
         * emit transformations. 
         * </span><span class="s2">@param </span><span class="s3">sourceFile </span><span class="s0">A source file that provides context for the node. The source text of 
         * the file is used to emit the original source content for literals and identifiers, while 
         * the identifiers of the source file are used when generating unique names to avoid 
         * collisions. 
         */</span>
        <span class="s1">printNode(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Prints a list of nodes using the given format flags 
         */</span>
        <span class="s1">printList&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">format</span><span class="s2">: </span><span class="s3">ListFormat</span><span class="s1">, </span><span class="s3">list</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Prints a source file as-is, without any emit transformations. 
         */</span>
        <span class="s1">printFile(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Prints a bundle of source files as-is, without any emit transformations. 
         */</span>
        <span class="s1">printBundle(</span><span class="s3">bundle</span><span class="s2">: </span><span class="s3">Bundle</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PrintHandlers </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* A hook used by the Printer when generating unique names to avoid collisions with 
         * globally defined names that exist outside of the current source file. 
         */</span>
        <span class="s1">hasGlobalName</span><span class="s2">?</span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A hook used by the Printer to provide notifications prior to emitting a node. A 
         * compatible implementation **must** invoke `emitCallback` with the provided `hint` and 
         * `node` values. 
         * </span><span class="s2">@param </span><span class="s3">hint </span><span class="s0">A hint indicating the intended purpose of the node. 
         * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The node to emit. 
         * </span><span class="s2">@param </span><span class="s3">emitCallback </span><span class="s0">A callback that, when invoked, will emit the node. 
         * </span><span class="s2">@example</span>
         <span class="s0">* ```ts 
         * var printer = createPrinter(printerOptions, { 
         *   onEmitNode(hint, node, emitCallback) { 
         *     // set up or track state prior to emitting the node... 
         *     emitCallback(hint, node); 
         *     // restore state after emitting the node... 
         *   } 
         * }); 
         * ``` 
         */</span>
        <span class="s1">onEmitNode</span><span class="s2">?</span><span class="s1">(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s5">emitCallback</span><span class="s2">: </span><span class="s1">(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A hook used to check if an emit notification is required for a node. 
         * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The node to emit. 
         */</span>
        <span class="s1">isEmitNotificationEnabled</span><span class="s2">?</span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A hook used by the Printer to perform just-in-time substitution of a node. This is 
         * primarily used by node transformations that need to substitute one node for another, 
         * such as replacing `myExportedVar` with `exports.myExportedVar`. 
         * </span><span class="s2">@param </span><span class="s3">hint </span><span class="s0">A hint indicating the intended purpose of the node. 
         * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The node to emit. 
         * </span><span class="s2">@example</span>
         <span class="s0">* ```ts 
         * var printer = createPrinter(printerOptions, { 
         *   substituteNode(hint, node) { 
         *     // perform substitution if necessary... 
         *     return node; 
         *   } 
         * }); 
         * ``` 
         */</span>
        <span class="s1">substituteNode</span><span class="s2">?</span><span class="s1">(</span><span class="s3">hint</span><span class="s2">: </span><span class="s3">EmitHint</span><span class="s1">, </span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PrinterOptions </span><span class="s1">{</span>
        <span class="s1">removeComments</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">newLine</span><span class="s2">?: </span><span class="s3">NewLineKind</span><span class="s1">;</span>
        <span class="s1">omitTrailingSemicolon</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noEmitHelpers</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">GetEffectiveTypeRootsHost </span><span class="s1">{</span>
        <span class="s1">directoryExists</span><span class="s2">?</span><span class="s1">(</span><span class="s3">directoryName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TextSpan </span><span class="s1">{</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TextChangeRange </span><span class="s1">{</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">newLength</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">SyntaxList </span><span class="s2">extends </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SyntaxList</span><span class="s1">;</span>
        <span class="s1">_children</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export enum </span><span class="s3">ListFormat </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">SingleLine </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">MultiLine </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">PreserveLines </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">LinesMask </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">NotDelimited </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">BarDelimited </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">AmpersandDelimited </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">CommaDelimited </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">AsteriskDelimited </span><span class="s2">= </span><span class="s6">32</span><span class="s1">,</span>
        <span class="s3">DelimitersMask </span><span class="s2">= </span><span class="s6">60</span><span class="s1">,</span>
        <span class="s3">AllowTrailingComma </span><span class="s2">= </span><span class="s6">64</span><span class="s1">,</span>
        <span class="s3">Indented </span><span class="s2">= </span><span class="s6">128</span><span class="s1">,</span>
        <span class="s3">SpaceBetweenBraces </span><span class="s2">= </span><span class="s6">256</span><span class="s1">,</span>
        <span class="s3">SpaceBetweenSiblings </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">Braces </span><span class="s2">= </span><span class="s6">1024</span><span class="s1">,</span>
        <span class="s3">Parenthesis </span><span class="s2">= </span><span class="s6">2048</span><span class="s1">,</span>
        <span class="s3">AngleBrackets </span><span class="s2">= </span><span class="s6">4096</span><span class="s1">,</span>
        <span class="s3">SquareBrackets </span><span class="s2">= </span><span class="s6">8192</span><span class="s1">,</span>
        <span class="s3">BracketsMask </span><span class="s2">= </span><span class="s6">15360</span><span class="s1">,</span>
        <span class="s3">OptionalIfUndefined </span><span class="s2">= </span><span class="s6">16384</span><span class="s1">,</span>
        <span class="s3">OptionalIfEmpty </span><span class="s2">= </span><span class="s6">32768</span><span class="s1">,</span>
        <span class="s3">Optional </span><span class="s2">= </span><span class="s6">49152</span><span class="s1">,</span>
        <span class="s3">PreferNewLine </span><span class="s2">= </span><span class="s6">65536</span><span class="s1">,</span>
        <span class="s3">NoTrailingNewLine </span><span class="s2">= </span><span class="s6">131072</span><span class="s1">,</span>
        <span class="s3">NoInterveningComments </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">NoSpaceIfEmpty </span><span class="s2">= </span><span class="s6">524288</span><span class="s1">,</span>
        <span class="s3">SingleElement </span><span class="s2">= </span><span class="s6">1048576</span><span class="s1">,</span>
        <span class="s3">SpaceAfterList </span><span class="s2">= </span><span class="s6">2097152</span><span class="s1">,</span>
        <span class="s3">Modifiers </span><span class="s2">= </span><span class="s6">2359808</span><span class="s1">,</span>
        <span class="s3">HeritageClauses </span><span class="s2">= </span><span class="s6">512</span><span class="s1">,</span>
        <span class="s3">SingleLineTypeLiteralMembers </span><span class="s2">= </span><span class="s6">768</span><span class="s1">,</span>
        <span class="s3">MultiLineTypeLiteralMembers </span><span class="s2">= </span><span class="s6">32897</span><span class="s1">,</span>
        <span class="s3">SingleLineTupleTypeElements </span><span class="s2">= </span><span class="s6">528</span><span class="s1">,</span>
        <span class="s3">MultiLineTupleTypeElements </span><span class="s2">= </span><span class="s6">657</span><span class="s1">,</span>
        <span class="s3">UnionTypeConstituents </span><span class="s2">= </span><span class="s6">516</span><span class="s1">,</span>
        <span class="s3">IntersectionTypeConstituents </span><span class="s2">= </span><span class="s6">520</span><span class="s1">,</span>
        <span class="s3">ObjectBindingPatternElements </span><span class="s2">= </span><span class="s6">525136</span><span class="s1">,</span>
        <span class="s3">ArrayBindingPatternElements </span><span class="s2">= </span><span class="s6">524880</span><span class="s1">,</span>
        <span class="s3">ObjectLiteralExpressionProperties </span><span class="s2">= </span><span class="s6">526226</span><span class="s1">,</span>
        <span class="s3">ImportClauseEntries </span><span class="s2">= </span><span class="s6">526226</span><span class="s1">,</span>
        <span class="s3">ArrayLiteralExpressionElements </span><span class="s2">= </span><span class="s6">8914</span><span class="s1">,</span>
        <span class="s3">CommaListElements </span><span class="s2">= </span><span class="s6">528</span><span class="s1">,</span>
        <span class="s3">CallExpressionArguments </span><span class="s2">= </span><span class="s6">2576</span><span class="s1">,</span>
        <span class="s3">NewExpressionArguments </span><span class="s2">= </span><span class="s6">18960</span><span class="s1">,</span>
        <span class="s3">TemplateExpressionSpans </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">SingleLineBlockStatements </span><span class="s2">= </span><span class="s6">768</span><span class="s1">,</span>
        <span class="s3">MultiLineBlockStatements </span><span class="s2">= </span><span class="s6">129</span><span class="s1">,</span>
        <span class="s3">VariableDeclarationList </span><span class="s2">= </span><span class="s6">528</span><span class="s1">,</span>
        <span class="s3">SingleLineFunctionBodyStatements </span><span class="s2">= </span><span class="s6">768</span><span class="s1">,</span>
        <span class="s3">MultiLineFunctionBodyStatements </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">ClassHeritageClauses </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">ClassMembers </span><span class="s2">= </span><span class="s6">129</span><span class="s1">,</span>
        <span class="s3">InterfaceMembers </span><span class="s2">= </span><span class="s6">129</span><span class="s1">,</span>
        <span class="s3">EnumMembers </span><span class="s2">= </span><span class="s6">145</span><span class="s1">,</span>
        <span class="s3">CaseBlockClauses </span><span class="s2">= </span><span class="s6">129</span><span class="s1">,</span>
        <span class="s3">NamedImportsOrExportsElements </span><span class="s2">= </span><span class="s6">525136</span><span class="s1">,</span>
        <span class="s3">JsxElementOrFragmentChildren </span><span class="s2">= </span><span class="s6">262144</span><span class="s1">,</span>
        <span class="s3">JsxElementAttributes </span><span class="s2">= </span><span class="s6">262656</span><span class="s1">,</span>
        <span class="s3">CaseOrDefaultClauseStatements </span><span class="s2">= </span><span class="s6">163969</span><span class="s1">,</span>
        <span class="s3">HeritageClauseTypes </span><span class="s2">= </span><span class="s6">528</span><span class="s1">,</span>
        <span class="s3">SourceFileStatements </span><span class="s2">= </span><span class="s6">131073</span><span class="s1">,</span>
        <span class="s3">Decorators </span><span class="s2">= </span><span class="s6">2146305</span><span class="s1">,</span>
        <span class="s3">TypeArguments </span><span class="s2">= </span><span class="s6">53776</span><span class="s1">,</span>
        <span class="s3">TypeParameters </span><span class="s2">= </span><span class="s6">53776</span><span class="s1">,</span>
        <span class="s3">Parameters </span><span class="s2">= </span><span class="s6">2576</span><span class="s1">,</span>
        <span class="s3">IndexSignatureParameters </span><span class="s2">= </span><span class="s6">8848</span><span class="s1">,</span>
        <span class="s3">JSDocComment </span><span class="s2">= </span><span class="s6">33</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">UserPreferences </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">disableSuggestions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">quotePreference</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;double&quot; </span><span class="s2">| </span><span class="s4">&quot;single&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsForModuleExports</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsForImportStatements</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsWithSnippetText</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeAutomaticOptionalChainCompletions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsWithInsertText</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsWithClassMemberSnippets</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsWithObjectLiteralMethodSnippets</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">useLabelDetailsInCompletionEntries</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">allowIncompleteCompletions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">importModuleSpecifierPreference</span><span class="s2">?: </span><span class="s4">&quot;shortest&quot; </span><span class="s2">| </span><span class="s4">&quot;project-relative&quot; </span><span class="s2">| </span><span class="s4">&quot;relative&quot; </span><span class="s2">| </span><span class="s4">&quot;non-relative&quot;</span><span class="s1">;</span>
        <span class="s0">/** Determines whether we import `foo/index.ts` as &quot;foo&quot;, &quot;foo/index&quot;, or &quot;foo/index.js&quot; */</span>
        <span class="s2">readonly </span><span class="s1">importModuleSpecifierEnding</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;minimal&quot; </span><span class="s2">| </span><span class="s4">&quot;index&quot; </span><span class="s2">| </span><span class="s4">&quot;js&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">allowTextChangesInNewFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">providePrefixAndSuffixTextForRename</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includePackageJsonAutoImports</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;on&quot; </span><span class="s2">| </span><span class="s4">&quot;off&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">provideRefactorNotApplicableReason</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">jsxAttributeCompletionStyle</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;braces&quot; </span><span class="s2">| </span><span class="s4">&quot;none&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayParameterNameHints</span><span class="s2">?: </span><span class="s4">&quot;none&quot; </span><span class="s2">| </span><span class="s4">&quot;literals&quot; </span><span class="s2">| </span><span class="s4">&quot;all&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayParameterNameHintsWhenArgumentMatchesName</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayFunctionParameterTypeHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayVariableTypeHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayVariableTypeHintsWhenTypeMatchesName</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayPropertyDeclarationTypeHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayFunctionLikeReturnTypeHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayEnumMemberValueHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">allowRenameOfImportPath</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">autoImportFileExcludePatterns</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/** Represents a bigint literal value without requiring bigint support */</span>
    <span class="s2">export interface </span><span class="s3">PseudoBigInt </span><span class="s1">{</span>
        <span class="s1">negative</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">base10Value</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export </span><span class="s1">{};</span>
<span class="s1">}</span>
<span class="s2">declare function </span><span class="s1">setTimeout(</span><span class="s5">handler</span><span class="s2">: </span><span class="s1">(</span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s3">timeout</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
<span class="s2">declare function </span><span class="s1">clearTimeout(</span><span class="s3">handle</span><span class="s2">: </span><span class="s3">any</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">export enum </span><span class="s3">FileWatcherEventKind </span><span class="s1">{</span>
        <span class="s3">Created </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Changed </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Deleted </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">FileWatcherCallback </span><span class="s2">= </span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">eventKind</span><span class="s2">: </span><span class="s3">FileWatcherEventKind</span><span class="s1">, </span><span class="s3">modifiedTime</span><span class="s2">?: </span><span class="s3">Date</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">DirectoryWatcherCallback </span><span class="s2">= </span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">System </span><span class="s1">{</span>
        <span class="s1">args</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">newLine</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">write(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">writeOutputIsTTY</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getWidthOfTerminal</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">readFile(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">encoding</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getFileSize</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">writeFile(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">writeByteOrderMark</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@pollingInterval </span><span class="s0">- this parameter is used in polling-based watchers and ignored in watchers that 
         * use native OS file watching 
         */</span>
        <span class="s1">watchFile</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">callback</span><span class="s2">: </span><span class="s3">FileWatcherCallback</span><span class="s1">, </span><span class="s3">pollingInterval</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FileWatcher</span><span class="s1">;</span>
        <span class="s1">watchDirectory</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">callback</span><span class="s2">: </span><span class="s3">DirectoryWatcherCallback</span><span class="s1">, </span><span class="s3">recursive</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FileWatcher</span><span class="s1">;</span>
        <span class="s1">resolvePath(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">fileExists(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">directoryExists(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">createDirectory(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getExecutingFilePath()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getDirectories(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">readDirectory(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">extensions</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">exclude</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">include</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">depth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">getModifiedTime</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Date </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">setModifiedTime</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">time</span><span class="s2">: </span><span class="s3">Date</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">deleteFile</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm) 
         */</span>
        <span class="s1">createHash</span><span class="s2">?</span><span class="s1">(</span><span class="s3">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** This must be cryptographically secure. Only implement this method using `crypto.createHash(&quot;sha256&quot;)`. */</span>
        <span class="s1">createSHA256Hash</span><span class="s2">?</span><span class="s1">(</span><span class="s3">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getMemoryUsage</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">exit(</span><span class="s3">exitCode</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">realpath</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">setTimeout</span><span class="s2">?</span><span class="s1">(</span><span class="s5">callback</span><span class="s2">: </span><span class="s1">(</span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s3">ms</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s1">clearTimeout</span><span class="s2">?</span><span class="s1">(</span><span class="s3">timeoutId</span><span class="s2">: </span><span class="s3">any</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">clearScreen</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">base64decode</span><span class="s2">?</span><span class="s1">(</span><span class="s3">input</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">base64encode</span><span class="s2">?</span><span class="s1">(</span><span class="s3">input</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FileWatcher </span><span class="s1">{</span>
        <span class="s1">close()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export function </span><span class="s1">getNodeMajorVersion()</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export let </span><span class="s1">sys</span><span class="s2">: </span><span class="s3">System</span><span class="s1">;</span>
    <span class="s2">export </span><span class="s1">{};</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">type </span><span class="s3">ErrorCallback </span><span class="s2">= </span><span class="s1">(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">DiagnosticMessage</span><span class="s1">, </span><span class="s3">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">Scanner </span><span class="s1">{</span>
        <span class="s1">getStartPos()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getToken()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">getTextPos()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getTokenPos()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getTokenText()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getTokenValue()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">hasUnicodeEscape()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">hasExtendedUnicodeEscape()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">hasPrecedingLineBreak()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isIdentifier()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isReservedWord()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isUnterminated()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">reScanGreaterToken()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanSlashToken()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanAsteriskEqualsToken()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanTemplateToken(</span><span class="s3">isTaggedTemplate</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanTemplateHeadOrNoSubstitutionTemplate()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">scanJsxIdentifier()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">scanJsxAttributeValue()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanJsxAttributeValue()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanJsxToken(</span><span class="s3">allowMultilineJsxText</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxTokenSyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanLessThanToken()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanHashToken()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanQuestionToken()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">reScanInvalidIdentifier()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">scanJsxToken()</span><span class="s2">: </span><span class="s3">JsxTokenSyntaxKind</span><span class="s1">;</span>
        <span class="s1">scanJsDocToken()</span><span class="s2">: </span><span class="s3">JSDocSyntaxKind</span><span class="s1">;</span>
        <span class="s1">scan()</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">;</span>
        <span class="s1">getText()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">setText(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">start</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">length</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">setOnError(</span><span class="s3">onError</span><span class="s2">: </span><span class="s3">ErrorCallback </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">setScriptTarget(</span><span class="s3">scriptTarget</span><span class="s2">: </span><span class="s3">ScriptTarget</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">setLanguageVariant(</span><span class="s3">variant</span><span class="s2">: </span><span class="s3">LanguageVariant</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">setTextPos(</span><span class="s3">textPos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">lookAhead&lt;</span><span class="s3">T</span><span class="s1">&gt;(</span><span class="s5">callback</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
        <span class="s1">scanRange&lt;</span><span class="s3">T</span><span class="s1">&gt;(</span><span class="s3">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s5">callback</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
        <span class="s1">tryScan&lt;</span><span class="s3">T</span><span class="s1">&gt;(</span><span class="s5">callback</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">tokenToString(</span><span class="s3">t</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getPositionOfLineAndCharacter(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFileLike</span><span class="s1">, </span><span class="s3">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">character</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getLineAndCharacterOfPosition(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFileLike</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LineAndCharacter</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isWhiteSpaceLike(</span><span class="s3">ch</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/** Does not include line breaks. For that, see isWhiteSpaceLike. */</span>
    <span class="s2">function </span><span class="s1">isWhiteSpaceSingleLine(</span><span class="s3">ch</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isLineBreak(</span><span class="s3">ch</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">couldStartTrivia(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">forEachLeadingCommentRange&lt;</span><span class="s3">U</span><span class="s1">&gt;(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s5">cb</span><span class="s2">: </span><span class="s1">(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">CommentKind</span><span class="s1">, </span><span class="s3">hasTrailingNewLine</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">U</span><span class="s1">)</span><span class="s2">: </span><span class="s3">U </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">forEachLeadingCommentRange&lt;</span><span class="s3">T</span><span class="s1">, </span><span class="s3">U</span><span class="s1">&gt;(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s5">cb</span><span class="s2">: </span><span class="s1">(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">CommentKind</span><span class="s1">, </span><span class="s3">hasTrailingNewLine</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">state</span><span class="s2">: </span><span class="s3">T</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">U</span><span class="s1">, </span><span class="s3">state</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">U </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">forEachTrailingCommentRange&lt;</span><span class="s3">U</span><span class="s1">&gt;(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s5">cb</span><span class="s2">: </span><span class="s1">(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">CommentKind</span><span class="s1">, </span><span class="s3">hasTrailingNewLine</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">U</span><span class="s1">)</span><span class="s2">: </span><span class="s3">U </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">forEachTrailingCommentRange&lt;</span><span class="s3">T</span><span class="s1">, </span><span class="s3">U</span><span class="s1">&gt;(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s5">cb</span><span class="s2">: </span><span class="s1">(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">CommentKind</span><span class="s1">, </span><span class="s3">hasTrailingNewLine</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">state</span><span class="s2">: </span><span class="s3">T</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">U</span><span class="s1">, </span><span class="s3">state</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">U </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">reduceEachLeadingCommentRange&lt;</span><span class="s3">T</span><span class="s1">, </span><span class="s3">U</span><span class="s1">&gt;(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s5">cb</span><span class="s2">: </span><span class="s1">(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">CommentKind</span><span class="s1">, </span><span class="s3">hasTrailingNewLine</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">state</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">memo</span><span class="s2">: </span><span class="s3">U</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">U</span><span class="s1">, </span><span class="s3">state</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">initial</span><span class="s2">: </span><span class="s3">U</span><span class="s1">)</span><span class="s2">: </span><span class="s3">U </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">reduceEachTrailingCommentRange&lt;</span><span class="s3">T</span><span class="s1">, </span><span class="s3">U</span><span class="s1">&gt;(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s5">cb</span><span class="s2">: </span><span class="s1">(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">CommentKind</span><span class="s1">, </span><span class="s3">hasTrailingNewLine</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">state</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">memo</span><span class="s2">: </span><span class="s3">U</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">U</span><span class="s1">, </span><span class="s3">state</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">initial</span><span class="s2">: </span><span class="s3">U</span><span class="s1">)</span><span class="s2">: </span><span class="s3">U </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getLeadingCommentRanges(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CommentRange</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getTrailingCommentRanges(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CommentRange</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Optionally, get the shebang */</span>
    <span class="s2">function </span><span class="s1">getShebang(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIdentifierStart(</span><span class="s3">ch</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">languageVersion</span><span class="s2">: </span><span class="s3">ScriptTarget </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIdentifierPart(</span><span class="s3">ch</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">languageVersion</span><span class="s2">: </span><span class="s3">ScriptTarget </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">identifierVariant</span><span class="s2">?: </span><span class="s3">LanguageVariant</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createScanner(</span><span class="s3">languageVersion</span><span class="s2">: </span><span class="s3">ScriptTarget</span><span class="s1">, </span><span class="s3">skipTrivia</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">languageVariant</span><span class="s2">?: </span><span class="s3">LanguageVariant</span><span class="s1">, </span><span class="s3">textInitial</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">onError</span><span class="s2">?: </span><span class="s3">ErrorCallback</span><span class="s1">, </span><span class="s3">start</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">length</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Scanner</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">function </span><span class="s1">isExternalModuleNameRelative(</span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">sortAndDeduplicateDiagnostics&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Diagnostic</span><span class="s1">&gt;(</span><span class="s3">diagnostics</span><span class="s2">: readonly </span><span class="s3">T</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">SortedReadonlyArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s2">function </span><span class="s1">getDefaultLibFileName(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanEnd(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanIsEmpty(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanContainsPosition(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanContainsTextSpan(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">other</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanOverlapsWith(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">other</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanOverlap(</span><span class="s3">span1</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">span2</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanIntersectsWithTextSpan(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">other</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanIntersectsWith(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">decodedTextSpanIntersectsWith(</span><span class="s3">start1</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">length1</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">start2</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">length2</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanIntersectsWithPosition(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textSpanIntersection(</span><span class="s3">span1</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">span2</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createTextSpan(</span><span class="s3">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createTextSpanFromBounds(</span><span class="s3">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textChangeRangeNewSpan(</span><span class="s3">range</span><span class="s2">: </span><span class="s3">TextChangeRange</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">textChangeRangeIsUnchanged(</span><span class="s3">range</span><span class="s2">: </span><span class="s3">TextChangeRange</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createTextChangeRange(</span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">newLength</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChangeRange</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">unchangedTextChangeRange</span><span class="s2">: </span><span class="s3">TextChangeRange</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Called to merge all the changes that occurred across several versions of a script snapshot 
     * into a single change.  i.e. if a user keeps making successive edits to a script we will 
     * have a text change from V1 to V2, V2 to V3, ..., Vn. 
     * 
     * This function will then merge those changes into a single change range valid between V1 and 
     * Vn. 
     */</span>
    <span class="s2">function </span><span class="s1">collapseTextChangeRangesAcrossMultipleVersions(</span><span class="s3">changes</span><span class="s2">: readonly </span><span class="s3">TextChangeRange</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TextChangeRange</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getTypeParameterOwner(</span><span class="s3">d</span><span class="s2">: </span><span class="s3">Declaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Declaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">ParameterPropertyDeclaration </span><span class="s2">= </span><span class="s3">ParameterDeclaration </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">parent</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">isParameterPropertyDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">parent</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ParameterPropertyDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isEmptyBindingPattern(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">BindingPattern</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isEmptyBindingElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">BindingElement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">walkUpBindingElementsAndPatterns(</span><span class="s3">binding</span><span class="s2">: </span><span class="s3">BindingElement</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getCombinedModifierFlags(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Declaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModifierFlags</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getCombinedNodeFlags(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeFlags</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Checks to see if the locale is in the appropriate format, 
     * and if it is, attempts to set the appropriate language. 
     */</span>
    <span class="s2">function </span><span class="s1">validateLocaleAndSetLanguage(</span><span class="s3">locale</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">sys</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">getExecutingFilePath()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">resolvePath(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">fileExists(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">readFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}, </span><span class="s3">errors</span><span class="s2">?: </span><span class="s3">Push</span><span class="s1">&lt;</span><span class="s3">Diagnostic</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getOriginalNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getOriginalNode&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s5">nodeTest</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">node </span><span class="s2">is </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getOriginalNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getOriginalNode&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">nodeTest</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">node </span><span class="s2">is </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Iterates through the parent chain of a node and performs the callback on each parent until the callback 
     * returns a truthy value, then returns that value. 
     * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns &quot;quit&quot; 
     * At that point findAncestor returns undefined. 
     */</span>
    <span class="s2">function </span><span class="s1">findAncestor&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">callback</span><span class="s2">: </span><span class="s1">(</span><span class="s3">element</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">element </span><span class="s2">is </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">findAncestor(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">callback</span><span class="s2">: </span><span class="s1">(</span><span class="s3">element</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean </span><span class="s2">| </span><span class="s4">&quot;quit&quot;</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets a value indicating whether a node originated in the parse tree. 
     * 
     * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The node to test. 
     */</span>
    <span class="s2">function </span><span class="s1">isParseTreeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the original parse tree node for a node. 
     * 
     * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The original node. 
     * </span><span class="s2">@returns </span><span class="s0">The original parse tree node if found; otherwise, undefined. 
     */</span>
    <span class="s2">function </span><span class="s1">getParseTreeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the original parse tree node for a node. 
     * 
     * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The original node. 
     * </span><span class="s2">@param </span><span class="s3">nodeTest </span><span class="s0">A callback used to ensure the correct type of parse tree node is returned. 
     * </span><span class="s2">@returns </span><span class="s0">The original parse tree node if found; otherwise, undefined. 
     */</span>
    <span class="s2">function </span><span class="s1">getParseTreeNode&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">nodeTest</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">node </span><span class="s2">is </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */</span>
    <span class="s2">function </span><span class="s1">escapeLeadingUnderscores(</span><span class="s3">identifier</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">__String</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Remove extra underscore from escaped identifier text content. 
     * 
     * </span><span class="s2">@param </span><span class="s3">identifier </span><span class="s0">The escaped identifier text. 
     * </span><span class="s2">@returns </span><span class="s0">The unescaped identifier text. 
     */</span>
    <span class="s2">function </span><span class="s1">unescapeLeadingUnderscores(</span><span class="s3">identifier</span><span class="s2">: </span><span class="s3">__String</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">idText(</span><span class="s3">identifierOrPrivateName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PrivateIdentifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">symbolName(</span><span class="s3">symbol</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getNameOfJSDocTypedef(</span><span class="s3">declaration</span><span class="s2">: </span><span class="s3">JSDocTypedefTag</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PrivateIdentifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getNameOfDeclaration(</span><span class="s3">declaration</span><span class="s2">: </span><span class="s3">Declaration </span><span class="s2">| </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DeclarationName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getDecorators(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">HasDecorators</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getModifiers(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">HasModifiers</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the JSDoc parameter tags for the node if present. 
     * 
     * </span><span class="s2">@remarks </span><span class="s0">Returns any JSDoc param tag whose name matches the provided 
     * parameter, whether a param tag on a containing function 
     * expression, or a param tag on a variable declaration whose 
     * initializer is the containing function. The tags closest to the 
     * node are returned first, so in the previous example, the param 
     * tag on the containing function expression would be first. 
     * 
     * For binding patterns, parameter tags are matched by position. 
     */</span>
    <span class="s2">function </span><span class="s1">getJSDocParameterTags(</span><span class="s3">param</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">JSDocParameterTag</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the JSDoc type parameter tags for the node if present. 
     * 
     * </span><span class="s2">@remarks </span><span class="s0">Returns any JSDoc template tag whose names match the provided 
     * parameter, whether a template tag on a containing function 
     * expression, or a template tag on a variable declaration whose 
     * initializer is the containing function. The tags closest to the 
     * node are returned first, so in the previous example, the template 
     * tag on the containing function expression would be first. 
     */</span>
    <span class="s2">function </span><span class="s1">getJSDocTypeParameterTags(</span><span class="s3">param</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">JSDocTemplateTag</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* Return true if the node has JSDoc parameter tags. 
     * 
     * </span><span class="s2">@remarks </span><span class="s0">Includes parameter tags that are not directly on the node, 
     * for example on a variable declaration whose initializer is a function expression. 
     */</span>
    <span class="s2">function </span><span class="s1">hasJSDocParameterTags(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionLikeDeclaration </span><span class="s2">| </span><span class="s3">SignatureDeclaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc augments tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocAugmentsTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocAugmentsTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc implements tags for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocImplementsTags(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">JSDocImplementsTag</span><span class="s1">[];</span>
    <span class="s0">/** Gets the JSDoc class tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocClassTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocClassTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc public tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocPublicTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocPublicTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc private tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocPrivateTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocPrivateTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc protected tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocProtectedTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocProtectedTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc protected tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocReadonlyTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocReadonlyTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getJSDocOverrideTagNoCache(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocOverrideTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc deprecated tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocDeprecatedTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocDeprecatedTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc enum tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocEnumTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocEnumTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc this tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocThisTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocThisTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc return tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocReturnTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocReturnTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc template tag for the node if present */</span>
    <span class="s2">function </span><span class="s1">getJSDocTemplateTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTemplateTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Gets the JSDoc type tag for the node if present and valid */</span>
    <span class="s2">function </span><span class="s1">getJSDocTypeTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTypeTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the type node for the node if provided via JSDoc. 
     * 
     * </span><span class="s2">@remarks </span><span class="s0">The search includes any JSDoc param tag that relates 
     * to the provided parameter, for example a type tag on the 
     * parameter itself, or a param tag on a containing function 
     * expression, or a param tag on a variable declaration whose 
     * initializer is the containing function. The tags closest to the 
     * node are examined first, so in the previous example, the type 
     * tag directly on the node would be returned. 
     */</span>
    <span class="s2">function </span><span class="s1">getJSDocType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the return type node for the node if provided via JSDoc return tag or type tag. 
     * 
     * </span><span class="s2">@remarks </span><span class="s0">`getJSDocReturnTag` just gets the whole JSDoc tag. This function 
     * gets the type from inside the braces, after the fat arrow, etc. 
     */</span>
    <span class="s2">function </span><span class="s1">getJSDocReturnType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** Get all JSDoc tags related to a node, including those on parent nodes. */</span>
    <span class="s2">function </span><span class="s1">getJSDocTags(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">JSDocTag</span><span class="s1">[];</span>
    <span class="s0">/** Gets all JSDoc tags that match a specified predicate */</span>
    <span class="s2">function </span><span class="s1">getAllJSDocTags&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">JSDocTag</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s5">predicate</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tag</span><span class="s2">: </span><span class="s3">JSDocTag</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">tag </span><span class="s2">is </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">T</span><span class="s1">[];</span>
    <span class="s0">/** Gets all JSDoc tags of a specified kind */</span>
    <span class="s2">function </span><span class="s1">getAllJSDocTagsOfKind(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">JSDocTag</span><span class="s1">[];</span>
    <span class="s0">/** Gets the text of a jsdoc comment, flattening links to their text. */</span>
    <span class="s2">function </span><span class="s1">getTextOfJSDocComment(</span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the effective type parameters. If the node was parsed in a 
     * JavaScript file, gets the type parameters from the `</span><span class="s2">@template</span><span class="s0">` tag from JSDoc. 
     * 
     * This does *not* return type parameters from a jsdoc reference to a generic type, eg 
     * 
     * type Id = &lt;T&gt;(x: T) =&gt; T 
     * /** </span><span class="s2">@type </span><span class="s3">{Id} </span><span class="s0">/ 
     * function id(x) { return x } 
     */</span>
    <span class="s2">function </span><span class="s1">getEffectiveTypeParameterDeclarations(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">DeclarationWithTypeParameters</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[];</span>
    <span class="s2">function </span><span class="s1">getEffectiveConstraintOfTypeParameter(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isMemberName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">MemberName</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPropertyAccessChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PropertyAccessChain</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isElementAccessChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ElementAccessChain</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCallChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CallChain</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isOptionalChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PropertyAccessChain </span><span class="s2">| </span><span class="s3">ElementAccessChain </span><span class="s2">| </span><span class="s3">CallChain </span><span class="s2">| </span><span class="s3">NonNullChain</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNullishCoalesce(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isConstTypeReference(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">skipPartiallyEmittedExpressions(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">skipPartiallyEmittedExpressions(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNonNullChain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NonNullChain</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isBreakOrContinueStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">BreakOrContinueStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNamedExportBindings(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NamedExportBindings</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isUnparsedTextLike(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">UnparsedTextLike</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isUnparsedNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">UnparsedNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocPropertyLikeTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocPropertyLikeTag</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* True if kind is of some token syntax kind. 
     * For example, this is true for an IfKeyword but not for an IfStatement. 
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail. 
     */</span>
    <span class="s2">function </span><span class="s1">isTokenKind(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* True if node is of some token syntax kind. 
     * For example, this is true for an IfKeyword but not for an IfStatement. 
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail. 
     */</span>
    <span class="s2">function </span><span class="s1">isToken(</span><span class="s3">n</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isLiteralExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">LiteralExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateLiteralToken(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateLiteralToken</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateMiddleOrTemplateTail(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isImportOrExportSpecifier(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ImportSpecifier </span><span class="s2">| </span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeOnlyImportOrExportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeOnlyAliasDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isAssertionKey(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">AssertionKey</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isStringTextContainingNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">TemplateLiteralToken</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isModifier(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">Modifier</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isEntityName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">EntityName</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPropertyName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isBindingName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">BindingName</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isFunctionLike(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SignatureDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isClassElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ClassElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isClassLike(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ClassLikeDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isAccessor(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">AccessorDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isModifierLike(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ModifierLike</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isClassOrTypeElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ClassElement </span><span class="s2">| </span><span class="s3">TypeElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isObjectLiteralElementLike(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ObjectLiteralElementLike</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Node test that determines whether a node is a valid type node. 
     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part* 
     * of a TypeNode. 
     */</span>
    <span class="s2">function </span><span class="s1">isTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isFunctionOrConstructorTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">FunctionTypeNode </span><span class="s2">| </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPropertyAccessOrQualifiedName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PropertyAccessExpression </span><span class="s2">| </span><span class="s3">QualifiedName</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCallLikeExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CallLikeExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCallOrNewExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">NewExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateLiteral(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateLiteral</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isAssertionExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">AssertionExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIterationStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">lookInLabeledStatements</span><span class="s2">: </span><span class="s3">false</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">IterationStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIterationStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">lookInLabeledStatements</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">IterationStatement </span><span class="s2">| </span><span class="s3">LabeledStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxOpeningLikeElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxOpeningLikeElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCaseOrDefaultClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CaseOrDefaultClause</span><span class="s1">;</span>
    <span class="s0">/** True if node is of a kind that may contain comment text. */</span>
    <span class="s2">function </span><span class="s1">isJSDocCommentContainingNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isSetAccessor(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isGetAccessor(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s0">/** True if has initializer node attached to it. */</span>
    <span class="s2">function </span><span class="s1">hasOnlyExpressionInitializer(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">HasExpressionInitializer</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isObjectLiteralElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ObjectLiteralElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isStringLiteralLike(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">StringLiteralLike</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocLinkLike(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocLink </span><span class="s2">| </span><span class="s3">JSDocLinkCode </span><span class="s2">| </span><span class="s3">JSDocLinkPlain</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">hasRestParameter(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">SignatureDeclaration </span><span class="s2">| </span><span class="s3">JSDocSignature</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isRestParameter(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParameterDeclaration </span><span class="s2">| </span><span class="s3">JSDocParameterTag</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">factory</span><span class="s2">: </span><span class="s3">NodeFactory</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createUnparsedSourceFile(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createUnparsedSourceFile(</span><span class="s3">inputFile</span><span class="s2">: </span><span class="s3">InputFiles</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s4">&quot;js&quot; </span><span class="s2">| </span><span class="s4">&quot;dts&quot;</span><span class="s1">, </span><span class="s3">stripInternal</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createUnparsedSourceFile(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">mapPath</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">map</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createInputFiles(</span><span class="s3">javascriptText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">declarationText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">InputFiles</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createInputFiles(</span><span class="s5">readFileText</span><span class="s2">: </span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">javascriptPath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">javascriptMapPath</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">declarationPath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">declarationMapPath</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">buildInfoPath</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">InputFiles</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createInputFiles(</span><span class="s3">javascriptText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">declarationText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">javascriptMapPath</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">javascriptMapText</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">declarationMapPath</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">declarationMapText</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">InputFiles</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create an external source map source file reference 
     */</span>
    <span class="s2">function </span><span class="s1">createSourceMapSource(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s5">skipTrivia</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceMapSource</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">setOriginalNode&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">original</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Clears any `EmitNode` entries from parse-tree nodes. 
     * </span><span class="s2">@param </span><span class="s3">sourceFile </span><span class="s0">A source file. 
     */</span>
    <span class="s2">function </span><span class="s1">disposeEmitNodes(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets flags that control emit behavior of a node. 
     */</span>
    <span class="s2">function </span><span class="s1">setEmitFlags&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">emitFlags</span><span class="s2">: </span><span class="s3">EmitFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets a custom text range to use when emitting source maps. 
     */</span>
    <span class="s2">function </span><span class="s1">getSourceMapRange(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceMapRange</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets a custom text range to use when emitting source maps. 
     */</span>
    <span class="s2">function </span><span class="s1">setSourceMapRange&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">range</span><span class="s2">: </span><span class="s3">SourceMapRange </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the TextRange to use for source maps for a token of a node. 
     */</span>
    <span class="s2">function </span><span class="s1">getTokenSourceMapRange(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceMapRange </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets the TextRange to use for source maps for a token of a node. 
     */</span>
    <span class="s2">function </span><span class="s1">setTokenSourceMapRange&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">, </span><span class="s3">range</span><span class="s2">: </span><span class="s3">SourceMapRange </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets a custom text range to use when emitting comments. 
     */</span>
    <span class="s2">function </span><span class="s1">getCommentRange(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextRange</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets a custom text range to use when emitting comments. 
     */</span>
    <span class="s2">function </span><span class="s1">setCommentRange&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">range</span><span class="s2">: </span><span class="s3">TextRange</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getSyntheticLeadingComments(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SynthesizedComment</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">setSyntheticLeadingComments&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">comments</span><span class="s2">: </span><span class="s3">SynthesizedComment</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">addSyntheticLeadingComment&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SingleLineCommentTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MultiLineCommentTrivia</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">hasTrailingNewLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getSyntheticTrailingComments(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SynthesizedComment</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">setSyntheticTrailingComments&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">comments</span><span class="s2">: </span><span class="s3">SynthesizedComment</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">addSyntheticTrailingComment&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SingleLineCommentTrivia </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MultiLineCommentTrivia</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">hasTrailingNewLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">moveSyntheticComments&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">original</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the constant value to emit for an expression representing an enum. 
     */</span>
    <span class="s2">function </span><span class="s1">getConstantValue(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">AccessExpression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">number </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Sets the constant value to emit for an expression. 
     */</span>
    <span class="s2">function </span><span class="s1">setConstantValue(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">AccessExpression</span><span class="s1">, </span><span class="s3">value</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AccessExpression</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Adds an EmitHelper to a node. 
     */</span>
    <span class="s2">function </span><span class="s1">addEmitHelper&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">helper</span><span class="s2">: </span><span class="s3">EmitHelper</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Add EmitHelpers to a node. 
     */</span>
    <span class="s2">function </span><span class="s1">addEmitHelpers&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">helpers</span><span class="s2">: </span><span class="s3">EmitHelper</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Removes an EmitHelper from a node. 
     */</span>
    <span class="s2">function </span><span class="s1">removeEmitHelper(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">helper</span><span class="s2">: </span><span class="s3">EmitHelper</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets the EmitHelpers of a node. 
     */</span>
    <span class="s2">function </span><span class="s1">getEmitHelpers(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EmitHelper</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Moves matching emit helpers from a source node to a target node. 
     */</span>
    <span class="s2">function </span><span class="s1">moveEmitHelpers(</span><span class="s3">source</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s3">target</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s5">predicate</span><span class="s2">: </span><span class="s1">(</span><span class="s3">helper</span><span class="s2">: </span><span class="s3">EmitHelper</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">function </span><span class="s1">isNumericLiteral(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NumericLiteral</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isBigIntLiteral(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">BigIntLiteral</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isStringLiteral(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxText(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxText</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isRegularExpressionLiteral(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">RegularExpressionLiteral</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNoSubstitutionTemplateLiteral(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateHead(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateHead</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateMiddle(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateMiddle</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateTail(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateTail</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isDotDotDotToken(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">DotDotDotToken</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPlusToken(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PlusToken</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isMinusToken(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">MinusToken</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isAsteriskToken(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">AsteriskToken</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIdentifier(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPrivateIdentifier(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isQualifiedName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">QualifiedName</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isComputedPropertyName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ComputedPropertyName</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeParameterDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isParameter(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isDecorator(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">Decorator</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPropertySignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PropertySignature</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPropertyDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isMethodSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">MethodSignature</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isMethodDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isClassStaticBlockDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ClassStaticBlockDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isConstructorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isGetAccessorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isSetAccessorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCallSignatureDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CallSignatureDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isConstructSignatureDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ConstructSignatureDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIndexSignatureDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypePredicateNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypePredicateNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeReferenceNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeReferenceNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isFunctionTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">FunctionTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isConstructorTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeQueryNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeQueryNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeLiteralNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeLiteralNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isArrayTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ArrayTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTupleTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TupleTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNamedTupleMember(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NamedTupleMember</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isOptionalTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">OptionalTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isRestTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">RestTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isUnionTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">UnionTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIntersectionTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">IntersectionTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isConditionalTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ConditionalTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isInferTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">InferTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isParenthesizedTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ParenthesizedTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isThisTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ThisTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeOperatorNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeOperatorNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIndexedAccessTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">IndexedAccessTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isMappedTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">MappedTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isLiteralTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">LiteralTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isImportTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateLiteralTypeSpan(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateLiteralTypeSpan</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateLiteralTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateLiteralTypeNode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isObjectBindingPattern(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ObjectBindingPattern</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isArrayBindingPattern(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ArrayBindingPattern</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isBindingElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">BindingElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isArrayLiteralExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isObjectLiteralExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPropertyAccessExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PropertyAccessExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isElementAccessExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ElementAccessExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCallExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CallExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNewExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NewExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTaggedTemplateExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeAssertionExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeAssertion</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isParenthesizedExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ParenthesizedExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isFunctionExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">FunctionExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isArrowFunction(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isDeleteExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">DeleteExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeOfExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeOfExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isVoidExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">VoidExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isAwaitExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">AwaitExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPrefixUnaryExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPostfixUnaryExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isBinaryExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isConditionalExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ConditionalExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isYieldExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">YieldExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isSpreadElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SpreadElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isClassExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ClassExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isOmittedExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">OmittedExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isExpressionWithTypeArguments(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isAsExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">AsExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNonNullExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NonNullExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isMetaProperty(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">MetaProperty</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isSyntheticExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SyntheticExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPartiallyEmittedExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PartiallyEmittedExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCommaListExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CommaListExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTemplateSpan(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TemplateSpan</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isSemicolonClassElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SemicolonClassElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isBlock(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">Block</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isVariableStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">VariableStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isEmptyStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">EmptyStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isExpressionStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isIfStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">IfStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isDoStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">DoStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isWhileStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">WhileStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isForStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ForStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isForInStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ForInStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isForOfStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ForOfStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isContinueStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ContinueStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isBreakStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">BreakStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isReturnStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ReturnStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isWithStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">WithStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isSwitchStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SwitchStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isLabeledStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">LabeledStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isThrowStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ThrowStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTryStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TryStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isDebuggerStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">DebuggerStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isVariableDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isVariableDeclarationList(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">VariableDeclarationList</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isFunctionDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isClassDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isInterfaceDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isTypeAliasDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isEnumDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isModuleDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isModuleBlock(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ModuleBlock</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCaseBlock(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CaseBlock</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNamespaceExportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NamespaceExportDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isImportEqualsDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isImportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isImportClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ImportClause</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isImportTypeAssertionContainer(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ImportTypeAssertionContainer</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isAssertClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">AssertClause</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isAssertEntry(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">AssertEntry</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNamespaceImport(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NamespaceImport</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNamespaceExport(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NamespaceExport</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNamedImports(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NamedImports</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isImportSpecifier(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ImportSpecifier</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isExportAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isExportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNamedExports(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NamedExports</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isExportSpecifier(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isMissingDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">MissingDeclaration</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isNotEmittedStatement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">NotEmittedStatement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isExternalModuleReference(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ExternalModuleReference</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxSelfClosingElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxSelfClosingElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxOpeningElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxOpeningElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxClosingElement(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxClosingElement</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxFragment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxFragment</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxOpeningFragment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxOpeningFragment</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxClosingFragment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxClosingFragment</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxAttribute(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxAttribute</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxAttributes(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxSpreadAttribute(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxSpreadAttribute</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJsxExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JsxExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCaseClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CaseClause</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isDefaultClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">DefaultClause</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isHeritageClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">HeritageClause</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isCatchClause(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">CatchClause</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isPropertyAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">PropertyAssignment</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isShorthandPropertyAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">ShorthandPropertyAssignment</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isSpreadAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SpreadAssignment</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isEnumMember(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">EnumMember</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isUnparsedPrepend(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">UnparsedPrepend</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isSourceFile(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">SourceFile</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isBundle(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">Bundle</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isUnparsedSource(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">UnparsedSource</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocTypeExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocNameReference(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocNameReference</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocMemberName(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocMemberName</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocLink(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocLink</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocLinkCode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocLinkCode</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocLinkPlain(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocLinkPlain</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocAllType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocAllType</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocUnknownType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocUnknownType</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocNullableType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocNullableType</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocNonNullableType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocNonNullableType</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocOptionalType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocOptionalType</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocFunctionType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocFunctionType</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocVariadicType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocVariadicType</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocNamepathType(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocNamepathType</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDoc(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDoc</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocTypeLiteral(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocTypeLiteral</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocSignature</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocAugmentsTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocAugmentsTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocAuthorTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocAuthorTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocClassTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocClassTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocCallbackTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocCallbackTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocPublicTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocPublicTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocPrivateTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocPrivateTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocProtectedTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocProtectedTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocReadonlyTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocReadonlyTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocOverrideTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocOverrideTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocDeprecatedTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocDeprecatedTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocSeeTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocSeeTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocEnumTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocEnumTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocParameterTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocParameterTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocReturnTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocReturnTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocThisTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocThisTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocTypeTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocTypeTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocTemplateTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocTemplateTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocTypedefTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocTypedefTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocUnknownTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocUnknownTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocPropertyTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocPropertyTag</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">isJSDocImplementsTag(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">JSDocImplementsTag</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">function </span><span class="s1">setTextRange&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">TextRange</span><span class="s1">&gt;(</span><span class="s3">range</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">location</span><span class="s2">: </span><span class="s3">TextRange </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">canHaveModifiers(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">HasModifiers</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">canHaveDecorators(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">)</span><span class="s2">: </span><span class="s3">node </span><span class="s2">is </span><span class="s3">HasDecorators</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes 
     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise, 
     * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns 
     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned. 
     * 
     * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">a given node to visit its children 
     * </span><span class="s2">@param </span><span class="s3">cbNode </span><span class="s0">a callback to be invoked for all child nodes 
     * </span><span class="s2">@param </span><span class="s3">cbNodes </span><span class="s0">a callback to be invoked for embedded array 
     * 
     * </span><span class="s2">@remarks </span><span class="s0">`forEachChild` must visit the children of a node in the order 
     * that they appear in the source code. The language service depends on this property to locate nodes by position. 
     */</span>
    <span class="s2">export function </span><span class="s1">forEachChild&lt;</span><span class="s3">T</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">, </span><span class="s5">cbNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">cbNodes</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Node</span><span class="s1">&gt;) </span><span class="s2">=&gt; </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">CreateSourceFileOptions </span><span class="s1">{</span>
        <span class="s1">languageVersion</span><span class="s2">: </span><span class="s3">ScriptTarget</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Controls the format the file is detected as - this can be derived from only the path 
         * and files on disk, but needs to be done with a module resolution cache in scope to be performant. 
         * This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`. 
         */</span>
        <span class="s1">impliedNodeFormat</span><span class="s2">?: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Controls how module-y-ness is set for the given file. Usually the result of calling 
         * `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default 
         * check specified by `isFileProbablyExternalModule` will be used to set the field. 
         */</span>
        <span class="s1">setExternalModuleIndicator</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">file</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export function </span><span class="s1">createSourceFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">sourceText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">languageVersionOrOptions</span><span class="s2">: </span><span class="s3">ScriptTarget </span><span class="s2">| </span><span class="s3">CreateSourceFileOptions</span><span class="s1">, </span><span class="s3">setParentNodes</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">parseIsolatedEntityName(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">languageVersion</span><span class="s2">: </span><span class="s3">ScriptTarget</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse json text into SyntaxTree and return node and parse errors if any 
     * </span><span class="s2">@param </span><span class="s3">fileName</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s3">sourceText</span>
     <span class="s0">*/</span>
    <span class="s2">export function </span><span class="s1">parseJsonText(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">sourceText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsonSourceFile</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">isExternalModule(</span><span class="s3">file</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">updateSourceFile(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">newText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">textChangeRange</span><span class="s2">: </span><span class="s3">TextChangeRange</span><span class="s1">, </span><span class="s3">aggressiveChecks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
    <span class="s2">export </span><span class="s1">{};</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">export function </span><span class="s1">parseCommandLine(</span><span class="s3">commandLine</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s5">readFile</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParsedCommandLine</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">DiagnosticReporter </span><span class="s2">= </span><span class="s1">(</span><span class="s3">diagnostic</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reports config file diagnostics 
     */</span>
    <span class="s2">export interface </span><span class="s3">ConfigFileDiagnosticsReporter </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Reports unrecoverable error when parsing config file 
         */</span>
        <span class="s1">onUnRecoverableConfigFileDiagnostic</span><span class="s2">: </span><span class="s3">DiagnosticReporter</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors 
     */</span>
    <span class="s2">export interface </span><span class="s3">ParseConfigFileHost </span><span class="s2">extends </span><span class="s3">ParseConfigHost</span><span class="s1">, </span><span class="s3">ConfigFileDiagnosticsReporter </span><span class="s1">{</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads the config file, reports errors if any and exits if the config file cannot be found 
     */</span>
    <span class="s2">export function </span><span class="s1">getParsedCommandLineOfConfigFile(</span><span class="s3">configFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">optionsToExtend</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ParseConfigFileHost</span><span class="s1">, </span><span class="s3">extendedConfigCache</span><span class="s2">?: </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">ExtendedConfigCacheEntry</span><span class="s1">&gt;, </span><span class="s3">watchOptionsToExtend</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">, </span><span class="s3">extraFileExtensions</span><span class="s2">?: readonly </span><span class="s3">FileExtensionInfo</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ParsedCommandLine </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Read tsconfig.json file 
     * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The path to the config file 
     */</span>
    <span class="s2">export function </span><span class="s1">readConfigFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s5">readFile</span><span class="s2">: </span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">config</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s1">error</span><span class="s2">?: </span><span class="s3">Diagnostic</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse the text of the tsconfig.json file 
     * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The path to the config file 
     * </span><span class="s2">@param </span><span class="s3">jsonText </span><span class="s0">The text of the config file 
     */</span>
    <span class="s2">export function </span><span class="s1">parseConfigFileTextToJson(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">jsonText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">config</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s1">error</span><span class="s2">?: </span><span class="s3">Diagnostic</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/**</span>
     <span class="s0">* Read tsconfig.json file 
     * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The path to the config file 
     */</span>
    <span class="s2">export function </span><span class="s1">readJsonConfigFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s5">readFile</span><span class="s2">: </span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TsConfigSourceFile</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Convert the json syntax tree into the json value 
     */</span>
    <span class="s2">export function </span><span class="s1">convertToObject(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">JsonSourceFile</span><span class="s1">, </span><span class="s3">errors</span><span class="s2">: </span><span class="s3">Push</span><span class="s1">&lt;</span><span class="s3">Diagnostic</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse the contents of a config file (tsconfig.json). 
     * </span><span class="s2">@param </span><span class="s3">json </span><span class="s0">The contents of the config file to parse 
     * </span><span class="s2">@param </span><span class="s3">host </span><span class="s0">Instance of ParseConfigHost used to enumerate files in folder. 
     * </span><span class="s2">@param </span><span class="s3">basePath </span><span class="s0">A root directory to resolve relative path entries in the config 
     *    file to. e.g. outDir 
     */</span>
    <span class="s2">export function </span><span class="s1">parseJsonConfigFileContent(</span><span class="s3">json</span><span class="s2">: </span><span class="s3">any</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ParseConfigHost</span><span class="s1">, </span><span class="s3">basePath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">existingOptions</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">configFileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">resolutionStack</span><span class="s2">?: </span><span class="s3">Path</span><span class="s1">[], </span><span class="s3">extraFileExtensions</span><span class="s2">?: readonly </span><span class="s3">FileExtensionInfo</span><span class="s1">[], </span><span class="s3">extendedConfigCache</span><span class="s2">?: </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">ExtendedConfigCacheEntry</span><span class="s1">&gt;, </span><span class="s3">existingWatchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParsedCommandLine</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse the contents of a config file (tsconfig.json). 
     * </span><span class="s2">@param </span><span class="s3">jsonNode </span><span class="s0">The contents of the config file to parse 
     * </span><span class="s2">@param </span><span class="s3">host </span><span class="s0">Instance of ParseConfigHost used to enumerate files in folder. 
     * </span><span class="s2">@param </span><span class="s3">basePath </span><span class="s0">A root directory to resolve relative path entries in the config 
     *    file to. e.g. outDir 
     */</span>
    <span class="s2">export function </span><span class="s1">parseJsonSourceFileConfigFileContent(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">TsConfigSourceFile</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ParseConfigHost</span><span class="s1">, </span><span class="s3">basePath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">existingOptions</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">configFileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">resolutionStack</span><span class="s2">?: </span><span class="s3">Path</span><span class="s1">[], </span><span class="s3">extraFileExtensions</span><span class="s2">?: readonly </span><span class="s3">FileExtensionInfo</span><span class="s1">[], </span><span class="s3">extendedConfigCache</span><span class="s2">?: </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">ExtendedConfigCacheEntry</span><span class="s1">&gt;, </span><span class="s3">existingWatchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParsedCommandLine</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ParsedTsconfig </span><span class="s1">{</span>
        <span class="s1">raw</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s1">options</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">watchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">;</span>
        <span class="s1">typeAcquisition</span><span class="s2">?: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet 
         */</span>
        <span class="s1">extendedConfigPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ExtendedConfigCacheEntry </span><span class="s1">{</span>
        <span class="s1">extendedResult</span><span class="s2">: </span><span class="s3">TsConfigSourceFile</span><span class="s1">;</span>
        <span class="s1">extendedConfig</span><span class="s2">: </span><span class="s3">ParsedTsconfig </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export function </span><span class="s1">convertCompilerOptionsFromJson(</span><span class="s3">jsonOptions</span><span class="s2">: </span><span class="s3">any</span><span class="s1">, </span><span class="s3">basePath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">configFileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
    <span class="s1">};</span>
    <span class="s2">export function </span><span class="s1">convertTypeAcquisitionFromJson(</span><span class="s3">jsonOptions</span><span class="s2">: </span><span class="s3">any</span><span class="s1">, </span><span class="s3">basePath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">configFileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
    <span class="s1">};</span>
    <span class="s2">export </span><span class="s1">{};</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">export function </span><span class="s1">getEffectiveTypeRoots(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">GetEffectiveTypeRootsHost</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s3">{string | undefined} containingFile </span><span class="s0">- file that contains type reference directive, can be undefined if containing file is unknown. 
     * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups 
     * is assumed to be the same as root directory of the project. 
     */</span>
    <span class="s2">export function </span><span class="s1">resolveTypeReferenceDirective(</span><span class="s3">typeReferenceDirectiveName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ModuleResolutionHost</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">?: </span><span class="s3">ResolvedProjectReference</span><span class="s1">, </span><span class="s3">cache</span><span class="s2">?: </span><span class="s3">TypeReferenceDirectiveResolutionCache</span><span class="s1">, </span><span class="s3">resolutionMode</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">])</span><span class="s2">: </span><span class="s3">ResolvedTypeReferenceDirectiveWithFailedLookupLocations</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Given a set of options, returns the set of type directive names 
     *   that should be included for this program automatically. 
     * This list could either come from the config file, 
     *   or from enumerating the types root + initial secondary types lookup location. 
     * More type directives might appear in the program later as a result of loading actual source files; 
     *   this list is only the set of defaults that are implicitly included. 
     */</span>
    <span class="s2">export function </span><span class="s1">getAutomaticTypeDirectiveNames(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ModuleResolutionHost</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s2">export interface </span><span class="s3">TypeReferenceDirectiveResolutionCache </span><span class="s2">extends </span><span class="s3">PerDirectoryResolutionCache</span><span class="s1">&lt;</span><span class="s3">ResolvedTypeReferenceDirectiveWithFailedLookupLocations</span><span class="s1">&gt;, </span><span class="s3">PackageJsonInfoCache </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ModeAwareCache</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">get(</span><span class="s3">key</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">mode</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">set(</span><span class="s3">key</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">mode</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">value</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s1">delete(</span><span class="s3">key</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">mode</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">this</span><span class="s1">;</span>
        <span class="s1">has(</span><span class="s3">key</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">mode</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">forEach(</span><span class="s5">cb</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elem</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">key</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">mode</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">size()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Cached resolutions per containing directory. 
     * This assumes that any module id will have the same resolution for sibling files located in the same folder. 
     */</span>
    <span class="s2">export interface </span><span class="s3">PerDirectoryResolutionCache</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">getOrCreateCacheForDirectory(</span><span class="s3">directoryName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">?: </span><span class="s3">ResolvedProjectReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModeAwareCache</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
        <span class="s1">clear()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  Updates with the current compilerOptions the cache will operate with. 
         *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects 
         */</span>
        <span class="s1">update(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ModuleResolutionCache </span><span class="s2">extends </span><span class="s3">PerDirectoryResolutionCache</span><span class="s1">&lt;</span><span class="s3">ResolvedModuleWithFailedLookupLocations</span><span class="s1">&gt;, </span><span class="s3">NonRelativeModuleNameResolutionCache</span><span class="s1">, </span><span class="s3">PackageJsonInfoCache </span><span class="s1">{</span>
        <span class="s1">getPackageJsonInfoCache()</span><span class="s2">: </span><span class="s3">PackageJsonInfoCache</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Stored map from non-relative module name to a table: directory -&gt; result of module lookup in this directory 
     * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive. 
     */</span>
    <span class="s2">export interface </span><span class="s3">NonRelativeModuleNameResolutionCache </span><span class="s2">extends </span><span class="s3">PackageJsonInfoCache </span><span class="s1">{</span>
        <span class="s1">getOrCreateCacheForModuleName(</span><span class="s3">nonRelativeModuleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">mode</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">?: </span><span class="s3">ResolvedProjectReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PerModuleNameCache</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PackageJsonInfoCache </span><span class="s1">{</span>
        <span class="s1">clear()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">PerModuleNameCache </span><span class="s1">{</span>
        <span class="s1">get(</span><span class="s3">directory</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedModuleWithFailedLookupLocations </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">set(</span><span class="s3">directory</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">result</span><span class="s2">: </span><span class="s3">ResolvedModuleWithFailedLookupLocations</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export function </span><span class="s1">createModuleResolutionCache(</span><span class="s3">currentDirectory</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s5">getCanonicalFileName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleResolutionCache</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">createTypeReferenceDirectiveResolutionCache(</span><span class="s3">currentDirectory</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s5">getCanonicalFileName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">packageJsonInfoCache</span><span class="s2">?: </span><span class="s3">PackageJsonInfoCache</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeReferenceDirectiveResolutionCache</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">resolveModuleNameFromCache(</span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">cache</span><span class="s2">: </span><span class="s3">ModuleResolutionCache</span><span class="s1">, </span><span class="s3">mode</span><span class="s2">?: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedModuleWithFailedLookupLocations </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">resolveModuleName(</span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">compilerOptions</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ModuleResolutionHost</span><span class="s1">, </span><span class="s3">cache</span><span class="s2">?: </span><span class="s3">ModuleResolutionCache</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">?: </span><span class="s3">ResolvedProjectReference</span><span class="s1">, </span><span class="s3">resolutionMode</span><span class="s2">?: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedModuleWithFailedLookupLocations</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">nodeModuleNameResolver(</span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">compilerOptions</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ModuleResolutionHost</span><span class="s1">, </span><span class="s3">cache</span><span class="s2">?: </span><span class="s3">ModuleResolutionCache</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">?: </span><span class="s3">ResolvedProjectReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedModuleWithFailedLookupLocations</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">classicNameResolver(</span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">compilerOptions</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ModuleResolutionHost</span><span class="s1">, </span><span class="s3">cache</span><span class="s2">?: </span><span class="s3">NonRelativeModuleNameResolutionCache</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">?: </span><span class="s3">ResolvedProjectReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedModuleWithFailedLookupLocations</span><span class="s1">;</span>
    <span class="s2">export </span><span class="s1">{};</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits a Node using the supplied visitor, possibly returning a new Node in its place. 
     * 
     * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The Node to visit. 
     * </span><span class="s2">@param </span><span class="s3">visitor </span><span class="s0">The callback used to visit the Node. 
     * </span><span class="s2">@param </span><span class="s3">test </span><span class="s0">A callback to execute to verify the Node is valid. 
     * </span><span class="s2">@param </span><span class="s3">lift </span><span class="s0">An optional callback to execute to lift a NodeArray into a valid Node. 
     */</span>
    <span class="s2">function </span><span class="s1">visitNode&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">test</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s5">lift</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: readonly </span><span class="s3">Node</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits a Node using the supplied visitor, possibly returning a new Node in its place. 
     * 
     * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The Node to visit. 
     * </span><span class="s2">@param </span><span class="s3">visitor </span><span class="s0">The callback used to visit the Node. 
     * </span><span class="s2">@param </span><span class="s3">test </span><span class="s0">A callback to execute to verify the Node is valid. 
     * </span><span class="s2">@param </span><span class="s3">lift </span><span class="s0">An optional callback to execute to lift a NodeArray into a valid Node. 
     */</span>
    <span class="s2">function </span><span class="s1">visitNode&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">test</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s5">lift</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: readonly </span><span class="s3">Node</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place. 
     * 
     * </span><span class="s2">@param </span><span class="s3">nodes </span><span class="s0">The NodeArray to visit. 
     * </span><span class="s2">@param </span><span class="s3">visitor </span><span class="s0">The callback used to visit a Node. 
     * </span><span class="s2">@param </span><span class="s3">test </span><span class="s0">A node test to execute for each node. 
     * </span><span class="s2">@param </span><span class="s3">start </span><span class="s0">An optional value indicating the starting offset at which to start visiting. 
     * </span><span class="s2">@param </span><span class="s3">count </span><span class="s0">An optional value indicating the maximum number of nodes to visit. 
     */</span>
    <span class="s2">function </span><span class="s1">visitNodes&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">test</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">start</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">count</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place. 
     * 
     * </span><span class="s2">@param </span><span class="s3">nodes </span><span class="s0">The NodeArray to visit. 
     * </span><span class="s2">@param </span><span class="s3">visitor </span><span class="s0">The callback used to visit a Node. 
     * </span><span class="s2">@param </span><span class="s3">test </span><span class="s0">A node test to execute for each node. 
     * </span><span class="s2">@param </span><span class="s3">start </span><span class="s0">An optional value indicating the starting offset at which to start visiting. 
     * </span><span class="s2">@param </span><span class="s3">count </span><span class="s0">An optional value indicating the maximum number of nodes to visit. 
     */</span>
    <span class="s2">function </span><span class="s1">visitNodes&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">test</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">start</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">count</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Starts a new lexical environment and visits a statement list, ending the lexical environment 
     * and merging hoisted declarations upon completion. 
     */</span>
    <span class="s2">function </span><span class="s1">visitLexicalEnvironment(</span><span class="s3">statements</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Statement</span><span class="s1">&gt;, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">, </span><span class="s3">start</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">ensureUseStrict</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">nodesVisitor</span><span class="s2">?: </span><span class="s3">NodesVisitor</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Statement</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Starts a new lexical environment and visits a parameter list, suspending the lexical 
     * environment upon completion. 
     */</span>
    <span class="s2">function </span><span class="s1">visitParameterList(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">, </span><span class="s3">nodesVisitor</span><span class="s2">?: </span><span class="s3">NodesVisitor</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;;</span>
    <span class="s2">function </span><span class="s1">visitParameterList(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">, </span><span class="s3">nodesVisitor</span><span class="s2">?: </span><span class="s3">NodesVisitor</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resumes a suspended lexical environment and visits a function body, ending the lexical 
     * environment and merging hoisted declarations upon completion. 
     */</span>
    <span class="s2">function </span><span class="s1">visitFunctionBody(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionBody</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionBody</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resumes a suspended lexical environment and visits a function body, ending the lexical 
     * environment and merging hoisted declarations upon completion. 
     */</span>
    <span class="s2">function </span><span class="s1">visitFunctionBody(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resumes a suspended lexical environment and visits a concise body, ending the lexical 
     * environment and merging hoisted declarations upon completion. 
     */</span>
    <span class="s2">function </span><span class="s1">visitFunctionBody(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits an iteration body, adding any block-scoped variables required by the transformation. 
     */</span>
    <span class="s2">function </span><span class="s1">visitIterationBody(</span><span class="s3">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place. 
     * 
     * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The Node whose children will be visited. 
     * </span><span class="s2">@param </span><span class="s3">visitor </span><span class="s0">The callback used to visit each child. 
     * </span><span class="s2">@param </span><span class="s3">context </span><span class="s0">A lexical environment context for the visitor. 
     */</span>
    <span class="s2">function </span><span class="s1">visitEachChild&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place. 
     * 
     * </span><span class="s2">@param </span><span class="s3">node </span><span class="s0">The Node whose children will be visited. 
     * </span><span class="s2">@param </span><span class="s3">visitor </span><span class="s0">The callback used to visit each child. 
     * </span><span class="s2">@param </span><span class="s3">context </span><span class="s0">A lexical environment context for the visitor. 
     */</span>
    <span class="s2">function </span><span class="s1">visitEachChild&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">visitor</span><span class="s2">: </span><span class="s3">Visitor</span><span class="s1">, </span><span class="s3">context</span><span class="s2">: </span><span class="s3">TransformationContext</span><span class="s1">, </span><span class="s3">nodesVisitor</span><span class="s2">?: typeof </span><span class="s3">visitNodes</span><span class="s1">, </span><span class="s3">tokenVisitor</span><span class="s2">?: </span><span class="s3">Visitor</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">function </span><span class="s1">getTsBuildInfoEmitOutputFilePath(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getOutputFileNames(</span><span class="s3">commandLine</span><span class="s2">: </span><span class="s3">ParsedCommandLine</span><span class="s1">, </span><span class="s3">inputFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">ignoreCase</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s2">function </span><span class="s1">createPrinter(</span><span class="s3">printerOptions</span><span class="s2">?: </span><span class="s3">PrinterOptions</span><span class="s1">, </span><span class="s3">handlers</span><span class="s2">?: </span><span class="s3">PrintHandlers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Printer</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">export function </span><span class="s1">findConfigFile(</span><span class="s3">searchPath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s5">fileExists</span><span class="s2">: </span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">configName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">resolveTripleslashReference(</span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">createCompilerHost(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">setParentNodes</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CompilerHost</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">getPreEmitDiagnostics(</span><span class="s3">program</span><span class="s2">: </span><span class="s3">Program</span><span class="s1">, </span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
    <span class="s2">export interface </span><span class="s3">FormatDiagnosticsHost </span><span class="s1">{</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getCanonicalFileName(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getNewLine()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export function </span><span class="s1">formatDiagnostics(</span><span class="s3">diagnostics</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[], </span><span class="s3">host</span><span class="s2">: </span><span class="s3">FormatDiagnosticsHost</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">formatDiagnostic(</span><span class="s3">diagnostic</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">FormatDiagnosticsHost</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">formatDiagnosticsWithColorAndContext(</span><span class="s3">diagnostics</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[], </span><span class="s3">host</span><span class="s2">: </span><span class="s3">FormatDiagnosticsHost</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">flattenDiagnosticMessageText(</span><span class="s3">diag</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">DiagnosticMessageChain </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">newLine</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">indent</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly 
     * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file. 
     */</span>
    <span class="s2">export function </span><span class="s1">getModeForFileReference(</span><span class="s3">ref</span><span class="s2">: </span><span class="s3">FileReference </span><span class="s2">| </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFileMode</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">])</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Calculates the final resolution mode for an import at some index within a file's imports list. This is generally the explicitly 
     * defined mode of the import if provided, or, if not, the mode of the containing file (with some exceptions: import=require is always commonjs, dynamic import is always esm). 
     * If you have an actual import node, prefer using getModeForUsageLocation on the reference string node. 
     * </span><span class="s2">@param </span><span class="s3">file </span><span class="s0">File to fetch the resolution mode within 
     * </span><span class="s2">@param </span><span class="s3">index </span><span class="s0">Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations 
     */</span>
    <span class="s2">export function </span><span class="s1">getModeForResolutionAtIndex(</span><span class="s3">file</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">index</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Calculates the final resolution mode for a given module reference node. This is generally the explicitly provided resolution mode, if 
     * one exists, or the mode of the containing source file. (Excepting import=require, which is always commonjs, and dynamic import, which is always esm). 
     * Notably, this function always returns `undefined` if the containing file has an `undefined` `impliedNodeFormat` - this field is only set when 
     * `moduleResolution` is `node16`+. 
     * </span><span class="s2">@param </span><span class="s3">file </span><span class="s0">The file the import or import-like reference is contained within 
     * </span><span class="s2">@param </span><span class="s3">usage </span><span class="s0">The module reference string 
     * </span><span class="s2">@returns </span><span class="s0">The final resolution mode of the import 
     */</span>
    <span class="s2">export function </span><span class="s1">getModeForUsageLocation(</span><span class="s3">file</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">impliedNodeFormat</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">];</span>
    <span class="s1">}, </span><span class="s3">usage</span><span class="s2">: </span><span class="s3">StringLiteralLike</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">getConfigFileParsingDiagnostics(</span><span class="s3">configFileParseResult</span><span class="s2">: </span><span class="s3">ParsedCommandLine</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the 
     * `options` parameter. 
     * 
     * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The normalized absolute path to check the format of (it need not exist on disk) 
     * </span><span class="s2">@param </span><span class="s0">[packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often 
     * </span><span class="s2">@param </span><span class="s3">host </span><span class="s0">The ModuleResolutionHost which can perform the filesystem lookups for package json data 
     * </span><span class="s2">@param </span><span class="s3">options </span><span class="s0">The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution` 
     * </span><span class="s2">@returns </span><span class="s0">`undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format 
     */</span>
    <span class="s2">export function </span><span class="s1">getImpliedNodeFormatForFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">, </span><span class="s3">packageJsonInfoCache</span><span class="s2">: </span><span class="s3">PackageJsonInfoCache </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ModuleResolutionHost</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions' 
     * that represent a compilation unit. 
     * 
     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and 
     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in. 
     * 
     * </span><span class="s2">@param </span><span class="s3">createProgramOptions </span><span class="s0">- The options for creating a program. 
     * </span><span class="s2">@returns </span><span class="s0">A 'Program' object. 
     */</span>
    <span class="s2">export function </span><span class="s1">createProgram(</span><span class="s3">createProgramOptions</span><span class="s2">: </span><span class="s3">CreateProgramOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Program</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions' 
     * that represent a compilation unit. 
     * 
     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and 
     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in. 
     * 
     * </span><span class="s2">@param </span><span class="s3">rootNames </span><span class="s0">- A set of root files. 
     * </span><span class="s2">@param </span><span class="s3">options </span><span class="s0">- The compiler options which should be used. 
     * </span><span class="s2">@param </span><span class="s3">host </span><span class="s0">- The host interacts with the underlying file system. 
     * </span><span class="s2">@param </span><span class="s3">oldProgram </span><span class="s0">- Reuses an old program structure. 
     * </span><span class="s2">@param </span><span class="s3">configFileParsingDiagnostics </span><span class="s0">- error during config file parsing 
     * </span><span class="s2">@returns </span><span class="s0">A 'Program' object. 
     */</span>
    <span class="s2">export function </span><span class="s1">createProgram(</span><span class="s3">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">host</span><span class="s2">?: </span><span class="s3">CompilerHost</span><span class="s1">, </span><span class="s3">oldProgram</span><span class="s2">?: </span><span class="s3">Program</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">Program</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">*/ </span><span class="s2">export interface </span><span class="s3">ResolveProjectReferencePathHost </span><span class="s1">{</span>
        <span class="s1">fileExists(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the target config filename of a project reference. 
     * Note: The file might not exist. 
     */</span>
    <span class="s2">export function </span><span class="s1">resolveProjectReferencePath(</span><span class="s3">ref</span><span class="s2">: </span><span class="s3">ProjectReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedConfigFileName</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">*/ </span><span class="s2">export function </span><span class="s1">resolveProjectReferencePath(</span><span class="s3">host</span><span class="s2">: </span><span class="s3">ResolveProjectReferencePathHost</span><span class="s1">, </span><span class="s3">ref</span><span class="s2">: </span><span class="s3">ProjectReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedConfigFileName</span><span class="s1">;</span>
    <span class="s2">export </span><span class="s1">{};</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">EmitOutput </span><span class="s1">{</span>
        <span class="s1">outputFiles</span><span class="s2">: </span><span class="s3">OutputFile</span><span class="s1">[];</span>
        <span class="s1">emitSkipped</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">OutputFile </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">writeByteOrderMark</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">type </span><span class="s3">AffectedFileResult</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s1">{</span>
        <span class="s1">result</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
        <span class="s1">affected</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">Program</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">BuilderProgramHost </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* return true if file names are treated with case sensitivity 
         */</span>
        <span class="s1">useCaseSensitiveFileNames()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If provided this would be used this hash instead of actual file shape text for detecting changes 
         */</span>
        <span class="s1">createHash</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* When emit or emitNextAffectedFile are called without writeFile, 
         * this callback if present would be used to write files 
         */</span>
        <span class="s1">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Builder to manage the program state changes 
     */</span>
    <span class="s2">interface </span><span class="s3">BuilderProgram </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns current program 
         */</span>
        <span class="s1">getProgram()</span><span class="s2">: </span><span class="s3">Program</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get compiler options of the program 
         */</span>
        <span class="s1">getCompilerOptions()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the source file in the program with file name 
         */</span>
        <span class="s1">getSourceFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get a list of files in the program 
         */</span>
        <span class="s1">getSourceFiles()</span><span class="s2">: readonly </span><span class="s3">SourceFile</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the diagnostics for compiler options 
         */</span>
        <span class="s1">getOptionsDiagnostics(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the diagnostics that dont belong to any file 
         */</span>
        <span class="s1">getGlobalDiagnostics(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the diagnostics from config file parsing 
         */</span>
        <span class="s1">getConfigFileParsingDiagnostics()</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the syntax diagnostics, for all source files if source file is not supplied 
         */</span>
        <span class="s1">getSyntacticDiagnostics(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the declaration diagnostics, for all source files if source file is not supplied 
         */</span>
        <span class="s1">getDeclarationDiagnostics(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">DiagnosticWithLocation</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get all the dependencies of the file 
         */</span>
        <span class="s1">getAllDependencies(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program 
         * The semantic diagnostics are cached and managed here 
         * Note that it is assumed that when asked about semantic diagnostics through this API, 
         * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics 
         * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided, 
         * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics 
         */</span>
        <span class="s1">getSemanticDiagnostics(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Emits the JavaScript and declaration files. 
         * When targetSource file is specified, emits the files corresponding to that source file, 
         * otherwise for the whole program. 
         * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified, 
         * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified, 
         * it will only emit all the affected files instead of whole program 
         * 
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host 
         * in that order would be used to write the files 
         */</span>
        <span class="s1">emit(</span><span class="s3">targetSourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s3">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">customTransformers</span><span class="s2">?: </span><span class="s3">CustomTransformers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EmitResult</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the current directory of the program 
         */</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The builder that caches the semantic diagnostics for the program and handles the changed files and affected files 
     */</span>
    <span class="s2">interface </span><span class="s3">SemanticDiagnosticsBuilderProgram </span><span class="s2">extends </span><span class="s3">BuilderProgram </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the semantic diagnostics from the program for the next affected file and caches it 
         * Returns undefined if the iteration is complete 
         */</span>
        <span class="s1">getSemanticDiagnosticsOfNextAffectedFile(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s5">ignoreSourceFile</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AffectedFileResult</span><span class="s1">&lt;</span><span class="s2">readonly </span><span class="s3">Diagnostic</span><span class="s1">[]&gt;;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The builder that can handle the changes in program and iterate through changed file to emit the files 
     * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files 
     */</span>
    <span class="s2">interface </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram </span><span class="s2">extends </span><span class="s3">SemanticDiagnosticsBuilderProgram </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete 
         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host 
         * in that order would be used to write the files 
         */</span>
        <span class="s1">emitNextAffectedFile(</span><span class="s3">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s3">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">customTransformers</span><span class="s2">?: </span><span class="s3">CustomTransformers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AffectedFileResult</span><span class="s1">&lt;</span><span class="s3">EmitResult</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Create the builder to manage semantic diagnostics and cache them 
     */</span>
    <span class="s2">function </span><span class="s1">createSemanticDiagnosticsBuilderProgram(</span><span class="s3">newProgram</span><span class="s2">: </span><span class="s3">Program</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">BuilderProgramHost</span><span class="s1">, </span><span class="s3">oldProgram</span><span class="s2">?: </span><span class="s3">SemanticDiagnosticsBuilderProgram</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">SemanticDiagnosticsBuilderProgram</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createSemanticDiagnosticsBuilderProgram(</span><span class="s3">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">host</span><span class="s2">?: </span><span class="s3">CompilerHost</span><span class="s1">, </span><span class="s3">oldProgram</span><span class="s2">?: </span><span class="s3">SemanticDiagnosticsBuilderProgram</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[], </span><span class="s3">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">SemanticDiagnosticsBuilderProgram</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Create the builder that can handle the changes in program and iterate through changed files 
     * to emit the those files and manage semantic diagnostics cache as well 
     */</span>
    <span class="s2">function </span><span class="s1">createEmitAndSemanticDiagnosticsBuilderProgram(</span><span class="s3">newProgram</span><span class="s2">: </span><span class="s3">Program</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">BuilderProgramHost</span><span class="s1">, </span><span class="s3">oldProgram</span><span class="s2">?: </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createEmitAndSemanticDiagnosticsBuilderProgram(</span><span class="s3">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">host</span><span class="s2">?: </span><span class="s3">CompilerHost</span><span class="s1">, </span><span class="s3">oldProgram</span><span class="s2">?: </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[], </span><span class="s3">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a builder thats just abstraction over program and can be used with watch 
     */</span>
    <span class="s2">function </span><span class="s1">createAbstractBuilder(</span><span class="s3">newProgram</span><span class="s2">: </span><span class="s3">Program</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">BuilderProgramHost</span><span class="s1">, </span><span class="s3">oldProgram</span><span class="s2">?: </span><span class="s3">BuilderProgram</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">BuilderProgram</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createAbstractBuilder(</span><span class="s3">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">host</span><span class="s2">?: </span><span class="s3">CompilerHost</span><span class="s1">, </span><span class="s3">oldProgram</span><span class="s2">?: </span><span class="s3">BuilderProgram</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[], </span><span class="s3">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">BuilderProgram</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">ReadBuildProgramHost </span><span class="s1">{</span>
        <span class="s1">useCaseSensitiveFileNames()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">readFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">readBuilderProgram(</span><span class="s3">compilerOptions</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ReadBuildProgramHost</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createIncrementalCompilerHost(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">system</span><span class="s2">?: </span><span class="s3">System</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CompilerHost</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">IncrementalProgramOptions</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; {</span>
        <span class="s1">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[];</span>
        <span class="s1">host</span><span class="s2">?: </span><span class="s3">CompilerHost</span><span class="s1">;</span>
        <span class="s1">createProgram</span><span class="s2">?: </span><span class="s3">CreateProgram</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">createIncrementalProgram&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram </span><span class="s2">= </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s1">&gt;({ </span><span class="s3">rootNames</span><span class="s1">, </span><span class="s3">options</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s1">, </span><span class="s3">projectReferences</span><span class="s1">, </span><span class="s3">host</span><span class="s1">, </span><span class="s3">createProgram </span><span class="s1">}</span><span class="s2">: </span><span class="s3">IncrementalProgramOptions</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">WatchStatusReporter </span><span class="s2">= </span><span class="s1">(</span><span class="s3">diagnostic</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">, </span><span class="s3">newLine</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">errorCount</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s0">/** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */</span>
    <span class="s2">type </span><span class="s3">CreateProgram</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s1">(</span><span class="s3">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">host</span><span class="s2">?: </span><span class="s3">CompilerHost</span><span class="s1">, </span><span class="s3">oldProgram</span><span class="s2">?: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">configFileParsingDiagnostics</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[], </span><span class="s3">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">;</span>
    <span class="s0">/** Host that has watch functionality used in --watch mode */</span>
    <span class="s2">interface </span><span class="s3">WatchHost </span><span class="s1">{</span>
        <span class="s0">/** If provided, called with Diagnostic message that informs about change in watch status */</span>
        <span class="s1">onWatchStatusChange</span><span class="s2">?</span><span class="s1">(</span><span class="s3">diagnostic</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">, </span><span class="s3">newLine</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">errorCount</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** Used to watch changes in source files, missing files needed to update the program or config file */</span>
        <span class="s1">watchFile(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">callback</span><span class="s2">: </span><span class="s3">FileWatcherCallback</span><span class="s1">, </span><span class="s3">pollingInterval</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FileWatcher</span><span class="s1">;</span>
        <span class="s0">/** Used to watch resolved module's failed lookup locations, config file specs, type roots where auto type reference directives are added */</span>
        <span class="s1">watchDirectory(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">callback</span><span class="s2">: </span><span class="s3">DirectoryWatcherCallback</span><span class="s1">, </span><span class="s3">recursive</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FileWatcher</span><span class="s1">;</span>
        <span class="s0">/** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */</span>
        <span class="s1">setTimeout</span><span class="s2">?</span><span class="s1">(</span><span class="s5">callback</span><span class="s2">: </span><span class="s1">(</span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s3">ms</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s0">/** If provided, will be used to reset existing delayed compilation */</span>
        <span class="s1">clearTimeout</span><span class="s2">?</span><span class="s1">(</span><span class="s3">timeoutId</span><span class="s2">: </span><span class="s3">any</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProgramHost</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; {</span>
        <span class="s0">/**</span>
         <span class="s0">* Used to create the program when need for program creation or recreation detected 
         */</span>
        <span class="s1">createProgram</span><span class="s2">: </span><span class="s3">CreateProgram</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
        <span class="s1">useCaseSensitiveFileNames()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getNewLine()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getDefaultLibFileName(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getDefaultLibLocation</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">createHash</span><span class="s2">?</span><span class="s1">(</span><span class="s3">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Use to check file presence for source files and 
         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well 
         */</span>
        <span class="s1">fileExists(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Use to read file text for source files and 
         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well 
         */</span>
        <span class="s1">readFile(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">encoding</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** If provided, used for module resolution as well as to handle directory structure */</span>
        <span class="s1">directoryExists</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** If provided, used in resolutions as well as handling directory structure */</span>
        <span class="s1">getDirectories</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/** If provided, used to cache and handle directory structure modifications */</span>
        <span class="s1">readDirectory</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">extensions</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">exclude</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">include</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">depth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/** Symbol links resolution */</span>
        <span class="s1">realpath</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** If provided would be used to write log about compilation */</span>
        <span class="s1">trace</span><span class="s2">?</span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** If provided is used to get the environment variable */</span>
        <span class="s1">getEnvironmentVariable</span><span class="s2">?</span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** If provided, used to resolve the module names, otherwise typescript's default module resolution */</span>
        <span class="s1">resolveModuleNames</span><span class="s2">?</span><span class="s1">(</span><span class="s3">moduleNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">reusedNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">: </span><span class="s3">ResolvedProjectReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">containingSourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ResolvedModule </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
        <span class="s0">/** If provided, used to resolve type reference directives, otherwise typescript's default resolution */</span>
        <span class="s1">resolveTypeReferenceDirectives</span><span class="s2">?</span><span class="s1">(</span><span class="s3">typeReferenceDirectiveNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| readonly </span><span class="s3">FileReference</span><span class="s1">[], </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">: </span><span class="s3">ResolvedProjectReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">containingFileMode</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it 
         */</span>
        <span class="s1">getModuleResolutionCache</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">ModuleResolutionCache </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">WatchCompilerHost</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ProgramHost</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">WatchHost </span><span class="s1">{</span>
        <span class="s0">/** Instead of using output d.ts file from project reference, use its source file */</span>
        <span class="s1">useSourceOfProjectReferenceRedirect</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** If provided, use this method to get parsed command lines for referenced projects */</span>
        <span class="s1">getParsedCommandLine</span><span class="s2">?</span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParsedCommandLine </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** If provided, callback to invoke after every new program creation */</span>
        <span class="s1">afterProgramCreate</span><span class="s2">?</span><span class="s1">(</span><span class="s3">program</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Host to create watch with root files and options 
     */</span>
    <span class="s2">interface </span><span class="s3">WatchCompilerHostOfFilesAndCompilerOptions</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">WatchCompilerHost</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s0">/** root files to use to generate program */</span>
        <span class="s1">rootFiles</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/** Compiler options */</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">watchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">;</span>
        <span class="s0">/** Project References */</span>
        <span class="s1">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Host to create watch with config file 
     */</span>
    <span class="s2">interface </span><span class="s3">WatchCompilerHostOfConfigFile</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">WatchCompilerHost</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">ConfigFileDiagnosticsReporter </span><span class="s1">{</span>
        <span class="s0">/** Name of the config file to compile */</span>
        <span class="s1">configFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** Options to extend */</span>
        <span class="s1">optionsToExtend</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">watchOptionsToExtend</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">;</span>
        <span class="s1">extraFileExtensions</span><span class="s2">?: readonly </span><span class="s3">FileExtensionInfo</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Used to generate source file names from the config file and its include, exclude, files rules 
         * and also to cache the directory stucture 
         */</span>
        <span class="s1">readDirectory(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">extensions</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">exclude</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">include</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">depth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">Watch</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s0">/** Synchronize with host and get updated program */</span>
        <span class="s1">getProgram()</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
        <span class="s0">/** Closes the watch */</span>
        <span class="s1">close()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the watch what generates program using the config file 
     */</span>
    <span class="s2">interface </span><span class="s3">WatchOfConfigFile</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">Watch</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the watch that generates program using the root files and compiler options 
     */</span>
    <span class="s2">interface </span><span class="s3">WatchOfFilesAndCompilerOptions</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">Watch</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s0">/** Updates the root files in the program, only if this is not config file compilation */</span>
        <span class="s1">updateRootFileNames(</span><span class="s3">fileNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Create the watch compiler host for either configFile or fileNames and its options 
     */</span>
    <span class="s2">function </span><span class="s1">createWatchCompilerHost&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt;(</span><span class="s3">configFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">optionsToExtend</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">system</span><span class="s2">: </span><span class="s3">System</span><span class="s1">, </span><span class="s3">createProgram</span><span class="s2">?: </span><span class="s3">CreateProgram</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">reportDiagnostic</span><span class="s2">?: </span><span class="s3">DiagnosticReporter</span><span class="s1">, </span><span class="s3">reportWatchStatus</span><span class="s2">?: </span><span class="s3">WatchStatusReporter</span><span class="s1">, </span><span class="s3">watchOptionsToExtend</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">, </span><span class="s3">extraFileExtensions</span><span class="s2">?: readonly </span><span class="s3">FileExtensionInfo</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">WatchCompilerHostOfConfigFile</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s2">function </span><span class="s1">createWatchCompilerHost&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt;(</span><span class="s3">rootFiles</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">system</span><span class="s2">: </span><span class="s3">System</span><span class="s1">, </span><span class="s3">createProgram</span><span class="s2">?: </span><span class="s3">CreateProgram</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">reportDiagnostic</span><span class="s2">?: </span><span class="s3">DiagnosticReporter</span><span class="s1">, </span><span class="s3">reportWatchStatus</span><span class="s2">?: </span><span class="s3">WatchStatusReporter</span><span class="s1">, </span><span class="s3">projectReferences</span><span class="s2">?: readonly </span><span class="s3">ProjectReference</span><span class="s1">[], </span><span class="s3">watchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">WatchCompilerHostOfFilesAndCompilerOptions</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the watch from the host for root files and compiler options 
     */</span>
    <span class="s2">function </span><span class="s1">createWatchProgram&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt;(</span><span class="s3">host</span><span class="s2">: </span><span class="s3">WatchCompilerHostOfFilesAndCompilerOptions</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">WatchOfFilesAndCompilerOptions</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates the watch from the host for config file 
     */</span>
    <span class="s2">function </span><span class="s1">createWatchProgram&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt;(</span><span class="s3">host</span><span class="s2">: </span><span class="s3">WatchCompilerHostOfConfigFile</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;)</span><span class="s2">: </span><span class="s3">WatchOfConfigFile</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">BuildOptions </span><span class="s1">{</span>
        <span class="s1">dry</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">force</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">verbose</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">incremental</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">assumeChangesOnlyAffectDirectDependencies</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">traceResolution</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">[</span><span class="s3">option</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s3">CompilerOptionsValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">ReportEmitErrorSummary </span><span class="s2">= </span><span class="s1">(</span><span class="s3">errorCount</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">filesInError</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ReportFileInError </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[]) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">ReportFileInError </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SolutionBuilderHostBase</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ProgramHost</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">createDirectory</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Should provide create directory and writeFile if done of invalidatedProjects is not invoked with 
         * writeFileCallback 
         */</span>
        <span class="s1">writeFile</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">writeByteOrderMark</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getCustomTransformers</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CustomTransformers </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getModifiedTime(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Date </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">setModifiedTime(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">date</span><span class="s2">: </span><span class="s3">Date</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">deleteFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getParsedCommandLine</span><span class="s2">?</span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParsedCommandLine </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">reportDiagnostic</span><span class="s2">: </span><span class="s3">DiagnosticReporter</span><span class="s1">;</span>
        <span class="s1">reportSolutionBuilderStatus</span><span class="s2">: </span><span class="s3">DiagnosticReporter</span><span class="s1">;</span>
        <span class="s1">afterProgramEmitAndDiagnostics</span><span class="s2">?</span><span class="s1">(</span><span class="s3">program</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SolutionBuilderHost</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">SolutionBuilderHostBase</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">reportErrorSummary</span><span class="s2">?: </span><span class="s3">ReportEmitErrorSummary</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SolutionBuilderWithWatchHost</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">SolutionBuilderHostBase</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">WatchHost </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SolutionBuilder</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; {</span>
        <span class="s1">build(</span><span class="s3">project</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s3">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">, </span><span class="s5">getCustomTransformers</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CustomTransformers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExitStatus</span><span class="s1">;</span>
        <span class="s1">clean(</span><span class="s3">project</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExitStatus</span><span class="s1">;</span>
        <span class="s1">buildReferences(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s3">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">, </span><span class="s5">getCustomTransformers</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CustomTransformers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExitStatus</span><span class="s1">;</span>
        <span class="s1">cleanReferences(</span><span class="s3">project</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExitStatus</span><span class="s1">;</span>
        <span class="s1">getNextInvalidatedProject(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: </span><span class="s3">InvalidatedProject</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Create a function that reports watch status by writing to the system and handles the formating of the diagnostic 
     */</span>
    <span class="s2">function </span><span class="s1">createBuilderStatusReporter(</span><span class="s3">system</span><span class="s2">: </span><span class="s3">System</span><span class="s1">, </span><span class="s3">pretty</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DiagnosticReporter</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createSolutionBuilderHost&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram </span><span class="s2">= </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s1">&gt;(</span><span class="s3">system</span><span class="s2">?: </span><span class="s3">System</span><span class="s1">, </span><span class="s3">createProgram</span><span class="s2">?: </span><span class="s3">CreateProgram</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">reportDiagnostic</span><span class="s2">?: </span><span class="s3">DiagnosticReporter</span><span class="s1">, </span><span class="s3">reportSolutionBuilderStatus</span><span class="s2">?: </span><span class="s3">DiagnosticReporter</span><span class="s1">, </span><span class="s3">reportErrorSummary</span><span class="s2">?: </span><span class="s3">ReportEmitErrorSummary</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SolutionBuilderHost</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s2">function </span><span class="s1">createSolutionBuilderWithWatchHost&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram </span><span class="s2">= </span><span class="s3">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s1">&gt;(</span><span class="s3">system</span><span class="s2">?: </span><span class="s3">System</span><span class="s1">, </span><span class="s3">createProgram</span><span class="s2">?: </span><span class="s3">CreateProgram</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">reportDiagnostic</span><span class="s2">?: </span><span class="s3">DiagnosticReporter</span><span class="s1">, </span><span class="s3">reportSolutionBuilderStatus</span><span class="s2">?: </span><span class="s3">DiagnosticReporter</span><span class="s1">, </span><span class="s3">reportWatchStatus</span><span class="s2">?: </span><span class="s3">WatchStatusReporter</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SolutionBuilderWithWatchHost</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s2">function </span><span class="s1">createSolutionBuilder&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt;(</span><span class="s3">host</span><span class="s2">: </span><span class="s3">SolutionBuilderHost</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">defaultOptions</span><span class="s2">: </span><span class="s3">BuildOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SolutionBuilder</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s2">function </span><span class="s1">createSolutionBuilderWithWatch&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt;(</span><span class="s3">host</span><span class="s2">: </span><span class="s3">SolutionBuilderWithWatchHost</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;, </span><span class="s3">rootNames</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">defaultOptions</span><span class="s2">: </span><span class="s3">BuildOptions</span><span class="s1">, </span><span class="s3">baseWatchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SolutionBuilder</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s2">enum </span><span class="s3">InvalidatedProjectKind </span><span class="s1">{</span>
        <span class="s3">Build </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">UpdateBundle </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">UpdateOutputFileStamps </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InvalidatedProjectBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">InvalidatedProjectKind</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">project</span><span class="s2">: </span><span class="s3">ResolvedConfigFileName</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly 
         */</span>
        <span class="s1">done(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s3">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">, </span><span class="s3">customTransformers</span><span class="s2">?: </span><span class="s3">CustomTransformers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExitStatus</span><span class="s1">;</span>
        <span class="s1">getCompilerOptions()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">UpdateOutputFileStampsProject </span><span class="s2">extends </span><span class="s3">InvalidatedProjectBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">InvalidatedProjectKind</span><span class="s1">.</span><span class="s3">UpdateOutputFileStamps</span><span class="s1">;</span>
        <span class="s1">updateOutputFileStatmps()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">BuildInvalidedProject</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">InvalidatedProjectBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">InvalidatedProjectKind</span><span class="s1">.</span><span class="s3">Build</span><span class="s1">;</span>
        <span class="s1">getBuilderProgram()</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getProgram()</span><span class="s2">: </span><span class="s3">Program </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSourceFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSourceFiles()</span><span class="s2">: readonly </span><span class="s3">SourceFile</span><span class="s1">[];</span>
        <span class="s1">getOptionsDiagnostics(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">getGlobalDiagnostics(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">getConfigFileParsingDiagnostics()</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">getSyntacticDiagnostics(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">getAllDependencies(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">getSemanticDiagnostics(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">getSemanticDiagnosticsOfNextAffectedFile(</span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s5">ignoreSourceFile</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">AffectedFileResult</span><span class="s1">&lt;</span><span class="s2">readonly </span><span class="s3">Diagnostic</span><span class="s1">[]&gt;;</span>
        <span class="s1">emit(</span><span class="s3">targetSourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">, </span><span class="s3">cancellationToken</span><span class="s2">?: </span><span class="s3">CancellationToken</span><span class="s1">, </span><span class="s3">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">customTransformers</span><span class="s2">?: </span><span class="s3">CustomTransformers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EmitResult </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">UpdateBundleProject</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">InvalidatedProjectBase </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">InvalidatedProjectKind</span><span class="s1">.</span><span class="s3">UpdateBundle</span><span class="s1">;</span>
        <span class="s1">emit(</span><span class="s3">writeFile</span><span class="s2">?: </span><span class="s3">WriteFileCallback</span><span class="s1">, </span><span class="s3">customTransformers</span><span class="s2">?: </span><span class="s3">CustomTransformers</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EmitResult </span><span class="s2">| </span><span class="s3">BuildInvalidedProject</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">InvalidatedProject</span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">BuilderProgram</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s3">UpdateOutputFileStampsProject </span><span class="s2">| </span><span class="s3">BuildInvalidedProject</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">UpdateBundleProject</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">type </span><span class="s3">ActionSet </span><span class="s2">= </span><span class="s4">&quot;action::set&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">ActionInvalidate </span><span class="s2">= </span><span class="s4">&quot;action::invalidate&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">ActionPackageInstalled </span><span class="s2">= </span><span class="s4">&quot;action::packageInstalled&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">EventTypesRegistry </span><span class="s2">= </span><span class="s4">&quot;event::typesRegistry&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">EventBeginInstallTypes </span><span class="s2">= </span><span class="s4">&quot;event::beginInstallTypes&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">EventEndInstallTypes </span><span class="s2">= </span><span class="s4">&quot;event::endInstallTypes&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">EventInitializationFailed </span><span class="s2">= </span><span class="s4">&quot;event::initializationFailed&quot;</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">TypingInstallerResponse </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">ActionSet </span><span class="s2">| </span><span class="s3">ActionInvalidate </span><span class="s2">| </span><span class="s3">EventTypesRegistry </span><span class="s2">| </span><span class="s3">ActionPackageInstalled </span><span class="s2">| </span><span class="s3">EventBeginInstallTypes </span><span class="s2">| </span><span class="s3">EventEndInstallTypes </span><span class="s2">| </span><span class="s3">EventInitializationFailed</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TypingInstallerRequestWithProjectName </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">projectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DiscoverTypings </span><span class="s2">extends </span><span class="s3">TypingInstallerRequestWithProjectName </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">fileNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s2">readonly </span><span class="s1">projectRootPath</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">compilerOptions</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">watchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeAcquisition</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">unresolvedImports</span><span class="s2">: </span><span class="s3">SortedReadonlyArray</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">cachePath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;discover&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CloseProject </span><span class="s2">extends </span><span class="s3">TypingInstallerRequestWithProjectName </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;closeProject&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TypesRegistryRequest </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;typesRegistry&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InstallPackageRequest </span><span class="s2">extends </span><span class="s3">TypingInstallerRequestWithProjectName </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;installPackage&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">fileName</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">packageName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">projectRootPath</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PackageInstalledResponse </span><span class="s2">extends </span><span class="s3">ProjectResponse </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">ActionPackageInstalled</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">success</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InitializationFailedResponse </span><span class="s2">extends </span><span class="s3">TypingInstallerResponse </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">EventInitializationFailed</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">stack</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProjectResponse </span><span class="s2">extends </span><span class="s3">TypingInstallerResponse </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">projectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InvalidateCachedTypings </span><span class="s2">extends </span><span class="s3">ProjectResponse </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">ActionInvalidate</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InstallTypes </span><span class="s2">extends </span><span class="s3">ProjectResponse </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">EventBeginInstallTypes </span><span class="s2">| </span><span class="s3">EventEndInstallTypes</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">eventId</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typingsInstallerVersion</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">packagesToInstall</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">BeginInstallTypes </span><span class="s2">extends </span><span class="s3">InstallTypes </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">EventBeginInstallTypes</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">EndInstallTypes </span><span class="s2">extends </span><span class="s3">InstallTypes </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">EventEndInstallTypes</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">installSuccess</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SetTypings </span><span class="s2">extends </span><span class="s3">ProjectResponse </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">typeAcquisition</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">compilerOptions</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typings</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s2">readonly </span><span class="s1">unresolvedImports</span><span class="s2">: </span><span class="s3">SortedReadonlyArray</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">&gt;;</span>
        <span class="s2">readonly </span><span class="s1">kind</span><span class="s2">: </span><span class="s3">ActionSet</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s1">getSourceFile()</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">getChildCount(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getChildAt(</span><span class="s3">index</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">;</span>
        <span class="s1">getChildren(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">[];</span>
        <span class="s1">getStart(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">includeJsDocComment</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getFullStart()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getEnd()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getWidth(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFileLike</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getFullWidth()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getLeadingTriviaWidth(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getFullText(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getText(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getFirstToken(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getLastToken(</span><span class="s3">sourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">forEachChild&lt;</span><span class="s3">T</span><span class="s1">&gt;(</span><span class="s5">cbNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s5">cbNodeArray</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">nodes</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Node</span><span class="s1">&gt;) </span><span class="s2">=&gt; </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">Identifier </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PrivateIdentifier </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">Symbol </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getFlags()</span><span class="s2">: </span><span class="s3">SymbolFlags</span><span class="s1">;</span>
        <span class="s1">getEscapedName()</span><span class="s2">: </span><span class="s3">__String</span><span class="s1">;</span>
        <span class="s1">getName()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getDeclarations()</span><span class="s2">: </span><span class="s3">Declaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getDocumentationComment(</span><span class="s3">typeChecker</span><span class="s2">: </span><span class="s3">TypeChecker </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">getJsDocTags(</span><span class="s3">checker</span><span class="s2">?: </span><span class="s3">TypeChecker</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JSDocTagInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">Type </span><span class="s1">{</span>
        <span class="s1">getFlags()</span><span class="s2">: </span><span class="s3">TypeFlags</span><span class="s1">;</span>
        <span class="s1">getSymbol()</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getProperties()</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">getProperty(</span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getApparentProperties()</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">getCallSignatures()</span><span class="s2">: readonly </span><span class="s3">Signature</span><span class="s1">[];</span>
        <span class="s1">getConstructSignatures()</span><span class="s2">: readonly </span><span class="s3">Signature</span><span class="s1">[];</span>
        <span class="s1">getStringIndexType()</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getNumberIndexType()</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getBaseTypes()</span><span class="s2">: </span><span class="s3">BaseType</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getNonNullableType()</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getConstraint()</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getDefault()</span><span class="s2">: </span><span class="s3">Type </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">isUnion()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">UnionType</span><span class="s1">;</span>
        <span class="s1">isIntersection()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">IntersectionType</span><span class="s1">;</span>
        <span class="s1">isUnionOrIntersection()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">UnionOrIntersectionType</span><span class="s1">;</span>
        <span class="s1">isLiteral()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">LiteralType</span><span class="s1">;</span>
        <span class="s1">isStringLiteral()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">StringLiteralType</span><span class="s1">;</span>
        <span class="s1">isNumberLiteral()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">NumberLiteralType</span><span class="s1">;</span>
        <span class="s1">isTypeParameter()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">TypeParameter</span><span class="s1">;</span>
        <span class="s1">isClassOrInterface()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">InterfaceType</span><span class="s1">;</span>
        <span class="s1">isClass()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">InterfaceType</span><span class="s1">;</span>
        <span class="s1">isIndexType()</span><span class="s2">: </span><span class="s3">this </span><span class="s2">is </span><span class="s3">IndexType</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TypeReference </span><span class="s1">{</span>
        <span class="s1">typeArguments</span><span class="s2">?: readonly </span><span class="s3">Type</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">Signature </span><span class="s1">{</span>
        <span class="s1">getDeclaration()</span><span class="s2">: </span><span class="s3">SignatureDeclaration</span><span class="s1">;</span>
        <span class="s1">getTypeParameters()</span><span class="s2">: </span><span class="s3">TypeParameter</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getParameters()</span><span class="s2">: </span><span class="s3">Symbol</span><span class="s1">[];</span>
        <span class="s1">getTypeParameterAtPosition(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getReturnType()</span><span class="s2">: </span><span class="s3">Type</span><span class="s1">;</span>
        <span class="s1">getDocumentationComment(</span><span class="s3">typeChecker</span><span class="s2">: </span><span class="s3">TypeChecker </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">getJsDocTags()</span><span class="s2">: </span><span class="s3">JSDocTagInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SourceFile </span><span class="s1">{</span>
        <span class="s1">getLineAndCharacterOfPosition(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LineAndCharacter</span><span class="s1">;</span>
        <span class="s1">getLineEndOfPosition(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getLineStarts()</span><span class="s2">: readonly </span><span class="s3">number</span><span class="s1">[];</span>
        <span class="s1">getPositionOfLineAndCharacter(</span><span class="s3">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">character</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">update(</span><span class="s3">newText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">textChangeRange</span><span class="s2">: </span><span class="s3">TextChangeRange</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SourceFileLike </span><span class="s1">{</span>
        <span class="s1">getLineAndCharacterOfPosition(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LineAndCharacter</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SourceMapSource </span><span class="s1">{</span>
        <span class="s1">getLineAndCharacterOfPosition(</span><span class="s3">pos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LineAndCharacter</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents an immutable snapshot of a script at a specified time.Once acquired, the 
     * snapshot is observably immutable. i.e. the same calls with the same parameters will return 
     * the same values. 
     */</span>
    <span class="s2">interface </span><span class="s3">IScriptSnapshot </span><span class="s1">{</span>
        <span class="s0">/** Gets a portion of the script snapshot specified by [start, end). */</span>
        <span class="s1">getText(</span><span class="s3">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** Gets the length of this script snapshot. */</span>
        <span class="s1">getLength()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the TextChangeRange that describe how the text changed between this text and 
         * an older version.  This information is used by the incremental parser to determine 
         * what sections of the script need to be re-parsed.  'undefined' can be returned if the 
         * change range cannot be determined.  However, in that case, incremental parsing will 
         * not happen and the entire document will be re - parsed. 
         */</span>
        <span class="s1">getChangeRange(</span><span class="s3">oldSnapshot</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChangeRange </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Releases all resources held by this script snapshot */</span>
        <span class="s1">dispose</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">namespace </span><span class="s3">ScriptSnapshot </span><span class="s1">{</span>
        <span class="s2">function </span><span class="s1">fromString(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PreProcessedFileInfo </span><span class="s1">{</span>
        <span class="s1">referencedFiles</span><span class="s2">: </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">typeReferenceDirectives</span><span class="s2">: </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">libReferenceDirectives</span><span class="s2">: </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">importedFiles</span><span class="s2">: </span><span class="s3">FileReference</span><span class="s1">[];</span>
        <span class="s1">ambientExternalModules</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">isLibFile</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">HostCancellationToken </span><span class="s1">{</span>
        <span class="s1">isCancellationRequested()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InstallPackageOptions </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">;</span>
        <span class="s1">packageName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PerformanceEvent </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;UpdateGraph&quot; </span><span class="s2">| </span><span class="s4">&quot;CreatePackageJsonAutoImportProvider&quot;</span><span class="s1">;</span>
        <span class="s1">durationMs</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">LanguageServiceMode </span><span class="s1">{</span>
        <span class="s3">Semantic </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">PartialSemantic </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Syntactic </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">IncompleteCompletionsCache </span><span class="s1">{</span>
        <span class="s1">get()</span><span class="s2">: </span><span class="s3">CompletionInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">set(</span><span class="s3">response</span><span class="s2">: </span><span class="s3">CompletionInfo</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">clear()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">LanguageServiceHost </span><span class="s2">extends </span><span class="s3">GetEffectiveTypeRootsHost</span><span class="s1">, </span><span class="s3">MinimalResolutionCacheHost </span><span class="s1">{</span>
        <span class="s1">getCompilationSettings()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">getNewLine</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getProjectVersion</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getScriptFileNames()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">getScriptKind</span><span class="s2">?</span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptKind</span><span class="s1">;</span>
        <span class="s1">getScriptVersion(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getScriptSnapshot(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IScriptSnapshot </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getProjectReferences</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: readonly </span><span class="s3">ProjectReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getLocalizedDiagnosticMessages</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s1">getCancellationToken</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">HostCancellationToken</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getDefaultLibFileName(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">log</span><span class="s2">?</span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">trace</span><span class="s2">?</span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">error</span><span class="s2">?</span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">readDirectory</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">extensions</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">exclude</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">include</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">depth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">realpath</span><span class="s2">?</span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">readFile(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">encoding</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">fileExists(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getTypeRootsVersion</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">resolveModuleNames</span><span class="s2">?</span><span class="s1">(</span><span class="s3">moduleNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">reusedNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">: </span><span class="s3">ResolvedProjectReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">containingSourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ResolvedModule </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
        <span class="s1">getResolvedModuleWithFailedLookupLocationsFromCache</span><span class="s2">?</span><span class="s1">(</span><span class="s3">modulename</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">resolutionMode</span><span class="s2">?: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedModuleWithFailedLookupLocations </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">resolveTypeReferenceDirectives</span><span class="s2">?</span><span class="s1">(</span><span class="s3">typeDirectiveNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">FileReference</span><span class="s1">[], </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">: </span><span class="s3">ResolvedProjectReference </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">containingFileMode</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
        <span class="s1">getDirectories</span><span class="s2">?</span><span class="s1">(</span><span class="s3">directoryName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets a set of custom transformers to use during emit. 
         */</span>
        <span class="s1">getCustomTransformers</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">CustomTransformers </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">isKnownTypesPackageName</span><span class="s2">?</span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">installPackage</span><span class="s2">?</span><span class="s1">(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">InstallPackageOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">&gt;;</span>
        <span class="s1">writeFile</span><span class="s2">?</span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">content</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getParsedCommandLine</span><span class="s2">?</span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParsedCommandLine </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">WithMetadata</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s3">T </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">metadata</span><span class="s2">?: </span><span class="s3">unknown</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">enum </span><span class="s3">SemanticClassificationFormat </span><span class="s1">{</span>
        <span class="s3">Original </span><span class="s2">= </span><span class="s4">&quot;original&quot;</span><span class="s1">,</span>
        <span class="s3">TwentyTwenty </span><span class="s2">= </span><span class="s4">&quot;2020&quot;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">LanguageService </span><span class="s1">{</span>
        <span class="s0">/** This is used as a part of restarting the language service. */</span>
        <span class="s1">cleanupSemanticCache()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets errors indicating invalid syntax in a file. 
         * 
         * In English, &quot;this cdeo have, erorrs&quot; is syntactically invalid because it has typos, 
         * grammatical errors, and misplaced punctuation. Likewise, examples of syntax 
         * errors in TypeScript are missing parentheses in an `if` statement, mismatched 
         * curly braces, and using a reserved keyword as a variable name. 
         * 
         * These diagnostics are inexpensive to compute and don't require knowledge of 
         * other files. Note that a non-empty result increases the likelihood of false positives 
         * from `getSemanticDiagnostics`. 
         * 
         * While these represent the majority of syntax-related diagnostics, there are some 
         * that require the type system, which will be present in `getSemanticDiagnostics`. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">A path to the file you want syntactic diagnostics for 
         */</span>
        <span class="s1">getSyntacticDiagnostics(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DiagnosticWithLocation</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets warnings or errors indicating type system issues in a given file. 
         * Requesting semantic diagnostics may start up the type system and 
         * run deferred work, so the first call may take longer than subsequent calls. 
         * 
         * Unlike the other get*Diagnostics functions, these diagnostics can potentially not 
         * include a reference to a source file. Specifically, the first time this is called, 
         * it will return global diagnostics with no associated location. 
         * 
         * To contrast the differences between semantic and syntactic diagnostics, consider the 
         * sentence: &quot;The sun is green.&quot; is syntactically correct; those are real English words with 
         * correct sentence structure. However, it is semantically invalid, because it is not true. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">A path to the file you want semantic diagnostics for 
         */</span>
        <span class="s1">getSemanticDiagnostics(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets suggestion diagnostics for a specific file. These diagnostics tend to 
         * proactively suggest refactors, as opposed to diagnostics that indicate 
         * potentially incorrect runtime behavior. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">A path to the file you want semantic diagnostics for 
         */</span>
        <span class="s1">getSuggestionDiagnostics(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DiagnosticWithLocation</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets global diagnostics related to the program configuration and compiler options. 
         */</span>
        <span class="s1">getCompilerOptionsDiagnostics()</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use getEncodedSyntacticClassifications instead. */</span>
        <span class="s1">getSyntacticClassifications(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassifiedSpan</span><span class="s1">[];</span>
        <span class="s1">getSyntacticClassifications(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">format</span><span class="s2">: </span><span class="s3">SemanticClassificationFormat</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassifiedSpan</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">ClassifiedSpan2020</span><span class="s1">[];</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use getEncodedSemanticClassifications instead. */</span>
        <span class="s1">getSemanticClassifications(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassifiedSpan</span><span class="s1">[];</span>
        <span class="s1">getSemanticClassifications(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">format</span><span class="s2">: </span><span class="s3">SemanticClassificationFormat</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassifiedSpan</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">ClassifiedSpan2020</span><span class="s1">[];</span>
        <span class="s0">/** Encoded as triples of [start, length, ClassificationType]. */</span>
        <span class="s1">getEncodedSyntacticClassifications(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Classifications</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets semantic highlights information for a particular file. Has two formats, an older 
         * version used by VS and a format used by VS Code. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The path to the file 
         * </span><span class="s2">@param </span><span class="s3">position </span><span class="s0">A text span to return results within 
         * </span><span class="s2">@param </span><span class="s3">format </span><span class="s0">Which format to use, defaults to &quot;original&quot; 
         * </span><span class="s2">@returns </span><span class="s0">a number array encoded as triples of [start, length, ClassificationType, ...]. 
         */</span>
        <span class="s1">getEncodedSemanticClassifications(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">format</span><span class="s2">?: </span><span class="s3">SemanticClassificationFormat</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Classifications</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets completion entries at a particular position in a file. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The path to the file 
         * </span><span class="s2">@param </span><span class="s3">position </span><span class="s0">A zero-based index of the character where you want the entries 
         * </span><span class="s2">@param </span><span class="s3">options </span><span class="s0">An object describing how the request was triggered and what kinds 
         * of code actions can be returned with the completions. 
         * </span><span class="s2">@param </span><span class="s3">formattingSettings </span><span class="s0">settings needed for calling formatting functions. 
         */</span>
        <span class="s1">getCompletionsAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">GetCompletionsAtPositionOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">formattingSettings</span><span class="s2">?: </span><span class="s3">FormatCodeSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">WithMetadata</span><span class="s1">&lt;</span><span class="s3">CompletionInfo</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The path to the file 
         * </span><span class="s2">@param </span><span class="s3">position </span><span class="s0">A zero based index of the character where you want the entries 
         * </span><span class="s2">@param </span><span class="s3">entryName </span><span class="s0">The `name` from an existing completion which came from `getCompletionsAtPosition` 
         * </span><span class="s2">@param </span><span class="s3">formatOptions </span><span class="s0">How should code samples in the completions be formatted, can be undefined for backwards compatibility 
         * </span><span class="s2">@param </span><span class="s3">source </span><span class="s0">`source` property from the completion entry 
         * </span><span class="s2">@param </span><span class="s3">preferences </span><span class="s0">User settings, can be undefined for backwards compatibility 
         * </span><span class="s2">@param </span><span class="s3">data </span><span class="s0">`data` property from the completion entry 
         */</span>
        <span class="s1">getCompletionEntryDetails(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">entryName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">formatOptions</span><span class="s2">: </span><span class="s3">FormatCodeOptions </span><span class="s2">| </span><span class="s3">FormatCodeSettings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">source</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">data</span><span class="s2">: </span><span class="s3">CompletionEntryData </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CompletionEntryDetails </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getCompletionEntrySymbol(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">source</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Symbol </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Gets semantic information about the identifier at a particular position in a 
         * file. Quick info is what you typically see when you hover in an editor. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The path to the file 
         * </span><span class="s2">@param </span><span class="s3">position </span><span class="s0">A zero-based index of the character where you want the quick info 
         */</span>
        <span class="s1">getQuickInfoAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">QuickInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getNameOrDottedNameSpan(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">startPos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">endPos</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getBreakpointStatementAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSignatureHelpItems(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">SignatureHelpItemsOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SignatureHelpItems </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getRenameInfo(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences</span><span class="s1">)</span><span class="s2">: </span><span class="s3">RenameInfo</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use the signature with `UserPreferences` instead. */</span>
        <span class="s1">getRenameInfo(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">RenameInfoOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">RenameInfo</span><span class="s1">;</span>
        <span class="s1">findRenameLocations(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">findInStrings</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">findInComments</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">providePrefixAndSuffixTextForRename</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">RenameLocation</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSmartSelectionRange(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SelectionRange</span><span class="s1">;</span>
        <span class="s1">getDefinitionAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">DefinitionInfo</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getDefinitionAndBoundSpan(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DefinitionInfoAndBoundSpan </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getTypeDefinitionAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">DefinitionInfo</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getImplementationAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">ImplementationLocation</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getReferencesAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ReferenceEntry</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">findReferences(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ReferencedSymbol</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getDocumentHighlights(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">filesToSearch</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">DocumentHighlights</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getFileReferences(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ReferenceEntry</span><span class="s1">[];</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">*/</span>
        <span class="s1">getOccurrencesAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">ReferenceEntry</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getNavigateToItems(</span><span class="s3">searchValue</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">maxResultCount</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">fileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">excludeDtsFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NavigateToItem</span><span class="s1">[];</span>
        <span class="s1">getNavigationBarItems(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NavigationBarItem</span><span class="s1">[];</span>
        <span class="s1">getNavigationTree(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NavigationTree</span><span class="s1">;</span>
        <span class="s1">prepareCallHierarchy(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallHierarchyItem </span><span class="s2">| </span><span class="s3">CallHierarchyItem</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">provideCallHierarchyIncomingCalls(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallHierarchyIncomingCall</span><span class="s1">[];</span>
        <span class="s1">provideCallHierarchyOutgoingCalls(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallHierarchyOutgoingCall</span><span class="s1">[];</span>
        <span class="s1">provideInlayHints(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">InlayHint</span><span class="s1">[];</span>
        <span class="s1">getOutliningSpans(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">OutliningSpan</span><span class="s1">[];</span>
        <span class="s1">getTodoComments(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">descriptors</span><span class="s2">: </span><span class="s3">TodoCommentDescriptor</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">TodoComment</span><span class="s1">[];</span>
        <span class="s1">getBraceMatchingAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
        <span class="s1">getIndentationAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">EditorOptions </span><span class="s2">| </span><span class="s3">EditorSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">getFormattingEditsForRange(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">FormatCodeOptions </span><span class="s2">| </span><span class="s3">FormatCodeSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChange</span><span class="s1">[];</span>
        <span class="s1">getFormattingEditsForDocument(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">FormatCodeOptions </span><span class="s2">| </span><span class="s3">FormatCodeSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChange</span><span class="s1">[];</span>
        <span class="s1">getFormattingEditsAfterKeystroke(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">key</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">options</span><span class="s2">: </span><span class="s3">FormatCodeOptions </span><span class="s2">| </span><span class="s3">FormatCodeSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChange</span><span class="s1">[];</span>
        <span class="s1">getDocCommentTemplateAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">DocCommentTemplateOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextInsertion </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">isValidBraceCompletionAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">openingBrace</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This will return a defined result if the position is after the `&gt;` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag. 
         * Editors should call this after `&gt;` is typed. 
         */</span>
        <span class="s1">getJsxClosingTagAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">JsxClosingTagInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getSpanOfEnclosingComment(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">onlyMultiLine</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">toLineColumnOffset</span><span class="s2">?</span><span class="s1">(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LineAndCharacter</span><span class="s1">;</span>
        <span class="s1">getCodeFixesAtPosition(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">errorCodes</span><span class="s2">: readonly </span><span class="s3">number</span><span class="s1">[], </span><span class="s3">formatOptions</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">CodeFixAction</span><span class="s1">[];</span>
        <span class="s1">getCombinedCodeFix(</span><span class="s3">scope</span><span class="s2">: </span><span class="s3">CombinedCodeFixScope</span><span class="s1">, </span><span class="s3">fixId</span><span class="s2">: </span><span class="s1">{}, </span><span class="s3">formatOptions</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CombinedCodeActions</span><span class="s1">;</span>
        <span class="s1">applyCodeActionCommand(</span><span class="s3">action</span><span class="s2">: </span><span class="s3">CodeActionCommand</span><span class="s1">, </span><span class="s3">formatSettings</span><span class="s2">?: </span><span class="s3">FormatCodeSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">&gt;;</span>
        <span class="s1">applyCodeActionCommand(</span><span class="s3">action</span><span class="s2">: </span><span class="s3">CodeActionCommand</span><span class="s1">[], </span><span class="s3">formatSettings</span><span class="s2">?: </span><span class="s3">FormatCodeSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">[]&gt;;</span>
        <span class="s1">applyCodeActionCommand(</span><span class="s3">action</span><span class="s2">: </span><span class="s3">CodeActionCommand </span><span class="s2">| </span><span class="s3">CodeActionCommand</span><span class="s1">[], </span><span class="s3">formatSettings</span><span class="s2">?: </span><span class="s3">FormatCodeSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult </span><span class="s2">| </span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">[]&gt;;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">action</span><span class="s2">: </span><span class="s3">CodeActionCommand</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">&gt;;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">action</span><span class="s2">: </span><span class="s3">CodeActionCommand</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">[]&gt;;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">action</span><span class="s2">: </span><span class="s3">CodeActionCommand </span><span class="s2">| </span><span class="s3">CodeActionCommand</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult </span><span class="s2">| </span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">[]&gt;;</span>
        <span class="s1">getApplicableRefactors(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">positionOrRange</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">TextRange</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">triggerReason</span><span class="s2">?: </span><span class="s3">RefactorTriggerReason</span><span class="s1">, </span><span class="s3">kind</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ApplicableRefactorInfo</span><span class="s1">[];</span>
        <span class="s1">getEditsForRefactor(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">formatOptions</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">, </span><span class="s3">positionOrRange</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">TextRange</span><span class="s1">, </span><span class="s3">refactorName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">actionName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">RefactorEditInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">organizeImports(</span><span class="s3">args</span><span class="s2">: </span><span class="s3">OrganizeImportsArgs</span><span class="s1">, </span><span class="s3">formatOptions</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">FileTextChanges</span><span class="s1">[];</span>
        <span class="s1">getEditsForFileRename(</span><span class="s3">oldFilePath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">newFilePath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">formatOptions</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">UserPreferences </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: readonly </span><span class="s3">FileTextChanges</span><span class="s1">[];</span>
        <span class="s1">getEmitOutput(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">forceDtsEmit</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EmitOutput</span><span class="s1">;</span>
        <span class="s1">getProgram()</span><span class="s2">: </span><span class="s3">Program </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">toggleLineComment(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">textRange</span><span class="s2">: </span><span class="s3">TextRange</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChange</span><span class="s1">[];</span>
        <span class="s1">toggleMultilineComment(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">textRange</span><span class="s2">: </span><span class="s3">TextRange</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChange</span><span class="s1">[];</span>
        <span class="s1">commentSelection(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">textRange</span><span class="s2">: </span><span class="s3">TextRange</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChange</span><span class="s1">[];</span>
        <span class="s1">uncommentSelection(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">textRange</span><span class="s2">: </span><span class="s3">TextRange</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextChange</span><span class="s1">[];</span>
        <span class="s1">dispose()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">JsxClosingTagInfo </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">newText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CombinedCodeFixScope </span><span class="s1">{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s4">&quot;file&quot;</span><span class="s1">;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">OrganizeImportsArgs </span><span class="s2">extends </span><span class="s3">CombinedCodeFixScope </span><span class="s1">{</span>
        <span class="s1">skipDestructiveCodeActions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">CompletionsTriggerCharacter </span><span class="s2">= </span><span class="s4">&quot;.&quot; </span><span class="s2">| </span><span class="s4">'&quot;' </span><span class="s2">| </span><span class="s4">&quot;'&quot; </span><span class="s2">| </span><span class="s4">&quot;`&quot; </span><span class="s2">| </span><span class="s4">&quot;/&quot; </span><span class="s2">| </span><span class="s4">&quot;@&quot; </span><span class="s2">| </span><span class="s4">&quot;&lt;&quot; </span><span class="s2">| </span><span class="s4">&quot;#&quot; </span><span class="s2">| </span><span class="s4">&quot; &quot;</span><span class="s1">;</span>
    <span class="s2">enum </span><span class="s3">CompletionTriggerKind </span><span class="s1">{</span>
        <span class="s0">/** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */</span>
        <span class="s3">Invoked </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s0">/** Completion was triggered by a trigger character. */</span>
        <span class="s3">TriggerCharacter </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s0">/** Completion was re-triggered as the current completion list is incomplete. */</span>
        <span class="s3">TriggerForIncompleteCompletions </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">GetCompletionsAtPositionOptions </span><span class="s2">extends </span><span class="s3">UserPreferences </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If the editor is asking for completions because a certain character was typed 
         * (as opposed to when the user explicitly requested them) this should be set. 
         */</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s3">CompletionsTriggerCharacter</span><span class="s1">;</span>
        <span class="s1">triggerKind</span><span class="s2">?: </span><span class="s3">CompletionTriggerKind</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use includeCompletionsForModuleExports */</span>
        <span class="s1">includeExternalModuleExports</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use includeCompletionsWithInsertText */</span>
        <span class="s1">includeInsertTextCompletions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">SignatureHelpTriggerCharacter </span><span class="s2">= </span><span class="s4">&quot;,&quot; </span><span class="s2">| </span><span class="s4">&quot;(&quot; </span><span class="s2">| </span><span class="s4">&quot;&lt;&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">SignatureHelpRetriggerCharacter </span><span class="s2">= </span><span class="s3">SignatureHelpTriggerCharacter </span><span class="s2">| </span><span class="s4">&quot;)&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpItemsOptions </span><span class="s1">{</span>
        <span class="s1">triggerReason</span><span class="s2">?: </span><span class="s3">SignatureHelpTriggerReason</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">SignatureHelpTriggerReason </span><span class="s2">= </span><span class="s3">SignatureHelpInvokedReason </span><span class="s2">| </span><span class="s3">SignatureHelpCharacterTypedReason </span><span class="s2">| </span><span class="s3">SignatureHelpRetriggeredReason</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that the user manually requested signature help. 
     * The language service will unconditionally attempt to provide a result. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpInvokedReason </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;invoked&quot;</span><span class="s1">;</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that the signature help request came from a user typing a character. 
     * Depending on the character and the syntactic context, the request may or may not be served a result. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpCharacterTypedReason </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;characterTyped&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Character that was responsible for triggering signature help. 
         */</span>
        <span class="s1">triggerCharacter</span><span class="s2">: </span><span class="s3">SignatureHelpTriggerCharacter</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that this signature help request came from typing a character or moving the cursor. 
     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust. 
     * The language service will unconditionally attempt to provide a result. 
     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpRetriggeredReason </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;retrigger&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Character that was responsible for triggering signature help. 
         */</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s3">SignatureHelpRetriggerCharacter</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ApplyCodeActionCommandResult </span><span class="s1">{</span>
        <span class="s1">successMessage</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">Classifications </span><span class="s1">{</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s3">number</span><span class="s1">[];</span>
        <span class="s1">endOfLineState</span><span class="s2">: </span><span class="s3">EndOfLineState</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ClassifiedSpan </span><span class="s1">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">classificationType</span><span class="s2">: </span><span class="s3">ClassificationTypeNames</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ClassifiedSpan2020 </span><span class="s1">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">classificationType</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Navigation bar interface designed for visual studio's dual-column layout. 
     * This does not form a proper tree. 
     * The navbar is returned as a list of top-level items, each of which has a list of child items. 
     * Child items always have an empty array for their `childItems`. 
     */</span>
    <span class="s2">interface </span><span class="s3">NavigationBarItem </span><span class="s1">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
        <span class="s1">childItems</span><span class="s2">: </span><span class="s3">NavigationBarItem</span><span class="s1">[];</span>
        <span class="s1">indent</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">bolded</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">grayed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Node in a tree of nested declarations in a file. 
     * The top node is always a script or module node. 
     */</span>
    <span class="s2">interface </span><span class="s3">NavigationTree </span><span class="s1">{</span>
        <span class="s0">/** Name of the declaration, or a short description, e.g. &quot;&lt;class&gt;&quot;. */</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s0">/** ScriptElementKindModifier separated by commas, e.g. &quot;public,abstract&quot; */</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Spans of the nodes that generated this declaration. 
         * There will be more than one if this is the result of merging. 
         */</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
        <span class="s1">nameSpan</span><span class="s2">: </span><span class="s3">TextSpan </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** Present if non-empty */</span>
        <span class="s1">childItems</span><span class="s2">?: </span><span class="s3">NavigationTree</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CallHierarchyItem </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">selectionSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">containerName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CallHierarchyIncomingCall </span><span class="s1">{</span>
        <span class="s1">from</span><span class="s2">: </span><span class="s3">CallHierarchyItem</span><span class="s1">;</span>
        <span class="s1">fromSpans</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CallHierarchyOutgoingCall </span><span class="s1">{</span>
        <span class="s1">to</span><span class="s2">: </span><span class="s3">CallHierarchyItem</span><span class="s1">;</span>
        <span class="s1">fromSpans</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">InlayHintKind </span><span class="s1">{</span>
        <span class="s3">Type </span><span class="s2">= </span><span class="s4">&quot;Type&quot;</span><span class="s1">,</span>
        <span class="s3">Parameter </span><span class="s2">= </span><span class="s4">&quot;Parameter&quot;</span><span class="s1">,</span>
        <span class="s3">Enum </span><span class="s2">= </span><span class="s4">&quot;Enum&quot;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InlayHint </span><span class="s1">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">InlayHintKind</span><span class="s1">;</span>
        <span class="s1">whitespaceBefore</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">whitespaceAfter</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TodoCommentDescriptor </span><span class="s1">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">priority</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TodoComment </span><span class="s1">{</span>
        <span class="s1">descriptor</span><span class="s2">: </span><span class="s3">TodoCommentDescriptor</span><span class="s1">;</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TextChange </span><span class="s1">{</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">newText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FileTextChanges </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">textChanges</span><span class="s2">: readonly </span><span class="s3">TextChange</span><span class="s1">[];</span>
        <span class="s1">isNewFile</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CodeAction </span><span class="s1">{</span>
        <span class="s0">/** Description of the code action to display in the UI of the editor */</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** Text changes to apply to each file as part of the code action */</span>
        <span class="s1">changes</span><span class="s2">: </span><span class="s3">FileTextChanges</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* If the user accepts the code fix, the editor should send the action back in a `applyAction` request. 
         * This allows the language service to have side effects (e.g. installing dependencies) upon a code fix. 
         */</span>
        <span class="s1">commands</span><span class="s2">?: </span><span class="s3">CodeActionCommand</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CodeFixAction </span><span class="s2">extends </span><span class="s3">CodeAction </span><span class="s1">{</span>
        <span class="s0">/** Short name to identify the fix, for use by telemetry. */</span>
        <span class="s1">fixName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If present, one may call 'getCombinedCodeFix' with this fixId. 
         * This may be omitted to indicate that the code fix can't be applied in a group. 
         */</span>
        <span class="s1">fixId</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s1">fixAllDescription</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CombinedCodeActions </span><span class="s1">{</span>
        <span class="s1">changes</span><span class="s2">: readonly </span><span class="s3">FileTextChanges</span><span class="s1">[];</span>
        <span class="s1">commands</span><span class="s2">?: readonly </span><span class="s3">CodeActionCommand</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">CodeActionCommand </span><span class="s2">= </span><span class="s3">InstallPackageAction</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">InstallPackageAction </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A set of one or more available refactoring actions, grouped under a parent refactoring. 
     */</span>
    <span class="s2">interface </span><span class="s3">ApplicableRefactorInfo </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The programmatic name of the refactoring 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A description of this refactoring category to show to the user. 
         * If the refactoring gets inlined (see below), this text will not be visible. 
         */</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Inlineable refactorings can have their actions hoisted out to the top level 
         * of a context menu. Non-inlineanable refactorings should always be shown inside 
         * their parent grouping. 
         * 
         * If not specified, this value is assumed to be 'true' 
         */</span>
        <span class="s1">inlineable</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">actions</span><span class="s2">: </span><span class="s3">RefactorActionInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a single refactoring action - for example, the &quot;Extract Method...&quot; refactor might 
     * offer several actions, each corresponding to a surround class or closure to extract into. 
     */</span>
    <span class="s2">interface </span><span class="s3">RefactorActionInfo </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The programmatic name of the refactoring action 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A description of this refactoring action to show to the user. 
         * If the parent refactoring is inlined away, this will be the only text shown, 
         * so this description should make sense by itself if the parent is inlineable=true 
         */</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A message to show to the user if the refactoring cannot be applied in 
         * the current context. 
         */</span>
        <span class="s1">notApplicableReason</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The hierarchical dotted name of the refactor action. 
         */</span>
        <span class="s1">kind</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A set of edits to make in response to a refactor action, plus an optional 
     * location where renaming should be invoked from 
     */</span>
    <span class="s2">interface </span><span class="s3">RefactorEditInfo </span><span class="s1">{</span>
        <span class="s1">edits</span><span class="s2">: </span><span class="s3">FileTextChanges</span><span class="s1">[];</span>
        <span class="s1">renameFilename</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">renameLocation</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">commands</span><span class="s2">?: </span><span class="s3">CodeActionCommand</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">RefactorTriggerReason </span><span class="s2">= </span><span class="s4">&quot;implicit&quot; </span><span class="s2">| </span><span class="s4">&quot;invoked&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">TextInsertion </span><span class="s1">{</span>
        <span class="s1">newText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** The position in newText the caret should point to after the insertion. */</span>
        <span class="s1">caretOffset</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DocumentSpan </span><span class="s1">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If the span represents a location that was remapped (e.g. via a .d.ts.map file), 
         * then the original filename and span will be specified here 
         */</span>
        <span class="s1">originalTextSpan</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">originalFileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If DocumentSpan.textSpan is the span for name of the declaration, 
         * then this is the span for relevant declaration 
         */</span>
        <span class="s1">contextSpan</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">originalContextSpan</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">RenameLocation </span><span class="s2">extends </span><span class="s3">DocumentSpan </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">prefixText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">suffixText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ReferenceEntry </span><span class="s2">extends </span><span class="s3">DocumentSpan </span><span class="s1">{</span>
        <span class="s1">isWriteAccess</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isInString</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ImplementationLocation </span><span class="s2">extends </span><span class="s3">DocumentSpan </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">HighlightSpanKind </span><span class="s1">{</span>
        <span class="s3">none </span><span class="s2">= </span><span class="s4">&quot;none&quot;</span><span class="s1">,</span>
        <span class="s3">definition </span><span class="s2">= </span><span class="s4">&quot;definition&quot;</span><span class="s1">,</span>
        <span class="s3">reference </span><span class="s2">= </span><span class="s4">&quot;reference&quot;</span><span class="s1">,</span>
        <span class="s3">writtenReference </span><span class="s2">= </span><span class="s4">&quot;writtenReference&quot;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">HighlightSpan </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">isInString</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">contextSpan</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">HighlightSpanKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">NavigateToItem </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">matchKind</span><span class="s2">: </span><span class="s4">&quot;exact&quot; </span><span class="s2">| </span><span class="s4">&quot;prefix&quot; </span><span class="s2">| </span><span class="s4">&quot;substring&quot; </span><span class="s2">| </span><span class="s4">&quot;camelCase&quot;</span><span class="s1">;</span>
        <span class="s1">isCaseSensitive</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">containerName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">containerKind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">IndentStyle </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Block </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Smart </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">SemicolonPreference </span><span class="s1">{</span>
        <span class="s3">Ignore </span><span class="s2">= </span><span class="s4">&quot;ignore&quot;</span><span class="s1">,</span>
        <span class="s3">Insert </span><span class="s2">= </span><span class="s4">&quot;insert&quot;</span><span class="s1">,</span>
        <span class="s3">Remove </span><span class="s2">= </span><span class="s4">&quot;remove&quot;</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">- consider using EditorSettings instead */</span>
    <span class="s2">interface </span><span class="s3">EditorOptions </span><span class="s1">{</span>
        <span class="s1">BaseIndentSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">IndentSize</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">TabSize</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">NewLineCharacter</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">ConvertTabsToSpaces</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">IndentStyle</span><span class="s2">: </span><span class="s3">IndentStyle</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">EditorSettings </span><span class="s1">{</span>
        <span class="s1">baseIndentSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">indentSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">tabSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">newLineCharacter</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">convertTabsToSpaces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">indentStyle</span><span class="s2">?: </span><span class="s3">IndentStyle</span><span class="s1">;</span>
        <span class="s1">trimTrailingWhitespace</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">- consider using FormatCodeSettings instead */</span>
    <span class="s2">interface </span><span class="s3">FormatCodeOptions </span><span class="s2">extends </span><span class="s3">EditorOptions </span><span class="s1">{</span>
        <span class="s1">InsertSpaceAfterCommaDelimiter</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterSemicolonInForStatements</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceBeforeAndAfterBinaryOperators</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterConstructor</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterKeywordsInControlFlowStatements</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterFunctionKeywordForAnonymousFunctions</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceAfterTypeAssertion</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">InsertSpaceBeforeFunctionParenthesis</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">PlaceOpenBraceOnNewLineForFunctions</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">PlaceOpenBraceOnNewLineForControlBlocks</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceBeforeTypeAnnotation</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FormatCodeSettings </span><span class="s2">extends </span><span class="s3">EditorSettings </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterCommaDelimiter</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterSemicolonInForStatements</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceBeforeAndAfterBinaryOperators</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterConstructor</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterKeywordsInControlFlowStatements</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterFunctionKeywordForAnonymousFunctions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterOpeningAndBeforeClosingEmptyBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceAfterTypeAssertion</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceBeforeFunctionParenthesis</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">placeOpenBraceOnNewLineForFunctions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">placeOpenBraceOnNewLineForControlBlocks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">insertSpaceBeforeTypeAnnotation</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">indentMultiLineObjectLiteralBeginningOnBlankLine</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">semicolons</span><span class="s2">?: </span><span class="s3">SemicolonPreference</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">getDefaultFormatCodeSettings(</span><span class="s3">newLineCharacter</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">DefinitionInfo </span><span class="s2">extends </span><span class="s3">DocumentSpan </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">containerKind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">containerName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">unverified</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DefinitionInfoAndBoundSpan </span><span class="s1">{</span>
        <span class="s1">definitions</span><span class="s2">?: readonly </span><span class="s3">DefinitionInfo</span><span class="s1">[];</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ReferencedSymbolDefinitionInfo </span><span class="s2">extends </span><span class="s3">DefinitionInfo </span><span class="s1">{</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ReferencedSymbol </span><span class="s1">{</span>
        <span class="s1">definition</span><span class="s2">: </span><span class="s3">ReferencedSymbolDefinitionInfo</span><span class="s1">;</span>
        <span class="s1">references</span><span class="s2">: </span><span class="s3">ReferencedSymbolEntry</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ReferencedSymbolEntry </span><span class="s2">extends </span><span class="s3">ReferenceEntry </span><span class="s1">{</span>
        <span class="s1">isDefinition</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">SymbolDisplayPartKind </span><span class="s1">{</span>
        <span class="s3">aliasName </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">className </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">enumName </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">fieldName </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">interfaceName </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">keyword </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">lineBreak </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s3">numericLiteral </span><span class="s2">= </span><span class="s6">7</span><span class="s1">,</span>
        <span class="s3">stringLiteral </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">localName </span><span class="s2">= </span><span class="s6">9</span><span class="s1">,</span>
        <span class="s3">methodName </span><span class="s2">= </span><span class="s6">10</span><span class="s1">,</span>
        <span class="s3">moduleName </span><span class="s2">= </span><span class="s6">11</span><span class="s1">,</span>
        <span class="s3">operator </span><span class="s2">= </span><span class="s6">12</span><span class="s1">,</span>
        <span class="s3">parameterName </span><span class="s2">= </span><span class="s6">13</span><span class="s1">,</span>
        <span class="s3">propertyName </span><span class="s2">= </span><span class="s6">14</span><span class="s1">,</span>
        <span class="s3">punctuation </span><span class="s2">= </span><span class="s6">15</span><span class="s1">,</span>
        <span class="s3">space </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">text </span><span class="s2">= </span><span class="s6">17</span><span class="s1">,</span>
        <span class="s3">typeParameterName </span><span class="s2">= </span><span class="s6">18</span><span class="s1">,</span>
        <span class="s3">enumMemberName </span><span class="s2">= </span><span class="s6">19</span><span class="s1">,</span>
        <span class="s3">functionName </span><span class="s2">= </span><span class="s6">20</span><span class="s1">,</span>
        <span class="s3">regularExpressionLiteral </span><span class="s2">= </span><span class="s6">21</span><span class="s1">,</span>
        <span class="s3">link </span><span class="s2">= </span><span class="s6">22</span><span class="s1">,</span>
        <span class="s3">linkName </span><span class="s2">= </span><span class="s6">23</span><span class="s1">,</span>
        <span class="s3">linkText </span><span class="s2">= </span><span class="s6">24</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SymbolDisplayPart </span><span class="s1">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">JSDocLinkDisplayPart </span><span class="s2">extends </span><span class="s3">SymbolDisplayPart </span><span class="s1">{</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s3">DocumentSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">JSDocTagInfo </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">QuickInfo </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">displayParts</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">documentation</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">tags</span><span class="s2">?: </span><span class="s3">JSDocTagInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">RenameInfo </span><span class="s2">= </span><span class="s3">RenameInfoSuccess </span><span class="s2">| </span><span class="s3">RenameInfoFailure</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">RenameInfoSuccess </span><span class="s1">{</span>
        <span class="s1">canRename</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* File or directory to rename. 
         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`. 
         */</span>
        <span class="s1">fileToRename</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">displayName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">fullDisplayName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">triggerSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">RenameInfoFailure </span><span class="s1">{</span>
        <span class="s1">canRename</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">localizedErrorMessage</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Use `UserPreferences` instead. 
     */</span>
    <span class="s2">interface </span><span class="s3">RenameInfoOptions </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">allowRenameOfImportPath</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DocCommentTemplateOptions </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">generateReturnInDocTemplate</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpParameter </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">documentation</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">isOptional</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isRest</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SelectionRange </span><span class="s1">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">parent</span><span class="s2">?: </span><span class="s3">SelectionRange</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a single signature to show in signature help. 
     * The id is used for subsequent calls into the language service to ask questions about the 
     * signature help item in the context of any documents that have been updated.  i.e. after 
     * an edit has happened, while signature help is still active, the host can ask important 
     * questions like 'what parameter is the user currently contained within?'. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpItem </span><span class="s1">{</span>
        <span class="s1">isVariadic</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">prefixDisplayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">suffixDisplayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">separatorDisplayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">parameters</span><span class="s2">: </span><span class="s3">SignatureHelpParameter</span><span class="s1">[];</span>
        <span class="s1">documentation</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">tags</span><span class="s2">: </span><span class="s3">JSDocTagInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a set of signature help items, and the preferred item that should be selected. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpItems </span><span class="s1">{</span>
        <span class="s1">items</span><span class="s2">: </span><span class="s3">SignatureHelpItem</span><span class="s1">[];</span>
        <span class="s1">applicableSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">selectedItemIndex</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">argumentIndex</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">argumentCount</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">CompletionInfoFlags </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">MayIncludeAutoImports </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">IsImportStatementCompletion </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">IsContinuation </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">ResolvedModuleSpecifiers </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">ResolvedModuleSpecifiersBeyondLimit </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">MayIncludeMethodSnippets </span><span class="s2">= </span><span class="s6">32</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionInfo </span><span class="s1">{</span>
        <span class="s0">/** For performance telemetry. */</span>
        <span class="s1">flags</span><span class="s2">?: </span><span class="s3">CompletionInfoFlags</span><span class="s1">;</span>
        <span class="s0">/** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */</span>
        <span class="s1">isGlobalCompletion</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isMemberCompletion</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* In the absence of `CompletionEntry[&quot;replacementSpan&quot;], the editor may choose whether to use 
         * this span or its default one. If `CompletionEntry[&quot;replacementSpan&quot;]` is defined, that span 
         * must be used to commit that completion entry. 
         */</span>
        <span class="s1">optionalReplacementSpan</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* true when the current location also allows for a new identifier 
         */</span>
        <span class="s1">isNewIdentifierLocation</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates to client to continue requesting completions on subsequent keystrokes. 
         */</span>
        <span class="s1">isIncomplete</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">entries</span><span class="s2">: </span><span class="s3">CompletionEntry</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionEntryDataAutoImport </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the property or export in the module's symbol table. Differs from the completion name 
         * in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default. 
         */</span>
        <span class="s1">exportName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">moduleSpecifier</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** The file name declaring the export's module symbol, if it was an external module */</span>
        <span class="s1">fileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** The module name (with quotes stripped) of the export's module symbol, if it was an ambient module */</span>
        <span class="s1">ambientModuleName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** True if the export was found in the package.json AutoImportProvider */</span>
        <span class="s1">isPackageJsonImport</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionEntryDataUnresolved </span><span class="s2">extends </span><span class="s3">CompletionEntryDataAutoImport </span><span class="s1">{</span>
        <span class="s0">/** The key in the `ExportMapCache` where the completion entry's `SymbolExportInfo[]` is found */</span>
        <span class="s1">exportMapKey</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionEntryDataResolved </span><span class="s2">extends </span><span class="s3">CompletionEntryDataAutoImport </span><span class="s1">{</span>
        <span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">CompletionEntryData </span><span class="s2">= </span><span class="s3">CompletionEntryDataUnresolved </span><span class="s2">| </span><span class="s3">CompletionEntryDataResolved</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">CompletionEntry </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">sortText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">insertText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">isSnippet</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional span that indicates the text to be replaced by this completion item. 
         * If present, this span should be used instead of the default one. 
         * It will be set if the required span differs from the one generated by the default replacement behavior. 
         */</span>
        <span class="s1">replacementSpan</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">hasAction</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">sourceDisplay</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">labelDetails</span><span class="s2">?: </span><span class="s3">CompletionEntryLabelDetails</span><span class="s1">;</span>
        <span class="s1">isRecommended</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">isFromUncheckedFile</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">isPackageJsonImport</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">isImportStatementCompletion</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`, 
         * that allows TS Server to look up the symbol represented by the completion item, disambiguating 
         * items with the same name. Currently only defined for auto-import completions, but the type is 
         * `unknown` in the protocol, so it can be changed as needed to support other kinds of completions. 
         * The presence of this property should generally not be used to assume that this completion entry 
         * is an auto-import. 
         */</span>
        <span class="s1">data</span><span class="s2">?: </span><span class="s3">CompletionEntryData</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionEntryLabelDetails </span><span class="s1">{</span>
        <span class="s1">detail</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">description</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionEntryDetails </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">documentation</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">tags</span><span class="s2">?: </span><span class="s3">JSDocTagInfo</span><span class="s1">[];</span>
        <span class="s1">codeActions</span><span class="s2">?: </span><span class="s3">CodeAction</span><span class="s1">[];</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `sourceDisplay` instead. */</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s1">sourceDisplay</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">OutliningSpan </span><span class="s1">{</span>
        <span class="s0">/** The span of the document to actually collapse. */</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s0">/** The span of the document to display when the user hovers over the collapsed span. */</span>
        <span class="s1">hintSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s0">/** The text to display in the editor for the collapsed region. */</span>
        <span class="s1">bannerText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Whether or not this region should be automatically collapsed when 
         * the 'Collapse to Definitions' command is invoked. 
         */</span>
        <span class="s1">autoCollapse</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Classification of the contents of the span 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">OutliningSpanKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">OutliningSpanKind </span><span class="s1">{</span>
        <span class="s0">/** Single or multi-line comments */</span>
        <span class="s3">Comment </span><span class="s2">= </span><span class="s4">&quot;comment&quot;</span><span class="s1">,</span>
        <span class="s0">/** Sections marked by '// #region' and '// #endregion' comments */</span>
        <span class="s3">Region </span><span class="s2">= </span><span class="s4">&quot;region&quot;</span><span class="s1">,</span>
        <span class="s0">/** Declarations and expressions */</span>
        <span class="s3">Code </span><span class="s2">= </span><span class="s4">&quot;code&quot;</span><span class="s1">,</span>
        <span class="s0">/** Contiguous blocks of import declarations */</span>
        <span class="s3">Imports </span><span class="s2">= </span><span class="s4">&quot;imports&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">OutputFileType </span><span class="s1">{</span>
        <span class="s3">JavaScript </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">SourceMap </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Declaration </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">EndOfLineState </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">InMultiLineCommentTrivia </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">InSingleQuoteStringLiteral </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">InDoubleQuoteStringLiteral </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">InTemplateHeadOrNoSubstitutionTemplate </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">InTemplateMiddleOrTail </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">InTemplateSubstitutionPosition </span><span class="s2">= </span><span class="s6">6</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">TokenClass </span><span class="s1">{</span>
        <span class="s3">Punctuation </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Keyword </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">Operator </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">Comment </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">Whitespace </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">Identifier </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">NumberLiteral </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s3">BigIntLiteral </span><span class="s2">= </span><span class="s6">7</span><span class="s1">,</span>
        <span class="s3">StringLiteral </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">RegExpLiteral </span><span class="s2">= </span><span class="s6">9</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ClassificationResult </span><span class="s1">{</span>
        <span class="s1">finalLexState</span><span class="s2">: </span><span class="s3">EndOfLineState</span><span class="s1">;</span>
        <span class="s1">entries</span><span class="s2">: </span><span class="s3">ClassificationInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ClassificationInfo </span><span class="s1">{</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">classification</span><span class="s2">: </span><span class="s3">TokenClass</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">Classifier </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Gives lexical classifications of tokens on a line without any syntactic context. 
         * For instance, a token consisting of the text 'string' can be either an identifier 
         * named 'string' or the keyword 'string', however, because this classifier is not aware, 
         * it relies on certain heuristics to give acceptable results. For classifications where 
         * speed trumps accuracy, this function is preferable; however, for true accuracy, the 
         * syntactic classifier is ideal. In fact, in certain editing scenarios, combining the 
         * lexical, syntactic, and semantic classifiers may issue the best user experience. 
         * 
         * </span><span class="s2">@param </span><span class="s3">text                      </span><span class="s0">The text of a line to classify. 
         * </span><span class="s2">@param </span><span class="s3">lexState                  </span><span class="s0">The state of the lexical classifier at the end of the previous line. 
         * </span><span class="s2">@param </span><span class="s3">syntacticClassifierAbsent </span><span class="s0">Whether the client is *not* using a syntactic classifier. 
         *                                  If there is no syntactic classifier (syntacticClassifierAbsent=true), 
         *                                  certain heuristics may be used in its place; however, if there is a 
         *                                  syntactic classifier (syntacticClassifierAbsent=false), certain 
         *                                  classifications which may be incorrectly categorized will be given 
         *                                  back as Identifiers in order to allow the syntactic classifier to 
         *                                  subsume the classification. 
         * </span><span class="s2">@deprecated </span><span class="s0">Use getLexicalClassifications instead. 
         */</span>
        <span class="s1">getClassificationsForLine(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">lexState</span><span class="s2">: </span><span class="s3">EndOfLineState</span><span class="s1">, </span><span class="s3">syntacticClassifierAbsent</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassificationResult</span><span class="s1">;</span>
        <span class="s1">getEncodedLexicalClassifications(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">endOfLineState</span><span class="s2">: </span><span class="s3">EndOfLineState</span><span class="s1">, </span><span class="s3">syntacticClassifierAbsent</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Classifications</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">ScriptElementKind </span><span class="s1">{</span>
        <span class="s3">unknown </span><span class="s2">= </span><span class="s4">&quot;&quot;</span><span class="s1">,</span>
        <span class="s3">warning </span><span class="s2">= </span><span class="s4">&quot;warning&quot;</span><span class="s1">,</span>
        <span class="s0">/** predefined type (void) or keyword (class) */</span>
        <span class="s3">keyword </span><span class="s2">= </span><span class="s4">&quot;keyword&quot;</span><span class="s1">,</span>
        <span class="s0">/** top level script node */</span>
        <span class="s3">scriptElement </span><span class="s2">= </span><span class="s4">&quot;script&quot;</span><span class="s1">,</span>
        <span class="s0">/** module foo {} */</span>
        <span class="s3">moduleElement </span><span class="s2">= </span><span class="s4">&quot;module&quot;</span><span class="s1">,</span>
        <span class="s0">/** class X {} */</span>
        <span class="s3">classElement </span><span class="s2">= </span><span class="s4">&quot;class&quot;</span><span class="s1">,</span>
        <span class="s0">/** var x = class X {} */</span>
        <span class="s3">localClassElement </span><span class="s2">= </span><span class="s4">&quot;local class&quot;</span><span class="s1">,</span>
        <span class="s0">/** interface Y {} */</span>
        <span class="s3">interfaceElement </span><span class="s2">= </span><span class="s4">&quot;interface&quot;</span><span class="s1">,</span>
        <span class="s0">/** type T = ... */</span>
        <span class="s3">typeElement </span><span class="s2">= </span><span class="s4">&quot;type&quot;</span><span class="s1">,</span>
        <span class="s0">/** enum E */</span>
        <span class="s3">enumElement </span><span class="s2">= </span><span class="s4">&quot;enum&quot;</span><span class="s1">,</span>
        <span class="s3">enumMemberElement </span><span class="s2">= </span><span class="s4">&quot;enum member&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Inside module and script only 
         * const v = .. 
         */</span>
        <span class="s3">variableElement </span><span class="s2">= </span><span class="s4">&quot;var&quot;</span><span class="s1">,</span>
        <span class="s0">/** Inside function */</span>
        <span class="s3">localVariableElement </span><span class="s2">= </span><span class="s4">&quot;local var&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* Inside module and script only 
         * function f() { } 
         */</span>
        <span class="s3">functionElement </span><span class="s2">= </span><span class="s4">&quot;function&quot;</span><span class="s1">,</span>
        <span class="s0">/** Inside function */</span>
        <span class="s3">localFunctionElement </span><span class="s2">= </span><span class="s4">&quot;local function&quot;</span><span class="s1">,</span>
        <span class="s0">/** class X { [public|private]* foo() {} } */</span>
        <span class="s3">memberFunctionElement </span><span class="s2">= </span><span class="s4">&quot;method&quot;</span><span class="s1">,</span>
        <span class="s0">/** class X { [public|private]* [get|set] foo:number; } */</span>
        <span class="s3">memberGetAccessorElement </span><span class="s2">= </span><span class="s4">&quot;getter&quot;</span><span class="s1">,</span>
        <span class="s3">memberSetAccessorElement </span><span class="s2">= </span><span class="s4">&quot;setter&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* class X { [public|private]* foo:number; } 
         * interface Y { foo:number; } 
         */</span>
        <span class="s3">memberVariableElement </span><span class="s2">= </span><span class="s4">&quot;property&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* class X { constructor() { } } 
         * class X { static { } } 
         */</span>
        <span class="s3">constructorImplementationElement </span><span class="s2">= </span><span class="s4">&quot;constructor&quot;</span><span class="s1">,</span>
        <span class="s0">/** interface Y { ():number; } */</span>
        <span class="s3">callSignatureElement </span><span class="s2">= </span><span class="s4">&quot;call&quot;</span><span class="s1">,</span>
        <span class="s0">/** interface Y { []:number; } */</span>
        <span class="s3">indexSignatureElement </span><span class="s2">= </span><span class="s4">&quot;index&quot;</span><span class="s1">,</span>
        <span class="s0">/** interface Y { new():Y; } */</span>
        <span class="s3">constructSignatureElement </span><span class="s2">= </span><span class="s4">&quot;construct&quot;</span><span class="s1">,</span>
        <span class="s0">/** function foo(*Y*: string) */</span>
        <span class="s3">parameterElement </span><span class="s2">= </span><span class="s4">&quot;parameter&quot;</span><span class="s1">,</span>
        <span class="s3">typeParameterElement </span><span class="s2">= </span><span class="s4">&quot;type parameter&quot;</span><span class="s1">,</span>
        <span class="s3">primitiveType </span><span class="s2">= </span><span class="s4">&quot;primitive type&quot;</span><span class="s1">,</span>
        <span class="s3">label </span><span class="s2">= </span><span class="s4">&quot;label&quot;</span><span class="s1">,</span>
        <span class="s3">alias </span><span class="s2">= </span><span class="s4">&quot;alias&quot;</span><span class="s1">,</span>
        <span class="s3">constElement </span><span class="s2">= </span><span class="s4">&quot;const&quot;</span><span class="s1">,</span>
        <span class="s3">letElement </span><span class="s2">= </span><span class="s4">&quot;let&quot;</span><span class="s1">,</span>
        <span class="s3">directory </span><span class="s2">= </span><span class="s4">&quot;directory&quot;</span><span class="s1">,</span>
        <span class="s3">externalModuleName </span><span class="s2">= </span><span class="s4">&quot;external module name&quot;</span><span class="s1">,</span>
        <span class="s0">/**</span>
         <span class="s0">* &lt;JsxTagName attribute1 attribute2={0} /&gt; 
         * </span><span class="s2">@deprecated</span>
         <span class="s0">*/</span>
        <span class="s3">jsxAttribute </span><span class="s2">= </span><span class="s4">&quot;JSX attribute&quot;</span><span class="s1">,</span>
        <span class="s0">/** String literal */</span>
        <span class="s3">string </span><span class="s2">= </span><span class="s4">&quot;string&quot;</span><span class="s1">,</span>
        <span class="s0">/** Jsdoc @link: in `</span><span class="s3">{</span><span class="s2">@link </span><span class="s3">C link text}</span><span class="s0">`, the before and after text &quot;</span><span class="s3">{</span><span class="s2">@link </span><span class="s3">&quot; and &quot;}</span><span class="s0">&quot; */</span>
        <span class="s3">link </span><span class="s2">= </span><span class="s4">&quot;link&quot;</span><span class="s1">,</span>
        <span class="s0">/** Jsdoc @link: in `</span><span class="s3">{</span><span class="s2">@link </span><span class="s3">C link text}</span><span class="s0">`, the entity name &quot;C&quot; */</span>
        <span class="s3">linkName </span><span class="s2">= </span><span class="s4">&quot;link name&quot;</span><span class="s1">,</span>
        <span class="s0">/** Jsdoc @link: in `</span><span class="s3">{</span><span class="s2">@link </span><span class="s3">C link text}</span><span class="s0">`, the link text &quot;link text&quot; */</span>
        <span class="s3">linkText </span><span class="s2">= </span><span class="s4">&quot;link text&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">ScriptElementKindModifier </span><span class="s1">{</span>
        <span class="s3">none </span><span class="s2">= </span><span class="s4">&quot;&quot;</span><span class="s1">,</span>
        <span class="s3">publicMemberModifier </span><span class="s2">= </span><span class="s4">&quot;public&quot;</span><span class="s1">,</span>
        <span class="s3">privateMemberModifier </span><span class="s2">= </span><span class="s4">&quot;private&quot;</span><span class="s1">,</span>
        <span class="s3">protectedMemberModifier </span><span class="s2">= </span><span class="s4">&quot;protected&quot;</span><span class="s1">,</span>
        <span class="s3">exportedModifier </span><span class="s2">= </span><span class="s4">&quot;export&quot;</span><span class="s1">,</span>
        <span class="s3">ambientModifier </span><span class="s2">= </span><span class="s4">&quot;declare&quot;</span><span class="s1">,</span>
        <span class="s3">staticModifier </span><span class="s2">= </span><span class="s4">&quot;static&quot;</span><span class="s1">,</span>
        <span class="s3">abstractModifier </span><span class="s2">= </span><span class="s4">&quot;abstract&quot;</span><span class="s1">,</span>
        <span class="s3">optionalModifier </span><span class="s2">= </span><span class="s4">&quot;optional&quot;</span><span class="s1">,</span>
        <span class="s3">deprecatedModifier </span><span class="s2">= </span><span class="s4">&quot;deprecated&quot;</span><span class="s1">,</span>
        <span class="s3">dtsModifier </span><span class="s2">= </span><span class="s4">&quot;.d.ts&quot;</span><span class="s1">,</span>
        <span class="s3">tsModifier </span><span class="s2">= </span><span class="s4">&quot;.ts&quot;</span><span class="s1">,</span>
        <span class="s3">tsxModifier </span><span class="s2">= </span><span class="s4">&quot;.tsx&quot;</span><span class="s1">,</span>
        <span class="s3">jsModifier </span><span class="s2">= </span><span class="s4">&quot;.js&quot;</span><span class="s1">,</span>
        <span class="s3">jsxModifier </span><span class="s2">= </span><span class="s4">&quot;.jsx&quot;</span><span class="s1">,</span>
        <span class="s3">jsonModifier </span><span class="s2">= </span><span class="s4">&quot;.json&quot;</span><span class="s1">,</span>
        <span class="s3">dmtsModifier </span><span class="s2">= </span><span class="s4">&quot;.d.mts&quot;</span><span class="s1">,</span>
        <span class="s3">mtsModifier </span><span class="s2">= </span><span class="s4">&quot;.mts&quot;</span><span class="s1">,</span>
        <span class="s3">mjsModifier </span><span class="s2">= </span><span class="s4">&quot;.mjs&quot;</span><span class="s1">,</span>
        <span class="s3">dctsModifier </span><span class="s2">= </span><span class="s4">&quot;.d.cts&quot;</span><span class="s1">,</span>
        <span class="s3">ctsModifier </span><span class="s2">= </span><span class="s4">&quot;.cts&quot;</span><span class="s1">,</span>
        <span class="s3">cjsModifier </span><span class="s2">= </span><span class="s4">&quot;.cjs&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">ClassificationTypeNames </span><span class="s1">{</span>
        <span class="s3">comment </span><span class="s2">= </span><span class="s4">&quot;comment&quot;</span><span class="s1">,</span>
        <span class="s3">identifier </span><span class="s2">= </span><span class="s4">&quot;identifier&quot;</span><span class="s1">,</span>
        <span class="s3">keyword </span><span class="s2">= </span><span class="s4">&quot;keyword&quot;</span><span class="s1">,</span>
        <span class="s3">numericLiteral </span><span class="s2">= </span><span class="s4">&quot;number&quot;</span><span class="s1">,</span>
        <span class="s3">bigintLiteral </span><span class="s2">= </span><span class="s4">&quot;bigint&quot;</span><span class="s1">,</span>
        <span class="s3">operator </span><span class="s2">= </span><span class="s4">&quot;operator&quot;</span><span class="s1">,</span>
        <span class="s3">stringLiteral </span><span class="s2">= </span><span class="s4">&quot;string&quot;</span><span class="s1">,</span>
        <span class="s3">whiteSpace </span><span class="s2">= </span><span class="s4">&quot;whitespace&quot;</span><span class="s1">,</span>
        <span class="s3">text </span><span class="s2">= </span><span class="s4">&quot;text&quot;</span><span class="s1">,</span>
        <span class="s3">punctuation </span><span class="s2">= </span><span class="s4">&quot;punctuation&quot;</span><span class="s1">,</span>
        <span class="s3">className </span><span class="s2">= </span><span class="s4">&quot;class name&quot;</span><span class="s1">,</span>
        <span class="s3">enumName </span><span class="s2">= </span><span class="s4">&quot;enum name&quot;</span><span class="s1">,</span>
        <span class="s3">interfaceName </span><span class="s2">= </span><span class="s4">&quot;interface name&quot;</span><span class="s1">,</span>
        <span class="s3">moduleName </span><span class="s2">= </span><span class="s4">&quot;module name&quot;</span><span class="s1">,</span>
        <span class="s3">typeParameterName </span><span class="s2">= </span><span class="s4">&quot;type parameter name&quot;</span><span class="s1">,</span>
        <span class="s3">typeAliasName </span><span class="s2">= </span><span class="s4">&quot;type alias name&quot;</span><span class="s1">,</span>
        <span class="s3">parameterName </span><span class="s2">= </span><span class="s4">&quot;parameter name&quot;</span><span class="s1">,</span>
        <span class="s3">docCommentTagName </span><span class="s2">= </span><span class="s4">&quot;doc comment tag name&quot;</span><span class="s1">,</span>
        <span class="s3">jsxOpenTagName </span><span class="s2">= </span><span class="s4">&quot;jsx open tag name&quot;</span><span class="s1">,</span>
        <span class="s3">jsxCloseTagName </span><span class="s2">= </span><span class="s4">&quot;jsx close tag name&quot;</span><span class="s1">,</span>
        <span class="s3">jsxSelfClosingTagName </span><span class="s2">= </span><span class="s4">&quot;jsx self closing tag name&quot;</span><span class="s1">,</span>
        <span class="s3">jsxAttribute </span><span class="s2">= </span><span class="s4">&quot;jsx attribute&quot;</span><span class="s1">,</span>
        <span class="s3">jsxText </span><span class="s2">= </span><span class="s4">&quot;jsx text&quot;</span><span class="s1">,</span>
        <span class="s3">jsxAttributeStringLiteralValue </span><span class="s2">= </span><span class="s4">&quot;jsx attribute string literal value&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">ClassificationType </span><span class="s1">{</span>
        <span class="s3">comment </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">identifier </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">keyword </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">numericLiteral </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">operator </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">stringLiteral </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s3">regularExpressionLiteral </span><span class="s2">= </span><span class="s6">7</span><span class="s1">,</span>
        <span class="s3">whiteSpace </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">text </span><span class="s2">= </span><span class="s6">9</span><span class="s1">,</span>
        <span class="s3">punctuation </span><span class="s2">= </span><span class="s6">10</span><span class="s1">,</span>
        <span class="s3">className </span><span class="s2">= </span><span class="s6">11</span><span class="s1">,</span>
        <span class="s3">enumName </span><span class="s2">= </span><span class="s6">12</span><span class="s1">,</span>
        <span class="s3">interfaceName </span><span class="s2">= </span><span class="s6">13</span><span class="s1">,</span>
        <span class="s3">moduleName </span><span class="s2">= </span><span class="s6">14</span><span class="s1">,</span>
        <span class="s3">typeParameterName </span><span class="s2">= </span><span class="s6">15</span><span class="s1">,</span>
        <span class="s3">typeAliasName </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">parameterName </span><span class="s2">= </span><span class="s6">17</span><span class="s1">,</span>
        <span class="s3">docCommentTagName </span><span class="s2">= </span><span class="s6">18</span><span class="s1">,</span>
        <span class="s3">jsxOpenTagName </span><span class="s2">= </span><span class="s6">19</span><span class="s1">,</span>
        <span class="s3">jsxCloseTagName </span><span class="s2">= </span><span class="s6">20</span><span class="s1">,</span>
        <span class="s3">jsxSelfClosingTagName </span><span class="s2">= </span><span class="s6">21</span><span class="s1">,</span>
        <span class="s3">jsxAttribute </span><span class="s2">= </span><span class="s6">22</span><span class="s1">,</span>
        <span class="s3">jsxText </span><span class="s2">= </span><span class="s6">23</span><span class="s1">,</span>
        <span class="s3">jsxAttributeStringLiteralValue </span><span class="s2">= </span><span class="s6">24</span><span class="s1">,</span>
        <span class="s3">bigintLiteral </span><span class="s2">= </span><span class="s6">25</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InlayHintsContext </span><span class="s1">{</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">program</span><span class="s2">: </span><span class="s3">Program</span><span class="s1">;</span>
        <span class="s1">cancellationToken</span><span class="s2">: </span><span class="s3">CancellationToken</span><span class="s1">;</span>
        <span class="s1">host</span><span class="s2">: </span><span class="s3">LanguageServiceHost</span><span class="s1">;</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">preferences</span><span class="s2">: </span><span class="s3">UserPreferences</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/** The classifier is used for syntactic highlighting in editors via the TSServer */</span>
    <span class="s2">function </span><span class="s1">createClassifier()</span><span class="s2">: </span><span class="s3">Classifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">DocumentHighlights </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">highlightSpans</span><span class="s2">: </span><span class="s3">HighlightSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The document registry represents a store of SourceFile objects that can be shared between 
     * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST) 
     * of files in the context. 
     * SourceFile objects account for most of the memory usage by the language service. Sharing 
     * the same DocumentRegistry instance between different instances of LanguageService allow 
     * for more efficient memory utilization since all projects will share at least the library 
     * file (lib.d.ts). 
     * 
     * A more advanced use of the document registry is to serialize sourceFile objects to disk 
     * and re-hydrate them when needed. 
     * 
     * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it 
     * to all subsequent createLanguageService calls. 
     */</span>
    <span class="s2">interface </span><span class="s3">DocumentRegistry </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Request a stored SourceFile with a given fileName and compilationSettings. 
         * The first call to acquire will call createLanguageServiceSourceFile to generate 
         * the SourceFile if was not found in the registry. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The name of the file requested 
         * </span><span class="s2">@param </span><span class="s3">compilationSettingsOrHost </span><span class="s0">Some compilation settings like target affects the 
         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store 
         * multiple copies of the same file for different compilation settings. A minimal 
         * resolution cache is needed to fully define a source file's shape when 
         * the compilation settings include `module: node16`+, so providing a cache host 
         * object should be preferred. A common host is a language service `ConfiguredProject`. 
         * </span><span class="s2">@param </span><span class="s3">scriptSnapshot </span><span class="s0">Text of the file. Only used if the file was not found 
         * in the registry and a new one was created. 
         * </span><span class="s2">@param </span><span class="s3">version </span><span class="s0">Current version of the file. Only used if the file was not found 
         * in the registry and a new one was created. 
         */</span>
        <span class="s1">acquireDocument(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">compilationSettingsOrHost</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">MinimalResolutionCacheHost</span><span class="s1">, </span><span class="s3">scriptSnapshot</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">, </span><span class="s3">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">sourceFileOptions</span><span class="s2">?: </span><span class="s3">CreateSourceFileOptions </span><span class="s2">| </span><span class="s3">ScriptTarget</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">acquireDocumentWithKey(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">, </span><span class="s3">compilationSettingsOrHost</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">MinimalResolutionCacheHost</span><span class="s1">, </span><span class="s3">key</span><span class="s2">: </span><span class="s3">DocumentRegistryBucketKey</span><span class="s1">, </span><span class="s3">scriptSnapshot</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">, </span><span class="s3">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">sourceFileOptions</span><span class="s2">?: </span><span class="s3">CreateSourceFileOptions </span><span class="s2">| </span><span class="s3">ScriptTarget</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Request an updated version of an already existing SourceFile with a given fileName 
         * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile 
         * to get an updated SourceFile. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The name of the file requested 
         * </span><span class="s2">@param </span><span class="s3">compilationSettingsOrHost </span><span class="s0">Some compilation settings like target affects the 
         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store 
         * multiple copies of the same file for different compilation settings. A minimal 
         * resolution cache is needed to fully define a source file's shape when 
         * the compilation settings include `module: node16`+, so providing a cache host 
         * object should be preferred. A common host is a language service `ConfiguredProject`. 
         * </span><span class="s2">@param </span><span class="s3">scriptSnapshot </span><span class="s0">Text of the file. 
         * </span><span class="s2">@param </span><span class="s3">version </span><span class="s0">Current version of the file. 
         */</span>
        <span class="s1">updateDocument(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">compilationSettingsOrHost</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">MinimalResolutionCacheHost</span><span class="s1">, </span><span class="s3">scriptSnapshot</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">, </span><span class="s3">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">sourceFileOptions</span><span class="s2">?: </span><span class="s3">CreateSourceFileOptions </span><span class="s2">| </span><span class="s3">ScriptTarget</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">updateDocumentWithKey(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">, </span><span class="s3">compilationSettingsOrHost</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">| </span><span class="s3">MinimalResolutionCacheHost</span><span class="s1">, </span><span class="s3">key</span><span class="s2">: </span><span class="s3">DocumentRegistryBucketKey</span><span class="s1">, </span><span class="s3">scriptSnapshot</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">, </span><span class="s3">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">sourceFileOptions</span><span class="s2">?: </span><span class="s3">CreateSourceFileOptions </span><span class="s2">| </span><span class="s3">ScriptTarget</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
        <span class="s1">getKeyForCompilationSettings(</span><span class="s3">settings</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DocumentRegistryBucketKey</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Informs the DocumentRegistry that a file is not needed any longer. 
         * 
         * Note: It is not allowed to call release on a SourceFile that was not acquired from 
         * this registry originally. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The name of the file to be released 
         * </span><span class="s2">@param </span><span class="s3">compilationSettings </span><span class="s0">The compilation settings used to acquire the file 
         * </span><span class="s2">@param </span><span class="s3">scriptKind </span><span class="s0">The script kind of the file to be released 
         */</span>
        <span class="s0">/**</span><span class="s2">@deprecated </span><span class="s0">pass scriptKind and impliedNodeFormat for correctness */</span>
        <span class="s1">releaseDocument(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">compilationSettings</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Informs the DocumentRegistry that a file is not needed any longer. 
         * 
         * Note: It is not allowed to call release on a SourceFile that was not acquired from 
         * this registry originally. 
         * 
         * </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">The name of the file to be released 
         * </span><span class="s2">@param </span><span class="s3">compilationSettings </span><span class="s0">The compilation settings used to acquire the file 
         * </span><span class="s2">@param </span><span class="s3">scriptKind </span><span class="s0">The script kind of the file to be released 
         * </span><span class="s2">@param </span><span class="s3">impliedNodeFormat </span><span class="s0">The implied source file format of the file to be released 
         */</span>
        <span class="s1">releaseDocument(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">compilationSettings</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">impliedNodeFormat</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">])</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">pass scriptKind for and impliedNodeFormat correctness */</span>
        <span class="s1">releaseDocumentWithKey(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">, </span><span class="s3">key</span><span class="s2">: </span><span class="s3">DocumentRegistryBucketKey</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">releaseDocumentWithKey(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">, </span><span class="s3">key</span><span class="s2">: </span><span class="s3">DocumentRegistryBucketKey</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">impliedNodeFormat</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">])</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">reportStats()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">DocumentRegistryBucketKey </span><span class="s2">= </span><span class="s3">string </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">__bucketKey</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">createDocumentRegistry(</span><span class="s3">useCaseSensitiveFileNames</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">currentDirectory</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DocumentRegistry</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">function </span><span class="s1">preProcessFile(</span><span class="s3">sourceText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">readImportFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">detectJavaScriptImports</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PreProcessedFileInfo</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">TranspileOptions </span><span class="s1">{</span>
        <span class="s1">compilerOptions</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">fileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">reportDiagnostics</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">moduleName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">renamedDependencies</span><span class="s2">?: </span><span class="s3">MapLike</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">&gt;;</span>
        <span class="s1">transformers</span><span class="s2">?: </span><span class="s3">CustomTransformers</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TranspileOutput </span><span class="s1">{</span>
        <span class="s1">outputText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">diagnostics</span><span class="s2">?: </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">sourceMapText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">transpileModule(</span><span class="s3">input</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">transpileOptions</span><span class="s2">: </span><span class="s3">TranspileOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TranspileOutput</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">transpile(</span><span class="s3">input</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">compilerOptions</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">fileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">diagnostics</span><span class="s2">?: </span><span class="s3">Diagnostic</span><span class="s1">[], </span><span class="s3">moduleName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/** The version of the language service API */</span>
    <span class="s2">const </span><span class="s1">servicesVersion </span><span class="s2">= </span><span class="s4">&quot;0.8&quot;</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">toEditorSettings(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">EditorOptions </span><span class="s2">| </span><span class="s3">EditorSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EditorSettings</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">displayPartsToString(</span><span class="s3">displayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getDefaultCompilerOptions()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">getSupportedCodeFixes()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s2">function </span><span class="s1">createLanguageServiceSourceFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">scriptSnapshot</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">, </span><span class="s3">scriptTargetOrOptions</span><span class="s2">: </span><span class="s3">ScriptTarget </span><span class="s2">| </span><span class="s3">CreateSourceFileOptions</span><span class="s1">, </span><span class="s3">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">setNodeParents</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">updateLanguageServiceSourceFile(</span><span class="s3">sourceFile</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">scriptSnapshot</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">, </span><span class="s3">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">textChangeRange</span><span class="s2">: </span><span class="s3">TextChangeRange </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">aggressiveChecks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createLanguageService(</span><span class="s3">host</span><span class="s2">: </span><span class="s3">LanguageServiceHost</span><span class="s1">, </span><span class="s3">documentRegistry</span><span class="s2">?: </span><span class="s3">DocumentRegistry</span><span class="s1">, </span><span class="s3">syntaxOnlyOrLanguageServiceMode</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">LanguageServiceMode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LanguageService</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Get the path of the default library files (lib.d.ts) as distributed with the typescript 
     * node package. 
     * The functionality is not supported if the ts module is consumed outside of a node module. 
     */</span>
    <span class="s2">function </span><span class="s1">getDefaultLibFilePath(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Transform one or more nodes using the supplied transformers. 
     * </span><span class="s2">@param </span><span class="s3">source </span><span class="s0">A single `Node` or an array of `Node` objects. 
     * </span><span class="s2">@param </span><span class="s3">transformers </span><span class="s0">An array of `TransformerFactory` callbacks used to process the transformation. 
     * </span><span class="s2">@param </span><span class="s3">compilerOptions </span><span class="s0">Optional compiler options. 
     */</span>
    <span class="s2">function </span><span class="s1">transform&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">source</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">T</span><span class="s1">[], </span><span class="s3">transformers</span><span class="s2">: </span><span class="s3">TransformerFactory</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;[], </span><span class="s3">compilerOptions</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TransformationResult</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">CompressedData </span><span class="s1">{</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">compressionKind</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">data</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">ModuleImportResult </span><span class="s2">= </span><span class="s1">{</span>
        <span class="s1">module</span><span class="s2">: </span><span class="s1">{};</span>
        <span class="s1">error</span><span class="s2">: </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">| </span><span class="s1">{</span>
        <span class="s1">module</span><span class="s2">: </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">error</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">stack</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
            <span class="s1">message</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}; 
    </span><span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use </span><span class="s3">{</span><span class="s2">@link </span><span class="s3">ModuleImportResult} </span><span class="s0">instead. */</span>
    <span class="s1">type RequireResult = ModuleImportResult; 
    </span><span class="s2">interface </span><span class="s3">ServerHost </span><span class="s2">extends </span><span class="s3">System </span><span class="s1">{</span>
        <span class="s1">watchFile(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">callback</span><span class="s2">: </span><span class="s3">FileWatcherCallback</span><span class="s1">, </span><span class="s3">pollingInterval</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FileWatcher</span><span class="s1">;</span>
        <span class="s1">watchDirectory(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">callback</span><span class="s2">: </span><span class="s3">DirectoryWatcherCallback</span><span class="s1">, </span><span class="s3">recursive</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">options</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FileWatcher</span><span class="s1">;</span>
        <span class="s1">setTimeout(</span><span class="s5">callback</span><span class="s2">: </span><span class="s1">(</span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s3">ms</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s1">clearTimeout(</span><span class="s3">timeoutId</span><span class="s2">: </span><span class="s3">any</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">setImmediate(</span><span class="s5">callback</span><span class="s2">: </span><span class="s1">(</span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s2">...</span><span class="s3">args</span><span class="s2">: </span><span class="s3">any</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s1">clearImmediate(</span><span class="s3">timeoutId</span><span class="s2">: </span><span class="s3">any</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">gc</span><span class="s2">?</span><span class="s1">()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">trace</span><span class="s2">?</span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">require</span><span class="s2">?</span><span class="s1">(</span><span class="s3">initialPath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleImportResult</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">enum </span><span class="s3">LogLevel </span><span class="s1">{</span>
        <span class="s3">terse </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">normal </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">requestTime </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">verbose </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">emptyArray</span><span class="s2">: </span><span class="s3">SortedReadonlyArray</span><span class="s1">&lt;</span><span class="s3">never</span><span class="s1">&gt;;</span>
    <span class="s2">interface </span><span class="s3">Logger </span><span class="s1">{</span>
        <span class="s1">close()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">hasLevel(</span><span class="s3">level</span><span class="s2">: </span><span class="s3">LogLevel</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">loggingEnabled()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">perftrc(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">info(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">startGroup()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">endGroup()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">msg(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">Msg</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getLogFileName()</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">Msg </span><span class="s1">{</span>
        <span class="s3">Err </span><span class="s2">= </span><span class="s4">&quot;Err&quot;</span><span class="s1">,</span>
        <span class="s3">Info </span><span class="s2">= </span><span class="s4">&quot;Info&quot;</span><span class="s1">,</span>
        <span class="s3">Perf </span><span class="s2">= </span><span class="s4">&quot;Perf&quot;</span>
    <span class="s1">}</span>
    <span class="s2">namespace </span><span class="s3">Msg </span><span class="s1">{</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Only here for backwards-compatibility. Prefer just `Msg`. */</span>
        <span class="s2">type </span><span class="s3">Types </span><span class="s2">= </span><span class="s3">Msg</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">createInstallTypingsRequest(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">, </span><span class="s3">typeAcquisition</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">, </span><span class="s3">unresolvedImports</span><span class="s2">: </span><span class="s3">SortedReadonlyArray</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">&gt;, </span><span class="s3">cachePath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">DiscoverTypings</span><span class="s1">;</span>
    <span class="s2">namespace </span><span class="s3">Errors </span><span class="s1">{</span>
        <span class="s2">function </span><span class="s1">ThrowNoProject()</span><span class="s2">: </span><span class="s3">never</span><span class="s1">;</span>
        <span class="s2">function </span><span class="s1">ThrowProjectLanguageServiceDisabled()</span><span class="s2">: </span><span class="s3">never</span><span class="s1">;</span>
        <span class="s2">function </span><span class="s1">ThrowProjectDoesNotContainDocument(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">)</span><span class="s2">: </span><span class="s3">never</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">NormalizedPath </span><span class="s2">= </span><span class="s3">string </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">__normalizedPathTag</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">function </span><span class="s1">toNormalizedPath(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">normalizedPathToPath(</span><span class="s3">normalizedPath</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">, </span><span class="s3">currentDirectory</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s5">getCanonicalFileName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">f</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">asNormalizedPath(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">NormalizedPathMap</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; {</span>
        <span class="s1">get(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">set(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">, </span><span class="s3">value</span><span class="s2">: </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">contains(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">remove(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">createNormalizedPathMap&lt;</span><span class="s3">T</span><span class="s1">&gt;()</span><span class="s2">: </span><span class="s3">NormalizedPathMap</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s2">function </span><span class="s1">isInferredProjectName(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">makeInferredProjectName(</span><span class="s3">counter</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">createSortedArray&lt;</span><span class="s3">T</span><span class="s1">&gt;()</span><span class="s2">: </span><span class="s3">SortedArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Declaration module describing the TypeScript Server protocol 
 */</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server</span><span class="s1">.</span><span class="s3">protocol </span><span class="s1">{</span>
    <span class="s2">enum </span><span class="s3">CommandTypes </span><span class="s1">{</span>
        <span class="s3">JsxClosingTag </span><span class="s2">= </span><span class="s4">&quot;jsxClosingTag&quot;</span><span class="s1">,</span>
        <span class="s3">Brace </span><span class="s2">= </span><span class="s4">&quot;brace&quot;</span><span class="s1">,</span>
        <span class="s3">BraceCompletion </span><span class="s2">= </span><span class="s4">&quot;braceCompletion&quot;</span><span class="s1">,</span>
        <span class="s3">GetSpanOfEnclosingComment </span><span class="s2">= </span><span class="s4">&quot;getSpanOfEnclosingComment&quot;</span><span class="s1">,</span>
        <span class="s3">Change </span><span class="s2">= </span><span class="s4">&quot;change&quot;</span><span class="s1">,</span>
        <span class="s3">Close </span><span class="s2">= </span><span class="s4">&quot;close&quot;</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Prefer CompletionInfo -- see comment on CompletionsResponse */</span>
        <span class="s3">Completions </span><span class="s2">= </span><span class="s4">&quot;completions&quot;</span><span class="s1">,</span>
        <span class="s3">CompletionInfo </span><span class="s2">= </span><span class="s4">&quot;completionInfo&quot;</span><span class="s1">,</span>
        <span class="s3">CompletionDetails </span><span class="s2">= </span><span class="s4">&quot;completionEntryDetails&quot;</span><span class="s1">,</span>
        <span class="s3">CompileOnSaveAffectedFileList </span><span class="s2">= </span><span class="s4">&quot;compileOnSaveAffectedFileList&quot;</span><span class="s1">,</span>
        <span class="s3">CompileOnSaveEmitFile </span><span class="s2">= </span><span class="s4">&quot;compileOnSaveEmitFile&quot;</span><span class="s1">,</span>
        <span class="s3">Configure </span><span class="s2">= </span><span class="s4">&quot;configure&quot;</span><span class="s1">,</span>
        <span class="s3">Definition </span><span class="s2">= </span><span class="s4">&quot;definition&quot;</span><span class="s1">,</span>
        <span class="s3">DefinitionAndBoundSpan </span><span class="s2">= </span><span class="s4">&quot;definitionAndBoundSpan&quot;</span><span class="s1">,</span>
        <span class="s3">Implementation </span><span class="s2">= </span><span class="s4">&quot;implementation&quot;</span><span class="s1">,</span>
        <span class="s3">Exit </span><span class="s2">= </span><span class="s4">&quot;exit&quot;</span><span class="s1">,</span>
        <span class="s3">FileReferences </span><span class="s2">= </span><span class="s4">&quot;fileReferences&quot;</span><span class="s1">,</span>
        <span class="s3">Format </span><span class="s2">= </span><span class="s4">&quot;format&quot;</span><span class="s1">,</span>
        <span class="s3">Formatonkey </span><span class="s2">= </span><span class="s4">&quot;formatonkey&quot;</span><span class="s1">,</span>
        <span class="s3">Geterr </span><span class="s2">= </span><span class="s4">&quot;geterr&quot;</span><span class="s1">,</span>
        <span class="s3">GeterrForProject </span><span class="s2">= </span><span class="s4">&quot;geterrForProject&quot;</span><span class="s1">,</span>
        <span class="s3">SemanticDiagnosticsSync </span><span class="s2">= </span><span class="s4">&quot;semanticDiagnosticsSync&quot;</span><span class="s1">,</span>
        <span class="s3">SyntacticDiagnosticsSync </span><span class="s2">= </span><span class="s4">&quot;syntacticDiagnosticsSync&quot;</span><span class="s1">,</span>
        <span class="s3">SuggestionDiagnosticsSync </span><span class="s2">= </span><span class="s4">&quot;suggestionDiagnosticsSync&quot;</span><span class="s1">,</span>
        <span class="s3">NavBar </span><span class="s2">= </span><span class="s4">&quot;navbar&quot;</span><span class="s1">,</span>
        <span class="s3">Navto </span><span class="s2">= </span><span class="s4">&quot;navto&quot;</span><span class="s1">,</span>
        <span class="s3">NavTree </span><span class="s2">= </span><span class="s4">&quot;navtree&quot;</span><span class="s1">,</span>
        <span class="s3">NavTreeFull </span><span class="s2">= </span><span class="s4">&quot;navtree-full&quot;</span><span class="s1">,</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">*/</span>
        <span class="s3">Occurrences </span><span class="s2">= </span><span class="s4">&quot;occurrences&quot;</span><span class="s1">,</span>
        <span class="s3">DocumentHighlights </span><span class="s2">= </span><span class="s4">&quot;documentHighlights&quot;</span><span class="s1">,</span>
        <span class="s3">Open </span><span class="s2">= </span><span class="s4">&quot;open&quot;</span><span class="s1">,</span>
        <span class="s3">Quickinfo </span><span class="s2">= </span><span class="s4">&quot;quickinfo&quot;</span><span class="s1">,</span>
        <span class="s3">References </span><span class="s2">= </span><span class="s4">&quot;references&quot;</span><span class="s1">,</span>
        <span class="s3">Reload </span><span class="s2">= </span><span class="s4">&quot;reload&quot;</span><span class="s1">,</span>
        <span class="s3">Rename </span><span class="s2">= </span><span class="s4">&quot;rename&quot;</span><span class="s1">,</span>
        <span class="s3">Saveto </span><span class="s2">= </span><span class="s4">&quot;saveto&quot;</span><span class="s1">,</span>
        <span class="s3">SignatureHelp </span><span class="s2">= </span><span class="s4">&quot;signatureHelp&quot;</span><span class="s1">,</span>
        <span class="s3">FindSourceDefinition </span><span class="s2">= </span><span class="s4">&quot;findSourceDefinition&quot;</span><span class="s1">,</span>
        <span class="s3">Status </span><span class="s2">= </span><span class="s4">&quot;status&quot;</span><span class="s1">,</span>
        <span class="s3">TypeDefinition </span><span class="s2">= </span><span class="s4">&quot;typeDefinition&quot;</span><span class="s1">,</span>
        <span class="s3">ProjectInfo </span><span class="s2">= </span><span class="s4">&quot;projectInfo&quot;</span><span class="s1">,</span>
        <span class="s3">ReloadProjects </span><span class="s2">= </span><span class="s4">&quot;reloadProjects&quot;</span><span class="s1">,</span>
        <span class="s3">Unknown </span><span class="s2">= </span><span class="s4">&quot;unknown&quot;</span><span class="s1">,</span>
        <span class="s3">OpenExternalProject </span><span class="s2">= </span><span class="s4">&quot;openExternalProject&quot;</span><span class="s1">,</span>
        <span class="s3">OpenExternalProjects </span><span class="s2">= </span><span class="s4">&quot;openExternalProjects&quot;</span><span class="s1">,</span>
        <span class="s3">CloseExternalProject </span><span class="s2">= </span><span class="s4">&quot;closeExternalProject&quot;</span><span class="s1">,</span>
        <span class="s3">UpdateOpen </span><span class="s2">= </span><span class="s4">&quot;updateOpen&quot;</span><span class="s1">,</span>
        <span class="s3">GetOutliningSpans </span><span class="s2">= </span><span class="s4">&quot;getOutliningSpans&quot;</span><span class="s1">,</span>
        <span class="s3">TodoComments </span><span class="s2">= </span><span class="s4">&quot;todoComments&quot;</span><span class="s1">,</span>
        <span class="s3">Indentation </span><span class="s2">= </span><span class="s4">&quot;indentation&quot;</span><span class="s1">,</span>
        <span class="s3">DocCommentTemplate </span><span class="s2">= </span><span class="s4">&quot;docCommentTemplate&quot;</span><span class="s1">,</span>
        <span class="s3">CompilerOptionsForInferredProjects </span><span class="s2">= </span><span class="s4">&quot;compilerOptionsForInferredProjects&quot;</span><span class="s1">,</span>
        <span class="s3">GetCodeFixes </span><span class="s2">= </span><span class="s4">&quot;getCodeFixes&quot;</span><span class="s1">,</span>
        <span class="s3">GetCombinedCodeFix </span><span class="s2">= </span><span class="s4">&quot;getCombinedCodeFix&quot;</span><span class="s1">,</span>
        <span class="s3">ApplyCodeActionCommand </span><span class="s2">= </span><span class="s4">&quot;applyCodeActionCommand&quot;</span><span class="s1">,</span>
        <span class="s3">GetSupportedCodeFixes </span><span class="s2">= </span><span class="s4">&quot;getSupportedCodeFixes&quot;</span><span class="s1">,</span>
        <span class="s3">GetApplicableRefactors </span><span class="s2">= </span><span class="s4">&quot;getApplicableRefactors&quot;</span><span class="s1">,</span>
        <span class="s3">GetEditsForRefactor </span><span class="s2">= </span><span class="s4">&quot;getEditsForRefactor&quot;</span><span class="s1">,</span>
        <span class="s3">OrganizeImports </span><span class="s2">= </span><span class="s4">&quot;organizeImports&quot;</span><span class="s1">,</span>
        <span class="s3">GetEditsForFileRename </span><span class="s2">= </span><span class="s4">&quot;getEditsForFileRename&quot;</span><span class="s1">,</span>
        <span class="s3">ConfigurePlugin </span><span class="s2">= </span><span class="s4">&quot;configurePlugin&quot;</span><span class="s1">,</span>
        <span class="s3">SelectionRange </span><span class="s2">= </span><span class="s4">&quot;selectionRange&quot;</span><span class="s1">,</span>
        <span class="s3">ToggleLineComment </span><span class="s2">= </span><span class="s4">&quot;toggleLineComment&quot;</span><span class="s1">,</span>
        <span class="s3">ToggleMultilineComment </span><span class="s2">= </span><span class="s4">&quot;toggleMultilineComment&quot;</span><span class="s1">,</span>
        <span class="s3">CommentSelection </span><span class="s2">= </span><span class="s4">&quot;commentSelection&quot;</span><span class="s1">,</span>
        <span class="s3">UncommentSelection </span><span class="s2">= </span><span class="s4">&quot;uncommentSelection&quot;</span><span class="s1">,</span>
        <span class="s3">PrepareCallHierarchy </span><span class="s2">= </span><span class="s4">&quot;prepareCallHierarchy&quot;</span><span class="s1">,</span>
        <span class="s3">ProvideCallHierarchyIncomingCalls </span><span class="s2">= </span><span class="s4">&quot;provideCallHierarchyIncomingCalls&quot;</span><span class="s1">,</span>
        <span class="s3">ProvideCallHierarchyOutgoingCalls </span><span class="s2">= </span><span class="s4">&quot;provideCallHierarchyOutgoingCalls&quot;</span><span class="s1">,</span>
        <span class="s3">ProvideInlayHints </span><span class="s2">= </span><span class="s4">&quot;provideInlayHints&quot;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A TypeScript Server message 
     */</span>
    <span class="s2">interface </span><span class="s3">Message </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Sequence number of the message 
         */</span>
        <span class="s1">seq</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* One of &quot;request&quot;, &quot;response&quot;, or &quot;event&quot; 
         */</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s4">&quot;request&quot; </span><span class="s2">| </span><span class="s4">&quot;response&quot; </span><span class="s2">| </span><span class="s4">&quot;event&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Client-initiated request message 
     */</span>
    <span class="s2">interface </span><span class="s3">Request </span><span class="s2">extends </span><span class="s3">Message </span><span class="s1">{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s4">&quot;request&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The command to execute 
         */</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Object containing arguments for the command 
         */</span>
        <span class="s1">arguments</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to reload the project structure for all the opened files 
     */</span>
    <span class="s2">interface </span><span class="s3">ReloadProjectsRequest </span><span class="s2">extends </span><span class="s3">Message </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ReloadProjects</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Server-initiated event message 
     */</span>
    <span class="s2">interface </span><span class="s3">Event </span><span class="s2">extends </span><span class="s3">Message </span><span class="s1">{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s4">&quot;event&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of event 
         */</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Event-specific information 
         */</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response by server to client request message. 
     */</span>
    <span class="s2">interface </span><span class="s3">Response </span><span class="s2">extends </span><span class="s3">Message </span><span class="s1">{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s4">&quot;response&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sequence number of the request message. 
         */</span>
        <span class="s1">request_seq</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Outcome of the request. 
         */</span>
        <span class="s1">success</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The command requested. 
         */</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If success === false, this should always be provided. 
         * Otherwise, may (or may not) contain a success message. 
         */</span>
        <span class="s1">message</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains message body if success === true. 
         */</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains extra information that plugin can include to be passed on 
         */</span>
        <span class="s1">metadata</span><span class="s2">?: </span><span class="s3">unknown</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Exposes information about the performance of this request-response pair. 
         */</span>
        <span class="s1">performanceData</span><span class="s2">?: </span><span class="s3">PerformanceData</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PerformanceData </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Time spent updating the program graph, in milliseconds. 
         */</span>
        <span class="s1">updateGraphDurationMs</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The time spent creating or updating the auto-import program, in milliseconds. 
         */</span>
        <span class="s1">createAutoImportProviderProgramDurationMs</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for FileRequest messages. 
     */</span>
    <span class="s2">interface </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The file for the request (absolute pathname required). 
         */</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">projectFileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">StatusRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Status</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">StatusResponseBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The TypeScript version (`ts.version`). 
         */</span>
        <span class="s1">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to StatusRequest 
     */</span>
    <span class="s2">interface </span><span class="s3">StatusResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">StatusResponseBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Requests a JS Doc comment template for a given position 
     */</span>
    <span class="s2">interface </span><span class="s3">DocCommentTemplateRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">DocCommentTemplate</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to DocCommentTemplateRequest 
     */</span>
    <span class="s2">interface </span><span class="s3">DocCommandTemplateResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">TextInsertion</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A request to get TODO comments from the file 
     */</span>
    <span class="s2">interface </span><span class="s3">TodoCommentRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">TodoComments</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">TodoCommentRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for TodoCommentRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">TodoCommentRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Array of target TodoCommentDescriptors that describes TODO comments to be found 
         */</span>
        <span class="s1">descriptors</span><span class="s2">: </span><span class="s3">TodoCommentDescriptor</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response for TodoCommentRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">TodoCommentsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">TodoComment</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A request to determine if the caret is inside a comment. 
     */</span>
    <span class="s2">interface </span><span class="s3">SpanOfEnclosingCommentRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GetSpanOfEnclosingComment</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">SpanOfEnclosingCommentRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SpanOfEnclosingCommentRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Requires that the enclosing span be a multi-line comment, or else the request returns undefined. 
         */</span>
        <span class="s1">onlyMultiLine</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to obtain outlining spans in file. 
     */</span>
    <span class="s2">interface </span><span class="s3">OutliningSpansRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GetOutliningSpans</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">OutliningSpan </span><span class="s1">{</span>
        <span class="s0">/** The span of the document to actually collapse. */</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s0">/** The span of the document to display when the user hovers over the collapsed span. */</span>
        <span class="s1">hintSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s0">/** The text to display in the editor for the collapsed region. */</span>
        <span class="s1">bannerText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Whether or not this region should be automatically collapsed when 
         * the 'Collapse to Definitions' command is invoked. 
         */</span>
        <span class="s1">autoCollapse</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Classification of the contents of the span 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">OutliningSpanKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to OutliningSpansRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">OutliningSpansResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">OutliningSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A request to get indentation for a location in file 
     */</span>
    <span class="s2">interface </span><span class="s3">IndentationRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Indentation</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">IndentationRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response for IndentationRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">IndentationResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">IndentationResult</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Indentation result representing where indentation should be placed 
     */</span>
    <span class="s2">interface </span><span class="s3">IndentationResult </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The base position in the document that the indent should be relative to 
         */</span>
        <span class="s1">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of columns the indent should be at relative to the position's column. 
         */</span>
        <span class="s1">indentation</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for IndentationRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">IndentationRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional set of settings to be used when computing indentation. 
         * If argument is omitted - then it will use settings for file that were previously set via 'configure' request or global settings. 
         */</span>
        <span class="s1">options</span><span class="s2">?: </span><span class="s3">EditorSettings</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for ProjectInfoRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">ProjectInfoRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicate if the file name list of the project is needed 
         */</span>
        <span class="s1">needFileNameList</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A request to get the project information of the current file. 
     */</span>
    <span class="s2">interface </span><span class="s3">ProjectInfoRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ProjectInfo</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">ProjectInfoRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A request to retrieve compiler options diagnostics for a project 
     */</span>
    <span class="s2">interface </span><span class="s3">CompilerOptionsDiagnosticsRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">CompilerOptionsDiagnosticsRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for CompilerOptionsDiagnosticsRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">CompilerOptionsDiagnosticsRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of the project to retrieve compiler options diagnostics. 
         */</span>
        <span class="s1">projectFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response message body for &quot;projectInfo&quot; request 
     */</span>
    <span class="s2">interface </span><span class="s3">ProjectInfo </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* For configured project, this is the normalized path of the 'tsconfig.json' file 
         * For inferred project, this is undefined 
         */</span>
        <span class="s1">configFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The list of normalized file name in the project, including 'lib.d.ts' 
         */</span>
        <span class="s1">fileNames</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates if the project has a active language service instance 
         */</span>
        <span class="s1">languageServiceDisabled</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents diagnostic info that includes location of diagnostic in two forms 
     * - start position and length of the error span 
     * - startLocation and endLocation - a pair of Location objects that store start/end line and offset of the error span. 
     */</span>
    <span class="s2">interface </span><span class="s3">DiagnosticWithLinePosition </span><span class="s1">{</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">startLocation</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s1">endLocation</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">code</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */</span>
        <span class="s1">reportsUnnecessary</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s1">reportsDeprecated</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s1">relatedInformation</span><span class="s2">?: </span><span class="s3">DiagnosticRelatedInformation</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response message for &quot;projectInfo&quot; request 
     */</span>
    <span class="s2">interface </span><span class="s3">ProjectInfoResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">ProjectInfo</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request whose sole parameter is a file name. 
     */</span>
    <span class="s2">interface </span><span class="s3">FileRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FileRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Instances of this interface specify a location in a source file: 
     * (file, line, character offset), where line and character offset are 1-based. 
     */</span>
    <span class="s2">interface </span><span class="s3">FileLocationRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The line number for the request (1-based). 
         */</span>
        <span class="s1">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The character offset (on the line) for the request (1-based). 
         */</span>
        <span class="s1">offset</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">FileLocationOrRangeRequestArgs </span><span class="s2">= </span><span class="s3">FileLocationRequestArgs </span><span class="s2">| </span><span class="s3">FileRangeRequestArgs</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Request refactorings at a given position or selection area. 
     */</span>
    <span class="s2">interface </span><span class="s3">GetApplicableRefactorsRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GetApplicableRefactors</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">GetApplicableRefactorsRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">GetApplicableRefactorsRequestArgs </span><span class="s2">= </span><span class="s3">FileLocationOrRangeRequestArgs </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">triggerReason</span><span class="s2">?: </span><span class="s3">RefactorTriggerReason</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">type </span><span class="s3">RefactorTriggerReason </span><span class="s2">= </span><span class="s4">&quot;implicit&quot; </span><span class="s2">| </span><span class="s4">&quot;invoked&quot;</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Response is a list of available refactorings. 
     * Each refactoring exposes one or more &quot;Actions&quot;; a user selects one action to invoke a refactoring 
     */</span>
    <span class="s2">interface </span><span class="s3">GetApplicableRefactorsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">ApplicableRefactorInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A set of one or more available refactoring actions, grouped under a parent refactoring. 
     */</span>
    <span class="s2">interface </span><span class="s3">ApplicableRefactorInfo </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The programmatic name of the refactoring 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A description of this refactoring category to show to the user. 
         * If the refactoring gets inlined (see below), this text will not be visible. 
         */</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Inlineable refactorings can have their actions hoisted out to the top level 
         * of a context menu. Non-inlineanable refactorings should always be shown inside 
         * their parent grouping. 
         * 
         * If not specified, this value is assumed to be 'true' 
         */</span>
        <span class="s1">inlineable</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">actions</span><span class="s2">: </span><span class="s3">RefactorActionInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a single refactoring action - for example, the &quot;Extract Method...&quot; refactor might 
     * offer several actions, each corresponding to a surround class or closure to extract into. 
     */</span>
    <span class="s2">interface </span><span class="s3">RefactorActionInfo </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The programmatic name of the refactoring action 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A description of this refactoring action to show to the user. 
         * If the parent refactoring is inlined away, this will be the only text shown, 
         * so this description should make sense by itself if the parent is inlineable=true 
         */</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A message to show to the user if the refactoring cannot be applied in 
         * the current context. 
         */</span>
        <span class="s1">notApplicableReason</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The hierarchical dotted name of the refactor action. 
         */</span>
        <span class="s1">kind</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">GetEditsForRefactorRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GetEditsForRefactor</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">GetEditsForRefactorRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request the edits that a particular refactoring action produces. 
     * Callers must specify the name of the refactor and the name of the action. 
     */</span>
    <span class="s2">type </span><span class="s3">GetEditsForRefactorRequestArgs </span><span class="s2">= </span><span class="s3">FileLocationOrRangeRequestArgs </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s1">refactor</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">action</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">interface </span><span class="s3">GetEditsForRefactorResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">RefactorEditInfo</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">RefactorEditInfo </span><span class="s1">{</span>
        <span class="s1">edits</span><span class="s2">: </span><span class="s3">FileCodeEdits</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional location where the editor should start a rename operation once 
         * the refactoring edits have been applied 
         */</span>
        <span class="s1">renameLocation</span><span class="s2">?: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s1">renameFilename</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Organize imports by: 
     *   1) Removing unused imports 
     *   2) Coalescing imports from the same module 
     *   3) Sorting imports 
     */</span>
    <span class="s2">interface </span><span class="s3">OrganizeImportsRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">OrganizeImports</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">OrganizeImportsRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">OrganizeImportsScope </span><span class="s2">= </span><span class="s3">GetCombinedCodeFixScope</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">OrganizeImportsRequestArgs </span><span class="s1">{</span>
        <span class="s1">scope</span><span class="s2">: </span><span class="s3">OrganizeImportsScope</span><span class="s1">;</span>
        <span class="s1">skipDestructiveCodeActions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">OrganizeImportsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">: readonly </span><span class="s3">FileCodeEdits</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">GetEditsForFileRenameRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GetEditsForFileRename</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">GetEditsForFileRenameRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** Note: Paths may also be directories. */</span>
    <span class="s2">interface </span><span class="s3">GetEditsForFileRenameRequestArgs </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">oldFilePath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">newFilePath</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">GetEditsForFileRenameResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">: readonly </span><span class="s3">FileCodeEdits</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request for the available codefixes at a specific position. 
     */</span>
    <span class="s2">interface </span><span class="s3">CodeFixRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GetCodeFixes</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">CodeFixRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">GetCombinedCodeFixRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GetCombinedCodeFix</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">GetCombinedCodeFixRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">GetCombinedCodeFixResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">CombinedCodeActions</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ApplyCodeActionCommandRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ApplyCodeActionCommand</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">ApplyCodeActionCommandRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ApplyCodeActionCommandResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FileRangeRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The line number for the request (1-based). 
         */</span>
        <span class="s1">startLine</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The character offset (on the line) for the request (1-based). 
         */</span>
        <span class="s1">startOffset</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The line number for the request (1-based). 
         */</span>
        <span class="s1">endLine</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The character offset (on the line) for the request (1-based). 
         */</span>
        <span class="s1">endOffset</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Instances of this interface specify errorcodes on a specific location in a sourcefile. 
     */</span>
    <span class="s2">interface </span><span class="s3">CodeFixRequestArgs </span><span class="s2">extends </span><span class="s3">FileRangeRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Errorcodes we want to get the fixes for. 
         */</span>
        <span class="s1">errorCodes</span><span class="s2">: readonly </span><span class="s3">number</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">GetCombinedCodeFixRequestArgs </span><span class="s1">{</span>
        <span class="s1">scope</span><span class="s2">: </span><span class="s3">GetCombinedCodeFixScope</span><span class="s1">;</span>
        <span class="s1">fixId</span><span class="s2">: </span><span class="s1">{};</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">GetCombinedCodeFixScope </span><span class="s1">{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s4">&quot;file&quot;</span><span class="s1">;</span>
        <span class="s1">args</span><span class="s2">: </span><span class="s3">FileRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ApplyCodeActionCommandRequestArgs </span><span class="s1">{</span>
        <span class="s0">/** May also be an array of commands. */</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s1">{};</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response for GetCodeFixes request. 
     */</span>
    <span class="s2">interface </span><span class="s3">GetCodeFixesResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">CodeAction</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A request whose arguments specify a file location (file, line, col). 
     */</span>
    <span class="s2">interface </span><span class="s3">FileLocationRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FileLocationRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A request to get codes of supported code fixes. 
     */</span>
    <span class="s2">interface </span><span class="s3">GetSupportedCodeFixesRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GetSupportedCodeFixes</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A response for GetSupportedCodeFixesRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">GetSupportedCodeFixesResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* List of error codes supported by the server. 
         */</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A request to get encoded semantic classifications for a span in the file 
     */</span>
    <span class="s2">interface </span><span class="s3">EncodedSemanticClassificationsRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">EncodedSemanticClassificationsRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for EncodedSemanticClassificationsRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">EncodedSemanticClassificationsRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Start position of the span. 
         */</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Length of the span. 
         */</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional parameter for the semantic highlighting response, if absent it 
         * defaults to &quot;original&quot;. 
         */</span>
        <span class="s1">format</span><span class="s2">?: </span><span class="s4">&quot;original&quot; </span><span class="s2">| </span><span class="s4">&quot;2020&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** The response for a EncodedSemanticClassificationsRequest */</span>
    <span class="s2">interface </span><span class="s3">EncodedSemanticClassificationsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">EncodedSemanticClassificationsResponseBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Implementation response message. Gives series of text spans depending on the format ar. 
     */</span>
    <span class="s2">interface </span><span class="s3">EncodedSemanticClassificationsResponseBody </span><span class="s1">{</span>
        <span class="s1">endOfLineState</span><span class="s2">: </span><span class="s3">EndOfLineState</span><span class="s1">;</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s3">number</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments in document highlight request; include: filesToSearch, file, 
     * line, offset. 
     */</span>
    <span class="s2">interface </span><span class="s3">DocumentHighlightsRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* List of files to search for document highlights. 
         */</span>
        <span class="s1">filesToSearch</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Go to definition request; value of command field is 
     * &quot;definition&quot;. Return response giving the file locations that 
     * define the symbol found in file at location line, col. 
     */</span>
    <span class="s2">interface </span><span class="s3">DefinitionRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Definition</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DefinitionAndBoundSpanRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">DefinitionAndBoundSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FindSourceDefinitionRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">FindSourceDefinition</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DefinitionAndBoundSpanResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">DefinitionInfoAndBoundSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Go to type request; value of command field is 
     * &quot;typeDefinition&quot;. Return response giving the file locations that 
     * define the type for the symbol found in file at location line, col. 
     */</span>
    <span class="s2">interface </span><span class="s3">TypeDefinitionRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">TypeDefinition</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Go to implementation request; value of command field is 
     * &quot;implementation&quot;. Return response giving the file locations that 
     * implement the symbol found in file at location line, col. 
     */</span>
    <span class="s2">interface </span><span class="s3">ImplementationRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Implementation</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Location in source code expressed as (one-based) line and (one-based) column offset. 
     */</span>
    <span class="s2">interface </span><span class="s3">Location </span><span class="s1">{</span>
        <span class="s1">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">offset</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Object found in response messages defining a span of text in source code. 
     */</span>
    <span class="s2">interface </span><span class="s3">TextSpan </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* First character of the definition. 
         */</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* One character past last character of the definition. 
         */</span>
        <span class="s1">end</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Object found in response messages defining a span of text in a specific source file. 
     */</span>
    <span class="s2">interface </span><span class="s3">FileSpan </span><span class="s2">extends </span><span class="s3">TextSpan </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* File containing text span. 
         */</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">JSDocTagInfo </span><span class="s1">{</span>
        <span class="s0">/** Name of the JSDoc tag */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Comment text after the JSDoc tag -- the text after the tag name until the next tag or end of comment 
         * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise. 
         */</span>
        <span class="s1">text</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TextSpanWithContext </span><span class="s2">extends </span><span class="s3">TextSpan </span><span class="s1">{</span>
        <span class="s1">contextStart</span><span class="s2">?: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s1">contextEnd</span><span class="s2">?: </span><span class="s3">Location</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FileSpanWithContext </span><span class="s2">extends </span><span class="s3">FileSpan</span><span class="s1">, </span><span class="s3">TextSpanWithContext </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DefinitionInfo </span><span class="s2">extends </span><span class="s3">FileSpanWithContext </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* When true, the file may or may not exist. 
         */</span>
        <span class="s1">unverified</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DefinitionInfoAndBoundSpan </span><span class="s1">{</span>
        <span class="s1">definitions</span><span class="s2">: readonly </span><span class="s3">DefinitionInfo</span><span class="s1">[];</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Definition response message.  Gives text range for definition. 
     */</span>
    <span class="s2">interface </span><span class="s3">DefinitionResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">DefinitionInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DefinitionInfoAndBoundSpanResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">DefinitionInfoAndBoundSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `DefinitionInfoAndBoundSpanResponse` instead. */</span>
    <span class="s2">type </span><span class="s3">DefinitionInfoAndBoundSpanReponse </span><span class="s2">= </span><span class="s3">DefinitionInfoAndBoundSpanResponse</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Definition response message.  Gives text range for definition. 
     */</span>
    <span class="s2">interface </span><span class="s3">TypeDefinitionResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">FileSpanWithContext</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Implementation response message.  Gives text range for implementations. 
     */</span>
    <span class="s2">interface </span><span class="s3">ImplementationResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">FileSpanWithContext</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to get brace completion for a location in the file. 
     */</span>
    <span class="s2">interface </span><span class="s3">BraceCompletionRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">BraceCompletion</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">BraceCompletionRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Argument for BraceCompletionRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">BraceCompletionRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Kind of opening brace 
         */</span>
        <span class="s1">openingBrace</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">JsxClosingTagRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">JsxClosingTag</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">arguments</span><span class="s2">: </span><span class="s3">JsxClosingTagRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">JsxClosingTagRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">JsxClosingTagResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">TextInsertion</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@deprecated</span>
     <span class="s0">* Get occurrences request; value of command field is 
     * &quot;occurrences&quot;. Return response giving spans that are relevant 
     * in the file at a given line and column. 
     */</span>
    <span class="s2">interface </span><span class="s3">OccurrencesRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Occurrences</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">*/</span>
    <span class="s2">interface </span><span class="s3">OccurrencesResponseItem </span><span class="s2">extends </span><span class="s3">FileSpanWithContext </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* True if the occurrence is a write location, false otherwise. 
         */</span>
        <span class="s1">isWriteAccess</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if the occurrence is in a string, undefined otherwise; 
         */</span>
        <span class="s1">isInString</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">*/</span>
    <span class="s2">interface </span><span class="s3">OccurrencesResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">OccurrencesResponseItem</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Get document highlights request; value of command field is 
     * &quot;documentHighlights&quot;. Return response giving spans that are relevant 
     * in the file at a given line and column. 
     */</span>
    <span class="s2">interface </span><span class="s3">DocumentHighlightsRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">DocumentHighlights</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">DocumentHighlightsRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Span augmented with extra information that denotes the kind of the highlighting to be used for span. 
     */</span>
    <span class="s2">interface </span><span class="s3">HighlightSpan </span><span class="s2">extends </span><span class="s3">TextSpanWithContext </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">HighlightSpanKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a set of highligh spans for a give name 
     */</span>
    <span class="s2">interface </span><span class="s3">DocumentHighlightsItem </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* File containing highlight spans. 
         */</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Spans to highlight in file. 
         */</span>
        <span class="s1">highlightSpans</span><span class="s2">: </span><span class="s3">HighlightSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response for a DocumentHighlightsRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">DocumentHighlightsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">DocumentHighlightsItem</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Find references request; value of command field is 
     * &quot;references&quot;. Return response giving the file locations that 
     * reference the symbol found in file at location line, col. 
     */</span>
    <span class="s2">interface </span><span class="s3">ReferencesRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">References</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ReferencesResponseItem </span><span class="s2">extends </span><span class="s3">FileSpanWithContext </span><span class="s1">{</span>
        <span class="s0">/** Text of line containing the reference.  Including this 
         *  with the response avoids latency of editor loading files 
         * to show text of reference line (the server already has 
         * loaded the referencing files). 
         */</span>
        <span class="s1">lineText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if reference is a write location, false otherwise. 
         */</span>
        <span class="s1">isWriteAccess</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Present only if the search was triggered from a declaration. 
         * True indicates that the references refers to the same symbol 
         * (i.e. has the same meaning) as the declaration that began the 
         * search. 
         */</span>
        <span class="s1">isDefinition</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The body of a &quot;references&quot; response message. 
     */</span>
    <span class="s2">interface </span><span class="s3">ReferencesResponseBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The file locations referencing the symbol. 
         */</span>
        <span class="s1">refs</span><span class="s2">: readonly </span><span class="s3">ReferencesResponseItem</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the symbol. 
         */</span>
        <span class="s1">symbolName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The start character offset of the symbol (on the line provided by the references request). 
         */</span>
        <span class="s1">symbolStartOffset</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The full display name of the symbol. 
         */</span>
        <span class="s1">symbolDisplayString</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to &quot;references&quot; request. 
     */</span>
    <span class="s2">interface </span><span class="s3">ReferencesResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">ReferencesResponseBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FileReferencesRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">FileReferences</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FileReferencesResponseBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The file locations referencing the symbol. 
         */</span>
        <span class="s1">refs</span><span class="s2">: readonly </span><span class="s3">ReferencesResponseItem</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the symbol. 
         */</span>
        <span class="s1">symbolName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FileReferencesResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">FileReferencesResponseBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Argument for RenameRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">RenameRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Should text at specified location be found/changed in comments? 
         */</span>
        <span class="s1">findInComments</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Should text at specified location be found/changed in strings? 
         */</span>
        <span class="s1">findInStrings</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Rename request; value of command field is &quot;rename&quot;. Return 
     * response giving the file locations that reference the symbol 
     * found in file at location line, col. Also return full display 
     * name of the symbol so that client can print it unambiguously. 
     */</span>
    <span class="s2">interface </span><span class="s3">RenameRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Rename</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">RenameRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Information about the item to be renamed. 
     */</span>
    <span class="s2">type </span><span class="s3">RenameInfo </span><span class="s2">= </span><span class="s3">RenameInfoSuccess </span><span class="s2">| </span><span class="s3">RenameInfoFailure</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">RenameInfoSuccess </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* True if item can be renamed. 
         */</span>
        <span class="s1">canRename</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* File or directory to rename. 
         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`. 
         */</span>
        <span class="s1">fileToRename</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Display name of the item to be renamed. 
         */</span>
        <span class="s1">displayName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Full display name of item to be renamed. 
         */</span>
        <span class="s1">fullDisplayName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The items's kind (such as 'className' or 'parameterName' or plain 'text'). 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional modifiers for the kind (such as 'public'). 
         */</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** Span of text to rename. */</span>
        <span class="s1">triggerSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">RenameInfoFailure </span><span class="s1">{</span>
        <span class="s1">canRename</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Error message if item can not be renamed. 
         */</span>
        <span class="s1">localizedErrorMessage</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">*  A group of text spans, all in 'file'. 
     */</span>
    <span class="s2">interface </span><span class="s3">SpanGroup </span><span class="s1">{</span>
        <span class="s0">/** The file to which the spans apply */</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** The text spans in this group */</span>
        <span class="s1">locs</span><span class="s2">: </span><span class="s3">RenameTextSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">RenameTextSpan </span><span class="s2">extends </span><span class="s3">TextSpanWithContext </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">prefixText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">suffixText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">RenameResponseBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Information about the item to be renamed. 
         */</span>
        <span class="s1">info</span><span class="s2">: </span><span class="s3">RenameInfo</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of span groups (one per file) that refer to the item to be renamed. 
         */</span>
        <span class="s1">locs</span><span class="s2">: readonly </span><span class="s3">SpanGroup</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Rename response message. 
     */</span>
    <span class="s2">interface </span><span class="s3">RenameResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">RenameResponseBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a file in external project. 
     * External project is project whose set of files, compilation options and open\close state 
     * is maintained by the client (i.e. if all this data come from .csproj file in Visual Studio). 
     * External project will exist even if all files in it are closed and should be closed explicitly. 
     * If external project includes one or more tsconfig.json/jsconfig.json files then tsserver will 
     * create configured project for every config file but will maintain a link that these projects were created 
     * as a result of opening external project so they should be removed once external project is closed. 
     */</span>
    <span class="s2">interface </span><span class="s3">ExternalFile </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of file file 
         */</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Script kind of the file 
         */</span>
        <span class="s1">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKindName </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">ScriptKind</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Whether file has mixed content (i.e. .cshtml file that combines html markup with C#/JavaScript) 
         */</span>
        <span class="s1">hasMixedContent</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Content of the file 
         */</span>
        <span class="s1">content</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represent an external project 
     */</span>
    <span class="s2">interface </span><span class="s3">ExternalProject </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Project name 
         */</span>
        <span class="s1">projectFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* List of root files in project 
         */</span>
        <span class="s1">rootFiles</span><span class="s2">: </span><span class="s3">ExternalFile</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Compiler options for the project 
         */</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s3">ExternalProjectCompilerOptions</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">typingOptions. Use typeAcquisition instead 
         */</span>
        <span class="s1">typingOptions</span><span class="s2">?: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Explicitly specified type acquisition for the project 
         */</span>
        <span class="s1">typeAcquisition</span><span class="s2">?: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompileOnSaveMixin </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If compile on save is enabled for the project 
         */</span>
        <span class="s1">compileOnSave</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* For external projects, some of the project settings are sent together with 
     * compiler settings. 
     */</span>
    <span class="s2">type </span><span class="s3">ExternalProjectCompilerOptions </span><span class="s2">= </span><span class="s3">CompilerOptions </span><span class="s2">&amp; </span><span class="s3">CompileOnSaveMixin </span><span class="s2">&amp; </span><span class="s3">WatchOptions</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">FileWithProjectReferenceRedirectInfo </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of file 
         */</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if the file is primarily included in a referenced project 
         */</span>
        <span class="s1">isSourceOfProjectReferenceRedirect</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a set of changes that happen in project 
     */</span>
    <span class="s2">interface </span><span class="s3">ProjectChanges </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* List of added files 
         */</span>
        <span class="s1">added</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">FileWithProjectReferenceRedirectInfo</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* List of removed files 
         */</span>
        <span class="s1">removed</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">FileWithProjectReferenceRedirectInfo</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* List of updated files 
         */</span>
        <span class="s1">updated</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">FileWithProjectReferenceRedirectInfo</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* List of files that have had their project reference redirect status updated 
         * Only provided when the synchronizeProjectList request has includeProjectReferenceRedirectInfo set to true 
         */</span>
        <span class="s1">updatedRedirects</span><span class="s2">?: </span><span class="s3">FileWithProjectReferenceRedirectInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Information found in a configure request. 
     */</span>
    <span class="s2">interface </span><span class="s3">ConfigureRequestArguments </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Information about the host, for example 'Emacs 24.4' or 
         * 'Sublime Text version 3075' 
         */</span>
        <span class="s1">hostInfo</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If present, tab settings apply only to this file. 
         */</span>
        <span class="s1">file</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The format options to use during formatting and other code editing features. 
         */</span>
        <span class="s1">formatOptions</span><span class="s2">?: </span><span class="s3">FormatCodeSettings</span><span class="s1">;</span>
        <span class="s1">preferences</span><span class="s2">?: </span><span class="s3">UserPreferences</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The host's additional supported .js file extensions 
         */</span>
        <span class="s1">extraFileExtensions</span><span class="s2">?: </span><span class="s3">FileExtensionInfo</span><span class="s1">[];</span>
        <span class="s1">watchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">WatchFileKind </span><span class="s1">{</span>
        <span class="s3">FixedPollingInterval </span><span class="s2">= </span><span class="s4">&quot;FixedPollingInterval&quot;</span><span class="s1">,</span>
        <span class="s3">PriorityPollingInterval </span><span class="s2">= </span><span class="s4">&quot;PriorityPollingInterval&quot;</span><span class="s1">,</span>
        <span class="s3">DynamicPriorityPolling </span><span class="s2">= </span><span class="s4">&quot;DynamicPriorityPolling&quot;</span><span class="s1">,</span>
        <span class="s3">FixedChunkSizePolling </span><span class="s2">= </span><span class="s4">&quot;FixedChunkSizePolling&quot;</span><span class="s1">,</span>
        <span class="s3">UseFsEvents </span><span class="s2">= </span><span class="s4">&quot;UseFsEvents&quot;</span><span class="s1">,</span>
        <span class="s3">UseFsEventsOnParentDirectory </span><span class="s2">= </span><span class="s4">&quot;UseFsEventsOnParentDirectory&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">WatchDirectoryKind </span><span class="s1">{</span>
        <span class="s3">UseFsEvents </span><span class="s2">= </span><span class="s4">&quot;UseFsEvents&quot;</span><span class="s1">,</span>
        <span class="s3">FixedPollingInterval </span><span class="s2">= </span><span class="s4">&quot;FixedPollingInterval&quot;</span><span class="s1">,</span>
        <span class="s3">DynamicPriorityPolling </span><span class="s2">= </span><span class="s4">&quot;DynamicPriorityPolling&quot;</span><span class="s1">,</span>
        <span class="s3">FixedChunkSizePolling </span><span class="s2">= </span><span class="s4">&quot;FixedChunkSizePolling&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">PollingWatchKind </span><span class="s1">{</span>
        <span class="s3">FixedInterval </span><span class="s2">= </span><span class="s4">&quot;FixedInterval&quot;</span><span class="s1">,</span>
        <span class="s3">PriorityInterval </span><span class="s2">= </span><span class="s4">&quot;PriorityInterval&quot;</span><span class="s1">,</span>
        <span class="s3">DynamicPriority </span><span class="s2">= </span><span class="s4">&quot;DynamicPriority&quot;</span><span class="s1">,</span>
        <span class="s3">FixedChunkSize </span><span class="s2">= </span><span class="s4">&quot;FixedChunkSize&quot;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">WatchOptions </span><span class="s1">{</span>
        <span class="s1">watchFile</span><span class="s2">?: </span><span class="s3">WatchFileKind </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">WatchFileKind</span><span class="s1">;</span>
        <span class="s1">watchDirectory</span><span class="s2">?: </span><span class="s3">WatchDirectoryKind </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">WatchDirectoryKind</span><span class="s1">;</span>
        <span class="s1">fallbackPolling</span><span class="s2">?: </span><span class="s3">PollingWatchKind </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">PollingWatchKind</span><span class="s1">;</span>
        <span class="s1">synchronousWatchDirectory</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">excludeDirectories</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">excludeFiles</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">[</span><span class="s3">option</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s3">CompilerOptionsValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">*  Configure request; value of command field is &quot;configure&quot;.  Specifies 
     *  host information, such as host type, tab size, and indent size. 
     */</span>
    <span class="s2">interface </span><span class="s3">ConfigureRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Configure</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">ConfigureRequestArguments</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to &quot;configure&quot; request.  This is just an acknowledgement, so 
     * no body field is required. 
     */</span>
    <span class="s2">interface </span><span class="s3">ConfigureResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ConfigurePluginRequestArguments </span><span class="s1">{</span>
        <span class="s1">pluginName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">configuration</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ConfigurePluginRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ConfigurePlugin</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">ConfigurePluginRequestArguments</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ConfigurePluginResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SelectionRangeRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">SelectionRange</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">SelectionRangeRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SelectionRangeRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s1">locations</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SelectionRangeResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">SelectionRange</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SelectionRange </span><span class="s1">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">parent</span><span class="s2">?: </span><span class="s3">SelectionRange</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ToggleLineCommentRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ToggleLineComment</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FileRangeRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ToggleMultilineCommentRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ToggleMultilineComment</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FileRangeRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CommentSelectionRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">CommentSelection</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FileRangeRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">UncommentSelectionRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">UncommentSelection</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FileRangeRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">*  Information found in an &quot;open&quot; request. 
     */</span>
    <span class="s2">interface </span><span class="s3">OpenRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Used when a version of the file content is known to be more up to date than the one on disk. 
         * Then the known content will be used upon opening instead of the disk copy 
         */</span>
        <span class="s1">fileContent</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Used to specify the script kind of the file explicitly. It could be one of the following: 
         *      &quot;TS&quot;, &quot;JS&quot;, &quot;TSX&quot;, &quot;JSX&quot; 
         */</span>
        <span class="s1">scriptKindName</span><span class="s2">?: </span><span class="s3">ScriptKindName</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Used to limit the searching for project config file. If given the searching will stop at this 
         * root path; otherwise it will go all the way up to the dist root path. 
         */</span>
        <span class="s1">projectRootPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">ScriptKindName </span><span class="s2">= </span><span class="s4">&quot;TS&quot; </span><span class="s2">| </span><span class="s4">&quot;JS&quot; </span><span class="s2">| </span><span class="s4">&quot;TSX&quot; </span><span class="s2">| </span><span class="s4">&quot;JSX&quot;</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Open request; value of command field is &quot;open&quot;. Notify the 
     * server that the client has file open.  The server will not 
     * monitor the filesystem for changes in this file and will assume 
     * that the client is updating the server (using the change and/or 
     * reload messages) when the file changes. Server does not currently 
     * send a response to an open request. 
     */</span>
    <span class="s2">interface </span><span class="s3">OpenRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Open</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">OpenRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to open or update external project 
     */</span>
    <span class="s2">interface </span><span class="s3">OpenExternalProjectRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">OpenExternalProject</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">OpenExternalProjectArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments to OpenExternalProjectRequest request 
     */</span>
    <span class="s2">type </span><span class="s3">OpenExternalProjectArgs </span><span class="s2">= </span><span class="s3">ExternalProject</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to open multiple external projects 
     */</span>
    <span class="s2">interface </span><span class="s3">OpenExternalProjectsRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">OpenExternalProjects</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">OpenExternalProjectsArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments to OpenExternalProjectsRequest 
     */</span>
    <span class="s2">interface </span><span class="s3">OpenExternalProjectsArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* List of external projects to open or update 
         */</span>
        <span class="s1">projects</span><span class="s2">: </span><span class="s3">ExternalProject</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to OpenExternalProjectRequest request. This is just an acknowledgement, so 
     * no body field is required. 
     */</span>
    <span class="s2">interface </span><span class="s3">OpenExternalProjectResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to OpenExternalProjectsRequest request. This is just an acknowledgement, so 
     * no body field is required. 
     */</span>
    <span class="s2">interface </span><span class="s3">OpenExternalProjectsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to close external project. 
     */</span>
    <span class="s2">interface </span><span class="s3">CloseExternalProjectRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">CloseExternalProject</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">CloseExternalProjectRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments to CloseExternalProjectRequest request 
     */</span>
    <span class="s2">interface </span><span class="s3">CloseExternalProjectRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of the project to close 
         */</span>
        <span class="s1">projectFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to CloseExternalProjectRequest request. This is just an acknowledgement, so 
     * no body field is required. 
     */</span>
    <span class="s2">interface </span><span class="s3">CloseExternalProjectResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to synchronize list of open files with the client 
     */</span>
    <span class="s2">interface </span><span class="s3">UpdateOpenRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">UpdateOpen</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">UpdateOpenRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments to UpdateOpenRequest 
     */</span>
    <span class="s2">interface </span><span class="s3">UpdateOpenRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* List of newly open files 
         */</span>
        <span class="s1">openFiles</span><span class="s2">?: </span><span class="s3">OpenRequestArgs</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* List of open files files that were changes 
         */</span>
        <span class="s1">changedFiles</span><span class="s2">?: </span><span class="s3">FileCodeEdits</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* List of files that were closed 
         */</span>
        <span class="s1">closedFiles</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* External projects have a typeAcquisition option so they need to be added separately to compiler options for inferred projects. 
     */</span>
    <span class="s2">type </span><span class="s3">InferredProjectCompilerOptions </span><span class="s2">= </span><span class="s3">ExternalProjectCompilerOptions </span><span class="s2">&amp; </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to set compiler options for inferred projects. 
     * External projects are opened / closed explicitly. 
     * Configured projects are opened when user opens loose file that has 'tsconfig.json' or 'jsconfig.json' anywhere in one of containing folders. 
     * This configuration file will be used to obtain a list of files and configuration settings for the project. 
     * Inferred projects are created when user opens a loose file that is not the part of external project 
     * or configured project and will contain only open file and transitive closure of referenced files if 'useOneInferredProject' is false, 
     * or all open loose files and its transitive closure of referenced files if 'useOneInferredProject' is true. 
     */</span>
    <span class="s2">interface </span><span class="s3">SetCompilerOptionsForInferredProjectsRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">CompilerOptionsForInferredProjects</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">SetCompilerOptionsForInferredProjectsArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Argument for SetCompilerOptionsForInferredProjectsRequest request. 
     */</span>
    <span class="s2">interface </span><span class="s3">SetCompilerOptionsForInferredProjectsArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Compiler options to be used with inferred projects. 
         */</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s3">InferredProjectCompilerOptions</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Specifies the project root path used to scope compiler options. 
         * It is an error to provide this property if the server has not been started with 
         * `useInferredProjectPerProjectRoot` enabled. 
         */</span>
        <span class="s1">projectRootPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to SetCompilerOptionsForInferredProjectsResponse request. This is just an acknowledgement, so 
     * no body field is required. 
     */</span>
    <span class="s2">interface </span><span class="s3">SetCompilerOptionsForInferredProjectsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">*  Exit request; value of command field is &quot;exit&quot;.  Ask the server process 
     *  to exit. 
     */</span>
    <span class="s2">interface </span><span class="s3">ExitRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Exit</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Close request; value of command field is &quot;close&quot;. Notify the 
     * server that the client has closed a previously open file.  If 
     * file is still referenced by open files, the server will resume 
     * monitoring the filesystem for changes to file.  Server does not 
     * currently send a response to a close request. 
     */</span>
    <span class="s2">interface </span><span class="s3">CloseRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Close</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to obtain the list of files that should be regenerated if target file is recompiled. 
     * NOTE: this us query-only operation and does not generate any output on disk. 
     */</span>
    <span class="s2">interface </span><span class="s3">CompileOnSaveAffectedFileListRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">CompileOnSaveAffectedFileList</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Contains a list of files that should be regenerated in a project 
     */</span>
    <span class="s2">interface </span><span class="s3">CompileOnSaveAffectedFileListSingleProject </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Project name 
         */</span>
        <span class="s1">projectFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* List of files names that should be recompiled 
         */</span>
        <span class="s1">fileNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* true if project uses outFile or out compiler option 
         */</span>
        <span class="s1">projectUsesOutFile</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response for CompileOnSaveAffectedFileListRequest request; 
     */</span>
    <span class="s2">interface </span><span class="s3">CompileOnSaveAffectedFileListResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">CompileOnSaveAffectedFileListSingleProject</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Request to recompile the file. All generated outputs (.js, .d.ts or .js.map files) is written on disk. 
     */</span>
    <span class="s2">interface </span><span class="s3">CompileOnSaveEmitFileRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">CompileOnSaveEmitFile</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">CompileOnSaveEmitFileRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for CompileOnSaveEmitFileRequest 
     */</span>
    <span class="s2">interface </span><span class="s3">CompileOnSaveEmitFileRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* if true - then file should be recompiled even if it does not have any changes. 
         */</span>
        <span class="s1">forced</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">includeLinePosition</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** if true - return response as object with emitSkipped and diagnostics */</span>
        <span class="s1">richResponse</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompileOnSaveEmitFileResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">EmitResult</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">EmitResult </span><span class="s1">{</span>
        <span class="s1">emitSkipped</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">diagnostics</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">DiagnosticWithLinePosition</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Quickinfo request; value of command field is 
     * &quot;quickinfo&quot;. Return response giving a quick type and 
     * documentation string for the symbol found in file at location 
     * line, col. 
     */</span>
    <span class="s2">interface </span><span class="s3">QuickInfoRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Quickinfo</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FileLocationRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Body of QuickInfoResponse. 
     */</span>
    <span class="s2">interface </span><span class="s3">QuickInfoResponseBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's kind (such as 'className' or 'parameterName' or plain 'text'). 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional modifiers for the kind (such as 'public'). 
         */</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Starting file location of symbol. 
         */</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* One past last character of symbol. 
         */</span>
        <span class="s1">end</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Type and kind of symbol. 
         */</span>
        <span class="s1">displayString</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Documentation associated with symbol. 
         * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise. 
         */</span>
        <span class="s1">documentation</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* JSDoc tags associated with symbol. 
         */</span>
        <span class="s1">tags</span><span class="s2">: </span><span class="s3">JSDocTagInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Quickinfo response message. 
     */</span>
    <span class="s2">interface </span><span class="s3">QuickInfoResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">QuickInfoResponseBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for format messages. 
     */</span>
    <span class="s2">interface </span><span class="s3">FormatRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Last line of range for which to format text in file. 
         */</span>
        <span class="s1">endLine</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Character offset on last line of range for which to format text in file. 
         */</span>
        <span class="s1">endOffset</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Format options to be used. 
         */</span>
        <span class="s1">options</span><span class="s2">?: </span><span class="s3">FormatCodeSettings</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Format request; value of command field is &quot;format&quot;.  Return 
     * response giving zero or more edit instructions.  The edit 
     * instructions will be sorted in file order.  Applying the edit 
     * instructions in reverse to file will result in correctly 
     * reformatted text. 
     */</span>
    <span class="s2">interface </span><span class="s3">FormatRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Format</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FormatRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Object found in response messages defining an editing 
     * instruction for a span of text in source code.  The effect of 
     * this instruction is to replace the text starting at start and 
     * ending one character before end with newText. For an insertion, 
     * the text span is empty.  For a deletion, newText is empty. 
     */</span>
    <span class="s2">interface </span><span class="s3">CodeEdit </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* First character of the text span to edit. 
         */</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* One character past last character of the text span to edit. 
         */</span>
        <span class="s1">end</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Replace the span defined above with this string (may be 
         * the empty string). 
         */</span>
        <span class="s1">newText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FileCodeEdits </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">textChanges</span><span class="s2">: </span><span class="s3">CodeEdit</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CodeFixResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s0">/** The code actions that are available */</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">CodeFixAction</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CodeAction </span><span class="s1">{</span>
        <span class="s0">/** Description of the code action to display in the UI of the editor */</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** Text changes to apply to each file as part of the code action */</span>
        <span class="s1">changes</span><span class="s2">: </span><span class="s3">FileCodeEdits</span><span class="s1">[];</span>
        <span class="s0">/** A command is an opaque object that should be passed to `ApplyCodeActionCommandRequestArgs` without modification.  */</span>
        <span class="s1">commands</span><span class="s2">?: </span><span class="s1">{}[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CombinedCodeActions </span><span class="s1">{</span>
        <span class="s1">changes</span><span class="s2">: readonly </span><span class="s3">FileCodeEdits</span><span class="s1">[];</span>
        <span class="s1">commands</span><span class="s2">?: readonly </span><span class="s1">{}[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CodeFixAction </span><span class="s2">extends </span><span class="s3">CodeAction </span><span class="s1">{</span>
        <span class="s0">/** Short name to identify the fix, for use by telemetry. */</span>
        <span class="s1">fixName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If present, one may call 'getCombinedCodeFix' with this fixId. 
         * This may be omitted to indicate that the code fix can't be applied in a group. 
         */</span>
        <span class="s1">fixId</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s0">/** Should be present if and only if 'fixId' is. */</span>
        <span class="s1">fixAllDescription</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Format and format on key response message. 
     */</span>
    <span class="s2">interface </span><span class="s3">FormatResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">CodeEdit</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for format on key messages. 
     */</span>
    <span class="s2">interface </span><span class="s3">FormatOnKeyRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Key pressed (';', '\n', or '}'). 
         */</span>
        <span class="s1">key</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">options</span><span class="s2">?: </span><span class="s3">FormatCodeSettings</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Format on key request; value of command field is 
     * &quot;formatonkey&quot;. Given file location and key typed (as string), 
     * return response giving zero or more edit instructions.  The 
     * edit instructions will be sorted in file order.  Applying the 
     * edit instructions in reverse to file will result in correctly 
     * reformatted text. 
     */</span>
    <span class="s2">interface </span><span class="s3">FormatOnKeyRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Formatonkey</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">FormatOnKeyRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">CompletionsTriggerCharacter </span><span class="s2">= </span><span class="s4">&quot;.&quot; </span><span class="s2">| </span><span class="s4">'&quot;' </span><span class="s2">| </span><span class="s4">&quot;'&quot; </span><span class="s2">| </span><span class="s4">&quot;`&quot; </span><span class="s2">| </span><span class="s4">&quot;/&quot; </span><span class="s2">| </span><span class="s4">&quot;@&quot; </span><span class="s2">| </span><span class="s4">&quot;&lt;&quot; </span><span class="s2">| </span><span class="s4">&quot;#&quot; </span><span class="s2">| </span><span class="s4">&quot; &quot;</span><span class="s1">;</span>
    <span class="s2">enum </span><span class="s3">CompletionTriggerKind </span><span class="s1">{</span>
        <span class="s0">/** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */</span>
        <span class="s3">Invoked </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s0">/** Completion was triggered by a trigger character. */</span>
        <span class="s3">TriggerCharacter </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s0">/** Completion was re-triggered as the current completion list is incomplete. */</span>
        <span class="s3">TriggerForIncompleteCompletions </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for completions messages. 
     */</span>
    <span class="s2">interface </span><span class="s3">CompletionsRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional prefix to apply to possible completions. 
         */</span>
        <span class="s1">prefix</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Character that was responsible for triggering completion. 
         * Should be `undefined` if a user manually requested completion. 
         */</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s3">CompletionsTriggerCharacter</span><span class="s1">;</span>
        <span class="s1">triggerKind</span><span class="s2">?: </span><span class="s3">CompletionTriggerKind</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Use UserPreferences.includeCompletionsForModuleExports 
         */</span>
        <span class="s1">includeExternalModuleExports</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Use UserPreferences.includeCompletionsWithInsertText 
         */</span>
        <span class="s1">includeInsertTextCompletions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Completions request; value of command field is &quot;completions&quot;. 
     * Given a file location (file, line, col) and a prefix (which may 
     * be the empty string), return the possible completions that 
     * begin with prefix. 
     */</span>
    <span class="s2">interface </span><span class="s3">CompletionsRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Completions </span><span class="s2">| </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">CompletionInfo</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">CompletionsRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for completion details request. 
     */</span>
    <span class="s2">interface </span><span class="s3">CompletionDetailsRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Names of one or more entries for which to obtain details. 
         */</span>
        <span class="s1">entryNames</span><span class="s2">: </span><span class="s1">(</span><span class="s3">string </span><span class="s2">| </span><span class="s3">CompletionEntryIdentifier</span><span class="s1">)[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionEntryIdentifier </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">data</span><span class="s2">?: </span><span class="s3">unknown</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Completion entry details request; value of command field is 
     * &quot;completionEntryDetails&quot;.  Given a file location (file, line, 
     * col) and an array of completion entry names return more 
     * detailed information for each completion entry. 
     */</span>
    <span class="s2">interface </span><span class="s3">CompletionDetailsRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">CompletionDetails</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">CompletionDetailsRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Part of a symbol description. 
     */</span>
    <span class="s2">interface </span><span class="s3">SymbolDisplayPart </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Text of an item describing the symbol. 
         */</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's kind (such as 'className' or 'parameterName' or plain 'text'). 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** A part of a symbol description that links from a jsdoc </span><span class="s2">@link </span><span class="s0">tag to a declaration */</span>
    <span class="s2">interface </span><span class="s3">JSDocLinkDisplayPart </span><span class="s2">extends </span><span class="s3">SymbolDisplayPart </span><span class="s1">{</span>
        <span class="s0">/** The location of the declaration that the </span><span class="s2">@link </span><span class="s0">tag links to. */</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s3">FileSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* An item found in a completion response. 
     */</span>
    <span class="s2">interface </span><span class="s3">CompletionEntry </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's name. 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's kind (such as 'className' or 'parameterName'). 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional modifiers for the kind (such as 'public'). 
         */</span>
        <span class="s1">kindModifiers</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A string that is used for comparing completion items so that they can be ordered.  This 
         * is often the same as the name but may be different in certain circumstances. 
         */</span>
        <span class="s1">sortText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Text to insert instead of `name`. 
         * This is used to support bracketed completions; If `name` might be &quot;a-b&quot; but `insertText` would be `[&quot;a-b&quot;]`, 
         * coupled with `replacementSpan` to replace a dotted access with a bracket access. 
         */</span>
        <span class="s1">insertText</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* `insertText` should be interpreted as a snippet if true. 
         */</span>
        <span class="s1">isSnippet</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional span that indicates the text to be replaced by this completion item. 
         * If present, this span should be used instead of the default one. 
         * It will be set if the required span differs from the one generated by the default replacement behavior. 
         */</span>
        <span class="s1">replacementSpan</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether commiting this completion entry will require additional code actions to be 
         * made to avoid errors. The CompletionEntryDetails will have these actions. 
         */</span>
        <span class="s1">hasAction</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Identifier (not necessarily human-readable) identifying where this completion came from. 
         */</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Human-readable description of the `source`. 
         */</span>
        <span class="s1">sourceDisplay</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Additional details for the label. 
         */</span>
        <span class="s1">labelDetails</span><span class="s2">?: </span><span class="s3">CompletionEntryLabelDetails</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, this completion should be highlighted as recommended. There will only be one of these. 
         * This will be set when we know the user should write an expression with a certain type and that type is an enum or constructable class. 
         * Then either that enum/class or a namespace containing it will be the recommended symbol. 
         */</span>
        <span class="s1">isRecommended</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, this completion was generated from traversing the name table of an unchecked JS file, 
         * and therefore may not be accurate. 
         */</span>
        <span class="s1">isFromUncheckedFile</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, this completion was for an auto-import of a module not yet in the program, but listed 
         * in the project package.json. Used for telemetry reporting. 
         */</span>
        <span class="s1">isPackageJsonImport</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, this completion was an auto-import-style completion of an import statement (i.e., the 
         * module specifier was inserted along with the imported identifier). Used for telemetry reporting. 
         */</span>
        <span class="s1">isImportStatementCompletion</span><span class="s2">?: </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`, 
         * that allows TS Server to look up the symbol represented by the completion item, disambiguating 
         * items with the same name. 
         */</span>
        <span class="s1">data</span><span class="s2">?: </span><span class="s3">unknown</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionEntryLabelDetails </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional string which is rendered less prominently directly after 
         * </span><span class="s3">{</span><span class="s2">@link </span><span class="s3">CompletionEntry.name name}</span><span class="s0">, without any spacing. Should be 
         * used for function signatures or type annotations. 
         */</span>
        <span class="s1">detail</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional string which is rendered less prominently after 
         * </span><span class="s3">{</span><span class="s2">@link </span><span class="s3">CompletionEntryLabelDetails.detail}</span><span class="s0">. Should be used for fully qualified 
         * names or file path. 
         */</span>
        <span class="s1">description</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Additional completion entry details, available on demand 
     */</span>
    <span class="s2">interface </span><span class="s3">CompletionEntryDetails </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's name. 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's kind (such as 'className' or 'parameterName'). 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional modifiers for the kind (such as 'public'). 
         */</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Display parts of the symbol (similar to quick info). 
         */</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Documentation strings for the symbol. 
         */</span>
        <span class="s1">documentation</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* JSDoc tags for the symbol. 
         */</span>
        <span class="s1">tags</span><span class="s2">?: </span><span class="s3">JSDocTagInfo</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The associated code actions for this entry 
         */</span>
        <span class="s1">codeActions</span><span class="s2">?: </span><span class="s3">CodeAction</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Use `sourceDisplay` instead. 
         */</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Human-readable description of the `source` from the CompletionEntry. 
         */</span>
        <span class="s1">sourceDisplay</span><span class="s2">?: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Prefer CompletionInfoResponse, which supports several top-level fields in addition to the array of entries. */</span>
    <span class="s2">interface </span><span class="s3">CompletionsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">CompletionEntry</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionInfoResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">CompletionInfo</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionInfo </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">flags</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isGlobalCompletion</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isMemberCompletion</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isNewIdentifierLocation</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* In the absence of `CompletionEntry[&quot;replacementSpan&quot;]`, the editor may choose whether to use 
         * this span or its default one. If `CompletionEntry[&quot;replacementSpan&quot;]` is defined, that span 
         * must be used to commit that completion entry. 
         */</span>
        <span class="s2">readonly </span><span class="s1">optionalReplacementSpan</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">isIncomplete</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">entries</span><span class="s2">: readonly </span><span class="s3">CompletionEntry</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompletionDetailsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">CompletionEntryDetails</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signature help information for a single parameter 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpParameter </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The parameter's name 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Documentation of the parameter. 
         */</span>
        <span class="s1">documentation</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Display parts of the parameter. 
         */</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Whether the parameter is optional or not. 
         */</span>
        <span class="s1">isOptional</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents a single signature to show in signature help. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpItem </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Whether the signature accepts a variable number of arguments. 
         */</span>
        <span class="s1">isVariadic</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The prefix display parts. 
         */</span>
        <span class="s1">prefixDisplayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The suffix display parts. 
         */</span>
        <span class="s1">suffixDisplayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The separator display parts. 
         */</span>
        <span class="s1">separatorDisplayParts</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The signature helps items for the parameters. 
         */</span>
        <span class="s1">parameters</span><span class="s2">: </span><span class="s3">SignatureHelpParameter</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The signature's documentation 
         */</span>
        <span class="s1">documentation</span><span class="s2">: </span><span class="s3">SymbolDisplayPart</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The signature's JSDoc tags 
         */</span>
        <span class="s1">tags</span><span class="s2">: </span><span class="s3">JSDocTagInfo</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signature help items found in the response of a signature help request. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpItems </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The signature help items. 
         */</span>
        <span class="s1">items</span><span class="s2">: </span><span class="s3">SignatureHelpItem</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The span for which signature help should appear on a signature 
         */</span>
        <span class="s1">applicableSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The item selected in the set of available help items. 
         */</span>
        <span class="s1">selectedItemIndex</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The argument selected in the set of parameters. 
         */</span>
        <span class="s1">argumentIndex</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The argument count 
         */</span>
        <span class="s1">argumentCount</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">SignatureHelpTriggerCharacter </span><span class="s2">= </span><span class="s4">&quot;,&quot; </span><span class="s2">| </span><span class="s4">&quot;(&quot; </span><span class="s2">| </span><span class="s4">&quot;&lt;&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">SignatureHelpRetriggerCharacter </span><span class="s2">= </span><span class="s3">SignatureHelpTriggerCharacter </span><span class="s2">| </span><span class="s4">&quot;)&quot;</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments of a signature help request. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpRequestArgs </span><span class="s2">extends </span><span class="s3">FileLocationRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Reason why signature help was invoked. 
         * See each individual possible 
         */</span>
        <span class="s1">triggerReason</span><span class="s2">?: </span><span class="s3">SignatureHelpTriggerReason</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">SignatureHelpTriggerReason </span><span class="s2">= </span><span class="s3">SignatureHelpInvokedReason </span><span class="s2">| </span><span class="s3">SignatureHelpCharacterTypedReason </span><span class="s2">| </span><span class="s3">SignatureHelpRetriggeredReason</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that the user manually requested signature help. 
     * The language service will unconditionally attempt to provide a result. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpInvokedReason </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;invoked&quot;</span><span class="s1">;</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that the signature help request came from a user typing a character. 
     * Depending on the character and the syntactic context, the request may or may not be served a result. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpCharacterTypedReason </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;characterTyped&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Character that was responsible for triggering signature help. 
         */</span>
        <span class="s1">triggerCharacter</span><span class="s2">: </span><span class="s3">SignatureHelpTriggerCharacter</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signals that this signature help request came from typing a character or moving the cursor. 
     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust. 
     * The language service will unconditionally attempt to provide a result. 
     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpRetriggeredReason </span><span class="s1">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;retrigger&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Character that was responsible for triggering signature help. 
         */</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s3">SignatureHelpRetriggerCharacter</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Signature help request; value of command field is &quot;signatureHelp&quot;. 
     * Given a file location (file, line, col), return the signature 
     * help. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">SignatureHelp</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">SignatureHelpRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response object for a SignatureHelpRequest. 
     */</span>
    <span class="s2">interface </span><span class="s3">SignatureHelpResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">SignatureHelpItems</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">InlayHintKind </span><span class="s2">= </span><span class="s4">&quot;Type&quot; </span><span class="s2">| </span><span class="s4">&quot;Parameter&quot; </span><span class="s2">| </span><span class="s4">&quot;Enum&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">InlayHintsRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Start position of the span. 
         */</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Length of the span. 
         */</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InlayHintsRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ProvideInlayHints</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">InlayHintsRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InlayHintItem </span><span class="s1">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">position</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">InlayHintKind</span><span class="s1">;</span>
        <span class="s1">whitespaceBefore</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">whitespaceAfter</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InlayHintsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">InlayHintItem</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Synchronous request for semantic diagnostics of one file. 
     */</span>
    <span class="s2">interface </span><span class="s3">SemanticDiagnosticsSyncRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">SemanticDiagnosticsSync</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">SemanticDiagnosticsSyncRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SemanticDiagnosticsSyncRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s1">includeLinePosition</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response object for synchronous sematic diagnostics request. 
     */</span>
    <span class="s2">interface </span><span class="s3">SemanticDiagnosticsSyncResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">Diagnostic</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">DiagnosticWithLinePosition</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SuggestionDiagnosticsSyncRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">SuggestionDiagnosticsSync</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">SuggestionDiagnosticsSyncRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">SuggestionDiagnosticsSyncRequestArgs </span><span class="s2">= </span><span class="s3">SemanticDiagnosticsSyncRequestArgs</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">SuggestionDiagnosticsSyncResponse </span><span class="s2">= </span><span class="s3">SemanticDiagnosticsSyncResponse</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Synchronous request for syntactic diagnostics of one file. 
     */</span>
    <span class="s2">interface </span><span class="s3">SyntacticDiagnosticsSyncRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">SyntacticDiagnosticsSync</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">SyntacticDiagnosticsSyncRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SyntacticDiagnosticsSyncRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s1">includeLinePosition</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response object for synchronous syntactic diagnostics request. 
     */</span>
    <span class="s2">interface </span><span class="s3">SyntacticDiagnosticsSyncResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">Diagnostic</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">DiagnosticWithLinePosition</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for GeterrForProject request. 
     */</span>
    <span class="s2">interface </span><span class="s3">GeterrForProjectRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* the file requesting project error list 
         */</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Delay in milliseconds to wait before starting to compute 
         * errors for the files in the file list 
         */</span>
        <span class="s1">delay</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* GeterrForProjectRequest request; value of command field is 
     * &quot;geterrForProject&quot;. It works similarly with 'Geterr', only 
     * it request for every file in this project. 
     */</span>
    <span class="s2">interface </span><span class="s3">GeterrForProjectRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">GeterrForProject</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">GeterrForProjectRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for geterr messages. 
     */</span>
    <span class="s2">interface </span><span class="s3">GeterrRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* List of file names for which to compute compiler errors. 
         * The files will be checked in list order. 
         */</span>
        <span class="s1">files</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Delay in milliseconds to wait before starting to compute 
         * errors for the files in the file list 
         */</span>
        <span class="s1">delay</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Geterr request; value of command field is &quot;geterr&quot;. Wait for 
     * delay milliseconds and then, if during the wait no change or 
     * reload messages have arrived for the first file in the files 
     * list, get the syntactic errors for the file, field requests, 
     * and then get the semantic errors for the file.  Repeat with a 
     * smaller delay for each subsequent file on the files list.  Best 
     * practice for an editor is to send a file list containing each 
     * file that is currently visible, in most-recently-used order. 
     */</span>
    <span class="s2">interface </span><span class="s3">GeterrRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Geterr</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">GeterrRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">RequestCompletedEventName </span><span class="s2">= </span><span class="s4">&quot;requestCompleted&quot;</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Event that is sent when server have finished processing request with specified id. 
     */</span>
    <span class="s2">interface </span><span class="s3">RequestCompletedEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">RequestCompletedEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">RequestCompletedEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">RequestCompletedEventBody </span><span class="s1">{</span>
        <span class="s1">request_seq</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Item of diagnostic information found in a DiagnosticEvent message. 
     */</span>
    <span class="s2">interface </span><span class="s3">Diagnostic </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Starting file location at which text applies. 
         */</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The last file location at which the text applies. 
         */</span>
        <span class="s1">end</span><span class="s2">: </span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Text of diagnostic message. 
         */</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The category of the diagnostic message, e.g. &quot;error&quot;, &quot;warning&quot;, or &quot;suggestion&quot;. 
         */</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">reportsUnnecessary</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s1">reportsDeprecated</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s0">/**</span>
         <span class="s0">* Any related spans the diagnostic may have, such as other locations relevant to an error, such as declarartion sites 
         */</span>
        <span class="s1">relatedInformation</span><span class="s2">?: </span><span class="s3">DiagnosticRelatedInformation</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* The error code of the diagnostic message. 
         */</span>
        <span class="s1">code</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the plugin reporting the message. 
         */</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DiagnosticWithFileName </span><span class="s2">extends </span><span class="s3">Diagnostic </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of the file the diagnostic is in 
         */</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Represents additional spans returned with a diagnostic which are relevant to it 
     */</span>
    <span class="s2">interface </span><span class="s3">DiagnosticRelatedInformation </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The category of the related information message, e.g. &quot;error&quot;, &quot;warning&quot;, or &quot;suggestion&quot;. 
         */</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The code used ot identify the related information 
         */</span>
        <span class="s1">code</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Text of related or additional information. 
         */</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Associated location 
         */</span>
        <span class="s1">span</span><span class="s2">?: </span><span class="s3">FileSpan</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">DiagnosticEventBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The file for which diagnostic information is reported. 
         */</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of diagnostic information items. 
         */</span>
        <span class="s1">diagnostics</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">DiagnosticEventKind </span><span class="s2">= </span><span class="s4">&quot;semanticDiag&quot; </span><span class="s2">| </span><span class="s4">&quot;syntaxDiag&quot; </span><span class="s2">| </span><span class="s4">&quot;suggestionDiag&quot;</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Event message for DiagnosticEventKind event types. 
     * These events provide syntactic and semantic errors for a file. 
     */</span>
    <span class="s2">interface </span><span class="s3">DiagnosticEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">DiagnosticEventBody</span><span class="s1">;</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">DiagnosticEventKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ConfigFileDiagnosticEventBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The file which trigged the searching and error-checking of the config file 
         */</span>
        <span class="s1">triggerFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the found config file. 
         */</span>
        <span class="s1">configFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An arry of diagnostic information items for the found config file. 
         */</span>
        <span class="s1">diagnostics</span><span class="s2">: </span><span class="s3">DiagnosticWithFileName</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Event message for &quot;configFileDiag&quot; event type. 
     * This event provides errors for a found config file. 
     */</span>
    <span class="s2">interface </span><span class="s3">ConfigFileDiagnosticEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">ConfigFileDiagnosticEventBody</span><span class="s1">;</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s4">&quot;configFileDiag&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">ProjectLanguageServiceStateEventName </span><span class="s2">= </span><span class="s4">&quot;projectLanguageServiceState&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">ProjectLanguageServiceStateEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">ProjectLanguageServiceStateEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">ProjectLanguageServiceStateEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProjectLanguageServiceStateEventBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Project name that has changes in the state of language service. 
         * For configured projects this will be the config file path. 
         * For external projects this will be the name of the projects specified when project was open. 
         * For inferred projects this event is not raised. 
         */</span>
        <span class="s1">projectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* True if language service state switched from disabled to enabled 
         * and false otherwise. 
         */</span>
        <span class="s1">languageServiceEnabled</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">ProjectsUpdatedInBackgroundEventName </span><span class="s2">= </span><span class="s4">&quot;projectsUpdatedInBackground&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">ProjectsUpdatedInBackgroundEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">ProjectsUpdatedInBackgroundEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">ProjectsUpdatedInBackgroundEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProjectsUpdatedInBackgroundEventBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Current set of open files 
         */</span>
        <span class="s1">openFiles</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">ProjectLoadingStartEventName </span><span class="s2">= </span><span class="s4">&quot;projectLoadingStart&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">ProjectLoadingStartEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">ProjectLoadingStartEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">ProjectLoadingStartEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProjectLoadingStartEventBody </span><span class="s1">{</span>
        <span class="s0">/** name of the project */</span>
        <span class="s1">projectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** reason for loading */</span>
        <span class="s1">reason</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">ProjectLoadingFinishEventName </span><span class="s2">= </span><span class="s4">&quot;projectLoadingFinish&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">ProjectLoadingFinishEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">ProjectLoadingFinishEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">ProjectLoadingFinishEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProjectLoadingFinishEventBody </span><span class="s1">{</span>
        <span class="s0">/** name of the project */</span>
        <span class="s1">projectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">SurveyReadyEventName </span><span class="s2">= </span><span class="s4">&quot;surveyReady&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">SurveyReadyEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">SurveyReadyEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">SurveyReadyEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SurveyReadyEventBody </span><span class="s1">{</span>
        <span class="s0">/** Name of the survey. This is an internal machine- and programmer-friendly name */</span>
        <span class="s1">surveyId</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">LargeFileReferencedEventName </span><span class="s2">= </span><span class="s4">&quot;largeFileReferenced&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">LargeFileReferencedEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">LargeFileReferencedEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">LargeFileReferencedEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">LargeFileReferencedEventBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* name of the large file being loaded 
         */</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* size of the file 
         */</span>
        <span class="s1">fileSize</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* max file size allowed on the server 
         */</span>
        <span class="s1">maxFileSize</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for reload request. 
     */</span>
    <span class="s2">interface </span><span class="s3">ReloadRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of temporary file from which to reload file 
         * contents. May be same as file. 
         */</span>
        <span class="s1">tmpfile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Reload request message; value of command field is &quot;reload&quot;. 
     * Reload contents of file with name given by the 'file' argument 
     * from temporary file with name given by the 'tmpfile' argument. 
     * The two names can be identical. 
     */</span>
    <span class="s2">interface </span><span class="s3">ReloadRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Reload</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">ReloadRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to &quot;reload&quot; request. This is just an acknowledgement, so 
     * no body field is required. 
     */</span>
    <span class="s2">interface </span><span class="s3">ReloadResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for saveto request. 
     */</span>
    <span class="s2">interface </span><span class="s3">SavetoRequestArgs </span><span class="s2">extends </span><span class="s3">FileRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of temporary file into which to save server's view of 
         * file contents. 
         */</span>
        <span class="s1">tmpfile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Saveto request message; value of command field is &quot;saveto&quot;. 
     * For debugging purposes, save to a temporaryfile (named by 
     * argument 'tmpfile') the contents of file named by argument 
     * 'file'.  The server does not currently send a response to a 
     * &quot;saveto&quot; request. 
     */</span>
    <span class="s2">interface </span><span class="s3">SavetoRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Saveto</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">SavetoRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for navto request message. 
     */</span>
    <span class="s2">interface </span><span class="s3">NavtoRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Search term to navigate to from current location; term can 
         * be '.*' or an identifier prefix. 
         */</span>
        <span class="s1">searchValue</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  Optional limit on the number of items to return. 
         */</span>
        <span class="s1">maxResultCount</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The file for the request (absolute pathname required). 
         */</span>
        <span class="s1">file</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional flag to indicate we want results for just the current file 
         * or the entire project. 
         */</span>
        <span class="s1">currentFileOnly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">projectFileName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Navto request message; value of command field is &quot;navto&quot;. 
     * Return list of objects giving file locations and symbols that 
     * match the search term given in argument 'searchTerm'.  The 
     * context for the search is given by the named file. 
     */</span>
    <span class="s2">interface </span><span class="s3">NavtoRequest </span><span class="s2">extends </span><span class="s3">Request </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Navto</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">NavtoRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* An item found in a navto response. 
     */</span>
    <span class="s2">interface </span><span class="s3">NavtoItem </span><span class="s2">extends </span><span class="s3">FileSpan </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's name. 
         */</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's kind (such as 'className' or 'parameterName'). 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* exact, substring, or prefix. 
         */</span>
        <span class="s1">matchKind</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If this was a case sensitive or insensitive match. 
         */</span>
        <span class="s1">isCaseSensitive</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional modifiers for the kind (such as 'public'). 
         */</span>
        <span class="s1">kindModifiers</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of symbol's container symbol (if any); for example, 
         * the class name if symbol is a class member. 
         */</span>
        <span class="s1">containerName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Kind of symbol's container symbol (if any). 
         */</span>
        <span class="s1">containerKind</span><span class="s2">?: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Navto response message. Body is an array of navto items.  Each 
     * item gives a symbol that matched the search term. 
     */</span>
    <span class="s2">interface </span><span class="s3">NavtoResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">NavtoItem</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Arguments for change request message. 
     */</span>
    <span class="s2">interface </span><span class="s3">ChangeRequestArgs </span><span class="s2">extends </span><span class="s3">FormatRequestArgs </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional string to insert at location (file, line, offset). 
         */</span>
        <span class="s1">insertString</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Change request message; value of command field is &quot;change&quot;. 
     * Update the server's view of the file named by argument 'file'. 
     * Server does not currently send a response to a change request. 
     */</span>
    <span class="s2">interface </span><span class="s3">ChangeRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Change</span><span class="s1">;</span>
        <span class="s1">arguments</span><span class="s2">: </span><span class="s3">ChangeRequestArgs</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Response to &quot;brace&quot; request. 
     */</span>
    <span class="s2">interface </span><span class="s3">BraceResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Brace matching request; value of command field is &quot;brace&quot;. 
     * Return response giving the file locations of matching braces 
     * found in file at location line, offset. 
     */</span>
    <span class="s2">interface </span><span class="s3">BraceRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">Brace</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* NavBar items request; value of command field is &quot;navbar&quot;. 
     * Return response giving the list of navigation bar entries 
     * extracted from the requested file. 
     */</span>
    <span class="s2">interface </span><span class="s3">NavBarRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">NavBar</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* NavTree request; value of command field is &quot;navtree&quot;. 
     * Return response giving the navigation tree of the requested file. 
     */</span>
    <span class="s2">interface </span><span class="s3">NavTreeRequest </span><span class="s2">extends </span><span class="s3">FileRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">NavTree</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">NavigationBarItem </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The item's display text. 
         */</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The symbol's kind (such as 'className' or 'parameterName'). 
         */</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional modifiers for the kind (such as 'public'). 
         */</span>
        <span class="s1">kindModifiers</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The definition locations of the item. 
         */</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional children. 
         */</span>
        <span class="s1">childItems</span><span class="s2">?: </span><span class="s3">NavigationBarItem</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Number of levels deep this item should appear. 
         */</span>
        <span class="s1">indent</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** protocol.NavigationTree is identical to ts.NavigationTree, except using protocol.TextSpan instead of ts.TextSpan */</span>
    <span class="s2">interface </span><span class="s3">NavigationTree </span><span class="s1">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
        <span class="s1">nameSpan</span><span class="s2">: </span><span class="s3">TextSpan </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">childItems</span><span class="s2">?: </span><span class="s3">NavigationTree</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">TelemetryEventName </span><span class="s2">= </span><span class="s4">&quot;telemetry&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">TelemetryEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">TelemetryEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">TelemetryEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TelemetryEventBody </span><span class="s1">{</span>
        <span class="s1">telemetryEventName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">payload</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">TypesInstallerInitializationFailedEventName </span><span class="s2">= </span><span class="s4">&quot;typesInstallerInitializationFailed&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">TypesInstallerInitializationFailedEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">TypesInstallerInitializationFailedEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">TypesInstallerInitializationFailedEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TypesInstallerInitializationFailedEventBody </span><span class="s1">{</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">TypingsInstalledTelemetryEventName </span><span class="s2">= </span><span class="s4">&quot;typingsInstalled&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">TypingsInstalledTelemetryEventBody </span><span class="s2">extends </span><span class="s3">TelemetryEventBody </span><span class="s1">{</span>
        <span class="s1">telemetryEventName</span><span class="s2">: </span><span class="s3">TypingsInstalledTelemetryEventName</span><span class="s1">;</span>
        <span class="s1">payload</span><span class="s2">: </span><span class="s3">TypingsInstalledTelemetryEventPayload</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">TypingsInstalledTelemetryEventPayload </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Comma separated list of installed typing packages 
         */</span>
        <span class="s1">installedPackages</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* true if install request succeeded, otherwise - false 
         */</span>
        <span class="s1">installSuccess</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* version of typings installer 
         */</span>
        <span class="s1">typingsInstallerVersion</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">BeginInstallTypesEventName </span><span class="s2">= </span><span class="s4">&quot;beginInstallTypes&quot;</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">EndInstallTypesEventName </span><span class="s2">= </span><span class="s4">&quot;endInstallTypes&quot;</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">BeginInstallTypesEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">BeginInstallTypesEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">BeginInstallTypesEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">EndInstallTypesEvent </span><span class="s2">extends </span><span class="s3">Event </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">EndInstallTypesEventName</span><span class="s1">;</span>
        <span class="s1">body</span><span class="s2">: </span><span class="s3">EndInstallTypesEventBody</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">InstallTypesEventBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* correlation id to match begin and end events 
         */</span>
        <span class="s1">eventId</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* list of packages to install 
         */</span>
        <span class="s1">packages</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">BeginInstallTypesEventBody </span><span class="s2">extends </span><span class="s3">InstallTypesEventBody </span><span class="s1">{</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">EndInstallTypesEventBody </span><span class="s2">extends </span><span class="s3">InstallTypesEventBody </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* true if installation succeeded, otherwise false 
         */</span>
        <span class="s1">success</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">NavBarResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">NavigationBarItem</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">NavTreeResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s1">body</span><span class="s2">?: </span><span class="s3">NavigationTree</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CallHierarchyItem </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s3">ScriptElementKind</span><span class="s1">;</span>
        <span class="s1">kindModifiers</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">selectionSpan</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s1">containerName</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CallHierarchyIncomingCall </span><span class="s1">{</span>
        <span class="s1">from</span><span class="s2">: </span><span class="s3">CallHierarchyItem</span><span class="s1">;</span>
        <span class="s1">fromSpans</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CallHierarchyOutgoingCall </span><span class="s1">{</span>
        <span class="s1">to</span><span class="s2">: </span><span class="s3">CallHierarchyItem</span><span class="s1">;</span>
        <span class="s1">fromSpans</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PrepareCallHierarchyRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">PrepareCallHierarchy</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PrepareCallHierarchyResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">CallHierarchyItem </span><span class="s2">| </span><span class="s3">CallHierarchyItem</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProvideCallHierarchyIncomingCallsRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ProvideCallHierarchyIncomingCalls</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProvideCallHierarchyIncomingCallsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">CallHierarchyIncomingCall</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProvideCallHierarchyOutgoingCallsRequest </span><span class="s2">extends </span><span class="s3">FileLocationRequest </span><span class="s1">{</span>
        <span class="s1">command</span><span class="s2">: </span><span class="s3">CommandTypes</span><span class="s1">.</span><span class="s3">ProvideCallHierarchyOutgoingCalls</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ProvideCallHierarchyOutgoingCallsResponse </span><span class="s2">extends </span><span class="s3">Response </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">body</span><span class="s2">: </span><span class="s3">CallHierarchyOutgoingCall</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">IndentStyle </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s4">&quot;None&quot;</span><span class="s1">,</span>
        <span class="s3">Block </span><span class="s2">= </span><span class="s4">&quot;Block&quot;</span><span class="s1">,</span>
        <span class="s3">Smart </span><span class="s2">= </span><span class="s4">&quot;Smart&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">SemicolonPreference </span><span class="s1">{</span>
        <span class="s3">Ignore </span><span class="s2">= </span><span class="s4">&quot;ignore&quot;</span><span class="s1">,</span>
        <span class="s3">Insert </span><span class="s2">= </span><span class="s4">&quot;insert&quot;</span><span class="s1">,</span>
        <span class="s3">Remove </span><span class="s2">= </span><span class="s4">&quot;remove&quot;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">EditorSettings </span><span class="s1">{</span>
        <span class="s1">baseIndentSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">indentSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">tabSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">newLineCharacter</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">convertTabsToSpaces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">indentStyle</span><span class="s2">?: </span><span class="s3">IndentStyle </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">IndentStyle</span><span class="s1">;</span>
        <span class="s1">trimTrailingWhitespace</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FormatCodeSettings </span><span class="s2">extends </span><span class="s3">EditorSettings </span><span class="s1">{</span>
        <span class="s1">insertSpaceAfterCommaDelimiter</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterSemicolonInForStatements</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceBeforeAndAfterBinaryOperators</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterConstructor</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterKeywordsInControlFlowStatements</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterFunctionKeywordForAnonymousFunctions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterOpeningAndBeforeClosingEmptyBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceAfterTypeAssertion</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceBeforeFunctionParenthesis</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">placeOpenBraceOnNewLineForFunctions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">placeOpenBraceOnNewLineForControlBlocks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">insertSpaceBeforeTypeAnnotation</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">semicolons</span><span class="s2">?: </span><span class="s3">SemicolonPreference</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">UserPreferences </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">disableSuggestions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">quotePreference</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;double&quot; </span><span class="s2">| </span><span class="s4">&quot;single&quot;</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If enabled, TypeScript will search through all external modules' exports and add them to the completions list. 
         * This affects lone identifier completions but not completions on the right hand side of `obj.`. 
         */</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsForModuleExports</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables auto-import-style completions on partially-typed import statements. E.g., allows 
         * `import write|` to be completed to `import { writeFile } from &quot;fs&quot;`. 
         */</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsForImportStatements</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Allows completions to be formatted with snippet text, indicated by `CompletionItem[&quot;isSnippet&quot;]`. 
         */</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsWithSnippetText</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If enabled, the completion list will include completions with invalid identifier names. 
         * For those entries, The `insertText` and `replacementSpan` properties will be set to change from `.x` property access to `[&quot;x&quot;]`. 
         */</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsWithInsertText</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Unless this option is `false`, or `includeCompletionsWithInsertText` is not enabled, 
         * member completion lists triggered with `.` will include entries on potentially-null and potentially-undefined 
         * values, with insertion text to replace preceding `.` tokens with `?.`. 
         */</span>
        <span class="s2">readonly </span><span class="s1">includeAutomaticOptionalChainCompletions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If enabled, completions for class members (e.g. methods and properties) will include 
         * a whole declaration for the member. 
         * E.g., `class A { f| }` could be completed to `class A { foo(): number {} }`, instead of 
         * `class A { foo }`. 
         */</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsWithClassMemberSnippets</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If enabled, object literal methods will have a method declaration completion entry in addition 
         * to the regular completion entry containing just the method name. 
         * E.g., `const objectLiteral: T = { f| }` could be completed to `const objectLiteral: T = { foo(): void {} }`, 
         * in addition to `const objectLiteral: T = { foo }`. 
         */</span>
        <span class="s2">readonly </span><span class="s1">includeCompletionsWithObjectLiteralMethodSnippets</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Indicates whether </span><span class="s3">{</span><span class="s2">@link </span><span class="s3">CompletionEntry.labelDetails completion entry label details} </span><span class="s0">are supported. 
         * If not, contents of `labelDetails` may be included in the </span><span class="s3">{</span><span class="s2">@link </span><span class="s3">CompletionEntry.name} </span><span class="s0">property. 
         */</span>
        <span class="s2">readonly </span><span class="s1">useLabelDetailsInCompletionEntries</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">allowIncompleteCompletions</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">importModuleSpecifierPreference</span><span class="s2">?: </span><span class="s4">&quot;shortest&quot; </span><span class="s2">| </span><span class="s4">&quot;project-relative&quot; </span><span class="s2">| </span><span class="s4">&quot;relative&quot; </span><span class="s2">| </span><span class="s4">&quot;non-relative&quot;</span><span class="s1">;</span>
        <span class="s0">/** Determines whether we import `foo/index.ts` as &quot;foo&quot;, &quot;foo/index&quot;, or &quot;foo/index.js&quot; */</span>
        <span class="s2">readonly </span><span class="s1">importModuleSpecifierEnding</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;minimal&quot; </span><span class="s2">| </span><span class="s4">&quot;index&quot; </span><span class="s2">| </span><span class="s4">&quot;js&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">allowTextChangesInNewFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">lazyConfiguredProjectsFromExternalProject</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">providePrefixAndSuffixTextForRename</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">provideRefactorNotApplicableReason</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">allowRenameOfImportPath</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includePackageJsonAutoImports</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;on&quot; </span><span class="s2">| </span><span class="s4">&quot;off&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">jsxAttributeCompletionStyle</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;braces&quot; </span><span class="s2">| </span><span class="s4">&quot;none&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">displayPartsForJSDoc</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">generateReturnInDocTemplate</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayParameterNameHints</span><span class="s2">?: </span><span class="s4">&quot;none&quot; </span><span class="s2">| </span><span class="s4">&quot;literals&quot; </span><span class="s2">| </span><span class="s4">&quot;all&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayParameterNameHintsWhenArgumentMatchesName</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayFunctionParameterTypeHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayVariableTypeHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayVariableTypeHintsWhenTypeMatchesName</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayPropertyDeclarationTypeHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayFunctionLikeReturnTypeHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">includeInlayEnumMemberValueHints</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">autoImportFileExcludePatterns</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">CompilerOptions </span><span class="s1">{</span>
        <span class="s1">allowJs</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">allowSyntheticDefaultImports</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">allowUnreachableCode</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">allowUnusedLabels</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">alwaysStrict</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">baseUrl</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">charset</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">checkJs</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">declaration</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">declarationDir</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">disableSizeLimit</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">downlevelIteration</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">emitBOM</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">emitDecoratorMetadata</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">experimentalDecorators</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">forceConsistentCasingInFileNames</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">importHelpers</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">inlineSourceMap</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">inlineSources</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isolatedModules</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">jsx</span><span class="s2">?: </span><span class="s3">JsxEmit </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">JsxEmit</span><span class="s1">;</span>
        <span class="s1">lib</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">locale</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">mapRoot</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">maxNodeModuleJsDepth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">module</span><span class="s2">?: </span><span class="s3">ModuleKind </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">ModuleKind</span><span class="s1">;</span>
        <span class="s1">moduleResolution</span><span class="s2">?: </span><span class="s3">ModuleResolutionKind </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">ModuleResolutionKind</span><span class="s1">;</span>
        <span class="s1">newLine</span><span class="s2">?: </span><span class="s3">NewLineKind </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">NewLineKind</span><span class="s1">;</span>
        <span class="s1">noEmit</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noEmitHelpers</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noEmitOnError</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noErrorTruncation</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noFallthroughCasesInSwitch</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitAny</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitReturns</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitThis</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noUnusedLocals</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noUnusedParameters</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noImplicitUseStrict</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noLib</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">noResolve</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">out</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">outDir</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">outFile</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">paths</span><span class="s2">?: </span><span class="s3">MapLike</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">[]&gt;;</span>
        <span class="s1">plugins</span><span class="s2">?: </span><span class="s3">PluginImport</span><span class="s1">[];</span>
        <span class="s1">preserveConstEnums</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">preserveSymlinks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">project</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">reactNamespace</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">removeComments</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">references</span><span class="s2">?: </span><span class="s3">ProjectReference</span><span class="s1">[];</span>
        <span class="s1">rootDir</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">rootDirs</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">skipLibCheck</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">skipDefaultLibCheck</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">sourceMap</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">sourceRoot</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">strict</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">strictNullChecks</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">suppressExcessPropertyErrors</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">suppressImplicitAnyIndexErrors</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">useDefineForClassFields</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">target</span><span class="s2">?: </span><span class="s3">ScriptTarget </span><span class="s2">| </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">ScriptTarget</span><span class="s1">;</span>
        <span class="s1">traceResolution</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">resolveJsonModule</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">types</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/** Paths used to used to compute primary types search locations */</span>
        <span class="s1">typeRoots</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">[</span><span class="s3">option</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s3">CompilerOptionsValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">JsxEmit </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s4">&quot;None&quot;</span><span class="s1">,</span>
        <span class="s3">Preserve </span><span class="s2">= </span><span class="s4">&quot;Preserve&quot;</span><span class="s1">,</span>
        <span class="s3">ReactNative </span><span class="s2">= </span><span class="s4">&quot;ReactNative&quot;</span><span class="s1">,</span>
        <span class="s3">React </span><span class="s2">= </span><span class="s4">&quot;React&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">ModuleKind </span><span class="s1">{</span>
        <span class="s3">None </span><span class="s2">= </span><span class="s4">&quot;None&quot;</span><span class="s1">,</span>
        <span class="s3">CommonJS </span><span class="s2">= </span><span class="s4">&quot;CommonJS&quot;</span><span class="s1">,</span>
        <span class="s3">AMD </span><span class="s2">= </span><span class="s4">&quot;AMD&quot;</span><span class="s1">,</span>
        <span class="s3">UMD </span><span class="s2">= </span><span class="s4">&quot;UMD&quot;</span><span class="s1">,</span>
        <span class="s3">System </span><span class="s2">= </span><span class="s4">&quot;System&quot;</span><span class="s1">,</span>
        <span class="s3">ES6 </span><span class="s2">= </span><span class="s4">&quot;ES6&quot;</span><span class="s1">,</span>
        <span class="s3">ES2015 </span><span class="s2">= </span><span class="s4">&quot;ES2015&quot;</span><span class="s1">,</span>
        <span class="s3">ESNext </span><span class="s2">= </span><span class="s4">&quot;ESNext&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">ModuleResolutionKind </span><span class="s1">{</span>
        <span class="s3">Classic </span><span class="s2">= </span><span class="s4">&quot;Classic&quot;</span><span class="s1">,</span>
        <span class="s3">Node </span><span class="s2">= </span><span class="s4">&quot;Node&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">NewLineKind </span><span class="s1">{</span>
        <span class="s3">Crlf </span><span class="s2">= </span><span class="s4">&quot;Crlf&quot;</span><span class="s1">,</span>
        <span class="s3">Lf </span><span class="s2">= </span><span class="s4">&quot;Lf&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">ScriptTarget </span><span class="s1">{</span>
        <span class="s3">ES3 </span><span class="s2">= </span><span class="s4">&quot;ES3&quot;</span><span class="s1">,</span>
        <span class="s3">ES5 </span><span class="s2">= </span><span class="s4">&quot;ES5&quot;</span><span class="s1">,</span>
        <span class="s3">ES6 </span><span class="s2">= </span><span class="s4">&quot;ES6&quot;</span><span class="s1">,</span>
        <span class="s3">ES2015 </span><span class="s2">= </span><span class="s4">&quot;ES2015&quot;</span><span class="s1">,</span>
        <span class="s3">ES2016 </span><span class="s2">= </span><span class="s4">&quot;ES2016&quot;</span><span class="s1">,</span>
        <span class="s3">ES2017 </span><span class="s2">= </span><span class="s4">&quot;ES2017&quot;</span><span class="s1">,</span>
        <span class="s3">ES2018 </span><span class="s2">= </span><span class="s4">&quot;ES2018&quot;</span><span class="s1">,</span>
        <span class="s3">ES2019 </span><span class="s2">= </span><span class="s4">&quot;ES2019&quot;</span><span class="s1">,</span>
        <span class="s3">ES2020 </span><span class="s2">= </span><span class="s4">&quot;ES2020&quot;</span><span class="s1">,</span>
        <span class="s3">ES2021 </span><span class="s2">= </span><span class="s4">&quot;ES2021&quot;</span><span class="s1">,</span>
        <span class="s3">ES2022 </span><span class="s2">= </span><span class="s4">&quot;ES2022&quot;</span><span class="s1">,</span>
        <span class="s3">ESNext </span><span class="s2">= </span><span class="s4">&quot;ESNext&quot;</span>
    <span class="s1">}</span>
    <span class="s2">enum </span><span class="s3">ClassificationType </span><span class="s1">{</span>
        <span class="s3">comment </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">identifier </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">keyword </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">numericLiteral </span><span class="s2">= </span><span class="s6">4</span><span class="s1">,</span>
        <span class="s3">operator </span><span class="s2">= </span><span class="s6">5</span><span class="s1">,</span>
        <span class="s3">stringLiteral </span><span class="s2">= </span><span class="s6">6</span><span class="s1">,</span>
        <span class="s3">regularExpressionLiteral </span><span class="s2">= </span><span class="s6">7</span><span class="s1">,</span>
        <span class="s3">whiteSpace </span><span class="s2">= </span><span class="s6">8</span><span class="s1">,</span>
        <span class="s3">text </span><span class="s2">= </span><span class="s6">9</span><span class="s1">,</span>
        <span class="s3">punctuation </span><span class="s2">= </span><span class="s6">10</span><span class="s1">,</span>
        <span class="s3">className </span><span class="s2">= </span><span class="s6">11</span><span class="s1">,</span>
        <span class="s3">enumName </span><span class="s2">= </span><span class="s6">12</span><span class="s1">,</span>
        <span class="s3">interfaceName </span><span class="s2">= </span><span class="s6">13</span><span class="s1">,</span>
        <span class="s3">moduleName </span><span class="s2">= </span><span class="s6">14</span><span class="s1">,</span>
        <span class="s3">typeParameterName </span><span class="s2">= </span><span class="s6">15</span><span class="s1">,</span>
        <span class="s3">typeAliasName </span><span class="s2">= </span><span class="s6">16</span><span class="s1">,</span>
        <span class="s3">parameterName </span><span class="s2">= </span><span class="s6">17</span><span class="s1">,</span>
        <span class="s3">docCommentTagName </span><span class="s2">= </span><span class="s6">18</span><span class="s1">,</span>
        <span class="s3">jsxOpenTagName </span><span class="s2">= </span><span class="s6">19</span><span class="s1">,</span>
        <span class="s3">jsxCloseTagName </span><span class="s2">= </span><span class="s6">20</span><span class="s1">,</span>
        <span class="s3">jsxSelfClosingTagName </span><span class="s2">= </span><span class="s6">21</span><span class="s1">,</span>
        <span class="s3">jsxAttribute </span><span class="s2">= </span><span class="s6">22</span><span class="s1">,</span>
        <span class="s3">jsxText </span><span class="s2">= </span><span class="s6">23</span><span class="s1">,</span>
        <span class="s3">jsxAttributeStringLiteralValue </span><span class="s2">= </span><span class="s6">24</span><span class="s1">,</span>
        <span class="s3">bigintLiteral </span><span class="s2">= </span><span class="s6">25</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">ScriptInfoVersion </span><span class="s1">{</span>
        <span class="s1">svc</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">isDynamicFileName(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">class </span><span class="s3">ScriptInfo </span><span class="s1">{</span>
        <span class="s2">private readonly </span><span class="s1">host;</span>
        <span class="s2">readonly </span><span class="s1">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">scriptKind</span><span class="s2">: </span><span class="s3">ScriptKind</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">hasMixedContent</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* All projects that include this file 
         */</span>
        <span class="s2">readonly </span><span class="s1">containingProjects</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">[];</span>
        <span class="s2">private </span><span class="s1">formatSettings;</span>
        <span class="s2">private </span><span class="s1">preferences;</span>
        <span class="s2">private </span><span class="s1">textStorage;</span>
        <span class="s2">constructor</span><span class="s1">(</span><span class="s3">host</span><span class="s2">: </span><span class="s3">ServerHost</span><span class="s1">, </span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">hasMixedContent</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">, </span><span class="s3">initialVersion</span><span class="s2">?: </span><span class="s3">ScriptInfoVersion</span><span class="s1">);</span>
        <span class="s1">isScriptOpen()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">open(</span><span class="s3">newText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">close(</span><span class="s3">fileExists</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getSnapshot()</span><span class="s2">: </span><span class="s3">IScriptSnapshot</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">ensureRealPath;</span>
        <span class="s1">getFormatCodeSettings()</span><span class="s2">: </span><span class="s3">FormatCodeSettings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getPreferences()</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">UserPreferences </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">attachToProject(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isAttached(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">detachFromProject(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">detachAllProjects()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getDefaultProject()</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">;</span>
        <span class="s1">registerFileUpdate()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">setOptions(</span><span class="s3">formatSettings</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">, </span><span class="s3">preferences</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">UserPreferences </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getLatestVersion()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">saveTo(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">reloadFromFile(</span><span class="s3">tempFileName</span><span class="s2">?: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">editContent(</span><span class="s3">start</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">end</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">newText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">markContainingProjectsAsDirty()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">isOrphan()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  </span><span class="s2">@param </span><span class="s3">line </span><span class="s0">1 based index 
         */</span>
        <span class="s1">lineToTextSpan(</span><span class="s3">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TextSpan</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@param </span><span class="s3">line </span><span class="s0">1 based index 
         * </span><span class="s2">@param </span><span class="s3">offset </span><span class="s0">1 based index 
         */</span>
        <span class="s1">lineOffsetToPosition(</span><span class="s3">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">offset</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">positionToLineOffset(</span><span class="s3">position</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">Location</span><span class="s1">;</span>
        <span class="s1">isJavaScript()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">InstallPackageOptionsWithProject </span><span class="s2">extends </span><span class="s3">InstallPackageOptions </span><span class="s1">{</span>
        <span class="s1">projectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">projectRootPath</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ITypingsInstaller </span><span class="s1">{</span>
        <span class="s1">isKnownTypesPackageName(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">installPackage(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">InstallPackageOptionsWithProject</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">&gt;;</span>
        <span class="s1">enqueueInstallTypingsRequest(</span><span class="s3">p</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">, </span><span class="s3">typeAcquisition</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">, </span><span class="s3">unresolvedImports</span><span class="s2">: </span><span class="s3">SortedReadonlyArray</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">attach(</span><span class="s3">projectService</span><span class="s2">: </span><span class="s3">ProjectService</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">onProjectClosed(</span><span class="s3">p</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">globalTypingsCacheLocation</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">nullTypingsInstaller</span><span class="s2">: </span><span class="s3">ITypingsInstaller</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">enum </span><span class="s3">ProjectKind </span><span class="s1">{</span>
        <span class="s3">Inferred </span><span class="s2">= </span><span class="s6">0</span><span class="s1">,</span>
        <span class="s3">Configured </span><span class="s2">= </span><span class="s6">1</span><span class="s1">,</span>
        <span class="s3">External </span><span class="s2">= </span><span class="s6">2</span><span class="s1">,</span>
        <span class="s3">AutoImportProvider </span><span class="s2">= </span><span class="s6">3</span><span class="s1">,</span>
        <span class="s3">Auxiliary </span><span class="s2">= </span><span class="s6">4</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">allRootFilesAreJsOrDts(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">allFilesAreJsOrDts(</span><span class="s3">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">PluginCreateInfo </span><span class="s1">{</span>
        <span class="s1">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">;</span>
        <span class="s1">languageService</span><span class="s2">: </span><span class="s3">LanguageService</span><span class="s1">;</span>
        <span class="s1">languageServiceHost</span><span class="s2">: </span><span class="s3">LanguageServiceHost</span><span class="s1">;</span>
        <span class="s1">serverHost</span><span class="s2">: </span><span class="s3">ServerHost</span><span class="s1">;</span>
        <span class="s1">session</span><span class="s2">?: </span><span class="s3">Session</span><span class="s1">&lt;</span><span class="s3">unknown</span><span class="s1">&gt;;</span>
        <span class="s1">config</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PluginModule </span><span class="s1">{</span>
        <span class="s1">create(</span><span class="s3">createInfo</span><span class="s2">: </span><span class="s3">PluginCreateInfo</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LanguageService</span><span class="s1">;</span>
        <span class="s1">getExternalFiles</span><span class="s2">?</span><span class="s1">(</span><span class="s3">proj</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">onConfigurationChanged</span><span class="s2">?</span><span class="s1">(</span><span class="s3">config</span><span class="s2">: </span><span class="s3">any</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PluginModuleWithName </span><span class="s1">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">module</span><span class="s2">: </span><span class="s3">PluginModule</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">PluginModuleFactory </span><span class="s2">= </span><span class="s1">(</span><span class="s3">mod</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">typescript</span><span class="s2">: typeof </span><span class="s3">ts</span><span class="s1">;</span>
    <span class="s1">}) </span><span class="s2">=&gt; </span><span class="s3">PluginModule</span><span class="s1">;</span>
    <span class="s2">abstract class </span><span class="s3">Project </span><span class="s2">implements </span><span class="s3">LanguageServiceHost</span><span class="s1">, </span><span class="s3">ModuleResolutionHost </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">projectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">projectKind</span><span class="s2">: </span><span class="s3">ProjectKind</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">projectService</span><span class="s2">: </span><span class="s3">ProjectService</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">documentRegistry;</span>
        <span class="s2">private </span><span class="s1">compilerOptions;</span>
        <span class="s1">compileOnSaveEnabled</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">watchOptions</span><span class="s2">: </span><span class="s3">WatchOptions </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">rootFiles;</span>
        <span class="s2">private </span><span class="s1">rootFilesMap;</span>
        <span class="s2">private </span><span class="s1">program;</span>
        <span class="s2">private </span><span class="s1">externalFiles;</span>
        <span class="s2">private </span><span class="s1">missingFilesMap;</span>
        <span class="s2">private </span><span class="s1">generatedFilesMap;</span>
        <span class="s2">private </span><span class="s1">plugins;</span>
        <span class="s2">protected </span><span class="s1">languageService</span><span class="s2">: </span><span class="s3">LanguageService</span><span class="s1">;</span>
        <span class="s1">languageServiceEnabled</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">trace</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">realpath</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">builderState;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set of files names that were updated since the last call to getChangesSinceVersion. 
         */</span>
        <span class="s2">private </span><span class="s1">updatedFileNames;</span>
        <span class="s0">/**</span>
         <span class="s0">* Set of files that was returned from the last call to getChangesSinceVersion. 
         */</span>
        <span class="s2">private </span><span class="s1">lastReportedFileNames;</span>
        <span class="s0">/**</span>
         <span class="s0">* Last version that was reported. 
         */</span>
        <span class="s2">private </span><span class="s1">lastReportedVersion;</span>
        <span class="s0">/**</span>
         <span class="s0">* Current project's program version. (incremented everytime new program is created that is not complete reuse from the old one) 
         * This property is changed in 'updateGraph' based on the set of files in program 
         */</span>
        <span class="s2">private </span><span class="s1">projectProgramVersion;</span>
        <span class="s0">/**</span>
         <span class="s0">* Current version of the project state. It is changed when: 
         * - new root file was added/removed 
         * - edit happen in some file that is currently included in the project. 
         * This property is different from projectStructureVersion since in most cases edits don't affect set of files in the project 
         */</span>
        <span class="s2">private </span><span class="s1">projectStateVersion;</span>
        <span class="s2">protected </span><span class="s1">projectErrors</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">isInitialLoadPending</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">private readonly </span><span class="s1">cancellationToken;</span>
        <span class="s1">isNonTsProject()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isJsOnlyProject()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">static </span><span class="s1">resolveModule(</span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">initialDir</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">host</span><span class="s2">: </span><span class="s3">ServerHost</span><span class="s1">, </span><span class="s5">log</span><span class="s2">: </span><span class="s1">(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">, </span><span class="s5">logErrors</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">)</span><span class="s2">: </span><span class="s1">{} </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">isKnownTypesPackageName(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">installPackage(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">InstallPackageOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Promise</span><span class="s1">&lt;</span><span class="s3">ApplyCodeActionCommandResult</span><span class="s1">&gt;;</span>
        <span class="s2">private get </span><span class="s1">typingsCache();</span>
        <span class="s1">getCompilationSettings()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">getCompilerOptions()</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s1">getNewLine()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getProjectVersion()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getProjectReferences()</span><span class="s2">: readonly </span><span class="s3">ProjectReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getScriptFileNames()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s2">private </span><span class="s1">getOrCreateScriptInfoAndAttachToProject;</span>
        <span class="s1">getScriptKind(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptKind</span><span class="s1">;</span>
        <span class="s1">getScriptVersion(</span><span class="s3">filename</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getScriptSnapshot(</span><span class="s3">filename</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IScriptSnapshot </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getCancellationToken()</span><span class="s2">: </span><span class="s3">HostCancellationToken</span><span class="s1">;</span>
        <span class="s1">getCurrentDirectory()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">getDefaultLibFileName()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">useCaseSensitiveFileNames()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">readDirectory(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">extensions</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">exclude</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">include</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">depth</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">readFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">writeFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">content</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">fileExists(</span><span class="s3">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">resolveModuleNames(</span><span class="s3">moduleNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">reusedNames</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">redirectedReference</span><span class="s2">?: </span><span class="s3">ResolvedProjectReference</span><span class="s1">, </span><span class="s3">_options</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">containingSourceFile</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">)</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ResolvedModuleFull </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
        <span class="s1">getModuleResolutionCache()</span><span class="s2">: </span><span class="s3">ModuleResolutionCache </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getResolvedModuleWithFailedLookupLocationsFromCache(</span><span class="s3">moduleName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">resolutionMode</span><span class="s2">?: </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">CommonJS </span><span class="s2">| </span><span class="s3">ModuleKind</span><span class="s1">.</span><span class="s3">ESNext</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ResolvedModuleWithFailedLookupLocations </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">resolveTypeReferenceDirectives(</span><span class="s3">typeDirectiveNames</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">FileReference</span><span class="s1">[], </span><span class="s3">containingFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">redirectedReference</span><span class="s2">?: </span><span class="s3">ResolvedProjectReference</span><span class="s1">, </span><span class="s3">_options</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">containingFileMode</span><span class="s2">?: </span><span class="s3">SourceFile</span><span class="s1">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s1">] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s1">(</span><span class="s3">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)[];</span>
        <span class="s1">directoryExists(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getDirectories(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">log(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">error(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">setInternalCompilerOptionsForEmittingJsFiles;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the errors that dont have any file name associated 
         */</span>
        <span class="s1">getGlobalProjectErrors()</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get all the project errors 
         */</span>
        <span class="s1">getAllProjectErrors()</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">setProjectErrors(</span><span class="s3">projectErrors</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getLanguageService(</span><span class="s3">ensureSynchronized</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">LanguageService</span><span class="s1">;</span>
        <span class="s1">getCompileOnSaveAffectedFileList(</span><span class="s3">scriptInfo</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns true if emit was conducted 
         */</span>
        <span class="s1">emitFile(</span><span class="s3">scriptInfo</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">, </span><span class="s5">writeFile</span><span class="s2">: </span><span class="s1">(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">data</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">writeByteOrderMark</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">)</span><span class="s2">: </span><span class="s3">EmitResult</span><span class="s1">;</span>
        <span class="s1">enableLanguageService()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">disableLanguageService(</span><span class="s3">lastFileExceededProgramSize</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getProjectName()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">removeLocalTypingsFromTypeAcquisition(</span><span class="s3">newTypeAcquisition</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
        <span class="s1">getExternalFiles()</span><span class="s2">: </span><span class="s3">SortedReadonlyArray</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">&gt;;</span>
        <span class="s1">getSourceFile(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SourceFile </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">close()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">detachScriptInfoIfNotRoot;</span>
        <span class="s1">isClosed()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">hasRoots()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getRootFiles()</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">[];</span>
        <span class="s1">getRootScriptInfos()</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">[];</span>
        <span class="s1">getScriptInfos()</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">[];</span>
        <span class="s1">getExcludedFiles()</span><span class="s2">: readonly </span><span class="s3">NormalizedPath</span><span class="s1">[];</span>
        <span class="s1">getFileNames(</span><span class="s3">excludeFilesFromExternalLibraries</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">excludeConfigFiles</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">[];</span>
        <span class="s1">hasConfigFile(</span><span class="s3">configFilePath</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">containsScriptInfo(</span><span class="s3">info</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">containsFile(</span><span class="s3">filename</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">, </span><span class="s3">requireOpen</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">isRoot(</span><span class="s3">info</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">addRoot(</span><span class="s3">info</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">, </span><span class="s3">fileName</span><span class="s2">?: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">addMissingFileRoot(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">removeFile(</span><span class="s3">info</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">, </span><span class="s3">fileExists</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">detachFromProject</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">registerFileUpdate(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">markAsDirty()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Updates set of files that contribute to this project 
         * </span><span class="s2">@returns</span><span class="s0">: true if set of files in the project stays the same and false - otherwise. 
         */</span>
        <span class="s1">updateGraph()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">removeExistingTypings(</span><span class="s3">include</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s2">private </span><span class="s1">updateGraphWorker;</span>
        <span class="s2">private </span><span class="s1">detachScriptInfoFromProject;</span>
        <span class="s2">private </span><span class="s1">addMissingFileWatcher;</span>
        <span class="s2">private </span><span class="s1">isWatchedMissingFile;</span>
        <span class="s2">private </span><span class="s1">createGeneratedFileWatcher;</span>
        <span class="s2">private </span><span class="s1">isValidGeneratedFileWatcher;</span>
        <span class="s2">private </span><span class="s1">clearGeneratedFileWatch;</span>
        <span class="s1">getScriptInfoForNormalizedPath(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getScriptInfo(</span><span class="s3">uncheckedFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">filesToString(</span><span class="s3">writeProjectFileNames</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">setCompilerOptions(</span><span class="s3">compilerOptions</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">setTypeAcquisition(</span><span class="s3">newTypeAcquisition</span><span class="s2">: </span><span class="s3">TypeAcquisition </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getTypeAcquisition()</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">removeRoot(</span><span class="s3">info</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">enableGlobalPlugins(</span><span class="s3">options</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">, </span><span class="s3">pluginConfigOverrides</span><span class="s2">: </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">any</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">enablePlugin(</span><span class="s3">pluginConfigEntry</span><span class="s2">: </span><span class="s3">PluginImport</span><span class="s1">, </span><span class="s3">searchPaths</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[], </span><span class="s3">pluginConfigOverrides</span><span class="s2">: </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">any</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">enableProxy;</span>
        <span class="s0">/** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */</span>
        <span class="s1">refreshDiagnostics()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* If a file is opened and no tsconfig (or jsconfig) is found, 
     * the file and its imports/references are put into an InferredProject. 
     */</span>
    <span class="s2">class </span><span class="s3">InferredProject </span><span class="s2">extends </span><span class="s3">Project </span><span class="s1">{</span>
        <span class="s2">private </span><span class="s1">_isJsInferredProject;</span>
        <span class="s1">toggleJsInferredProject(</span><span class="s3">isJsInferredProject</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">setCompilerOptions(</span><span class="s3">options</span><span class="s2">?: </span><span class="s3">CompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** this is canonical project root path */</span>
        <span class="s2">readonly </span><span class="s1">projectRootPath</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">addRoot(</span><span class="s3">info</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">removeRoot(</span><span class="s3">info</span><span class="s2">: </span><span class="s3">ScriptInfo</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">isProjectWithSingleRoot()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">close()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getTypeAcquisition()</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">class </span><span class="s3">AutoImportProviderProject </span><span class="s2">extends </span><span class="s3">Project </span><span class="s1">{</span>
        <span class="s2">private </span><span class="s1">hostProject;</span>
        <span class="s2">private </span><span class="s1">rootFileNames;</span>
        <span class="s1">isOrphan()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">updateGraph()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">hasRoots()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">markAsDirty()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getScriptFileNames()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">getLanguageService()</span><span class="s2">: </span><span class="s3">never</span><span class="s1">;</span>
        <span class="s1">getModuleResolutionHostForAutoImportProvider()</span><span class="s2">: </span><span class="s3">never</span><span class="s1">;</span>
        <span class="s1">getProjectReferences()</span><span class="s2">: readonly </span><span class="s3">ProjectReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getTypeAcquisition()</span><span class="s2">: </span><span class="s3">TypeAcquisition</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* If a file is opened, the server will look for a tsconfig (or jsconfig) 
     * and if successful create a ConfiguredProject for it. 
     * Otherwise it will create an InferredProject. 
     */</span>
    <span class="s2">class </span><span class="s3">ConfiguredProject </span><span class="s2">extends </span><span class="s3">Project </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">canonicalConfigFilePath</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">;</span>
        <span class="s0">/** Ref count to the project when opened from external project */</span>
        <span class="s2">private </span><span class="s1">externalProjectRefCount;</span>
        <span class="s2">private </span><span class="s1">projectReferences;</span>
        <span class="s0">/**</span>
         <span class="s0">* If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph 
         * </span><span class="s2">@returns</span><span class="s0">: true if set of files in the project stays the same and false - otherwise. 
         */</span>
        <span class="s1">updateGraph()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getConfigFilePath()</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">;</span>
        <span class="s1">getProjectReferences()</span><span class="s2">: readonly </span><span class="s3">ProjectReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">updateReferences(</span><span class="s3">refs</span><span class="s2">: readonly </span><span class="s3">ProjectReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Get the errors that dont have any file name associated 
         */</span>
        <span class="s1">getGlobalProjectErrors()</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Get all the project errors 
         */</span>
        <span class="s1">getAllProjectErrors()</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">setProjectErrors(</span><span class="s3">projectErrors</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">close()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">getEffectiveTypeRoots()</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Project whose configuration is handled externally, such as in a '.csproj'. 
     * These are created only if a host explicitly calls `openExternalProject`. 
     */</span>
    <span class="s2">class </span><span class="s3">ExternalProject </span><span class="s2">extends </span><span class="s3">Project </span><span class="s1">{</span>
        <span class="s1">externalProjectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">compileOnSaveEnabled</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">excludedFiles</span><span class="s2">: readonly </span><span class="s3">NormalizedPath</span><span class="s1">[];</span>
        <span class="s1">updateGraph()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">getExcludedFiles()</span><span class="s2">: readonly </span><span class="s3">NormalizedPath</span><span class="s1">[];</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">export const </span><span class="s1">maxProgramSizeForNonTsFiles</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s2">export const </span><span class="s1">ProjectsUpdatedInBackgroundEvent </span><span class="s2">= </span><span class="s4">&quot;projectsUpdatedInBackground&quot;</span><span class="s1">;</span>
    <span class="s2">export const </span><span class="s1">ProjectLoadingStartEvent </span><span class="s2">= </span><span class="s4">&quot;projectLoadingStart&quot;</span><span class="s1">;</span>
    <span class="s2">export const </span><span class="s1">ProjectLoadingFinishEvent </span><span class="s2">= </span><span class="s4">&quot;projectLoadingFinish&quot;</span><span class="s1">;</span>
    <span class="s2">export const </span><span class="s1">LargeFileReferencedEvent </span><span class="s2">= </span><span class="s4">&quot;largeFileReferenced&quot;</span><span class="s1">;</span>
    <span class="s2">export const </span><span class="s1">ConfigFileDiagEvent </span><span class="s2">= </span><span class="s4">&quot;configFileDiag&quot;</span><span class="s1">;</span>
    <span class="s2">export const </span><span class="s1">ProjectLanguageServiceStateEvent </span><span class="s2">= </span><span class="s4">&quot;projectLanguageServiceState&quot;</span><span class="s1">;</span>
    <span class="s2">export const </span><span class="s1">ProjectInfoTelemetryEvent </span><span class="s2">= </span><span class="s4">&quot;projectInfo&quot;</span><span class="s1">;</span>
    <span class="s2">export const </span><span class="s1">OpenFileInfoTelemetryEvent </span><span class="s2">= </span><span class="s4">&quot;openFileInfo&quot;</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">ProjectsUpdatedInBackgroundEvent </span><span class="s1">{</span>
        <span class="s1">eventName</span><span class="s2">: typeof </span><span class="s3">ProjectsUpdatedInBackgroundEvent</span><span class="s1">;</span>
        <span class="s1">data</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">openFiles</span><span class="s2">: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ProjectLoadingStartEvent </span><span class="s1">{</span>
        <span class="s1">eventName</span><span class="s2">: typeof </span><span class="s3">ProjectLoadingStartEvent</span><span class="s1">;</span>
        <span class="s1">data</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">;</span>
            <span class="s1">reason</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ProjectLoadingFinishEvent </span><span class="s1">{</span>
        <span class="s1">eventName</span><span class="s2">: typeof </span><span class="s3">ProjectLoadingFinishEvent</span><span class="s1">;</span>
        <span class="s1">data</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">LargeFileReferencedEvent </span><span class="s1">{</span>
        <span class="s1">eventName</span><span class="s2">: typeof </span><span class="s3">LargeFileReferencedEvent</span><span class="s1">;</span>
        <span class="s1">data</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">file</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
            <span class="s1">fileSize</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
            <span class="s1">maxFileSize</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ConfigFileDiagEvent </span><span class="s1">{</span>
        <span class="s1">eventName</span><span class="s2">: typeof </span><span class="s3">ConfigFileDiagEvent</span><span class="s1">;</span>
        <span class="s1">data</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">triggerFile</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
            <span class="s1">configFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
            <span class="s1">diagnostics</span><span class="s2">: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ProjectLanguageServiceStateEvent </span><span class="s1">{</span>
        <span class="s1">eventName</span><span class="s2">: typeof </span><span class="s3">ProjectLanguageServiceStateEvent</span><span class="s1">;</span>
        <span class="s1">data</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">;</span>
            <span class="s1">languageServiceEnabled</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">/** This will be converted to the payload of a protocol.TelemetryEvent in session.defaultEventHandler. */</span>
    <span class="s2">export interface </span><span class="s3">ProjectInfoTelemetryEvent </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">eventName</span><span class="s2">: typeof </span><span class="s3">ProjectInfoTelemetryEvent</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">data</span><span class="s2">: </span><span class="s3">ProjectInfoTelemetryEventData</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ProjectInfoTelemetryEventData </span><span class="s1">{</span>
        <span class="s0">/** Cryptographically secure hash of project file location. */</span>
        <span class="s2">readonly </span><span class="s1">projectId</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** Count of file extensions seen in the project. */</span>
        <span class="s2">readonly </span><span class="s1">fileStats</span><span class="s2">: </span><span class="s3">FileStats</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Any compiler options that might contain paths will be taken out. 
         * Enum compiler options will be converted to strings. 
         */</span>
        <span class="s2">readonly </span><span class="s1">compilerOptions</span><span class="s2">: </span><span class="s3">CompilerOptions</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">extends</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">files</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">include</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">exclude</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">compileOnSave</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typeAcquisition</span><span class="s2">: </span><span class="s3">ProjectInfoTypeAcquisitionData</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">configFileName</span><span class="s2">: </span><span class="s4">&quot;tsconfig.json&quot; </span><span class="s2">| </span><span class="s4">&quot;jsconfig.json&quot; </span><span class="s2">| </span><span class="s4">&quot;other&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">projectType</span><span class="s2">: </span><span class="s4">&quot;external&quot; </span><span class="s2">| </span><span class="s4">&quot;configured&quot;</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">languageServiceEnabled</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** TypeScript version used by the server. */</span>
        <span class="s2">readonly </span><span class="s1">version</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Info that we may send about a file that was just opened. 
     * Info about a file will only be sent once per session, even if the file changes in ways that might affect the info. 
     * Currently this is only sent for '.js' files. 
     */</span>
    <span class="s2">export interface </span><span class="s3">OpenFileInfoTelemetryEvent </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">eventName</span><span class="s2">: typeof </span><span class="s3">OpenFileInfoTelemetryEvent</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">data</span><span class="s2">: </span><span class="s3">OpenFileInfoTelemetryEventData</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">OpenFileInfoTelemetryEventData </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">info</span><span class="s2">: </span><span class="s3">OpenFileInfo</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ProjectInfoTypeAcquisitionData </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">enable</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">include</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">exclude</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">FileStats </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">js</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">jsSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">jsx</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">jsxSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">ts</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tsSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tsx</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">tsxSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">dts</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">dtsSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">deferred</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">deferredSize</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">OpenFileInfo </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">checkJs</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export type </span><span class="s3">ProjectServiceEvent </span><span class="s2">= </span><span class="s3">LargeFileReferencedEvent </span><span class="s2">| </span><span class="s3">ProjectsUpdatedInBackgroundEvent </span><span class="s2">| </span><span class="s3">ProjectLoadingStartEvent </span><span class="s2">| </span><span class="s3">ProjectLoadingFinishEvent </span><span class="s2">| </span><span class="s3">ConfigFileDiagEvent </span><span class="s2">| </span><span class="s3">ProjectLanguageServiceStateEvent </span><span class="s2">| </span><span class="s3">ProjectInfoTelemetryEvent </span><span class="s2">| </span><span class="s3">OpenFileInfoTelemetryEvent</span><span class="s1">;</span>
    <span class="s2">export type </span><span class="s3">ProjectServiceEventHandler </span><span class="s2">= </span><span class="s1">(</span><span class="s3">event</span><span class="s2">: </span><span class="s3">ProjectServiceEvent</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">SafeList </span><span class="s1">{</span>
        <span class="s1">[</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">match</span><span class="s2">: </span><span class="s3">RegExp</span><span class="s1">;</span>
            <span class="s1">exclude</span><span class="s2">?: </span><span class="s1">(</span><span class="s3">string </span><span class="s2">| </span><span class="s3">number</span><span class="s1">)[][];</span>
            <span class="s1">types</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">TypesMapFile </span><span class="s1">{</span>
        <span class="s1">typesMap</span><span class="s2">: </span><span class="s3">SafeList</span><span class="s1">;</span>
        <span class="s1">simpleMap</span><span class="s2">: </span><span class="s1">{</span>
            <span class="s1">[</span><span class="s3">libName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">]</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">export function </span><span class="s1">convertFormatOptions(</span><span class="s3">protocolOptions</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">FormatCodeSettings</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">convertCompilerOptions(</span><span class="s3">protocolOptions</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ExternalProjectCompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CompilerOptions </span><span class="s2">&amp; </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">CompileOnSaveMixin</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">convertWatchOptions(</span><span class="s3">protocolOptions</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ExternalProjectCompilerOptions</span><span class="s1">, </span><span class="s3">currentDirectory</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">WatchOptionsAndErrors </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">convertTypeAcquisition(</span><span class="s3">protocolOptions</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">InferredProjectCompilerOptions</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAcquisition </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">tryConvertScriptKindName(</span><span class="s3">scriptKindName</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ScriptKindName </span><span class="s2">| </span><span class="s3">ScriptKind</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptKind</span><span class="s1">;</span>
    <span class="s2">export function </span><span class="s1">convertScriptKindName(</span><span class="s3">scriptKindName</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ScriptKindName</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptKind</span><span class="s1">.</span><span class="s3">Unknown </span><span class="s2">| </span><span class="s3">ScriptKind</span><span class="s1">.</span><span class="s3">JS </span><span class="s2">| </span><span class="s3">ScriptKind</span><span class="s1">.</span><span class="s3">JSX </span><span class="s2">| </span><span class="s3">ScriptKind</span><span class="s1">.</span><span class="s3">TS </span><span class="s2">| </span><span class="s3">ScriptKind</span><span class="s1">.</span><span class="s3">TSX</span><span class="s1">;</span>
    <span class="s2">export interface </span><span class="s3">HostConfiguration </span><span class="s1">{</span>
        <span class="s1">formatCodeOptions</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">;</span>
        <span class="s1">preferences</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">UserPreferences</span><span class="s1">;</span>
        <span class="s1">hostInfo</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">extraFileExtensions</span><span class="s2">?: </span><span class="s3">FileExtensionInfo</span><span class="s1">[];</span>
        <span class="s1">watchOptions</span><span class="s2">?: </span><span class="s3">WatchOptions</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">OpenConfiguredProjectResult </span><span class="s1">{</span>
        <span class="s1">configFileName</span><span class="s2">?: </span><span class="s3">NormalizedPath</span><span class="s1">;</span>
        <span class="s1">configFileErrors</span><span class="s2">?: readonly </span><span class="s3">Diagnostic</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">ProjectServiceOptions </span><span class="s1">{</span>
        <span class="s1">host</span><span class="s2">: </span><span class="s3">ServerHost</span><span class="s1">;</span>
        <span class="s1">logger</span><span class="s2">: </span><span class="s3">Logger</span><span class="s1">;</span>
        <span class="s1">cancellationToken</span><span class="s2">: </span><span class="s3">HostCancellationToken</span><span class="s1">;</span>
        <span class="s1">useSingleInferredProject</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">useInferredProjectPerProjectRoot</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">typingsInstaller</span><span class="s2">: </span><span class="s3">ITypingsInstaller</span><span class="s1">;</span>
        <span class="s1">eventHandler</span><span class="s2">?: </span><span class="s3">ProjectServiceEventHandler</span><span class="s1">;</span>
        <span class="s1">suppressDiagnosticEvents</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">throttleWaitMilliseconds</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">globalPlugins</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">pluginProbeLocations</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">allowLocalPluginLoads</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">typesMapLocation</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">use serverMode instead */</span>
        <span class="s1">syntaxOnly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">serverMode</span><span class="s2">?: </span><span class="s3">LanguageServiceMode</span><span class="s1">;</span>
        <span class="s1">session</span><span class="s2">: </span><span class="s3">Session</span><span class="s1">&lt;</span><span class="s3">unknown</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export interface </span><span class="s3">WatchOptionsAndErrors </span><span class="s1">{</span>
        <span class="s1">watchOptions</span><span class="s2">: </span><span class="s3">WatchOptions</span><span class="s1">;</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s3">Diagnostic</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export class </span><span class="s3">ProjectService </span><span class="s1">{</span>
        <span class="s2">private readonly </span><span class="s1">nodeModulesWatchers;</span>
        <span class="s0">/**</span>
         <span class="s0">* Contains all the deleted script info's version information so that 
         * it does not reset when creating script info again 
         * (and could have potentially collided with version where contents mismatch) 
         */</span>
        <span class="s2">private readonly </span><span class="s1">filenameToScriptInfoVersion;</span>
        <span class="s2">private readonly </span><span class="s1">allJsFilesForOpenFileTelemetry;</span>
        <span class="s0">/**</span>
         <span class="s0">* maps external project file name to list of config files that were the part of this project 
         */</span>
        <span class="s2">private readonly </span><span class="s1">externalProjectToConfiguredProjectMap;</span>
        <span class="s0">/**</span>
         <span class="s0">* external projects (configuration and list of root files is not controlled by tsserver) 
         */</span>
        <span class="s2">readonly </span><span class="s1">externalProjects</span><span class="s2">: </span><span class="s3">ExternalProject</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* projects built from openFileRoots 
         */</span>
        <span class="s2">readonly </span><span class="s1">inferredProjects</span><span class="s2">: </span><span class="s3">InferredProject</span><span class="s1">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* projects specified by a tsconfig.json file 
         */</span>
        <span class="s2">readonly </span><span class="s1">configuredProjects</span><span class="s2">: </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">ConfiguredProject</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Open files: with value being project root path, and key being Path of the file that is open 
         */</span>
        <span class="s2">readonly </span><span class="s1">openFiles</span><span class="s2">: </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">NormalizedPath </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Map of open files that are opened without complete path but have projectRoot as current directory 
         */</span>
        <span class="s2">private readonly </span><span class="s1">openFilesWithNonRootedDiskPath;</span>
        <span class="s2">private </span><span class="s1">compilerOptionsForInferredProjects;</span>
        <span class="s2">private </span><span class="s1">compilerOptionsForInferredProjectsPerProjectRoot;</span>
        <span class="s2">private </span><span class="s1">watchOptionsForInferredProjects;</span>
        <span class="s2">private </span><span class="s1">watchOptionsForInferredProjectsPerProjectRoot;</span>
        <span class="s2">private </span><span class="s1">typeAcquisitionForInferredProjects;</span>
        <span class="s2">private </span><span class="s1">typeAcquisitionForInferredProjectsPerProjectRoot;</span>
        <span class="s0">/**</span>
         <span class="s0">* Project size for configured or external projects 
         */</span>
        <span class="s2">private readonly </span><span class="s1">projectToSizeMap;</span>
        <span class="s2">private readonly </span><span class="s1">hostConfiguration;</span>
        <span class="s2">private </span><span class="s1">safelist;</span>
        <span class="s2">private readonly </span><span class="s1">legacySafelist;</span>
        <span class="s2">private </span><span class="s1">pendingProjectUpdates;</span>
        <span class="s2">readonly </span><span class="s1">currentDirectory</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">toCanonicalFileName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">f</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">host</span><span class="s2">: </span><span class="s3">ServerHost</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">logger</span><span class="s2">: </span><span class="s3">Logger</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">cancellationToken</span><span class="s2">: </span><span class="s3">HostCancellationToken</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">useSingleInferredProject</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">useInferredProjectPerProjectRoot</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">typingsInstaller</span><span class="s2">: </span><span class="s3">ITypingsInstaller</span><span class="s1">;</span>
        <span class="s2">private readonly </span><span class="s1">globalCacheLocationDirectoryPath;</span>
        <span class="s2">readonly </span><span class="s1">throttleWaitMilliseconds</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">private readonly </span><span class="s1">eventHandler</span><span class="s2">?</span><span class="s1">;</span>
        <span class="s2">private readonly </span><span class="s1">suppressDiagnosticEvents</span><span class="s2">?</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">globalPlugins</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s2">readonly </span><span class="s1">pluginProbeLocations</span><span class="s2">: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s2">readonly </span><span class="s1">allowLocalPluginLoads</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">currentPluginConfigOverrides;</span>
        <span class="s2">readonly </span><span class="s1">typesMapLocation</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">use serverMode instead */</span>
        <span class="s2">readonly </span><span class="s1">syntaxOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">readonly </span><span class="s1">serverMode</span><span class="s2">: </span><span class="s3">LanguageServiceMode</span><span class="s1">;</span>
        <span class="s0">/** Tracks projects that we have already sent telemetry for. */</span>
        <span class="s2">private readonly </span><span class="s1">seenProjects;</span>
        <span class="s2">private </span><span class="s1">performanceEventHandler</span><span class="s2">?</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">pendingPluginEnablements</span><span class="s2">?</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">currentPluginEnablementPromise</span><span class="s2">?</span><span class="s1">;</span>
        <span class="s2">constructor</span><span class="s1">(</span><span class="s3">opts</span><span class="s2">: </span><span class="s3">ProjectServiceOptions</span><span class="s1">);</span>
        <span class="s1">toPath(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">loadTypesMap;</span>
        <span class="s1">updateTypingsForProject(</span><span class="s3">response</span><span class="s2">: </span><span class="s3">SetTypings </span><span class="s2">| </span><span class="s3">InvalidateCachedTypings </span><span class="s2">| </span><span class="s3">PackageInstalledResponse</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">delayUpdateProjectGraph;</span>
        <span class="s2">private </span><span class="s1">delayUpdateProjectGraphs;</span>
        <span class="s1">setCompilerOptionsForInferredProjects(</span><span class="s3">projectCompilerOptions</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">InferredProjectCompilerOptions</span><span class="s1">, </span><span class="s3">projectRootPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">findProject(</span><span class="s3">projectName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Project </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getDefaultProjectForFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">, </span><span class="s3">ensureProject</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">Project </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">doEnsureDefaultProjectForFile;</span>
        <span class="s1">getScriptInfoEnsuringProjectsUptoDate(</span><span class="s3">uncheckedFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Ensures the project structures are upto date 
         * This means, 
         * - we go through all the projects and update them if they are dirty 
         * - if updates reflect some change in structure or there was pending request to ensure projects for open files 
         *   ensure that each open script info has project 
         */</span>
        <span class="s2">private </span><span class="s1">ensureProjectStructuresUptoDate;</span>
        <span class="s1">getFormatCodeOptions(</span><span class="s3">file</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">;</span>
        <span class="s1">getPreferences(</span><span class="s3">file</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">UserPreferences</span><span class="s1">;</span>
        <span class="s1">getHostFormatCodeOptions()</span><span class="s2">: </span><span class="s3">FormatCodeSettings</span><span class="s1">;</span>
        <span class="s1">getHostPreferences()</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">UserPreferences</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">onSourceFileChanged;</span>
        <span class="s2">private </span><span class="s1">handleSourceMapProjects;</span>
        <span class="s2">private </span><span class="s1">delayUpdateSourceInfoProjects;</span>
        <span class="s2">private </span><span class="s1">delayUpdateProjectsOfScriptInfoPath;</span>
        <span class="s2">private </span><span class="s1">handleDeletedFile;</span>
        <span class="s2">private </span><span class="s1">removeProject;</span>
        <span class="s2">private </span><span class="s1">assignOrphanScriptInfosToInferredProject;</span>
        <span class="s0">/**</span>
         <span class="s0">* Remove this file from the set of open, non-configured files. 
         * </span><span class="s2">@param </span><span class="s3">info </span><span class="s0">The file that has been closed or newly configured 
         */</span>
        <span class="s2">private </span><span class="s1">closeOpenFile;</span>
        <span class="s2">private </span><span class="s1">deleteScriptInfo;</span>
        <span class="s2">private </span><span class="s1">configFileExists;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns true if the configFileExistenceInfo is needed/impacted by open files that are root of inferred project 
         */</span>
        <span class="s2">private </span><span class="s1">configFileExistenceImpactsRootOfInferredProject;</span>
        <span class="s0">/**</span>
         <span class="s0">* This is called on file close, so that we stop watching the config file for this script info 
         */</span>
        <span class="s2">private </span><span class="s1">stopWatchingConfigFilesForClosedScriptInfo;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function tries to search for a tsconfig.json for the given file. 
         * This is different from the method the compiler uses because 
         * the compiler can assume it will always start searching in the 
         * current directory (the directory in which tsc was invoked). 
         * The server must start searching from the directory containing 
         * the newly opened file. 
         */</span>
        <span class="s2">private </span><span class="s1">forEachConfigFileLocation;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function tries to search for a tsconfig.json for the given file. 
         * This is different from the method the compiler uses because 
         * the compiler can assume it will always start searching in the 
         * current directory (the directory in which tsc was invoked). 
         * The server must start searching from the directory containing 
         * the newly opened file. 
         * If script info is passed in, it is asserted to be open script info 
         * otherwise just file name 
         */</span>
        <span class="s2">private </span><span class="s1">getConfigFileNameForFile;</span>
        <span class="s2">private </span><span class="s1">printProjects;</span>
        <span class="s2">private </span><span class="s1">getConfiguredProjectByCanonicalConfigFilePath;</span>
        <span class="s2">private </span><span class="s1">findExternalProjectByProjectName;</span>
        <span class="s0">/** Get a filename if the language service exceeds the maximum allowed program size; otherwise returns undefined. */</span>
        <span class="s2">private </span><span class="s1">getFilenameForExceededTotalSizeLimitForNonTsFiles;</span>
        <span class="s2">private </span><span class="s1">createExternalProject;</span>
        <span class="s2">private </span><span class="s1">addFilesToNonInferredProject;</span>
        <span class="s2">private </span><span class="s1">updateNonInferredProjectFiles;</span>
        <span class="s2">private </span><span class="s1">updateRootAndOptionsOfNonInferredProject;</span>
        <span class="s2">private </span><span class="s1">sendConfigFileDiagEvent;</span>
        <span class="s2">private </span><span class="s1">getOrCreateInferredProjectForProjectRootPathIfEnabled;</span>
        <span class="s2">private </span><span class="s1">getOrCreateSingleInferredProjectIfEnabled;</span>
        <span class="s2">private </span><span class="s1">getOrCreateSingleInferredWithoutProjectRoot;</span>
        <span class="s2">private </span><span class="s1">createInferredProject;</span>
        <span class="s1">getScriptInfo(</span><span class="s3">uncheckedFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">watchClosedScriptInfo;</span>
        <span class="s2">private </span><span class="s1">createNodeModulesWatcher;</span>
        <span class="s2">private </span><span class="s1">watchClosedScriptInfoInNodeModules;</span>
        <span class="s2">private </span><span class="s1">getModifiedTime;</span>
        <span class="s2">private </span><span class="s1">refreshScriptInfo;</span>
        <span class="s2">private </span><span class="s1">refreshScriptInfosInDirectory;</span>
        <span class="s2">private </span><span class="s1">stopWatchingScriptInfo;</span>
        <span class="s2">private </span><span class="s1">getOrCreateScriptInfoNotOpenedByClientForNormalizedPath;</span>
        <span class="s2">private </span><span class="s1">getOrCreateScriptInfoOpenedByClientForNormalizedPath;</span>
        <span class="s1">getOrCreateScriptInfoForNormalizedPath(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">, </span><span class="s3">openedByClient</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">fileContent</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">hasMixedContent</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">hostToQueryFileExistsOn</span><span class="s2">?: </span><span class="s1">{</span>
            <span class="s1">fileExists(</span><span class="s3">path</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">})</span><span class="s2">: </span><span class="s3">ScriptInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">getOrCreateScriptInfoWorker;</span>
        <span class="s0">/**</span>
         <span class="s0">* This gets the script info for the normalized path. If the path is not rooted disk path then the open script info with project root context is preferred 
         */</span>
        <span class="s1">getScriptInfoForNormalizedPath(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s1">getScriptInfoForPath(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">Path</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ScriptInfo </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">addSourceInfoToSourceMap;</span>
        <span class="s2">private </span><span class="s1">addMissingSourceMapFile;</span>
        <span class="s1">setHostConfiguration(</span><span class="s3">args</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ConfigureRequestArguments</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">closeLog()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function rebuilds the project for every file opened by the client 
         * This does not reload contents of open files from disk. But we could do that if needed 
         */</span>
        <span class="s1">reloadProjects()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function goes through all the openFiles and tries to file the config file for them. 
         * If the config file is found and it refers to existing project, it reloads it either immediately 
         * or schedules it for reload depending on delayReload option 
         * If there is no existing project it just opens the configured project for the config file 
         * reloadForInfo provides a way to filter out files to reload configured project for 
         */</span>
        <span class="s2">private </span><span class="s1">reloadConfiguredProjectForFiles;</span>
        <span class="s0">/**</span>
         <span class="s0">* Remove the root of inferred project if script info is part of another project 
         */</span>
        <span class="s2">private </span><span class="s1">removeRootOfInferredProjectIfNowPartOfOtherProject;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is to update the project structure for every inferred project. 
         * It is called on the premise that all the configured projects are 
         * up to date. 
         * This will go through open files and assign them to inferred project if open file is not part of any other project 
         * After that all the inferred project graphs are updated 
         */</span>
        <span class="s2">private </span><span class="s1">ensureProjectForOpenFiles;</span>
        <span class="s0">/**</span>
         <span class="s0">* Open file whose contents is managed by the client 
         * </span><span class="s2">@param </span><span class="s3">filename </span><span class="s0">is absolute pathname 
         * </span><span class="s2">@param </span><span class="s3">fileContent </span><span class="s0">is a known version of the file content that is more up to date than the one on disk 
         */</span>
        <span class="s1">openClientFile(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">fileContent</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">projectRootPath</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">OpenConfiguredProjectResult</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">findExternalProjectContainingOpenScriptInfo;</span>
        <span class="s2">private </span><span class="s1">getOrCreateOpenScriptInfo;</span>
        <span class="s2">private </span><span class="s1">assignProjectToOpenedScriptInfo;</span>
        <span class="s2">private </span><span class="s1">createAncestorProjects;</span>
        <span class="s2">private </span><span class="s1">ensureProjectChildren;</span>
        <span class="s2">private </span><span class="s1">cleanupAfterOpeningFile;</span>
        <span class="s1">openClientFileWithNormalizedPath(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">, </span><span class="s3">fileContent</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">scriptKind</span><span class="s2">?: </span><span class="s3">ScriptKind</span><span class="s1">, </span><span class="s3">hasMixedContent</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">projectRootPath</span><span class="s2">?: </span><span class="s3">NormalizedPath</span><span class="s1">)</span><span class="s2">: </span><span class="s3">OpenConfiguredProjectResult</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">removeOrphanConfiguredProjects;</span>
        <span class="s2">private </span><span class="s1">removeOrphanScriptInfos;</span>
        <span class="s2">private </span><span class="s1">telemetryOnOpenFile;</span>
        <span class="s0">/**</span>
         <span class="s0">* Close file whose contents is managed by the client 
         * </span><span class="s2">@param </span><span class="s3">filename </span><span class="s0">is absolute pathname 
         */</span>
        <span class="s1">closeClientFile(</span><span class="s3">uncheckedFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">collectChanges;</span>
        <span class="s2">private </span><span class="s1">closeConfiguredProjectReferencedFromExternalProject;</span>
        <span class="s1">closeExternalProject(</span><span class="s3">uncheckedFileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">openExternalProjects(</span><span class="s3">projects</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ExternalProject</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** Makes a filename safe to insert in a RegExp */</span>
        <span class="s2">private static readonly </span><span class="s1">filenameEscapeRegexp;</span>
        <span class="s2">private static </span><span class="s1">escapeFilenameForRegex;</span>
        <span class="s1">resetSafeList()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">applySafeList(</span><span class="s3">proj</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ExternalProject</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">[];</span>
        <span class="s1">openExternalProject(</span><span class="s3">proj</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ExternalProject</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">hasDeferredExtension()</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">enableRequestedPluginsAsync;</span>
        <span class="s2">private </span><span class="s1">enableRequestedPluginsWorker;</span>
        <span class="s2">private </span><span class="s1">enableRequestedPluginsForProjectAsync;</span>
        <span class="s1">configurePlugin(</span><span class="s3">args</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">ConfigurePluginRequestArguments</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">export </span><span class="s1">{};</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts</span><span class="s1">.</span><span class="s3">server </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">ServerCancellationToken </span><span class="s2">extends </span><span class="s3">HostCancellationToken </span><span class="s1">{</span>
        <span class="s1">setRequest(</span><span class="s3">requestId</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">resetRequest(</span><span class="s3">requestId</span><span class="s2">: </span><span class="s3">number</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">nullCancellationToken</span><span class="s2">: </span><span class="s3">ServerCancellationToken</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">PendingErrorCheck </span><span class="s1">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s3">NormalizedPath</span><span class="s1">;</span>
        <span class="s1">project</span><span class="s2">: </span><span class="s3">Project</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s3">CommandNames </span><span class="s2">= </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">CommandTypes</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">CommandNames</span><span class="s2">: </span><span class="s3">any</span><span class="s1">;</span>
    <span class="s2">function </span><span class="s1">formatMessage&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">Message</span><span class="s1">&gt;(</span><span class="s3">msg</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">logger</span><span class="s2">: </span><span class="s3">Logger</span><span class="s1">, </span><span class="s5">byteLength</span><span class="s2">: </span><span class="s1">(</span><span class="s3">s</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">encoding</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">number</span><span class="s1">, </span><span class="s3">newLine</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s2">type </span><span class="s3">Event </span><span class="s2">= </span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">object</span><span class="s1">&gt;(</span><span class="s3">body</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">eventName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">;</span>
    <span class="s2">interface </span><span class="s3">EventSender </span><span class="s1">{</span>
        <span class="s1">event</span><span class="s2">: </span><span class="s3">Event</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">SessionOptions </span><span class="s1">{</span>
        <span class="s1">host</span><span class="s2">: </span><span class="s3">ServerHost</span><span class="s1">;</span>
        <span class="s1">cancellationToken</span><span class="s2">: </span><span class="s3">ServerCancellationToken</span><span class="s1">;</span>
        <span class="s1">useSingleInferredProject</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">useInferredProjectPerProjectRoot</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">typingsInstaller</span><span class="s2">: </span><span class="s3">ITypingsInstaller</span><span class="s1">;</span>
        <span class="s1">byteLength</span><span class="s2">: </span><span class="s1">(</span><span class="s3">buf</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">encoding</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">hrtime</span><span class="s2">: </span><span class="s1">(</span><span class="s3">start</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">number</span><span class="s1">[];</span>
        <span class="s1">logger</span><span class="s2">: </span><span class="s3">Logger</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If falsy, all events are suppressed. 
         */</span>
        <span class="s1">canUseEvents</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">eventHandler</span><span class="s2">?: </span><span class="s3">ProjectServiceEventHandler</span><span class="s1">;</span>
        <span class="s0">/** Has no effect if eventHandler is also specified. */</span>
        <span class="s1">suppressDiagnosticEvents</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">use serverMode instead */</span>
        <span class="s1">syntaxOnly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">serverMode</span><span class="s2">?: </span><span class="s3">LanguageServiceMode</span><span class="s1">;</span>
        <span class="s1">throttleWaitMilliseconds</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s1">noGetErrOnBackgroundUpdate</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">globalPlugins</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">pluginProbeLocations</span><span class="s2">?: readonly </span><span class="s3">string</span><span class="s1">[];</span>
        <span class="s1">allowLocalPluginLoads</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s1">typesMapLocation</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">class </span><span class="s3">Session</span><span class="s1">&lt;</span><span class="s3">TMessage </span><span class="s2">= </span><span class="s3">string</span><span class="s1">&gt; </span><span class="s2">implements </span><span class="s3">EventSender </span><span class="s1">{</span>
        <span class="s2">private readonly </span><span class="s1">gcTimer;</span>
        <span class="s2">protected </span><span class="s1">projectService</span><span class="s2">: </span><span class="s3">ProjectService</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">changeSeq;</span>
        <span class="s2">private </span><span class="s1">performanceData;</span>
        <span class="s2">private </span><span class="s1">currentRequestId;</span>
        <span class="s2">private </span><span class="s1">errorCheck;</span>
        <span class="s2">protected </span><span class="s1">host</span><span class="s2">: </span><span class="s3">ServerHost</span><span class="s1">;</span>
        <span class="s2">private readonly </span><span class="s1">cancellationToken;</span>
        <span class="s2">protected readonly </span><span class="s1">typingsInstaller</span><span class="s2">: </span><span class="s3">ITypingsInstaller</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">byteLength</span><span class="s2">: </span><span class="s1">(</span><span class="s3">buf</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">encoding</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">number</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">hrtime;</span>
        <span class="s2">protected </span><span class="s1">logger</span><span class="s2">: </span><span class="s3">Logger</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">canUseEvents</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">suppressDiagnosticEvents</span><span class="s2">?</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">eventHandler;</span>
        <span class="s2">private readonly </span><span class="s1">noGetErrOnBackgroundUpdate</span><span class="s2">?</span><span class="s1">;</span>
        <span class="s2">constructor</span><span class="s1">(</span><span class="s3">opts</span><span class="s2">: </span><span class="s3">SessionOptions</span><span class="s1">);</span>
        <span class="s2">private </span><span class="s1">sendRequestCompletedEvent;</span>
        <span class="s2">private </span><span class="s1">addPerformanceData;</span>
        <span class="s2">private </span><span class="s1">performanceEventHandler;</span>
        <span class="s2">private </span><span class="s1">defaultEventHandler;</span>
        <span class="s2">private </span><span class="s1">projectsUpdatedInBackgroundEvent;</span>
        <span class="s1">logError(</span><span class="s3">err</span><span class="s2">: </span><span class="s3">Error</span><span class="s1">, </span><span class="s3">cmd</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">logErrorWorker;</span>
        <span class="s1">send(</span><span class="s3">msg</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">Message</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">writeMessage(</span><span class="s3">msg</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">Message</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s1">event&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">object</span><span class="s1">&gt;(</span><span class="s3">body</span><span class="s2">: </span><span class="s3">T</span><span class="s1">, </span><span class="s3">eventName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">*/</span>
        <span class="s1">output(</span><span class="s3">info</span><span class="s2">: </span><span class="s3">any</span><span class="s1">, </span><span class="s3">cmdName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">reqSeq</span><span class="s2">?: </span><span class="s3">number</span><span class="s1">, </span><span class="s3">errorMsg</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">doOutput;</span>
        <span class="s2">private </span><span class="s1">semanticCheck;</span>
        <span class="s2">private </span><span class="s1">syntacticCheck;</span>
        <span class="s2">private </span><span class="s1">suggestionCheck;</span>
        <span class="s2">private </span><span class="s1">sendDiagnosticsEvent;</span>
        <span class="s0">/** It is the caller's responsibility to verify that `!this.suppressDiagnosticEvents`. */</span>
        <span class="s2">private </span><span class="s1">updateErrorCheck;</span>
        <span class="s2">private </span><span class="s1">cleanProjects;</span>
        <span class="s2">private </span><span class="s1">cleanup;</span>
        <span class="s2">private </span><span class="s1">getEncodedSyntacticClassifications;</span>
        <span class="s2">private </span><span class="s1">getEncodedSemanticClassifications;</span>
        <span class="s2">private </span><span class="s1">getProject;</span>
        <span class="s2">private </span><span class="s1">getConfigFileAndProject;</span>
        <span class="s2">private </span><span class="s1">getConfigFileDiagnostics;</span>
        <span class="s2">private </span><span class="s1">convertToDiagnosticsWithLinePositionFromDiagnosticFile;</span>
        <span class="s2">private </span><span class="s1">getCompilerOptionsDiagnostics;</span>
        <span class="s2">private </span><span class="s1">convertToDiagnosticsWithLinePosition;</span>
        <span class="s2">private </span><span class="s1">getDiagnosticsWorker;</span>
        <span class="s2">private </span><span class="s1">getDefinition;</span>
        <span class="s2">private </span><span class="s1">mapDefinitionInfoLocations;</span>
        <span class="s2">private </span><span class="s1">getDefinitionAndBoundSpan;</span>
        <span class="s2">private </span><span class="s1">findSourceDefinition;</span>
        <span class="s2">private </span><span class="s1">getEmitOutput;</span>
        <span class="s2">private </span><span class="s1">mapJSDocTagInfo;</span>
        <span class="s2">private </span><span class="s1">mapDisplayParts;</span>
        <span class="s2">private </span><span class="s1">mapSignatureHelpItems;</span>
        <span class="s2">private </span><span class="s1">mapDefinitionInfo;</span>
        <span class="s2">private static </span><span class="s1">mapToOriginalLocation;</span>
        <span class="s2">private </span><span class="s1">toFileSpan;</span>
        <span class="s2">private </span><span class="s1">toFileSpanWithContext;</span>
        <span class="s2">private </span><span class="s1">getTypeDefinition;</span>
        <span class="s2">private </span><span class="s1">mapImplementationLocations;</span>
        <span class="s2">private </span><span class="s1">getImplementation;</span>
        <span class="s2">private </span><span class="s1">getOccurrences;</span>
        <span class="s2">private </span><span class="s1">getSyntacticDiagnosticsSync;</span>
        <span class="s2">private </span><span class="s1">getSemanticDiagnosticsSync;</span>
        <span class="s2">private </span><span class="s1">getSuggestionDiagnosticsSync;</span>
        <span class="s2">private </span><span class="s1">getJsxClosingTag;</span>
        <span class="s2">private </span><span class="s1">getDocumentHighlights;</span>
        <span class="s2">private </span><span class="s1">provideInlayHints;</span>
        <span class="s2">private </span><span class="s1">setCompilerOptionsForInferredProjects;</span>
        <span class="s2">private </span><span class="s1">getProjectInfo;</span>
        <span class="s2">private </span><span class="s1">getProjectInfoWorker;</span>
        <span class="s2">private </span><span class="s1">getRenameInfo;</span>
        <span class="s2">private </span><span class="s1">getProjects;</span>
        <span class="s2">private </span><span class="s1">getDefaultProject;</span>
        <span class="s2">private </span><span class="s1">getRenameLocations;</span>
        <span class="s2">private </span><span class="s1">mapRenameInfo;</span>
        <span class="s2">private </span><span class="s1">toSpanGroups;</span>
        <span class="s2">private </span><span class="s1">getReferences;</span>
        <span class="s2">private </span><span class="s1">getFileReferences;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@param </span><span class="s3">fileName </span><span class="s0">is the name of the file to be opened 
         * </span><span class="s2">@param </span><span class="s3">fileContent </span><span class="s0">is a version of the file content that is known to be more up to date than the one on disk 
         */</span>
        <span class="s2">private </span><span class="s1">openClientFile;</span>
        <span class="s2">private </span><span class="s1">getPosition;</span>
        <span class="s2">private </span><span class="s1">getPositionInFile;</span>
        <span class="s2">private </span><span class="s1">getFileAndProject;</span>
        <span class="s2">private </span><span class="s1">getFileAndLanguageServiceForSyntacticOperation;</span>
        <span class="s2">private </span><span class="s1">getFileAndProjectWorker;</span>
        <span class="s2">private </span><span class="s1">getOutliningSpans;</span>
        <span class="s2">private </span><span class="s1">getTodoComments;</span>
        <span class="s2">private </span><span class="s1">getDocCommentTemplate;</span>
        <span class="s2">private </span><span class="s1">getSpanOfEnclosingComment;</span>
        <span class="s2">private </span><span class="s1">getIndentation;</span>
        <span class="s2">private </span><span class="s1">getBreakpointStatement;</span>
        <span class="s2">private </span><span class="s1">getNameOrDottedNameSpan;</span>
        <span class="s2">private </span><span class="s1">isValidBraceCompletion;</span>
        <span class="s2">private </span><span class="s1">getQuickInfoWorker;</span>
        <span class="s2">private </span><span class="s1">getFormattingEditsForRange;</span>
        <span class="s2">private </span><span class="s1">getFormattingEditsForRangeFull;</span>
        <span class="s2">private </span><span class="s1">getFormattingEditsForDocumentFull;</span>
        <span class="s2">private </span><span class="s1">getFormattingEditsAfterKeystrokeFull;</span>
        <span class="s2">private </span><span class="s1">getFormattingEditsAfterKeystroke;</span>
        <span class="s2">private </span><span class="s1">getCompletions;</span>
        <span class="s2">private </span><span class="s1">getCompletionEntryDetails;</span>
        <span class="s2">private </span><span class="s1">getCompileOnSaveAffectedFileList;</span>
        <span class="s2">private </span><span class="s1">emitFile;</span>
        <span class="s2">private </span><span class="s1">getSignatureHelpItems;</span>
        <span class="s2">private </span><span class="s1">toPendingErrorCheck;</span>
        <span class="s2">private </span><span class="s1">getDiagnostics;</span>
        <span class="s2">private </span><span class="s1">change;</span>
        <span class="s2">private </span><span class="s1">reload;</span>
        <span class="s2">private </span><span class="s1">saveToTmp;</span>
        <span class="s2">private </span><span class="s1">closeClientFile;</span>
        <span class="s2">private </span><span class="s1">mapLocationNavigationBarItems;</span>
        <span class="s2">private </span><span class="s1">getNavigationBarItems;</span>
        <span class="s2">private </span><span class="s1">toLocationNavigationTree;</span>
        <span class="s2">private </span><span class="s1">getNavigationTree;</span>
        <span class="s2">private </span><span class="s1">getNavigateToItems;</span>
        <span class="s2">private </span><span class="s1">getFullNavigateToItems;</span>
        <span class="s2">private </span><span class="s1">getSupportedCodeFixes;</span>
        <span class="s2">private </span><span class="s1">isLocation;</span>
        <span class="s2">private </span><span class="s1">extractPositionOrRange;</span>
        <span class="s2">private </span><span class="s1">getRange;</span>
        <span class="s2">private </span><span class="s1">getApplicableRefactors;</span>
        <span class="s2">private </span><span class="s1">getEditsForRefactor;</span>
        <span class="s2">private </span><span class="s1">organizeImports;</span>
        <span class="s2">private </span><span class="s1">getEditsForFileRename;</span>
        <span class="s2">private </span><span class="s1">getCodeFixes;</span>
        <span class="s2">private </span><span class="s1">getCombinedCodeFix;</span>
        <span class="s2">private </span><span class="s1">applyCodeActionCommand;</span>
        <span class="s2">private </span><span class="s1">getStartAndEndPosition;</span>
        <span class="s2">private </span><span class="s1">mapCodeAction;</span>
        <span class="s2">private </span><span class="s1">mapCodeFixAction;</span>
        <span class="s2">private </span><span class="s1">mapTextChangesToCodeEdits;</span>
        <span class="s2">private </span><span class="s1">mapTextChangeToCodeEdit;</span>
        <span class="s2">private </span><span class="s1">convertTextChangeToCodeEdit;</span>
        <span class="s2">private </span><span class="s1">getBraceMatching;</span>
        <span class="s2">private </span><span class="s1">getDiagnosticsForProject;</span>
        <span class="s2">private </span><span class="s1">configurePlugin;</span>
        <span class="s2">private </span><span class="s1">getSmartSelectionRange;</span>
        <span class="s2">private </span><span class="s1">toggleLineComment;</span>
        <span class="s2">private </span><span class="s1">toggleMultilineComment;</span>
        <span class="s2">private </span><span class="s1">commentSelection;</span>
        <span class="s2">private </span><span class="s1">uncommentSelection;</span>
        <span class="s2">private </span><span class="s1">mapSelectionRange;</span>
        <span class="s2">private </span><span class="s1">getScriptInfoFromProjectService;</span>
        <span class="s2">private </span><span class="s1">toProtocolCallHierarchyItem;</span>
        <span class="s2">private </span><span class="s1">toProtocolCallHierarchyIncomingCall;</span>
        <span class="s2">private </span><span class="s1">toProtocolCallHierarchyOutgoingCall;</span>
        <span class="s2">private </span><span class="s1">prepareCallHierarchy;</span>
        <span class="s2">private </span><span class="s1">provideCallHierarchyIncomingCalls;</span>
        <span class="s2">private </span><span class="s1">provideCallHierarchyOutgoingCalls;</span>
        <span class="s1">getCanonicalFileName(</span><span class="s3">fileName</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">exit()</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">notRequired;</span>
        <span class="s2">private </span><span class="s1">requiredResponse;</span>
        <span class="s2">private </span><span class="s1">handlers;</span>
        <span class="s1">addProtocolHandler(</span><span class="s3">command</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s5">handler</span><span class="s2">: </span><span class="s1">(</span><span class="s3">request</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">Request</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">HandlerResponse</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">setCurrentRequest;</span>
        <span class="s2">private </span><span class="s1">resetCurrentRequest;</span>
        <span class="s1">executeWithRequestId&lt;</span><span class="s3">T</span><span class="s1">&gt;(</span><span class="s3">requestId</span><span class="s2">: </span><span class="s3">number</span><span class="s1">, </span><span class="s5">f</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">)</span><span class="s2">: </span><span class="s3">T</span><span class="s1">;</span>
        <span class="s1">executeCommand(</span><span class="s3">request</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">Request</span><span class="s1">)</span><span class="s2">: </span><span class="s3">HandlerResponse</span><span class="s1">;</span>
        <span class="s1">onMessage(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">TMessage</span><span class="s1">)</span><span class="s2">: </span><span class="s3">void</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">parseMessage(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">TMessage</span><span class="s1">)</span><span class="s2">: </span><span class="s3">protocol</span><span class="s1">.</span><span class="s3">Request</span><span class="s1">;</span>
        <span class="s2">protected </span><span class="s1">toStringMessage(</span><span class="s3">message</span><span class="s2">: </span><span class="s3">TMessage</span><span class="s1">)</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s2">private </span><span class="s1">getFormatOptions;</span>
        <span class="s2">private </span><span class="s1">getPreferences;</span>
        <span class="s2">private </span><span class="s1">getHostFormatOptions;</span>
        <span class="s2">private </span><span class="s1">getHostPreferences;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">HandlerResponse </span><span class="s1">{</span>
        <span class="s1">response</span><span class="s2">?: </span><span class="s1">{};</span>
        <span class="s1">responseRequired</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNodeArray` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNodeArray</span><span class="s2">: </span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">elements</span><span class="s2">?: readonly </span><span class="s3">T</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">hasTrailingComma</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNumericLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNumericLiteral</span><span class="s2">: </span><span class="s1">(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">number</span><span class="s1">, </span><span class="s3">numericLiteralFlags</span><span class="s2">?: </span><span class="s3">TokenFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NumericLiteral</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createBigIntLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createBigIntLiteral</span><span class="s2">: </span><span class="s1">(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PseudoBigInt</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BigIntLiteral</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createStringLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createStringLiteral</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">isSingleQuote</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">isSingleQuote</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">hasExtendedUnicodeEscape</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createStringLiteralFromNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createStringLiteralFromNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">sourceNode</span><span class="s2">: </span><span class="s3">PropertyNameLiteral</span><span class="s1">, </span><span class="s3">isSingleQuote</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createRegularExpressionLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createRegularExpressionLiteral</span><span class="s2">: </span><span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">RegularExpressionLiteral</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createLoopVariable` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createLoopVariable</span><span class="s2">: </span><span class="s1">(</span><span class="s3">reservedInNestedScopes</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createUniqueName` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createUniqueName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">GeneratedIdentifierFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPrivateIdentifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPrivateIdentifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createSuper` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createSuper</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">SuperExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createThis` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createThis</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">ThisExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNull` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNull</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">NullLiteral</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTrue` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTrue</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">TrueLiteral</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createFalse` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createFalse</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">FalseLiteral</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createModifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createModifier</span><span class="s2">: </span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">ModifierSyntaxKind</span><span class="s1">&gt;(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">T</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ModifierToken</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt;;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createModifiersFromModifierFlags` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createModifiersFromModifierFlags</span><span class="s2">: </span><span class="s1">(</span><span class="s3">flags</span><span class="s2">: </span><span class="s3">ModifierFlags</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createQualifiedName` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createQualifiedName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">QualifiedName</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateQualifiedName` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateQualifiedName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">QualifiedName</span><span class="s1">, </span><span class="s3">left</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">QualifiedName</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createComputedPropertyName` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createComputedPropertyName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ComputedPropertyName</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateComputedPropertyName` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateComputedPropertyName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ComputedPropertyName</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ComputedPropertyName</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypeParameterDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypeParameterDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">?: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">defaultType</span><span class="s2">?: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">?: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">defaultType</span><span class="s2">?: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypeParameterDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypeParameterDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">defaultType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">defaultType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createParameterDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createParameter</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateParameterDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateParameter</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createDecorator` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createDecorator</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Decorator</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateDecorator` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateDecorator</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Decorator</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Decorator</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPropertyDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createProperty</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionOrExclamationToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionOrExclamationToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updatePropertyDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateProperty</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionOrExclamationToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionOrExclamationToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createMethodDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createMethod</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateMethodDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateMethod</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createConstructorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createConstructor</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateConstructorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateConstructor</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createGetAccessorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createGetAccessor</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateGetAccessorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateGetAccessor</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createSetAccessorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createSetAccessor</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateSetAccessorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateSetAccessor</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createCallSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createCallSignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CallSignatureDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateCallSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateCallSignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CallSignatureDeclaration</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CallSignatureDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createConstructSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createConstructSignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ConstructSignatureDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateConstructSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateConstructSignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructSignatureDeclaration</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ConstructSignatureDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateIndexSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateIndexSignature</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createKeywordTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createKeywordTypeNode</span><span class="s2">: </span><span class="s1">&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">KeywordTypeSyntaxKind</span><span class="s1">&gt;(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">KeywordTypeNode</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypePredicateNodeWithModifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">assertsModifier</span><span class="s2">: </span><span class="s3">AssertsKeyword </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameterName</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypePredicateNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypePredicateNodeWithModifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypePredicateNode</span><span class="s1">, </span><span class="s3">assertsModifier</span><span class="s2">: </span><span class="s3">AssertsKeyword </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameterName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypePredicateNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypeReferenceNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypeReferenceNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeName</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeReferenceNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypeReferenceNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypeReferenceNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeReferenceNode</span><span class="s1">, </span><span class="s3">typeName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeReferenceNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createFunctionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createFunctionTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">FunctionTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateFunctionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateFunctionTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionTypeNode</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">FunctionTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createConstructorTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createConstructorTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateConstructorTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateConstructorTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructorTypeNode</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypeQueryNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypeQueryNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">exprName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeQueryNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypeQueryNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypeQueryNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeQueryNode</span><span class="s1">, </span><span class="s3">exprName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeQueryNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypeLiteralNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypeLiteralNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeLiteralNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypeLiteralNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypeLiteralNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeLiteralNode</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt;) </span><span class="s2">=&gt; </span><span class="s3">TypeLiteralNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createArrayTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createArrayTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elementType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ArrayTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateArrayTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateArrayTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrayTypeNode</span><span class="s1">, </span><span class="s3">elementType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ArrayTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTupleTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTupleTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s1">(</span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">NamedTupleMember</span><span class="s1">)[]) </span><span class="s2">=&gt; </span><span class="s3">TupleTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTupleTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTupleTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TupleTypeNode</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s1">(</span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">NamedTupleMember</span><span class="s1">)[]) </span><span class="s2">=&gt; </span><span class="s3">TupleTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createOptionalTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createOptionalTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">OptionalTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateOptionalTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateOptionalTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">OptionalTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">OptionalTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createRestTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createRestTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">RestTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateRestTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateRestTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">RestTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">RestTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createUnionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createUnionTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">types</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">UnionTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateUnionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateUnionTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">UnionTypeNode</span><span class="s1">, </span><span class="s3">types</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;) </span><span class="s2">=&gt; </span><span class="s3">UnionTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createIntersectionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createIntersectionTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">types</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">IntersectionTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateIntersectionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateIntersectionTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IntersectionTypeNode</span><span class="s1">, </span><span class="s3">types</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeNode</span><span class="s1">&gt;) </span><span class="s2">=&gt; </span><span class="s3">IntersectionTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createConditionalTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createConditionalTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">checkType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">extendsType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">trueType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">falseType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ConditionalTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateConditionalTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateConditionalTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConditionalTypeNode</span><span class="s1">, </span><span class="s3">checkType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">extendsType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">trueType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">falseType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ConditionalTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createInferTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createInferTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">InferTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateInferTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateInferTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">InferTypeNode</span><span class="s1">, </span><span class="s3">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">InferTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createImportTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createImportTypeNode</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">assertions</span><span class="s2">?: </span><span class="s3">ImportTypeAssertionContainer </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">?: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">assertions</span><span class="s2">?: </span><span class="s3">ImportTypeAssertionContainer </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">?: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">?: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateImportTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateImportTypeNode</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">, </span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">assertions</span><span class="s2">: </span><span class="s3">ImportTypeAssertionContainer </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">, </span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createParenthesizedType` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createParenthesizedType</span><span class="s2">: </span><span class="s1">(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ParenthesizedTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateParenthesizedType` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateParenthesizedType</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParenthesizedTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ParenthesizedTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createThisTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createThisTypeNode</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">ThisTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypeOperatorNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypeOperatorNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeOperatorNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeOperatorNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createIndexedAccessTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">objectType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">indexType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">IndexedAccessTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateIndexedAccessTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IndexedAccessTypeNode</span><span class="s1">, </span><span class="s3">objectType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">indexType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">IndexedAccessTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createMappedTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createMappedTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">readonlyToken</span><span class="s2">: </span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">, </span><span class="s3">nameType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">MappedTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateMappedTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateMappedTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MappedTypeNode</span><span class="s1">, </span><span class="s3">readonlyToken</span><span class="s2">: </span><span class="s3">ReadonlyKeyword </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameter</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">, </span><span class="s3">nameType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">PlusToken </span><span class="s2">| </span><span class="s3">MinusToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeElement</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">MappedTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createLiteralTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createLiteralTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">literal</span><span class="s2">: </span><span class="s3">LiteralExpression </span><span class="s2">| </span><span class="s3">BooleanLiteral </span><span class="s2">| </span><span class="s3">PrefixUnaryExpression </span><span class="s2">| </span><span class="s3">NullLiteral</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">LiteralTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateLiteralTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateLiteralTypeNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">LiteralTypeNode</span><span class="s1">, </span><span class="s3">literal</span><span class="s2">: </span><span class="s3">LiteralExpression </span><span class="s2">| </span><span class="s3">BooleanLiteral </span><span class="s2">| </span><span class="s3">PrefixUnaryExpression </span><span class="s2">| </span><span class="s3">NullLiteral</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">LiteralTypeNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createObjectBindingPattern` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createObjectBindingPattern</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">BindingElement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ObjectBindingPattern</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateObjectBindingPattern` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateObjectBindingPattern</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ObjectBindingPattern</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">BindingElement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ObjectBindingPattern</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createArrayBindingPattern` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createArrayBindingPattern</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ArrayBindingElement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ArrayBindingPattern</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateArrayBindingPattern` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateArrayBindingPattern</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrayBindingPattern</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ArrayBindingElement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ArrayBindingPattern</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createBindingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createBindingElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BindingElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateBindingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateBindingElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">BindingElement</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">PropertyName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BindingElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createArrayLiteralExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createArrayLiteral</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elements</span><span class="s2">?: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateArrayLiteralExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateArrayLiteral</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrayLiteralExpression</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ArrayLiteralExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createObjectLiteralExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createObjectLiteral</span><span class="s2">: </span><span class="s1">(</span><span class="s3">properties</span><span class="s2">?: readonly </span><span class="s3">ObjectLiteralElementLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateObjectLiteralExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateObjectLiteral</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ObjectLiteralExpression</span><span class="s1">, </span><span class="s3">properties</span><span class="s2">: readonly </span><span class="s3">ObjectLiteralElementLike</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ObjectLiteralExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPropertyAccessExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPropertyAccess</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">MemberName</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PropertyAccessExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updatePropertyAccessExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updatePropertyAccess</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyAccessExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">MemberName</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PropertyAccessExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPropertyAccessChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPropertyAccessChain</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">MemberName</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PropertyAccessChain</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updatePropertyAccessChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updatePropertyAccessChain</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyAccessChain</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">MemberName</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PropertyAccessChain</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createElementAccessExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createElementAccess</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">index</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ElementAccessExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateElementAccessExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateElementAccess</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ElementAccessExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">argumentExpression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ElementAccessExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createElementAccessChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createElementAccessChain</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">index</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ElementAccessChain</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateElementAccessChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateElementAccessChain</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ElementAccessChain</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentExpression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ElementAccessChain</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createCallExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createCall</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CallExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateCallExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateCall</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">CallExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createCallChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createCallChain</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CallChain</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateCallChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateCallChain</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CallChain</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionDotToken</span><span class="s2">: </span><span class="s3">QuestionDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">CallChain</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNewExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNew</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NewExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateNewExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateNew</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NewExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">argumentsArray</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NewExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypeAssertion` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypeAssertion</span><span class="s2">: </span><span class="s1">(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeAssertion</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypeAssertion` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypeAssertion</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeAssertion</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeAssertion</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createParenthesizedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createParen</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ParenthesizedExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateParenthesizedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateParen</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParenthesizedExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ParenthesizedExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createFunctionExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createFunctionExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">FunctionExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateFunctionExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateFunctionExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionExpression</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">FunctionExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createDeleteExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createDelete</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">DeleteExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateDeleteExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateDelete</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">DeleteExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">DeleteExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypeOfExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypeOf</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeOfExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypeOfExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypeOf</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeOfExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypeOfExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createVoidExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createVoid</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">VoidExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateVoidExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateVoid</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VoidExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">VoidExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createAwaitExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createAwait</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">AwaitExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateAwaitExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateAwait</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">AwaitExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">AwaitExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPrefixExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPrefix</span><span class="s2">: </span><span class="s1">(</span><span class="s3">operator</span><span class="s2">: </span><span class="s3">PrefixUnaryOperator</span><span class="s1">, </span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updatePrefixExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updatePrefix</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PrefixUnaryExpression</span><span class="s1">, </span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPostfixUnaryExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPostfix</span><span class="s2">: </span><span class="s1">(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">operator</span><span class="s2">: </span><span class="s3">PostfixUnaryOperator</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updatePostfixUnaryExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updatePostfix</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PostfixUnaryExpression</span><span class="s1">, </span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createBinaryExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createBinary</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">operator</span><span class="s2">: </span><span class="s3">BinaryOperator </span><span class="s2">| </span><span class="s3">BinaryOperatorToken</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateConditionalExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateConditional</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConditionalExpression</span><span class="s1">, </span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken</span><span class="s1">, </span><span class="s3">whenTrue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">colonToken</span><span class="s2">: </span><span class="s3">ColonToken</span><span class="s1">, </span><span class="s3">whenFalse</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ConditionalExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTemplateExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTemplateExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">head</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">, </span><span class="s3">templateSpans</span><span class="s2">: readonly </span><span class="s3">TemplateSpan</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">TemplateExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTemplateExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTemplateExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TemplateExpression</span><span class="s1">, </span><span class="s3">head</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">, </span><span class="s3">templateSpans</span><span class="s2">: readonly </span><span class="s3">TemplateSpan</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">TemplateExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTemplateHead` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTemplateHead</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateHead</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTemplateMiddle` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTemplateMiddle</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateMiddle</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateMiddle</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTemplateTail` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTemplateTail</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateTail</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">templateFlags</span><span class="s2">?: </span><span class="s3">TokenFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TemplateTail</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNoSubstitutionTemplateLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNoSubstitutionTemplateLiteral</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">rawText</span><span class="s2">: </span><span class="s3">string</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NoSubstitutionTemplateLiteral</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateYieldExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateYield</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">YieldExpression</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">YieldExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createSpreadExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createSpread</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">SpreadElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateSpreadExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateSpread</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SpreadElement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">SpreadElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createOmittedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createOmittedExpression</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">OmittedExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createAsExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createAsExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">AsExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateAsExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateAsExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">AsExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">AsExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNonNullExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNonNullExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NonNullExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateNonNullExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateNonNullExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NonNullExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NonNullExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNonNullChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNonNullChain</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NonNullChain</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateNonNullChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateNonNullChain</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NonNullChain</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NonNullChain</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createMetaProperty` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createMetaProperty</span><span class="s2">: </span><span class="s1">(</span><span class="s3">keywordToken</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImportKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">NewKeyword</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">MetaProperty</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateMetaProperty` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateMetaProperty</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MetaProperty</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">MetaProperty</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTemplateSpan` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTemplateSpan</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">literal</span><span class="s2">: </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TemplateSpan</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTemplateSpan` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTemplateSpan</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TemplateSpan</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">literal</span><span class="s2">: </span><span class="s3">TemplateMiddle </span><span class="s2">| </span><span class="s3">TemplateTail</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TemplateSpan</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createSemicolonClassElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createSemicolonClassElement</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">SemicolonClassElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createBlock</span><span class="s2">: </span><span class="s1">(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">multiLine</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Block</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateBlock</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">Block</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createVariableStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createVariableStatement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">declarationList</span><span class="s2">: </span><span class="s3">VariableDeclarationList </span><span class="s2">| readonly </span><span class="s3">VariableDeclaration</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">VariableStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateVariableStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateVariableStatement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VariableStatement</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">declarationList</span><span class="s2">: </span><span class="s3">VariableDeclarationList</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">VariableStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createEmptyStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createEmptyStatement</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">EmptyStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createExpressionStatement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateExpressionStatement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExpressionStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createStatement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateStatement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExpressionStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createIfStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createIf</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">thenStatement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">elseStatement</span><span class="s2">?: </span><span class="s3">Statement </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">IfStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateIfStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateIf</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IfStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">thenStatement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">elseStatement</span><span class="s2">: </span><span class="s3">Statement </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">IfStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createDoStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createDo</span><span class="s2">: </span><span class="s1">(</span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">DoStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateDoStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateDo</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">DoStatement</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">DoStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createWhileStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createWhile</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">WhileStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateWhileStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateWhile</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">WhileStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">WhileStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createForStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createFor</span><span class="s2">: </span><span class="s1">(</span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">incrementor</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ForStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateForStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateFor</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ForStatement</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">incrementor</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ForStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createForInStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createForIn</span><span class="s2">: </span><span class="s1">(</span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ForInStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateForInStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateForIn</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ForInStatement</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ForInStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createForOfStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createForOf</span><span class="s2">: </span><span class="s1">(</span><span class="s3">awaitModifier</span><span class="s2">: </span><span class="s3">AwaitKeyword </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ForOfStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateForOfStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateForOf</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ForOfStatement</span><span class="s1">, </span><span class="s3">awaitModifier</span><span class="s2">: </span><span class="s3">AwaitKeyword </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">ForInitializer</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ForOfStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createContinueStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createContinue</span><span class="s2">: </span><span class="s1">(</span><span class="s3">label</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ContinueStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateContinueStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateContinue</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ContinueStatement</span><span class="s1">, </span><span class="s3">label</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ContinueStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createBreakStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createBreak</span><span class="s2">: </span><span class="s1">(</span><span class="s3">label</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BreakStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateBreakStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateBreak</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">BreakStatement</span><span class="s1">, </span><span class="s3">label</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BreakStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createReturnStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createReturn</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ReturnStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateReturnStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateReturn</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ReturnStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ReturnStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createWithStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createWith</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">WithStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateWithStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateWith</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">WithStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">WithStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createSwitchStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createSwitch</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">caseBlock</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">SwitchStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateSwitchStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateSwitch</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SwitchStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">caseBlock</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">SwitchStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createLabelStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createLabel</span><span class="s2">: </span><span class="s1">(</span><span class="s3">label</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">LabeledStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateLabelStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateLabel</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">LabeledStatement</span><span class="s1">, </span><span class="s3">label</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">statement</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">LabeledStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createThrowStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createThrow</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ThrowStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateThrowStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateThrow</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ThrowStatement</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ThrowStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTryStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTry</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tryBlock</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">, </span><span class="s3">catchClause</span><span class="s2">: </span><span class="s3">CatchClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">finallyBlock</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TryStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTryStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTry</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TryStatement</span><span class="s1">, </span><span class="s3">tryBlock</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">, </span><span class="s3">catchClause</span><span class="s2">: </span><span class="s3">CatchClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">finallyBlock</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TryStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createDebuggerStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createDebuggerStatement</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">DebuggerStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createVariableDeclarationList` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createVariableDeclarationList</span><span class="s2">: </span><span class="s1">(</span><span class="s3">declarations</span><span class="s2">: readonly </span><span class="s3">VariableDeclaration</span><span class="s1">[], </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">NodeFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">VariableDeclarationList</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateVariableDeclarationList` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateVariableDeclarationList</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VariableDeclarationList</span><span class="s1">, </span><span class="s3">declarations</span><span class="s2">: readonly </span><span class="s3">VariableDeclaration</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">VariableDeclarationList</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createFunctionDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createFunctionDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateFunctionDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateFunctionDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createClassDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createClassDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateClassDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateClassDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">ModifierLike</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createInterfaceDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createInterfaceDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateInterfaceDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateInterfaceDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypeAliasDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypeAliasDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypeAliasDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypeAliasDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createEnumDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createEnumDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">EnumMember</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">EnumMember</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateEnumDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateEnumDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">EnumMember</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">EnumMember</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createModuleDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createModuleDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">NodeFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">NodeFlags </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateModuleDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateModuleDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createModuleBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createModuleBlock</span><span class="s2">: </span><span class="s1">(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ModuleBlock</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateModuleBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateModuleBlock</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ModuleBlock</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ModuleBlock</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createCaseBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createCaseBlock</span><span class="s2">: </span><span class="s1">(</span><span class="s3">clauses</span><span class="s2">: readonly </span><span class="s3">CaseOrDefaultClause</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">CaseBlock</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateCaseBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateCaseBlock</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CaseBlock</span><span class="s1">, </span><span class="s3">clauses</span><span class="s2">: readonly </span><span class="s3">CaseOrDefaultClause</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">CaseBlock</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNamespaceExportDeclaration</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NamespaceExportDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateNamespaceExportDeclaration</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamespaceExportDeclaration</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NamespaceExportDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createImportEqualsDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createImportEqualsDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateImportEqualsDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateImportEqualsDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createImportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createImportDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">importClause</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">?: </span><span class="s3">AssertClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">importClause</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">?: </span><span class="s3">AssertClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateImportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateImportDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">importClause</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">: </span><span class="s3">AssertClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">importClause</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">: </span><span class="s3">AssertClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNamespaceImport` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNamespaceImport</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NamespaceImport</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateNamespaceImport` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateNamespaceImport</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamespaceImport</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NamespaceImport</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNamedImports` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNamedImports</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ImportSpecifier</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">NamedImports</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateNamedImports` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateNamedImports</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamedImports</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ImportSpecifier</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">NamedImports</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createImportSpecifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createImportSpecifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ImportSpecifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateImportSpecifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateImportSpecifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportSpecifier</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ImportSpecifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExportAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createExportAssignment</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isExportEquals</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isExportEquals</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateExportAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateExportAssignment</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNamedExports` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNamedExports</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ExportSpecifier</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">NamedExports</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateNamedExports` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateNamedExports</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamedExports</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">ExportSpecifier</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">NamedExports</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExportSpecifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createExportSpecifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateExportSpecifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateExportSpecifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportSpecifier</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">propertyName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExternalModuleReference` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createExternalModuleReference</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExternalModuleReference</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateExternalModuleReference` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateExternalModuleReference</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExternalModuleReference</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExternalModuleReference</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocTypeExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocTypeExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocTypeExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocTypeTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocTypeTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocTypeTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocReturnTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocReturnTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocReturnTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocThisTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocThisTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocThisTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocComment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocComment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">tags</span><span class="s2">?: readonly </span><span class="s3">JSDocTag</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDoc</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocParameterTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">isBracketed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isNameFirst</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocParameterTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocClassTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocClassTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocClassTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocAugmentsTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocAugmentsTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">className</span><span class="s2">: </span><span class="s3">ExpressionWithTypeArguments </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PropertyAccessEntityNameExpression</span><span class="s1">;</span>
    <span class="s1">}, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocAugmentsTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocEnumTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocEnumTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocTypeExpression</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocEnumTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocTemplateTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocTemplateTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[], </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocTemplateTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocTypedefTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocTypedefTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeLiteral </span><span class="s2">| </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">fullName</span><span class="s2">?: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocTypedefTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocCallbackTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocCallbackTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">: </span><span class="s3">JSDocSignature</span><span class="s1">, </span><span class="s3">fullName</span><span class="s2">?: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocCallbackTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocSignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">JSDocTemplateTag</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">JSDocParameterTag</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">JSDocReturnTag </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocSignature</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocPropertyTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocPropertyTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">isBracketed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isNameFirst</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocPropertyTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocTypeLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocTypeLiteral</span><span class="s2">: </span><span class="s1">(</span><span class="s3">jsDocPropertyTags</span><span class="s2">?: readonly </span><span class="s3">JSDocPropertyLikeTag</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isArrayType</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocTypeLiteral</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocImplementsTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocImplementsTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">className</span><span class="s2">: </span><span class="s3">ExpressionWithTypeArguments </span><span class="s2">&amp; </span><span class="s1">{</span>
        <span class="s2">readonly </span><span class="s1">expression</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PropertyAccessEntityNameExpression</span><span class="s1">;</span>
    <span class="s1">}, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocImplementsTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocAuthorTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocAuthorTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocAuthorTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocPublicTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocPublicTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocPublicTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocPrivateTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocPrivateTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocPrivateTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocProtectedTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocProtectedTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocProtectedTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocReadonlyTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocReadonlyTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocReadonlyTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocUnknownTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">JSDocComment</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocUnknownTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">openingElement</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">, </span><span class="s3">children</span><span class="s2">: readonly </span><span class="s3">JsxChild</span><span class="s1">[], </span><span class="s3">closingElement</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxElement</span><span class="s1">, </span><span class="s3">openingElement</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">, </span><span class="s3">children</span><span class="s2">: readonly </span><span class="s3">JsxChild</span><span class="s1">[], </span><span class="s3">closingElement</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxSelfClosingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxSelfClosingElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxSelfClosingElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxSelfClosingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxSelfClosingElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxSelfClosingElement</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxSelfClosingElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxOpeningElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxOpeningElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxOpeningElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxOpeningElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxOpeningElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxOpeningElement</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">attributes</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxOpeningElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxClosingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxClosingElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxClosingElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxClosingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxClosingElement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxClosingElement</span><span class="s1">, </span><span class="s3">tagName</span><span class="s2">: </span><span class="s3">JsxTagNameExpression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxClosingElement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxFragment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxFragment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">openingFragment</span><span class="s2">: </span><span class="s3">JsxOpeningFragment</span><span class="s1">, </span><span class="s3">children</span><span class="s2">: readonly </span><span class="s3">JsxChild</span><span class="s1">[], </span><span class="s3">closingFragment</span><span class="s2">: </span><span class="s3">JsxClosingFragment</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxFragment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxText` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxText</span><span class="s2">: </span><span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containsOnlyTriviaWhiteSpaces</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxText</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxText` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxText</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxText</span><span class="s1">, </span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">, </span><span class="s3">containsOnlyTriviaWhiteSpaces</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxText</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxOpeningFragment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxOpeningFragment</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">JsxOpeningFragment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxJsxClosingFragment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxJsxClosingFragment</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">JsxClosingFragment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxFragment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxFragment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxFragment</span><span class="s1">, </span><span class="s3">openingFragment</span><span class="s2">: </span><span class="s3">JsxOpeningFragment</span><span class="s1">, </span><span class="s3">children</span><span class="s2">: readonly </span><span class="s3">JsxChild</span><span class="s1">[], </span><span class="s3">closingFragment</span><span class="s2">: </span><span class="s3">JsxClosingFragment</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxFragment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxAttribute` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxAttribute</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">JsxAttributeValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxAttribute</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxAttribute` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxAttribute</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxAttribute</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">JsxAttributeValue </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxAttribute</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxAttributes` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxAttributes</span><span class="s2">: </span><span class="s1">(</span><span class="s3">properties</span><span class="s2">: readonly </span><span class="s3">JsxAttributeLike</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxAttributes` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxAttributes</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxAttributes</span><span class="s1">, </span><span class="s3">properties</span><span class="s2">: readonly </span><span class="s3">JsxAttributeLike</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">JsxAttributes</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxSpreadAttribute` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxSpreadAttribute</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxSpreadAttribute</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxSpreadAttribute` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxSpreadAttribute</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxSpreadAttribute</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxSpreadAttribute</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJsxExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJsxExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateJsxExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateJsxExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">JsxExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JsxExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createCaseClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createCaseClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">CaseClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateCaseClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateCaseClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CaseClause</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">CaseClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createDefaultClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createDefaultClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">DefaultClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateDefaultClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateDefaultClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">DefaultClause</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">DefaultClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createHeritageClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createHeritageClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">token</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExtendsKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ImplementsKeyword</span><span class="s1">, </span><span class="s3">types</span><span class="s2">: readonly </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">HeritageClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateHeritageClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateHeritageClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">HeritageClause</span><span class="s1">, </span><span class="s3">types</span><span class="s2">: readonly </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">HeritageClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createCatchClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createCatchClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">variableDeclaration</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">BindingName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">block</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CatchClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateCatchClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateCatchClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CatchClause</span><span class="s1">, </span><span class="s3">variableDeclaration</span><span class="s2">: </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">block</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">CatchClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPropertyAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPropertyAssignment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PropertyAssignment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updatePropertyAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updatePropertyAssignment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyAssignment</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PropertyAssignment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createShorthandPropertyAssignment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">objectAssignmentInitializer</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ShorthandPropertyAssignment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateShorthandPropertyAssignment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ShorthandPropertyAssignment</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">objectAssignmentInitializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ShorthandPropertyAssignment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createSpreadAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createSpreadAssignment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">SpreadAssignment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateSpreadAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateSpreadAssignment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SpreadAssignment</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">SpreadAssignment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createEnumMember` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createEnumMember</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">EnumMember</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateEnumMember` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateEnumMember</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">EnumMember</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">EnumMember</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateSourceFile` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateSourceFileNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SourceFile</span><span class="s1">, </span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">isDeclarationFile</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">referencedFiles</span><span class="s2">?: readonly </span><span class="s3">FileReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeReferences</span><span class="s2">?: readonly </span><span class="s3">FileReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">hasNoDefaultLib</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">libReferences</span><span class="s2">?: readonly </span><span class="s3">FileReference</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">SourceFile</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNotEmittedStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNotEmittedStatement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">original</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NotEmittedStatement</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPartiallyEmittedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPartiallyEmittedExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">original</span><span class="s2">?: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PartiallyEmittedExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updatePartiallyEmittedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updatePartiallyEmittedExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PartiallyEmittedExpression</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PartiallyEmittedExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createCommaListExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createCommaList</span><span class="s2">: </span><span class="s1">(</span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">CommaListExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateCommaListExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateCommaList</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">CommaListExpression</span><span class="s1">, </span><span class="s3">elements</span><span class="s2">: readonly </span><span class="s3">Expression</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">CommaListExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createBundle` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createBundle</span><span class="s2">: </span><span class="s1">(</span><span class="s3">sourceFiles</span><span class="s2">: readonly </span><span class="s3">SourceFile</span><span class="s1">[], </span><span class="s3">prepends</span><span class="s2">?: readonly </span><span class="s1">(</span><span class="s3">UnparsedSource </span><span class="s2">| </span><span class="s3">InputFiles</span><span class="s1">)[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Bundle</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateBundle` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateBundle</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Bundle</span><span class="s1">, </span><span class="s3">sourceFiles</span><span class="s2">: readonly </span><span class="s3">SourceFile</span><span class="s1">[], </span><span class="s3">prepends</span><span class="s2">?: readonly </span><span class="s1">(</span><span class="s3">UnparsedSource </span><span class="s2">| </span><span class="s3">InputFiles</span><span class="s1">)[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Bundle</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createImmediatelyInvokedFunctionExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createImmediatelyInvokedFunctionExpression</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">param</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">paramValue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createImmediatelyInvokedArrowFunction` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createImmediatelyInvokedArrowFunction</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">statements</span><span class="s2">: readonly </span><span class="s3">Statement</span><span class="s1">[], </span><span class="s3">param</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">paramValue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">CallExpression</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createVoidZero` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createVoidZero</span><span class="s2">: </span><span class="s1">() </span><span class="s2">=&gt; </span><span class="s3">VoidExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExportDefault` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createExportDefault</span><span class="s2">: </span><span class="s1">(</span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExternalModuleExport` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createExternalModuleExport</span><span class="s2">: </span><span class="s1">(</span><span class="s3">exportName</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createNamespaceExport` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createNamespaceExport</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NamespaceExport</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateNamespaceExport` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateNamespaceExport</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">NamespaceExport</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">NamespaceExport</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createToken` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createToken</span><span class="s2">: </span><span class="s1">&lt;</span><span class="s3">TKind </span><span class="s2">extends </span><span class="s3">SyntaxKind</span><span class="s1">&gt;(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">TKind</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Token</span><span class="s1">&lt;</span><span class="s3">TKind</span><span class="s1">&gt;;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createIdentifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createIdentifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTempVariable` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTempVariable</span><span class="s2">: </span><span class="s1">(</span><span class="s3">recordTempVariable</span><span class="s2">: </span><span class="s1">((</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">void</span><span class="s1">) </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.getGeneratedNameForNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">getGeneratedNameForNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic)` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createOptimisticUniqueName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic | GeneratedIdentifierFlags.FileLevel)` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createFileLevelUniqueName</span><span class="s2">: </span><span class="s1">(</span><span class="s3">text</span><span class="s2">: </span><span class="s3">string</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createIndexSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createIndexSignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypePredicateNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">parameterName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisTypeNode </span><span class="s2">| </span><span class="s3">string</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypePredicateNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTypePredicateNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypePredicateNode</span><span class="s1">, </span><span class="s3">parameterName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisTypeNode</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">TypePredicateNode</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createStringLiteral`, `factory.createStringLiteralFromNode`, `factory.createNumericLiteral`, `factory.createBigIntLiteral`, `factory.createTrue`, `factory.createFalse`, or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createLiteral</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">NoSubstitutionTemplateLiteral </span><span class="s2">| </span><span class="s3">NumericLiteral </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">)</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">number </span><span class="s2">| </span><span class="s3">PseudoBigInt</span><span class="s1">)</span><span class="s2">: </span><span class="s3">NumericLiteral</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">BooleanLiteral</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">value</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">number </span><span class="s2">| </span><span class="s3">PseudoBigInt </span><span class="s2">| </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PrimaryExpression</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createMethodSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createMethodSignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">MethodSignature</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateMethodSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateMethodSignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MethodSignature</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">MethodSignature</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTypeOperatorNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTypeOperatorNode</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeOperatorNode</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">operator</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">KeyOfKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">UniqueKeyword </span><span class="s2">| </span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ReadonlyKeyword</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeOperatorNode</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createTaggedTemplate` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createTaggedTemplate</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">tag</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">template</span><span class="s2">: </span><span class="s3">TemplateLiteral</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">tag</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">template</span><span class="s2">: </span><span class="s3">TemplateLiteral</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateTaggedTemplate` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateTaggedTemplate</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">, </span><span class="s3">tag</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">template</span><span class="s2">: </span><span class="s3">TemplateLiteral</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">, </span><span class="s3">tag</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">template</span><span class="s2">: </span><span class="s3">TemplateLiteral</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateBinary` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateBinary</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">BinaryExpression</span><span class="s1">, </span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">operator</span><span class="s2">?: </span><span class="s3">BinaryOperator </span><span class="s2">| </span><span class="s3">BinaryOperatorToken</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createConditional` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createConditional</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">whenTrue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">whenFalse</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConditionalExpression</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">condition</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken</span><span class="s1">, </span><span class="s3">whenTrue</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">colonToken</span><span class="s2">: </span><span class="s3">ColonToken</span><span class="s1">, </span><span class="s3">whenFalse</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConditionalExpression</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createYield` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createYield</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">expression</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">YieldExpression</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">YieldExpression</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createClassExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createClassExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ClassExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateClassExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateClassExpression</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassExpression</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[]) </span><span class="s2">=&gt; </span><span class="s3">ClassExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPropertySignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPropertySignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName </span><span class="s2">| </span><span class="s3">string</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PropertySignature</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updatePropertySignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updatePropertySignature</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertySignature</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PropertySignature</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createExpressionWithTypeArguments</span><span class="s2">: </span><span class="s1">(</span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateExpressionWithTypeArguments</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExpressionWithTypeArguments</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createArrowFunction` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createArrowFunction</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">equalsGreaterThanToken</span><span class="s2">: </span><span class="s3">EqualsGreaterThanToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateArrowFunction` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateArrowFunction</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">equalsGreaterThanToken</span><span class="s2">: </span><span class="s3">EqualsGreaterThanToken</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ConciseBody</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ArrowFunction</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createVariableDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createVariableDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">exclamationToken</span><span class="s2">: </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateVariableDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateVariableDeclaration</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
        <span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">exclamationToken</span><span class="s2">: </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createImportClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createImportClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">namedBindings</span><span class="s2">: </span><span class="s3">NamedImportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ImportClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateImportClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateImportClause</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportClause</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">namedBindings</span><span class="s2">: </span><span class="s3">NamedImportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ImportClause</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createExportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createExportDeclaration</span><span class="s2">: </span><span class="s1">(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">exportClause</span><span class="s2">: </span><span class="s3">NamedExportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.updateExportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">updateExportDeclaration</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">exportClause</span><span class="s2">: </span><span class="s3">NamedExportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createJSDocParamTag</span><span class="s2">: </span><span class="s1">(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">isBracketed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">typeExpression</span><span class="s2">?: </span><span class="s3">JSDocTypeExpression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">comment</span><span class="s2">?: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">JSDocParameterTag</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createComma` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createComma</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createLessThan` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createLessThan</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createAssignment</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createStrictEquality` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createStrictEquality</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createStrictInequality` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createStrictInequality</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createAdd` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createAdd</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createSubtract` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createSubtract</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createLogicalAnd` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createLogicalAnd</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createLogicalOr` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createLogicalOr</span><span class="s2">: </span><span class="s1">(</span><span class="s3">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createPostfixIncrement` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createPostfixIncrement</span><span class="s2">: </span><span class="s1">(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PostfixUnaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `factory.createLogicalNot` or the factory supplied by your transformation context instead. */</span>
    <span class="s2">const </span><span class="s1">createLogicalNot</span><span class="s2">: </span><span class="s1">(</span><span class="s3">operand</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">PrefixUnaryExpression</span><span class="s1">;</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use an appropriate `factory` method instead. */</span>
    <span class="s2">const </span><span class="s1">createNode</span><span class="s2">: </span><span class="s1">(</span><span class="s3">kind</span><span class="s2">: </span><span class="s3">SyntaxKind</span><span class="s1">, </span><span class="s3">pos</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">, </span><span class="s3">end</span><span class="s2">?: </span><span class="s3">any</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">Node</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a shallow, memberwise clone of a node ~for mutation~ with its `pos`, `end`, and `parent` set. 
     * 
     * NOTE: It is unsafe to change any properties of a `Node` that relate to its AST children, as those changes won't be 
     * captured with respect to transformations. 
     * 
     * </span><span class="s2">@deprecated </span><span class="s0">Use an appropriate `factory.update...` method instead, use `setCommentRange` or `setSourceMapRange`, and avoid setting `parent`. 
     */</span>
    <span class="s2">const </span><span class="s1">getMutableClone</span><span class="s2">: </span><span class="s1">&lt;</span><span class="s3">T </span><span class="s2">extends </span><span class="s3">Node</span><span class="s1">&gt;(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">T</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">T</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use `isTypeAssertionExpression` instead. */</span>
    <span class="s2">const </span><span class="s1">isTypeAssertion</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">node </span><span class="s2">is </span><span class="s3">TypeAssertion</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Use `ts.ReadonlyESMap&lt;K, V&gt;` instead. 
     */</span>
    <span class="s2">interface </span><span class="s3">ReadonlyMap</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ReadonlyESMap</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">, </span><span class="s3">T</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Use `ts.ESMap&lt;K, V&gt;` instead. 
     */</span>
    <span class="s2">interface </span><span class="s3">Map</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">extends </span><span class="s3">ESMap</span><span class="s1">&lt;</span><span class="s3">string</span><span class="s1">, </span><span class="s3">T</span><span class="s1">&gt; {</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Use `isMemberName` instead. 
     */</span>
    <span class="s2">const </span><span class="s1">isIdentifierOrPrivateIdentifier</span><span class="s2">: </span><span class="s1">(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">Node</span><span class="s1">) </span><span class="s2">=&gt; </span><span class="s3">node </span><span class="s2">is </span><span class="s3">MemberName</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">NodeFactory </span><span class="s1">{</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use the overload that accepts 'modifiers' */</span>
        <span class="s1">createConstructorTypeNode(</span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use the overload that accepts 'modifiers' */</span>
        <span class="s1">updateConstructorTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructorTypeNode</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">TypeParameterDeclaration</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ParameterDeclaration</span><span class="s1">&gt;, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorTypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">NodeFactory </span><span class="s1">{</span>
        <span class="s1">createImportTypeNode(</span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">assertions</span><span class="s2">?: </span><span class="s3">ImportTypeAssertionContainer</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">?: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[], </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use the overload that accepts 'assertions' */</span>
        <span class="s1">createImportTypeNode(</span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">?: </span><span class="s3">EntityName</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">?: readonly </span><span class="s3">TypeNode</span><span class="s1">[], </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use the overload that accepts 'assertions' */</span>
        <span class="s1">updateImportTypeNode(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">, </span><span class="s3">argument</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">qualifier</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeArguments</span><span class="s2">: readonly </span><span class="s3">TypeNode</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOf</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportTypeNode</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">NodeFactory </span><span class="s1">{</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use the overload that accepts 'modifiers' */</span>
        <span class="s1">createTypeParameterDeclaration(</span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">defaultType</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">Use the overload that accepts 'modifiers' */</span>
        <span class="s1">updateTypeParameterDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">constraint</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">defaultType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">declare namespace </span><span class="s3">ts </span><span class="s1">{</span>
    <span class="s2">interface </span><span class="s3">Node </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">`decorators` has been removed from `Node` and merged with `modifiers` on the `Node` subtypes that support them. 
         * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators. 
         * Use `ts.getDecorators()` to get the decorators of a `Node`. 
         * 
         * For example: 
         * ```ts 
         * const decorators = ts.canHaveDecorators(node) ? ts.getDecorators(node) : undefined; 
         * ``` 
         */</span>
        <span class="s2">readonly </span><span class="s1">decorators</span><span class="s2">?: </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">`modifiers` has been removed from `Node` and moved to the `Node` subtypes that support them. 
         * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers. 
         * Use `ts.getModifiers()` to get the modifiers of a `Node`. 
         * 
         * For example: 
         * ```ts 
         * const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined; 
         * ``` 
         */</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">ModifierLike</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PropertySignature </span><span class="s1">{</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">A property signature cannot have an initializer */</span>
        <span class="s2">readonly </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">PropertyAssignment </span><span class="s1">{</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">A property assignment cannot have a question token */</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">A property assignment cannot have an exclamation token */</span>
        <span class="s2">readonly </span><span class="s1">exclamationToken</span><span class="s2">?: </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">ShorthandPropertyAssignment </span><span class="s1">{</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">A shorthand property assignment cannot have modifiers */</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">A shorthand property assignment cannot have a question token */</span>
        <span class="s2">readonly </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">A shorthand property assignment cannot have an exclamation token */</span>
        <span class="s2">readonly </span><span class="s1">exclamationToken</span><span class="s2">?: </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">FunctionTypeNode </span><span class="s1">{</span>
        <span class="s0">/** </span><span class="s2">@deprecated </span><span class="s0">A function type cannot have modifiers */</span>
        <span class="s2">readonly </span><span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">NodeArray</span><span class="s1">&lt;</span><span class="s3">Modifier</span><span class="s1">&gt; </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">interface </span><span class="s3">NodeFactory </span><span class="s1">{</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createParameterDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">?: </span><span class="s3">QuestionToken</span><span class="s1">, </span><span class="s3">type</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateParameterDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">dotDotDotToken</span><span class="s2">: </span><span class="s3">DotDotDotToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">BindingName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ParameterDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createPropertyDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionOrExclamationToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updatePropertyDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionOrExclamationToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">ExclamationToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">initializer</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">PropertyDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createMethodDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateMethodDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">questionToken</span><span class="s2">: </span><span class="s3">QuestionToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">MethodDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createConstructorDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateConstructorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ConstructorDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createGetAccessorDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateGetAccessorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">GetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createSetAccessorDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateSetAccessorDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">SetAccessorDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createIndexSignature(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters. 
         */</span>
        <span class="s1">updateIndexSignature(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">IndexSignatureDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters. 
         */</span>
        <span class="s1">createClassStaticBlockDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassStaticBlockDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateClassStaticBlockDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassStaticBlockDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ClassStaticBlockDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createClassExpression(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassExpression</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateClassExpression(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassExpression</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassExpression</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createFunctionDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateFunctionDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">asteriskToken</span><span class="s2">: </span><span class="s3">AsteriskToken </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">parameters</span><span class="s2">: readonly </span><span class="s3">ParameterDeclaration</span><span class="s1">[], </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">Block </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createClassDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateClassDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">ClassElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createInterfaceDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateInterfaceDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">heritageClauses</span><span class="s2">: readonly </span><span class="s3">HeritageClause</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">TypeElement</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">InterfaceDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createTypeAliasDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateTypeAliasDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">typeParameters</span><span class="s2">: readonly </span><span class="s3">TypeParameterDeclaration</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">type</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">)</span><span class="s2">: </span><span class="s3">TypeAliasDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createEnumDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">EnumMember</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateEnumDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">members</span><span class="s2">: readonly </span><span class="s3">EnumMember</span><span class="s1">[])</span><span class="s2">: </span><span class="s3">EnumDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createModuleDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">flags</span><span class="s2">?: </span><span class="s3">NodeFlags</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateModuleDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">ModuleName</span><span class="s1">, </span><span class="s3">body</span><span class="s2">: </span><span class="s3">ModuleBody </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ModuleDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createImportEqualsDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">string </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateImportEqualsDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">, </span><span class="s3">moduleReference</span><span class="s2">: </span><span class="s3">ModuleReference</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportEqualsDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createImportDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">importClause</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">?: </span><span class="s3">AssertClause</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateImportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">importClause</span><span class="s2">: </span><span class="s3">ImportClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">: </span><span class="s3">AssertClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createExportAssignment(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isExportEquals</span><span class="s2">: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateExportAssignment(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportAssignment</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">createExportDeclaration(</span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">exportClause</span><span class="s2">: </span><span class="s3">NamedExportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">?: </span><span class="s3">AssertClause</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter. 
         */</span>
        <span class="s1">updateExportDeclaration(</span><span class="s3">node</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">, </span><span class="s3">decorators</span><span class="s2">: readonly </span><span class="s3">Decorator</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">modifiers</span><span class="s2">: readonly </span><span class="s3">Modifier</span><span class="s1">[] </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">isTypeOnly</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">, </span><span class="s3">exportClause</span><span class="s2">: </span><span class="s3">NamedExportBindings </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">moduleSpecifier</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">, </span><span class="s3">assertClause</span><span class="s2">: </span><span class="s3">AssertClause </span><span class="s2">| </span><span class="s3">undefined</span><span class="s1">)</span><span class="s2">: </span><span class="s3">ExportDeclaration</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">export = </span><span class="s3">ts</span><span class="s1">;</span>
<span class="s2">export as namespace </span><span class="s3">ts</span><span class="s1">;</span></pre>
</body>
</html>
<html>
<head>
<title>indent-legacy.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
indent-legacy.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @fileoverview This option sets a specific tab width for your code 
 * 
 * This rule has been ported and modified from nodeca. 
 * @author Vitaly Puzrin 
 * @author Gyandeep Singh 
 * @deprecated in ESLint v4.0.0 
 */</span>

<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s1">const astUtils = require(</span><span class="s2">&quot;./utils/ast-utils&quot;</span><span class="s1">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway.</span>
<span class="s0">/* c8 ignore next */</span>
<span class="s0">/** @type {import('../shared/types').Rule} */</span>
<span class="s1">module.exports = {</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s2">&quot;layout&quot;</span><span class="s1">,</span>

        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s2">&quot;Enforce consistent indentation&quot;</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">url: </span><span class="s2">&quot;https://eslint.org/docs/latest/rules/indent-legacy&quot;</span>
        <span class="s1">},</span>

        <span class="s1">deprecated: </span><span class="s3">true</span><span class="s1">,</span>

        <span class="s1">replacedBy: [</span><span class="s2">&quot;indent&quot;</span><span class="s1">],</span>

        <span class="s1">fixable: </span><span class="s2">&quot;whitespace&quot;</span><span class="s1">,</span>

        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">oneOf: [</span>
                    <span class="s1">{</span>
                        <span class="s1">enum: [</span><span class="s2">&quot;tab&quot;</span><span class="s1">]</span>
                    <span class="s1">},</span>
                    <span class="s1">{</span>
                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                        <span class="s1">minimum: </span><span class="s4">0</span>
                    <span class="s1">}</span>
                <span class="s1">]</span>
            <span class="s1">},</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">SwitchCase: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                        <span class="s1">minimum: </span><span class="s4">0</span>
                    <span class="s1">},</span>
                    <span class="s1">VariableDeclarator: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">{</span>
                                <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                <span class="s1">minimum: </span><span class="s4">0</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                                <span class="s1">properties: {</span>
                                    <span class="s3">var</span><span class="s1">: {</span>
                                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                        <span class="s1">minimum: </span><span class="s4">0</span>
                                    <span class="s1">},</span>
                                    <span class="s1">let: {</span>
                                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                        <span class="s1">minimum: </span><span class="s4">0</span>
                                    <span class="s1">},</span>
                                    <span class="s1">const: {</span>
                                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                        <span class="s1">minimum: </span><span class="s4">0</span>
                                    <span class="s1">}</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                        <span class="s1">]</span>
                    <span class="s1">},</span>
                    <span class="s1">outerIIFEBody: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                        <span class="s1">minimum: </span><span class="s4">0</span>
                    <span class="s1">},</span>
                    <span class="s1">MemberExpression: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                        <span class="s1">minimum: </span><span class="s4">0</span>
                    <span class="s1">},</span>
                    <span class="s1">FunctionDeclaration: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                        <span class="s1">properties: {</span>
                            <span class="s1">parameters: {</span>
                                <span class="s1">oneOf: [</span>
                                    <span class="s1">{</span>
                                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                        <span class="s1">minimum: </span><span class="s4">0</span>
                                    <span class="s1">},</span>
                                    <span class="s1">{</span>
                                        <span class="s1">enum: [</span><span class="s2">&quot;first&quot;</span><span class="s1">]</span>
                                    <span class="s1">}</span>
                                <span class="s1">]</span>
                            <span class="s1">},</span>
                            <span class="s1">body: {</span>
                                <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                <span class="s1">minimum: </span><span class="s4">0</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">FunctionExpression: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                        <span class="s1">properties: {</span>
                            <span class="s1">parameters: {</span>
                                <span class="s1">oneOf: [</span>
                                    <span class="s1">{</span>
                                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                        <span class="s1">minimum: </span><span class="s4">0</span>
                                    <span class="s1">},</span>
                                    <span class="s1">{</span>
                                        <span class="s1">enum: [</span><span class="s2">&quot;first&quot;</span><span class="s1">]</span>
                                    <span class="s1">}</span>
                                <span class="s1">]</span>
                            <span class="s1">},</span>
                            <span class="s1">body: {</span>
                                <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                <span class="s1">minimum: </span><span class="s4">0</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">CallExpression: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                        <span class="s1">properties: {</span>
                            <span class="s1">parameters: {</span>
                                <span class="s1">oneOf: [</span>
                                    <span class="s1">{</span>
                                        <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                        <span class="s1">minimum: </span><span class="s4">0</span>
                                    <span class="s1">},</span>
                                    <span class="s1">{</span>
                                        <span class="s1">enum: [</span><span class="s2">&quot;first&quot;</span><span class="s1">]</span>
                                    <span class="s1">}</span>
                                <span class="s1">]</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">ArrayExpression: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">{</span>
                                <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                <span class="s1">minimum: </span><span class="s4">0</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">enum: [</span><span class="s2">&quot;first&quot;</span><span class="s1">]</span>
                            <span class="s1">}</span>
                        <span class="s1">]</span>
                    <span class="s1">},</span>
                    <span class="s1">ObjectExpression: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">{</span>
                                <span class="s1">type: </span><span class="s2">&quot;integer&quot;</span><span class="s1">,</span>
                                <span class="s1">minimum: </span><span class="s4">0</span>
                            <span class="s1">},</span>
                            <span class="s1">{</span>
                                <span class="s1">enum: [</span><span class="s2">&quot;first&quot;</span><span class="s1">]</span>
                            <span class="s1">}</span>
                        <span class="s1">]</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s3">false</span>
            <span class="s1">}</span>
        <span class="s1">],</span>
        <span class="s1">messages: {</span>
            <span class="s1">expected: </span><span class="s2">&quot;Expected indentation of {{expected}} but found {{actual}}.&quot;</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">create(context) {</span>
        <span class="s1">const DEFAULT_VARIABLE_INDENT = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">const DEFAULT_PARAMETER_INDENT = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// For backwards compatibility, don't check parameter indentation unless specified in the config</span>
        <span class="s1">const DEFAULT_FUNCTION_BODY_INDENT = </span><span class="s4">1</span><span class="s1">;</span>

        <span class="s1">let indentType = </span><span class="s2">&quot;space&quot;</span><span class="s1">;</span>
        <span class="s1">let indentSize = </span><span class="s4">4</span><span class="s1">;</span>
        <span class="s1">const options = {</span>
            <span class="s1">SwitchCase: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s1">VariableDeclarator: {</span>
                <span class="s3">var</span><span class="s1">: DEFAULT_VARIABLE_INDENT,</span>
                <span class="s1">let: DEFAULT_VARIABLE_INDENT,</span>
                <span class="s1">const: DEFAULT_VARIABLE_INDENT</span>
            <span class="s1">},</span>
            <span class="s1">outerIIFEBody: </span><span class="s3">null</span><span class="s1">,</span>
            <span class="s1">FunctionDeclaration: {</span>
                <span class="s1">parameters: DEFAULT_PARAMETER_INDENT,</span>
                <span class="s1">body: DEFAULT_FUNCTION_BODY_INDENT</span>
            <span class="s1">},</span>
            <span class="s1">FunctionExpression: {</span>
                <span class="s1">parameters: DEFAULT_PARAMETER_INDENT,</span>
                <span class="s1">body: DEFAULT_FUNCTION_BODY_INDENT</span>
            <span class="s1">},</span>
            <span class="s1">CallExpression: {</span>
                <span class="s1">arguments: DEFAULT_PARAMETER_INDENT</span>
            <span class="s1">},</span>
            <span class="s1">ArrayExpression: </span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">ObjectExpression: </span><span class="s4">1</span>
        <span class="s1">};</span>

        <span class="s1">const sourceCode = context.sourceCode;</span>

        <span class="s3">if </span><span class="s1">(context.options.length) {</span>
            <span class="s3">if </span><span class="s1">(context.options[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">&quot;tab&quot;</span><span class="s1">) {</span>
                <span class="s1">indentSize = </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">indentType = </span><span class="s2">&quot;tab&quot;</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s0">/* c8 ignore start */ </span><span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">context.options[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
                <span class="s1">indentSize = context.options[</span><span class="s4">0</span><span class="s1">];</span>
                <span class="s1">indentType = </span><span class="s2">&quot;space&quot;</span><span class="s1">;</span>
            <span class="s1">}</span><span class="s0">/* c8 ignore stop */</span>

            <span class="s3">if </span><span class="s1">(context.options[</span><span class="s4">1</span><span class="s1">]) {</span>
                <span class="s1">const opts = context.options[</span><span class="s4">1</span><span class="s1">];</span>

                <span class="s1">options.SwitchCase = opts.SwitchCase || </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">const variableDeclaratorRules = opts.VariableDeclarator;</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">variableDeclaratorRules === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
                    <span class="s1">options.VariableDeclarator = {</span>
                        <span class="s3">var</span><span class="s1">: variableDeclaratorRules,</span>
                        <span class="s1">let: variableDeclaratorRules,</span>
                        <span class="s1">const: variableDeclaratorRules</span>
                    <span class="s1">};</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">variableDeclaratorRules === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
                    <span class="s1">Object.assign(options.VariableDeclarator, variableDeclaratorRules);</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.outerIIFEBody === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
                    <span class="s1">options.outerIIFEBody = opts.outerIIFEBody;</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.MemberExpression === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
                    <span class="s1">options.MemberExpression = opts.MemberExpression;</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.FunctionDeclaration === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
                    <span class="s1">Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.FunctionExpression === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
                    <span class="s1">Object.assign(options.FunctionExpression, opts.FunctionExpression);</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.CallExpression === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
                    <span class="s1">Object.assign(options.CallExpression, opts.CallExpression);</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.ArrayExpression === </span><span class="s2">&quot;number&quot; </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">opts.ArrayExpression === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
                    <span class="s1">options.ArrayExpression = opts.ArrayExpression;</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">opts.ObjectExpression === </span><span class="s2">&quot;number&quot; </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">opts.ObjectExpression === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
                    <span class="s1">options.ObjectExpression = opts.ObjectExpression;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">const caseIndentStore = {};</span>

        <span class="s0">/** 
         * Creates an error message for a line, given the expected/actual indentation. 
         * @param {int} expectedAmount The expected amount of indentation characters for this line 
         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line 
         * @param {int} actualTabs The actual number of indentation tabs that were found on this line 
         * @returns {string} An error message for this line 
         */</span>
        <span class="s3">function </span><span class="s1">createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {</span>
            <span class="s1">const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">&quot;&quot; </span><span class="s1">: </span><span class="s2">&quot;s&quot;</span><span class="s1">}`; </span><span class="s0">// e.g. &quot;2 tabs&quot;</span>
            <span class="s1">const foundSpacesWord = `space${actualSpaces === </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">&quot;&quot; </span><span class="s1">: </span><span class="s2">&quot;s&quot;</span><span class="s1">}`; </span><span class="s0">// e.g. &quot;space&quot;</span>
            <span class="s1">const foundTabsWord = `tab${actualTabs === </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">&quot;&quot; </span><span class="s1">: </span><span class="s2">&quot;s&quot;</span><span class="s1">}`; </span><span class="s0">// e.g. &quot;tabs&quot;</span>
            <span class="s1">let foundStatement;</span>

            <span class="s3">if </span><span class="s1">(actualSpaces &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; actualTabs &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; </span><span class="s0">// e.g. &quot;1 space and 2 tabs&quot;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(actualSpaces &gt; </span><span class="s4">0</span><span class="s1">) {</span>

                <span class="s0">/* 
                 * Abbreviate the message if the expected indentation is also spaces. 
                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces' 
                 */</span>
                <span class="s1">foundStatement = indentType === </span><span class="s2">&quot;space&quot; </span><span class="s1">? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(actualTabs &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">foundStatement = indentType === </span><span class="s2">&quot;tab&quot; </span><span class="s1">? actualTabs : `${actualTabs} ${foundTabsWord}`;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">foundStatement = </span><span class="s2">&quot;0&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">{</span>
                <span class="s1">expected: expectedStatement,</span>
                <span class="s1">actual: foundStatement</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Reports a given indent violation 
         * @param {ASTNode} node Node violating the indent rule 
         * @param {int} needed Expected indentation character count 
         * @param {int} gottenSpaces Indentation space count in the actual node/code 
         * @param {int} gottenTabs Indentation tab count in the actual node/code 
         * @param {Object} [loc] Error line and column location 
         * @param {boolean} isLastNodeCheck Is the error for last node check 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {</span>
            <span class="s3">if </span><span class="s1">(gottenSpaces &amp;&amp; gottenTabs) {</span>

                <span class="s0">// To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">const desiredIndent = (indentType === </span><span class="s2">&quot;space&quot; </span><span class="s1">? </span><span class="s2">&quot; &quot; </span><span class="s1">: </span><span class="s2">&quot;</span><span class="s5">\t</span><span class="s2">&quot;</span><span class="s1">).repeat(needed);</span>

            <span class="s1">const textRange = isLastNodeCheck</span>
                <span class="s1">? [node.range[</span><span class="s4">1</span><span class="s1">] - node.loc.end.column, node.range[</span><span class="s4">1</span><span class="s1">] - node.loc.end.column + gottenSpaces + gottenTabs]</span>
                <span class="s1">: [node.range[</span><span class="s4">0</span><span class="s1">] - node.loc.start.column, node.range[</span><span class="s4">0</span><span class="s1">] - node.loc.start.column + gottenSpaces + gottenTabs];</span>

            <span class="s1">context.report({</span>
                <span class="s1">node,</span>
                <span class="s1">loc,</span>
                <span class="s1">messageId: </span><span class="s2">&quot;expected&quot;</span><span class="s1">,</span>
                <span class="s1">data: createErrorMessageData(needed, gottenSpaces, gottenTabs),</span>
                <span class="s1">fix: fixer =&gt; fixer.replaceTextRange(textRange, desiredIndent)</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Get the actual indent of node 
         * @param {ASTNode|Token} node Node to examine 
         * @param {boolean} [byLastLine=false] get indent of node's last line 
         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also 
         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and 
         * `badChar` is the amount of the other indentation character. 
         */</span>
        <span class="s3">function </span><span class="s1">getNodeIndent(node, byLastLine) {</span>
            <span class="s1">const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);</span>
            <span class="s1">const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(</span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
            <span class="s1">const indentChars = srcCharsBeforeNode.slice(</span><span class="s4">0</span><span class="s1">, srcCharsBeforeNode.findIndex(char =&gt; char !== </span><span class="s2">&quot; &quot; </span><span class="s1">&amp;&amp; char !== </span><span class="s2">&quot;</span><span class="s5">\t</span><span class="s2">&quot;</span><span class="s1">));</span>
            <span class="s1">const spaces = indentChars.filter(char =&gt; char === </span><span class="s2">&quot; &quot;</span><span class="s1">).length;</span>
            <span class="s1">const tabs = indentChars.filter(char =&gt; char === </span><span class="s2">&quot;</span><span class="s5">\t</span><span class="s2">&quot;</span><span class="s1">).length;</span>

            <span class="s3">return </span><span class="s1">{</span>
                <span class="s1">space: spaces,</span>
                <span class="s1">tab: tabs,</span>
                <span class="s1">goodChar: indentType === </span><span class="s2">&quot;space&quot; </span><span class="s1">? spaces : tabs,</span>
                <span class="s1">badChar: indentType === </span><span class="s2">&quot;space&quot; </span><span class="s1">? tabs : spaces</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Checks node is the first in its own start line. By default it looks by start line. 
         * @param {ASTNode} node The node to check 
         * @param {boolean} [byEndLocation=false] Lookup based on start position or end 
         * @returns {boolean} true if its the first in the its start line 
         */</span>
        <span class="s3">function </span><span class="s1">isNodeFirstInLine(node, byEndLocation) {</span>
            <span class="s1">const firstToken = byEndLocation === </span><span class="s3">true </span><span class="s1">? sourceCode.getLastToken(node, </span><span class="s4">1</span><span class="s1">) : sourceCode.getTokenBefore(node),</span>
                <span class="s1">startLine = byEndLocation === </span><span class="s3">true </span><span class="s1">? node.loc.end.line : node.loc.start.line,</span>
                <span class="s1">endLine = firstToken ? firstToken.loc.end.line : -</span><span class="s4">1</span><span class="s1">;</span>

            <span class="s3">return </span><span class="s1">startLine !== endLine;</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check indent for node 
         * @param {ASTNode} node Node to check 
         * @param {int} neededIndent needed indent 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">checkNodeIndent(node, neededIndent) {</span>
            <span class="s1">const actualIndent = getNodeIndent(node, </span><span class="s3">false</span><span class="s1">);</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">node.type !== </span><span class="s2">&quot;ArrayExpression&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">node.type !== </span><span class="s2">&quot;ObjectExpression&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">(actualIndent.goodChar !== neededIndent || actualIndent.badChar !== </span><span class="s4">0</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">isNodeFirstInLine(node)</span>
            <span class="s1">) {</span>
                <span class="s1">report(node, neededIndent, actualIndent.space, actualIndent.tab);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">&quot;IfStatement&quot; </span><span class="s1">&amp;&amp; node.alternate) {</span>
                <span class="s1">const elseToken = sourceCode.getTokenBefore(node.alternate);</span>

                <span class="s1">checkNodeIndent(elseToken, neededIndent);</span>

                <span class="s3">if </span><span class="s1">(!isNodeFirstInLine(node.alternate)) {</span>
                    <span class="s1">checkNodeIndent(node.alternate, neededIndent);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">&quot;TryStatement&quot; </span><span class="s1">&amp;&amp; node.handler) {</span>
                <span class="s1">const catchToken = sourceCode.getFirstToken(node.handler);</span>

                <span class="s1">checkNodeIndent(catchToken, neededIndent);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">&quot;TryStatement&quot; </span><span class="s1">&amp;&amp; node.finalizer) {</span>
                <span class="s1">const finallyToken = sourceCode.getTokenBefore(node.finalizer);</span>

                <span class="s1">checkNodeIndent(finallyToken, neededIndent);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">&quot;DoWhileStatement&quot;</span><span class="s1">) {</span>
                <span class="s1">const whileToken = sourceCode.getTokenAfter(node.body);</span>

                <span class="s1">checkNodeIndent(whileToken, neededIndent);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check indent for nodes list 
         * @param {ASTNode[]} nodes list of node objects 
         * @param {int} indent needed indent 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">checkNodesIndent(nodes, indent) {</span>
            <span class="s1">nodes.forEach(node =&gt; checkNodeIndent(node, indent));</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check last node line indent this detects, that block closed correctly 
         * @param {ASTNode} node Node to examine 
         * @param {int} lastLineIndent needed indent 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">checkLastNodeLineIndent(node, lastLineIndent) {</span>
            <span class="s1">const lastToken = sourceCode.getLastToken(node);</span>
            <span class="s1">const endIndent = getNodeIndent(lastToken, </span><span class="s3">true</span><span class="s1">);</span>

            <span class="s3">if </span><span class="s1">((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== </span><span class="s4">0</span><span class="s1">) &amp;&amp; isNodeFirstInLine(node, </span><span class="s3">true</span><span class="s1">)) {</span>
                <span class="s1">report(</span>
                    <span class="s1">node,</span>
                    <span class="s1">lastLineIndent,</span>
                    <span class="s1">endIndent.space,</span>
                    <span class="s1">endIndent.tab,</span>
                    <span class="s1">{ line: lastToken.loc.start.line, column: lastToken.loc.start.column },</span>
                    <span class="s3">true</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check last node line indent this detects, that block closed correctly 
         * This function for more complicated return statement case, where closing parenthesis may be followed by ';' 
         * @param {ASTNode} node Node to examine 
         * @param {int} firstLineIndent first line needed indent 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">checkLastReturnStatementLineIndent(node, firstLineIndent) {</span>

            <span class="s0">/* 
             * in case if return statement ends with ');' we have traverse back to ')' 
             * otherwise we'll measure indent for ';' and replace ')' 
             */</span>
            <span class="s1">const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);</span>
            <span class="s1">const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>

            <span class="s3">if </span><span class="s1">(textBeforeClosingParenthesis.trim()) {</span>

                <span class="s0">// There are tokens before the closing paren, don't report this case</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">const endIndent = getNodeIndent(lastToken, </span><span class="s3">true</span><span class="s1">);</span>

            <span class="s3">if </span><span class="s1">(endIndent.goodChar !== firstLineIndent) {</span>
                <span class="s1">report(</span>
                    <span class="s1">node,</span>
                    <span class="s1">firstLineIndent,</span>
                    <span class="s1">endIndent.space,</span>
                    <span class="s1">endIndent.tab,</span>
                    <span class="s1">{ line: lastToken.loc.start.line, column: lastToken.loc.start.column },</span>
                    <span class="s3">true</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check first node line indent is correct 
         * @param {ASTNode} node Node to examine 
         * @param {int} firstLineIndent needed indent 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">checkFirstNodeLineIndent(node, firstLineIndent) {</span>
            <span class="s1">const startIndent = getNodeIndent(node, </span><span class="s3">false</span><span class="s1">);</span>

            <span class="s3">if </span><span class="s1">((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== </span><span class="s4">0</span><span class="s1">) &amp;&amp; isNodeFirstInLine(node)) {</span>
                <span class="s1">report(</span>
                    <span class="s1">node,</span>
                    <span class="s1">firstLineIndent,</span>
                    <span class="s1">startIndent.space,</span>
                    <span class="s1">startIndent.tab,</span>
                    <span class="s1">{ line: node.loc.start.line, column: node.loc.start.column }</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Returns a parent node of given node based on a specified type 
         * if not present then return null 
         * @param {ASTNode} node node to examine 
         * @param {string} type type that is being looked for 
         * @param {string} stopAtList end points for the evaluating code 
         * @returns {ASTNode|void} if found then node otherwise null 
         */</span>
        <span class="s3">function </span><span class="s1">getParentNodeByType(node, type, stopAtList) {</span>
            <span class="s1">let parent = node.parent;</span>
            <span class="s1">const stopAtSet = </span><span class="s3">new </span><span class="s1">Set(stopAtList || [</span><span class="s2">&quot;Program&quot;</span><span class="s1">]);</span>

            <span class="s3">while </span><span class="s1">(parent.type !== type &amp;&amp; !stopAtSet.has(parent.type) &amp;&amp; parent.type !== </span><span class="s2">&quot;Program&quot;</span><span class="s1">) {</span>
                <span class="s1">parent = parent.parent;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">parent.type === type ? parent : </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Returns the VariableDeclarator based on the current node 
         * if not present then return null 
         * @param {ASTNode} node node to examine 
         * @returns {ASTNode|void} if found then node otherwise null 
         */</span>
        <span class="s3">function </span><span class="s1">getVariableDeclaratorNode(node) {</span>
            <span class="s3">return </span><span class="s1">getParentNodeByType(node, </span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check to see if the node is part of the multi-line variable declaration. 
         * Also if its on the same line as the varNode 
         * @param {ASTNode} node node to check 
         * @param {ASTNode} varNode variable declaration node to check against 
         * @returns {boolean} True if all the above condition satisfy 
         */</span>
        <span class="s3">function </span><span class="s1">isNodeInVarOnTop(node, varNode) {</span>
            <span class="s3">return </span><span class="s1">varNode &amp;&amp;</span>
                <span class="s1">varNode.parent.loc.start.line === node.loc.start.line &amp;&amp;</span>
                <span class="s1">varNode.parent.declarations.length &gt; </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check to see if the argument before the callee node is multi-line and 
         * there should only be 1 argument before the callee node 
         * @param {ASTNode} node node to check 
         * @returns {boolean} True if arguments are multi-line 
         */</span>
        <span class="s3">function </span><span class="s1">isArgBeforeCalleeNodeMultiline(node) {</span>
            <span class="s1">const parent = node.parent;</span>

            <span class="s3">if </span><span class="s1">(parent.arguments.length &gt;= </span><span class="s4">2 </span><span class="s1">&amp;&amp; parent.arguments[</span><span class="s4">1</span><span class="s1">] === node) {</span>
                <span class="s3">return </span><span class="s1">parent.arguments[</span><span class="s4">0</span><span class="s1">].loc.end.line &gt; parent.arguments[</span><span class="s4">0</span><span class="s1">].loc.start.line;</span>
            <span class="s1">}</span>

            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check to see if the node is a file level IIFE 
         * @param {ASTNode} node The function node to check. 
         * @returns {boolean} True if the node is the outer IIFE 
         */</span>
        <span class="s3">function </span><span class="s1">isOuterIIFE(node) {</span>
            <span class="s1">const parent = node.parent;</span>
            <span class="s1">let stmt = parent.parent;</span>

            <span class="s0">/* 
             * Verify that the node is an IIEF 
             */</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">parent.type !== </span><span class="s2">&quot;CallExpression&quot; </span><span class="s1">||</span>
                <span class="s1">parent.callee !== node) {</span>

                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * Navigate legal ancestors to determine whether this IIEF is outer 
             */</span>
            <span class="s3">while </span><span class="s1">(</span>
                <span class="s1">stmt.type === </span><span class="s2">&quot;UnaryExpression&quot; </span><span class="s1">&amp;&amp; (</span>
                    <span class="s1">stmt.operator === </span><span class="s2">&quot;!&quot; </span><span class="s1">||</span>
                    <span class="s1">stmt.operator === </span><span class="s2">&quot;~&quot; </span><span class="s1">||</span>
                    <span class="s1">stmt.operator === </span><span class="s2">&quot;+&quot; </span><span class="s1">||</span>
                    <span class="s1">stmt.operator === </span><span class="s2">&quot;-&quot;</span><span class="s1">) ||</span>
                <span class="s1">stmt.type === </span><span class="s2">&quot;AssignmentExpression&quot; </span><span class="s1">||</span>
                <span class="s1">stmt.type === </span><span class="s2">&quot;LogicalExpression&quot; </span><span class="s1">||</span>
                <span class="s1">stmt.type === </span><span class="s2">&quot;SequenceExpression&quot; </span><span class="s1">||</span>
                <span class="s1">stmt.type === </span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">) {</span>

                <span class="s1">stmt = stmt.parent;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">((</span>
                <span class="s1">stmt.type === </span><span class="s2">&quot;ExpressionStatement&quot; </span><span class="s1">||</span>
                <span class="s1">stmt.type === </span><span class="s2">&quot;VariableDeclaration&quot;</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">stmt.parent &amp;&amp; stmt.parent.type === </span><span class="s2">&quot;Program&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check indent for function block content 
         * @param {ASTNode} node A BlockStatement node that is inside of a function. 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">checkIndentInFunctionBlock(node) {</span>

            <span class="s0">/* 
             * Search first caller in chain. 
             * Ex.: 
             * 
             * Models &lt;- Identifier 
             *   .User 
             *   .find() 
             *   .exec(function() { 
             *   // function body 
             * }); 
             * 
             * Looks for 'Models' 
             */</span>
            <span class="s1">const calleeNode = node.parent; </span><span class="s0">// FunctionExpression</span>
            <span class="s1">let indent;</span>

            <span class="s3">if </span><span class="s1">(calleeNode.parent &amp;&amp;</span>
                <span class="s1">(calleeNode.parent.type === </span><span class="s2">&quot;Property&quot; </span><span class="s1">||</span>
                <span class="s1">calleeNode.parent.type === </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">)) {</span>

                <span class="s0">// If function is part of array or object, comma can be put at left</span>
                <span class="s1">indent = getNodeIndent(calleeNode, </span><span class="s3">false</span><span class="s1">).goodChar;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>

                <span class="s0">// If function is standalone, simple calculate indent</span>
                <span class="s1">indent = getNodeIndent(calleeNode).goodChar;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(calleeNode.parent.type === </span><span class="s2">&quot;CallExpression&quot;</span><span class="s1">) {</span>
                <span class="s1">const calleeParent = calleeNode.parent;</span>

                <span class="s3">if </span><span class="s1">(calleeNode.type !== </span><span class="s2">&quot;FunctionExpression&quot; </span><span class="s1">&amp;&amp; calleeNode.type !== </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(calleeParent &amp;&amp; calleeParent.loc.start.line &lt; node.loc.start.line) {</span>
                        <span class="s1">indent = getNodeIndent(calleeParent).goodChar;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">if </span><span class="s1">(isArgBeforeCalleeNodeMultiline(calleeNode) &amp;&amp;</span>
                        <span class="s1">calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &amp;&amp;</span>
                        <span class="s1">!isNodeFirstInLine(calleeNode)) {</span>
                        <span class="s1">indent = getNodeIndent(calleeParent).goodChar;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * function body indent should be indent + indent size, unless this 
             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled. 
             */</span>
            <span class="s1">let functionOffset = indentSize;</span>

            <span class="s3">if </span><span class="s1">(options.outerIIFEBody !== </span><span class="s3">null </span><span class="s1">&amp;&amp; isOuterIIFE(calleeNode)) {</span>
                <span class="s1">functionOffset = options.outerIIFEBody * indentSize;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(calleeNode.type === </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">) {</span>
                <span class="s1">functionOffset = options.FunctionExpression.body * indentSize;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(calleeNode.type === </span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s1">) {</span>
                <span class="s1">functionOffset = options.FunctionDeclaration.body * indentSize;</span>
            <span class="s1">}</span>
            <span class="s1">indent += functionOffset;</span>

            <span class="s0">// check if the node is inside a variable</span>
            <span class="s1">const parentVarNode = getVariableDeclaratorNode(node);</span>

            <span class="s3">if </span><span class="s1">(parentVarNode &amp;&amp; isNodeInVarOnTop(node, parentVarNode)) {</span>
                <span class="s1">indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(node.body.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">checkNodesIndent(node.body, indent);</span>
            <span class="s1">}</span>

            <span class="s1">checkLastNodeLineIndent(node, indent - functionOffset);</span>
        <span class="s1">}</span>


        <span class="s0">/** 
         * Checks if the given node starts and ends on the same line 
         * @param {ASTNode} node The node to check 
         * @returns {boolean} Whether or not the block starts and ends on the same line. 
         */</span>
        <span class="s3">function </span><span class="s1">isSingleLineNode(node) {</span>
            <span class="s1">const lastToken = sourceCode.getLastToken(node),</span>
                <span class="s1">startLine = node.loc.start.line,</span>
                <span class="s1">endLine = lastToken.loc.end.line;</span>

            <span class="s3">return </span><span class="s1">startLine === endLine;</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check indent for array block content or object block content 
         * @param {ASTNode} node node to examine 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">checkIndentInArrayOrObjectBlock(node) {</span>

            <span class="s0">// Skip inline</span>
            <span class="s3">if </span><span class="s1">(isSingleLineNode(node)) {</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">let elements = (node.type === </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">) ? node.elements : node.properties;</span>

            <span class="s0">// filter out empty elements example would be [ , 2] so remove first element as espree considers it as null</span>
            <span class="s1">elements = elements.filter(elem =&gt; elem !== </span><span class="s3">null</span><span class="s1">);</span>

            <span class="s1">let nodeIndent;</span>
            <span class="s1">let elementsIndent;</span>
            <span class="s1">const parentVarNode = getVariableDeclaratorNode(node);</span>

            <span class="s0">// TODO - come up with a better strategy in future</span>
            <span class="s3">if </span><span class="s1">(isNodeFirstInLine(node)) {</span>
                <span class="s1">const parent = node.parent;</span>

                <span class="s1">nodeIndent = getNodeIndent(parent).goodChar;</span>
                <span class="s3">if </span><span class="s1">(!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {</span>
                    <span class="s3">if </span><span class="s1">(parent.type !== </span><span class="s2">&quot;VariableDeclarator&quot; </span><span class="s1">|| parentVarNode === parentVarNode.parent.declarations[</span><span class="s4">0</span><span class="s1">]) {</span>
                        <span class="s3">if </span><span class="s1">(parent.type === </span><span class="s2">&quot;VariableDeclarator&quot; </span><span class="s1">&amp;&amp; parentVarNode.loc.start.line === parent.loc.start.line) {</span>
                            <span class="s1">nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);</span>
                        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent.type === </span><span class="s2">&quot;ObjectExpression&quot; </span><span class="s1">|| parent.type === </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s1">) {</span>
                            <span class="s1">const parentElements = node.parent.type === </span><span class="s2">&quot;ObjectExpression&quot; </span><span class="s1">? node.parent.properties : node.parent.elements;</span>

                            <span class="s3">if </span><span class="s1">(parentElements[</span><span class="s4">0</span><span class="s1">] &amp;&amp;</span>
                                    <span class="s1">parentElements[</span><span class="s4">0</span><span class="s1">].loc.start.line === parent.loc.start.line &amp;&amp;</span>
                                    <span class="s1">parentElements[</span><span class="s4">0</span><span class="s1">].loc.end.line !== parent.loc.start.line) {</span>

                                <span class="s0">/* 
                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest. 
                                 * e.g. [{ 
                                 *        foo: 1 
                                 *      }, 
                                 *      { 
                                 *        bar: 1 
                                 *      }] 
                                 * the second object is not indented. 
                                 */</span>
                            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options[parent.type] === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
                                <span class="s1">nodeIndent += options[parent.type] * indentSize;</span>
                            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                                <span class="s1">nodeIndent = parentElements[</span><span class="s4">0</span><span class="s1">].loc.start.column;</span>
                            <span class="s1">}</span>
                        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent.type === </span><span class="s2">&quot;CallExpression&quot; </span><span class="s1">|| parent.type === </span><span class="s2">&quot;NewExpression&quot;</span><span class="s1">) {</span>
                            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options.CallExpression.arguments === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
                                <span class="s1">nodeIndent += options.CallExpression.arguments * indentSize;</span>
                            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(options.CallExpression.arguments === </span><span class="s2">&quot;first&quot;</span><span class="s1">) {</span>
                                <span class="s3">if </span><span class="s1">(parent.arguments.includes(node)) {</span>
                                    <span class="s1">nodeIndent = parent.arguments[</span><span class="s4">0</span><span class="s1">].loc.start.column;</span>
                                <span class="s1">}</span>
                            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                                <span class="s1">nodeIndent += indentSize;</span>
                            <span class="s1">}</span>
                        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(parent.type === </span><span class="s2">&quot;LogicalExpression&quot; </span><span class="s1">|| parent.type === </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">) {</span>
                            <span class="s1">nodeIndent += indentSize;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s1">checkFirstNodeLineIndent(node, nodeIndent);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">nodeIndent = getNodeIndent(node).goodChar;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(options[node.type] === </span><span class="s2">&quot;first&quot;</span><span class="s1">) {</span>
                <span class="s1">elementsIndent = elements.length ? elements[</span><span class="s4">0</span><span class="s1">].loc.start.column : </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// If there are no elements, elementsIndent doesn't matter.</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">elementsIndent = nodeIndent + indentSize * options[node.type];</span>
            <span class="s1">}</span>

            <span class="s0">/* 
             * Check if the node is a multiple variable declaration; if so, then 
             * make sure indentation takes that into account. 
             */</span>
            <span class="s3">if </span><span class="s1">(isNodeInVarOnTop(node, parentVarNode)) {</span>
                <span class="s1">elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];</span>
            <span class="s1">}</span>

            <span class="s1">checkNodesIndent(elements, elementsIndent);</span>

            <span class="s3">if </span><span class="s1">(elements.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>

                <span class="s0">// Skip last block line check if last item in same line</span>
                <span class="s3">if </span><span class="s1">(elements[elements.length - </span><span class="s4">1</span><span class="s1">].loc.end.line === node.loc.end.line) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">checkLastNodeLineIndent(node, nodeIndent +</span>
                <span class="s1">(isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : </span><span class="s4">0</span><span class="s1">));</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check if the node or node body is a BlockStatement or not 
         * @param {ASTNode} node node to test 
         * @returns {boolean} True if it or its body is a block statement 
         */</span>
        <span class="s3">function </span><span class="s1">isNodeBodyBlock(node) {</span>
            <span class="s3">return </span><span class="s1">node.type === </span><span class="s2">&quot;BlockStatement&quot; </span><span class="s1">|| node.type === </span><span class="s2">&quot;ClassBody&quot; </span><span class="s1">|| (node.body &amp;&amp; node.body.type === </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s1">) ||</span>
                <span class="s1">(node.consequent &amp;&amp; node.consequent.type === </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check indentation for blocks 
         * @param {ASTNode} node node to check 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">blockIndentationCheck(node) {</span>

            <span class="s0">// Skip inline blocks</span>
            <span class="s3">if </span><span class="s1">(isSingleLineNode(node)) {</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(node.parent &amp;&amp; (</span>
                <span class="s1">node.parent.type === </span><span class="s2">&quot;FunctionExpression&quot; </span><span class="s1">||</span>
                <span class="s1">node.parent.type === </span><span class="s2">&quot;FunctionDeclaration&quot; </span><span class="s1">||</span>
                <span class="s1">node.parent.type === </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">)</span>
            <span class="s1">) {</span>
                <span class="s1">checkIndentInFunctionBlock(node);</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">let indent;</span>
            <span class="s1">let nodesToCheck = [];</span>

            <span class="s0">/* 
             * For this statements we should check indent from statement beginning, 
             * not from the beginning of the block. 
             */</span>
            <span class="s1">const statementsWithProperties = [</span>
                <span class="s2">&quot;IfStatement&quot;</span><span class="s1">, </span><span class="s2">&quot;WhileStatement&quot;</span><span class="s1">, </span><span class="s2">&quot;ForStatement&quot;</span><span class="s1">, </span><span class="s2">&quot;ForInStatement&quot;</span><span class="s1">, </span><span class="s2">&quot;ForOfStatement&quot;</span><span class="s1">, </span><span class="s2">&quot;DoWhileStatement&quot;</span><span class="s1">, </span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s1">, </span><span class="s2">&quot;TryStatement&quot;</span>
            <span class="s1">];</span>

            <span class="s3">if </span><span class="s1">(node.parent &amp;&amp; statementsWithProperties.includes(node.parent.type) &amp;&amp; isNodeBodyBlock(node)) {</span>
                <span class="s1">indent = getNodeIndent(node.parent).goodChar;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.parent &amp;&amp; node.parent.type === </span><span class="s2">&quot;CatchClause&quot;</span><span class="s1">) {</span>
                <span class="s1">indent = getNodeIndent(node.parent.parent).goodChar;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">indent = getNodeIndent(node).goodChar;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">&quot;IfStatement&quot; </span><span class="s1">&amp;&amp; node.consequent.type !== </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s1">) {</span>
                <span class="s1">nodesToCheck = [node.consequent];</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(Array.isArray(node.body)) {</span>
                <span class="s1">nodesToCheck = node.body;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">nodesToCheck = [node.body];</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(nodesToCheck.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">checkNodesIndent(nodesToCheck, indent + indentSize);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s1">) {</span>
                <span class="s1">checkLastNodeLineIndent(node, indent);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Filter out the elements which are on the same line of each other or the node. 
         * basically have only 1 elements from each line except the variable declaration line. 
         * @param {ASTNode} node Variable declaration node 
         * @returns {ASTNode[]} Filtered elements 
         */</span>
        <span class="s3">function </span><span class="s1">filterOutSameLineVars(node) {</span>
            <span class="s3">return </span><span class="s1">node.declarations.reduce((finalCollection, elem) =&gt; {</span>
                <span class="s1">const lastElem = finalCollection[finalCollection.length - </span><span class="s4">1</span><span class="s1">];</span>

                <span class="s3">if </span><span class="s1">((elem.loc.start.line !== node.loc.start.line &amp;&amp; !lastElem) ||</span>
                    <span class="s1">(lastElem &amp;&amp; lastElem.loc.start.line !== elem.loc.start.line)) {</span>
                    <span class="s1">finalCollection.push(elem);</span>
                <span class="s1">}</span>

                <span class="s3">return </span><span class="s1">finalCollection;</span>
            <span class="s1">}, []);</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check indentation for variable declarations 
         * @param {ASTNode} node node to examine 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">checkIndentInVariableDeclarations(node) {</span>
            <span class="s1">const elements = filterOutSameLineVars(node);</span>
            <span class="s1">const nodeIndent = getNodeIndent(node).goodChar;</span>
            <span class="s1">const lastElement = elements[elements.length - </span><span class="s4">1</span><span class="s1">];</span>

            <span class="s1">const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];</span>

            <span class="s1">checkNodesIndent(elements, elementsIndent);</span>

            <span class="s0">// Only check the last line if there is any token after the last item</span>
            <span class="s3">if </span><span class="s1">(sourceCode.getLastToken(node).loc.end.line &lt;= lastElement.loc.end.line) {</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);</span>

            <span class="s3">if </span><span class="s1">(tokenBeforeLastElement.value === </span><span class="s2">&quot;,&quot;</span><span class="s1">) {</span>

                <span class="s0">// Special case for comma-first syntax where the semicolon is indented</span>
                <span class="s1">checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">checkLastNodeLineIndent(node, elementsIndent - indentSize);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check and decide whether to check for indentation for blockless nodes 
         * Scenarios are for or while statements without braces around them 
         * @param {ASTNode} node node to examine 
         * @returns {void} 
         */</span>
        <span class="s3">function </span><span class="s1">blockLessNodes(node) {</span>
            <span class="s3">if </span><span class="s1">(node.body.type !== </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s1">) {</span>
                <span class="s1">blockIndentationCheck(node);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Returns the expected indentation for the case statement 
         * @param {ASTNode} node node to examine 
         * @param {int} [providedSwitchIndent] indent for switch statement 
         * @returns {int} indent size 
         */</span>
        <span class="s3">function </span><span class="s1">expectedCaseIndent(node, providedSwitchIndent) {</span>
            <span class="s1">const switchNode = (node.type === </span><span class="s2">&quot;SwitchStatement&quot;</span><span class="s1">) ? node : node.parent;</span>
            <span class="s1">const switchIndent = </span><span class="s3">typeof </span><span class="s1">providedSwitchIndent === </span><span class="s2">&quot;undefined&quot;</span>
                <span class="s1">? getNodeIndent(switchNode).goodChar</span>
                <span class="s1">: providedSwitchIndent;</span>
            <span class="s1">let caseIndent;</span>

            <span class="s3">if </span><span class="s1">(caseIndentStore[switchNode.loc.start.line]) {</span>
                <span class="s3">return </span><span class="s1">caseIndentStore[switchNode.loc.start.line];</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(switchNode.cases.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; options.SwitchCase === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">caseIndent = switchIndent;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">caseIndent = switchIndent + (indentSize * options.SwitchCase);</span>
            <span class="s1">}</span>

            <span class="s1">caseIndentStore[switchNode.loc.start.line] = caseIndent;</span>
            <span class="s3">return </span><span class="s1">caseIndent;</span>

        <span class="s1">}</span>

        <span class="s0">/** 
         * Checks whether a return statement is wrapped in () 
         * @param {ASTNode} node node to examine 
         * @returns {boolean} the result 
         */</span>
        <span class="s3">function </span><span class="s1">isWrappedInParenthesis(node) {</span>
            <span class="s1">const regex = /^</span><span class="s3">return</span><span class="s1">\s*?\(\s*?\);*?/u;</span>

            <span class="s1">const statementWithoutArgument = sourceCode.getText(node).replace(</span>
                <span class="s1">sourceCode.getText(node.argument), </span><span class="s2">&quot;&quot;</span>
            <span class="s1">);</span>

            <span class="s3">return </span><span class="s1">regex.test(statementWithoutArgument);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">Program(node) {</span>
                <span class="s3">if </span><span class="s1">(node.body.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>

                    <span class="s0">// Root nodes should have no indent</span>
                    <span class="s1">checkNodesIndent(node.body, getNodeIndent(node).goodChar);</span>
                <span class="s1">}</span>
            <span class="s1">},</span>

            <span class="s1">ClassBody: blockIndentationCheck,</span>

            <span class="s1">BlockStatement: blockIndentationCheck,</span>

            <span class="s1">WhileStatement: blockLessNodes,</span>

            <span class="s1">ForStatement: blockLessNodes,</span>

            <span class="s1">ForInStatement: blockLessNodes,</span>

            <span class="s1">ForOfStatement: blockLessNodes,</span>

            <span class="s1">DoWhileStatement: blockLessNodes,</span>

            <span class="s1">IfStatement(node) {</span>
                <span class="s3">if </span><span class="s1">(node.consequent.type !== </span><span class="s2">&quot;BlockStatement&quot; </span><span class="s1">&amp;&amp; node.consequent.loc.start.line &gt; node.loc.start.line) {</span>
                    <span class="s1">blockIndentationCheck(node);</span>
                <span class="s1">}</span>
            <span class="s1">},</span>

            <span class="s1">VariableDeclaration(node) {</span>
                <span class="s3">if </span><span class="s1">(node.declarations[node.declarations.length - </span><span class="s4">1</span><span class="s1">].loc.start.line &gt; node.declarations[</span><span class="s4">0</span><span class="s1">].loc.start.line) {</span>
                    <span class="s1">checkIndentInVariableDeclarations(node);</span>
                <span class="s1">}</span>
            <span class="s1">},</span>

            <span class="s1">ObjectExpression(node) {</span>
                <span class="s1">checkIndentInArrayOrObjectBlock(node);</span>
            <span class="s1">},</span>

            <span class="s1">ArrayExpression(node) {</span>
                <span class="s1">checkIndentInArrayOrObjectBlock(node);</span>
            <span class="s1">},</span>

            <span class="s1">MemberExpression(node) {</span>

                <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options.MemberExpression === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(isSingleLineNode(node)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s0">/* 
                 * The typical layout of variable declarations and assignments 
                 * alter the expectation of correct indentation. Skip them. 
                 * TODO: Add appropriate configuration options for variable 
                 * declarations and assignments. 
                 */</span>
                <span class="s3">if </span><span class="s1">(getParentNodeByType(node, </span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s1">, [</span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">, </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s1">])) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(getParentNodeByType(node, </span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">, [</span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s1">])) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;</span>

                <span class="s1">const checkNodes = [node.property];</span>

                <span class="s1">const dot = sourceCode.getTokenBefore(node.property);</span>

                <span class="s3">if </span><span class="s1">(dot.type === </span><span class="s2">&quot;Punctuator&quot; </span><span class="s1">&amp;&amp; dot.value === </span><span class="s2">&quot;.&quot;</span><span class="s1">) {</span>
                    <span class="s1">checkNodes.push(dot);</span>
                <span class="s1">}</span>

                <span class="s1">checkNodesIndent(checkNodes, propertyIndent);</span>
            <span class="s1">},</span>

            <span class="s1">SwitchStatement(node) {</span>

                <span class="s0">// Switch is not a 'BlockStatement'</span>
                <span class="s1">const switchIndent = getNodeIndent(node).goodChar;</span>
                <span class="s1">const caseIndent = expectedCaseIndent(node, switchIndent);</span>

                <span class="s1">checkNodesIndent(node.cases, caseIndent);</span>


                <span class="s1">checkLastNodeLineIndent(node, switchIndent);</span>
            <span class="s1">},</span>

            <span class="s1">SwitchCase(node) {</span>

                <span class="s0">// Skip inline cases</span>
                <span class="s3">if </span><span class="s1">(isSingleLineNode(node)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">const caseIndent = expectedCaseIndent(node);</span>

                <span class="s1">checkNodesIndent(node.consequent, caseIndent + indentSize);</span>
            <span class="s1">},</span>

            <span class="s1">FunctionDeclaration(node) {</span>
                <span class="s3">if </span><span class="s1">(isSingleLineNode(node)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(options.FunctionDeclaration.parameters === </span><span class="s2">&quot;first&quot; </span><span class="s1">&amp;&amp; node.params.length) {</span>
                    <span class="s1">checkNodesIndent(node.params.slice(</span><span class="s4">1</span><span class="s1">), node.params[</span><span class="s4">0</span><span class="s1">].loc.start.column);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(options.FunctionDeclaration.parameters !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);</span>
                <span class="s1">}</span>
            <span class="s1">},</span>

            <span class="s1">FunctionExpression(node) {</span>
                <span class="s3">if </span><span class="s1">(isSingleLineNode(node)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(options.FunctionExpression.parameters === </span><span class="s2">&quot;first&quot; </span><span class="s1">&amp;&amp; node.params.length) {</span>
                    <span class="s1">checkNodesIndent(node.params.slice(</span><span class="s4">1</span><span class="s1">), node.params[</span><span class="s4">0</span><span class="s1">].loc.start.column);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(options.FunctionExpression.parameters !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);</span>
                <span class="s1">}</span>
            <span class="s1">},</span>

            <span class="s1">ReturnStatement(node) {</span>
                <span class="s3">if </span><span class="s1">(isSingleLineNode(node)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">const firstLineIndent = getNodeIndent(node).goodChar;</span>

                <span class="s0">// in case if return statement is wrapped in parenthesis</span>
                <span class="s3">if </span><span class="s1">(isWrappedInParenthesis(node)) {</span>
                    <span class="s1">checkLastReturnStatementLineIndent(node, firstLineIndent);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">checkNodeIndent(node, firstLineIndent);</span>
                <span class="s1">}</span>
            <span class="s1">},</span>

            <span class="s1">CallExpression(node) {</span>
                <span class="s3">if </span><span class="s1">(isSingleLineNode(node)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(options.CallExpression.arguments === </span><span class="s2">&quot;first&quot; </span><span class="s1">&amp;&amp; node.arguments.length) {</span>
                    <span class="s1">checkNodesIndent(node.arguments.slice(</span><span class="s4">1</span><span class="s1">), node.arguments[</span><span class="s4">0</span><span class="s1">].loc.start.column);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(options.CallExpression.arguments !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

        <span class="s1">};</span>

    <span class="s1">}</span>
<span class="s1">};</span>
</pre>
</body>
</html>
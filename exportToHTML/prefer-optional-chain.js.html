<html>
<head>
<title>prefer-optional-chain.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prefer-optional-chain.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">const tsutils_1 = require(</span><span class="s0">&quot;tsutils&quot;</span><span class="s1">);</span>
<span class="s1">const ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s1">const util = __importStar(require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">));</span>
<span class="s3">/* 
The AST is always constructed such the first element is always the deepest element. 
I.e. for this code: `foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz &amp;&amp; foo.bar.baz.buzz` 
The AST will look like this: 
{ 
  left: { 
    left: { 
      left: foo 
      right: foo.bar 
    } 
    right: foo.bar.baz 
  } 
  right: foo.bar.baz.buzz 
} 
*/</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= util.createRule({</span>
    <span class="s1">name: </span><span class="s0">'prefer-optional-chain'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Enforce using concise optional chain expressions instead of chained logical ands, negated logical ors, or empty objects'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s0">'strict'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">hasSuggestions: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">preferOptionalChain: </span><span class="s0">&quot;Prefer using an optional chain expression instead, as it's more concise and easier to read.&quot;</span><span class="s1">,</span>
            <span class="s1">optionalChainSuggest: </span><span class="s0">'Change to an optional chain.'</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [],</span>
    <span class="s1">create(context) {</span>
        <span class="s1">const sourceCode = context.getSourceCode();</span>
        <span class="s1">const parserServices = util.getParserServices(context, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s0">'LogicalExpression[operator=&quot;||&quot;], LogicalExpression[operator=&quot;??&quot;]'</span><span class="s1">(node) {</span>
                <span class="s1">const leftNode = node.left;</span>
                <span class="s1">const rightNode = node.right;</span>
                <span class="s1">const parentNode = node.parent;</span>
                <span class="s1">const isRightNodeAnEmptyObjectLiteral = rightNode.type === utils_1.AST_NODE_TYPES.ObjectExpression &amp;&amp;</span>
                    <span class="s1">rightNode.properties.length === </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(!isRightNodeAnEmptyObjectLiteral ||</span>
                    <span class="s1">!parentNode ||</span>
                    <span class="s1">parentNode.type !== utils_1.AST_NODE_TYPES.MemberExpression ||</span>
                    <span class="s1">parentNode.optional) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">function </span><span class="s1">isLeftSideLowerPrecedence() {</span>
                    <span class="s1">const logicalTsNode = parserServices.esTreeNodeToTSNodeMap.get(node);</span>
                    <span class="s1">const leftTsNode = parserServices.esTreeNodeToTSNodeMap.get(leftNode);</span>
                    <span class="s1">const operator = (</span><span class="s4">0</span><span class="s1">, tsutils_1.isBinaryExpression)(logicalTsNode)</span>
                        <span class="s1">? logicalTsNode.operatorToken.kind</span>
                        <span class="s1">: ts.SyntaxKind.Unknown;</span>
                    <span class="s1">const leftPrecedence = util.getOperatorPrecedence(leftTsNode.kind, operator);</span>
                    <span class="s2">return </span><span class="s1">leftPrecedence &lt; util.OperatorPrecedence.LeftHandSide;</span>
                <span class="s1">}</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: </span><span class="s0">'optionalChainSuggest'</span><span class="s1">,</span>
                    <span class="s1">suggest: [</span>
                        <span class="s1">{</span>
                            <span class="s1">messageId: </span><span class="s0">'optionalChainSuggest'</span><span class="s1">,</span>
                            <span class="s1">fix: (fixer) =&gt; {</span>
                                <span class="s1">const leftNodeText = sourceCode.getText(leftNode);</span>
                                <span class="s3">// Any node that is made of an operator with higher or equal precedence,</span>
                                <span class="s1">const maybeWrappedLeftNode = isLeftSideLowerPrecedence()</span>
                                    <span class="s1">? `(${leftNodeText})`</span>
                                    <span class="s1">: leftNodeText;</span>
                                <span class="s1">const propertyToBeOptionalText = sourceCode.getText(parentNode.property);</span>
                                <span class="s1">const maybeWrappedProperty = parentNode.computed</span>
                                    <span class="s1">? `[${propertyToBeOptionalText}]`</span>
                                    <span class="s1">: propertyToBeOptionalText;</span>
                                <span class="s2">return </span><span class="s1">fixer.replaceTextRange(parentNode.range, `${maybeWrappedLeftNode}?.${maybeWrappedProperty}`);</span>
                            <span class="s1">},</span>
                        <span class="s1">},</span>
                    <span class="s1">],</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s1">[[</span>
                <span class="s0">'LogicalExpression[operator=&quot;||&quot;] &gt; UnaryExpression[operator=&quot;!&quot;] &gt; Identifier'</span><span class="s1">,</span>
                <span class="s0">'LogicalExpression[operator=&quot;||&quot;] &gt; UnaryExpression[operator=&quot;!&quot;] &gt; MemberExpression'</span><span class="s1">,</span>
                <span class="s0">'LogicalExpression[operator=&quot;||&quot;] &gt; UnaryExpression[operator=&quot;!&quot;] &gt; ChainExpression &gt; MemberExpression'</span><span class="s1">,</span>
                <span class="s0">'LogicalExpression[operator=&quot;||&quot;] &gt; UnaryExpression[operator=&quot;!&quot;] &gt; MetaProperty'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">','</span><span class="s1">)](initialIdentifierOrNotEqualsExpr) {</span>
                <span class="s3">// selector guarantees this cast</span>
                <span class="s1">const initialExpression = (initialIdentifierOrNotEqualsExpr.parent.type ===</span>
                    <span class="s1">utils_1.AST_NODE_TYPES.ChainExpression</span>
                    <span class="s1">? initialIdentifierOrNotEqualsExpr.parent.parent</span>
                    <span class="s1">: initialIdentifierOrNotEqualsExpr.parent).parent;</span>
                <span class="s2">if </span><span class="s1">(initialExpression.left.type !== utils_1.AST_NODE_TYPES.UnaryExpression ||</span>
                    <span class="s1">initialExpression.left.argument !== initialIdentifierOrNotEqualsExpr) {</span>
                    <span class="s3">// the node(identifier or member expression) is not the deepest left node</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">// walk up the tree to figure out how many logical expressions we can include</span>
                <span class="s1">let previous = initialExpression;</span>
                <span class="s1">let current = initialExpression;</span>
                <span class="s1">let previousLeftText = getText(initialIdentifierOrNotEqualsExpr);</span>
                <span class="s1">let optionallyChainedCode = previousLeftText;</span>
                <span class="s1">let expressionCount = </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s2">while </span><span class="s1">(current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {</span>
                    <span class="s2">if </span><span class="s1">(current.right.type !== utils_1.AST_NODE_TYPES.UnaryExpression ||</span>
                        <span class="s1">!isValidChainTarget(current.right.argument, </span>
                        <span class="s3">// only allow unary '!' with identifiers for the first chain - !foo || !foo()</span>
                        <span class="s1">expressionCount === </span><span class="s4">1</span><span class="s1">)) {</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">const { rightText, shouldBreak } = breakIfInvalid({</span>
                        <span class="s1">rightNode: current.right.argument,</span>
                        <span class="s1">previousLeftText,</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(shouldBreak) {</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">let invalidOptionallyChainedPrivateProperty;</span>
                    <span class="s1">({</span>
                        <span class="s1">invalidOptionallyChainedPrivateProperty,</span>
                        <span class="s1">expressionCount,</span>
                        <span class="s1">previousLeftText,</span>
                        <span class="s1">optionallyChainedCode,</span>
                        <span class="s1">previous,</span>
                        <span class="s1">current,</span>
                    <span class="s1">} = normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current));</span>
                    <span class="s2">if </span><span class="s1">(invalidOptionallyChainedPrivateProperty) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">reportIfMoreThanOne({</span>
                    <span class="s1">expressionCount,</span>
                    <span class="s1">previous,</span>
                    <span class="s1">optionallyChainedCode,</span>
                    <span class="s1">sourceCode,</span>
                    <span class="s1">context,</span>
                    <span class="s1">shouldHandleChainedAnds: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s1">[[</span>
                <span class="s0">'LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; Identifier'</span><span class="s1">,</span>
                <span class="s0">'LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; MemberExpression'</span><span class="s1">,</span>
                <span class="s0">'LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; ChainExpression &gt; MemberExpression'</span><span class="s1">,</span>
                <span class="s0">'LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; MetaProperty'</span><span class="s1">,</span>
                <span class="s0">'LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; BinaryExpression[operator=&quot;!==&quot;]'</span><span class="s1">,</span>
                <span class="s0">'LogicalExpression[operator=&quot;&amp;&amp;&quot;] &gt; BinaryExpression[operator=&quot;!=&quot;]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">','</span><span class="s1">)](initialIdentifierOrNotEqualsExpr) {</span>
                <span class="s2">var </span><span class="s1">_a;</span>
                <span class="s3">// selector guarantees this cast</span>
                <span class="s1">const initialExpression = (((_a = initialIdentifierOrNotEqualsExpr.parent) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _a.type) ===</span>
                    <span class="s1">utils_1.AST_NODE_TYPES.ChainExpression</span>
                    <span class="s1">? initialIdentifierOrNotEqualsExpr.parent.parent</span>
                    <span class="s1">: initialIdentifierOrNotEqualsExpr.parent);</span>
                <span class="s2">if </span><span class="s1">(initialExpression.left !== initialIdentifierOrNotEqualsExpr) {</span>
                    <span class="s3">// the node(identifier or member expression) is not the deepest left node</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!isValidChainTarget(initialIdentifierOrNotEqualsExpr, </span><span class="s2">true</span><span class="s1">)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">// walk up the tree to figure out how many logical expressions we can include</span>
                <span class="s1">let previous = initialExpression;</span>
                <span class="s1">let current = initialExpression;</span>
                <span class="s1">let previousLeftText = getText(initialIdentifierOrNotEqualsExpr);</span>
                <span class="s1">let optionallyChainedCode = previousLeftText;</span>
                <span class="s1">let expressionCount = </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s2">while </span><span class="s1">(current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {</span>
                    <span class="s2">if </span><span class="s1">(!isValidChainTarget(current.right, </span>
                    <span class="s3">// only allow identifiers for the first chain - foo &amp;&amp; foo()</span>
                    <span class="s1">expressionCount === </span><span class="s4">1</span><span class="s1">)) {</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">const { rightText, shouldBreak } = breakIfInvalid({</span>
                        <span class="s1">rightNode: current.right,</span>
                        <span class="s1">previousLeftText,</span>
                    <span class="s1">});</span>
                    <span class="s2">if </span><span class="s1">(shouldBreak) {</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">let invalidOptionallyChainedPrivateProperty;</span>
                    <span class="s1">({</span>
                        <span class="s1">invalidOptionallyChainedPrivateProperty,</span>
                        <span class="s1">expressionCount,</span>
                        <span class="s1">previousLeftText,</span>
                        <span class="s1">optionallyChainedCode,</span>
                        <span class="s1">previous,</span>
                        <span class="s1">current,</span>
                    <span class="s1">} = normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current));</span>
                    <span class="s2">if </span><span class="s1">(invalidOptionallyChainedPrivateProperty) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">reportIfMoreThanOne({</span>
                    <span class="s1">expressionCount,</span>
                    <span class="s1">previous,</span>
                    <span class="s1">optionallyChainedCode,</span>
                    <span class="s1">sourceCode,</span>
                    <span class="s1">context,</span>
                    <span class="s1">shouldHandleChainedAnds: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
        <span class="s2">function </span><span class="s1">breakIfInvalid({ previousLeftText, rightNode, }) {</span>
            <span class="s1">let shouldBreak = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">const rightText = getText(rightNode);</span>
            <span class="s3">// can't just use startsWith because of cases like foo &amp;&amp; fooBar.baz;</span>
            <span class="s1">const matchRegex = </span><span class="s2">new </span><span class="s1">RegExp(`^${</span>
            <span class="s3">// escape regex characters</span>
            <span class="s1">previousLeftText.replace(/[.*+?^${}()|[\]\\]/g, </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">$&amp;'</span><span class="s1">)}[^a-zA-Z0-9_$]`);</span>
            <span class="s2">if </span><span class="s1">(!matchRegex.test(rightText) &amp;&amp;</span>
                <span class="s3">// handle redundant cases like foo.bar &amp;&amp; foo.bar</span>
                <span class="s1">previousLeftText !== rightText) {</span>
                <span class="s1">shouldBreak = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{ shouldBreak, leftText: previousLeftText, rightText };</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">getText(node) {</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.BinaryExpression) {</span>
                <span class="s2">return </span><span class="s1">getText(</span>
                <span class="s3">// isValidChainTarget ensures this is type safe</span>
                <span class="s1">node.left);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.CallExpression) {</span>
                <span class="s1">const calleeText = getText(</span>
                <span class="s3">// isValidChainTarget ensures this is type safe</span>
                <span class="s1">node.callee);</span>
                <span class="s3">// ensure that the call arguments are left untouched, or else we can break cases that _need_ whitespace:</span>
                <span class="s3">// - JSX: &lt;Foo Needs Space Between Attrs /&gt;</span>
                <span class="s3">// - Unary Operators: typeof foo, await bar, delete baz</span>
                <span class="s1">const closingParenToken = util.nullThrows(sourceCode.getLastToken(node), util.NullThrowsReasons.MissingToken(</span><span class="s0">'closing parenthesis'</span><span class="s1">, node.type));</span>
                <span class="s1">const openingParenToken = util.nullThrows(sourceCode.getFirstTokenBetween(node.callee, closingParenToken, util.isOpeningParenToken), util.NullThrowsReasons.MissingToken(</span><span class="s0">'opening parenthesis'</span><span class="s1">, node.type));</span>
                <span class="s1">const argumentsText = sourceCode.text.substring(openingParenToken.range[</span><span class="s4">0</span><span class="s1">], closingParenToken.range[</span><span class="s4">1</span><span class="s1">]);</span>
                <span class="s2">return </span><span class="s1">`${calleeText}${argumentsText}`;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.Identifier ||</span>
                <span class="s1">node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {</span>
                <span class="s2">return </span><span class="s1">node.name;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.MetaProperty) {</span>
                <span class="s2">return </span><span class="s1">`${node.meta.name}.${node.property.name}`;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.ThisExpression) {</span>
                <span class="s2">return </span><span class="s0">'this'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.ChainExpression) {</span>
                <span class="s3">/* istanbul ignore if */ </span><span class="s2">if </span><span class="s1">(node.expression.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {</span>
                    <span class="s3">// this shouldn't happen</span>
                    <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">getText(node.expression);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.object.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {</span>
                <span class="s3">// Not supported mixing with TSNonNullExpression</span>
                <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">getMemberExpressionText(node);</span>
        <span class="s1">}</span>
        <span class="s3">/** 
         * Gets a normalized representation of the given MemberExpression 
         */</span>
        <span class="s2">function </span><span class="s1">getMemberExpressionText(node) {</span>
            <span class="s1">let objectText;</span>
            <span class="s3">// cases should match the list in ALLOWED_MEMBER_OBJECT_TYPES</span>
            <span class="s2">switch </span><span class="s1">(node.object.type) {</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MemberExpression:</span>
                    <span class="s1">objectText = getMemberExpressionText(node.object);</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.CallExpression:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MetaProperty:</span>
                <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.ThisExpression:</span>
                    <span class="s1">objectText = getText(node.object);</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s3">/* istanbul ignore next */</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">let propertyText;</span>
            <span class="s2">if </span><span class="s1">(node.computed) {</span>
                <span class="s3">// cases should match the list in ALLOWED_COMPUTED_PROP_TYPES</span>
                <span class="s2">switch </span><span class="s1">(node.property.type) {</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                        <span class="s1">propertyText = getText(node.property);</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Literal:</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TemplateLiteral:</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.BinaryExpression:</span>
                        <span class="s1">propertyText = sourceCode.getText(node.property);</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MemberExpression:</span>
                        <span class="s1">propertyText = getMemberExpressionText(node.property);</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s3">/* istanbul ignore next */</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">`${objectText}${node.optional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}[${propertyText}]`;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s3">// cases should match the list in ALLOWED_NON_COMPUTED_PROP_TYPES</span>
                <span class="s2">switch </span><span class="s1">(node.property.type) {</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                        <span class="s1">propertyText = getText(node.property);</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.PrivateIdentifier:</span>
                        <span class="s1">propertyText = </span><span class="s0">'#' </span><span class="s1">+ getText(node.property);</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">propertyText = sourceCode.getText(node.property);</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">`${objectText}${node.optional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${propertyText}`;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s1">const ALLOWED_MEMBER_OBJECT_TYPES = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s1">utils_1.AST_NODE_TYPES.CallExpression,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.Identifier,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.MemberExpression,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.ThisExpression,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.MetaProperty,</span>
<span class="s1">]);</span>
<span class="s1">const ALLOWED_COMPUTED_PROP_TYPES = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s1">utils_1.AST_NODE_TYPES.Identifier,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.Literal,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.MemberExpression,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.TemplateLiteral,</span>
<span class="s1">]);</span>
<span class="s1">const ALLOWED_NON_COMPUTED_PROP_TYPES = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s1">utils_1.AST_NODE_TYPES.Identifier,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.PrivateIdentifier,</span>
<span class="s1">]);</span>
<span class="s2">function </span><span class="s1">reportIfMoreThanOne({ expressionCount, previous, optionallyChainedCode, sourceCode, context, shouldHandleChainedAnds, }) {</span>
    <span class="s2">if </span><span class="s1">(expressionCount &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(shouldHandleChainedAnds &amp;&amp;</span>
            <span class="s1">previous.right.type === utils_1.AST_NODE_TYPES.BinaryExpression) {</span>
            <span class="s1">let operator = previous.right.operator;</span>
            <span class="s2">if </span><span class="s1">(previous.right.operator === </span><span class="s0">'!==' </span><span class="s1">&amp;&amp;</span>
                <span class="s3">// TODO(#4820): Use the type checker to know whether this is `null`</span>
                <span class="s1">previous.right.right.type === utils_1.AST_NODE_TYPES.Literal &amp;&amp;</span>
                <span class="s1">previous.right.right.raw === </span><span class="s0">'null'</span><span class="s1">) {</span>
                <span class="s3">// case like foo !== null &amp;&amp; foo.bar !== null</span>
                <span class="s1">operator = </span><span class="s0">'!='</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// case like foo &amp;&amp; foo.bar !== someValue</span>
            <span class="s1">optionallyChainedCode += ` ${operator} ${sourceCode.getText(previous.right.right)}`;</span>
        <span class="s1">}</span>
        <span class="s1">context.report({</span>
            <span class="s1">node: previous,</span>
            <span class="s1">messageId: </span><span class="s0">'preferOptionalChain'</span><span class="s1">,</span>
            <span class="s1">suggest: [</span>
                <span class="s1">{</span>
                    <span class="s1">messageId: </span><span class="s0">'optionalChainSuggest'</span><span class="s1">,</span>
                    <span class="s1">fix: (fixer) =&gt; [</span>
                        <span class="s1">fixer.replaceText(previous, `${shouldHandleChainedAnds ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'!'</span><span class="s1">}${optionallyChainedCode}`),</span>
                    <span class="s1">],</span>
                <span class="s1">},</span>
            <span class="s1">],</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeRepeatingPatterns(rightText, expressionCount, previousLeftText, optionallyChainedCode, previous, current) {</span>
    <span class="s1">const leftText = previousLeftText;</span>
    <span class="s1">let invalidOptionallyChainedPrivateProperty = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s3">// omit weird doubled up expression that make no sense like foo.bar &amp;&amp; foo.bar</span>
    <span class="s2">if </span><span class="s1">(rightText !== previousLeftText) {</span>
        <span class="s1">expressionCount += </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">previousLeftText = rightText;</span>
        <span class="s3">/* 
        Diff the left and right text to construct the fix string 
        There are the following cases: 
     
        1) 
        rightText === 'foo.bar.baz.buzz' 
        leftText === 'foo.bar.baz' 
        diff === '.buzz' 
     
        2) 
        rightText === 'foo.bar.baz.buzz()' 
        leftText === 'foo.bar.baz' 
        diff === '.buzz()' 
     
        3) 
        rightText === 'foo.bar.baz.buzz()' 
        leftText === 'foo.bar.baz.buzz' 
        diff === '()' 
     
        4) 
        rightText === 'foo.bar.baz[buzz]' 
        leftText === 'foo.bar.baz' 
        diff === '[buzz]' 
     
        5) 
        rightText === 'foo.bar.baz?.buzz' 
        leftText === 'foo.bar.baz' 
        diff === '?.buzz' 
        */</span>
        <span class="s1">const diff = rightText.replace(leftText, </span><span class="s0">''</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(diff.startsWith(</span><span class="s0">'.#'</span><span class="s1">)) {</span>
            <span class="s3">// Do not handle direct optional chaining on private properties because of a typescript bug (https://github.com/microsoft/TypeScript/issues/42734)</span>
            <span class="s3">// We still allow in computed properties</span>
            <span class="s1">invalidOptionallyChainedPrivateProperty = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(diff.startsWith(</span><span class="s0">'?'</span><span class="s1">)) {</span>
            <span class="s3">// item was &quot;pre optional chained&quot;</span>
            <span class="s1">optionallyChainedCode += diff;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">const needsDot = diff.startsWith(</span><span class="s0">'('</span><span class="s1">) || diff.startsWith(</span><span class="s0">'['</span><span class="s1">);</span>
            <span class="s1">optionallyChainedCode += `?${needsDot ? </span><span class="s0">'.' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}${diff}`;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">previous = current;</span>
    <span class="s1">current = util.nullThrows(current.parent, util.NullThrowsReasons.MissingParent);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">invalidOptionallyChainedPrivateProperty,</span>
        <span class="s1">expressionCount,</span>
        <span class="s1">previousLeftText,</span>
        <span class="s1">optionallyChainedCode,</span>
        <span class="s1">previous,</span>
        <span class="s1">current,</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isValidChainTarget(node, allowIdentifier) {</span>
    <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.ChainExpression) {</span>
        <span class="s2">return </span><span class="s1">isValidChainTarget(node.expression, allowIdentifier);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.MemberExpression) {</span>
        <span class="s1">const isObjectValid = ALLOWED_MEMBER_OBJECT_TYPES.has(node.object.type) &amp;&amp;</span>
            <span class="s3">// make sure to validate the expression is of our expected structure</span>
            <span class="s1">isValidChainTarget(node.object, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">const isPropertyValid = node.computed</span>
            <span class="s1">? ALLOWED_COMPUTED_PROP_TYPES.has(node.property.type) &amp;&amp;</span>
                <span class="s3">// make sure to validate the member expression is of our expected structure</span>
                <span class="s1">(node.property.type === utils_1.AST_NODE_TYPES.MemberExpression</span>
                    <span class="s1">? isValidChainTarget(node.property, allowIdentifier)</span>
                    <span class="s1">: </span><span class="s2">true</span><span class="s1">)</span>
            <span class="s1">: ALLOWED_NON_COMPUTED_PROP_TYPES.has(node.property.type);</span>
        <span class="s2">return </span><span class="s1">isObjectValid &amp;&amp; isPropertyValid;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.CallExpression) {</span>
        <span class="s2">return </span><span class="s1">isValidChainTarget(node.callee, allowIdentifier);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(allowIdentifier &amp;&amp;</span>
        <span class="s1">(node.type === utils_1.AST_NODE_TYPES.Identifier ||</span>
            <span class="s1">node.type === utils_1.AST_NODE_TYPES.ThisExpression ||</span>
            <span class="s1">node.type === utils_1.AST_NODE_TYPES.MetaProperty)) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">/* 
    special case for the following, where we only want the left 
    - foo !== null 
    - foo != null 
    - foo !== undefined 
    - foo != undefined 
    */</span>
    <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
        <span class="s1">[</span><span class="s0">'!=='</span><span class="s1">, </span><span class="s0">'!='</span><span class="s1">].includes(node.operator) &amp;&amp;</span>
        <span class="s1">isValidChainTarget(node.left, allowIdentifier) &amp;&amp;</span>
        <span class="s1">(util.isUndefinedIdentifier(node.right) || util.isNullLiteral(node.right)));</span>
<span class="s1">}</span>
<span class="s3">//# sourceMappingURL=prefer-optional-chain.js.map</span></pre>
</body>
</html>
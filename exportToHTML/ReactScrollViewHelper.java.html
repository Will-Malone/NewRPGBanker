<html>
<head>
<title>ReactScrollViewHelper.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
.s7 { color: #77b767; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactScrollViewHelper.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.views.scroll</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.animation.Animator</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.animation.ValueAnimator</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Point</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.widget.OverScroller</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.core.view.ViewCompat</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.WritableNativeMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.ReactConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.build.ReactBuildConfig</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.FabricViewStateManager</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.PixelUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIManagerHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.ViewUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.EventDispatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Collections</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Set</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.WeakHashMap</span><span class="s2">;</span>

<span class="s3">/** Helper class that deals with emitting Scroll Events. */</span>
<span class="s2">public class </span><span class="s1">ReactScrollViewHelper {</span>
  <span class="s2">private static </span><span class="s1">String TAG = ReactHorizontalScrollView.</span><span class="s2">class</span><span class="s1">.getSimpleName()</span><span class="s2">;</span>
  <span class="s2">private static boolean </span><span class="s1">DEBUG_MODE = </span><span class="s2">false </span><span class="s1">&amp;&amp; ReactBuildConfig.DEBUG</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String CONTENT_OFFSET_LEFT = </span><span class="s4">&quot;contentOffsetLeft&quot;</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String CONTENT_OFFSET_TOP = </span><span class="s4">&quot;contentOffsetTop&quot;</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">String SCROLL_AWAY_PADDING_TOP = </span><span class="s4">&quot;scrollAwayPaddingTop&quot;</span><span class="s2">;</span>

  <span class="s2">public static final long </span><span class="s1">MOMENTUM_DELAY = </span><span class="s5">20</span><span class="s2">;</span>
  <span class="s2">public static final </span><span class="s1">String OVER_SCROLL_ALWAYS = </span><span class="s4">&quot;always&quot;</span><span class="s2">;</span>
  <span class="s2">public static final </span><span class="s1">String AUTO = </span><span class="s4">&quot;auto&quot;</span><span class="s2">;</span>
  <span class="s2">public static final </span><span class="s1">String OVER_SCROLL_NEVER = </span><span class="s4">&quot;never&quot;</span><span class="s2">;</span>

  <span class="s2">public static final int </span><span class="s1">SNAP_ALIGNMENT_DISABLED = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">public static final int </span><span class="s1">SNAP_ALIGNMENT_START = </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">public static final int </span><span class="s1">SNAP_ALIGNMENT_CENTER = </span><span class="s5">2</span><span class="s2">;</span>
  <span class="s2">public static final int </span><span class="s1">SNAP_ALIGNMENT_END = </span><span class="s5">3</span><span class="s2">;</span>

  <span class="s2">public interface </span><span class="s1">ScrollListener {</span>
    <span class="s2">void </span><span class="s1">onScroll(</span>
        <span class="s1">ViewGroup scrollView</span><span class="s2">, </span><span class="s1">ScrollEventType scrollEventType</span><span class="s2">, float </span><span class="s1">xVelocity</span><span class="s2">, float </span><span class="s1">yVelocity)</span><span class="s2">;</span>

    <span class="s2">void </span><span class="s1">onLayout(ViewGroup scrollView)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Support global native listeners for scroll events</span>
  <span class="s2">private static final </span><span class="s1">Set&lt;ScrollListener&gt; sScrollListeners =</span>
      <span class="s1">Collections.newSetFromMap(</span><span class="s2">new </span><span class="s1">WeakHashMap&lt;ScrollListener</span><span class="s2">, </span><span class="s1">Boolean&gt;())</span><span class="s2">;</span>

  <span class="s0">// If all else fails, this is the hardcoded value in OverScroller.java, in AOSP.</span>
  <span class="s0">// The default is defined here (as of this diff):</span>
  <span class="s0">// https://android.googlesource.com/platform/frameworks/base/+/ae5bcf23b5f0875e455790d6af387184dbd009c1/core/java/android/widget/OverScroller.java#44</span>
  <span class="s2">private static int </span><span class="s1">SMOOTH_SCROLL_DURATION = </span><span class="s5">250</span><span class="s2">;</span>
  <span class="s2">private static boolean </span><span class="s1">mSmoothScrollDurationInitialized = </span><span class="s2">false;</span>

  <span class="s3">/** Shared by {</span><span class="s6">@link </span><span class="s3">ReactScrollView} and {</span><span class="s6">@link </span><span class="s3">ReactHorizontalScrollView}. */</span>
  <span class="s2">public static </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">ViewGroup &amp; HasScrollEventThrottle&gt; </span><span class="s2">void </span><span class="s1">emitScrollEvent(</span>
      <span class="s1">T scrollView</span><span class="s2">, float </span><span class="s1">xVelocity</span><span class="s2">, float </span><span class="s1">yVelocity) {</span>
    <span class="s1">emitScrollEvent(scrollView</span><span class="s2">, </span><span class="s1">ScrollEventType.SCROLL</span><span class="s2">, </span><span class="s1">xVelocity</span><span class="s2">, </span><span class="s1">yVelocity)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">ViewGroup &amp; HasScrollEventThrottle&gt; </span><span class="s2">void </span><span class="s1">emitScrollBeginDragEvent(</span>
      <span class="s1">T scrollView) {</span>
    <span class="s1">emitScrollEvent(scrollView</span><span class="s2">, </span><span class="s1">ScrollEventType.BEGIN_DRAG)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">ViewGroup &amp; HasScrollEventThrottle&gt; </span><span class="s2">void </span><span class="s1">emitScrollEndDragEvent(</span>
      <span class="s1">T scrollView</span><span class="s2">, float </span><span class="s1">xVelocity</span><span class="s2">, float </span><span class="s1">yVelocity) {</span>
    <span class="s1">emitScrollEvent(scrollView</span><span class="s2">, </span><span class="s1">ScrollEventType.END_DRAG</span><span class="s2">, </span><span class="s1">xVelocity</span><span class="s2">, </span><span class="s1">yVelocity)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">ViewGroup &amp; HasScrollEventThrottle&gt; </span><span class="s2">void </span><span class="s1">emitScrollMomentumBeginEvent(</span>
      <span class="s1">T scrollView</span><span class="s2">, int </span><span class="s1">xVelocity</span><span class="s2">, int </span><span class="s1">yVelocity) {</span>
    <span class="s1">emitScrollEvent(scrollView</span><span class="s2">, </span><span class="s1">ScrollEventType.MOMENTUM_BEGIN</span><span class="s2">, </span><span class="s1">xVelocity</span><span class="s2">, </span><span class="s1">yVelocity)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">ViewGroup &amp; HasScrollEventThrottle&gt; </span><span class="s2">void </span><span class="s1">emitScrollMomentumEndEvent(</span>
      <span class="s1">T scrollView) {</span>
    <span class="s1">emitScrollEvent(scrollView</span><span class="s2">, </span><span class="s1">ScrollEventType.MOMENTUM_END)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">ViewGroup &amp; HasScrollEventThrottle&gt; </span><span class="s2">void </span><span class="s1">emitScrollEvent(</span>
      <span class="s1">T scrollView</span><span class="s2">, </span><span class="s1">ScrollEventType scrollEventType) {</span>
    <span class="s1">emitScrollEvent(scrollView</span><span class="s2">, </span><span class="s1">scrollEventType</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static </span><span class="s1">&lt;T </span><span class="s2">extends </span><span class="s1">ViewGroup &amp; HasScrollEventThrottle&gt; </span><span class="s2">void </span><span class="s1">emitScrollEvent(</span>
      <span class="s1">T scrollView</span><span class="s2">, </span><span class="s1">ScrollEventType scrollEventType</span><span class="s2">, float </span><span class="s1">xVelocity</span><span class="s2">, float </span><span class="s1">yVelocity) {</span>
    <span class="s2">long </span><span class="s1">now = System.currentTimeMillis()</span><span class="s2">;</span>
    <span class="s1">View contentView = scrollView.getChildAt(</span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(contentView == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(ScrollListener scrollListener : sScrollListeners) {</span>
      <span class="s1">scrollListener.onScroll(scrollView</span><span class="s2">, </span><span class="s1">scrollEventType</span><span class="s2">, </span><span class="s1">xVelocity</span><span class="s2">, </span><span class="s1">yVelocity)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">ReactContext reactContext = (ReactContext) scrollView.getContext()</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">surfaceId = UIManagerHelper.getSurfaceId(reactContext)</span><span class="s2">;</span>

    <span class="s0">// It's possible for the EventDispatcher to go away - for example,</span>
    <span class="s0">// if there's a crash initiated from JS and we tap on a ScrollView</span>
    <span class="s0">// around teardown of RN, this will cause a NPE. We can safely ignore</span>
    <span class="s0">// this since the crash is usually a red herring.</span>
    <span class="s1">EventDispatcher eventDispatcher =</span>
        <span class="s1">UIManagerHelper.getEventDispatcherForReactTag(reactContext</span><span class="s2">, </span><span class="s1">scrollView.getId())</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(eventDispatcher != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">eventDispatcher.dispatchEvent(</span>
          <span class="s1">ScrollEvent.obtain(</span>
              <span class="s1">surfaceId</span><span class="s2">,</span>
              <span class="s1">scrollView.getId()</span><span class="s2">,</span>
              <span class="s1">scrollEventType</span><span class="s2">,</span>
              <span class="s1">scrollView.getScrollX()</span><span class="s2">,</span>
              <span class="s1">scrollView.getScrollY()</span><span class="s2">,</span>
              <span class="s1">xVelocity</span><span class="s2">,</span>
              <span class="s1">yVelocity</span><span class="s2">,</span>
              <span class="s1">contentView.getWidth()</span><span class="s2">,</span>
              <span class="s1">contentView.getHeight()</span><span class="s2">,</span>
              <span class="s1">scrollView.getWidth()</span><span class="s2">,</span>
              <span class="s1">scrollView.getHeight()))</span><span class="s2">;</span>
      <span class="s1">scrollView.setLastScrollDispatchTime(now)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** This is only for Java listeners. onLayout events emitted to JS are handled elsewhere. */</span>
  <span class="s2">public static void </span><span class="s1">emitLayoutEvent(ViewGroup scrollView) {</span>
    <span class="s2">for </span><span class="s1">(ScrollListener scrollListener : sScrollListeners) {</span>
      <span class="s1">scrollListener.onLayout(scrollView)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public static int </span><span class="s1">parseOverScrollMode(String jsOverScrollMode) {</span>
    <span class="s2">if </span><span class="s1">(jsOverScrollMode == </span><span class="s2">null </span><span class="s1">|| jsOverScrollMode.equals(AUTO)) {</span>
      <span class="s2">return </span><span class="s1">View.OVER_SCROLL_IF_CONTENT_SCROLLS</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(jsOverScrollMode.equals(OVER_SCROLL_ALWAYS)) {</span>
      <span class="s2">return </span><span class="s1">View.OVER_SCROLL_ALWAYS</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(jsOverScrollMode.equals(OVER_SCROLL_NEVER)) {</span>
      <span class="s2">return </span><span class="s1">View.OVER_SCROLL_NEVER</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s4">&quot;wrong overScrollMode: &quot; </span><span class="s1">+ jsOverScrollMode)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">View.OVER_SCROLL_IF_CONTENT_SCROLLS</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public static int </span><span class="s1">parseSnapToAlignment(@Nullable String alignment) {</span>
    <span class="s2">if </span><span class="s1">(alignment == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">SNAP_ALIGNMENT_DISABLED</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s4">&quot;start&quot;</span><span class="s1">.equalsIgnoreCase(alignment)) {</span>
      <span class="s2">return </span><span class="s1">SNAP_ALIGNMENT_START</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s4">&quot;center&quot;</span><span class="s1">.equalsIgnoreCase(alignment)) {</span>
      <span class="s2">return </span><span class="s1">SNAP_ALIGNMENT_CENTER</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s4">&quot;end&quot;</span><span class="s1">.equals(alignment)) {</span>
      <span class="s2">return </span><span class="s1">SNAP_ALIGNMENT_END</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s4">&quot;wrong snap alignment value: &quot; </span><span class="s1">+ alignment)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">SNAP_ALIGNMENT_DISABLED</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public static int </span><span class="s1">getDefaultScrollAnimationDuration(Context context) {</span>
    <span class="s2">if </span><span class="s1">(!mSmoothScrollDurationInitialized) {</span>
      <span class="s1">mSmoothScrollDurationInitialized = </span><span class="s2">true;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">OverScrollerDurationGetter overScrollerDurationGetter =</span>
            <span class="s2">new </span><span class="s1">OverScrollerDurationGetter(context)</span><span class="s2">;</span>
        <span class="s1">SMOOTH_SCROLL_DURATION = overScrollerDurationGetter.getScrollAnimationDuration()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(Throwable e) {</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">SMOOTH_SCROLL_DURATION</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private static class </span><span class="s1">OverScrollerDurationGetter </span><span class="s2">extends </span><span class="s1">OverScroller {</span>
    <span class="s0">// This is the default in AOSP, hardcoded in OverScroller.java.</span>
    <span class="s2">private int </span><span class="s1">mScrollAnimationDuration = </span><span class="s5">250</span><span class="s2">;</span>

    <span class="s1">OverScrollerDurationGetter(Context context) {</span>
      <span class="s0">// We call with a null context because OverScroller does not use the context</span>
      <span class="s0">// in the execution path we're interested in, unless heavily modified in an AOSP fork.</span>
      <span class="s2">super</span><span class="s1">(context)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public int </span><span class="s1">getScrollAnimationDuration() {</span>
      <span class="s0">// If startScroll is called without a duration, OverScroller will call `startScroll(x, y, dx,</span>
      <span class="s0">// dy, duration)` with the default duration.</span>
      <span class="s2">super</span><span class="s1">.startScroll(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">return </span><span class="s1">mScrollAnimationDuration</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public void </span><span class="s1">startScroll(</span><span class="s2">int </span><span class="s1">startX</span><span class="s2">, int </span><span class="s1">startY</span><span class="s2">, int </span><span class="s1">dx</span><span class="s2">, int </span><span class="s1">dy</span><span class="s2">, int </span><span class="s1">duration) {</span>
      <span class="s1">mScrollAnimationDuration = duration</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Adds a scroll listener.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s7">&lt;p&gt;</span><span class="s3">Note that you must keep a reference to this scroll listener because this class only keeps a</span>
   <span class="s3">* weak reference to it (to prevent memory leaks). This means that code like </span><span class="s7">&lt;code&gt;</span>
   <span class="s3">* addScrollListener(new ScrollListener() {...})</span><span class="s7">&lt;/code&gt; </span><span class="s3">won't work, you need to do this instead:</span>
   <span class="s3">* </span><span class="s7">&lt;code&gt;</span>
   <span class="s3">*   mScrollListener = new ScrollListener() {...};</span>
   <span class="s3">*   ReactScrollViewHelper.addScrollListener(mScrollListener);</span>
   <span class="s3">* </span><span class="s7">&lt;/code&gt; </span><span class="s3">instead.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s6">@param </span><span class="s3">listener</span>
   <span class="s3">*/</span>
  <span class="s2">public static void </span><span class="s1">addScrollListener(ScrollListener listener) {</span>
    <span class="s1">sScrollListeners.add(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static void </span><span class="s1">removeScrollListener(ScrollListener listener) {</span>
    <span class="s1">sScrollListeners.remove(listener)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static class </span><span class="s1">ReactScrollViewScrollState {</span>
    <span class="s2">private final int </span><span class="s1">mLayoutDirection</span><span class="s2">;</span>
    <span class="s2">private final </span><span class="s1">Point mFinalAnimatedPositionScroll = </span><span class="s2">new </span><span class="s1">Point()</span><span class="s2">;</span>
    <span class="s2">private int </span><span class="s1">mScrollAwayPaddingTop = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">private final </span><span class="s1">Point mLastStateUpdateScroll = </span><span class="s2">new </span><span class="s1">Point(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">private boolean </span><span class="s1">mIsCanceled = </span><span class="s2">false;</span>
    <span class="s2">private boolean </span><span class="s1">mIsFinished = </span><span class="s2">true;</span>
    <span class="s2">private float </span><span class="s1">mDecelerationRate = </span><span class="s5">0.985f</span><span class="s2">;</span>

    <span class="s2">public </span><span class="s1">ReactScrollViewScrollState(</span><span class="s2">final int </span><span class="s1">layoutDirection) {</span>
      <span class="s1">mLayoutDirection = layoutDirection</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Get the layout direction. Can be either scrollView.LAYOUT_DIRECTION_RTL (1) or</span>
     <span class="s3">* scrollView.LAYOUT_DIRECTION_LTR (0). If the value is -1, it means unknown layout.</span>
     <span class="s3">*/</span>
    <span class="s2">public int </span><span class="s1">getLayoutDirection() {</span>
      <span class="s2">return </span><span class="s1">mLayoutDirection</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/** Get the position after current animation is finished */</span>
    <span class="s2">public </span><span class="s1">Point getFinalAnimatedPositionScroll() {</span>
      <span class="s2">return </span><span class="s1">mFinalAnimatedPositionScroll</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/** Set the final scroll position after scrolling animation is finished */</span>
    <span class="s2">public </span><span class="s1">ReactScrollViewScrollState setFinalAnimatedPositionScroll(</span>
        <span class="s2">int </span><span class="s1">finalAnimatedPositionScrollX</span><span class="s2">, int </span><span class="s1">finalAnimatedPositionScrollY) {</span>
      <span class="s1">mFinalAnimatedPositionScroll.set(finalAnimatedPositionScrollX</span><span class="s2">, </span><span class="s1">finalAnimatedPositionScrollY)</span><span class="s2">;</span>
      <span class="s2">return this;</span>
    <span class="s1">}</span>

    <span class="s3">/** Get the Fabric state of last scroll position */</span>
    <span class="s2">public </span><span class="s1">Point getLastStateUpdateScroll() {</span>
      <span class="s2">return </span><span class="s1">mLastStateUpdateScroll</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/** Set the Fabric state of last scroll position */</span>
    <span class="s2">public </span><span class="s1">ReactScrollViewScrollState setLastStateUpdateScroll(</span>
        <span class="s2">int </span><span class="s1">lastStateUpdateScrollX</span><span class="s2">, int </span><span class="s1">lastStateUpdateScrollY) {</span>
      <span class="s1">mLastStateUpdateScroll.set(lastStateUpdateScrollX</span><span class="s2">, </span><span class="s1">lastStateUpdateScrollY)</span><span class="s2">;</span>
      <span class="s2">return this;</span>
    <span class="s1">}</span>

    <span class="s3">/** Get the padding on the top for nav bar */</span>
    <span class="s2">public int </span><span class="s1">getScrollAwayPaddingTop() {</span>
      <span class="s2">return </span><span class="s1">mScrollAwayPaddingTop</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/** Set the padding on the top for nav bar */</span>
    <span class="s2">public </span><span class="s1">ReactScrollViewScrollState setScrollAwayPaddingTop(</span><span class="s2">int </span><span class="s1">scrollAwayPaddingTop) {</span>
      <span class="s1">mScrollAwayPaddingTop = scrollAwayPaddingTop</span><span class="s2">;</span>
      <span class="s2">return this;</span>
    <span class="s1">}</span>

    <span class="s3">/** Get true if the previous animation was canceled */</span>
    <span class="s2">public boolean </span><span class="s1">getIsCanceled() {</span>
      <span class="s2">return </span><span class="s1">mIsCanceled</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/** Set the state of current animation is canceled or not */</span>
    <span class="s2">public </span><span class="s1">ReactScrollViewScrollState setIsCanceled(</span><span class="s2">boolean </span><span class="s1">isCanceled) {</span>
      <span class="s1">mIsCanceled = isCanceled</span><span class="s2">;</span>
      <span class="s2">return this;</span>
    <span class="s1">}</span>

    <span class="s3">/** Get true if previous animation was finished */</span>
    <span class="s2">public boolean </span><span class="s1">getIsFinished() {</span>
      <span class="s2">return </span><span class="s1">mIsFinished</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/** Set the state of current animation is finished or not */</span>
    <span class="s2">public </span><span class="s1">ReactScrollViewScrollState setIsFinished(</span><span class="s2">boolean </span><span class="s1">isFinished) {</span>
      <span class="s1">mIsFinished = isFinished</span><span class="s2">;</span>
      <span class="s2">return this;</span>
    <span class="s1">}</span>

    <span class="s3">/** Get true if previous animation was finished */</span>
    <span class="s2">public float </span><span class="s1">getDecelerationRate() {</span>
      <span class="s2">return </span><span class="s1">mDecelerationRate</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/** Set the state of current animation is finished or not */</span>
    <span class="s2">public </span><span class="s1">ReactScrollViewScrollState setDecelerationRate(</span><span class="s2">float </span><span class="s1">decelerationRate) {</span>
      <span class="s1">mDecelerationRate = decelerationRate</span><span class="s2">;</span>
      <span class="s2">return this;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Scroll the given view to the location (x, y), with provided initial velocity. This method works</span>
   <span class="s3">* by calculate the &quot;would be&quot; initial velocity with internal friction to move to the point (x,</span>
   <span class="s3">* y), then apply that to the animator.</span>
   <span class="s3">*/</span>
  <span class="s2">public static </span><span class="s1">&lt;</span>
          <span class="s1">T </span><span class="s2">extends</span>
              <span class="s1">ViewGroup &amp; FabricViewStateManager.HasFabricViewStateManager &amp; HasScrollState</span>
                  <span class="s1">&amp; HasFlingAnimator&gt;</span>
      <span class="s2">void </span><span class="s1">smoothScrollTo(</span><span class="s2">final </span><span class="s1">T scrollView</span><span class="s2">, final int </span><span class="s1">x</span><span class="s2">, final int </span><span class="s1">y) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(TAG</span><span class="s2">, </span><span class="s4">&quot;smoothScrollTo[%d] x %d y %d&quot;</span><span class="s2">, </span><span class="s1">scrollView.getId()</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// Register the listeners for the fling animator if there isn't any</span>
    <span class="s2">final </span><span class="s1">ValueAnimator flingAnimator = scrollView.getFlingAnimator()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(flingAnimator.getListeners() == </span><span class="s2">null </span><span class="s1">|| flingAnimator.getListeners().size() == </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">registerFlingAnimator(scrollView)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">ReactScrollViewScrollState scrollState = scrollView.getReactScrollViewScrollState()</span><span class="s2">;</span>
    <span class="s1">scrollState.setFinalAnimatedPositionScroll(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>

    <span class="s2">final int </span><span class="s1">scrollX = scrollView.getScrollX()</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">scrollY = scrollView.getScrollY()</span><span class="s2">;</span>
    <span class="s0">// Only one fling animator will be started. For the horizontal scroll view, scrollY will always</span>
    <span class="s0">// be the same to y. This is the same to the vertical scroll view.</span>
    <span class="s2">if </span><span class="s1">(scrollX != x) {</span>
      <span class="s1">scrollView.startFlingAnimator(scrollX</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(scrollY != y) {</span>
      <span class="s1">scrollView.startFlingAnimator(scrollY</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">updateFabricScrollState(scrollView</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Get current position or position after current animation finishes, if any. */</span>
  <span class="s2">public static </span><span class="s1">&lt;</span>
          <span class="s1">T </span><span class="s2">extends</span>
              <span class="s1">ViewGroup &amp; FabricViewStateManager.HasFabricViewStateManager &amp; HasScrollState</span>
                  <span class="s1">&amp; HasFlingAnimator&gt;</span>
      <span class="s2">int </span><span class="s1">getNextFlingStartValue(</span>
          <span class="s2">final </span><span class="s1">T scrollView</span><span class="s2">,</span>
          <span class="s2">final int </span><span class="s1">currentValue</span><span class="s2">,</span>
          <span class="s2">final int </span><span class="s1">postAnimationValue</span><span class="s2">,</span>
          <span class="s2">final int </span><span class="s1">velocity) {</span>
    <span class="s2">final </span><span class="s1">ReactScrollViewScrollState scrollState = scrollView.getReactScrollViewScrollState()</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">velocityDirectionMask = velocity != </span><span class="s5">0 </span><span class="s1">? velocity / Math.abs(velocity) : </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">final boolean </span><span class="s1">isMovingTowardsAnimatedValue =</span>
        <span class="s1">velocityDirectionMask * (postAnimationValue - currentValue) &gt; </span><span class="s5">0</span><span class="s2">;</span>

    <span class="s0">// When the fling animation is not finished, or it was canceled and now we are moving towards</span>
    <span class="s0">// the final animated value, we will return the final animated value. This is because follow up</span>
    <span class="s0">// animation should consider the &quot;would be&quot; animated location, so that previous quick small</span>
    <span class="s0">// scrolls are still working.</span>
    <span class="s2">return </span><span class="s1">!scrollState.getIsFinished()</span>
            <span class="s1">|| (scrollState.getIsCanceled() &amp;&amp; isMovingTowardsAnimatedValue)</span>
        <span class="s1">? postAnimationValue</span>
        <span class="s1">: currentValue</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;</span>
          <span class="s1">T </span><span class="s2">extends</span>
              <span class="s1">ViewGroup &amp; FabricViewStateManager.HasFabricViewStateManager &amp; HasScrollState</span>
                  <span class="s1">&amp; HasFlingAnimator&gt;</span>
      <span class="s2">boolean </span><span class="s1">updateFabricScrollState(</span><span class="s2">final </span><span class="s1">T scrollView) {</span>
    <span class="s2">return </span><span class="s1">updateFabricScrollState(scrollView</span><span class="s2">, </span><span class="s1">scrollView.getScrollX()</span><span class="s2">, </span><span class="s1">scrollView.getScrollY())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Called on any stabilized onScroll change to propagate content offset value to a Shadow Node.</span>
   <span class="s3">*/</span>
  <span class="s2">public static </span><span class="s1">&lt;</span>
          <span class="s1">T </span><span class="s2">extends</span>
              <span class="s1">ViewGroup &amp; FabricViewStateManager.HasFabricViewStateManager &amp; HasScrollState</span>
                  <span class="s1">&amp; HasFlingAnimator&gt;</span>
      <span class="s2">boolean </span><span class="s1">updateFabricScrollState(</span><span class="s2">final </span><span class="s1">T scrollView</span><span class="s2">, final int </span><span class="s1">scrollX</span><span class="s2">, final int </span><span class="s1">scrollY) {</span>
    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s4">&quot;updateFabricScrollState[%d] scrollX %d scrollY %d&quot;</span><span class="s2">,</span>
          <span class="s1">scrollView.getId()</span><span class="s2">,</span>
          <span class="s1">scrollX</span><span class="s2">,</span>
          <span class="s1">scrollY)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(ViewUtil.getUIManagerType(scrollView.getId()) == UIManagerType.DEFAULT) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">ReactScrollViewScrollState scrollState = scrollView.getReactScrollViewScrollState()</span><span class="s2">;</span>
    <span class="s0">// Dedupe events to reduce JNI traffic</span>
    <span class="s2">if </span><span class="s1">(scrollState.getLastStateUpdateScroll().equals(scrollX</span><span class="s2">, </span><span class="s1">scrollY)) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s1">scrollState.setLastStateUpdateScroll(scrollX</span><span class="s2">, </span><span class="s1">scrollY)</span><span class="s2">;</span>
    <span class="s1">forceUpdateState(scrollView)</span><span class="s2">;</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;</span>
          <span class="s1">T </span><span class="s2">extends</span>
              <span class="s1">ViewGroup &amp; FabricViewStateManager.HasFabricViewStateManager &amp; HasScrollState</span>
                  <span class="s1">&amp; HasFlingAnimator&gt;</span>
      <span class="s2">void </span><span class="s1">forceUpdateState(</span><span class="s2">final </span><span class="s1">T scrollView) {</span>
    <span class="s2">final </span><span class="s1">ReactScrollViewScrollState scrollState = scrollView.getReactScrollViewScrollState()</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">scrollAwayPaddingTop = scrollState.getScrollAwayPaddingTop()</span><span class="s2">;</span>
    <span class="s2">final </span><span class="s1">Point scrollPos = scrollState.getLastStateUpdateScroll()</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">scrollX = scrollPos.x</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">scrollY = scrollPos.y</span><span class="s2">;</span>
    <span class="s2">final int </span><span class="s1">fabricScrollX</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">layoutDirection = scrollState.getLayoutDirection()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(layoutDirection == scrollView.LAYOUT_DIRECTION_RTL) {</span>
      <span class="s0">// getScrollX returns offset from left even when layout direction is RTL.</span>
      <span class="s0">// The following line calculates offset from right.</span>
      <span class="s1">View child = scrollView.getChildAt(</span><span class="s5">0</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">contentWidth = child != </span><span class="s2">null </span><span class="s1">? child.getWidth() : </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s1">fabricScrollX = -(contentWidth - scrollX - scrollView.getWidth())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">fabricScrollX = scrollX</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(DEBUG_MODE) {</span>
      <span class="s1">FLog.i(</span>
          <span class="s1">TAG</span><span class="s2">,</span>
          <span class="s4">&quot;updateFabricScrollState[%d] scrollX %d scrollY %d fabricScrollX&quot;</span><span class="s2">,</span>
          <span class="s1">scrollView.getId()</span><span class="s2">,</span>
          <span class="s1">scrollX</span><span class="s2">,</span>
          <span class="s1">scrollY</span><span class="s2">,</span>
          <span class="s1">fabricScrollX)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">scrollView</span>
        <span class="s1">.getFabricViewStateManager()</span>
        <span class="s1">.setState(</span>
            <span class="s2">new </span><span class="s1">FabricViewStateManager.StateUpdateCallback() {</span>
              <span class="s1">@Override</span>
              <span class="s2">public </span><span class="s1">WritableMap getStateUpdate() {</span>
                <span class="s1">WritableMap map = </span><span class="s2">new </span><span class="s1">WritableNativeMap()</span><span class="s2">;</span>
                <span class="s1">map.putDouble(CONTENT_OFFSET_LEFT</span><span class="s2">, </span><span class="s1">PixelUtil.toDIPFromPixel(scrollX))</span><span class="s2">;</span>
                <span class="s1">map.putDouble(CONTENT_OFFSET_TOP</span><span class="s2">, </span><span class="s1">PixelUtil.toDIPFromPixel(scrollY))</span><span class="s2">;</span>
                <span class="s1">map.putDouble(</span>
                    <span class="s1">SCROLL_AWAY_PADDING_TOP</span><span class="s2">, </span><span class="s1">PixelUtil.toDIPFromPixel(scrollAwayPaddingTop))</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">map</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;</span>
          <span class="s1">T </span><span class="s2">extends</span>
              <span class="s1">ViewGroup &amp; FabricViewStateManager.HasFabricViewStateManager &amp; HasScrollState</span>
                  <span class="s1">&amp; HasFlingAnimator &amp; HasScrollEventThrottle&gt;</span>
      <span class="s2">void </span><span class="s1">updateStateOnScrollChanged(</span>
          <span class="s2">final </span><span class="s1">T scrollView</span><span class="s2">, final float </span><span class="s1">xVelocity</span><span class="s2">, final float </span><span class="s1">yVelocity) {</span>
    <span class="s0">// Race an UpdateState with every onScroll. This makes it more likely that, in Fabric,</span>
    <span class="s0">// when JS processes the scroll event, the C++ ShadowNode representation will have a</span>
    <span class="s0">// &quot;more correct&quot; scroll position. It will frequently be /incorrect/ but this decreases</span>
    <span class="s0">// the error as much as possible.</span>
    <span class="s1">updateFabricScrollState(scrollView)</span><span class="s2">;</span>
    <span class="s1">emitScrollEvent(scrollView</span><span class="s2">, </span><span class="s1">xVelocity</span><span class="s2">, </span><span class="s1">yVelocity)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;</span>
          <span class="s1">T </span><span class="s2">extends</span>
              <span class="s1">ViewGroup &amp; FabricViewStateManager.HasFabricViewStateManager &amp; HasScrollState</span>
                  <span class="s1">&amp; HasFlingAnimator&gt;</span>
      <span class="s2">void </span><span class="s1">registerFlingAnimator(</span><span class="s2">final </span><span class="s1">T scrollView) {</span>
    <span class="s1">scrollView</span>
        <span class="s1">.getFlingAnimator()</span>
        <span class="s1">.addListener(</span>
            <span class="s2">new </span><span class="s1">Animator.AnimatorListener() {</span>
              <span class="s1">@Override</span>
              <span class="s2">public void </span><span class="s1">onAnimationStart(Animator animator) {</span>
                <span class="s2">final </span><span class="s1">ReactScrollViewScrollState scrollState =</span>
                    <span class="s1">scrollView.getReactScrollViewScrollState()</span><span class="s2">;</span>
                <span class="s1">scrollState.setIsCanceled(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">scrollState.setIsFinished(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s1">@Override</span>
              <span class="s2">public void </span><span class="s1">onAnimationEnd(Animator animator) {</span>
                <span class="s1">scrollView.getReactScrollViewScrollState().setIsFinished(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">updateFabricScrollState(scrollView)</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s1">@Override</span>
              <span class="s2">public void </span><span class="s1">onAnimationCancel(Animator animator) {</span>
                <span class="s1">scrollView.getReactScrollViewScrollState().setIsCanceled(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
              <span class="s1">}</span>

              <span class="s1">@Override</span>
              <span class="s2">public void </span><span class="s1">onAnimationRepeat(Animator animator) {}</span>
            <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static </span><span class="s1">&lt;</span>
          <span class="s1">T </span><span class="s2">extends</span>
              <span class="s1">ViewGroup &amp; FabricViewStateManager.HasFabricViewStateManager &amp; HasScrollState</span>
                  <span class="s1">&amp; HasFlingAnimator&gt;</span>
      <span class="s1">Point predictFinalScrollPosition(</span>
          <span class="s2">final </span><span class="s1">T scrollView</span><span class="s2">,</span>
          <span class="s2">final int </span><span class="s1">velocityX</span><span class="s2">,</span>
          <span class="s2">final int </span><span class="s1">velocityY</span><span class="s2">,</span>
          <span class="s2">final int </span><span class="s1">maximumOffsetX</span><span class="s2">,</span>
          <span class="s2">final int </span><span class="s1">maximumOffsetY) {</span>
    <span class="s2">final </span><span class="s1">ReactScrollViewScrollState scrollState = scrollView.getReactScrollViewScrollState()</span><span class="s2">;</span>
    <span class="s0">// ScrollView can *only* scroll for 250ms when using smoothScrollTo and there's</span>
    <span class="s0">// no way to customize the scroll duration. So, we create a temporary OverScroller</span>
    <span class="s0">// so we can predict where a fling would land and snap to nearby that point.</span>
    <span class="s1">OverScroller scroller = </span><span class="s2">new </span><span class="s1">OverScroller(scrollView.getContext())</span><span class="s2">;</span>
    <span class="s1">scroller.setFriction(</span><span class="s5">1.0f </span><span class="s1">- scrollState.getDecelerationRate())</span><span class="s2">;</span>

    <span class="s0">// predict where a fling would end up so we can scroll to the nearest snap offset</span>
    <span class="s2">int </span><span class="s1">width =</span>
        <span class="s1">scrollView.getWidth()</span>
            <span class="s1">- ViewCompat.getPaddingStart(scrollView)</span>
            <span class="s1">- ViewCompat.getPaddingEnd(scrollView)</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">height =</span>
        <span class="s1">scrollView.getHeight() - scrollView.getPaddingBottom() - scrollView.getPaddingTop()</span><span class="s2">;</span>
    <span class="s1">Point finalAnimatedPositionScroll = scrollState.getFinalAnimatedPositionScroll()</span><span class="s2">;</span>
    <span class="s1">scroller.fling(</span>
        <span class="s1">getNextFlingStartValue(</span>
            <span class="s1">scrollView</span><span class="s2">,</span>
            <span class="s1">scrollView.getScrollX()</span><span class="s2">,</span>
            <span class="s1">finalAnimatedPositionScroll.x</span><span class="s2">,</span>
            <span class="s1">velocityX)</span><span class="s2">, </span><span class="s0">// startX</span>
        <span class="s1">getNextFlingStartValue(</span>
            <span class="s1">scrollView</span><span class="s2">,</span>
            <span class="s1">scrollView.getScrollY()</span><span class="s2">,</span>
            <span class="s1">finalAnimatedPositionScroll.y</span><span class="s2">,</span>
            <span class="s1">velocityY)</span><span class="s2">, </span><span class="s0">// startY</span>
        <span class="s1">velocityX</span><span class="s2">, </span><span class="s0">// velocityX</span>
        <span class="s1">velocityY</span><span class="s2">, </span><span class="s0">// velocityY</span>
        <span class="s5">0</span><span class="s2">, </span><span class="s0">// minX</span>
        <span class="s1">maximumOffsetX</span><span class="s2">, </span><span class="s0">// maxX</span>
        <span class="s5">0</span><span class="s2">, </span><span class="s0">// minY</span>
        <span class="s1">maximumOffsetY</span><span class="s2">, </span><span class="s0">// maxY</span>
        <span class="s1">width / </span><span class="s5">2</span><span class="s2">, </span><span class="s0">// overX</span>
        <span class="s1">height / </span><span class="s5">2 </span><span class="s0">// overY</span>
        <span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return new </span><span class="s1">Point(scroller.getFinalX()</span><span class="s2">, </span><span class="s1">scroller.getFinalY())</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public interface </span><span class="s1">HasScrollState {</span>
    <span class="s3">/** Get the scroll state for the current ScrollView */</span>
    <span class="s1">ReactScrollViewScrollState getReactScrollViewScrollState()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public interface </span><span class="s1">HasFlingAnimator {</span>
    <span class="s3">/**</span>
     <span class="s3">* Start the fling animator that the ScrollView has to go from the start position to end</span>
     <span class="s3">* position.</span>
     <span class="s3">*/</span>
    <span class="s2">void </span><span class="s1">startFlingAnimator(</span><span class="s2">int </span><span class="s1">start</span><span class="s2">, int </span><span class="s1">end)</span><span class="s2">;</span>

    <span class="s3">/** Get the fling animator that is reused for the ScrollView to handle fling animation. */</span>
    <span class="s1">ValueAnimator getFlingAnimator()</span><span class="s2">;</span>

    <span class="s3">/** Get the fling distance with current velocity for prediction */</span>
    <span class="s2">int </span><span class="s1">getFlingExtrapolatedDistance(</span><span class="s2">int </span><span class="s1">velocity)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public interface </span><span class="s1">HasScrollEventThrottle {</span>
    <span class="s3">/**</span>
     <span class="s3">* Set the scroll event throttle in ms. This number is used to throttle the scroll events. The</span>
     <span class="s3">* default value is zero, which means the scroll events are sent with no throttle.</span>
     <span class="s3">*/</span>
    <span class="s2">void </span><span class="s1">setScrollEventThrottle(</span><span class="s2">int </span><span class="s1">scrollEventThrottle)</span><span class="s2">;</span>

    <span class="s3">/** Get the scroll event throttle in ms. */</span>
    <span class="s2">int </span><span class="s1">getScrollEventThrottle()</span><span class="s2">;</span>

    <span class="s3">/** Set the scroll view's last dispatch time for throttling */</span>
    <span class="s2">void </span><span class="s1">setLastScrollDispatchTime(</span><span class="s2">long </span><span class="s1">lastScrollDispatchTime)</span><span class="s2">;</span>

    <span class="s3">/** Get the scroll view dispatch time for throttling */</span>
    <span class="s2">long </span><span class="s1">getLastScrollDispatchTime()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public interface </span><span class="s1">HasSmoothScroll {</span>
    <span class="s2">void </span><span class="s1">reactSmoothScrollTo(</span><span class="s2">int </span><span class="s1">x</span><span class="s2">, int </span><span class="s1">y)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
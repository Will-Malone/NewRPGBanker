<html>
<head>
<title>event-target-shim.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
event-target-shim.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @author Toru Nagashima &lt;https://github.com/mysticatea&gt; 
 * @copyright 2015 Toru Nagashima. All rights reserved. 
 * See LICENSE file in root directory for full license. 
 */</span>
<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s2">'__esModule'</span><span class="s1">, { value: </span><span class="s3">true </span><span class="s1">});</span>

<span class="s0">/** 
 * @typedef {object} PrivateData 
 * @property {EventTarget} eventTarget The event target. 
 * @property {{type:string}} event The original event object. 
 * @property {number} eventPhase The current event phase. 
 * @property {EventTarget|null} currentTarget The current event target. 
 * @property {boolean} canceled The flag to prevent default. 
 * @property {boolean} stopped The flag to stop propagation. 
 * @property {boolean} immediateStopped The flag to stop propagation immediately. 
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null. 
 * @property {number} timeStamp The unix time. 
 * @private 
 */</span>

<span class="s0">/** 
 * Private data for event wrappers. 
 * @type {WeakMap&lt;Event, PrivateData&gt;} 
 * @private 
 */</span>
<span class="s1">const privateData = </span><span class="s3">new </span><span class="s1">WeakMap();</span>

<span class="s0">/** 
 * Cache for wrapper classes. 
 * @type {WeakMap&lt;Object, Function&gt;} 
 * @private 
 */</span>
<span class="s1">const wrappers = </span><span class="s3">new </span><span class="s1">WeakMap();</span>

<span class="s0">/** 
 * Get private data. 
 * @param {Event} event The event object to get private data. 
 * @returns {PrivateData} The private data of the event. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">pd(event) {</span>
    <span class="s1">const retv = privateData.get(event);</span>
    <span class="s1">console.assert(</span>
        <span class="s1">retv != </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s2">&quot;'this' is expected an Event object, but got&quot;</span><span class="s1">,</span>
        <span class="s1">event</span>
    <span class="s1">);</span>
    <span class="s3">return </span><span class="s1">retv</span>
<span class="s1">}</span>

<span class="s0">/** 
 * https://dom.spec.whatwg.org/#set-the-canceled-flag 
 * @param data {PrivateData} private data. 
 */</span>
<span class="s3">function </span><span class="s1">setCancelFlag(data) {</span>
    <span class="s3">if </span><span class="s1">(data.passiveListener != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s3">typeof </span><span class="s1">console !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s3">typeof </span><span class="s1">console.error === </span><span class="s2">&quot;function&quot;</span>
        <span class="s1">) {</span>
            <span class="s1">console.error(</span>
                <span class="s2">&quot;Unable to preventDefault inside passive event listener invocation.&quot;</span><span class="s1">,</span>
                <span class="s1">data.passiveListener</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">return</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!data.event.cancelable) {</span>
        <span class="s3">return</span>
    <span class="s1">}</span>

    <span class="s1">data.canceled = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">data.event.preventDefault === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s1">data.event.preventDefault();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * @see https://dom.spec.whatwg.org/#interface-event 
 * @private 
 */</span>
<span class="s0">/** 
 * The event wrapper. 
 * @constructor 
 * @param {EventTarget} eventTarget The event target of this dispatching. 
 * @param {Event|{type:string}} event The original event to wrap. 
 */</span>
<span class="s3">function </span><span class="s1">Event(eventTarget, event) {</span>
    <span class="s1">privateData.set(</span><span class="s3">this</span><span class="s1">, {</span>
        <span class="s1">eventTarget,</span>
        <span class="s1">event,</span>
        <span class="s1">eventPhase: </span><span class="s4">2</span><span class="s1">,</span>
        <span class="s1">currentTarget: eventTarget,</span>
        <span class="s1">canceled: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">stopped: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">immediateStopped: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">passiveListener: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">timeStamp: event.timeStamp || Date.now(),</span>
    <span class="s1">});</span>

    <span class="s0">// https://heycam.github.io/webidl/#Unforgeable</span>
    <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">&quot;isTrusted&quot;</span><span class="s1">, { value: </span><span class="s3">false</span><span class="s1">, enumerable: </span><span class="s3">true </span><span class="s1">});</span>

    <span class="s0">// Define accessors</span>
    <span class="s1">const keys = Object.keys(event);</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; keys.length; ++i) {</span>
        <span class="s1">const key = keys[i];</span>
        <span class="s3">if </span><span class="s1">(!(key </span><span class="s3">in this</span><span class="s1">)) {</span>
            <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, key, defineRedirectDescriptor(key));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// Should be enumerable, but class methods are not enumerable.</span>
<span class="s1">Event.prototype = {</span>
    <span class="s0">/** 
     * The type of this event. 
     * @type {string} 
     */</span>
    <span class="s1">get type() {</span>
        <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).event.type</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The target of this event. 
     * @type {EventTarget} 
     */</span>
    <span class="s1">get target() {</span>
        <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).eventTarget</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The target of this event. 
     * @type {EventTarget} 
     */</span>
    <span class="s1">get currentTarget() {</span>
        <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).currentTarget</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * @returns {EventTarget[]} The composed path of this event. 
     */</span>
    <span class="s1">composedPath() {</span>
        <span class="s1">const currentTarget = pd(</span><span class="s3">this</span><span class="s1">).currentTarget;</span>
        <span class="s3">if </span><span class="s1">(currentTarget == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">[currentTarget]</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Constant of NONE. 
     * @type {number} 
     */</span>
    <span class="s1">get NONE() {</span>
        <span class="s3">return </span><span class="s4">0</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Constant of CAPTURING_PHASE. 
     * @type {number} 
     */</span>
    <span class="s1">get CAPTURING_PHASE() {</span>
        <span class="s3">return </span><span class="s4">1</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Constant of AT_TARGET. 
     * @type {number} 
     */</span>
    <span class="s1">get AT_TARGET() {</span>
        <span class="s3">return </span><span class="s4">2</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Constant of BUBBLING_PHASE. 
     * @type {number} 
     */</span>
    <span class="s1">get BUBBLING_PHASE() {</span>
        <span class="s3">return </span><span class="s4">3</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The target of this event. 
     * @type {number} 
     */</span>
    <span class="s1">get eventPhase() {</span>
        <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).eventPhase</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Stop event bubbling. 
     * @returns {void} 
     */</span>
    <span class="s1">stopPropagation() {</span>
        <span class="s1">const data = pd(</span><span class="s3">this</span><span class="s1">);</span>

        <span class="s1">data.stopped = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">data.event.stopPropagation === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">data.event.stopPropagation();</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Stop event bubbling. 
     * @returns {void} 
     */</span>
    <span class="s1">stopImmediatePropagation() {</span>
        <span class="s1">const data = pd(</span><span class="s3">this</span><span class="s1">);</span>

        <span class="s1">data.stopped = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">data.immediateStopped = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">data.event.stopImmediatePropagation === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">data.event.stopImmediatePropagation();</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The flag to be bubbling. 
     * @type {boolean} 
     */</span>
    <span class="s1">get bubbles() {</span>
        <span class="s3">return </span><span class="s1">Boolean(pd(</span><span class="s3">this</span><span class="s1">).event.bubbles)</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The flag to be cancelable. 
     * @type {boolean} 
     */</span>
    <span class="s1">get cancelable() {</span>
        <span class="s3">return </span><span class="s1">Boolean(pd(</span><span class="s3">this</span><span class="s1">).event.cancelable)</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Cancel this event. 
     * @returns {void} 
     */</span>
    <span class="s1">preventDefault() {</span>
        <span class="s1">setCancelFlag(pd(</span><span class="s3">this</span><span class="s1">));</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The flag to indicate cancellation state. 
     * @type {boolean} 
     */</span>
    <span class="s1">get defaultPrevented() {</span>
        <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).canceled</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The flag to be composed. 
     * @type {boolean} 
     */</span>
    <span class="s1">get composed() {</span>
        <span class="s3">return </span><span class="s1">Boolean(pd(</span><span class="s3">this</span><span class="s1">).event.composed)</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The unix time of this event. 
     * @type {number} 
     */</span>
    <span class="s1">get timeStamp() {</span>
        <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).timeStamp</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The target of this event. 
     * @type {EventTarget} 
     * @deprecated 
     */</span>
    <span class="s1">get srcElement() {</span>
        <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).eventTarget</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The flag to stop event bubbling. 
     * @type {boolean} 
     * @deprecated 
     */</span>
    <span class="s1">get cancelBubble() {</span>
        <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).stopped</span>
    <span class="s1">},</span>
    <span class="s1">set cancelBubble(value) {</span>
        <span class="s3">if </span><span class="s1">(!value) {</span>
            <span class="s3">return</span>
        <span class="s1">}</span>
        <span class="s1">const data = pd(</span><span class="s3">this</span><span class="s1">);</span>

        <span class="s1">data.stopped = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">data.event.cancelBubble === </span><span class="s2">&quot;boolean&quot;</span><span class="s1">) {</span>
            <span class="s1">data.event.cancelBubble = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * The flag to indicate cancellation state. 
     * @type {boolean} 
     * @deprecated 
     */</span>
    <span class="s1">get returnValue() {</span>
        <span class="s3">return </span><span class="s1">!pd(</span><span class="s3">this</span><span class="s1">).canceled</span>
    <span class="s1">},</span>
    <span class="s1">set returnValue(value) {</span>
        <span class="s3">if </span><span class="s1">(!value) {</span>
            <span class="s1">setCancelFlag(pd(</span><span class="s3">this</span><span class="s1">));</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Initialize this event object. But do nothing under event dispatching. 
     * @param {string} type The event type. 
     * @param {boolean} [bubbles=false] The flag to be possible to bubble up. 
     * @param {boolean} [cancelable=false] The flag to be possible to cancel. 
     * @deprecated 
     */</span>
    <span class="s1">initEvent() {</span>
        <span class="s0">// Do nothing.</span>
    <span class="s1">},</span>
<span class="s1">};</span>

<span class="s0">// `constructor` is not enumerable.</span>
<span class="s1">Object.defineProperty(Event.prototype, </span><span class="s2">&quot;constructor&quot;</span><span class="s1">, {</span>
    <span class="s1">value: Event,</span>
    <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">writable: </span><span class="s3">true</span><span class="s1">,</span>
<span class="s1">});</span>

<span class="s0">// Ensure `event instanceof window.Event` is `true`.</span>
<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">window !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">window.Event !== </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
    <span class="s1">Object.setPrototypeOf(Event.prototype, window.Event.prototype);</span>

    <span class="s0">// Make association for wrappers.</span>
    <span class="s1">wrappers.set(window.Event.prototype, Event);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Get the property descriptor to redirect a given property. 
 * @param {string} key Property name to define property descriptor. 
 * @returns {PropertyDescriptor} The property descriptor to redirect the property. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">defineRedirectDescriptor(key) {</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">get() {</span>
            <span class="s3">return </span><span class="s1">pd(</span><span class="s3">this</span><span class="s1">).event[key]</span>
        <span class="s1">},</span>
        <span class="s1">set(value) {</span>
            <span class="s1">pd(</span><span class="s3">this</span><span class="s1">).event[key] = value;</span>
        <span class="s1">},</span>
        <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Get the property descriptor to call a given method property. 
 * @param {string} key Property name to define property descriptor. 
 * @returns {PropertyDescriptor} The property descriptor to call the method property. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">defineCallDescriptor(key) {</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">value() {</span>
            <span class="s1">const event = pd(</span><span class="s3">this</span><span class="s1">).event;</span>
            <span class="s3">return </span><span class="s1">event[key].apply(event, arguments)</span>
        <span class="s1">},</span>
        <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Define new wrapper class. 
 * @param {Function} BaseEvent The base wrapper class. 
 * @param {Object} proto The prototype of the original event. 
 * @returns {Function} The defined wrapper class. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">defineWrapper(BaseEvent, proto) {</span>
    <span class="s1">const keys = Object.keys(proto);</span>
    <span class="s3">if </span><span class="s1">(keys.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">BaseEvent</span>
    <span class="s1">}</span>

    <span class="s0">/** CustomEvent */</span>
    <span class="s3">function </span><span class="s1">CustomEvent(eventTarget, event) {</span>
        <span class="s1">BaseEvent.call(</span><span class="s3">this</span><span class="s1">, eventTarget, event);</span>
    <span class="s1">}</span>

    <span class="s1">CustomEvent.prototype = Object.create(BaseEvent.prototype, {</span>
        <span class="s1">constructor: { value: CustomEvent, configurable: </span><span class="s3">true</span><span class="s1">, writable: </span><span class="s3">true </span><span class="s1">},</span>
    <span class="s1">});</span>

    <span class="s0">// Define accessors.</span>
    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; keys.length; ++i) {</span>
        <span class="s1">const key = keys[i];</span>
        <span class="s3">if </span><span class="s1">(!(key </span><span class="s3">in </span><span class="s1">BaseEvent.prototype)) {</span>
            <span class="s1">const descriptor = Object.getOwnPropertyDescriptor(proto, key);</span>
            <span class="s1">const isFunc = </span><span class="s3">typeof </span><span class="s1">descriptor.value === </span><span class="s2">&quot;function&quot;</span><span class="s1">;</span>
            <span class="s1">Object.defineProperty(</span>
                <span class="s1">CustomEvent.prototype,</span>
                <span class="s1">key,</span>
                <span class="s1">isFunc</span>
                    <span class="s1">? defineCallDescriptor(key)</span>
                    <span class="s1">: defineRedirectDescriptor(key)</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">CustomEvent</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Get the wrapper class of a given prototype. 
 * @param {Object} proto The prototype of the original event to get its wrapper. 
 * @returns {Function} The wrapper class. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">getWrapper(proto) {</span>
    <span class="s3">if </span><span class="s1">(proto == </span><span class="s3">null </span><span class="s1">|| proto === Object.prototype) {</span>
        <span class="s3">return </span><span class="s1">Event</span>
    <span class="s1">}</span>

    <span class="s1">let wrapper = wrappers.get(proto);</span>
    <span class="s3">if </span><span class="s1">(wrapper == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);</span>
        <span class="s1">wrappers.set(proto, wrapper);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">wrapper</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Wrap a given event to management a dispatching. 
 * @param {EventTarget} eventTarget The event target of this dispatching. 
 * @param {Object} event The event to wrap. 
 * @returns {Event} The wrapper instance. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">wrapEvent(eventTarget, event) {</span>
    <span class="s1">const Wrapper = getWrapper(Object.getPrototypeOf(event));</span>
    <span class="s3">return new </span><span class="s1">Wrapper(eventTarget, event)</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Get the immediateStopped flag of a given event. 
 * @param {Event} event The event to get. 
 * @returns {boolean} The flag to stop propagation immediately. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">isStopped(event) {</span>
    <span class="s3">return </span><span class="s1">pd(event).immediateStopped</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Set the current event phase of a given event. 
 * @param {Event} event The event to set current target. 
 * @param {number} eventPhase New event phase. 
 * @returns {void} 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">setEventPhase(event, eventPhase) {</span>
    <span class="s1">pd(event).eventPhase = eventPhase;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Set the current target of a given event. 
 * @param {Event} event The event to set current target. 
 * @param {EventTarget|null} currentTarget New current target. 
 * @returns {void} 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">setCurrentTarget(event, currentTarget) {</span>
    <span class="s1">pd(event).currentTarget = currentTarget;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Set a passive listener of a given event. 
 * @param {Event} event The event to set current target. 
 * @param {Function|null} passiveListener New passive listener. 
 * @returns {void} 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">setPassiveListener(event, passiveListener) {</span>
    <span class="s1">pd(event).passiveListener = passiveListener;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * @typedef {object} ListenerNode 
 * @property {Function} listener 
 * @property {1|2|3} listenerType 
 * @property {boolean} passive 
 * @property {boolean} once 
 * @property {ListenerNode|null} next 
 * @private 
 */</span>

<span class="s0">/** 
 * @type {WeakMap&lt;object, Map&lt;string, ListenerNode&gt;&gt;} 
 * @private 
 */</span>
<span class="s1">const listenersMap = </span><span class="s3">new </span><span class="s1">WeakMap();</span>

<span class="s0">// Listener types</span>
<span class="s1">const CAPTURE = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">const BUBBLE = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s1">const ATTRIBUTE = </span><span class="s4">3</span><span class="s1">;</span>

<span class="s0">/** 
 * Check whether a given value is an object or not. 
 * @param {any} x The value to check. 
 * @returns {boolean} `true` if the value is an object. 
 */</span>
<span class="s3">function </span><span class="s1">isObject(x) {</span>
    <span class="s3">return </span><span class="s1">x !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">x === </span><span class="s2">&quot;object&quot; </span><span class="s0">//eslint-disable-line no-restricted-syntax</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Get listeners. 
 * @param {EventTarget} eventTarget The event target to get. 
 * @returns {Map&lt;string, ListenerNode&gt;} The listeners. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">getListeners(eventTarget) {</span>
    <span class="s1">const listeners = listenersMap.get(eventTarget);</span>
    <span class="s3">if </span><span class="s1">(listeners == </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">throw new </span><span class="s1">TypeError(</span>
            <span class="s2">&quot;'this' is expected an EventTarget object, but got another value.&quot;</span>
        <span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">listeners</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Get the property descriptor for the event attribute of a given event. 
 * @param {string} eventName The event name to get property descriptor. 
 * @returns {PropertyDescriptor} The property descriptor. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">defineEventAttributeDescriptor(eventName) {</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">get() {</span>
            <span class="s1">const listeners = getListeners(</span><span class="s3">this</span><span class="s1">);</span>
            <span class="s1">let node = listeners.get(eventName);</span>
            <span class="s3">while </span><span class="s1">(node != </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(node.listenerType === ATTRIBUTE) {</span>
                    <span class="s3">return </span><span class="s1">node.listener</span>
                <span class="s1">}</span>
                <span class="s1">node = node.next;</span>
            <span class="s1">}</span>
            <span class="s3">return null</span>
        <span class="s1">},</span>

        <span class="s1">set(listener) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">listener !== </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp; !isObject(listener)) {</span>
                <span class="s1">listener = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// eslint-disable-line no-param-reassign</span>
            <span class="s1">}</span>
            <span class="s1">const listeners = getListeners(</span><span class="s3">this</span><span class="s1">);</span>

            <span class="s0">// Traverse to the tail while removing old value.</span>
            <span class="s1">let prev = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">let node = listeners.get(eventName);</span>
            <span class="s3">while </span><span class="s1">(node != </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(node.listenerType === ATTRIBUTE) {</span>
                    <span class="s0">// Remove old value.</span>
                    <span class="s3">if </span><span class="s1">(prev !== </span><span class="s3">null</span><span class="s1">) {</span>
                        <span class="s1">prev.next = node.next;</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.next !== </span><span class="s3">null</span><span class="s1">) {</span>
                        <span class="s1">listeners.set(eventName, node.next);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">listeners.</span><span class="s3">delete</span><span class="s1">(eventName);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">prev = node;</span>
                <span class="s1">}</span>

                <span class="s1">node = node.next;</span>
            <span class="s1">}</span>

            <span class="s0">// Add new value.</span>
            <span class="s3">if </span><span class="s1">(listener !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">const newNode = {</span>
                    <span class="s1">listener,</span>
                    <span class="s1">listenerType: ATTRIBUTE,</span>
                    <span class="s1">passive: </span><span class="s3">false</span><span class="s1">,</span>
                    <span class="s1">once: </span><span class="s3">false</span><span class="s1">,</span>
                    <span class="s1">next: </span><span class="s3">null</span><span class="s1">,</span>
                <span class="s1">};</span>
                <span class="s3">if </span><span class="s1">(prev === </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">listeners.set(eventName, newNode);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">prev.next = newNode;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Define an event attribute (e.g. `eventTarget.onclick`). 
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite. 
 * @param {string} eventName The event name to define. 
 * @returns {void} 
 */</span>
<span class="s3">function </span><span class="s1">defineEventAttribute(eventTargetPrototype, eventName) {</span>
    <span class="s1">Object.defineProperty(</span>
        <span class="s1">eventTargetPrototype,</span>
        <span class="s1">`on${eventName}`,</span>
        <span class="s1">defineEventAttributeDescriptor(eventName)</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Define a custom EventTarget with event attributes. 
 * @param {string[]} eventNames Event names for event attributes. 
 * @returns {EventTarget} The custom EventTarget. 
 * @private 
 */</span>
<span class="s3">function </span><span class="s1">defineCustomEventTarget(eventNames) {</span>
    <span class="s0">/** CustomEventTarget */</span>
    <span class="s3">function </span><span class="s1">CustomEventTarget() {</span>
        <span class="s1">EventTarget.call(</span><span class="s3">this</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">CustomEventTarget.prototype = Object.create(EventTarget.prototype, {</span>
        <span class="s1">constructor: {</span>
            <span class="s1">value: CustomEventTarget,</span>
            <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s1">writable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">});</span>

    <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; eventNames.length; ++i) {</span>
        <span class="s1">defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">CustomEventTarget</span>
<span class="s1">}</span>

<span class="s0">/** 
 * EventTarget. 
 * 
 * - This is constructor if no arguments. 
 * - This is a function which returns a CustomEventTarget constructor if there are arguments. 
 * 
 * For example: 
 * 
 *     class A extends EventTarget {} 
 *     class B extends EventTarget(&quot;message&quot;) {} 
 *     class C extends EventTarget(&quot;message&quot;, &quot;error&quot;) {} 
 *     class D extends EventTarget([&quot;message&quot;, &quot;error&quot;]) {} 
 */</span>
<span class="s3">function </span><span class="s1">EventTarget() {</span>
    <span class="s0">/*eslint-disable consistent-return */</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this instanceof </span><span class="s1">EventTarget) {</span>
        <span class="s1">listenersMap.set(</span><span class="s3">this</span><span class="s1">, </span><span class="s3">new </span><span class="s1">Map());</span>
        <span class="s3">return</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(arguments.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; Array.isArray(arguments[</span><span class="s4">0</span><span class="s1">])) {</span>
        <span class="s3">return </span><span class="s1">defineCustomEventTarget(arguments[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(arguments.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">const types = </span><span class="s3">new </span><span class="s1">Array(arguments.length);</span>
        <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; arguments.length; ++i) {</span>
            <span class="s1">types[i] = arguments[i];</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">defineCustomEventTarget(types)</span>
    <span class="s1">}</span>
    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Cannot call a class as a function&quot;</span><span class="s1">)</span>
    <span class="s0">/*eslint-enable consistent-return */</span>
<span class="s1">}</span>

<span class="s0">// Should be enumerable, but class methods are not enumerable.</span>
<span class="s1">EventTarget.prototype = {</span>
    <span class="s0">/** 
     * Add a given listener to this event target. 
     * @param {string} eventName The event name to add. 
     * @param {Function} listener The listener to add. 
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener. 
     * @returns {void} 
     */</span>
    <span class="s1">addEventListener(eventName, listener, options) {</span>
        <span class="s3">if </span><span class="s1">(listener == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">listener !== </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp; !isObject(listener)) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;'listener' should be a function or an object.&quot;</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s1">const listeners = getListeners(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const optionsIsObj = isObject(options);</span>
        <span class="s1">const capture = optionsIsObj</span>
            <span class="s1">? Boolean(options.capture)</span>
            <span class="s1">: Boolean(options);</span>
        <span class="s1">const listenerType = capture ? CAPTURE : BUBBLE;</span>
        <span class="s1">const newNode = {</span>
            <span class="s1">listener,</span>
            <span class="s1">listenerType,</span>
            <span class="s1">passive: optionsIsObj &amp;&amp; Boolean(options.passive),</span>
            <span class="s1">once: optionsIsObj &amp;&amp; Boolean(options.once),</span>
            <span class="s1">next: </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s1">};</span>

        <span class="s0">// Set it as the first node if the first node is null.</span>
        <span class="s1">let node = listeners.get(eventName);</span>
        <span class="s3">if </span><span class="s1">(node === undefined) {</span>
            <span class="s1">listeners.set(eventName, newNode);</span>
            <span class="s3">return</span>
        <span class="s1">}</span>

        <span class="s0">// Traverse to the tail while checking duplication..</span>
        <span class="s1">let prev = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">while </span><span class="s1">(node != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">node.listener === listener &amp;&amp;</span>
                <span class="s1">node.listenerType === listenerType</span>
            <span class="s1">) {</span>
                <span class="s0">// Should ignore duplication.</span>
                <span class="s3">return</span>
            <span class="s1">}</span>
            <span class="s1">prev = node;</span>
            <span class="s1">node = node.next;</span>
        <span class="s1">}</span>

        <span class="s0">// Add it.</span>
        <span class="s1">prev.next = newNode;</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Remove a given listener from this event target. 
     * @param {string} eventName The event name to remove. 
     * @param {Function} listener The listener to remove. 
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener. 
     * @returns {void} 
     */</span>
    <span class="s1">removeEventListener(eventName, listener, options) {</span>
        <span class="s3">if </span><span class="s1">(listener == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span>
        <span class="s1">}</span>

        <span class="s1">const listeners = getListeners(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const capture = isObject(options)</span>
            <span class="s1">? Boolean(options.capture)</span>
            <span class="s1">: Boolean(options);</span>
        <span class="s1">const listenerType = capture ? CAPTURE : BUBBLE;</span>

        <span class="s1">let prev = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">let node = listeners.get(eventName);</span>
        <span class="s3">while </span><span class="s1">(node != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">node.listener === listener &amp;&amp;</span>
                <span class="s1">node.listenerType === listenerType</span>
            <span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(prev !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">prev.next = node.next;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.next !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">listeners.set(eventName, node.next);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">listeners.</span><span class="s3">delete</span><span class="s1">(eventName);</span>
                <span class="s1">}</span>
                <span class="s3">return</span>
            <span class="s1">}</span>

            <span class="s1">prev = node;</span>
            <span class="s1">node = node.next;</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Dispatch a given event. 
     * @param {Event|{type:string}} event The event to dispatch. 
     * @returns {boolean} `false` if canceled. 
     */</span>
    <span class="s1">dispatchEvent(event) {</span>
        <span class="s3">if </span><span class="s1">(event == </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">event.type !== </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'&quot;event.type&quot; should be a string.'</span><span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s0">// If listeners aren't registered, terminate.</span>
        <span class="s1">const listeners = getListeners(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">const eventName = event.type;</span>
        <span class="s1">let node = listeners.get(eventName);</span>
        <span class="s3">if </span><span class="s1">(node == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return true</span>
        <span class="s1">}</span>

        <span class="s0">// Since we cannot rewrite several properties, so wrap object.</span>
        <span class="s1">const wrappedEvent = wrapEvent(</span><span class="s3">this</span><span class="s1">, event);</span>

        <span class="s0">// This doesn't process capturing phase and bubbling phase.</span>
        <span class="s0">// This isn't participating in a tree.</span>
        <span class="s1">let prev = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">while </span><span class="s1">(node != </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// Remove this listener if it's once</span>
            <span class="s3">if </span><span class="s1">(node.once) {</span>
                <span class="s3">if </span><span class="s1">(prev !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">prev.next = node.next;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.next !== </span><span class="s3">null</span><span class="s1">) {</span>
                    <span class="s1">listeners.set(eventName, node.next);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">listeners.</span><span class="s3">delete</span><span class="s1">(eventName);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">prev = node;</span>
            <span class="s1">}</span>

            <span class="s0">// Call this listener</span>
            <span class="s1">setPassiveListener(</span>
                <span class="s1">wrappedEvent,</span>
                <span class="s1">node.passive ? node.listener : </span><span class="s3">null</span>
            <span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">node.listener === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s1">node.listener.call(</span><span class="s3">this</span><span class="s1">, wrappedEvent);</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                    <span class="s3">if </span><span class="s1">(</span>
                        <span class="s3">typeof </span><span class="s1">console !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp;</span>
                        <span class="s3">typeof </span><span class="s1">console.error === </span><span class="s2">&quot;function&quot;</span>
                    <span class="s1">) {</span>
                        <span class="s1">console.error(err);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
                <span class="s1">node.listenerType !== ATTRIBUTE &amp;&amp;</span>
                <span class="s3">typeof </span><span class="s1">node.listener.handleEvent === </span><span class="s2">&quot;function&quot;</span>
            <span class="s1">) {</span>
                <span class="s1">node.listener.handleEvent(wrappedEvent);</span>
            <span class="s1">}</span>

            <span class="s0">// Break if `event.stopImmediatePropagation` was called.</span>
            <span class="s3">if </span><span class="s1">(isStopped(wrappedEvent)) {</span>
                <span class="s3">break</span>
            <span class="s1">}</span>

            <span class="s1">node = node.next;</span>
        <span class="s1">}</span>
        <span class="s1">setPassiveListener(wrappedEvent, </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">setEventPhase(wrappedEvent, </span><span class="s4">0</span><span class="s1">);</span>
        <span class="s1">setCurrentTarget(wrappedEvent, </span><span class="s3">null</span><span class="s1">);</span>

        <span class="s3">return </span><span class="s1">!wrappedEvent.defaultPrevented</span>
    <span class="s1">},</span>
<span class="s1">};</span>

<span class="s0">// `constructor` is not enumerable.</span>
<span class="s1">Object.defineProperty(EventTarget.prototype, </span><span class="s2">&quot;constructor&quot;</span><span class="s1">, {</span>
    <span class="s1">value: EventTarget,</span>
    <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">writable: </span><span class="s3">true</span><span class="s1">,</span>
<span class="s1">});</span>

<span class="s0">// Ensure `eventTarget instanceof window.EventTarget` is `true`.</span>
<span class="s3">if </span><span class="s1">(</span>
    <span class="s3">typeof </span><span class="s1">window !== </span><span class="s2">&quot;undefined&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s3">typeof </span><span class="s1">window.EventTarget !== </span><span class="s2">&quot;undefined&quot;</span>
<span class="s1">) {</span>
    <span class="s1">Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);</span>
<span class="s1">}</span>

<span class="s1">exports.defineEventAttribute = defineEventAttribute;</span>
<span class="s1">exports.EventTarget = EventTarget;</span>
<span class="s1">exports.</span><span class="s3">default </span><span class="s1">= EventTarget;</span>

<span class="s1">module.exports = EventTarget</span>
<span class="s1">module.exports.EventTarget = module.exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = EventTarget</span>
<span class="s1">module.exports.defineEventAttribute = defineEventAttribute</span>
<span class="s0">//# sourceMappingURL=event-target-shim.js.map</span>
</pre>
</body>
</html>
<html>
<head>
<title>estree.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
estree.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_parseError&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnenumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;toESTreeLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;ESTreeParserMixin&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;tokens&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRegExpLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;estreeParseLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBigIntLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;bigInt&quot;</span><span class="s0">,</span><span class="s1">&quot;BigInt&quot;</span><span class="s0">,</span><span class="s1">&quot;_unused&quot;</span><span class="s0">,</span><span class="s1">&quot;bigint&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDecimalLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;decimal&quot;</span><span class="s0">,</span><span class="s1">&quot;parseLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;parseStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;parseNumericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;parseNullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBooleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;directiveToStmt&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionValue&quot;</span><span class="s0">,</span><span class="s1">&quot;stmt&quot;</span><span class="s0">,</span><span class="s1">&quot;rawValue&quot;</span><span class="s0">,</span><span class="s1">&quot;initFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;checkDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;getObjectOrClassMethodParams&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidDirective&quot;</span><span class="s0">,</span><span class="s1">&quot;_stmt$expression$extr&quot;</span><span class="s0">,</span><span class="s1">&quot;parenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBlockBody&quot;</span><span class="s0">,</span><span class="s1">&quot;allowDirectives&quot;</span><span class="s0">,</span><span class="s1">&quot;topLevel&quot;</span><span class="s0">,</span><span class="s1">&quot;afterBlockParse&quot;</span><span class="s0">,</span><span class="s1">&quot;directiveStatements&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;pushClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;classBody&quot;</span><span class="s0">,</span><span class="s1">&quot;isGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;isConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;allowsDirectSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;getPluginOption&quot;</span><span class="s0">,</span><span class="s1">&quot;convertPrivateNameToPrivateIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrivateNameSV&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFunctionBody&quot;</span><span class="s0">,</span><span class="s1">&quot;allowExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;allowDirectSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;inClassScope&quot;</span><span class="s0">,</span><span class="s1">&quot;funcNode&quot;</span><span class="s0">,</span><span class="s1">&quot;startNode&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;finishNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parseClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;propertyNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parseClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;parseObjectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;isAccessor&quot;</span><span class="s0">,</span><span class="s1">&quot;shorthand&quot;</span><span class="s0">,</span><span class="s1">&quot;parseObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;startLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;refExpressionErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidLVal&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnparenthesizedInAssign&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignable&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;toAssignable&quot;</span><span class="s0">,</span><span class="s1">&quot;isLHS&quot;</span><span class="s0">,</span><span class="s1">&quot;classScope&quot;</span><span class="s0">,</span><span class="s1">&quot;usePrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;toAssignableObjectExpressionProp&quot;</span><span class="s0">,</span><span class="s1">&quot;isLast&quot;</span><span class="s0">,</span><span class="s1">&quot;raise&quot;</span><span class="s0">,</span><span class="s1">&quot;Errors&quot;</span><span class="s0">,</span><span class="s1">&quot;PatternHasAccessor&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;PatternHasMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;finishCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;unfinished&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$arguments$&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;toReferencedArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;parseExport&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;exportStartLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;lastTokStartLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;_declaration$decorato&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;resetStartLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;parseSubscript&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;noCalls&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalChainMember&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;stop&quot;</span><span class="s0">,</span><span class="s1">&quot;chain&quot;</span><span class="s0">,</span><span class="s1">&quot;startNodeAtNode&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPropertyAsPrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;finishNodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;endLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;resetEndLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;lastTokEndLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/plugins/estree.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { TokenType } from </span><span class="s3">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Parser from </span><span class="s3">\&quot;</span><span class="s1">../parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s3">\&quot;</span><span class="s1">../parser/util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as N from </span><span class="s3">\&quot;</span><span class="s1">../types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Node as NodeType, NodeBase, File } from </span><span class="s3">\&quot;</span><span class="s1">../types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Position } from </span><span class="s3">\&quot;</span><span class="s1">../util/location</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Errors } from </span><span class="s3">\&quot;</span><span class="s1">../parse-error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Undone } from </span><span class="s3">\&quot;</span><span class="s1">../parser/node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { BindingTypes } from </span><span class="s3">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const { defineProperty } = Object;</span><span class="s3">\n</span><span class="s1">const toUnenumerable = (object: any, key: string) =&gt;</span><span class="s3">\n  </span><span class="s1">defineProperty(object, key, { enumerable: false, value: object[key] });</span><span class="s3">\n\n</span><span class="s1">function toESTreeLocation(node: any) {</span><span class="s3">\n  </span><span class="s1">node.loc.start &amp;&amp; toUnenumerable(node.loc.start, </span><span class="s3">\&quot;</span><span class="s1">index</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">node.loc.end &amp;&amp; toUnenumerable(node.loc.end, </span><span class="s3">\&quot;</span><span class="s1">index</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default (superClass: typeof Parser) =&gt;</span><span class="s3">\n  </span><span class="s1">class ESTreeParserMixin extends superClass implements Parser {</span><span class="s3">\n    </span><span class="s1">parse(): File {</span><span class="s3">\n      </span><span class="s1">const file = toESTreeLocation(super.parse());</span><span class="s3">\n\n      </span><span class="s1">if (this.options.tokens) {</span><span class="s3">\n        </span><span class="s1">file.tokens = file.tokens.map(toESTreeLocation);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return file;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s3">\n    </span><span class="s1">parseRegExpLiteral({ pattern, flags }): N.EstreeRegExpLiteral {</span><span class="s3">\n      </span><span class="s1">let regex: RegExp | null = null;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">regex = new RegExp(pattern, flags);</span><span class="s3">\n      </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">// In environments that don't support these flags value will</span><span class="s3">\n        </span><span class="s1">// be null as the regex can't be represented natively.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const node = this.estreeParseLiteral&lt;N.EstreeRegExpLiteral&gt;(regex);</span><span class="s3">\n      </span><span class="s1">node.regex = { pattern, flags };</span><span class="s3">\n\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s3">\n    </span><span class="s1">parseBigIntLiteral(value: any): N.Node {</span><span class="s3">\n      </span><span class="s1">// https://github.com/estree/estree/blob/master/es2020.md#bigintliteral</span><span class="s3">\n      </span><span class="s1">let bigInt: BigInt | null;</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">bigInt = BigInt(value);</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">bigInt = null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const node = this.estreeParseLiteral&lt;N.EstreeBigIntLiteral&gt;(bigInt);</span><span class="s3">\n      </span><span class="s1">node.bigint = String(node.value || value);</span><span class="s3">\n\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s3">\n    </span><span class="s1">parseDecimalLiteral(value: any): N.Node {</span><span class="s3">\n      </span><span class="s1">// https://github.com/estree/estree/blob/master/experimental/decimal.md</span><span class="s3">\n      </span><span class="s1">// todo: use BigDecimal when node supports it.</span><span class="s3">\n      </span><span class="s1">const decimal: null = null;</span><span class="s3">\n      </span><span class="s1">const node = this.estreeParseLiteral(decimal);</span><span class="s3">\n      </span><span class="s1">node.decimal = String(node.value || value);</span><span class="s3">\n\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">estreeParseLiteral&lt;T extends N.Node&gt;(value: any) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s3">\n      </span><span class="s1">return this.parseLiteral&lt;T&gt;(value, </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s3">\n    </span><span class="s1">parseStringLiteral(value: any): N.Node {</span><span class="s3">\n      </span><span class="s1">return this.estreeParseLiteral(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseNumericLiteral(value: any): any {</span><span class="s3">\n      </span><span class="s1">return this.estreeParseLiteral(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s3">\n    </span><span class="s1">parseNullLiteral(): N.Node {</span><span class="s3">\n      </span><span class="s1">return this.estreeParseLiteral(null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseBooleanLiteral(value: boolean): N.BooleanLiteral {</span><span class="s3">\n      </span><span class="s1">return this.estreeParseLiteral(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Cast a Directive to an ExpressionStatement. Mutates the input Directive.</span><span class="s3">\n    </span><span class="s1">directiveToStmt(directive: N.Directive): N.ExpressionStatement {</span><span class="s3">\n      </span><span class="s1">const expression = directive.value as any as N.EstreeLiteral;</span><span class="s3">\n      </span><span class="s1">delete directive.value;</span><span class="s3">\n\n      </span><span class="s1">expression.type = </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error N.EstreeLiteral.raw is not defined.</span><span class="s3">\n      </span><span class="s1">expression.raw = expression.extra.raw;</span><span class="s3">\n      </span><span class="s1">expression.value = expression.extra.expressionValue;</span><span class="s3">\n\n      </span><span class="s1">const stmt = directive as any as N.ExpressionStatement;</span><span class="s3">\n      </span><span class="s1">stmt.type = </span><span class="s3">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">stmt.expression = expression;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error N.ExpressionStatement.directive is not defined</span><span class="s3">\n      </span><span class="s1">stmt.directive = expression.extra.rawValue;</span><span class="s3">\n\n      </span><span class="s1">delete expression.extra;</span><span class="s3">\n\n      </span><span class="s1">return stmt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// ==================================</span><span class="s3">\n    </span><span class="s1">// Overrides</span><span class="s3">\n    </span><span class="s1">// ==================================</span><span class="s3">\n\n    </span><span class="s1">initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {</span><span class="s3">\n      </span><span class="s1">super.initFunction(node, isAsync);</span><span class="s3">\n      </span><span class="s1">node.expression = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">checkDeclaration(node: N.Pattern | N.ObjectProperty): void {</span><span class="s3">\n      </span><span class="s1">if (node != null &amp;&amp; this.isObjectProperty(node)) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error plugin typings</span><span class="s3">\n        </span><span class="s1">this.checkDeclaration((node as unknown as N.EstreeProperty).value);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">super.checkDeclaration(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {</span><span class="s3">\n      </span><span class="s1">return (method as any as N.EstreeProperty | N.EstreeMethodDefinition)</span><span class="s3">\n        </span><span class="s1">.value.params;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">isValidDirective(stmt: N.Statement): boolean {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">stmt.type === </span><span class="s3">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">stmt.expression.type === </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof stmt.expression.value === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">!stmt.expression.extra?.parenthesized</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseBlockBody(</span><span class="s3">\n      </span><span class="s1">node: N.BlockStatementLike,</span><span class="s3">\n      </span><span class="s1">allowDirectives: boolean | undefined | null,</span><span class="s3">\n      </span><span class="s1">topLevel: boolean,</span><span class="s3">\n      </span><span class="s1">end: TokenType,</span><span class="s3">\n      </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s3">\n    </span><span class="s1">): void {</span><span class="s3">\n      </span><span class="s1">super.parseBlockBody(</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">allowDirectives,</span><span class="s3">\n        </span><span class="s1">topLevel,</span><span class="s3">\n        </span><span class="s1">end,</span><span class="s3">\n        </span><span class="s1">afterBlockParse,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const directiveStatements = node.directives.map(d =&gt;</span><span class="s3">\n        </span><span class="s1">this.directiveToStmt(d),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error estree plugin typings</span><span class="s3">\n      </span><span class="s1">node.body = directiveStatements.concat(node.body);</span><span class="s3">\n      </span><span class="s1">delete node.directives;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">pushClassMethod(</span><span class="s3">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s3">\n      </span><span class="s1">method: N.ClassMethod,</span><span class="s3">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s3">\n      </span><span class="s1">isAsync: boolean,</span><span class="s3">\n      </span><span class="s1">isConstructor: boolean,</span><span class="s3">\n      </span><span class="s1">allowsDirectSuper: boolean,</span><span class="s3">\n    </span><span class="s1">): void {</span><span class="s3">\n      </span><span class="s1">this.parseMethod(</span><span class="s3">\n        </span><span class="s1">method,</span><span class="s3">\n        </span><span class="s1">isGenerator,</span><span class="s3">\n        </span><span class="s1">isAsync,</span><span class="s3">\n        </span><span class="s1">isConstructor,</span><span class="s3">\n        </span><span class="s1">allowsDirectSuper,</span><span class="s3">\n        \&quot;</span><span class="s1">ClassMethod</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">true,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (method.typeParameters) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s3">\n        </span><span class="s1">method.value.typeParameters = method.typeParameters;</span><span class="s3">\n        </span><span class="s1">delete method.typeParameters;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">classBody.body.push(method);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parsePrivateName(): any {</span><span class="s3">\n      </span><span class="s1">const node = super.parsePrivateName();</span><span class="s3">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">classFeatures</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this.convertPrivateNameToPrivateIdentifier(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">convertPrivateNameToPrivateIdentifier(</span><span class="s3">\n      </span><span class="s1">node: N.PrivateName,</span><span class="s3">\n    </span><span class="s1">): N.EstreePrivateIdentifier {</span><span class="s3">\n      </span><span class="s1">const name = super.getPrivateNameSV(node);</span><span class="s3">\n      </span><span class="s1">node = node as any;</span><span class="s3">\n      </span><span class="s1">delete node.id;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s3">\n      </span><span class="s1">node.name = name;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s3">\n      </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return node as unknown as N.EstreePrivateIdentifier;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">isPrivateName(node: N.Node): boolean {</span><span class="s3">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">classFeatures</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">return super.isPrivateName(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return node.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">getPrivateNameSV(node: N.Node): string {</span><span class="s3">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">classFeatures</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">return super.getPrivateNameSV(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return node.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error plugin may override interfaces</span><span class="s3">\n    </span><span class="s1">parseLiteral&lt;T extends N.Literal&gt;(value: any, type: T[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">]): T {</span><span class="s3">\n      </span><span class="s1">const node = super.parseLiteral&lt;T&gt;(value, type);</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s3">\n      </span><span class="s1">node.raw = node.extra.raw;</span><span class="s3">\n      </span><span class="s1">delete node.extra;</span><span class="s3">\n\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseFunctionBody(</span><span class="s3">\n      </span><span class="s1">node: N.Function,</span><span class="s3">\n      </span><span class="s1">allowExpression?: boolean | null,</span><span class="s3">\n      </span><span class="s1">isMethod: boolean = false,</span><span class="s3">\n    </span><span class="s1">): void {</span><span class="s3">\n      </span><span class="s1">super.parseFunctionBody(node, allowExpression, isMethod);</span><span class="s3">\n      </span><span class="s1">node.expression = node.body.type !== </span><span class="s3">\&quot;</span><span class="s1">BlockStatement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error plugin may override interfaces</span><span class="s3">\n    </span><span class="s1">parseMethod&lt;</span><span class="s3">\n      </span><span class="s1">T extends N.ClassPrivateMethod | N.ObjectMethod | N.ClassMethod,</span><span class="s3">\n    </span><span class="s1">&gt;(</span><span class="s3">\n      </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s3">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s3">\n      </span><span class="s1">isAsync: boolean,</span><span class="s3">\n      </span><span class="s1">isConstructor: boolean,</span><span class="s3">\n      </span><span class="s1">allowDirectSuper: boolean,</span><span class="s3">\n      </span><span class="s1">type: T[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n      </span><span class="s1">inClassScope: boolean = false,</span><span class="s3">\n    </span><span class="s1">): N.EstreeMethodDefinition {</span><span class="s3">\n      </span><span class="s1">let funcNode = this.startNode&lt;N.MethodLike&gt;();</span><span class="s3">\n      </span><span class="s1">funcNode.kind = node.kind; // provide kind, so super method correctly sets state</span><span class="s3">\n      </span><span class="s1">funcNode = super.parseMethod(</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n        </span><span class="s1">funcNode,</span><span class="s3">\n        </span><span class="s1">isGenerator,</span><span class="s3">\n        </span><span class="s1">isAsync,</span><span class="s3">\n        </span><span class="s1">isConstructor,</span><span class="s3">\n        </span><span class="s1">allowDirectSuper,</span><span class="s3">\n        </span><span class="s1">type,</span><span class="s3">\n        </span><span class="s1">inClassScope,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s3">\n      </span><span class="s1">funcNode.type = </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">delete funcNode.kind;</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s3">\n      </span><span class="s1">node.value = funcNode;</span><span class="s3">\n      </span><span class="s1">if (type === </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">node.computed = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return this.finishNode(</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error cast methods to estree types</span><span class="s3">\n        </span><span class="s1">node as Undone&lt;N.EstreeMethodDefinition&gt;,</span><span class="s3">\n        \&quot;</span><span class="s1">MethodDefinition</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseClassProperty(...args: [N.ClassProperty]): any {</span><span class="s3">\n      </span><span class="s1">const propertyNode = super.parseClassProperty(...args) as any;</span><span class="s3">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">classFeatures</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">return propertyNode as N.EstreePropertyDefinition;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">propertyNode.type = </span><span class="s3">\&quot;</span><span class="s1">PropertyDefinition</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return propertyNode as N.EstreePropertyDefinition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseClassPrivateProperty(...args: [N.ClassPrivateProperty]): any {</span><span class="s3">\n      </span><span class="s1">const propertyNode = super.parseClassPrivateProperty(...args) as any;</span><span class="s3">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">classFeatures</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">return propertyNode as N.EstreePropertyDefinition;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">propertyNode.type = </span><span class="s3">\&quot;</span><span class="s1">PropertyDefinition</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">propertyNode.computed = false;</span><span class="s3">\n      </span><span class="s1">return propertyNode as N.EstreePropertyDefinition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseObjectMethod(</span><span class="s3">\n      </span><span class="s1">prop: N.ObjectMethod,</span><span class="s3">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s3">\n      </span><span class="s1">isAsync: boolean,</span><span class="s3">\n      </span><span class="s1">isPattern: boolean,</span><span class="s3">\n      </span><span class="s1">isAccessor: boolean,</span><span class="s3">\n    </span><span class="s1">): N.ObjectMethod | undefined | null {</span><span class="s3">\n      </span><span class="s1">const node: N.EstreeProperty = super.parseObjectMethod(</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n        </span><span class="s1">isGenerator,</span><span class="s3">\n        </span><span class="s1">isAsync,</span><span class="s3">\n        </span><span class="s1">isPattern,</span><span class="s3">\n        </span><span class="s1">isAccessor,</span><span class="s3">\n      </span><span class="s1">) as any;</span><span class="s3">\n\n      </span><span class="s1">if (node) {</span><span class="s3">\n        </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if ((node as any as N.ClassMethod).kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">node.kind = </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">node.shorthand = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return node as any;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseObjectProperty(</span><span class="s3">\n      </span><span class="s1">prop: N.ObjectProperty,</span><span class="s3">\n      </span><span class="s1">startLoc: Position | undefined | null,</span><span class="s3">\n      </span><span class="s1">isPattern: boolean,</span><span class="s3">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s3">\n    </span><span class="s1">): N.ObjectProperty | undefined | null {</span><span class="s3">\n      </span><span class="s1">const node: N.EstreeProperty = super.parseObjectProperty(</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n        </span><span class="s1">startLoc,</span><span class="s3">\n        </span><span class="s1">isPattern,</span><span class="s3">\n        </span><span class="s1">refExpressionErrors,</span><span class="s3">\n      </span><span class="s1">) as any;</span><span class="s3">\n\n      </span><span class="s1">if (node) {</span><span class="s3">\n        </span><span class="s1">node.kind = </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return node as any;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">isValidLVal(</span><span class="s3">\n      </span><span class="s1">type: string,</span><span class="s3">\n      </span><span class="s1">isUnparenthesizedInAssign: boolean,</span><span class="s3">\n      </span><span class="s1">binding: BindingTypes,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return type === </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot;\n        </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;\n        </span><span class="s1">: super.isValidLVal(type, isUnparenthesizedInAssign, binding);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">isAssignable(node: N.Node, isBinding?: boolean): boolean {</span><span class="s3">\n      </span><span class="s1">if (node != null &amp;&amp; this.isObjectProperty(node)) {</span><span class="s3">\n        </span><span class="s1">return this.isAssignable(node.value, isBinding);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return super.isAssignable(node, isBinding);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">toAssignable(node: N.Node, isLHS: boolean = false): void {</span><span class="s3">\n      </span><span class="s1">if (node != null &amp;&amp; this.isObjectProperty(node)) {</span><span class="s3">\n        </span><span class="s1">const { key, value } = node;</span><span class="s3">\n        </span><span class="s1">if (this.isPrivateName(key)) {</span><span class="s3">\n          </span><span class="s1">this.classScope.usePrivateName(</span><span class="s3">\n            </span><span class="s1">this.getPrivateNameSV(key),</span><span class="s3">\n            </span><span class="s1">key.loc.start,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.toAssignable(value, isLHS);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">super.toAssignable(node, isLHS);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">toAssignableObjectExpressionProp(</span><span class="s3">\n      </span><span class="s1">prop: N.Node,</span><span class="s3">\n      </span><span class="s1">isLast: boolean,</span><span class="s3">\n      </span><span class="s1">isLHS: boolean,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (prop.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">|| prop.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.raise(Errors.PatternHasAccessor, { at: prop.key });</span><span class="s3">\n      </span><span class="s1">} else if (prop.method) {</span><span class="s3">\n        </span><span class="s1">this.raise(Errors.PatternHasMethod, { at: prop.key });</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">super.toAssignableObjectExpressionProp(prop, isLast, isLHS);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">finishCallExpression&lt;T extends N.CallExpression | N.OptionalCallExpression&gt;(</span><span class="s3">\n      </span><span class="s1">unfinished: Undone&lt;T&gt;,</span><span class="s3">\n      </span><span class="s1">optional: boolean,</span><span class="s3">\n    </span><span class="s1">): T {</span><span class="s3">\n      </span><span class="s1">const node = super.finishCallExpression(unfinished, optional);</span><span class="s3">\n\n      </span><span class="s1">if (node.callee.type === </span><span class="s3">\&quot;</span><span class="s1">Import</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">(node as N.Node as N.EstreeImportExpression).type = </span><span class="s3">\&quot;</span><span class="s1">ImportExpression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">(node as N.Node as N.EstreeImportExpression).source = node.arguments[0];</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">this.hasPlugin(</span><span class="s3">\&quot;</span><span class="s1">importAttributes</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n          </span><span class="s1">this.hasPlugin(</span><span class="s3">\&quot;</span><span class="s1">importAssertions</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">(node as N.Node as N.EstreeImportExpression).attributes =</span><span class="s3">\n            </span><span class="s1">node.arguments[1] ?? null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// arguments isn't optional in the type definition</span><span class="s3">\n        </span><span class="s1">delete node.arguments;</span><span class="s3">\n        </span><span class="s1">// callee isn't optional in the type definition</span><span class="s3">\n        </span><span class="s1">delete node.callee;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">toReferencedArguments(</span><span class="s3">\n      </span><span class="s1">node:</span><span class="s3">\n        </span><span class="s1">| N.CallExpression</span><span class="s3">\n        </span><span class="s1">| N.OptionalCallExpression</span><span class="s3">\n        </span><span class="s1">| N.EstreeImportExpression,</span><span class="s3">\n      </span><span class="s1">/* isParenthesizedExpr?: boolean, */</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// ImportExpressions do not have an arguments array.</span><span class="s3">\n      </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">ImportExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">super.toReferencedArguments(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseExport(</span><span class="s3">\n      </span><span class="s1">unfinished: Undone&lt;N.AnyExport&gt;,</span><span class="s3">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const exportStartLoc = this.state.lastTokStartLoc;</span><span class="s3">\n      </span><span class="s1">const node = super.parseExport(unfinished, decorators);</span><span class="s3">\n\n      </span><span class="s1">switch (node.type) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s3">\n          </span><span class="s1">node.exported = null;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">node.specifiers.length === 1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s3">\n            </span><span class="s1">node.specifiers[0].type === </span><span class="s3">\&quot;</span><span class="s1">ExportNamespaceSpecifier</span><span class="s3">\&quot;\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s3">\n            </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s3">\n            </span><span class="s1">node.exported = node.specifiers[0].exported;</span><span class="s3">\n            </span><span class="s1">delete node.specifiers;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// fallthrough</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportDefaultDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">const { declaration } = node;</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">declaration?.type === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n              </span><span class="s1">declaration.decorators?.length &gt; 0 &amp;&amp;</span><span class="s3">\n              </span><span class="s1">// decorator comes before export</span><span class="s3">\n              </span><span class="s1">declaration.start === node.start</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">this.resetStartLocation(</span><span class="s3">\n                </span><span class="s1">node,</span><span class="s3">\n                </span><span class="s1">// For compatibility with ESLint's keyword-spacing rule, which assumes that an</span><span class="s3">\n                </span><span class="s1">// export declaration must start with export.</span><span class="s3">\n                </span><span class="s1">// https://github.com/babel/babel/issues/15085</span><span class="s3">\n                </span><span class="s1">// Here we reset export declaration's start to be the start of the export token</span><span class="s3">\n                </span><span class="s1">exportStartLoc,</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseSubscript(</span><span class="s3">\n      </span><span class="s1">base: N.Expression,</span><span class="s3">\n      </span><span class="s1">startLoc: Position,</span><span class="s3">\n      </span><span class="s1">noCalls: boolean | undefined | null,</span><span class="s3">\n      </span><span class="s1">state: N.ParseSubscriptState,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const node = super.parseSubscript(base, startLoc, noCalls, state);</span><span class="s3">\n\n      </span><span class="s1">if (state.optionalChainMember) {</span><span class="s3">\n        </span><span class="s1">// https://github.com/estree/estree/blob/master/es2020.md#chainexpression</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">node.type === </span><span class="s3">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">node.type === </span><span class="s3">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s3">\&quot;\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">node.type = node.type.substring(8); // strip Optional prefix</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (state.stop) {</span><span class="s3">\n          </span><span class="s1">const chain = this.startNodeAtNode(node);</span><span class="s3">\n          </span><span class="s1">chain.expression = node;</span><span class="s3">\n          </span><span class="s1">return this.finishNode(chain, </span><span class="s3">\&quot;</span><span class="s1">ChainExpression</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">node.type === </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">node.type === </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot;\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">node.optional = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">hasPropertyAsPrivateName(node: N.Node): boolean {</span><span class="s3">\n      </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">ChainExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">node = node.expression;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return super.hasPropertyAsPrivateName(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error override interfaces</span><span class="s3">\n    </span><span class="s1">isObjectProperty(node: N.Node): boolean {</span><span class="s3">\n      </span><span class="s1">return node.type === </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.kind === </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !node.method;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">isObjectMethod(node: N.Node): boolean {</span><span class="s3">\n      </span><span class="s1">return node.method || node.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">|| node.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">finishNodeAt&lt;T extends NodeType&gt;(</span><span class="s3">\n      </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s3">\n      </span><span class="s1">type: T[</span><span class="s3">\&quot;</span><span class="s1">type\&quot;],\n      endLoc: Position,\n    ): T {\n      return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n    }\n\n    resetStartLocation(node: N.Node, startLoc: Position) {\n      super.resetStartLocation(node, startLoc);\n      toESTreeLocation(node);\n    }\n\n    resetEndLocation(\n      node: NodeBase,\n      endLoc: Position = this.state.lastTokEndLoc,\n    ): void {\n      super.resetEndLocation(node, endLoc);\n      toESTreeLocation(node);\n    }\n  };\n&quot;],&quot;mappings&quot;:&quot;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&quot;}</span></pre>
</body>
</html>
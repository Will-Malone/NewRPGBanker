<html>
<head>
<title>runtime.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runtime.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) 2014-present, Facebook, Inc. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">var </span><span class="s1">runtime = (</span><span class="s2">function </span><span class="s1">(exports) {</span>
  <span class="s3">&quot;use strict&quot;</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">Op = Object.prototype;</span>
  <span class="s2">var </span><span class="s1">hasOwn = Op.hasOwnProperty;</span>
  <span class="s2">var </span><span class="s1">defineProperty = Object.defineProperty || </span><span class="s2">function </span><span class="s1">(obj, key, desc) { obj[key] = desc.value; };</span>
  <span class="s2">var </span><span class="s1">undefined; </span><span class="s0">// More compressible than void 0.</span>
  <span class="s2">var </span><span class="s1">$Symbol = </span><span class="s2">typeof </span><span class="s1">Symbol === </span><span class="s3">&quot;function&quot; </span><span class="s1">? Symbol : {};</span>
  <span class="s2">var </span><span class="s1">iteratorSymbol = $Symbol.iterator || </span><span class="s3">&quot;@@iterator&quot;</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">asyncIteratorSymbol = $Symbol.asyncIterator || </span><span class="s3">&quot;@@asyncIterator&quot;</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">toStringTagSymbol = $Symbol.toStringTag || </span><span class="s3">&quot;@@toStringTag&quot;</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">define(obj, key, value) {</span>
    <span class="s1">Object.defineProperty(obj, key, {</span>
      <span class="s1">value: value,</span>
      <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">writable: </span><span class="s2">true</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">obj[key];</span>
  <span class="s1">}</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s0">// IE 8 has a broken Object.defineProperty that only works on DOM objects.</span>
    <span class="s1">define({}, </span><span class="s3">&quot;&quot;</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s1">define = </span><span class="s2">function</span><span class="s1">(obj, key, value) {</span>
      <span class="s2">return </span><span class="s1">obj[key] = value;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">wrap(innerFn, outerFn, self, tryLocsList) {</span>
    <span class="s0">// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.</span>
    <span class="s2">var </span><span class="s1">protoGenerator = outerFn &amp;&amp; outerFn.prototype </span><span class="s2">instanceof </span><span class="s1">Generator ? outerFn : Generator;</span>
    <span class="s2">var </span><span class="s1">generator = Object.create(protoGenerator.prototype);</span>
    <span class="s2">var </span><span class="s1">context = </span><span class="s2">new </span><span class="s1">Context(tryLocsList || []);</span>

    <span class="s0">// The ._invoke method unifies the implementations of the .next,</span>
    <span class="s0">// .throw, and .return methods.</span>
    <span class="s1">defineProperty(generator, </span><span class="s3">&quot;_invoke&quot;</span><span class="s1">, { value: makeInvokeMethod(innerFn, self, context) });</span>

    <span class="s2">return </span><span class="s1">generator;</span>
  <span class="s1">}</span>
  <span class="s1">exports.wrap = wrap;</span>

  <span class="s0">// Try/catch helper to minimize deoptimizations. Returns a completion</span>
  <span class="s0">// record like context.tryEntries[i].completion. This interface could</span>
  <span class="s0">// have been (and was previously) designed to take a closure to be</span>
  <span class="s0">// invoked without arguments, but in all the cases we care about we</span>
  <span class="s0">// already have an existing method we want to call, so there's no need</span>
  <span class="s0">// to create a new function object. We can even get away with assuming</span>
  <span class="s0">// the method takes exactly one argument, since that happens to be true</span>
  <span class="s0">// in every case, so we don't have to touch the arguments object. The</span>
  <span class="s0">// only additional allocation required is the completion record, which</span>
  <span class="s0">// has a stable shape and so hopefully should be cheap to allocate.</span>
  <span class="s2">function </span><span class="s1">tryCatch(fn, obj, arg) {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">{ type: </span><span class="s3">&quot;normal&quot;</span><span class="s1">, arg: fn.call(obj, arg) };</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
      <span class="s2">return </span><span class="s1">{ type: </span><span class="s3">&quot;throw&quot;</span><span class="s1">, arg: err };</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">GenStateSuspendedStart = </span><span class="s3">&quot;suspendedStart&quot;</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">GenStateSuspendedYield = </span><span class="s3">&quot;suspendedYield&quot;</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">GenStateExecuting = </span><span class="s3">&quot;executing&quot;</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">GenStateCompleted = </span><span class="s3">&quot;completed&quot;</span><span class="s1">;</span>

  <span class="s0">// Returning this object from the innerFn has the same effect as</span>
  <span class="s0">// breaking out of the dispatch switch statement.</span>
  <span class="s2">var </span><span class="s1">ContinueSentinel = {};</span>

  <span class="s0">// Dummy constructor functions that we use as the .constructor and</span>
  <span class="s0">// .constructor.prototype properties for functions that return Generator</span>
  <span class="s0">// objects. For full spec compliance, you may wish to configure your</span>
  <span class="s0">// minifier not to mangle the names of these two functions.</span>
  <span class="s2">function </span><span class="s1">Generator() {}</span>
  <span class="s2">function </span><span class="s1">GeneratorFunction() {}</span>
  <span class="s2">function </span><span class="s1">GeneratorFunctionPrototype() {}</span>

  <span class="s0">// This is a polyfill for %IteratorPrototype% for environments that</span>
  <span class="s0">// don't natively support it.</span>
  <span class="s2">var </span><span class="s1">IteratorPrototype = {};</span>
  <span class="s1">define(IteratorPrototype, iteratorSymbol, </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return this</span><span class="s1">;</span>
  <span class="s1">});</span>

  <span class="s2">var </span><span class="s1">getProto = Object.getPrototypeOf;</span>
  <span class="s2">var </span><span class="s1">NativeIteratorPrototype = getProto &amp;&amp; getProto(getProto(values([])));</span>
  <span class="s2">if </span><span class="s1">(NativeIteratorPrototype &amp;&amp;</span>
      <span class="s1">NativeIteratorPrototype !== Op &amp;&amp;</span>
      <span class="s1">hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {</span>
    <span class="s0">// This environment has a native %IteratorPrototype%; use it instead</span>
    <span class="s0">// of the polyfill.</span>
    <span class="s1">IteratorPrototype = NativeIteratorPrototype;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">Gp = GeneratorFunctionPrototype.prototype =</span>
    <span class="s1">Generator.prototype = Object.create(IteratorPrototype);</span>
  <span class="s1">GeneratorFunction.prototype = GeneratorFunctionPrototype;</span>
  <span class="s1">defineProperty(Gp, </span><span class="s3">&quot;constructor&quot;</span><span class="s1">, { value: GeneratorFunctionPrototype, configurable: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">defineProperty(</span>
    <span class="s1">GeneratorFunctionPrototype,</span>
    <span class="s3">&quot;constructor&quot;</span><span class="s1">,</span>
    <span class="s1">{ value: GeneratorFunction, configurable: </span><span class="s2">true </span><span class="s1">}</span>
  <span class="s1">);</span>
  <span class="s1">GeneratorFunction.displayName = define(</span>
    <span class="s1">GeneratorFunctionPrototype,</span>
    <span class="s1">toStringTagSymbol,</span>
    <span class="s3">&quot;GeneratorFunction&quot;</span>
  <span class="s1">);</span>

  <span class="s0">// Helper for defining the .next, .throw, and .return methods of the</span>
  <span class="s0">// Iterator interface in terms of a single ._invoke method.</span>
  <span class="s2">function </span><span class="s1">defineIteratorMethods(prototype) {</span>
    <span class="s1">[</span><span class="s3">&quot;next&quot;</span><span class="s1">, </span><span class="s3">&quot;throw&quot;</span><span class="s1">, </span><span class="s3">&quot;return&quot;</span><span class="s1">].forEach(</span><span class="s2">function</span><span class="s1">(method) {</span>
      <span class="s1">define(prototype, method, </span><span class="s2">function</span><span class="s1">(arg) {</span>
        <span class="s2">return this</span><span class="s1">._invoke(method, arg);</span>
      <span class="s1">});</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s1">exports.isGeneratorFunction = </span><span class="s2">function</span><span class="s1">(genFun) {</span>
    <span class="s2">var </span><span class="s1">ctor = </span><span class="s2">typeof </span><span class="s1">genFun === </span><span class="s3">&quot;function&quot; </span><span class="s1">&amp;&amp; genFun.constructor;</span>
    <span class="s2">return </span><span class="s1">ctor</span>
      <span class="s1">? ctor === GeneratorFunction ||</span>
        <span class="s0">// For the native GeneratorFunction constructor, the best we can</span>
        <span class="s0">// do is to check its .name property.</span>
        <span class="s1">(ctor.displayName || ctor.name) === </span><span class="s3">&quot;GeneratorFunction&quot;</span>
      <span class="s1">: </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s1">exports.mark = </span><span class="s2">function</span><span class="s1">(genFun) {</span>
    <span class="s2">if </span><span class="s1">(Object.setPrototypeOf) {</span>
      <span class="s1">Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">genFun.__proto__ = GeneratorFunctionPrototype;</span>
      <span class="s1">define(genFun, toStringTagSymbol, </span><span class="s3">&quot;GeneratorFunction&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">genFun.prototype = Object.create(Gp);</span>
    <span class="s2">return </span><span class="s1">genFun;</span>
  <span class="s1">};</span>

  <span class="s0">// Within the body of any async function, `await x` is transformed to</span>
  <span class="s0">// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test</span>
  <span class="s0">// `hasOwn.call(value, &quot;__await&quot;)` to determine if the yielded value is</span>
  <span class="s0">// meant to be awaited.</span>
  <span class="s1">exports.awrap = </span><span class="s2">function</span><span class="s1">(arg) {</span>
    <span class="s2">return </span><span class="s1">{ __await: arg };</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">AsyncIterator(generator, PromiseImpl) {</span>
    <span class="s2">function </span><span class="s1">invoke(method, arg, resolve, reject) {</span>
      <span class="s2">var </span><span class="s1">record = tryCatch(generator[method], generator, arg);</span>
      <span class="s2">if </span><span class="s1">(record.type === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
        <span class="s1">reject(record.arg);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">var </span><span class="s1">result = record.arg;</span>
        <span class="s2">var </span><span class="s1">value = result.value;</span>
        <span class="s2">if </span><span class="s1">(value &amp;&amp;</span>
            <span class="s2">typeof </span><span class="s1">value === </span><span class="s3">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">hasOwn.call(value, </span><span class="s3">&quot;__await&quot;</span><span class="s1">)) {</span>
          <span class="s2">return </span><span class="s1">PromiseImpl.resolve(value.__await).then(</span><span class="s2">function</span><span class="s1">(value) {</span>
            <span class="s1">invoke(</span><span class="s3">&quot;next&quot;</span><span class="s1">, value, resolve, reject);</span>
          <span class="s1">}, </span><span class="s2">function</span><span class="s1">(err) {</span>
            <span class="s1">invoke(</span><span class="s3">&quot;throw&quot;</span><span class="s1">, err, resolve, reject);</span>
          <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">PromiseImpl.resolve(value).then(</span><span class="s2">function</span><span class="s1">(unwrapped) {</span>
          <span class="s0">// When a yielded Promise is resolved, its final value becomes</span>
          <span class="s0">// the .value of the Promise&lt;{value,done}&gt; result for the</span>
          <span class="s0">// current iteration.</span>
          <span class="s1">result.value = unwrapped;</span>
          <span class="s1">resolve(result);</span>
        <span class="s1">}, </span><span class="s2">function</span><span class="s1">(error) {</span>
          <span class="s0">// If a rejected Promise was yielded, throw the rejection back</span>
          <span class="s0">// into the async generator function so it can be handled there.</span>
          <span class="s2">return </span><span class="s1">invoke(</span><span class="s3">&quot;throw&quot;</span><span class="s1">, error, resolve, reject);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">previousPromise;</span>

    <span class="s2">function </span><span class="s1">enqueue(method, arg) {</span>
      <span class="s2">function </span><span class="s1">callInvokeWithMethodAndArg() {</span>
        <span class="s2">return new </span><span class="s1">PromiseImpl(</span><span class="s2">function</span><span class="s1">(resolve, reject) {</span>
          <span class="s1">invoke(method, arg, resolve, reject);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">previousPromise =</span>
        <span class="s0">// If enqueue has been called before, then we want to wait until</span>
        <span class="s0">// all previous Promises have been resolved before calling invoke,</span>
        <span class="s0">// so that results are always delivered in the correct order. If</span>
        <span class="s0">// enqueue has not been called before, then it is important to</span>
        <span class="s0">// call invoke immediately, without waiting on a callback to fire,</span>
        <span class="s0">// so that the async generator function has the opportunity to do</span>
        <span class="s0">// any necessary setup in a predictable way. This predictability</span>
        <span class="s0">// is why the Promise constructor synchronously invokes its</span>
        <span class="s0">// executor callback, and why async functions synchronously</span>
        <span class="s0">// execute code before the first await. Since we implement simple</span>
        <span class="s0">// async functions in terms of async generators, it is especially</span>
        <span class="s0">// important to get this right, even though it requires care.</span>
        <span class="s1">previousPromise ? previousPromise.then(</span>
          <span class="s1">callInvokeWithMethodAndArg,</span>
          <span class="s0">// Avoid propagating failures to Promises returned by later</span>
          <span class="s0">// invocations of the iterator.</span>
          <span class="s1">callInvokeWithMethodAndArg</span>
        <span class="s1">) : callInvokeWithMethodAndArg();</span>
    <span class="s1">}</span>

    <span class="s0">// Define the unified helper method that is used to implement .next,</span>
    <span class="s0">// .throw, and .return (see defineIteratorMethods).</span>
    <span class="s1">defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s3">&quot;_invoke&quot;</span><span class="s1">, { value: enqueue });</span>
  <span class="s1">}</span>

  <span class="s1">defineIteratorMethods(AsyncIterator.prototype);</span>
  <span class="s1">define(AsyncIterator.prototype, asyncIteratorSymbol, </span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">return this</span><span class="s1">;</span>
  <span class="s1">});</span>
  <span class="s1">exports.AsyncIterator = AsyncIterator;</span>

  <span class="s0">// Note that simple async functions are implemented on top of</span>
  <span class="s0">// AsyncIterator objects; they just return a Promise for the value of</span>
  <span class="s0">// the final result produced by the iterator.</span>
  <span class="s1">exports.async = </span><span class="s2">function</span><span class="s1">(innerFn, outerFn, self, tryLocsList, PromiseImpl) {</span>
    <span class="s2">if </span><span class="s1">(PromiseImpl === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) PromiseImpl = Promise;</span>

    <span class="s2">var </span><span class="s1">iter = </span><span class="s2">new </span><span class="s1">AsyncIterator(</span>
      <span class="s1">wrap(innerFn, outerFn, self, tryLocsList),</span>
      <span class="s1">PromiseImpl</span>
    <span class="s1">);</span>

    <span class="s2">return </span><span class="s1">exports.isGeneratorFunction(outerFn)</span>
      <span class="s1">? iter </span><span class="s0">// If outerFn is a generator, return the full iterator.</span>
      <span class="s1">: iter.next().then(</span><span class="s2">function</span><span class="s1">(result) {</span>
          <span class="s2">return </span><span class="s1">result.done ? result.value : iter.next();</span>
        <span class="s1">});</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">makeInvokeMethod(innerFn, self, context) {</span>
    <span class="s2">var </span><span class="s1">state = GenStateSuspendedStart;</span>

    <span class="s2">return function </span><span class="s1">invoke(method, arg) {</span>
      <span class="s2">if </span><span class="s1">(state === GenStateExecuting) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Generator is already running&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(state === GenStateCompleted) {</span>
        <span class="s2">if </span><span class="s1">(method === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
          <span class="s2">throw </span><span class="s1">arg;</span>
        <span class="s1">}</span>

        <span class="s0">// Be forgiving, per 25.3.3.3.3 of the spec:</span>
        <span class="s0">// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume</span>
        <span class="s2">return </span><span class="s1">doneResult();</span>
      <span class="s1">}</span>

      <span class="s1">context.method = method;</span>
      <span class="s1">context.arg = arg;</span>

      <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">delegate = context.delegate;</span>
        <span class="s2">if </span><span class="s1">(delegate) {</span>
          <span class="s2">var </span><span class="s1">delegateResult = maybeInvokeDelegate(delegate, context);</span>
          <span class="s2">if </span><span class="s1">(delegateResult) {</span>
            <span class="s2">if </span><span class="s1">(delegateResult === ContinueSentinel) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s2">return </span><span class="s1">delegateResult;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(context.method === </span><span class="s3">&quot;next&quot;</span><span class="s1">) {</span>
          <span class="s0">// Setting context._sent for legacy support of Babel's</span>
          <span class="s0">// function.sent implementation.</span>
          <span class="s1">context.sent = context._sent = context.arg;</span>

        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(context.method === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(state === GenStateSuspendedStart) {</span>
            <span class="s1">state = GenStateCompleted;</span>
            <span class="s2">throw </span><span class="s1">context.arg;</span>
          <span class="s1">}</span>

          <span class="s1">context.dispatchException(context.arg);</span>

        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(context.method === </span><span class="s3">&quot;return&quot;</span><span class="s1">) {</span>
          <span class="s1">context.abrupt(</span><span class="s3">&quot;return&quot;</span><span class="s1">, context.arg);</span>
        <span class="s1">}</span>

        <span class="s1">state = GenStateExecuting;</span>

        <span class="s2">var </span><span class="s1">record = tryCatch(innerFn, self, context);</span>
        <span class="s2">if </span><span class="s1">(record.type === </span><span class="s3">&quot;normal&quot;</span><span class="s1">) {</span>
          <span class="s0">// If an exception is thrown from innerFn, we leave state ===</span>
          <span class="s0">// GenStateExecuting and loop back for another invocation.</span>
          <span class="s1">state = context.done</span>
            <span class="s1">? GenStateCompleted</span>
            <span class="s1">: GenStateSuspendedYield;</span>

          <span class="s2">if </span><span class="s1">(record.arg === ContinueSentinel) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">value: record.arg,</span>
            <span class="s1">done: context.done</span>
          <span class="s1">};</span>

        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(record.type === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
          <span class="s1">state = GenStateCompleted;</span>
          <span class="s0">// Dispatch the exception by looping back around to the</span>
          <span class="s0">// context.dispatchException(context.arg) call above.</span>
          <span class="s1">context.method = </span><span class="s3">&quot;throw&quot;</span><span class="s1">;</span>
          <span class="s1">context.arg = record.arg;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">// Call delegate.iterator[context.method](context.arg) and handle the</span>
  <span class="s0">// result, either by returning a { value, done } result from the</span>
  <span class="s0">// delegate iterator, or by modifying context.method and context.arg,</span>
  <span class="s0">// setting context.delegate to null, and returning the ContinueSentinel.</span>
  <span class="s2">function </span><span class="s1">maybeInvokeDelegate(delegate, context) {</span>
    <span class="s2">var </span><span class="s1">methodName = context.method;</span>
    <span class="s2">var </span><span class="s1">method = delegate.iterator[methodName];</span>
    <span class="s2">if </span><span class="s1">(method === undefined) {</span>
      <span class="s0">// A .throw or .return when the delegate iterator has no .throw</span>
      <span class="s0">// method, or a missing .next mehtod, always terminate the</span>
      <span class="s0">// yield* loop.</span>
      <span class="s1">context.delegate = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s0">// Note: [&quot;return&quot;] must be used for ES3 parsing compatibility.</span>
      <span class="s2">if </span><span class="s1">(methodName === </span><span class="s3">&quot;throw&quot; </span><span class="s1">&amp;&amp; delegate.iterator[</span><span class="s3">&quot;return&quot;</span><span class="s1">]) {</span>
        <span class="s0">// If the delegate iterator has a return method, give it a</span>
        <span class="s0">// chance to clean up.</span>
        <span class="s1">context.method = </span><span class="s3">&quot;return&quot;</span><span class="s1">;</span>
        <span class="s1">context.arg = undefined;</span>
        <span class="s1">maybeInvokeDelegate(delegate, context);</span>

        <span class="s2">if </span><span class="s1">(context.method === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
          <span class="s0">// If maybeInvokeDelegate(context) changed context.method from</span>
          <span class="s0">// &quot;return&quot; to &quot;throw&quot;, let that override the TypeError below.</span>
          <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(methodName !== </span><span class="s3">&quot;return&quot;</span><span class="s1">) {</span>
        <span class="s1">context.method = </span><span class="s3">&quot;throw&quot;</span><span class="s1">;</span>
        <span class="s1">context.arg = </span><span class="s2">new </span><span class="s1">TypeError(</span>
          <span class="s3">&quot;The iterator does not provide a '&quot; </span><span class="s1">+ methodName + </span><span class="s3">&quot;' method&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">record = tryCatch(method, delegate.iterator, context.arg);</span>

    <span class="s2">if </span><span class="s1">(record.type === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
      <span class="s1">context.method = </span><span class="s3">&quot;throw&quot;</span><span class="s1">;</span>
      <span class="s1">context.arg = record.arg;</span>
      <span class="s1">context.delegate = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">info = record.arg;</span>

    <span class="s2">if </span><span class="s1">(! info) {</span>
      <span class="s1">context.method = </span><span class="s3">&quot;throw&quot;</span><span class="s1">;</span>
      <span class="s1">context.arg = </span><span class="s2">new </span><span class="s1">TypeError(</span><span class="s3">&quot;iterator result is not an object&quot;</span><span class="s1">);</span>
      <span class="s1">context.delegate = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(info.done) {</span>
      <span class="s0">// Assign the result of the finished delegate to the temporary</span>
      <span class="s0">// variable specified by delegate.resultName (see delegateYield).</span>
      <span class="s1">context[delegate.resultName] = info.value;</span>

      <span class="s0">// Resume execution at the desired location (see delegateYield).</span>
      <span class="s1">context.next = delegate.nextLoc;</span>

      <span class="s0">// If context.method was &quot;throw&quot; but the delegate handled the</span>
      <span class="s0">// exception, let the outer generator proceed normally. If</span>
      <span class="s0">// context.method was &quot;next&quot;, forget context.arg since it has been</span>
      <span class="s0">// &quot;consumed&quot; by the delegate iterator. If context.method was</span>
      <span class="s0">// &quot;return&quot;, allow the original .return call to continue in the</span>
      <span class="s0">// outer generator.</span>
      <span class="s2">if </span><span class="s1">(context.method !== </span><span class="s3">&quot;return&quot;</span><span class="s1">) {</span>
        <span class="s1">context.method = </span><span class="s3">&quot;next&quot;</span><span class="s1">;</span>
        <span class="s1">context.arg = undefined;</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Re-yield the result returned by the delegate method.</span>
      <span class="s2">return </span><span class="s1">info;</span>
    <span class="s1">}</span>

    <span class="s0">// The delegate iterator is finished, so forget it and continue with</span>
    <span class="s0">// the outer generator.</span>
    <span class="s1">context.delegate = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
  <span class="s1">}</span>

  <span class="s0">// Define Generator.prototype.{next,throw,return} in terms of the</span>
  <span class="s0">// unified ._invoke helper method.</span>
  <span class="s1">defineIteratorMethods(Gp);</span>

  <span class="s1">define(Gp, toStringTagSymbol, </span><span class="s3">&quot;Generator&quot;</span><span class="s1">);</span>

  <span class="s0">// A Generator should always return itself as the iterator object when the</span>
  <span class="s0">// @@iterator function is called on it. Some browsers' implementations of the</span>
  <span class="s0">// iterator prototype chain incorrectly implement this, causing the Generator</span>
  <span class="s0">// object to not be returned from this call. This ensures that doesn't happen.</span>
  <span class="s0">// See https://github.com/facebook/regenerator/issues/274 for more details.</span>
  <span class="s1">define(Gp, iteratorSymbol, </span><span class="s2">function</span><span class="s1">() {</span>
    <span class="s2">return this</span><span class="s1">;</span>
  <span class="s1">});</span>

  <span class="s1">define(Gp, </span><span class="s3">&quot;toString&quot;</span><span class="s1">, </span><span class="s2">function</span><span class="s1">() {</span>
    <span class="s2">return </span><span class="s3">&quot;[object Generator]&quot;</span><span class="s1">;</span>
  <span class="s1">});</span>

  <span class="s2">function </span><span class="s1">pushTryEntry(locs) {</span>
    <span class="s2">var </span><span class="s1">entry = { tryLoc: locs[</span><span class="s4">0</span><span class="s1">] };</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s4">1 </span><span class="s2">in </span><span class="s1">locs) {</span>
      <span class="s1">entry.catchLoc = locs[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s4">2 </span><span class="s2">in </span><span class="s1">locs) {</span>
      <span class="s1">entry.finallyLoc = locs[</span><span class="s4">2</span><span class="s1">];</span>
      <span class="s1">entry.afterLoc = locs[</span><span class="s4">3</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s2">this</span><span class="s1">.tryEntries.push(entry);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">resetTryEntry(entry) {</span>
    <span class="s2">var </span><span class="s1">record = entry.completion || {};</span>
    <span class="s1">record.type = </span><span class="s3">&quot;normal&quot;</span><span class="s1">;</span>
    <span class="s2">delete </span><span class="s1">record.arg;</span>
    <span class="s1">entry.completion = record;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">Context(tryLocsList) {</span>
    <span class="s0">// The root entry object (effectively a try statement without a catch</span>
    <span class="s0">// or a finally block) gives us a place to store values thrown from</span>
    <span class="s0">// locations where there is no enclosing try statement.</span>
    <span class="s2">this</span><span class="s1">.tryEntries = [{ tryLoc: </span><span class="s3">&quot;root&quot; </span><span class="s1">}];</span>
    <span class="s1">tryLocsList.forEach(pushTryEntry, </span><span class="s2">this</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">.reset(</span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">exports.keys = </span><span class="s2">function</span><span class="s1">(val) {</span>
    <span class="s2">var </span><span class="s1">object = Object(val);</span>
    <span class="s2">var </span><span class="s1">keys = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">object) {</span>
      <span class="s1">keys.push(key);</span>
    <span class="s1">}</span>
    <span class="s1">keys.reverse();</span>

    <span class="s0">// Rather than returning an object with a next method, we keep</span>
    <span class="s0">// things simple and return the next function itself.</span>
    <span class="s2">return function </span><span class="s1">next() {</span>
      <span class="s2">while </span><span class="s1">(keys.length) {</span>
        <span class="s2">var </span><span class="s1">key = keys.pop();</span>
        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">object) {</span>
          <span class="s1">next.value = key;</span>
          <span class="s1">next.done = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s2">return </span><span class="s1">next;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// To avoid creating an additional object, we just hang the .value</span>
      <span class="s0">// and .done properties off the next function object itself. This</span>
      <span class="s0">// also ensures that the minifier will not anonymize the function.</span>
      <span class="s1">next.done = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">next;</span>
    <span class="s1">};</span>
  <span class="s1">};</span>

  <span class="s2">function </span><span class="s1">values(iterable) {</span>
    <span class="s2">if </span><span class="s1">(iterable) {</span>
      <span class="s2">var </span><span class="s1">iteratorMethod = iterable[iteratorSymbol];</span>
      <span class="s2">if </span><span class="s1">(iteratorMethod) {</span>
        <span class="s2">return </span><span class="s1">iteratorMethod.call(iterable);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">iterable.next === </span><span class="s3">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">iterable;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!isNaN(iterable.length)) {</span>
        <span class="s2">var </span><span class="s1">i = -</span><span class="s4">1</span><span class="s1">, next = </span><span class="s2">function </span><span class="s1">next() {</span>
          <span class="s2">while </span><span class="s1">(++i &lt; iterable.length) {</span>
            <span class="s2">if </span><span class="s1">(hasOwn.call(iterable, i)) {</span>
              <span class="s1">next.value = iterable[i];</span>
              <span class="s1">next.done = </span><span class="s2">false</span><span class="s1">;</span>
              <span class="s2">return </span><span class="s1">next;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">next.value = undefined;</span>
          <span class="s1">next.done = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s2">return </span><span class="s1">next;</span>
        <span class="s1">};</span>

        <span class="s2">return </span><span class="s1">next.next = next;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Return an iterator with no values.</span>
    <span class="s2">return </span><span class="s1">{ next: doneResult };</span>
  <span class="s1">}</span>
  <span class="s1">exports.values = values;</span>

  <span class="s2">function </span><span class="s1">doneResult() {</span>
    <span class="s2">return </span><span class="s1">{ value: undefined, done: </span><span class="s2">true </span><span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s1">Context.prototype = {</span>
    <span class="s1">constructor: Context,</span>

    <span class="s1">reset: </span><span class="s2">function</span><span class="s1">(skipTempReset) {</span>
      <span class="s2">this</span><span class="s1">.prev = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.next = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s0">// Resetting context._sent for legacy support of Babel's</span>
      <span class="s0">// function.sent implementation.</span>
      <span class="s2">this</span><span class="s1">.sent = </span><span class="s2">this</span><span class="s1">._sent = undefined;</span>
      <span class="s2">this</span><span class="s1">.done = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.delegate = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">this</span><span class="s1">.method = </span><span class="s3">&quot;next&quot;</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.arg = undefined;</span>

      <span class="s2">this</span><span class="s1">.tryEntries.forEach(resetTryEntry);</span>

      <span class="s2">if </span><span class="s1">(!skipTempReset) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in this</span><span class="s1">) {</span>
          <span class="s0">// Not sure about the optimal order of these conditions:</span>
          <span class="s2">if </span><span class="s1">(name.charAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s3">&quot;t&quot; </span><span class="s1">&amp;&amp;</span>
              <span class="s1">hasOwn.call(</span><span class="s2">this</span><span class="s1">, name) &amp;&amp;</span>
              <span class="s1">!isNaN(+name.slice(</span><span class="s4">1</span><span class="s1">))) {</span>
            <span class="s2">this</span><span class="s1">[name] = undefined;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">stop: </span><span class="s2">function</span><span class="s1">() {</span>
      <span class="s2">this</span><span class="s1">.done = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">var </span><span class="s1">rootEntry = </span><span class="s2">this</span><span class="s1">.tryEntries[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s2">var </span><span class="s1">rootRecord = rootEntry.completion;</span>
      <span class="s2">if </span><span class="s1">(rootRecord.type === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">rootRecord.arg;</span>
      <span class="s1">}</span>

      <span class="s2">return this</span><span class="s1">.rval;</span>
    <span class="s1">},</span>

    <span class="s1">dispatchException: </span><span class="s2">function</span><span class="s1">(exception) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.done) {</span>
        <span class="s2">throw </span><span class="s1">exception;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">context = </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s2">function </span><span class="s1">handle(loc, caught) {</span>
        <span class="s1">record.type = </span><span class="s3">&quot;throw&quot;</span><span class="s1">;</span>
        <span class="s1">record.arg = exception;</span>
        <span class="s1">context.next = loc;</span>

        <span class="s2">if </span><span class="s1">(caught) {</span>
          <span class="s0">// If the dispatched exception was caught by a catch block,</span>
          <span class="s0">// then let that catch block handle the exception normally.</span>
          <span class="s1">context.method = </span><span class="s3">&quot;next&quot;</span><span class="s1">;</span>
          <span class="s1">context.arg = undefined;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">!! caught;</span>
      <span class="s1">}</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.tryEntries.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; --i) {</span>
        <span class="s2">var </span><span class="s1">entry = </span><span class="s2">this</span><span class="s1">.tryEntries[i];</span>
        <span class="s2">var </span><span class="s1">record = entry.completion;</span>

        <span class="s2">if </span><span class="s1">(entry.tryLoc === </span><span class="s3">&quot;root&quot;</span><span class="s1">) {</span>
          <span class="s0">// Exception thrown outside of any try block that could handle</span>
          <span class="s0">// it, so set the completion value of the entire function to</span>
          <span class="s0">// throw the exception.</span>
          <span class="s2">return </span><span class="s1">handle(</span><span class="s3">&quot;end&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(entry.tryLoc &lt;= </span><span class="s2">this</span><span class="s1">.prev) {</span>
          <span class="s2">var </span><span class="s1">hasCatch = hasOwn.call(entry, </span><span class="s3">&quot;catchLoc&quot;</span><span class="s1">);</span>
          <span class="s2">var </span><span class="s1">hasFinally = hasOwn.call(entry, </span><span class="s3">&quot;finallyLoc&quot;</span><span class="s1">);</span>

          <span class="s2">if </span><span class="s1">(hasCatch &amp;&amp; hasFinally) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prev &lt; entry.catchLoc) {</span>
              <span class="s2">return </span><span class="s1">handle(entry.catchLoc, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prev &lt; entry.finallyLoc) {</span>
              <span class="s2">return </span><span class="s1">handle(entry.finallyLoc);</span>
            <span class="s1">}</span>

          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasCatch) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prev &lt; entry.catchLoc) {</span>
              <span class="s2">return </span><span class="s1">handle(entry.catchLoc, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>

          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasFinally) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prev &lt; entry.finallyLoc) {</span>
              <span class="s2">return </span><span class="s1">handle(entry.finallyLoc);</span>
            <span class="s1">}</span>

          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;try statement without catch or finally&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">abrupt: </span><span class="s2">function</span><span class="s1">(type, arg) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.tryEntries.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; --i) {</span>
        <span class="s2">var </span><span class="s1">entry = </span><span class="s2">this</span><span class="s1">.tryEntries[i];</span>
        <span class="s2">if </span><span class="s1">(entry.tryLoc &lt;= </span><span class="s2">this</span><span class="s1">.prev &amp;&amp;</span>
            <span class="s1">hasOwn.call(entry, </span><span class="s3">&quot;finallyLoc&quot;</span><span class="s1">) &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.prev &lt; entry.finallyLoc) {</span>
          <span class="s2">var </span><span class="s1">finallyEntry = entry;</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(finallyEntry &amp;&amp;</span>
          <span class="s1">(type === </span><span class="s3">&quot;break&quot; </span><span class="s1">||</span>
           <span class="s1">type === </span><span class="s3">&quot;continue&quot;</span><span class="s1">) &amp;&amp;</span>
          <span class="s1">finallyEntry.tryLoc &lt;= arg &amp;&amp;</span>
          <span class="s1">arg &lt;= finallyEntry.finallyLoc) {</span>
        <span class="s0">// Ignore the finally entry if control is not jumping to a</span>
        <span class="s0">// location outside the try/catch block.</span>
        <span class="s1">finallyEntry = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">record = finallyEntry ? finallyEntry.completion : {};</span>
      <span class="s1">record.type = type;</span>
      <span class="s1">record.arg = arg;</span>

      <span class="s2">if </span><span class="s1">(finallyEntry) {</span>
        <span class="s2">this</span><span class="s1">.method = </span><span class="s3">&quot;next&quot;</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.next = finallyEntry.finallyLoc;</span>
        <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
      <span class="s1">}</span>

      <span class="s2">return this</span><span class="s1">.complete(record);</span>
    <span class="s1">},</span>

    <span class="s1">complete: </span><span class="s2">function</span><span class="s1">(record, afterLoc) {</span>
      <span class="s2">if </span><span class="s1">(record.type === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
        <span class="s2">throw </span><span class="s1">record.arg;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(record.type === </span><span class="s3">&quot;break&quot; </span><span class="s1">||</span>
          <span class="s1">record.type === </span><span class="s3">&quot;continue&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.next = record.arg;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(record.type === </span><span class="s3">&quot;return&quot;</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.rval = </span><span class="s2">this</span><span class="s1">.arg = record.arg;</span>
        <span class="s2">this</span><span class="s1">.method = </span><span class="s3">&quot;return&quot;</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.next = </span><span class="s3">&quot;end&quot;</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(record.type === </span><span class="s3">&quot;normal&quot; </span><span class="s1">&amp;&amp; afterLoc) {</span>
        <span class="s2">this</span><span class="s1">.next = afterLoc;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
    <span class="s1">},</span>

    <span class="s1">finish: </span><span class="s2">function</span><span class="s1">(finallyLoc) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.tryEntries.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; --i) {</span>
        <span class="s2">var </span><span class="s1">entry = </span><span class="s2">this</span><span class="s1">.tryEntries[i];</span>
        <span class="s2">if </span><span class="s1">(entry.finallyLoc === finallyLoc) {</span>
          <span class="s2">this</span><span class="s1">.complete(entry.completion, entry.afterLoc);</span>
          <span class="s1">resetTryEntry(entry);</span>
          <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s3">&quot;catch&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">(tryLoc) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.tryEntries.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; --i) {</span>
        <span class="s2">var </span><span class="s1">entry = </span><span class="s2">this</span><span class="s1">.tryEntries[i];</span>
        <span class="s2">if </span><span class="s1">(entry.tryLoc === tryLoc) {</span>
          <span class="s2">var </span><span class="s1">record = entry.completion;</span>
          <span class="s2">if </span><span class="s1">(record.type === </span><span class="s3">&quot;throw&quot;</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">thrown = record.arg;</span>
            <span class="s1">resetTryEntry(entry);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">thrown;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// The context.catch method must only be called with a location</span>
      <span class="s0">// argument that corresponds to a known catch block.</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;illegal catch attempt&quot;</span><span class="s1">);</span>
    <span class="s1">},</span>

    <span class="s1">delegateYield: </span><span class="s2">function</span><span class="s1">(iterable, resultName, nextLoc) {</span>
      <span class="s2">this</span><span class="s1">.delegate = {</span>
        <span class="s1">iterator: values(iterable),</span>
        <span class="s1">resultName: resultName,</span>
        <span class="s1">nextLoc: nextLoc</span>
      <span class="s1">};</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.method === </span><span class="s3">&quot;next&quot;</span><span class="s1">) {</span>
        <span class="s0">// Deliberately forget the last sent value so that we don't</span>
        <span class="s0">// accidentally pass it on to the delegate.</span>
        <span class="s2">this</span><span class="s1">.arg = undefined;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">ContinueSentinel;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">// Regardless of whether this script is executing as a CommonJS module</span>
  <span class="s0">// or not, return the runtime object so that we can declare the variable</span>
  <span class="s0">// regeneratorRuntime in the outer scope, which allows this module to be</span>
  <span class="s0">// injected easily by `bin/regenerator --include-runtime script.js`.</span>
  <span class="s2">return </span><span class="s1">exports;</span>

<span class="s1">}(</span>
  <span class="s0">// If this script is executing as a CommonJS module, use module.exports</span>
  <span class="s0">// as the regeneratorRuntime namespace. Otherwise create a new empty</span>
  <span class="s0">// object. Either way, the resulting object will be used to initialize</span>
  <span class="s0">// the regeneratorRuntime variable at the top of this file.</span>
  <span class="s2">typeof </span><span class="s1">module === </span><span class="s3">&quot;object&quot; </span><span class="s1">? module.exports : {}</span>
<span class="s1">));</span>

<span class="s2">try </span><span class="s1">{</span>
  <span class="s1">regeneratorRuntime = runtime;</span>
<span class="s1">} </span><span class="s2">catch </span><span class="s1">(accidentalStrictMode) {</span>
  <span class="s0">// This module should not be running in strict mode, so the above</span>
  <span class="s0">// assignment should always work unless something is misconfigured. Just</span>
  <span class="s0">// in case runtime.js accidentally runs in strict mode, in modern engines</span>
  <span class="s0">// we can explicitly access globalThis. In older engines we can escape</span>
  <span class="s0">// strict mode using a global Function call. This could conceivably fail</span>
  <span class="s0">// if a Content Security Policy forbids using Function, but in that case</span>
  <span class="s0">// the proper solution is to fix the accidental strict mode problem. If</span>
  <span class="s0">// you've misconfigured your bundler to force strict mode and applied a</span>
  <span class="s0">// CSP to forbid Function, and you're not willing to fix either of those</span>
  <span class="s0">// problems, please detail your unique predicament in a GitHub issue.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">globalThis === </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s1">globalThis.regeneratorRuntime = runtime;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">Function(</span><span class="s3">&quot;r&quot;</span><span class="s1">, </span><span class="s3">&quot;regeneratorRuntime = r&quot;</span><span class="s1">)(runtime);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
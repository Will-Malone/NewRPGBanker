<html>
<head>
<title>placeholders.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
placeholders.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_types&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_parseError&quot;</span><span class="s0">,</span><span class="s1">&quot;PlaceholderErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;ParseErrorEnum&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassNameIsRequired&quot;</span><span class="s0">,</span><span class="s1">&quot;UnexpectedSpace&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;PlaceholdersParserMixin&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePlaceholder&quot;</span><span class="s0">,</span><span class="s1">&quot;expectedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;startNode&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;assertNoSpace&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;parseIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;expect&quot;</span><span class="s0">,</span><span class="s1">&quot;finishPlaceholder&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinished&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;finishNode&quot;</span><span class="s0">,</span><span class="s1">&quot;getTokenFromCode&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;finishOp&quot;</span><span class="s0">,</span><span class="s1">&quot;parseExprAtom&quot;</span><span class="s0">,</span><span class="s1">&quot;refExpressionErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;liberal&quot;</span><span class="s0">,</span><span class="s1">&quot;checkReservedWord&quot;</span><span class="s0">,</span><span class="s1">&quot;word&quot;</span><span class="s0">,</span><span class="s1">&quot;startLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;checkKeywords&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBindingAtom&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidLVal&quot;</span><span class="s0">,</span><span class="s1">&quot;isParenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;toAssignable&quot;</span><span class="s0">,</span><span class="s1">&quot;isLHS&quot;</span><span class="s0">,</span><span class="s1">&quot;chStartsBindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ch&quot;</span><span class="s0">,</span><span class="s1">&quot;nextToken&quot;</span><span class="s0">,</span><span class="s1">&quot;lookahead&quot;</span><span class="s0">,</span><span class="s1">&quot;verifyBreakContinue&quot;</span><span class="s0">,</span><span class="s1">&quot;isBreak&quot;</span><span class="s0">,</span><span class="s1">&quot;label&quot;</span><span class="s0">,</span><span class="s1">&quot;parseExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;parenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;stmt&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;parseStatementOrSloppyAnnexBFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;semicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;parseBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;allowDirectives&quot;</span><span class="s0">,</span><span class="s1">&quot;createNewLexicalScope&quot;</span><span class="s0">,</span><span class="s1">&quot;afterBlockParse&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFunctionId&quot;</span><span class="s0">,</span><span class="s1">&quot;requireId&quot;</span><span class="s0">,</span><span class="s1">&quot;parseClass&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalId&quot;</span><span class="s0">,</span><span class="s1">&quot;oldStrict&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholder&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;raise&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;parseClassId&quot;</span><span class="s0">,</span><span class="s1">&quot;parseClassSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;parseClassBody&quot;</span><span class="s0">,</span><span class="s1">&quot;parseExport&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;isContextual&quot;</span><span class="s0">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;expectPlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;specifier&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTokenStart&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnparsedContextual&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenLabelName&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTokenStartSince&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeParseExportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeDefaultIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;checkExport&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;parseImport&quot;</span><span class="s0">,</span><span class="s1">&quot;startNodeAtNode&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;eat&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStarImport&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeParseStarImportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;parseNamedImportSpecifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;expectContextual&quot;</span><span class="s0">,</span><span class="s1">&quot;parseImportSource&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;lastTokEndLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/plugins/placeholders.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import * as charCodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { tokenLabelName, tt } from </span><span class="s3">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Parser from </span><span class="s3">\&quot;</span><span class="s1">../parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as N from </span><span class="s3">\&quot;</span><span class="s1">../types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { ParseErrorEnum } from </span><span class="s3">\&quot;</span><span class="s1">../parse-error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Undone } from </span><span class="s3">\&quot;</span><span class="s1">../parser/node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s3">\&quot;</span><span class="s1">../parser/util</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { BindingTypes } from </span><span class="s3">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Position } from </span><span class="s3">\&quot;</span><span class="s1">../util/location</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type PossiblePlaceholders = {</span><span class="s3">\n  </span><span class="s1">Identifier: N.Identifier;</span><span class="s3">\n  </span><span class="s1">StringLiteral: N.StringLiteral;</span><span class="s3">\n  </span><span class="s1">Expression: N.Expression;</span><span class="s3">\n  </span><span class="s1">Statement: N.Statement;</span><span class="s3">\n  </span><span class="s1">Declaration: N.Declaration;</span><span class="s3">\n  </span><span class="s1">BlockStatement: N.BlockStatement;</span><span class="s3">\n  </span><span class="s1">ClassBody: N.ClassBody;</span><span class="s3">\n  </span><span class="s1">Pattern: N.Pattern;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export type PlaceholderTypes = keyof PossiblePlaceholders;</span><span class="s3">\n\n</span><span class="s1">type NodeOf&lt;T extends keyof PossiblePlaceholders&gt; = PossiblePlaceholders[T];</span><span class="s3">\n</span><span class="s1">// todo: when there  is proper union type for Node</span><span class="s3">\n</span><span class="s1">// type NodeOf&lt;T extends PlaceholderTypes&gt; = Extract&lt;N.Node, { type: T }&gt;;</span><span class="s3">\n\n</span><span class="s1">// todo: Placeholder&lt;T&gt; breaks everything, because its type is incompatible with</span><span class="s3">\n</span><span class="s1">// the substituted nodes.</span><span class="s3">\n</span><span class="s1">type MaybePlaceholder&lt;T extends PlaceholderTypes&gt; = NodeOf&lt;T&gt;; // | Placeholder&lt;T&gt;</span><span class="s3">\n\n</span><span class="s1">/* eslint sort-keys: </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot; </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PlaceholderErrors = ParseErrorEnum`placeholders`({</span><span class="s3">\n  </span><span class="s1">ClassNameIsRequired: </span><span class="s3">\&quot;</span><span class="s1">A class name is required.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">UnexpectedSpace: </span><span class="s3">\&quot;</span><span class="s1">Unexpected space in placeholder.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable sort-keys */</span><span class="s3">\n\n</span><span class="s1">export default (superClass: typeof Parser) =&gt;</span><span class="s3">\n  </span><span class="s1">class PlaceholdersParserMixin extends superClass implements Parser {</span><span class="s3">\n    </span><span class="s1">parsePlaceholder&lt;T extends PlaceholderTypes&gt;(</span><span class="s3">\n      </span><span class="s1">expectedNode: T,</span><span class="s3">\n    </span><span class="s1">): /*?N.Placeholder&lt;T&gt;*/ MaybePlaceholder&lt;T&gt; | undefined | null {</span><span class="s3">\n      </span><span class="s1">if (this.match(tt.placeholder)) {</span><span class="s3">\n        </span><span class="s1">const node = this.startNode();</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n        </span><span class="s1">this.assertNoSpace();</span><span class="s3">\n\n        </span><span class="s1">// We can't use this.parseIdentifier because</span><span class="s3">\n        </span><span class="s1">// we don't want nested placeholders.</span><span class="s3">\n        </span><span class="s1">node.name = super.parseIdentifier(/* liberal */ true);</span><span class="s3">\n\n        </span><span class="s1">this.assertNoSpace();</span><span class="s3">\n        </span><span class="s1">this.expect(tt.placeholder);</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error placeholder typings</span><span class="s3">\n        </span><span class="s1">return this.finishPlaceholder(node, expectedNode);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">finishPlaceholder&lt;T extends PlaceholderTypes&gt;(</span><span class="s3">\n      </span><span class="s1">node: N.Node,</span><span class="s3">\n      </span><span class="s1">expectedNode: T,</span><span class="s3">\n    </span><span class="s1">): /*N.Placeholder&lt;T&gt;*/ MaybePlaceholder&lt;T&gt; {</span><span class="s3">\n      </span><span class="s1">const isFinished = !!(node.expectedNode &amp;&amp; node.type === </span><span class="s3">\&quot;</span><span class="s1">Placeholder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">node.expectedNode = expectedNode;</span><span class="s3">\n\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s3">\n      </span><span class="s1">return isFinished ? node : this.finishNode(node, </span><span class="s3">\&quot;</span><span class="s1">Placeholder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s3">\n     </span><span class="s1">* tokenizer/index.js                                           *</span><span class="s3">\n     </span><span class="s1">* ============================================================ */</span><span class="s3">\n\n    </span><span class="s1">getTokenFromCode(code: number) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">code === charCodes.percentSign &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.finishOp(tt.placeholder, 2);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">super.getTokenFromCode(code);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s3">\n     </span><span class="s1">* parser/expression.js                                         *</span><span class="s3">\n     </span><span class="s1">* ============================================================ */</span><span class="s3">\n\n    </span><span class="s1">parseExprAtom(</span><span class="s3">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s3">\n    </span><span class="s1">): MaybePlaceholder&lt;</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">&gt; {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">super.parseExprAtom(refExpressionErrors)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseIdentifier(liberal?: boolean): MaybePlaceholder&lt;</span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">&gt; {</span><span class="s3">\n      </span><span class="s1">// NOTE: This function only handles identifiers outside of</span><span class="s3">\n      </span><span class="s1">// expressions and binding patterns, since they are already</span><span class="s3">\n      </span><span class="s1">// handled by the parseExprAtom and parseBindingAtom functions.</span><span class="s3">\n      </span><span class="s1">// This is needed, for example, to parse </span><span class="s3">\&quot;</span><span class="s1">class %%NAME%% {}</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) || super.parseIdentifier(liberal)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">checkReservedWord(</span><span class="s3">\n      </span><span class="s1">word: string,</span><span class="s3">\n      </span><span class="s1">startLoc: Position,</span><span class="s3">\n      </span><span class="s1">checkKeywords: boolean,</span><span class="s3">\n      </span><span class="s1">isBinding: boolean,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Sometimes we call #checkReservedWord(node.name), expecting</span><span class="s3">\n      </span><span class="s1">// that node is an Identifier. If it is a Placeholder, name</span><span class="s3">\n      </span><span class="s1">// will be undefined.</span><span class="s3">\n      </span><span class="s1">if (word !== undefined) {</span><span class="s3">\n        </span><span class="s1">super.checkReservedWord(word, startLoc, checkKeywords, isBinding);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s3">\n     </span><span class="s1">* parser/lval.js                                               *</span><span class="s3">\n     </span><span class="s1">* ============================================================ */</span><span class="s3">\n\n    </span><span class="s1">parseBindingAtom(): MaybePlaceholder&lt;</span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">&gt; {</span><span class="s3">\n      </span><span class="s1">return this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">) || super.parseBindingAtom();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">isValidLVal(type: string, isParenthesized: boolean, binding: BindingTypes) {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">type === </span><span class="s3">\&quot;</span><span class="s1">Placeholder</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">super.isValidLVal(type, isParenthesized, binding)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">toAssignable(node: N.Node, isLHS: boolean): void {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">node &amp;&amp;</span><span class="s3">\n        </span><span class="s1">node.type === </span><span class="s3">\&quot;</span><span class="s1">Placeholder</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">node.expectedNode === </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">node.expectedNode = </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">super.toAssignable(node, isLHS);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s3">\n     </span><span class="s1">* parser/statement.js                                          *</span><span class="s3">\n     </span><span class="s1">* ============================================================ */</span><span class="s3">\n\n    </span><span class="s1">chStartsBindingIdentifier(ch: number, pos: number): boolean {</span><span class="s3">\n      </span><span class="s1">if (super.chStartsBindingIdentifier(ch, pos)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Accept </span><span class="s3">\&quot;</span><span class="s1">let %%</span><span class="s3">\&quot; </span><span class="s1">as the start of </span><span class="s3">\&quot;</span><span class="s1">let %%placeholder%%</span><span class="s3">\&quot;</span><span class="s1">, as though the</span><span class="s3">\n      </span><span class="s1">// placeholder were an identifier.</span><span class="s3">\n      </span><span class="s1">const nextToken = this.lookahead();</span><span class="s3">\n      </span><span class="s1">if (nextToken.type === tt.placeholder) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">verifyBreakContinue(</span><span class="s3">\n      </span><span class="s1">node: N.BreakStatement | N.ContinueStatement,</span><span class="s3">\n      </span><span class="s1">isBreak: boolean,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error: node.label could be Placeholder</span><span class="s3">\n      </span><span class="s1">if (node.label &amp;&amp; node.label.type === </span><span class="s3">\&quot;</span><span class="s1">Placeholder</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n      </span><span class="s1">super.verifyBreakContinue(node, isBreak);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error Plugin will override parser interface</span><span class="s3">\n    </span><span class="s1">parseExpressionStatement(</span><span class="s3">\n      </span><span class="s1">node: MaybePlaceholder&lt;</span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">&gt;,</span><span class="s3">\n      </span><span class="s1">expr: N.Expression,</span><span class="s3">\n    </span><span class="s1">): MaybePlaceholder&lt;</span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">&gt; {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">expr.type !== </span><span class="s3">\&quot;</span><span class="s1">Placeholder</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">(expr.extra &amp;&amp; expr.extra.parenthesized)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error placeholder typings</span><span class="s3">\n        </span><span class="s1">return super.parseExpressionStatement(node, expr);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error placeholder typings</span><span class="s3">\n        </span><span class="s1">const stmt: N.LabeledStatement = node;</span><span class="s3">\n        </span><span class="s1">stmt.label = this.finishPlaceholder(expr, </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n        </span><span class="s1">stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();</span><span class="s3">\n        </span><span class="s1">return this.finishNode(stmt, </span><span class="s3">\&quot;</span><span class="s1">LabeledStatement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.semicolon();</span><span class="s3">\n      </span><span class="s1">node.name = expr.name;</span><span class="s3">\n      </span><span class="s1">return this.finishPlaceholder(node, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseBlock(</span><span class="s3">\n      </span><span class="s1">allowDirectives?: boolean,</span><span class="s3">\n      </span><span class="s1">createNewLexicalScope?: boolean,</span><span class="s3">\n      </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s3">\n    </span><span class="s1">): MaybePlaceholder&lt;</span><span class="s3">\&quot;</span><span class="s1">BlockStatement</span><span class="s3">\&quot;</span><span class="s1">&gt; {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">BlockStatement</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">super.parseBlock(</span><span class="s3">\n          </span><span class="s1">allowDirectives,</span><span class="s3">\n          </span><span class="s1">createNewLexicalScope,</span><span class="s3">\n          </span><span class="s1">afterBlockParse,</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseFunctionId(</span><span class="s3">\n      </span><span class="s1">requireId?: boolean,</span><span class="s3">\n    </span><span class="s1">): MaybePlaceholder&lt;</span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">&gt; | undefined | null {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) || super.parseFunctionId(requireId)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error Plugin will override parser interface</span><span class="s3">\n    </span><span class="s1">parseClass&lt;T extends N.Class&gt;(</span><span class="s3">\n      </span><span class="s1">node: T,</span><span class="s3">\n      </span><span class="s1">isStatement: /* T === ClassDeclaration */ boolean,</span><span class="s3">\n      </span><span class="s1">optionalId?: boolean,</span><span class="s3">\n    </span><span class="s1">): T {</span><span class="s3">\n      </span><span class="s1">const type = isStatement ? </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">ClassExpression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">this.next();</span><span class="s3">\n      </span><span class="s1">const oldStrict = this.state.strict;</span><span class="s3">\n\n      </span><span class="s1">const placeholder = this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (placeholder) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">this.match(tt._extends) ||</span><span class="s3">\n          </span><span class="s1">this.match(tt.placeholder) ||</span><span class="s3">\n          </span><span class="s1">this.match(tt.braceL)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">node.id = placeholder;</span><span class="s3">\n        </span><span class="s1">} else if (optionalId || !isStatement) {</span><span class="s3">\n          </span><span class="s1">node.id = null;</span><span class="s3">\n          </span><span class="s1">node.body = this.finishPlaceholder(placeholder, </span><span class="s3">\&quot;</span><span class="s1">ClassBody</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">return this.finishNode(node, type);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">throw this.raise(PlaceholderErrors.ClassNameIsRequired, {</span><span class="s3">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.parseClassId(node, isStatement, optionalId);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">super.parseClassSuper(node);</span><span class="s3">\n      </span><span class="s1">node.body =</span><span class="s3">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">ClassBody</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">super.parseClassBody(!!node.superClass, oldStrict);</span><span class="s3">\n      </span><span class="s1">return this.finishNode(node, type);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseExport(node: N.Node, decorators: N.Decorator[] | null): N.AnyExport {</span><span class="s3">\n      </span><span class="s1">const placeholder = this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (!placeholder) return super.parseExport(node, decorators);</span><span class="s3">\n\n      </span><span class="s1">if (!this.isContextual(tt._from) &amp;&amp; !this.match(tt.comma)) {</span><span class="s3">\n        </span><span class="s1">// export %%DECL%%;</span><span class="s3">\n        </span><span class="s1">node.specifiers = [];</span><span class="s3">\n        </span><span class="s1">node.source = null;</span><span class="s3">\n        </span><span class="s1">node.declaration = this.finishPlaceholder(placeholder, </span><span class="s3">\&quot;</span><span class="s1">Declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// export %%NAME%% from </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">this.expectPlugin(</span><span class="s3">\&quot;</span><span class="s1">exportDefaultFrom</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const specifier = this.startNode();</span><span class="s3">\n      </span><span class="s1">specifier.exported = placeholder;</span><span class="s3">\n      </span><span class="s1">node.specifiers = [this.finishNode(specifier, </span><span class="s3">\&quot;</span><span class="s1">ExportDefaultSpecifier</span><span class="s3">\&quot;</span><span class="s1">)];</span><span class="s3">\n\n      </span><span class="s1">return super.parseExport(node, decorators);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">isExportDefaultSpecifier(): boolean {</span><span class="s3">\n      </span><span class="s1">if (this.match(tt._default)) {</span><span class="s3">\n        </span><span class="s1">const next = this.nextTokenStart();</span><span class="s3">\n        </span><span class="s1">if (this.isUnparsedContextual(next, </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">this.input.startsWith(</span><span class="s3">\n              </span><span class="s1">tokenLabelName(tt.placeholder),</span><span class="s3">\n              </span><span class="s1">this.nextTokenStartSince(next + 4),</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return super.isExportDefaultSpecifier();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">maybeParseExportDefaultSpecifier(</span><span class="s3">\n      </span><span class="s1">node: Undone&lt;</span><span class="s3">\n        </span><span class="s1">| N.ExportDefaultDeclaration</span><span class="s3">\n        </span><span class="s1">| N.ExportAllDeclaration</span><span class="s3">\n        </span><span class="s1">| N.ExportNamedDeclaration</span><span class="s3">\n      </span><span class="s1">&gt;,</span><span class="s3">\n      </span><span class="s1">maybeDefaultIdentifier: N.Identifier | null,</span><span class="s3">\n    </span><span class="s1">): node is Undone&lt;N.ExportNamedDeclaration&gt; {</span><span class="s3">\n      </span><span class="s1">if ((node as N.ExportNamedDeclaration).specifiers?.length) {</span><span class="s3">\n        </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">export %%NAME%%</span><span class="s3">\&quot; </span><span class="s1">has already been parsed by #parseExport.</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return super.maybeParseExportDefaultSpecifier(</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">maybeDefaultIdentifier,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">checkExport(node: N.ExportNamedDeclaration): void {</span><span class="s3">\n      </span><span class="s1">const { specifiers } = node;</span><span class="s3">\n      </span><span class="s1">if (specifiers?.length) {</span><span class="s3">\n        </span><span class="s1">node.specifiers = specifiers.filter(</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error placeholder typings</span><span class="s3">\n          </span><span class="s1">node =&gt; node.exported.type === </span><span class="s3">\&quot;</span><span class="s1">Placeholder</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">super.checkExport(node);</span><span class="s3">\n      </span><span class="s1">node.specifiers = specifiers;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseImport(</span><span class="s3">\n      </span><span class="s1">node: Undone&lt;N.ImportDeclaration&gt;,</span><span class="s3">\n    </span><span class="s1">): N.ImportDeclaration | N.TsImportEqualsDeclaration {</span><span class="s3">\n      </span><span class="s1">const placeholder = this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (!placeholder) return super.parseImport(node);</span><span class="s3">\n\n      </span><span class="s1">node.specifiers = [];</span><span class="s3">\n\n      </span><span class="s1">if (!this.isContextual(tt._from) &amp;&amp; !this.match(tt.comma)) {</span><span class="s3">\n        </span><span class="s1">// import %%STRING%%;</span><span class="s3">\n        </span><span class="s1">node.source = this.finishPlaceholder(placeholder, </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.semicolon();</span><span class="s3">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s3">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// import %%DEFAULT%% ...</span><span class="s3">\n      </span><span class="s1">const specifier =</span><span class="s3">\n        </span><span class="s1">this.startNodeAtNode&lt;N.ImportDefaultSpecifier&gt;(placeholder);</span><span class="s3">\n      </span><span class="s1">specifier.local = placeholder;</span><span class="s3">\n      </span><span class="s1">node.specifiers.push(</span><span class="s3">\n        </span><span class="s1">this.finishNode(specifier, </span><span class="s3">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (this.eat(tt.comma)) {</span><span class="s3">\n        </span><span class="s1">// import %%DEFAULT%%, * as ...</span><span class="s3">\n        </span><span class="s1">const hasStarImport = this.maybeParseStarImportSpecifier(node);</span><span class="s3">\n\n        </span><span class="s1">// import %%DEFAULT%%, { ...</span><span class="s3">\n        </span><span class="s1">if (!hasStarImport) this.parseNamedImportSpecifiers(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.expectContextual(tt._from);</span><span class="s3">\n      </span><span class="s1">node.source = this.parseImportSource();</span><span class="s3">\n      </span><span class="s1">this.semicolon();</span><span class="s3">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s3">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">parseImportSource(): MaybePlaceholder&lt;</span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">&gt; {</span><span class="s3">\n      </span><span class="s1">// import ... from %%STRING%%;</span><span class="s3">\n\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">) || super.parseImportSource()</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Throws if the current token and the prev one are separated by a space.</span><span class="s3">\n    </span><span class="s1">assertNoSpace(): void {</span><span class="s3">\n      </span><span class="s1">if (this.state.start &gt; this.state.lastTokEndLoc.index) {</span><span class="s3">\n        </span><span class="s1">this.raise(PlaceholderErrors.UnexpectedSpace, {</span><span class="s3">\n          </span><span class="s1">at: this.state.lastTokEndLoc,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;}</span></pre>
</body>
</html>
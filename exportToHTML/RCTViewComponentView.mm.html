<html>
<head>
<title>RCTViewComponentView.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTViewComponentView.mm</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&quot;RCTViewComponentView.h&quot;</span>

<span class="s2">#import </span><span class="s3">&lt;CoreGraphics/CoreGraphics.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;QuartzCore/QuartzCore.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;objc/runtime.h&gt;</span>

<span class="s2">#import </span><span class="s3">&lt;React/RCTAssert.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTBorderDrawing.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTConversions.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;react/renderer/components/view/ViewComponentDescriptor.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;react/renderer/components/view/ViewEventEmitter.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;react/renderer/components/view/ViewProps.h&gt;</span>

<span class="s4">using namespace </span><span class="s1">facebook::react</span><span class="s4">;</span>

<span class="s4">@implementation </span><span class="s1">RCTViewComponentView {</span>
  <span class="s1">UIColor *_backgroundColor</span><span class="s4">;</span>
  <span class="s1">CALayer *_borderLayer</span><span class="s4">;</span>
  <span class="s1">BOOL _needsInvalidateLayer</span><span class="s4">;</span>
  <span class="s1">BOOL _isJSResponder</span><span class="s4">;</span>
  <span class="s1">BOOL _removeClippedSubviews</span><span class="s4">;</span>
  <span class="s1">NSMutableArray&lt;UIView *&gt; *_reactSubviews</span><span class="s4">;</span>
  <span class="s1">NSSet&lt;NSString *&gt; *</span><span class="s4">_Nullable </span><span class="s1">_propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (instancetype)initWithFrame:(CGRect)frame</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self = [super initWithFrame:frame]) {</span>
    <span class="s4">static auto const </span><span class="s1">defaultProps = std::make_shared&lt;ViewProps </span><span class="s4">const</span><span class="s1">&gt;()</span><span class="s4">;</span>
    <span class="s1">_props = defaultProps</span><span class="s4">;</span>
    <span class="s1">_reactSubviews = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">self.multipleTouchEnabled = YES</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (facebook::react::Props::Shared)props</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_props</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setContentView:(UIView *)contentView</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_contentView) {</span>
    <span class="s1">[_contentView removeFromSuperview]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">_contentView = contentView</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_contentView) {</span>
    <span class="s1">[self addSubview:_contentView]</span><span class="s4">;</span>
    <span class="s1">_contentView.frame = RCTCGRectFromRect(_layoutMetrics.getContentFrame())</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(UIEdgeInsetsEqualToEdgeInsets(self.hitTestEdgeInsets</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)) {</span>
    <span class="s4">return </span><span class="s1">[super pointInside:point withEvent:event]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">CGRect hitFrame = UIEdgeInsetsInsetRect(self.bounds</span><span class="s4">, </span><span class="s1">self.hitTestEdgeInsets)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">CGRectContainsPoint(hitFrame</span><span class="s4">, </span><span class="s1">point)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIColor *)backgroundColor</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_backgroundColor</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setBackgroundColor:(UIColor *)backgroundColor</span>
<span class="s1">{</span>
  <span class="s1">_backgroundColor = backgroundColor</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTComponentViewProtocol</span>

<span class="s1">+ (ComponentDescriptorProvider)componentDescriptorProvider</span>
<span class="s1">{</span>
  <span class="s1">RCTAssert(</span>
      <span class="s1">self == [RCTViewComponentView </span><span class="s4">class</span><span class="s1">]</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;`+[RCTComponentViewProtocol componentDescriptorProvider]` must be implemented for all subclasses (and `%@` particularly).&quot;</span><span class="s4">,</span>
      <span class="s1">NSStringFromClass([self </span><span class="s4">class</span><span class="s1">]))</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">concreteComponentDescriptorProvider&lt;ViewComponentDescriptor&gt;()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)mountChildComponentView:(UIView&lt;RCTComponentViewProtocol&gt; *)childComponentView index:(NSInteger)index</span>
<span class="s1">{</span>
  <span class="s1">RCTAssert(</span>
      <span class="s1">childComponentView.superview == nil</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;Attempt to mount already mounted component view. (parent: %@, child: %@, index: %@, existing parent: %@)&quot;</span><span class="s4">,</span>
      <span class="s1">self</span><span class="s4">,</span>
      <span class="s1">childComponentView</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">(index)</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s1">([childComponentView.superview tag]))</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_removeClippedSubviews) {</span>
    <span class="s1">[_reactSubviews insertObject:childComponentView atIndex:index]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">[self insertSubview:childComponentView atIndex:index]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)unmountChildComponentView:(UIView&lt;RCTComponentViewProtocol&gt; *)childComponentView index:(NSInteger)index</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_removeClippedSubviews) {</span>
    <span class="s1">[_reactSubviews removeObjectAtIndex:index]</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">RCTAssert(</span>
        <span class="s1">childComponentView.superview == self</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;Attempt to unmount a view which is mounted inside different view. (parent: %@, child: %@, index: %@)&quot;</span><span class="s4">,</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">childComponentView</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s1">(index))</span><span class="s4">;</span>
    <span class="s1">RCTAssert(</span>
        <span class="s1">(self.subviews.count &gt; index) &amp;&amp; [self.subviews objectAtIndex:index] == childComponentView</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s3">&quot;Attempt to unmount a view which has a different index. (parent: %@, child: %@, index: %@, actual index: %@, tag at index: %@)&quot;</span><span class="s4">,</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">childComponentView</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s1">(index)</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s1">([self.subviews indexOfObject:childComponentView])</span><span class="s4">,</span>
        <span class="s4">@</span><span class="s1">([[self.subviews objectAtIndex:index] tag]))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">[childComponentView removeFromSuperview]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateClippedSubviewsWithClipRect:(CGRect)clipRect relativeToView:(UIView *)clipView</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!_removeClippedSubviews) {</span>
    <span class="s0">// Use default behavior if unmounting is disabled</span>
    <span class="s4">return </span><span class="s1">[super updateClippedSubviewsWithClipRect:clipRect relativeToView:clipView]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_reactSubviews.count == </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s0">// Do nothing if we have no subviews</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(CGSizeEqualToSize(self.bounds.size</span><span class="s4">, </span><span class="s1">CGSizeZero)) {</span>
    <span class="s0">// Do nothing if layout hasn't happened yet</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s0">// Convert clipping rect to local coordinates</span>
  <span class="s1">clipRect = [clipView convertRect:clipRect toView:self]</span><span class="s4">;</span>

  <span class="s0">// Mount / unmount views</span>
  <span class="s4">for </span><span class="s1">(UIView *view in _reactSubviews) {</span>
    <span class="s4">if </span><span class="s1">(CGRectIntersectsRect(clipRect</span><span class="s4">, </span><span class="s1">view.frame)) {</span>
      <span class="s0">// View is at least partially visible, so remount it if unmounted</span>
      <span class="s1">[self addSubview:view]</span><span class="s4">;</span>
      <span class="s0">// View is visible, update clipped subviews</span>
      <span class="s1">[view updateClippedSubviewsWithClipRect:clipRect relativeToView:self]</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(view.superview) {</span>
      <span class="s0">// View is completely outside the clipRect, so unmount it</span>
      <span class="s1">[view removeFromSuperview]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateProps:(Props::Shared </span><span class="s4">const </span><span class="s1">&amp;)props oldProps:(Props::Shared </span><span class="s4">const </span><span class="s1">&amp;)oldProps</span>
<span class="s1">{</span>
  <span class="s1">RCTAssert(props</span><span class="s4">, @</span><span class="s3">&quot;`props` must not be `null`.&quot;</span><span class="s1">)</span><span class="s4">;</span>

<span class="s2">#ifndef </span><span class="s1">NS_BLOCK_ASSERTIONS</span>
  <span class="s4">auto </span><span class="s1">propsRawPtr = _props.get()</span><span class="s4">;</span>
  <span class="s1">RCTAssert(</span>
      <span class="s1">propsRawPtr &amp;&amp;</span>
          <span class="s1">([self </span><span class="s4">class</span><span class="s1">] == [RCTViewComponentView </span><span class="s4">class</span><span class="s1">] ||</span>
           <span class="s4">typeid</span><span class="s1">(*propsRawPtr).hash_code() != </span><span class="s4">typeid</span><span class="s1">(ViewProps </span><span class="s4">const</span><span class="s1">).hash_code())</span><span class="s4">,</span>
      <span class="s4">@</span><span class="s3">&quot;`RCTViewComponentView` subclasses (and `%@` particularly) must setup `_props`&quot;</span>
       <span class="s3">&quot; instance variable with a default value in the constructor.&quot;</span><span class="s4">,</span>
      <span class="s1">NSStringFromClass([self </span><span class="s4">class</span><span class="s1">]))</span><span class="s4">;</span>
<span class="s2">#endif</span>

  <span class="s4">auto const </span><span class="s1">&amp;oldViewProps = *std::static_pointer_cast&lt;ViewProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>
  <span class="s4">auto const </span><span class="s1">&amp;newViewProps = *std::static_pointer_cast&lt;ViewProps </span><span class="s4">const</span><span class="s1">&gt;(props)</span><span class="s4">;</span>

  <span class="s1">BOOL needsInvalidateLayer = NO</span><span class="s4">;</span>

  <span class="s0">// `opacity`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.opacity != newViewProps.opacity &amp;&amp;</span>
      <span class="s1">![_propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN containsObject:</span><span class="s4">@</span><span class="s3">&quot;opacity&quot;</span><span class="s1">]) {</span>
    <span class="s1">self.layer.opacity = (</span><span class="s4">float</span><span class="s1">)newViewProps.opacity</span><span class="s4">;</span>
    <span class="s1">needsInvalidateLayer = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(oldViewProps.removeClippedSubviews != newViewProps.removeClippedSubviews) {</span>
    <span class="s1">_removeClippedSubviews = newViewProps.removeClippedSubviews</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(_removeClippedSubviews &amp;&amp; self.subviews.count &gt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">_reactSubviews = [NSMutableArray arrayWithArray:self.subviews]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// `backgroundColor`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.backgroundColor != newViewProps.backgroundColor) {</span>
    <span class="s1">self.backgroundColor = RCTUIColorFromSharedColor(newViewProps.backgroundColor)</span><span class="s4">;</span>
    <span class="s1">needsInvalidateLayer = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `foregroundColor`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.foregroundColor != newViewProps.foregroundColor) {</span>
    <span class="s1">self.foregroundColor = RCTUIColorFromSharedColor(newViewProps.foregroundColor)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `shadowColor`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.shadowColor != newViewProps.shadowColor) {</span>
    <span class="s1">CGColorRef shadowColor = RCTCreateCGColorRefFromSharedColor(newViewProps.shadowColor)</span><span class="s4">;</span>
    <span class="s1">self.layer.shadowColor = shadowColor</span><span class="s4">;</span>
    <span class="s1">CGColorRelease(shadowColor)</span><span class="s4">;</span>
    <span class="s1">needsInvalidateLayer = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `shadowOffset`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.shadowOffset != newViewProps.shadowOffset) {</span>
    <span class="s1">self.layer.shadowOffset = RCTCGSizeFromSize(newViewProps.shadowOffset)</span><span class="s4">;</span>
    <span class="s1">needsInvalidateLayer = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `shadowOpacity`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.shadowOpacity != newViewProps.shadowOpacity) {</span>
    <span class="s1">self.layer.shadowOpacity = (</span><span class="s4">float</span><span class="s1">)newViewProps.shadowOpacity</span><span class="s4">;</span>
    <span class="s1">needsInvalidateLayer = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `shadowRadius`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.shadowRadius != newViewProps.shadowRadius) {</span>
    <span class="s1">self.layer.shadowRadius = (CGFloat)newViewProps.shadowRadius</span><span class="s4">;</span>
    <span class="s1">needsInvalidateLayer = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `backfaceVisibility`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.backfaceVisibility != newViewProps.backfaceVisibility) {</span>
    <span class="s1">self.layer.doubleSided = newViewProps.backfaceVisibility == BackfaceVisibility::Visible</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `shouldRasterize`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.shouldRasterize != newViewProps.shouldRasterize) {</span>
    <span class="s1">self.layer.shouldRasterize = newViewProps.shouldRasterize</span><span class="s4">;</span>
    <span class="s1">self.layer.rasterizationScale = newViewProps.shouldRasterize ? [UIScreen mainScreen].scale : </span><span class="s5">1.0</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `pointerEvents`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.pointerEvents != newViewProps.pointerEvents) {</span>
    <span class="s1">self.userInteractionEnabled = newViewProps.pointerEvents != PointerEventsMode::None</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `transform`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.transform != newViewProps.transform &amp;&amp;</span>
      <span class="s1">![_propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN containsObject:</span><span class="s4">@</span><span class="s3">&quot;transform&quot;</span><span class="s1">]) {</span>
    <span class="s1">self.layer.transform = RCTCATransform3DFromTransformMatrix(newViewProps.transform)</span><span class="s4">;</span>
    <span class="s1">self.layer.allowsEdgeAntialiasing = newViewProps.transform != Transform::Identity()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `hitSlop`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.hitSlop != newViewProps.hitSlop) {</span>
    <span class="s1">self.hitTestEdgeInsets = {</span>
        <span class="s1">-newViewProps.hitSlop.top</span><span class="s4">,</span>
        <span class="s1">-newViewProps.hitSlop.left</span><span class="s4">,</span>
        <span class="s1">-newViewProps.hitSlop.bottom</span><span class="s4">,</span>
        <span class="s1">-newViewProps.hitSlop.right}</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `overflow`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.getClipsContentToBounds() != newViewProps.getClipsContentToBounds()) {</span>
    <span class="s1">self.clipsToBounds = newViewProps.getClipsContentToBounds()</span><span class="s4">;</span>
    <span class="s1">needsInvalidateLayer = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `border`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.borderStyles != newViewProps.borderStyles || oldViewProps.borderRadii != newViewProps.borderRadii ||</span>
      <span class="s1">oldViewProps.borderColors != newViewProps.borderColors) {</span>
    <span class="s1">needsInvalidateLayer = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `nativeId`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.nativeId != newViewProps.nativeId) {</span>
    <span class="s1">self.nativeId = RCTNSStringFromStringNilIfEmpty(newViewProps.nativeId)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessible`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessible != newViewProps.accessible) {</span>
    <span class="s1">self.accessibilityElement.isAccessibilityElement = newViewProps.accessible</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityLabel`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityLabel != newViewProps.accessibilityLabel) {</span>
    <span class="s1">self.accessibilityElement.accessibilityLabel = RCTNSStringFromStringNilIfEmpty(newViewProps.accessibilityLabel)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityLanguage`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityLanguage != newViewProps.accessibilityLanguage) {</span>
    <span class="s1">self.accessibilityElement.accessibilityLanguage =</span>
        <span class="s1">RCTNSStringFromStringNilIfEmpty(newViewProps.accessibilityLanguage)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityHint`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityHint != newViewProps.accessibilityHint) {</span>
    <span class="s1">self.accessibilityElement.accessibilityHint = RCTNSStringFromStringNilIfEmpty(newViewProps.accessibilityHint)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityViewIsModal`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityViewIsModal != newViewProps.accessibilityViewIsModal) {</span>
    <span class="s1">self.accessibilityElement.accessibilityViewIsModal = newViewProps.accessibilityViewIsModal</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityElementsHidden`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityElementsHidden != newViewProps.accessibilityElementsHidden) {</span>
    <span class="s1">self.accessibilityElement.accessibilityElementsHidden = newViewProps.accessibilityElementsHidden</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityTraits`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityTraits != newViewProps.accessibilityTraits) {</span>
    <span class="s1">self.accessibilityElement.accessibilityTraits =</span>
        <span class="s1">RCTUIAccessibilityTraitsFromAccessibilityTraits(newViewProps.accessibilityTraits)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityState`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityState != newViewProps.accessibilityState) {</span>
    <span class="s1">self.accessibilityTraits &amp;= ~(UIAccessibilityTraitNotEnabled | UIAccessibilityTraitSelected)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(newViewProps.accessibilityState.selected) {</span>
      <span class="s1">self.accessibilityTraits |= UIAccessibilityTraitSelected</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">(newViewProps.accessibilityState.disabled) {</span>
      <span class="s1">self.accessibilityTraits |= UIAccessibilityTraitNotEnabled</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityIgnoresInvertColors`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityIgnoresInvertColors != newViewProps.accessibilityIgnoresInvertColors) {</span>
    <span class="s1">self.accessibilityIgnoresInvertColors = newViewProps.accessibilityIgnoresInvertColors</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// `accessibilityValue`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.accessibilityValue != newViewProps.accessibilityValue) {</span>
    <span class="s4">if </span><span class="s1">(newViewProps.accessibilityValue.text.has_value()) {</span>
      <span class="s1">self.accessibilityElement.accessibilityValue =</span>
          <span class="s1">RCTNSStringFromStringNilIfEmpty(newViewProps.accessibilityValue.text.value())</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span>
        <span class="s1">newViewProps.accessibilityValue.now.has_value() &amp;&amp; newViewProps.accessibilityValue.min.has_value() &amp;&amp;</span>
        <span class="s1">newViewProps.accessibilityValue.max.has_value()) {</span>
      <span class="s1">CGFloat val = (CGFloat)(newViewProps.accessibilityValue.now.value()) /</span>
          <span class="s1">(newViewProps.accessibilityValue.max.value() - newViewProps.accessibilityValue.min.value())</span><span class="s4">;</span>
      <span class="s1">self.accessibilityElement.accessibilityValue =</span>
          <span class="s1">[NSNumberFormatter localizedStringFromNumber:</span><span class="s4">@</span><span class="s1">(val) numberStyle:NSNumberFormatterPercentStyle]</span><span class="s4">;</span>
      <span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">self.accessibilityElement.accessibilityValue = nil</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// `testId`</span>
  <span class="s4">if </span><span class="s1">(oldViewProps.testId != newViewProps.testId) {</span>
    <span class="s1">self.accessibilityIdentifier = RCTNSStringFromString(newViewProps.testId)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">_needsInvalidateLayer = _needsInvalidateLayer || needsInvalidateLayer</span><span class="s4">;</span>

  <span class="s1">_props = std::static_pointer_cast&lt;ViewProps </span><span class="s4">const</span><span class="s1">&gt;(props)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateEventEmitter:(EventEmitter::Shared </span><span class="s4">const </span><span class="s1">&amp;)eventEmitter</span>
<span class="s1">{</span>
  <span class="s1">assert(std::dynamic_pointer_cast&lt;ViewEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(eventEmitter))</span><span class="s4">;</span>
  <span class="s1">_eventEmitter = std::static_pointer_cast&lt;ViewEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(eventEmitter)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateLayoutMetrics:(LayoutMetrics </span><span class="s4">const </span><span class="s1">&amp;)layoutMetrics</span>
           <span class="s1">oldLayoutMetrics:(LayoutMetrics </span><span class="s4">const </span><span class="s1">&amp;)oldLayoutMetrics</span>
<span class="s1">{</span>
  <span class="s0">// Using stored `_layoutMetrics` as `oldLayoutMetrics` here to avoid</span>
  <span class="s0">// re-applying individual sub-values which weren't changed.</span>
  <span class="s1">[super updateLayoutMetrics:layoutMetrics oldLayoutMetrics:_layoutMetrics]</span><span class="s4">;</span>

  <span class="s1">_layoutMetrics = layoutMetrics</span><span class="s4">;</span>
  <span class="s1">_needsInvalidateLayer = YES</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_borderLayer) {</span>
    <span class="s1">_borderLayer.frame = self.layer.bounds</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_contentView) {</span>
    <span class="s1">_contentView.frame = RCTCGRectFromRect(_layoutMetrics.getContentFrame())</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)isJSResponder</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_isJSResponder</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setIsJSResponder:(BOOL)isJSResponder</span>
<span class="s1">{</span>
  <span class="s1">_isJSResponder = isJSResponder</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)finalizeUpdates:(RNComponentViewUpdateMask)updateMask</span>
<span class="s1">{</span>
  <span class="s1">[super finalizeUpdates:updateMask]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!_needsInvalidateLayer) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">_needsInvalidateLayer = NO</span><span class="s4">;</span>
  <span class="s1">[self invalidateLayer]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)prepareForRecycle</span>
<span class="s1">{</span>
  <span class="s1">[super prepareForRecycle]</span><span class="s4">;</span>

  <span class="s0">// If view was managed by animated, its props need to align with UIView's properties.</span>
  <span class="s4">auto const </span><span class="s1">&amp;props = *std::static_pointer_cast&lt;ViewProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">([_propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN containsObject:</span><span class="s4">@</span><span class="s3">&quot;transform&quot;</span><span class="s1">]) {</span>
    <span class="s1">self.layer.transform = RCTCATransform3DFromTransformMatrix(props.transform)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">([_propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN containsObject:</span><span class="s4">@</span><span class="s3">&quot;opacity&quot;</span><span class="s1">]) {</span>
    <span class="s1">self.layer.opacity = (</span><span class="s4">float</span><span class="s1">)props.opacity</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">_propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN = nil</span><span class="s4">;</span>
  <span class="s1">_eventEmitter.reset()</span><span class="s4">;</span>
  <span class="s1">_isJSResponder = NO</span><span class="s4">;</span>
  <span class="s1">_removeClippedSubviews = NO</span><span class="s4">;</span>
  <span class="s1">_reactSubviews = [NSMutableArray </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setPropKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN:(NSSet&lt;NSString *&gt; *</span><span class="s4">_Nullable</span><span class="s1">)props</span>
<span class="s1">{</span>
  <span class="s1">_propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN = props</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSSet&lt;NSString *&gt; *</span><span class="s4">_Nullable</span><span class="s1">)propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIView *)betterHitTest:(CGPoint)point withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s0">// This is a classic textbook implementation of `hitTest:` with a couple of improvements:</span>
  <span class="s0">//   * It does not stop algorithm if some touch is outside the view</span>
  <span class="s0">//     which does not have `clipToBounds` enabled.</span>
  <span class="s0">//   * Taking `layer.zIndex` field into an account is not required because</span>
  <span class="s0">//     lists of `ShadowView`s are already sorted based on `zIndex` prop.</span>

  <span class="s4">if </span><span class="s1">(!self.userInteractionEnabled || self.hidden || self.alpha &lt; </span><span class="s5">0.01</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">BOOL isPointInside = [self pointInside:point withEvent:event]</span><span class="s4">;</span>

  <span class="s1">BOOL clipsToBounds = self.clipsToBounds</span><span class="s4">;</span>

  <span class="s1">clipsToBounds = clipsToBounds || _layoutMetrics.overflowInset == EdgeInsets{}</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(clipsToBounds &amp;&amp; !isPointInside) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">for </span><span class="s1">(UIView *subview in [self.subviews reverseObjectEnumerator]) {</span>
    <span class="s1">UIView *hitView = [subview hitTest:[subview convertPoint:point fromView:self] withEvent:event]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(hitView) {</span>
      <span class="s4">return </span><span class="s1">hitView</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">isPointInside ? self : nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s4">switch </span><span class="s1">(_props-&gt;pointerEvents) {</span>
    <span class="s4">case </span><span class="s1">PointerEventsMode::Auto:</span>
      <span class="s4">return </span><span class="s1">[self betterHitTest:point withEvent:event]</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">PointerEventsMode::None:</span>
      <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">PointerEventsMode::BoxOnly:</span>
      <span class="s4">return </span><span class="s1">[self pointInside:point withEvent:event] ? self : nil</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">PointerEventsMode::BoxNone:</span>
      <span class="s1">UIView *view = [self betterHitTest:point withEvent:event]</span><span class="s4">;</span>
      <span class="s4">return </span><span class="s1">view != self ? view : nil</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">RCTCornerRadii RCTCornerRadiiFromBorderRadii(BorderRadii borderRadii)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">RCTCornerRadii{</span>
      <span class="s1">.topLeft = (CGFloat)borderRadii.topLeft</span><span class="s4">,</span>
      <span class="s1">.topRight = (CGFloat)borderRadii.topRight</span><span class="s4">,</span>
      <span class="s1">.bottomLeft = (CGFloat)borderRadii.bottomLeft</span><span class="s4">,</span>
      <span class="s1">.bottomRight = (CGFloat)borderRadii.bottomRight}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">RCTBorderColors RCTCreateRCTBorderColorsFromBorderColors(BorderColors borderColors)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">RCTBorderColors{</span>
      <span class="s1">.top = RCTCreateCGColorRefFromSharedColor(borderColors.top)</span><span class="s4">,</span>
      <span class="s1">.left = RCTCreateCGColorRefFromSharedColor(borderColors.left)</span><span class="s4">,</span>
      <span class="s1">.bottom = RCTCreateCGColorRefFromSharedColor(borderColors.bottom)</span><span class="s4">,</span>
      <span class="s1">.right = RCTCreateCGColorRefFromSharedColor(borderColors.right)}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static void </span><span class="s1">RCTReleaseRCTBorderColors(RCTBorderColors borderColors)</span>
<span class="s1">{</span>
  <span class="s1">CGColorRelease(borderColors.top)</span><span class="s4">;</span>
  <span class="s1">CGColorRelease(borderColors.left)</span><span class="s4">;</span>
  <span class="s1">CGColorRelease(borderColors.bottom)</span><span class="s4">;</span>
  <span class="s1">CGColorRelease(borderColors.right)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">CALayerCornerCurve CornerCurveFromBorderCurve(BorderCurve borderCurve)</span>
<span class="s1">{</span>
  <span class="s0">// The constants are available only starting from iOS 13</span>
  <span class="s0">// CALayerCornerCurve is a typealias on NSString *</span>
  <span class="s4">switch </span><span class="s1">(borderCurve) {</span>
    <span class="s4">case </span><span class="s1">BorderCurve::Continuous:</span>
      <span class="s4">return @</span><span class="s3">&quot;continuous&quot;</span><span class="s4">; </span><span class="s0">// kCACornerCurveContinuous;</span>
    <span class="s4">case </span><span class="s1">BorderCurve::Circular:</span>
      <span class="s4">return @</span><span class="s3">&quot;circular&quot;</span><span class="s4">; </span><span class="s0">// kCACornerCurveCircular;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">RCTBorderStyle RCTBorderStyleFromBorderStyle(BorderStyle borderStyle)</span>
<span class="s1">{</span>
  <span class="s4">switch </span><span class="s1">(borderStyle) {</span>
    <span class="s4">case </span><span class="s1">BorderStyle::Solid:</span>
      <span class="s4">return </span><span class="s1">RCTBorderStyleSolid</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">BorderStyle::Dotted:</span>
      <span class="s4">return </span><span class="s1">RCTBorderStyleDotted</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">BorderStyle::Dashed:</span>
      <span class="s4">return </span><span class="s1">RCTBorderStyleDashed</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)invalidateLayer</span>
<span class="s1">{</span>
  <span class="s1">CALayer *layer = self.layer</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(CGSizeEqualToSize(layer.bounds.size</span><span class="s4">, </span><span class="s1">CGSizeZero)) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">auto const </span><span class="s1">borderMetrics = _props-&gt;resolveBorderMetrics(_layoutMetrics)</span><span class="s4">;</span>

  <span class="s0">// Stage 1. Shadow Path</span>
  <span class="s1">BOOL </span><span class="s4">const </span><span class="s1">layerHasShadow = layer.shadowOpacity &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; CGColorGetAlpha(layer.shadowColor) &gt; </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(layerHasShadow) {</span>
    <span class="s4">if </span><span class="s1">(CGColorGetAlpha(_backgroundColor.CGColor) &gt; </span><span class="s5">0.999</span><span class="s1">) {</span>
      <span class="s0">// If view has a solid background color, calculate shadow path from border.</span>
      <span class="s1">RCTCornerInsets </span><span class="s4">const </span><span class="s1">cornerInsets =</span>
          <span class="s1">RCTGetCornerInsets(RCTCornerRadiiFromBorderRadii(borderMetrics.borderRadii)</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)</span><span class="s4">;</span>
      <span class="s1">CGPathRef shadowPath = RCTPathCreateWithRoundedRect(self.bounds</span><span class="s4">, </span><span class="s1">cornerInsets</span><span class="s4">, </span><span class="s1">nil)</span><span class="s4">;</span>
      <span class="s1">layer.shadowPath = shadowPath</span><span class="s4">;</span>
      <span class="s1">CGPathRelease(shadowPath)</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s0">// Can't accurately calculate box shadow, so fall back to pixel-based shadow.</span>
      <span class="s1">layer.shadowPath = nil</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">layer.shadowPath = nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Stage 2. Border Rendering</span>
  <span class="s4">bool const </span><span class="s1">useCoreAnimationBorderRendering =</span>
      <span class="s1">borderMetrics.borderColors.isUniform() &amp;&amp; borderMetrics.borderWidths.isUniform() &amp;&amp;</span>
      <span class="s1">borderMetrics.borderStyles.isUniform() &amp;&amp; borderMetrics.borderRadii.isUniform() &amp;&amp;</span>
      <span class="s1">borderMetrics.borderStyles.left == BorderStyle::Solid &amp;&amp;</span>
      <span class="s1">(</span>
          <span class="s0">// iOS draws borders in front of the content whereas CSS draws them behind</span>
          <span class="s0">// the content. For this reason, only use iOS border drawing when clipping</span>
          <span class="s0">// or when the border is hidden.</span>
          <span class="s1">borderMetrics.borderWidths.left == </span><span class="s5">0 </span><span class="s1">||</span>
          <span class="s1">colorComponentsFromColor(borderMetrics.borderColors.left).alpha == </span><span class="s5">0 </span><span class="s1">|| self.clipsToBounds)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(useCoreAnimationBorderRendering) {</span>
    <span class="s1">layer.mask = nil</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(_borderLayer) {</span>
      <span class="s1">[_borderLayer removeFromSuperlayer]</span><span class="s4">;</span>
      <span class="s1">_borderLayer = nil</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">layer.borderWidth = (CGFloat)borderMetrics.borderWidths.left</span><span class="s4">;</span>
    <span class="s1">CGColorRef borderColor = RCTCreateCGColorRefFromSharedColor(borderMetrics.borderColors.left)</span><span class="s4">;</span>
    <span class="s1">layer.borderColor = borderColor</span><span class="s4">;</span>
    <span class="s1">CGColorRelease(borderColor)</span><span class="s4">;</span>
    <span class="s1">layer.cornerRadius = (CGFloat)borderMetrics.borderRadii.topLeft</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s4">, </span><span class="s1">*)) {</span>
      <span class="s1">layer.cornerCurve = CornerCurveFromBorderCurve(borderMetrics.borderCurves.topLeft)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">layer.backgroundColor = _backgroundColor.CGColor</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">if </span><span class="s1">(!_borderLayer) {</span>
      <span class="s1">_borderLayer = [CALayer </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">_borderLayer.zPosition = -</span><span class="s5">1024.0f</span><span class="s4">;</span>
      <span class="s1">_borderLayer.frame = layer.bounds</span><span class="s4">;</span>
      <span class="s1">_borderLayer.magnificationFilter = kCAFilterNearest</span><span class="s4">;</span>
      <span class="s1">[layer addSublayer:_borderLayer]</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">layer.backgroundColor = nil</span><span class="s4">;</span>
    <span class="s1">layer.borderWidth = </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">layer.borderColor = nil</span><span class="s4">;</span>
    <span class="s1">layer.cornerRadius = </span><span class="s5">0</span><span class="s4">;</span>

    <span class="s1">RCTBorderColors borderColors = RCTCreateRCTBorderColorsFromBorderColors(borderMetrics.borderColors)</span><span class="s4">;</span>

    <span class="s1">UIImage *image = RCTGetBorderImage(</span>
        <span class="s1">RCTBorderStyleFromBorderStyle(borderMetrics.borderStyles.left)</span><span class="s4">,</span>
        <span class="s1">layer.bounds.size</span><span class="s4">,</span>
        <span class="s1">RCTCornerRadiiFromBorderRadii(borderMetrics.borderRadii)</span><span class="s4">,</span>
        <span class="s1">RCTUIEdgeInsetsFromEdgeInsets(borderMetrics.borderWidths)</span><span class="s4">,</span>
        <span class="s1">borderColors</span><span class="s4">,</span>
        <span class="s1">_backgroundColor.CGColor</span><span class="s4">,</span>
        <span class="s1">self.clipsToBounds)</span><span class="s4">;</span>

    <span class="s1">RCTReleaseRCTBorderColors(borderColors)</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(image == nil) {</span>
      <span class="s1">_borderLayer.contents = nil</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">CGSize imageSize = image.size</span><span class="s4">;</span>
      <span class="s1">UIEdgeInsets imageCapInsets = image.capInsets</span><span class="s4">;</span>
      <span class="s1">CGRect contentsCenter = CGRect{</span>
          <span class="s1">CGPoint{imageCapInsets.left / imageSize.width</span><span class="s4">, </span><span class="s1">imageCapInsets.top / imageSize.height}</span><span class="s4">,</span>
          <span class="s1">CGSize{(CGFloat)</span><span class="s5">1.0 </span><span class="s1">/ imageSize.width</span><span class="s4">, </span><span class="s1">(CGFloat)</span><span class="s5">1.0 </span><span class="s1">/ imageSize.height}}</span><span class="s4">;</span>

      <span class="s1">_borderLayer.contents = (id)image.CGImage</span><span class="s4">;</span>
      <span class="s1">_borderLayer.contentsScale = image.scale</span><span class="s4">;</span>

      <span class="s1">BOOL isResizable = !UIEdgeInsetsEqualToEdgeInsets(image.capInsets</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(isResizable) {</span>
        <span class="s1">_borderLayer.contentsCenter = contentsCenter</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s1">_borderLayer.contentsCenter = CGRect{CGPoint{</span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">0.0</span><span class="s1">}</span><span class="s4">, </span><span class="s1">CGSize{</span><span class="s5">1.0</span><span class="s4">, </span><span class="s5">1.0</span><span class="s1">}}</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Stage 2.5. Custom Clipping Mask</span>
    <span class="s1">CAShapeLayer *maskLayer = nil</span><span class="s4">;</span>
    <span class="s1">CGFloat cornerRadius = </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(self.clipsToBounds) {</span>
      <span class="s4">if </span><span class="s1">(borderMetrics.borderRadii.isUniform()) {</span>
        <span class="s0">// In this case we can simply use `cornerRadius` exclusively.</span>
        <span class="s1">cornerRadius = borderMetrics.borderRadii.topLeft</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s0">// In this case we have to generate masking layer manually.</span>
        <span class="s1">CGPathRef path = RCTPathCreateWithRoundedRect(</span>
            <span class="s1">self.bounds</span><span class="s4">,</span>
            <span class="s1">RCTGetCornerInsets(RCTCornerRadiiFromBorderRadii(borderMetrics.borderRadii)</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)</span><span class="s4">,</span>
            <span class="s1">nil)</span><span class="s4">;</span>

        <span class="s1">maskLayer = [CAShapeLayer layer]</span><span class="s4">;</span>
        <span class="s1">maskLayer.path = path</span><span class="s4">;</span>
        <span class="s1">CGPathRelease(path)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">layer.cornerRadius = cornerRadius</span><span class="s4">;</span>
    <span class="s1">layer.mask = maskLayer</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Accessibility</span>

<span class="s1">- (NSObject *)accessibilityElement</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">NSString *RCTRecursiveAccessibilityLabel(UIView *view)</span>
<span class="s1">{</span>
  <span class="s1">NSMutableString *result = [NSMutableString stringWithString:</span><span class="s4">@</span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(UIView *subview in view.subviews) {</span>
    <span class="s1">NSString *label = subview.accessibilityLabel</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(!label) {</span>
      <span class="s1">label = RCTRecursiveAccessibilityLabel(subview)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">(label &amp;&amp; label.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s4">if </span><span class="s1">(result.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">[result appendString:</span><span class="s4">@</span><span class="s3">&quot; &quot;</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s1">}</span>
      <span class="s1">[result appendString:label]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">result</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)accessibilityLabel</span>
<span class="s1">{</span>
  <span class="s1">NSString *label = super.accessibilityLabel</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(label) {</span>
    <span class="s4">return </span><span class="s1">label</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">RCTRecursiveAccessibilityLabel(self)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)accessibilityValue</span>
<span class="s1">{</span>
  <span class="s4">auto const </span><span class="s1">&amp;props = *std::static_pointer_cast&lt;ViewProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>

  <span class="s0">// Handle Switch.</span>
  <span class="s4">if </span><span class="s1">((self.accessibilityTraits &amp; AccessibilityTraitSwitch) == AccessibilityTraitSwitch) {</span>
    <span class="s4">if </span><span class="s1">(props.accessibilityState.checked == AccessibilityState::Checked) {</span>
      <span class="s4">return @</span><span class="s3">&quot;1&quot;</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(props.accessibilityState.checked == AccessibilityState::Unchecked) {</span>
      <span class="s4">return @</span><span class="s3">&quot;0&quot;</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Handle states which haven't already been handled.</span>
  <span class="s4">if </span><span class="s1">(props.accessibilityState.checked == AccessibilityState::Checked) {</span>
    <span class="s4">return @</span><span class="s3">&quot;checked&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(props.accessibilityState.checked == AccessibilityState::Unchecked) {</span>
    <span class="s4">return @</span><span class="s3">&quot;unchecked&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(props.accessibilityState.checked == AccessibilityState::Mixed) {</span>
    <span class="s4">return @</span><span class="s3">&quot;mixed&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(props.accessibilityState.expanded) {</span>
    <span class="s4">return @</span><span class="s3">&quot;expanded&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(props.accessibilityState.busy) {</span>
    <span class="s4">return @</span><span class="s3">&quot;busy&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Accessibility Events</span>

<span class="s1">- (BOOL)shouldGroupAccessibilityChildren</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSArray&lt;UIAccessibilityCustomAction *&gt; *)accessibilityCustomActions</span>
<span class="s1">{</span>
  <span class="s4">auto const </span><span class="s1">&amp;accessibilityActions = _props-&gt;accessibilityActions</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(accessibilityActions.empty()) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">NSMutableArray&lt;UIAccessibilityCustomAction *&gt; *customActions = [NSMutableArray array]</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">auto const </span><span class="s1">&amp;accessibilityAction : accessibilityActions) {</span>
    <span class="s1">[customActions</span>
        <span class="s1">addObject:[[UIAccessibilityCustomAction alloc] initWithName:RCTNSStringFromString(accessibilityAction.name)</span>
                                                             <span class="s1">target:self</span>
                                                           <span class="s4">selector</span><span class="s1">:</span><span class="s4">@selector</span><span class="s1">(didActivateAccessibilityCustomAction:)]]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">[customActions copy]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)accessibilityActivate</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_eventEmitter &amp;&amp; _props-&gt;onAccessibilityTap) {</span>
    <span class="s1">_eventEmitter-&gt;onAccessibilityTap()</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)accessibilityPerformMagicTap</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_eventEmitter &amp;&amp; _props-&gt;onAccessibilityMagicTap) {</span>
    <span class="s1">_eventEmitter-&gt;onAccessibilityMagicTap()</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)accessibilityPerformEscape</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_eventEmitter &amp;&amp; _props-&gt;onAccessibilityEscape) {</span>
    <span class="s1">_eventEmitter-&gt;onAccessibilityEscape()</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)didActivateAccessibilityCustomAction:(UIAccessibilityCustomAction *)action</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_eventEmitter &amp;&amp; _props-&gt;onAccessibilityAction) {</span>
    <span class="s1">_eventEmitter-&gt;onAccessibilityAction(RCTStringFromNSString(action.name))</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (SharedTouchEventEmitter)touchEventEmitterAtPoint:(CGPoint)point</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_eventEmitter</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)componentViewName_DO_NOT_USE_THIS_IS_BROKEN</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">RCTNSStringFromString([[self </span><span class="s4">class</span><span class="s1">] componentDescriptorProvider].name)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>

<span class="s2">#ifdef </span><span class="s1">__cplusplus</span>
<span class="s4">extern </span><span class="s3">&quot;C&quot; </span><span class="s1">{</span>
<span class="s2">#endif</span>

<span class="s0">// Can't the import generated Plugin.h because plugins are not in this BUCK target</span>
<span class="s1">Class&lt;RCTComponentViewProtocol&gt; RCTViewCls(</span><span class="s4">void</span><span class="s1">)</span><span class="s4">;</span>

<span class="s2">#ifdef </span><span class="s1">__cplusplus</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s1">Class&lt;RCTComponentViewProtocol&gt; RCTViewCls(</span><span class="s4">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">RCTViewComponentView.</span><span class="s4">class;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
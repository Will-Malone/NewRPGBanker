<html>
<head>
<title>source-map.umd.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-map.umd.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
    <span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? factory(exports) :</span>
    <span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s0">], factory) :</span>
    <span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, factory(global.sourceMap = {}));</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(exports) { </span><span class="s2">'use strict'</span><span class="s0">;</span>

    <span class="s0">const comma = </span><span class="s2">','</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
    <span class="s0">const semicolon = </span><span class="s2">';'</span><span class="s0">.charCodeAt(</span><span class="s3">0</span><span class="s0">);</span>
    <span class="s0">const chars = </span><span class="s2">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s0">;</span>
    <span class="s0">const intToChar = </span><span class="s1">new </span><span class="s0">Uint8Array(</span><span class="s3">64</span><span class="s0">); </span><span class="s4">// 64 possible chars.</span>
    <span class="s0">const charToInteger = </span><span class="s1">new </span><span class="s0">Uint8Array(</span><span class="s3">128</span><span class="s0">); </span><span class="s4">// z is 122 in ASCII</span>
    <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">0</span><span class="s0">; i &lt; chars.length; i++) {</span>
        <span class="s0">const c = chars.charCodeAt(i);</span>
        <span class="s0">charToInteger[c] = i;</span>
        <span class="s0">intToChar[i] = c;</span>
    <span class="s0">}</span>
    <span class="s4">// Provide a fallback for older environments.</span>
    <span class="s0">const td = </span><span class="s1">typeof </span><span class="s0">TextDecoder !== </span><span class="s2">'undefined'</span>
        <span class="s0">? </span><span class="s1">new </span><span class="s0">TextDecoder()</span>
        <span class="s0">: </span><span class="s1">typeof </span><span class="s0">Buffer !== </span><span class="s2">'undefined'</span>
            <span class="s0">? {</span>
                <span class="s0">decode(buf) {</span>
                    <span class="s0">const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);</span>
                    <span class="s1">return </span><span class="s0">out.toString();</span>
                <span class="s0">},</span>
            <span class="s0">}</span>
            <span class="s0">: {</span>
                <span class="s0">decode(buf) {</span>
                    <span class="s0">let out = </span><span class="s2">''</span><span class="s0">;</span>
                    <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">0</span><span class="s0">; i &lt; buf.length; i++) {</span>
                        <span class="s0">out += String.fromCharCode(buf[i]);</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">out;</span>
                <span class="s0">},</span>
            <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">decode(mappings) {</span>
        <span class="s0">const state = </span><span class="s1">new </span><span class="s0">Int32Array(</span><span class="s3">5</span><span class="s0">);</span>
        <span class="s0">const decoded = [];</span>
        <span class="s0">let line = [];</span>
        <span class="s0">let sorted = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">let lastCol = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">0</span><span class="s0">; i &lt; mappings.length;) {</span>
            <span class="s0">const c = mappings.charCodeAt(i);</span>
            <span class="s1">if </span><span class="s0">(c === comma) {</span>
                <span class="s0">i++;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(c === semicolon) {</span>
                <span class="s0">state[</span><span class="s3">0</span><span class="s0">] = lastCol = </span><span class="s3">0</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(!sorted)</span>
                    <span class="s0">sort(line);</span>
                <span class="s0">sorted = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">decoded.push(line);</span>
                <span class="s0">line = [];</span>
                <span class="s0">i++;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">i = decodeInteger(mappings, i, state, </span><span class="s3">0</span><span class="s0">); </span><span class="s4">// generatedCodeColumn</span>
                <span class="s0">const col = state[</span><span class="s3">0</span><span class="s0">];</span>
                <span class="s1">if </span><span class="s0">(col &lt; lastCol)</span>
                    <span class="s0">sorted = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">lastCol = col;</span>
                <span class="s1">if </span><span class="s0">(!hasMoreSegments(mappings, i)) {</span>
                    <span class="s0">line.push([col]);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">i = decodeInteger(mappings, i, state, </span><span class="s3">1</span><span class="s0">); </span><span class="s4">// sourceFileIndex</span>
                <span class="s0">i = decodeInteger(mappings, i, state, </span><span class="s3">2</span><span class="s0">); </span><span class="s4">// sourceCodeLine</span>
                <span class="s0">i = decodeInteger(mappings, i, state, </span><span class="s3">3</span><span class="s0">); </span><span class="s4">// sourceCodeColumn</span>
                <span class="s1">if </span><span class="s0">(!hasMoreSegments(mappings, i)) {</span>
                    <span class="s0">line.push([col, state[</span><span class="s3">1</span><span class="s0">], state[</span><span class="s3">2</span><span class="s0">], state[</span><span class="s3">3</span><span class="s0">]]);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">i = decodeInteger(mappings, i, state, </span><span class="s3">4</span><span class="s0">); </span><span class="s4">// nameIndex</span>
                <span class="s0">line.push([col, state[</span><span class="s3">1</span><span class="s0">], state[</span><span class="s3">2</span><span class="s0">], state[</span><span class="s3">3</span><span class="s0">], state[</span><span class="s3">4</span><span class="s0">]]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!sorted)</span>
            <span class="s0">sort(line);</span>
        <span class="s0">decoded.push(line);</span>
        <span class="s1">return </span><span class="s0">decoded;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">decodeInteger(mappings, pos, state, j) {</span>
        <span class="s0">let value = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s0">let shift = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s0">let integer = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">const c = mappings.charCodeAt(pos++);</span>
            <span class="s0">integer = charToInteger[c];</span>
            <span class="s0">value |= (integer &amp; </span><span class="s3">31</span><span class="s0">) &lt;&lt; shift;</span>
            <span class="s0">shift += </span><span class="s3">5</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(integer &amp; </span><span class="s3">32</span><span class="s0">);</span>
        <span class="s0">const shouldNegate = value &amp; </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s0">value &gt;&gt;&gt;= </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(shouldNegate) {</span>
            <span class="s0">value = -</span><span class="s3">0</span><span class="s0">x80000000 | -value;</span>
        <span class="s0">}</span>
        <span class="s0">state[j] += value;</span>
        <span class="s1">return </span><span class="s0">pos;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hasMoreSegments(mappings, i) {</span>
        <span class="s1">if </span><span class="s0">(i &gt;= mappings.length)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">const c = mappings.charCodeAt(i);</span>
        <span class="s1">if </span><span class="s0">(c === comma || c === semicolon)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sort(line) {</span>
        <span class="s0">line.sort(sortComparator$1);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sortComparator$1(a, b) {</span>
        <span class="s1">return </span><span class="s0">a[</span><span class="s3">0</span><span class="s0">] - b[</span><span class="s3">0</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">encode(decoded) {</span>
        <span class="s0">const state = </span><span class="s1">new </span><span class="s0">Int32Array(</span><span class="s3">5</span><span class="s0">);</span>
        <span class="s0">let buf = </span><span class="s1">new </span><span class="s0">Uint8Array(</span><span class="s3">1024</span><span class="s0">);</span>
        <span class="s0">let pos = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">0</span><span class="s0">; i &lt; decoded.length; i++) {</span>
            <span class="s0">const line = decoded[i];</span>
            <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s0">buf = reserve(buf, pos, </span><span class="s3">1</span><span class="s0">);</span>
                <span class="s0">buf[pos++] = semicolon;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(line.length === </span><span class="s3">0</span><span class="s0">)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">state[</span><span class="s3">0</span><span class="s0">] = </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(let j = </span><span class="s3">0</span><span class="s0">; j &lt; line.length; j++) {</span>
                <span class="s0">const segment = line[j];</span>
                <span class="s4">// We can push up to 5 ints, each int can take at most 7 chars, and we</span>
                <span class="s4">// may push a comma.</span>
                <span class="s0">buf = reserve(buf, pos, </span><span class="s3">36</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(j &gt; </span><span class="s3">0</span><span class="s0">)</span>
                    <span class="s0">buf[pos++] = comma;</span>
                <span class="s0">pos = encodeInteger(buf, pos, state, segment, </span><span class="s3">0</span><span class="s0">); </span><span class="s4">// generatedCodeColumn</span>
                <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s3">1</span><span class="s0">)</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">pos = encodeInteger(buf, pos, state, segment, </span><span class="s3">1</span><span class="s0">); </span><span class="s4">// sourceFileIndex</span>
                <span class="s0">pos = encodeInteger(buf, pos, state, segment, </span><span class="s3">2</span><span class="s0">); </span><span class="s4">// sourceCodeLine</span>
                <span class="s0">pos = encodeInteger(buf, pos, state, segment, </span><span class="s3">3</span><span class="s0">); </span><span class="s4">// sourceCodeColumn</span>
                <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s3">4</span><span class="s0">)</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">pos = encodeInteger(buf, pos, state, segment, </span><span class="s3">4</span><span class="s0">); </span><span class="s4">// nameIndex</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">td.decode(buf.subarray(</span><span class="s3">0</span><span class="s0">, pos));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">reserve(buf, pos, count) {</span>
        <span class="s1">if </span><span class="s0">(buf.length &gt; pos + count)</span>
            <span class="s1">return </span><span class="s0">buf;</span>
        <span class="s0">const swap = </span><span class="s1">new </span><span class="s0">Uint8Array(buf.length * </span><span class="s3">2</span><span class="s0">);</span>
        <span class="s0">swap.set(buf);</span>
        <span class="s1">return </span><span class="s0">swap;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">encodeInteger(buf, pos, state, segment, j) {</span>
        <span class="s0">const next = segment[j];</span>
        <span class="s0">let num = next - state[j];</span>
        <span class="s0">state[j] = next;</span>
        <span class="s0">num = num &lt; </span><span class="s3">0 </span><span class="s0">? (-num &lt;&lt; </span><span class="s3">1</span><span class="s0">) | </span><span class="s3">1 </span><span class="s0">: num &lt;&lt; </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">let clamped = num &amp; </span><span class="s3">0</span><span class="s0">b011111;</span>
            <span class="s0">num &gt;&gt;&gt;= </span><span class="s3">5</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(num &gt; </span><span class="s3">0</span><span class="s0">)</span>
                <span class="s0">clamped |= </span><span class="s3">0</span><span class="s0">b100000;</span>
            <span class="s0">buf[pos++] = intToChar[clamped];</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(num &gt; </span><span class="s3">0</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">pos;</span>
    <span class="s0">}</span>

    <span class="s4">// Matches the scheme of a URL, eg &quot;http://&quot;</span>
    <span class="s0">const schemeRegex = /^[\w+.-]+:\/\</span><span class="s4">//;</span>
    <span class="s4">/** 
     * Matches the parts of a URL: 
     * 1. Scheme, including &quot;:&quot;, guaranteed. 
     * 2. User/password, including &quot;@&quot;, optional. 
     * 3. Host, guaranteed. 
     * 4. Port, including &quot;:&quot;, optional. 
     * 5. Path, including &quot;/&quot;, optional. 
     */</span>
    <span class="s0">const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?/;</span>
    <span class="s4">/** 
     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start 
     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive). 
     * 
     * 1. Host, optional. 
     * 2. Path, which may inclue &quot;/&quot;, guaranteed. 
     */</span>
    <span class="s0">const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/]*)?)?(\/?.*)/i;</span>
    <span class="s1">function </span><span class="s0">isAbsoluteUrl(input) {</span>
        <span class="s1">return </span><span class="s0">schemeRegex.test(input);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isSchemeRelativeUrl(input) {</span>
        <span class="s1">return </span><span class="s0">input.startsWith(</span><span class="s2">'//'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isAbsolutePath(input) {</span>
        <span class="s1">return </span><span class="s0">input.startsWith(</span><span class="s2">'/'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isFileUrl(input) {</span>
        <span class="s1">return </span><span class="s0">input.startsWith(</span><span class="s2">'file:'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseAbsoluteUrl(input) {</span>
        <span class="s0">const match = urlRegex.exec(input);</span>
        <span class="s1">return </span><span class="s0">makeUrl(match[</span><span class="s3">1</span><span class="s0">], match[</span><span class="s3">2</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">, match[</span><span class="s3">3</span><span class="s0">], match[</span><span class="s3">4</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">, match[</span><span class="s3">5</span><span class="s0">] || </span><span class="s2">'/'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseFileUrl(input) {</span>
        <span class="s0">const match = fileRegex.exec(input);</span>
        <span class="s0">const path = match[</span><span class="s3">2</span><span class="s0">];</span>
        <span class="s1">return </span><span class="s0">makeUrl(</span><span class="s2">'file:'</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, match[</span><span class="s3">1</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, isAbsolutePath(path) ? path : </span><span class="s2">'/' </span><span class="s0">+ path);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">makeUrl(scheme, user, host, port, path) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">scheme,</span>
            <span class="s0">user,</span>
            <span class="s0">host,</span>
            <span class="s0">port,</span>
            <span class="s0">path,</span>
            <span class="s0">relativePath: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseUrl(input) {</span>
        <span class="s1">if </span><span class="s0">(isSchemeRelativeUrl(input)) {</span>
            <span class="s0">const url = parseAbsoluteUrl(</span><span class="s2">'http:' </span><span class="s0">+ input);</span>
            <span class="s0">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">url;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(isAbsolutePath(input)) {</span>
            <span class="s0">const url = parseAbsoluteUrl(</span><span class="s2">'http://foo.com' </span><span class="s0">+ input);</span>
            <span class="s0">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s0">url.host = </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">url;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(isFileUrl(input))</span>
            <span class="s1">return </span><span class="s0">parseFileUrl(input);</span>
        <span class="s1">if </span><span class="s0">(isAbsoluteUrl(input))</span>
            <span class="s1">return </span><span class="s0">parseAbsoluteUrl(input);</span>
        <span class="s0">const url = parseAbsoluteUrl(</span><span class="s2">'http://foo.com/' </span><span class="s0">+ input);</span>
        <span class="s0">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s0">url.host = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s0">url.relativePath = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">url;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">stripPathFilename(path) {</span>
        <span class="s4">// If a path ends with a parent directory &quot;..&quot;, then it's a relative path with excess parent</span>
        <span class="s4">// paths. It's not a file, so we can't strip it.</span>
        <span class="s1">if </span><span class="s0">(path.endsWith(</span><span class="s2">'/..'</span><span class="s0">))</span>
            <span class="s1">return </span><span class="s0">path;</span>
        <span class="s0">const index = path.lastIndexOf(</span><span class="s2">'/'</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">path.slice(</span><span class="s3">0</span><span class="s0">, index + </span><span class="s3">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mergePaths(url, base) {</span>
        <span class="s4">// If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.</span>
        <span class="s1">if </span><span class="s0">(!url.relativePath)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">normalizePath(base);</span>
        <span class="s4">// If the path is just a &quot;/&quot;, then it was an empty path to begin with (remember, we're a relative</span>
        <span class="s4">// path).</span>
        <span class="s1">if </span><span class="s0">(url.path === </span><span class="s2">'/'</span><span class="s0">) {</span>
            <span class="s0">url.path = base.path;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s4">// Resolution happens relative to the base path's directory, not the file.</span>
            <span class="s0">url.path = stripPathFilename(base.path) + url.path;</span>
        <span class="s0">}</span>
        <span class="s4">// If the base path is absolute, then our path is now absolute too.</span>
        <span class="s0">url.relativePath = base.relativePath;</span>
    <span class="s0">}</span>
    <span class="s4">/** 
     * The path can have empty directories &quot;//&quot;, unneeded parents &quot;foo/..&quot;, or current directory 
     * &quot;foo/.&quot;. We need to normalize to a standard representation. 
     */</span>
    <span class="s1">function </span><span class="s0">normalizePath(url) {</span>
        <span class="s0">const { relativePath } = url;</span>
        <span class="s0">const pieces = url.path.split(</span><span class="s2">'/'</span><span class="s0">);</span>
        <span class="s4">// We need to preserve the first piece always, so that we output a leading slash. The item at</span>
        <span class="s4">// pieces[0] is an empty string.</span>
        <span class="s0">let pointer = </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s4">// Positive is the number of real directories we've output, used for popping a parent directory.</span>
        <span class="s4">// Eg, &quot;foo/bar/..&quot; will have a positive 2, and we can decrement to be left with just &quot;foo&quot;.</span>
        <span class="s0">let positive = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s4">// We need to keep a trailing slash if we encounter an empty directory (eg, splitting &quot;foo/&quot; will</span>
        <span class="s4">// generate `[&quot;foo&quot;, &quot;&quot;]` pieces). And, if we pop a parent directory. But once we encounter a</span>
        <span class="s4">// real directory, we won't need to append, unless the other conditions happen again.</span>
        <span class="s0">let addTrailingSlash = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">1</span><span class="s0">; i &lt; pieces.length; i++) {</span>
            <span class="s0">const piece = pieces[i];</span>
            <span class="s4">// An empty directory, could be a trailing slash, or just a double &quot;//&quot; in the path.</span>
            <span class="s1">if </span><span class="s0">(!piece) {</span>
                <span class="s0">addTrailingSlash = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s4">// If we encounter a real directory, then we don't need to append anymore.</span>
            <span class="s0">addTrailingSlash = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s4">// A current directory, which we can always drop.</span>
            <span class="s1">if </span><span class="s0">(piece === </span><span class="s2">'.'</span><span class="s0">)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s4">// A parent directory, we need to see if there are any real directories we can pop. Else, we</span>
            <span class="s4">// have an excess of parents, and we'll need to keep the &quot;..&quot;.</span>
            <span class="s1">if </span><span class="s0">(piece === </span><span class="s2">'..'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(positive) {</span>
                    <span class="s0">addTrailingSlash = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">positive--;</span>
                    <span class="s0">pointer--;</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(relativePath) {</span>
                    <span class="s4">// If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute</span>
                    <span class="s4">// URL, protocol relative URL, or an absolute path, we don't need to keep excess.</span>
                    <span class="s0">pieces[pointer++] = piece;</span>
                <span class="s0">}</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s4">// We've encountered a real directory. Move it to the next insertion pointer, which accounts for</span>
            <span class="s4">// any popped or dropped directories.</span>
            <span class="s0">pieces[pointer++] = piece;</span>
            <span class="s0">positive++;</span>
        <span class="s0">}</span>
        <span class="s0">let path = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">1</span><span class="s0">; i &lt; pointer; i++) {</span>
            <span class="s0">path += </span><span class="s2">'/' </span><span class="s0">+ pieces[i];</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!path || (addTrailingSlash &amp;&amp; !path.endsWith(</span><span class="s2">'/..'</span><span class="s0">))) {</span>
            <span class="s0">path += </span><span class="s2">'/'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">url.path = path;</span>
    <span class="s0">}</span>
    <span class="s4">/** 
     * Attempts to resolve `input` URL/path relative to `base`. 
     */</span>
    <span class="s1">function </span><span class="s0">resolve$1(input, base) {</span>
        <span class="s1">if </span><span class="s0">(!input &amp;&amp; !base)</span>
            <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s0">const url = parseUrl(input);</span>
        <span class="s4">// If we have a base, and the input isn't already an absolute URL, then we need to merge.</span>
        <span class="s1">if </span><span class="s0">(base &amp;&amp; !url.scheme) {</span>
            <span class="s0">const baseUrl = parseUrl(base);</span>
            <span class="s0">url.scheme = baseUrl.scheme;</span>
            <span class="s4">// If there's no host, then we were just a path.</span>
            <span class="s1">if </span><span class="s0">(!url.host) {</span>
                <span class="s4">// The host, user, and port are joined, you can't copy one without the others.</span>
                <span class="s0">url.user = baseUrl.user;</span>
                <span class="s0">url.host = baseUrl.host;</span>
                <span class="s0">url.port = baseUrl.port;</span>
            <span class="s0">}</span>
            <span class="s0">mergePaths(url, baseUrl);</span>
        <span class="s0">}</span>
        <span class="s0">normalizePath(url);</span>
        <span class="s4">// If the input (and base, if there was one) are both relative, then we need to output a relative.</span>
        <span class="s1">if </span><span class="s0">(url.relativePath) {</span>
            <span class="s4">// The first char is always a &quot;/&quot;.</span>
            <span class="s0">const path = url.path.slice(</span><span class="s3">1</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(!path)</span>
                <span class="s1">return </span><span class="s2">'.'</span><span class="s0">;</span>
            <span class="s4">// If base started with a leading &quot;.&quot;, or there is no base and input started with a &quot;.&quot;, then we</span>
            <span class="s4">// need to ensure that the relative path starts with a &quot;.&quot;. We don't know if relative starts</span>
            <span class="s4">// with a &quot;..&quot;, though, so check before prepending.</span>
            <span class="s0">const keepRelative = (base || input).startsWith(</span><span class="s2">'.'</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">!keepRelative || path.startsWith(</span><span class="s2">'.'</span><span class="s0">) ? path : </span><span class="s2">'./' </span><span class="s0">+ path;</span>
        <span class="s0">}</span>
        <span class="s4">// If there's no host (and no scheme/user/port), then we need to output an absolute path.</span>
        <span class="s1">if </span><span class="s0">(!url.scheme &amp;&amp; !url.host)</span>
            <span class="s1">return </span><span class="s0">url.path;</span>
        <span class="s4">// We're outputting either an absolute URL, or a protocol relative one.</span>
        <span class="s1">return </span><span class="s0">`${url.scheme}</span><span class="s4">//${url.user}${url.host}${url.port}${url.path}`;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">resolve(input, base) {</span>
        <span class="s4">// The base is always treated as a directory, if it's not empty.</span>
        <span class="s4">// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327</span>
        <span class="s4">// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401</span>
        <span class="s1">if </span><span class="s0">(base &amp;&amp; !base.endsWith(</span><span class="s2">'/'</span><span class="s0">))</span>
            <span class="s0">base += </span><span class="s2">'/'</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">resolve$1(input, base);</span>
    <span class="s0">}</span>

    <span class="s4">/** 
     * Removes everything after the last &quot;/&quot;, but leaves the slash. 
     */</span>
    <span class="s1">function </span><span class="s0">stripFilename(path) {</span>
        <span class="s1">if </span><span class="s0">(!path)</span>
            <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s0">const index = path.lastIndexOf(</span><span class="s2">'/'</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">path.slice(</span><span class="s3">0</span><span class="s0">, index + </span><span class="s3">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">const COLUMN$1 = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">const SOURCES_INDEX$1 = </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">const SOURCE_LINE$1 = </span><span class="s3">2</span><span class="s0">;</span>
    <span class="s0">const SOURCE_COLUMN$1 = </span><span class="s3">3</span><span class="s0">;</span>
    <span class="s0">const NAMES_INDEX$1 = </span><span class="s3">4</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">maybeSort(mappings, owned) {</span>
        <span class="s0">const unsortedIndex = nextUnsortedSegmentLine(mappings, </span><span class="s3">0</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(unsortedIndex === mappings.length)</span>
            <span class="s1">return </span><span class="s0">mappings;</span>
        <span class="s4">// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If</span>
        <span class="s4">// not, we do not want to modify the consumer's input array.</span>
        <span class="s1">if </span><span class="s0">(!owned)</span>
            <span class="s0">mappings = mappings.slice();</span>
        <span class="s1">for </span><span class="s0">(let i = unsortedIndex; i &lt; mappings.length; i = nextUnsortedSegmentLine(mappings, i + </span><span class="s3">1</span><span class="s0">)) {</span>
            <span class="s0">mappings[i] = sortSegments(mappings[i], owned);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mappings;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">nextUnsortedSegmentLine(mappings, start) {</span>
        <span class="s1">for </span><span class="s0">(let i = start; i &lt; mappings.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(!isSorted(mappings[i]))</span>
                <span class="s1">return </span><span class="s0">i;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mappings.length;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isSorted(line) {</span>
        <span class="s1">for </span><span class="s0">(let j = </span><span class="s3">1</span><span class="s0">; j &lt; line.length; j++) {</span>
            <span class="s1">if </span><span class="s0">(line[j][COLUMN$1] &lt; line[j - </span><span class="s3">1</span><span class="s0">][COLUMN$1]) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sortSegments(line, owned) {</span>
        <span class="s1">if </span><span class="s0">(!owned)</span>
            <span class="s0">line = line.slice();</span>
        <span class="s1">return </span><span class="s0">line.sort(sortComparator);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sortComparator(a, b) {</span>
        <span class="s1">return </span><span class="s0">a[COLUMN$1] - b[COLUMN$1];</span>
    <span class="s0">}</span>

    <span class="s0">let found = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s4">/** 
     * A binary search implementation that returns the index if a match is found. 
     * If no match is found, then the left-index (the index associated with the item that comes just 
     * before the desired index) is returned. To maintain proper sort order, a splice would happen at 
     * the next index: 
     * 
     * ```js 
     * const array = [1, 3]; 
     * const needle = 2; 
     * const index = binarySearch(array, needle, (item, needle) =&gt; item - needle); 
     * 
     * assert.equal(index, 0); 
     * array.splice(index + 1, 0, needle); 
     * assert.deepEqual(array, [1, 2, 3]); 
     * ``` 
     */</span>
    <span class="s1">function </span><span class="s0">binarySearch(haystack, needle, low, high) {</span>
        <span class="s1">while </span><span class="s0">(low &lt;= high) {</span>
            <span class="s0">const mid = low + ((high - low) &gt;&gt; </span><span class="s3">1</span><span class="s0">);</span>
            <span class="s0">const cmp = haystack[mid][COLUMN$1] - needle;</span>
            <span class="s1">if </span><span class="s0">(cmp === </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s0">found = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">mid;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(cmp &lt; </span><span class="s3">0</span><span class="s0">) {</span>
                <span class="s0">low = mid + </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">high = mid - </span><span class="s3">1</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">found = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">low - </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">upperBound(haystack, needle, index) {</span>
        <span class="s1">for </span><span class="s0">(let i = index + </span><span class="s3">1</span><span class="s0">; i &lt; haystack.length; i++, index++) {</span>
            <span class="s1">if </span><span class="s0">(haystack[i][COLUMN$1] !== needle)</span>
                <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">index;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">lowerBound(haystack, needle, index) {</span>
        <span class="s1">for </span><span class="s0">(let i = index - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--, index--) {</span>
            <span class="s1">if </span><span class="s0">(haystack[i][COLUMN$1] !== needle)</span>
                <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">index;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">memoizedState() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">lastKey: -</span><span class="s3">1</span><span class="s0">,</span>
            <span class="s0">lastNeedle: -</span><span class="s3">1</span><span class="s0">,</span>
            <span class="s0">lastIndex: -</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s4">/** 
     * This overly complicated beast is just to record the last tested line/column and the resulting 
     * index, allowing us to skip a few tests if mappings are monotonically increasing. 
     */</span>
    <span class="s1">function </span><span class="s0">memoizedBinarySearch(haystack, needle, state, key) {</span>
        <span class="s0">const { lastKey, lastNeedle, lastIndex } = state;</span>
        <span class="s0">let low = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s0">let high = haystack.length - </span><span class="s3">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(key === lastKey) {</span>
            <span class="s1">if </span><span class="s0">(needle === lastNeedle) {</span>
                <span class="s0">found = lastIndex !== -</span><span class="s3">1 </span><span class="s0">&amp;&amp; haystack[lastIndex][COLUMN$1] === needle;</span>
                <span class="s1">return </span><span class="s0">lastIndex;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(needle &gt;= lastNeedle) {</span>
                <span class="s4">// lastIndex may be -1 if the previous needle was not found.</span>
                <span class="s0">low = lastIndex === -</span><span class="s3">1 </span><span class="s0">? </span><span class="s3">0 </span><span class="s0">: lastIndex;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">high = lastIndex;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">state.lastKey = key;</span>
        <span class="s0">state.lastNeedle = needle;</span>
        <span class="s1">return </span><span class="s0">(state.lastIndex = binarySearch(haystack, needle, low, high));</span>
    <span class="s0">}</span>

    <span class="s0">const AnyMap = </span><span class="s1">function </span><span class="s0">(map, mapUrl) {</span>
        <span class="s0">const parsed = </span><span class="s1">typeof </span><span class="s0">map === </span><span class="s2">'string' </span><span class="s0">? JSON.parse(map) : map;</span>
        <span class="s1">if </span><span class="s0">(!(</span><span class="s2">'sections' </span><span class="s1">in </span><span class="s0">parsed))</span>
            <span class="s1">return new </span><span class="s0">TraceMap(parsed, mapUrl);</span>
        <span class="s0">const mappings = [];</span>
        <span class="s0">const sources = [];</span>
        <span class="s0">const sourcesContent = [];</span>
        <span class="s0">const names = [];</span>
        <span class="s0">const { sections } = parsed;</span>
        <span class="s0">let i = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(; i &lt; sections.length - </span><span class="s3">1</span><span class="s0">; i++) {</span>
            <span class="s0">const no = sections[i + </span><span class="s3">1</span><span class="s0">].offset;</span>
            <span class="s0">addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(sections.length &gt; </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s0">addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);</span>
        <span class="s0">}</span>
        <span class="s0">const joined = {</span>
            <span class="s0">version: </span><span class="s3">3</span><span class="s0">,</span>
            <span class="s0">file: parsed.file,</span>
            <span class="s0">names,</span>
            <span class="s0">sources,</span>
            <span class="s0">sourcesContent,</span>
            <span class="s0">mappings,</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">presortedDecodedMap(joined);</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {</span>
        <span class="s0">const map = AnyMap(section.map, mapUrl);</span>
        <span class="s0">const { line: lineOffset, column: columnOffset } = section.offset;</span>
        <span class="s0">const sourcesOffset = sources.length;</span>
        <span class="s0">const namesOffset = names.length;</span>
        <span class="s0">const decoded = decodedMappings(map);</span>
        <span class="s0">const { resolvedSources } = map;</span>
        <span class="s0">append(sources, resolvedSources);</span>
        <span class="s0">append(sourcesContent, map.sourcesContent || fillSourcesContent(resolvedSources.length));</span>
        <span class="s0">append(names, map.names);</span>
        <span class="s4">// If this section jumps forwards several lines, we need to add lines to the output mappings catch up.</span>
        <span class="s1">for </span><span class="s0">(let i = mappings.length; i &lt;= lineOffset; i++)</span>
            <span class="s0">mappings.push([]);</span>
        <span class="s4">// We can only add so many lines before we step into the range that the next section's map</span>
        <span class="s4">// controls. When we get to the last line, then we'll start checking the segments to see if</span>
        <span class="s4">// they've crossed into the column range.</span>
        <span class="s0">const stopI = stopLine - lineOffset;</span>
        <span class="s0">const len = Math.min(decoded.length, stopI + </span><span class="s3">1</span><span class="s0">);</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">0</span><span class="s0">; i &lt; len; i++) {</span>
            <span class="s0">const line = decoded[i];</span>
            <span class="s4">// On the 0th loop, the line will already exist due to a previous section, or the line catch up</span>
            <span class="s4">// loop above.</span>
            <span class="s0">const out = i === </span><span class="s3">0 </span><span class="s0">? mappings[lineOffset] : (mappings[lineOffset + i] = []);</span>
            <span class="s4">// On the 0th loop, the section's column offset shifts us forward. On all other lines (since the</span>
            <span class="s4">// map can be multiple lines), it doesn't.</span>
            <span class="s0">const cOffset = i === </span><span class="s3">0 </span><span class="s0">? columnOffset : </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(let j = </span><span class="s3">0</span><span class="s0">; j &lt; line.length; j++) {</span>
                <span class="s0">const seg = line[j];</span>
                <span class="s0">const column = cOffset + seg[COLUMN$1];</span>
                <span class="s4">// If this segment steps into the column range that the next section's map controls, we need</span>
                <span class="s4">// to stop early.</span>
                <span class="s1">if </span><span class="s0">(i === stopI &amp;&amp; column &gt;= stopColumn)</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(seg.length === </span><span class="s3">1</span><span class="s0">) {</span>
                    <span class="s0">out.push([column]);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX$1];</span>
                <span class="s0">const sourceLine = seg[SOURCE_LINE$1];</span>
                <span class="s0">const sourceColumn = seg[SOURCE_COLUMN$1];</span>
                <span class="s1">if </span><span class="s0">(seg.length === </span><span class="s3">4</span><span class="s0">) {</span>
                    <span class="s0">out.push([column, sourcesIndex, sourceLine, sourceColumn]);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX$1]]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">append(arr, other) {</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">0</span><span class="s0">; i &lt; other.length; i++)</span>
            <span class="s0">arr.push(other[i]);</span>
    <span class="s0">}</span>
    <span class="s4">// Sourcemaps don't need to have sourcesContent, and if they don't, we need to create an array of</span>
    <span class="s4">// equal length to the sources. This is because the sources and sourcesContent are paired arrays,</span>
    <span class="s4">// where `sourcesContent[i]` is the content of the `sources[i]` file. If we didn't, then joined</span>
    <span class="s4">// sourcemap would desynchronize the sources/contents.</span>
    <span class="s1">function </span><span class="s0">fillSourcesContent(len) {</span>
        <span class="s0">const sourcesContent = [];</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s3">0</span><span class="s0">; i &lt; len; i++)</span>
            <span class="s0">sourcesContent[i] = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">sourcesContent;</span>
    <span class="s0">}</span>

    <span class="s0">const INVALID_ORIGINAL_MAPPING = Object.freeze({</span>
        <span class="s0">source: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">line: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">column: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">name: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">});</span>
    <span class="s0">Object.freeze({</span>
        <span class="s0">line: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">column: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">});</span>
    <span class="s0">const LINE_GTR_ZERO = </span><span class="s2">'`line` must be greater than 0 (lines start at line 1)'</span><span class="s0">;</span>
    <span class="s0">const COL_GTR_EQ_ZERO = </span><span class="s2">'`column` must be greater than or equal to 0 (columns start at column 0)'</span><span class="s0">;</span>
    <span class="s0">const LEAST_UPPER_BOUND = -</span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">const GREATEST_LOWER_BOUND = </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s4">/** 
     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field. 
     */</span>
    <span class="s0">let decodedMappings;</span>
    <span class="s4">/** 
     * A higher-level API to find the source/line/column associated with a generated line/column 
     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in 
     * `source-map` library. 
     */</span>
    <span class="s0">let originalPositionFor;</span>
    <span class="s4">/** 
     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger 
     * maps. 
     */</span>
    <span class="s0">let presortedDecodedMap;</span>
    <span class="s0">class TraceMap {</span>
        <span class="s0">constructor(map, mapUrl) {</span>
            <span class="s1">this</span><span class="s0">._decodedMemo = memoizedState();</span>
            <span class="s1">this</span><span class="s0">._bySources = undefined;</span>
            <span class="s1">this</span><span class="s0">._bySourceMemos = undefined;</span>
            <span class="s0">const isString = </span><span class="s1">typeof </span><span class="s0">map === </span><span class="s2">'string'</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!isString &amp;&amp; map.constructor === TraceMap)</span>
                <span class="s1">return </span><span class="s0">map;</span>
            <span class="s0">const parsed = (isString ? JSON.parse(map) : map);</span>
            <span class="s0">const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;</span>
            <span class="s1">this</span><span class="s0">.version = version;</span>
            <span class="s1">this</span><span class="s0">.file = file;</span>
            <span class="s1">this</span><span class="s0">.names = names;</span>
            <span class="s1">this</span><span class="s0">.sourceRoot = sourceRoot;</span>
            <span class="s1">this</span><span class="s0">.sources = sources;</span>
            <span class="s1">this</span><span class="s0">.sourcesContent = sourcesContent;</span>
            <span class="s1">if </span><span class="s0">(sourceRoot || mapUrl) {</span>
                <span class="s0">const from = resolve(sourceRoot || </span><span class="s2">''</span><span class="s0">, stripFilename(mapUrl));</span>
                <span class="s1">this</span><span class="s0">.resolvedSources = sources.map((s) =&gt; resolve(s || </span><span class="s2">''</span><span class="s0">, from));</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.resolvedSources = sources.map((s) =&gt; s || </span><span class="s2">''</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">const { mappings } = parsed;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">mappings === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">._encoded = mappings;</span>
                <span class="s1">this</span><span class="s0">._decoded = undefined;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">._encoded = undefined;</span>
                <span class="s1">this</span><span class="s0">._decoded = maybeSort(mappings, isString);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(() =&gt; {</span>
        <span class="s0">decodedMappings = (map) =&gt; {</span>
            <span class="s1">return </span><span class="s0">(map._decoded || (map._decoded = decode(map._encoded)));</span>
        <span class="s0">};</span>
        <span class="s0">originalPositionFor = (map, { line, column, bias }) =&gt; {</span>
            <span class="s0">line--;</span>
            <span class="s1">if </span><span class="s0">(line &lt; </span><span class="s3">0</span><span class="s0">)</span>
                <span class="s1">throw new </span><span class="s0">Error(LINE_GTR_ZERO);</span>
            <span class="s1">if </span><span class="s0">(column &lt; </span><span class="s3">0</span><span class="s0">)</span>
                <span class="s1">throw new </span><span class="s0">Error(COL_GTR_EQ_ZERO);</span>
            <span class="s0">const decoded = decodedMappings(map);</span>
            <span class="s4">// It's common for parent source maps to have pointers to lines that have no</span>
            <span class="s4">// mapping (like a &quot;//# sourceMappingURL=&quot;) at the end of the child file.</span>
            <span class="s1">if </span><span class="s0">(line &gt;= decoded.length)</span>
                <span class="s1">return </span><span class="s0">INVALID_ORIGINAL_MAPPING;</span>
            <span class="s0">const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);</span>
            <span class="s1">if </span><span class="s0">(segment == </span><span class="s1">null</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">INVALID_ORIGINAL_MAPPING;</span>
            <span class="s1">if </span><span class="s0">(segment.length == </span><span class="s3">1</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">INVALID_ORIGINAL_MAPPING;</span>
            <span class="s0">const { names, resolvedSources } = map;</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">source: resolvedSources[segment[SOURCES_INDEX$1]],</span>
                <span class="s0">line: segment[SOURCE_LINE$1] + </span><span class="s3">1</span><span class="s0">,</span>
                <span class="s0">column: segment[SOURCE_COLUMN$1],</span>
                <span class="s0">name: segment.length === </span><span class="s3">5 </span><span class="s0">? names[segment[NAMES_INDEX$1]] : </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
        <span class="s0">presortedDecodedMap = (map, mapUrl) =&gt; {</span>
            <span class="s0">const clone = Object.assign({}, map);</span>
            <span class="s0">clone.mappings = [];</span>
            <span class="s0">const tracer = </span><span class="s1">new </span><span class="s0">TraceMap(clone, mapUrl);</span>
            <span class="s0">tracer._decoded = map.mappings;</span>
            <span class="s1">return </span><span class="s0">tracer;</span>
        <span class="s0">};</span>
    <span class="s0">})();</span>
    <span class="s1">function </span><span class="s0">traceSegmentInternal(segments, memo, line, column, bias) {</span>
        <span class="s0">let index = memoizedBinarySearch(segments, column, memo, line);</span>
        <span class="s1">if </span><span class="s0">(found) {</span>
            <span class="s0">index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(bias === LEAST_UPPER_BOUND)</span>
            <span class="s0">index++;</span>
        <span class="s1">if </span><span class="s0">(index === -</span><span class="s3">1 </span><span class="s0">|| index === segments.length)</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">segments[index];</span>
    <span class="s0">}</span>

    <span class="s4">/** 
     * Gets the index associated with `key` in the backing array, if it is already present. 
     */</span>
    <span class="s0">let get;</span>
    <span class="s4">/** 
     * Puts `key` into the backing array, if it is not already present. Returns 
     * the index of the `key` in the backing array. 
     */</span>
    <span class="s0">let put;</span>
    <span class="s4">/** 
     * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the 
     * index of the `key` in the backing array. 
     * 
     * This is designed to allow synchronizing a second array with the contents of the backing array, 
     * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`, 
     * and there are never duplicates. 
     */</span>
    <span class="s0">class SetArray {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">._indexes = { __proto__: </span><span class="s1">null </span><span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.array = [];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(() =&gt; {</span>
        <span class="s0">get = (strarr, key) =&gt; strarr._indexes[key];</span>
        <span class="s0">put = (strarr, key) =&gt; {</span>
            <span class="s4">// The key may or may not be present. If it is present, it's a number.</span>
            <span class="s0">const index = get(strarr, key);</span>
            <span class="s1">if </span><span class="s0">(index !== undefined)</span>
                <span class="s1">return </span><span class="s0">index;</span>
            <span class="s0">const { array, _indexes: indexes } = strarr;</span>
            <span class="s1">return </span><span class="s0">(indexes[key] = array.push(key) - </span><span class="s3">1</span><span class="s0">);</span>
        <span class="s0">};</span>
    <span class="s0">})();</span>

    <span class="s0">const COLUMN = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">const SOURCES_INDEX = </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">const SOURCE_LINE = </span><span class="s3">2</span><span class="s0">;</span>
    <span class="s0">const SOURCE_COLUMN = </span><span class="s3">3</span><span class="s0">;</span>
    <span class="s0">const NAMES_INDEX = </span><span class="s3">4</span><span class="s0">;</span>

    <span class="s0">const NO_NAME = -</span><span class="s3">1</span><span class="s0">;</span>
    <span class="s4">/** 
     * Same as `addMapping`, but will only add the mapping if it generates useful information in the 
     * resulting map. This only works correctly if mappings are added **in order**, meaning you should 
     * not add a mapping with a lower generated line/column than one that came before. 
     */</span>
    <span class="s0">let maybeAddMapping;</span>
    <span class="s4">/** 
     * Adds/removes the content of the source file to the source map. 
     */</span>
    <span class="s0">let setSourceContent;</span>
    <span class="s4">/** 
     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects 
     * a sourcemap, or to JSON.stringify. 
     */</span>
    <span class="s0">let toDecodedMap;</span>
    <span class="s4">/** 
     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects 
     * a sourcemap, or to JSON.stringify. 
     */</span>
    <span class="s0">let toEncodedMap;</span>
    <span class="s4">// This split declaration is only so that terser can elminiate the static initialization block.</span>
    <span class="s0">let addSegmentInternal;</span>
    <span class="s4">/** 
     * Provides the state to generate a sourcemap. 
     */</span>
    <span class="s0">class GenMapping {</span>
        <span class="s0">constructor({ file, sourceRoot } = {}) {</span>
            <span class="s1">this</span><span class="s0">._names = </span><span class="s1">new </span><span class="s0">SetArray();</span>
            <span class="s1">this</span><span class="s0">._sources = </span><span class="s1">new </span><span class="s0">SetArray();</span>
            <span class="s1">this</span><span class="s0">._sourcesContent = [];</span>
            <span class="s1">this</span><span class="s0">._mappings = [];</span>
            <span class="s1">this</span><span class="s0">.file = file;</span>
            <span class="s1">this</span><span class="s0">.sourceRoot = sourceRoot;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(() =&gt; {</span>
        <span class="s0">maybeAddMapping = (map, mapping) =&gt; {</span>
            <span class="s1">return </span><span class="s0">addMappingInternal(</span><span class="s1">true</span><span class="s0">, map, mapping);</span>
        <span class="s0">};</span>
        <span class="s0">setSourceContent = (map, source, content) =&gt; {</span>
            <span class="s0">const { _sources: sources, _sourcesContent: sourcesContent } = map;</span>
            <span class="s0">sourcesContent[put(sources, source)] = content;</span>
        <span class="s0">};</span>
        <span class="s0">toDecodedMap = (map) =&gt; {</span>
            <span class="s0">const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;</span>
            <span class="s0">removeEmptyFinalLines(mappings);</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">version: </span><span class="s3">3</span><span class="s0">,</span>
                <span class="s0">file: file || undefined,</span>
                <span class="s0">names: names.array,</span>
                <span class="s0">sourceRoot: sourceRoot || undefined,</span>
                <span class="s0">sources: sources.array,</span>
                <span class="s0">sourcesContent,</span>
                <span class="s0">mappings,</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
        <span class="s0">toEncodedMap = (map) =&gt; {</span>
            <span class="s0">const decoded = toDecodedMap(map);</span>
            <span class="s1">return </span><span class="s0">Object.assign(Object.assign({}, decoded), { mappings: encode(decoded.mappings) });</span>
        <span class="s0">};</span>
        <span class="s4">// Internal helpers</span>
        <span class="s0">addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name) =&gt; {</span>
            <span class="s0">const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;</span>
            <span class="s0">const line = getLine(mappings, genLine);</span>
            <span class="s0">const index = getColumnIndex(line, genColumn);</span>
            <span class="s1">if </span><span class="s0">(!source) {</span>
                <span class="s1">if </span><span class="s0">(skipable &amp;&amp; skipSourceless(line, index))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">insert(line, index, [genColumn]);</span>
            <span class="s0">}</span>
            <span class="s0">const sourcesIndex = put(sources, source);</span>
            <span class="s0">const namesIndex = name ? put(names, name) : NO_NAME;</span>
            <span class="s1">if </span><span class="s0">(sourcesIndex === sourcesContent.length)</span>
                <span class="s0">sourcesContent[sourcesIndex] = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(skipable &amp;&amp; skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">insert(line, index, name</span>
                <span class="s0">? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]</span>
                <span class="s0">: [genColumn, sourcesIndex, sourceLine, sourceColumn]);</span>
        <span class="s0">};</span>
    <span class="s0">})();</span>
    <span class="s1">function </span><span class="s0">getLine(mappings, index) {</span>
        <span class="s1">for </span><span class="s0">(let i = mappings.length; i &lt;= index; i++) {</span>
            <span class="s0">mappings[i] = [];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mappings[index];</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getColumnIndex(line, genColumn) {</span>
        <span class="s0">let index = line.length;</span>
        <span class="s1">for </span><span class="s0">(let i = index - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; index = i--) {</span>
            <span class="s0">const current = line[i];</span>
            <span class="s1">if </span><span class="s0">(genColumn &gt;= current[COLUMN])</span>
                <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">index;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">insert(array, index, value) {</span>
        <span class="s1">for </span><span class="s0">(let i = array.length; i &gt; index; i--) {</span>
            <span class="s0">array[i] = array[i - </span><span class="s3">1</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s0">array[index] = value;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">removeEmptyFinalLines(mappings) {</span>
        <span class="s0">const { length } = mappings;</span>
        <span class="s0">let len = length;</span>
        <span class="s1">for </span><span class="s0">(let i = len - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; len = i, i--) {</span>
            <span class="s1">if </span><span class="s0">(mappings[i].length &gt; </span><span class="s3">0</span><span class="s0">)</span>
                <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(len &lt; length)</span>
            <span class="s0">mappings.length = len;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">skipSourceless(line, index) {</span>
        <span class="s4">// The start of a line is already sourceless, so adding a sourceless segment to the beginning</span>
        <span class="s4">// doesn't generate any useful information.</span>
        <span class="s1">if </span><span class="s0">(index === </span><span class="s3">0</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">const prev = line[index - </span><span class="s3">1</span><span class="s0">];</span>
        <span class="s4">// If the previous segment is also sourceless, then adding another sourceless segment doesn't</span>
        <span class="s4">// genrate any new information. Else, this segment will end the source/named segment and point to</span>
        <span class="s4">// a sourceless position, which is useful.</span>
        <span class="s1">return </span><span class="s0">prev.length === </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {</span>
        <span class="s4">// A source/named segment at the start of a line gives position at that genColumn</span>
        <span class="s1">if </span><span class="s0">(index === </span><span class="s3">0</span><span class="s0">)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">const prev = line[index - </span><span class="s3">1</span><span class="s0">];</span>
        <span class="s4">// If the previous segment is sourceless, then we're transitioning to a source.</span>
        <span class="s1">if </span><span class="s0">(prev.length === </span><span class="s3">1</span><span class="s0">)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s4">// If the previous segment maps to the exact same source position, then this segment doesn't</span>
        <span class="s4">// provide any new position information.</span>
        <span class="s1">return </span><span class="s0">(sourcesIndex === prev[SOURCES_INDEX] &amp;&amp;</span>
            <span class="s0">sourceLine === prev[SOURCE_LINE] &amp;&amp;</span>
            <span class="s0">sourceColumn === prev[SOURCE_COLUMN] &amp;&amp;</span>
            <span class="s0">namesIndex === (prev.length === </span><span class="s3">5 </span><span class="s0">? prev[NAMES_INDEX] : NO_NAME));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">addMappingInternal(skipable, map, mapping) {</span>
        <span class="s0">const { generated, source, original, name } = mapping;</span>
        <span class="s1">if </span><span class="s0">(!source) {</span>
            <span class="s1">return </span><span class="s0">addSegmentInternal(skipable, map, generated.line - </span><span class="s3">1</span><span class="s0">, generated.column, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">const s = source;</span>
        <span class="s1">return </span><span class="s0">addSegmentInternal(skipable, map, generated.line - </span><span class="s3">1</span><span class="s0">, generated.column, s, original.line - </span><span class="s3">1</span><span class="s0">, original.column, name);</span>
    <span class="s0">}</span>

    <span class="s0">class SourceMapConsumer {</span>
        <span class="s0">constructor(map, mapUrl) {</span>
            <span class="s0">const trace = (</span><span class="s1">this</span><span class="s0">._map = </span><span class="s1">new </span><span class="s0">AnyMap(map, mapUrl));</span>
            <span class="s1">this</span><span class="s0">.file = trace.file;</span>
            <span class="s1">this</span><span class="s0">.names = trace.names;</span>
            <span class="s1">this</span><span class="s0">.sourceRoot = trace.sourceRoot;</span>
            <span class="s1">this</span><span class="s0">.sources = trace.resolvedSources;</span>
            <span class="s1">this</span><span class="s0">.sourcesContent = trace.sourcesContent;</span>
        <span class="s0">}</span>
        <span class="s0">originalPositionFor(needle) {</span>
            <span class="s1">return </span><span class="s0">originalPositionFor(</span><span class="s1">this</span><span class="s0">._map, needle);</span>
        <span class="s0">}</span>
        <span class="s0">destroy() {</span>
            <span class="s4">// noop.</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">class SourceMapGenerator {</span>
        <span class="s0">constructor(opts) {</span>
            <span class="s1">this</span><span class="s0">._map = </span><span class="s1">new </span><span class="s0">GenMapping(opts);</span>
        <span class="s0">}</span>
        <span class="s0">addMapping(mapping) {</span>
            <span class="s0">maybeAddMapping(</span><span class="s1">this</span><span class="s0">._map, mapping);</span>
        <span class="s0">}</span>
        <span class="s0">setSourceContent(source, content) {</span>
            <span class="s0">setSourceContent(</span><span class="s1">this</span><span class="s0">._map, source, content);</span>
        <span class="s0">}</span>
        <span class="s0">toJSON() {</span>
            <span class="s1">return </span><span class="s0">toEncodedMap(</span><span class="s1">this</span><span class="s0">._map);</span>
        <span class="s0">}</span>
        <span class="s0">toDecodedMap() {</span>
            <span class="s1">return </span><span class="s0">toDecodedMap(</span><span class="s1">this</span><span class="s0">._map);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">exports.SourceMapConsumer = SourceMapConsumer;</span>
    <span class="s0">exports.SourceMapGenerator = SourceMapGenerator;</span>

    <span class="s0">Object.defineProperty(exports, </span><span class="s2">'__esModule'</span><span class="s0">, { value: </span><span class="s1">true </span><span class="s0">});</span>

<span class="s0">}));</span>
<span class="s4">//# sourceMappingURL=source-map.umd.js.map</span>
</pre>
</body>
</html>
<html>
<head>
<title>expression-scope.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
expression-scope.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_parseError&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;kExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;kMaybeArrowParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;kMaybeAsyncArrowParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;kParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;ExpressionScope&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;canBeArrowParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isCertainlyParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrowHeadParsingScope&quot;</span><span class="s0">,</span><span class="s1">&quot;declarationErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;recordDeclarationError&quot;</span><span class="s0">,</span><span class="s1">&quot;ParsingErrorClass&quot;</span><span class="s0">,</span><span class="s1">&quot;at&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;clearDeclarationError&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;iterateErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;ExpressionScopeHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;parser&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;enter&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;recordParameterInitializerError&quot;</span><span class="s0">,</span><span class="s1">&quot;toParseError&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;raise&quot;</span><span class="s0">,</span><span class="s1">&quot;recordArrowParameterBindingError&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;recordAsyncArrowParametersError&quot;</span><span class="s0">,</span><span class="s1">&quot;Errors&quot;</span><span class="s0">,</span><span class="s1">&quot;AwaitBindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;validateAsPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;currentScope&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;newParameterDeclarationScope&quot;</span><span class="s0">,</span><span class="s1">&quot;newArrowHeadScope&quot;</span><span class="s0">,</span><span class="s1">&quot;newAsyncArrowScope&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpressionScope&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/util/expression-scope.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Errors, type ParseErrorConstructor } from </span><span class="s3">\&quot;</span><span class="s1">../parse-error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Position } from </span><span class="s3">\&quot;</span><span class="s1">./location</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Node } from </span><span class="s3">\&quot;</span><span class="s1">../types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Tokenizer from </span><span class="s3">\&quot;</span><span class="s1">../tokenizer</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @module util/expression-scope</span><span class="s3">\n\n</span><span class="s1">ExpressionScope is used to track declaration errors in these ambiguous patterns:</span><span class="s3">\n\n</span><span class="s1">- CoverParenthesizedExpressionAndArrowParameterList</span><span class="s3">\n  </span><span class="s1">e.g. we don't know if `({ x })` is an parenthesized expression or an</span><span class="s3">\n  </span><span class="s1">arrow function parameters until we see an `=&gt;` after `)`.</span><span class="s3">\n\n</span><span class="s1">- CoverCallExpressionAndAsyncArrowHead</span><span class="s3">\n  </span><span class="s1">e.g. we don't know if `async({ x })` is a call expression or an async arrow</span><span class="s3">\n  </span><span class="s1">function parameters until we see an `=&gt;` after `)`</span><span class="s3">\n\n</span><span class="s1">The following declaration errors (@see parser-errors/standard) will be recorded in</span><span class="s3">\n</span><span class="s1">some expression scopes and thrown later when we know what the ambiguous pattern is</span><span class="s3">\n\n</span><span class="s1">- AwaitBindingIdentifier</span><span class="s3">\n</span><span class="s1">- AwaitExpressionFormalParameter</span><span class="s3">\n</span><span class="s1">- YieldInParameter</span><span class="s3">\n</span><span class="s1">- InvalidParenthesizedAssignment when parenthesized is an identifier</span><span class="s3">\n\n</span><span class="s1">There are four different expression scope</span><span class="s3">\n</span><span class="s1">- Expression</span><span class="s3">\n  </span><span class="s1">A general scope that represents program / function body / static block. No errors</span><span class="s3">\n  </span><span class="s1">will be recorded nor thrown in this scope.</span><span class="s3">\n\n</span><span class="s1">- MaybeArrowParameterDeclaration</span><span class="s3">\n  </span><span class="s1">A scope that represents ambiguous arrow head e.g. `(x)`. Errors will be recorded</span><span class="s3">\n  </span><span class="s1">alongside parent scopes and thrown when `ExpressionScopeHandler#validateAsPattern`</span><span class="s3">\n  </span><span class="s1">is called.</span><span class="s3">\n\n</span><span class="s1">- MaybeAsyncArrowParameterDeclaration</span><span class="s3">\n  </span><span class="s1">A scope that represents ambiguous async arrow head e.g. `async(x)`. Errors will</span><span class="s3">\n  </span><span class="s1">be recorded alongside parent scopes and thrown when</span><span class="s3">\n  </span><span class="s1">`ExpressionScopeHandler#validateAsPattern` is called.</span><span class="s3">\n\n</span><span class="s1">- ParameterDeclaration</span><span class="s3">\n  </span><span class="s1">A scope that represents unambiguous function parameters `function(x)`. Errors</span><span class="s3">\n  </span><span class="s1">recorded in this scope will be thrown immediately. No errors will be recorded in</span><span class="s3">\n  </span><span class="s1">this scope.</span><span class="s3">\n\n</span><span class="s1">// @see {@link https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M|V8 Expression Scope design docs}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">const kExpression = 0,</span><span class="s3">\n  </span><span class="s1">kMaybeArrowParameterDeclaration = 1,</span><span class="s3">\n  </span><span class="s1">kMaybeAsyncArrowParameterDeclaration = 2,</span><span class="s3">\n  </span><span class="s1">kParameterDeclaration = 3;</span><span class="s3">\n\n</span><span class="s1">type ExpressionScopeType = 0 | 1 | 2 | 3;</span><span class="s3">\n\n</span><span class="s1">class ExpressionScope {</span><span class="s3">\n  </span><span class="s1">type: ExpressionScopeType;</span><span class="s3">\n\n  </span><span class="s1">constructor(type: ExpressionScopeType = kExpression) {</span><span class="s3">\n    </span><span class="s1">this.type = type;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">canBeArrowParameterDeclaration(): this is ArrowHeadParsingScope {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">this.type === kMaybeAsyncArrowParameterDeclaration ||</span><span class="s3">\n      </span><span class="s1">this.type === kMaybeArrowParameterDeclaration</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">isCertainlyParameterDeclaration() {</span><span class="s3">\n    </span><span class="s1">return this.type === kParameterDeclaration;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ArrowHeadParsingParameterInitializerError =</span><span class="s3">\n  </span><span class="s1">| typeof Errors.AwaitExpressionFormalParameter</span><span class="s3">\n  </span><span class="s1">| typeof Errors.YieldInParameter;</span><span class="s3">\n</span><span class="s1">type ArrowHeadParsingDeclarationError =</span><span class="s3">\n  </span><span class="s1">| ArrowHeadParsingParameterInitializerError</span><span class="s3">\n  </span><span class="s1">| typeof Errors.InvalidParenthesizedAssignment</span><span class="s3">\n  </span><span class="s1">| typeof Errors.AwaitBindingIdentifier;</span><span class="s3">\n\n</span><span class="s1">class ArrowHeadParsingScope extends ExpressionScope {</span><span class="s3">\n  </span><span class="s1">declarationErrors: Map&lt;number, [ParseErrorConstructor&lt;{}&gt;, Position]&gt; =</span><span class="s3">\n    </span><span class="s1">new Map();</span><span class="s3">\n  </span><span class="s1">constructor(type: 1 | 2) {</span><span class="s3">\n    </span><span class="s1">super(type);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">recordDeclarationError(</span><span class="s3">\n    </span><span class="s1">ParsingErrorClass: ParseErrorConstructor&lt;{}&gt;,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">at,</span><span class="s3">\n    </span><span class="s1">}: {</span><span class="s3">\n      </span><span class="s1">at: Position;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const index = at.index;</span><span class="s3">\n\n    </span><span class="s1">this.declarationErrors.set(index, [ParsingErrorClass, at]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">clearDeclarationError(index: number) {</span><span class="s3">\n    </span><span class="s1">this.declarationErrors.delete(index);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">iterateErrors(</span><span class="s3">\n    </span><span class="s1">iterator: (a: [ArrowHeadParsingDeclarationError, Position]) =&gt; void,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.declarationErrors.forEach(iterator);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class ExpressionScopeHandler {</span><span class="s3">\n  </span><span class="s1">parser: Tokenizer;</span><span class="s3">\n  </span><span class="s1">stack: Array&lt;ExpressionScope&gt; = [new ExpressionScope()];</span><span class="s3">\n\n  </span><span class="s1">constructor(parser: Tokenizer) {</span><span class="s3">\n    </span><span class="s1">this.parser = parser;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">enter(scope: ExpressionScope) {</span><span class="s3">\n    </span><span class="s1">this.stack.push(scope);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">exit() {</span><span class="s3">\n    </span><span class="s1">this.stack.pop();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Record likely parameter initializer errors</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* When current scope is a ParameterDeclaration, the error will be thrown immediately,</span><span class="s3">\n   </span><span class="s1">* otherwise it will be recorded to any ancestry MaybeArrowParameterDeclaration and</span><span class="s3">\n   </span><span class="s1">* MaybeAsyncArrowParameterDeclaration scope until an Expression scope is seen.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">recordParameterInitializerError(</span><span class="s3">\n    </span><span class="s1">toParseError: ArrowHeadParsingParameterInitializerError,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">at: node,</span><span class="s3">\n    </span><span class="s1">}: {</span><span class="s3">\n      </span><span class="s1">at: Node;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const origin = { at: node.loc.start };</span><span class="s3">\n    </span><span class="s1">const { stack } = this;</span><span class="s3">\n    </span><span class="s1">let i = stack.length - 1;</span><span class="s3">\n    </span><span class="s1">let scope: ExpressionScope = stack[i];</span><span class="s3">\n    </span><span class="s1">while (!scope.isCertainlyParameterDeclaration()) {</span><span class="s3">\n      </span><span class="s1">if (scope.canBeArrowParameterDeclaration()) {</span><span class="s3">\n        </span><span class="s1">scope.recordDeclarationError(toParseError, origin);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">/*:: invariant(scope.type == kExpression) */</span><span class="s3">\n        </span><span class="s1">// Type-Expression is the boundary where initializer error can populate to</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">scope = stack[--i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.parser.raise(toParseError, origin);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Record errors that must be thrown if the current pattern ends up being an arrow</span><span class="s3">\n   </span><span class="s1">* function parameter. This is used to record parenthesized identifiers, and to record</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">a as T</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">&lt;T&gt; a</span><span class="s3">\&quot; </span><span class="s1">type assertions when parsing typescript.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* A parenthesized identifier (or type assertion) in LHS can be ambiguous because the assignment</span><span class="s3">\n   </span><span class="s1">* can be transformed to an assignable later, but not vice versa:</span><span class="s3">\n   </span><span class="s1">* For example, in `([(a) = []] = []) =&gt; {}`, we think `(a) = []` is an LHS in `[(a) = []]`,</span><span class="s3">\n   </span><span class="s1">* an LHS within `[(a) = []] = []`. However the LHS chain is then transformed by toAssignable,</span><span class="s3">\n   </span><span class="s1">* and we should throw assignment `(a)`, which is only valid in LHS. Hence we record the</span><span class="s3">\n   </span><span class="s1">* location of parenthesized `(a)` to current scope if it is one of MaybeArrowParameterDeclaration</span><span class="s3">\n   </span><span class="s1">* and MaybeAsyncArrowParameterDeclaration</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Unlike `recordParameterInitializerError`, we don't record to ancestry scope because we</span><span class="s3">\n   </span><span class="s1">* validate arrow head parsing scope before exit, and then the LHS will be unambiguous:</span><span class="s3">\n   </span><span class="s1">* For example, in `( x = ( [(a) = []] = [] ) ) =&gt; {}`, we should not record `(a)` in `( x = ... ) =&gt;`</span><span class="s3">\n   </span><span class="s1">* arrow scope because when we finish parsing `( [(a) = []] = [] )`, it is an unambiguous assignment</span><span class="s3">\n   </span><span class="s1">* expression and can not be cast to pattern</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">recordArrowParameterBindingError(</span><span class="s3">\n    </span><span class="s1">error: ParseErrorConstructor&lt;{}&gt;,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">at: node,</span><span class="s3">\n    </span><span class="s1">}: {</span><span class="s3">\n      </span><span class="s1">at: Node;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const { stack } = this;</span><span class="s3">\n    </span><span class="s1">const scope: ExpressionScope = stack[stack.length - 1];</span><span class="s3">\n    </span><span class="s1">const origin = { at: node.loc.start };</span><span class="s3">\n    </span><span class="s1">if (scope.isCertainlyParameterDeclaration()) {</span><span class="s3">\n      </span><span class="s1">this.parser.raise(error, origin);</span><span class="s3">\n    </span><span class="s1">} else if (scope.canBeArrowParameterDeclaration()) {</span><span class="s3">\n      </span><span class="s1">scope.recordDeclarationError(error, origin);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Record likely async arrow parameter errors</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Errors will be recorded to any ancestry MaybeAsyncArrowParameterDeclaration</span><span class="s3">\n   </span><span class="s1">* scope until an Expression scope is seen.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">recordAsyncArrowParametersError({ at }: { at: Position }): void {</span><span class="s3">\n    </span><span class="s1">const { stack } = this;</span><span class="s3">\n    </span><span class="s1">let i = stack.length - 1;</span><span class="s3">\n    </span><span class="s1">let scope: ExpressionScope = stack[i];</span><span class="s3">\n    </span><span class="s1">while (scope.canBeArrowParameterDeclaration()) {</span><span class="s3">\n      </span><span class="s1">if (scope.type === kMaybeAsyncArrowParameterDeclaration) {</span><span class="s3">\n        </span><span class="s1">scope.recordDeclarationError(Errors.AwaitBindingIdentifier, { at });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">scope = stack[--i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">validateAsPattern(): void {</span><span class="s3">\n    </span><span class="s1">const { stack } = this;</span><span class="s3">\n    </span><span class="s1">const currentScope = stack[stack.length - 1];</span><span class="s3">\n    </span><span class="s1">if (!currentScope.canBeArrowParameterDeclaration()) return;</span><span class="s3">\n    </span><span class="s1">currentScope.iterateErrors(([toParseError, loc]) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.parser.raise(toParseError, { at: loc });</span><span class="s3">\n      </span><span class="s1">// iterate from parent scope</span><span class="s3">\n      </span><span class="s1">let i = stack.length - 2;</span><span class="s3">\n      </span><span class="s1">let scope = stack[i];</span><span class="s3">\n      </span><span class="s1">while (scope.canBeArrowParameterDeclaration()) {</span><span class="s3">\n        </span><span class="s1">scope.clearDeclarationError(loc.index);</span><span class="s3">\n        </span><span class="s1">scope = stack[--i];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function newParameterDeclarationScope() {</span><span class="s3">\n  </span><span class="s1">return new ExpressionScope(kParameterDeclaration);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function newArrowHeadScope() {</span><span class="s3">\n  </span><span class="s1">return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function newAsyncArrowScope() {</span><span class="s3">\n  </span><span class="s1">return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function newExpressionScope() {</span><span class="s3">\n  </span><span class="s1">return new ExpressionScope();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>
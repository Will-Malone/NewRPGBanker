<html>
<head>
<title>backend.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
backend.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">webpackUniversalModuleDefinition(root, factory) {</span>
	<span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module === </span><span class="s2">'object'</span><span class="s0">)</span>
		<span class="s0">module.exports = factory();</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd)</span>
		<span class="s0">define([], factory);</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object'</span><span class="s0">)</span>
		<span class="s0">exports[</span><span class="s2">&quot;ReactDevToolsBackend&quot;</span><span class="s0">] = factory();</span>
	<span class="s1">else</span>
		<span class="s0">root[</span><span class="s2">&quot;ReactDevToolsBackend&quot;</span><span class="s0">] = factory();</span>
<span class="s0">})(self, () =&gt; {</span>
<span class="s1">return </span><span class="s3">/******/ </span><span class="s0">(() =&gt; { </span><span class="s3">// webpackBootstrap</span>
<span class="s3">/******/ 	</span><span class="s1">var </span><span class="s0">__webpack_modules__ = ({</span>

<span class="s3">/***/ </span><span class="s4">602</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>

<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">__webpack_unused_export__;</span>
<span class="s3">/** 
 * @license React 
 * react-debug-tools.production.min.js 
 * 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>


<span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s1">var </span><span class="s0">h = __webpack_require__(</span><span class="s4">206</span><span class="s0">),</span>
    <span class="s0">p = __webpack_require__(</span><span class="s4">189</span><span class="s0">),</span>
    <span class="s0">q = Object.assign,</span>
    <span class="s0">w = p.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,</span>
    <span class="s0">x = [],</span>
    <span class="s0">y = </span><span class="s1">null</span><span class="s0">;</span>

<span class="s1">function </span><span class="s0">z() {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">=== y) {</span>
    <span class="s1">var </span><span class="s0">a = </span><span class="s1">new </span><span class="s0">Map();</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s0">A.useContext({</span>
        <span class="s0">_currentValue: </span><span class="s1">null</span>
      <span class="s0">}), A.useState(</span><span class="s1">null</span><span class="s0">), A.useReducer(</span><span class="s1">function </span><span class="s0">(c) {</span>
        <span class="s1">return </span><span class="s0">c;</span>
      <span class="s0">}, </span><span class="s1">null</span><span class="s0">), A.useRef(</span><span class="s1">null</span><span class="s0">), </span><span class="s2">&quot;function&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">A.useCacheRefresh &amp;&amp; A.useCacheRefresh(), A.useLayoutEffect(</span><span class="s1">function </span><span class="s0">() {}), A.useInsertionEffect(</span><span class="s1">function </span><span class="s0">() {}), A.useEffect(</span><span class="s1">function </span><span class="s0">() {}), A.useImperativeHandle(</span><span class="s1">void </span><span class="s4">0</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">return null</span><span class="s0">;</span>
      <span class="s0">}), A.useDebugValue(</span><span class="s1">null</span><span class="s0">), A.useCallback(</span><span class="s1">function </span><span class="s0">() {}), A.useMemo(</span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">return null</span><span class="s0">;</span>
      <span class="s0">}), </span><span class="s2">&quot;function&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">A.useMemoCache &amp;&amp; A.useMemoCache(</span><span class="s4">0</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">b = x;</span>
      <span class="s0">x = [];</span>
    <span class="s0">}</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">e = </span><span class="s4">0</span><span class="s0">; e &lt; b.length; e++) {</span>
      <span class="s1">var </span><span class="s0">f = b[e];</span>
      <span class="s0">a.set(f.primitive, h.parse(f.stackError));</span>
    <span class="s0">}</span>

    <span class="s0">y = a;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">y;</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">B = </span><span class="s1">null</span><span class="s0">;</span>

<span class="s1">function </span><span class="s0">C() {</span>
  <span class="s1">var </span><span class="s0">a = B;</span>
  <span class="s1">null </span><span class="s0">!== a &amp;&amp; (B = a.next);</span>
  <span class="s1">return </span><span class="s0">a;</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">A = {</span>
  <span class="s0">use: </span><span class="s1">function </span><span class="s0">use() {</span>
    <span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;Support for `use` not yet implemented in react-debug-tools.&quot;</span><span class="s0">);</span>
  <span class="s0">},</span>
  <span class="s0">readContext: </span><span class="s1">function </span><span class="s0">readContext(a) {</span>
    <span class="s1">return </span><span class="s0">a._currentValue;</span>
  <span class="s0">},</span>
  <span class="s0">useCacheRefresh: </span><span class="s1">function </span><span class="s0">useCacheRefresh() {</span>
    <span class="s1">var </span><span class="s0">a = C();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;CacheRefresh&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: </span><span class="s1">null </span><span class="s0">!== a ? a.memoizedState : </span><span class="s1">function </span><span class="s0">() {}</span>
    <span class="s0">});</span>
    <span class="s1">return function </span><span class="s0">() {};</span>
  <span class="s0">},</span>
  <span class="s0">useCallback: </span><span class="s1">function </span><span class="s0">useCallback(a) {</span>
    <span class="s1">var </span><span class="s0">b = C();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;Callback&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: </span><span class="s1">null </span><span class="s0">!== b ? b.memoizedState[</span><span class="s4">0</span><span class="s0">] : a</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">a;</span>
  <span class="s0">},</span>
  <span class="s0">useContext: </span><span class="s1">function </span><span class="s0">useContext(a) {</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;Context&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a._currentValue</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">a._currentValue;</span>
  <span class="s0">},</span>
  <span class="s0">useEffect: </span><span class="s1">function </span><span class="s0">useEffect(a) {</span>
    <span class="s0">C();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;Effect&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a</span>
    <span class="s0">});</span>
  <span class="s0">},</span>
  <span class="s0">useImperativeHandle: </span><span class="s1">function </span><span class="s0">useImperativeHandle(a) {</span>
    <span class="s0">C();</span>
    <span class="s1">var </span><span class="s0">b = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">null </span><span class="s0">!== a &amp;&amp; </span><span class="s2">&quot;object&quot; </span><span class="s0">=== _typeof(a) &amp;&amp; (b = a.current);</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;ImperativeHandle&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: b</span>
    <span class="s0">});</span>
  <span class="s0">},</span>
  <span class="s0">useDebugValue: </span><span class="s1">function </span><span class="s0">useDebugValue(a, b) {</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;DebugValue&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: </span><span class="s2">&quot;function&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">b ? b(a) : a</span>
    <span class="s0">});</span>
  <span class="s0">},</span>
  <span class="s0">useLayoutEffect: </span><span class="s1">function </span><span class="s0">useLayoutEffect(a) {</span>
    <span class="s0">C();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;LayoutEffect&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a</span>
    <span class="s0">});</span>
  <span class="s0">},</span>
  <span class="s0">useInsertionEffect: </span><span class="s1">function </span><span class="s0">useInsertionEffect(a) {</span>
    <span class="s0">C();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;InsertionEffect&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a</span>
    <span class="s0">});</span>
  <span class="s0">},</span>
  <span class="s0">useMemo: </span><span class="s1">function </span><span class="s0">useMemo(a) {</span>
    <span class="s1">var </span><span class="s0">b = C();</span>
    <span class="s0">a = </span><span class="s1">null </span><span class="s0">!== b ? b.memoizedState[</span><span class="s4">0</span><span class="s0">] : a();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;Memo&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">a;</span>
  <span class="s0">},</span>
  <span class="s0">useMemoCache: </span><span class="s1">function </span><span class="s0">useMemoCache(a) {</span>
    <span class="s1">var </span><span class="s0">b = C();</span>
    <span class="s0">b = </span><span class="s1">null </span><span class="s0">!== b &amp;&amp; </span><span class="s1">null </span><span class="s0">!== b.updateQueue &amp;&amp; </span><span class="s1">null </span><span class="s0">!= b.updateQueue.memoCache ? b.updateQueue.memoCache : {</span>
      <span class="s0">data: [],</span>
      <span class="s0">index: </span><span class="s4">0</span>
    <span class="s0">};</span>
    <span class="s0">b = b.data[b.index];</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">void </span><span class="s4">0 </span><span class="s0">=== b) {</span>
      <span class="s1">var </span><span class="s0">e = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.memo_cache_sentinel&quot;</span><span class="s0">);</span>
      <span class="s0">b = Array(a);</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">f = </span><span class="s4">0</span><span class="s0">; f &lt; a; f++) {</span>
        <span class="s0">b[f] = e;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;MemoCache&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: b</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">b;</span>
  <span class="s0">},</span>
  <span class="s0">useReducer: </span><span class="s1">function </span><span class="s0">useReducer(a, b, e) {</span>
    <span class="s0">a = C();</span>
    <span class="s0">b = </span><span class="s1">null </span><span class="s0">!== a ? a.memoizedState : </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">!== e ? e(b) : b;</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;Reducer&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: b</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">[b, </span><span class="s1">function </span><span class="s0">() {}];</span>
  <span class="s0">},</span>
  <span class="s0">useRef: </span><span class="s1">function </span><span class="s0">useRef(a) {</span>
    <span class="s1">var </span><span class="s0">b = C();</span>
    <span class="s0">a = </span><span class="s1">null </span><span class="s0">!== b ? b.memoizedState : {</span>
      <span class="s0">current: a</span>
    <span class="s0">};</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;Ref&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a.current</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">a;</span>
  <span class="s0">},</span>
  <span class="s0">useState: </span><span class="s1">function </span><span class="s0">useState(a) {</span>
    <span class="s1">var </span><span class="s0">b = C();</span>
    <span class="s0">a = </span><span class="s1">null </span><span class="s0">!== b ? b.memoizedState : </span><span class="s2">&quot;function&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">a ? a() : a;</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;State&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">[a, </span><span class="s1">function </span><span class="s0">() {}];</span>
  <span class="s0">},</span>
  <span class="s0">useTransition: </span><span class="s1">function </span><span class="s0">useTransition() {</span>
    <span class="s0">C();</span>
    <span class="s0">C();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;Transition&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">[!</span><span class="s4">1</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {}];</span>
  <span class="s0">},</span>
  <span class="s0">useSyncExternalStore: </span><span class="s1">function </span><span class="s0">useSyncExternalStore(a, b) {</span>
    <span class="s0">C();</span>
    <span class="s0">C();</span>
    <span class="s0">a = b();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;SyncExternalStore&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">a;</span>
  <span class="s0">},</span>
  <span class="s0">useDeferredValue: </span><span class="s1">function </span><span class="s0">useDeferredValue(a) {</span>
    <span class="s1">var </span><span class="s0">b = C();</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;DeferredValue&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: </span><span class="s1">null </span><span class="s0">!== b ? b.memoizedState : a</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">a;</span>
  <span class="s0">},</span>
  <span class="s0">useId: </span><span class="s1">function </span><span class="s0">useId() {</span>
    <span class="s1">var </span><span class="s0">a = C();</span>
    <span class="s0">a = </span><span class="s1">null </span><span class="s0">!== a ? a.memoizedState : </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s0">x.push({</span>
      <span class="s0">primitive: </span><span class="s2">&quot;Id&quot;</span><span class="s0">,</span>
      <span class="s0">stackError: Error(),</span>
      <span class="s0">value: a</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">a;</span>
  <span class="s0">}</span>
<span class="s0">},</span>
    <span class="s0">D = {</span>
  <span class="s0">get: </span><span class="s1">function </span><span class="s0">get(a, b) {</span>
    <span class="s1">if </span><span class="s0">(a.hasOwnProperty(b)) </span><span class="s1">return </span><span class="s0">a[b];</span>
    <span class="s0">a = Error(</span><span class="s2">&quot;Missing method in Dispatcher: &quot; </span><span class="s0">+ b);</span>
    <span class="s0">a.name = </span><span class="s2">&quot;ReactDebugToolsUnsupportedHookError&quot;</span><span class="s0">;</span>
    <span class="s1">throw </span><span class="s0">a;</span>
  <span class="s0">}</span>
<span class="s0">},</span>
    <span class="s0">E = </span><span class="s2">&quot;undefined&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">Proxy ? A : </span><span class="s1">new </span><span class="s0">Proxy(A, D),</span>
    <span class="s0">F = </span><span class="s4">0</span><span class="s0">;</span>

<span class="s1">function </span><span class="s0">G(a, b, e) {</span>
  <span class="s1">var </span><span class="s0">f = b[e].source,</span>
      <span class="s0">c = </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s0">a: </span><span class="s1">for </span><span class="s0">(; c &lt; a.length; c++) {</span>
    <span class="s1">if </span><span class="s0">(a[c].source === f) {</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">k = e + </span><span class="s4">1</span><span class="s0">, r = c + </span><span class="s4">1</span><span class="s0">; k &lt; b.length &amp;&amp; r &lt; a.length; k++, r++) {</span>
        <span class="s1">if </span><span class="s0">(a[r].source !== b[k].source) </span><span class="s1">continue </span><span class="s0">a;</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">c;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">H(a, b) {</span>
  <span class="s1">if </span><span class="s0">(!a) </span><span class="s1">return </span><span class="s0">!</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">b = </span><span class="s2">&quot;use&quot; </span><span class="s0">+ b;</span>
  <span class="s1">return </span><span class="s0">a.length &lt; b.length ? !</span><span class="s4">1 </span><span class="s0">: a.lastIndexOf(b) === a.length - b.length;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">I(a, b, e) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">f = [], c = </span><span class="s1">null</span><span class="s0">, k = f, r = </span><span class="s4">0</span><span class="s0">, t = [], v = </span><span class="s4">0</span><span class="s0">; v &lt; b.length; v++) {</span>
    <span class="s1">var </span><span class="s0">u = b[v];</span>
    <span class="s1">var </span><span class="s0">d = a;</span>
    <span class="s1">var </span><span class="s0">l = h.parse(u.stackError);</span>

    <span class="s0">b: {</span>
      <span class="s1">var </span><span class="s0">m = l,</span>
          <span class="s0">n = G(m, d, F);</span>
      <span class="s1">if </span><span class="s0">(-</span><span class="s4">1 </span><span class="s0">!== n) d = n;</span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">g = </span><span class="s4">0</span><span class="s0">; g &lt; d.length &amp;&amp; </span><span class="s4">5 </span><span class="s0">&gt; g; g++) {</span>
          <span class="s1">if </span><span class="s0">(n = G(m, d, g), -</span><span class="s4">1 </span><span class="s0">!== n) {</span>
            <span class="s0">F = g;</span>
            <span class="s0">d = n;</span>
            <span class="s1">break </span><span class="s0">b;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s0">d = -</span><span class="s4">1</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">b: {</span>
      <span class="s0">m = l;</span>
      <span class="s0">n = z().get(u.primitive);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">void </span><span class="s4">0 </span><span class="s0">!== n) </span><span class="s1">for </span><span class="s0">(g = </span><span class="s4">0</span><span class="s0">; g &lt; n.length &amp;&amp; g &lt; m.length; g++) {</span>
        <span class="s1">if </span><span class="s0">(n[g].source !== m[g].source) {</span>
          <span class="s0">g &lt; m.length - </span><span class="s4">1 </span><span class="s0">&amp;&amp; H(m[g].functionName, u.primitive) &amp;&amp; g++;</span>
          <span class="s0">g &lt; m.length - </span><span class="s4">1 </span><span class="s0">&amp;&amp; H(m[g].functionName, u.primitive) &amp;&amp; g++;</span>
          <span class="s0">m = g;</span>
          <span class="s1">break </span><span class="s0">b;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
      <span class="s0">m = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">l = -</span><span class="s4">1 </span><span class="s0">=== d || -</span><span class="s4">1 </span><span class="s0">=== m || </span><span class="s4">2 </span><span class="s0">&gt; d - m ? </span><span class="s1">null </span><span class="s0">: l.slice(m, d - </span><span class="s4">1</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">!== l) {</span>
      <span class="s0">d = </span><span class="s4">0</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">!== c) {</span>
        <span class="s1">for </span><span class="s0">(; d &lt; l.length &amp;&amp; d &lt; c.length &amp;&amp; l[l.length - d - </span><span class="s4">1</span><span class="s0">].source === c[c.length - d - </span><span class="s4">1</span><span class="s0">].source;) {</span>
          <span class="s0">d++;</span>
        <span class="s0">}</span>

        <span class="s1">for </span><span class="s0">(c = c.length - </span><span class="s4">1</span><span class="s0">; c &gt; d; c--) {</span>
          <span class="s0">k = t.pop();</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">for </span><span class="s0">(c = l.length - d - </span><span class="s4">1</span><span class="s0">; </span><span class="s4">1 </span><span class="s0">&lt;= c; c--) {</span>
        <span class="s0">d = [], m = l[c], (n = l[c - </span><span class="s4">1</span><span class="s0">].functionName) ? (g = n.lastIndexOf(</span><span class="s2">&quot;.&quot;</span><span class="s0">), -</span><span class="s4">1 </span><span class="s0">=== g &amp;&amp; (g = </span><span class="s4">0</span><span class="s0">), </span><span class="s2">&quot;use&quot; </span><span class="s0">=== n.slice(g, g + </span><span class="s4">3</span><span class="s0">) &amp;&amp; (g += </span><span class="s4">3</span><span class="s0">), n = n.slice(g)) : n = </span><span class="s2">&quot;&quot;</span><span class="s0">, n = {</span>
          <span class="s0">id: </span><span class="s1">null</span><span class="s0">,</span>
          <span class="s0">isStateEditable: !</span><span class="s4">1</span><span class="s0">,</span>
          <span class="s0">name: n,</span>
          <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s0">subHooks: d</span>
        <span class="s0">}, e &amp;&amp; (n.hookSource = {</span>
          <span class="s0">lineNumber: m.lineNumber,</span>
          <span class="s0">columnNumber: m.columnNumber,</span>
          <span class="s0">functionName: m.functionName,</span>
          <span class="s0">fileName: m.fileName</span>
        <span class="s0">}), k.push(n), t.push(k), k = d;</span>
      <span class="s0">}</span>

      <span class="s0">c = l;</span>
    <span class="s0">}</span>

    <span class="s0">d = u.primitive;</span>
    <span class="s0">u = {</span>
      <span class="s0">id: </span><span class="s2">&quot;Context&quot; </span><span class="s0">=== d || </span><span class="s2">&quot;DebugValue&quot; </span><span class="s0">=== d ? </span><span class="s1">null </span><span class="s0">: r++,</span>
      <span class="s0">isStateEditable: </span><span class="s2">&quot;Reducer&quot; </span><span class="s0">=== d || </span><span class="s2">&quot;State&quot; </span><span class="s0">=== d,</span>
      <span class="s0">name: d,</span>
      <span class="s0">value: u.value,</span>
      <span class="s0">subHooks: []</span>
    <span class="s0">};</span>
    <span class="s0">e &amp;&amp; (d = {</span>
      <span class="s0">lineNumber: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">functionName: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">fileName: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">columnNumber: </span><span class="s1">null</span>
    <span class="s0">}, l &amp;&amp; </span><span class="s4">1 </span><span class="s0">&lt;= l.length &amp;&amp; (l = l[</span><span class="s4">0</span><span class="s0">], d.lineNumber = l.lineNumber, d.functionName = l.functionName, d.fileName = l.fileName, d.columnNumber = l.columnNumber), u.hookSource = d);</span>
    <span class="s0">k.push(u);</span>
  <span class="s0">}</span>

  <span class="s0">J(f, </span><span class="s1">null</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">f;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">J(a, b) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">e = [], f = </span><span class="s4">0</span><span class="s0">; f &lt; a.length; f++) {</span>
    <span class="s1">var </span><span class="s0">c = a[f];</span>
    <span class="s2">&quot;DebugValue&quot; </span><span class="s0">=== c.name &amp;&amp; </span><span class="s4">0 </span><span class="s0">=== c.subHooks.length ? (a.splice(f, </span><span class="s4">1</span><span class="s0">), f--, e.push(c)) : J(c.subHooks, c);</span>
  <span class="s0">}</span>

  <span class="s1">null </span><span class="s0">!== b &amp;&amp; (</span><span class="s4">1 </span><span class="s0">=== e.length ? b.value = e[</span><span class="s4">0</span><span class="s0">].value : </span><span class="s4">1 </span><span class="s0">&lt; e.length &amp;&amp; (b.value = e.map(</span><span class="s1">function </span><span class="s0">(k) {</span>
    <span class="s1">return </span><span class="s0">k.value;</span>
  <span class="s0">})));</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">K(a) {</span>
  <span class="s1">if </span><span class="s0">(a </span><span class="s1">instanceof </span><span class="s0">Error &amp;&amp; </span><span class="s2">&quot;ReactDebugToolsUnsupportedHookError&quot; </span><span class="s0">=== a.name) </span><span class="s1">throw </span><span class="s0">a;</span>
  <span class="s1">var </span><span class="s0">b = Error(</span><span class="s2">&quot;Error rendering inspected component&quot;</span><span class="s0">, {</span>
    <span class="s0">cause: a</span>
  <span class="s0">});</span>
  <span class="s0">b.name = </span><span class="s2">&quot;ReactDebugToolsRenderError&quot;</span><span class="s0">;</span>
  <span class="s0">b.cause = a;</span>
  <span class="s1">throw </span><span class="s0">b;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">L(a, b, e) {</span>
  <span class="s1">var </span><span class="s0">f = </span><span class="s4">3 </span><span class="s0">&lt; arguments.length &amp;&amp; </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">!== arguments[</span><span class="s4">3</span><span class="s0">] ? arguments[</span><span class="s4">3</span><span class="s0">] : !</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">null </span><span class="s0">== e &amp;&amp; (e = w.ReactCurrentDispatcher);</span>
  <span class="s1">var </span><span class="s0">c = e.current;</span>
  <span class="s0">e.current = E;</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">k = Error();</span>
    <span class="s0">a(b);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(t) {</span>
    <span class="s0">K(t);</span>
  <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">r = x;</span>
    <span class="s0">x = [];</span>
    <span class="s0">e.current = c;</span>
  <span class="s0">}</span>

  <span class="s0">c = h.parse(k);</span>
  <span class="s1">return </span><span class="s0">I(c, r, f);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">M(a) {</span>
  <span class="s0">a.forEach(</span><span class="s1">function </span><span class="s0">(b, e) {</span>
    <span class="s1">return </span><span class="s0">e._currentValue = b;</span>
  <span class="s0">});</span>
<span class="s0">}</span>

<span class="s0">__webpack_unused_export__ = L;</span>

<span class="s0">exports.inspectHooksOfFiber = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">var </span><span class="s0">e = </span><span class="s4">2 </span><span class="s0">&lt; arguments.length &amp;&amp; </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">!== arguments[</span><span class="s4">2</span><span class="s0">] ? arguments[</span><span class="s4">2</span><span class="s0">] : !</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">null </span><span class="s0">== b &amp;&amp; (b = w.ReactCurrentDispatcher);</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s4">0 </span><span class="s0">!== a.tag &amp;&amp; </span><span class="s4">15 </span><span class="s0">!== a.tag &amp;&amp; </span><span class="s4">11 </span><span class="s0">!== a.tag) </span><span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;Unknown Fiber. Needs to be a function component to inspect hooks.&quot;</span><span class="s0">);</span>
  <span class="s0">z();</span>
  <span class="s1">var </span><span class="s0">f = a.type,</span>
      <span class="s0">c = a.memoizedProps;</span>

  <span class="s1">if </span><span class="s0">(f !== a.elementType &amp;&amp; f &amp;&amp; f.defaultProps) {</span>
    <span class="s0">c = q({}, c);</span>
    <span class="s1">var </span><span class="s0">k = f.defaultProps;</span>

    <span class="s1">for </span><span class="s0">(r </span><span class="s1">in </span><span class="s0">k) {</span>
      <span class="s1">void </span><span class="s4">0 </span><span class="s0">=== c[r] &amp;&amp; (c[r] = k[r]);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">B = a.memoizedState;</span>
  <span class="s1">var </span><span class="s0">r = </span><span class="s1">new </span><span class="s0">Map();</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">for </span><span class="s0">(k = a; k;) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s4">10 </span><span class="s0">=== k.tag) {</span>
        <span class="s1">var </span><span class="s0">t = k.type._context;</span>
        <span class="s0">r.has(t) || (r.set(t, t._currentValue), t._currentValue = k.memoizedProps.value);</span>
      <span class="s0">}</span>

      <span class="s0">k = k.</span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s4">11 </span><span class="s0">=== a.tag) {</span>
      <span class="s1">var </span><span class="s0">v = f.render;</span>
      <span class="s0">f = c;</span>
      <span class="s1">var </span><span class="s0">u = a.ref;</span>
      <span class="s0">t = b;</span>
      <span class="s1">var </span><span class="s0">d = t.current;</span>
      <span class="s0">t.current = E;</span>

      <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">l = Error();</span>
        <span class="s0">v(f, u);</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(g) {</span>
        <span class="s0">K(g);</span>
      <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">m = x;</span>
        <span class="s0">x = [];</span>
        <span class="s0">t.current = d;</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">n = h.parse(l);</span>
      <span class="s1">return </span><span class="s0">I(n, m, e);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">L(f, c, b, e);</span>
  <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
    <span class="s0">B = </span><span class="s1">null</span><span class="s0">, M(r);</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">987</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span>

<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>


<span class="s1">if </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
  <span class="s0">module.exports = __webpack_require__(</span><span class="s4">602</span><span class="s0">);</span>
<span class="s0">} </span><span class="s1">else </span><span class="s0">{}</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">9</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((__unused_webpack_module, exports) =&gt; {</span>

<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">__webpack_unused_export__;</span>
<span class="s3">/** 
 * @license React 
 * react-is.production.min.js 
 * 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>


<span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s1">var </span><span class="s0">b = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.element&quot;</span><span class="s0">),</span>
    <span class="s0">c = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.portal&quot;</span><span class="s0">),</span>
    <span class="s0">d = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.fragment&quot;</span><span class="s0">),</span>
    <span class="s0">e = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.strict_mode&quot;</span><span class="s0">),</span>
    <span class="s0">f = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.profiler&quot;</span><span class="s0">),</span>
    <span class="s0">g = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.provider&quot;</span><span class="s0">),</span>
    <span class="s0">h = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.context&quot;</span><span class="s0">),</span>
    <span class="s0">k = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.server_context&quot;</span><span class="s0">),</span>
    <span class="s0">l = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.forward_ref&quot;</span><span class="s0">),</span>
    <span class="s0">m = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.suspense&quot;</span><span class="s0">),</span>
    <span class="s0">n = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.suspense_list&quot;</span><span class="s0">),</span>
    <span class="s0">p = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.memo&quot;</span><span class="s0">),</span>
    <span class="s0">q = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.lazy&quot;</span><span class="s0">),</span>
    <span class="s0">t = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.offscreen&quot;</span><span class="s0">),</span>
    <span class="s0">u = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.cache&quot;</span><span class="s0">),</span>
    <span class="s0">v = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.client.reference&quot;</span><span class="s0">);</span>

<span class="s1">function </span><span class="s0">w(a) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;object&quot; </span><span class="s0">=== _typeof(a) &amp;&amp; </span><span class="s1">null </span><span class="s0">!== a) {</span>
    <span class="s1">var </span><span class="s0">r = a.$$typeof;</span>

    <span class="s1">switch </span><span class="s0">(r) {</span>
      <span class="s1">case </span><span class="s0">b:</span>
        <span class="s1">switch </span><span class="s0">(a = a.type, a) {</span>
          <span class="s1">case </span><span class="s0">d:</span>
          <span class="s1">case </span><span class="s0">f:</span>
          <span class="s1">case </span><span class="s0">e:</span>
          <span class="s1">case </span><span class="s0">m:</span>
          <span class="s1">case </span><span class="s0">n:</span>
            <span class="s1">return </span><span class="s0">a;</span>

          <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">switch </span><span class="s0">(a = a &amp;&amp; a.$$typeof, a) {</span>
              <span class="s1">case </span><span class="s0">k:</span>
              <span class="s1">case </span><span class="s0">h:</span>
              <span class="s1">case </span><span class="s0">l:</span>
              <span class="s1">case </span><span class="s0">q:</span>
              <span class="s1">case </span><span class="s0">p:</span>
              <span class="s1">case </span><span class="s0">g:</span>
                <span class="s1">return </span><span class="s0">a;</span>

              <span class="s1">default</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">r;</span>
            <span class="s0">}</span>

        <span class="s0">}</span>

      <span class="s1">case </span><span class="s0">c:</span>
        <span class="s1">return </span><span class="s0">r;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">exports.ContextConsumer = h;</span>
<span class="s0">exports.ContextProvider = g;</span>
<span class="s0">__webpack_unused_export__ = b;</span>
<span class="s0">exports.ForwardRef = l;</span>
<span class="s0">exports.Fragment = d;</span>
<span class="s0">exports.Lazy = q;</span>
<span class="s0">exports.Memo = p;</span>
<span class="s0">exports.Portal = c;</span>
<span class="s0">exports.Profiler = f;</span>
<span class="s0">exports.StrictMode = e;</span>
<span class="s0">exports.Suspense = m;</span>
<span class="s0">__webpack_unused_export__ = n;</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">!</span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">!</span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === h;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === g;</span>
<span class="s0">};</span>

<span class="s0">exports.isElement = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s2">&quot;object&quot; </span><span class="s0">=== _typeof(a) &amp;&amp; </span><span class="s1">null </span><span class="s0">!== a &amp;&amp; a.$$typeof === b;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === l;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === d;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === q;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === p;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === c;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === f;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === e;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === m;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">w(a) === n;</span>
<span class="s0">};</span>

<span class="s0">__webpack_unused_export__ = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s2">&quot;string&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">a || </span><span class="s2">&quot;function&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">a || a === d || a === f || a === e || a === m || a === n || a === t || a === u || </span><span class="s2">&quot;object&quot; </span><span class="s0">=== _typeof(a) &amp;&amp; </span><span class="s1">null </span><span class="s0">!== a &amp;&amp; (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === v || </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">!== a.getModuleId) ? !</span><span class="s4">0 </span><span class="s0">: !</span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">exports.typeOf = w;</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">550</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span>

<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>


<span class="s1">if </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
  <span class="s0">module.exports = __webpack_require__(</span><span class="s4">9</span><span class="s0">);</span>
<span class="s0">} </span><span class="s1">else </span><span class="s0">{}</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">978</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((__unused_webpack_module, exports) =&gt; {</span>

<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s3">/** 
 * @license React 
 * react.production.min.js 
 * 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>


<span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s1">var </span><span class="s0">l = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.element&quot;</span><span class="s0">),</span>
    <span class="s0">n = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.portal&quot;</span><span class="s0">),</span>
    <span class="s0">p = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.fragment&quot;</span><span class="s0">),</span>
    <span class="s0">q = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.strict_mode&quot;</span><span class="s0">),</span>
    <span class="s0">r = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.profiler&quot;</span><span class="s0">),</span>
    <span class="s0">t = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.provider&quot;</span><span class="s0">),</span>
    <span class="s0">u = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.context&quot;</span><span class="s0">),</span>
    <span class="s0">v = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.server_context&quot;</span><span class="s0">),</span>
    <span class="s0">w = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.forward_ref&quot;</span><span class="s0">),</span>
    <span class="s0">x = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.suspense&quot;</span><span class="s0">),</span>
    <span class="s0">y = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.suspense_list&quot;</span><span class="s0">),</span>
    <span class="s0">z = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.memo&quot;</span><span class="s0">),</span>
    <span class="s0">A = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.lazy&quot;</span><span class="s0">),</span>
    <span class="s0">aa = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.debug_trace_mode&quot;</span><span class="s0">),</span>
    <span class="s0">ba = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.offscreen&quot;</span><span class="s0">),</span>
    <span class="s0">ca = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.cache&quot;</span><span class="s0">),</span>
    <span class="s0">B = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;react.default_value&quot;</span><span class="s0">),</span>
    <span class="s0">C = Symbol.iterator;</span>

<span class="s1">function </span><span class="s0">da(a) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">=== a || </span><span class="s2">&quot;object&quot; </span><span class="s0">!== _typeof(a)) </span><span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">a = C &amp;&amp; a[C] || a[</span><span class="s2">&quot;@@iterator&quot;</span><span class="s0">];</span>
  <span class="s1">return </span><span class="s2">&quot;function&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">a ? a : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">D = {</span>
  <span class="s0">isMounted: </span><span class="s1">function </span><span class="s0">isMounted() {</span>
    <span class="s1">return </span><span class="s0">!</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">},</span>
  <span class="s0">enqueueForceUpdate: </span><span class="s1">function </span><span class="s0">enqueueForceUpdate() {},</span>
  <span class="s0">enqueueReplaceState: </span><span class="s1">function </span><span class="s0">enqueueReplaceState() {},</span>
  <span class="s0">enqueueSetState: </span><span class="s1">function </span><span class="s0">enqueueSetState() {}</span>
<span class="s0">},</span>
    <span class="s0">E = Object.assign,</span>
    <span class="s0">F = {};</span>

<span class="s1">function </span><span class="s0">G(a, b, c) {</span>
  <span class="s1">this</span><span class="s0">.props = a;</span>
  <span class="s1">this</span><span class="s0">.context = b;</span>
  <span class="s1">this</span><span class="s0">.refs = F;</span>
  <span class="s1">this</span><span class="s0">.updater = c || D;</span>
<span class="s0">}</span>

<span class="s0">G.prototype.isReactComponent = {};</span>

<span class="s0">G.prototype.setState = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;object&quot; </span><span class="s0">!== _typeof(a) &amp;&amp; </span><span class="s2">&quot;function&quot; </span><span class="s0">!== </span><span class="s1">typeof </span><span class="s0">a &amp;&amp; </span><span class="s1">null </span><span class="s0">!= a) </span><span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;setState(...): takes an object of state variables to update or a function which returns an object of state variables.&quot;</span><span class="s0">);</span>
  <span class="s1">this</span><span class="s0">.updater.enqueueSetState(</span><span class="s1">this</span><span class="s0">, a, b, </span><span class="s2">&quot;setState&quot;</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">G.prototype.forceUpdate = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">this</span><span class="s0">.updater.enqueueForceUpdate(</span><span class="s1">this</span><span class="s0">, a, </span><span class="s2">&quot;forceUpdate&quot;</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s1">function </span><span class="s0">H() {}</span>

<span class="s0">H.prototype = G.prototype;</span>

<span class="s1">function </span><span class="s0">I(a, b, c) {</span>
  <span class="s1">this</span><span class="s0">.props = a;</span>
  <span class="s1">this</span><span class="s0">.context = b;</span>
  <span class="s1">this</span><span class="s0">.refs = F;</span>
  <span class="s1">this</span><span class="s0">.updater = c || D;</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">J = I.prototype = </span><span class="s1">new </span><span class="s0">H();</span>
<span class="s0">J.constructor = I;</span>
<span class="s0">E(J, G.prototype);</span>
<span class="s0">J.isPureReactComponent = !</span><span class="s4">0</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">K = Array.isArray,</span>
    <span class="s0">L = Object.prototype.hasOwnProperty,</span>
    <span class="s0">M = {</span>
  <span class="s0">current: </span><span class="s1">null</span>
<span class="s0">},</span>
    <span class="s0">N = {</span>
  <span class="s0">key: !</span><span class="s4">0</span><span class="s0">,</span>
  <span class="s0">ref: !</span><span class="s4">0</span><span class="s0">,</span>
  <span class="s0">__self: !</span><span class="s4">0</span><span class="s0">,</span>
  <span class="s0">__source: !</span><span class="s4">0</span>
<span class="s0">};</span>

<span class="s1">function </span><span class="s0">O(a, b, c) {</span>
  <span class="s1">var </span><span class="s0">d,</span>
      <span class="s0">e = {},</span>
      <span class="s0">f = </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">g = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">!= b) </span><span class="s1">for </span><span class="s0">(d </span><span class="s1">in void </span><span class="s4">0 </span><span class="s0">!== b.ref &amp;&amp; (g = b.ref), </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">!== b.key &amp;&amp; (f = </span><span class="s2">&quot;&quot; </span><span class="s0">+ b.key), b) {</span>
    <span class="s0">L.call(b, d) &amp;&amp; !N.hasOwnProperty(d) &amp;&amp; (e[d] = b[d]);</span>
  <span class="s0">}</span>
  <span class="s1">var </span><span class="s0">h = arguments.length - </span><span class="s4">2</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s4">1 </span><span class="s0">=== h) e.children = c;</span><span class="s1">else if </span><span class="s0">(</span><span class="s4">1 </span><span class="s0">&lt; h) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">k = Array(h), m = </span><span class="s4">0</span><span class="s0">; m &lt; h; m++) {</span>
      <span class="s0">k[m] = arguments[m + </span><span class="s4">2</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s0">e.children = k;</span>
  <span class="s0">}</span>
  <span class="s1">if </span><span class="s0">(a &amp;&amp; a.defaultProps) </span><span class="s1">for </span><span class="s0">(d </span><span class="s1">in </span><span class="s0">h = a.defaultProps, h) {</span>
    <span class="s1">void </span><span class="s4">0 </span><span class="s0">=== e[d] &amp;&amp; (e[d] = h[d]);</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">$$typeof: l,</span>
    <span class="s0">type: a,</span>
    <span class="s0">key: f,</span>
    <span class="s0">ref: g,</span>
    <span class="s0">props: e,</span>
    <span class="s0">_owner: M.current</span>
  <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">ea(a, b) {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">$$typeof: l,</span>
    <span class="s0">type: a.type,</span>
    <span class="s0">key: b,</span>
    <span class="s0">ref: a.ref,</span>
    <span class="s0">props: a.props,</span>
    <span class="s0">_owner: a._owner</span>
  <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">P(a) {</span>
  <span class="s1">return </span><span class="s2">&quot;object&quot; </span><span class="s0">=== _typeof(a) &amp;&amp; </span><span class="s1">null </span><span class="s0">!== a &amp;&amp; a.$$typeof === l;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">escape(a) {</span>
  <span class="s1">var </span><span class="s0">b = {</span>
    <span class="s2">&quot;=&quot;</span><span class="s0">: </span><span class="s2">&quot;=0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;:&quot;</span><span class="s0">: </span><span class="s2">&quot;=2&quot;</span>
  <span class="s0">};</span>
  <span class="s1">return </span><span class="s2">&quot;$&quot; </span><span class="s0">+ a.replace(/[=:]/g, </span><span class="s1">function </span><span class="s0">(c) {</span>
    <span class="s1">return </span><span class="s0">b[c];</span>
  <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">Q = /\/+/g;</span>

<span class="s1">function </span><span class="s0">R(a, b) {</span>
  <span class="s1">return </span><span class="s2">&quot;object&quot; </span><span class="s0">=== _typeof(a) &amp;&amp; </span><span class="s1">null </span><span class="s0">!== a &amp;&amp; </span><span class="s1">null </span><span class="s0">!= a.key ? escape(</span><span class="s2">&quot;&quot; </span><span class="s0">+ a.key) : b.toString(</span><span class="s4">36</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">S(a, b, c, d, e) {</span>
  <span class="s1">var </span><span class="s0">f = _typeof(a);</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;undefined&quot; </span><span class="s0">=== f || </span><span class="s2">&quot;boolean&quot; </span><span class="s0">=== f) a = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">g = !</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">=== a) g = !</span><span class="s4">0</span><span class="s0">;</span><span class="s1">else switch </span><span class="s0">(f) {</span>
    <span class="s1">case </span><span class="s2">&quot;string&quot;</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">&quot;number&quot;</span><span class="s0">:</span>
      <span class="s0">g = !</span><span class="s4">0</span><span class="s0">;</span>
      <span class="s1">break</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">&quot;object&quot;</span><span class="s0">:</span>
      <span class="s1">switch </span><span class="s0">(a.$$typeof) {</span>
        <span class="s1">case </span><span class="s0">l:</span>
        <span class="s1">case </span><span class="s0">n:</span>
          <span class="s0">g = !</span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">}</span>

  <span class="s0">}</span>
  <span class="s1">if </span><span class="s0">(g) </span><span class="s1">return </span><span class="s0">g = a, e = e(g), a = </span><span class="s2">&quot;&quot; </span><span class="s0">=== d ? </span><span class="s2">&quot;.&quot; </span><span class="s0">+ R(g, </span><span class="s4">0</span><span class="s0">) : d, K(e) ? (c = </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">null </span><span class="s0">!= a &amp;&amp; (c = a.replace(Q, </span><span class="s2">&quot;$&amp;/&quot;</span><span class="s0">) + </span><span class="s2">&quot;/&quot;</span><span class="s0">), S(e, b, c, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(m) {</span>
    <span class="s1">return </span><span class="s0">m;</span>
  <span class="s0">})) : </span><span class="s1">null </span><span class="s0">!= e &amp;&amp; (P(e) &amp;&amp; (e = ea(e, c + (!e.key || g &amp;&amp; g.key === e.key ? </span><span class="s2">&quot;&quot; </span><span class="s0">: (</span><span class="s2">&quot;&quot; </span><span class="s0">+ e.key).replace(Q, </span><span class="s2">&quot;$&amp;/&quot;</span><span class="s0">) + </span><span class="s2">&quot;/&quot;</span><span class="s0">) + a)), b.push(e)), </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">g = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">d = </span><span class="s2">&quot;&quot; </span><span class="s0">=== d ? </span><span class="s2">&quot;.&quot; </span><span class="s0">: d + </span><span class="s2">&quot;:&quot;</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(K(a)) </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">h = </span><span class="s4">0</span><span class="s0">; h &lt; a.length; h++) {</span>
    <span class="s0">f = a[h];</span>
    <span class="s1">var </span><span class="s0">k = d + R(f, h);</span>
    <span class="s0">g += S(f, b, c, k, e);</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(k = da(a), </span><span class="s2">&quot;function&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">k) </span><span class="s1">for </span><span class="s0">(a = k.call(a), h = </span><span class="s4">0</span><span class="s0">; !(f = a.next()).done;) {</span>
    <span class="s0">f = f.value, k = d + R(f, h++), g += S(f, b, c, k, e);</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">&quot;object&quot; </span><span class="s0">=== f) </span><span class="s1">throw </span><span class="s0">b = String(a), Error(</span><span class="s2">&quot;Objects are not valid as a React child (found: &quot; </span><span class="s0">+ (</span><span class="s2">&quot;[object Object]&quot; </span><span class="s0">=== b ? </span><span class="s2">&quot;object with keys {&quot; </span><span class="s0">+ Object.keys(a).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">) + </span><span class="s2">&quot;}&quot; </span><span class="s0">: b) + </span><span class="s2">&quot;). If you meant to render a collection of children, use an array instead.&quot;</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">g;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">T(a, b, c) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">== a) </span><span class="s1">return </span><span class="s0">a;</span>
  <span class="s1">var </span><span class="s0">d = [],</span>
      <span class="s0">e = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">S(a, d, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(f) {</span>
    <span class="s1">return </span><span class="s0">b.call(c, f, e++);</span>
  <span class="s0">});</span>
  <span class="s1">return </span><span class="s0">d;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">fa(a) {</span>
  <span class="s1">if </span><span class="s0">(-</span><span class="s4">1 </span><span class="s0">=== a._status) {</span>
    <span class="s1">var </span><span class="s0">b = a._result;</span>
    <span class="s0">b = b();</span>
    <span class="s0">b.then(</span><span class="s1">function </span><span class="s0">(c) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s4">0 </span><span class="s0">=== a._status || -</span><span class="s4">1 </span><span class="s0">=== a._status) a._status = </span><span class="s4">1</span><span class="s0">, a._result = c;</span>
    <span class="s0">}, </span><span class="s1">function </span><span class="s0">(c) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s4">0 </span><span class="s0">=== a._status || -</span><span class="s4">1 </span><span class="s0">=== a._status) a._status = </span><span class="s4">2</span><span class="s0">, a._result = c;</span>
    <span class="s0">});</span>
    <span class="s0">-</span><span class="s4">1 </span><span class="s0">=== a._status &amp;&amp; (a._status = </span><span class="s4">0</span><span class="s0">, a._result = b);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s4">1 </span><span class="s0">=== a._status) </span><span class="s1">return </span><span class="s0">a._result.</span><span class="s1">default</span><span class="s0">;</span>
  <span class="s1">throw </span><span class="s0">a._result;</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">U = {</span>
  <span class="s0">current: </span><span class="s1">null</span>
<span class="s0">};</span>

<span class="s1">function </span><span class="s0">ha() {</span>
  <span class="s1">return new </span><span class="s0">WeakMap();</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">V() {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">s: </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">v: </span><span class="s1">void </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">o: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">p: </span><span class="s1">null</span>
  <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">W = {</span>
  <span class="s0">current: </span><span class="s1">null</span>
<span class="s0">},</span>
    <span class="s0">X = {</span>
  <span class="s0">transition: </span><span class="s1">null</span>
<span class="s0">},</span>
    <span class="s0">Y = {</span>
  <span class="s0">ReactCurrentDispatcher: W,</span>
  <span class="s0">ReactCurrentCache: U,</span>
  <span class="s0">ReactCurrentBatchConfig: X,</span>
  <span class="s0">ReactCurrentOwner: M,</span>
  <span class="s0">ContextRegistry: {}</span>
<span class="s0">},</span>
    <span class="s0">Z = Y.ContextRegistry;</span>
<span class="s0">exports.Children = {</span>
  <span class="s0">map: T,</span>
  <span class="s0">forEach: </span><span class="s1">function </span><span class="s0">forEach(a, b, c) {</span>
    <span class="s0">T(a, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s0">b.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
    <span class="s0">}, c);</span>
  <span class="s0">},</span>
  <span class="s0">count: </span><span class="s1">function </span><span class="s0">count(a) {</span>
    <span class="s1">var </span><span class="s0">b = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">T(a, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s0">b++;</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">b;</span>
  <span class="s0">},</span>
  <span class="s0">toArray: </span><span class="s1">function </span><span class="s0">toArray(a) {</span>
    <span class="s1">return </span><span class="s0">T(a, </span><span class="s1">function </span><span class="s0">(b) {</span>
      <span class="s1">return </span><span class="s0">b;</span>
    <span class="s0">}) || [];</span>
  <span class="s0">},</span>
  <span class="s0">only: </span><span class="s1">function </span><span class="s0">only(a) {</span>
    <span class="s1">if </span><span class="s0">(!P(a)) </span><span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;React.Children.only expected to receive a single React element child.&quot;</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s0">a;</span>
  <span class="s0">}</span>
<span class="s0">};</span>
<span class="s0">exports.Component = G;</span>
<span class="s0">exports.Fragment = p;</span>
<span class="s0">exports.Profiler = r;</span>
<span class="s0">exports.PureComponent = I;</span>
<span class="s0">exports.StrictMode = q;</span>
<span class="s0">exports.Suspense = x;</span>
<span class="s0">exports.SuspenseList = y;</span>
<span class="s0">exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y;</span>

<span class="s0">exports.cache = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s0">b = U.current;</span>
    <span class="s1">if </span><span class="s0">(!b) </span><span class="s1">return </span><span class="s0">a.apply(</span><span class="s1">null</span><span class="s0">, arguments);</span>
    <span class="s1">var </span><span class="s0">c = b.getCacheForType(ha);</span>
    <span class="s0">b = c.get(a);</span>
    <span class="s1">void </span><span class="s4">0 </span><span class="s0">=== b &amp;&amp; (b = V(), c.set(a, b));</span>
    <span class="s0">c = </span><span class="s4">0</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">d = arguments.length; c &lt; d; c++) {</span>
      <span class="s1">var </span><span class="s0">e = arguments[c];</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;function&quot; </span><span class="s0">=== </span><span class="s1">typeof </span><span class="s0">e || </span><span class="s2">&quot;object&quot; </span><span class="s0">=== _typeof(e) &amp;&amp; </span><span class="s1">null </span><span class="s0">!== e) {</span>
        <span class="s1">var </span><span class="s0">f = b.o;</span>
        <span class="s1">null </span><span class="s0">=== f &amp;&amp; (b.o = f = </span><span class="s1">new </span><span class="s0">WeakMap());</span>
        <span class="s0">b = f.get(e);</span>
        <span class="s1">void </span><span class="s4">0 </span><span class="s0">=== b &amp;&amp; (b = V(), f.set(e, b));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">f = b.p, </span><span class="s1">null </span><span class="s0">=== f &amp;&amp; (b.p = f = </span><span class="s1">new </span><span class="s0">Map()), b = f.get(e), </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">=== b &amp;&amp; (b = V(), f.set(e, b));</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s4">1 </span><span class="s0">=== b.s) </span><span class="s1">return </span><span class="s0">b.v;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s4">2 </span><span class="s0">=== b.s) </span><span class="s1">throw </span><span class="s0">b.v;</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">g = a.apply(</span><span class="s1">null</span><span class="s0">, arguments);</span>
      <span class="s0">c = b;</span>
      <span class="s0">c.s = </span><span class="s4">1</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s0">c.v = g;</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(h) {</span>
      <span class="s1">throw </span><span class="s0">g = b, g.s = </span><span class="s4">2</span><span class="s0">, g.v = h, h;</span>
    <span class="s0">}</span>
  <span class="s0">};</span>
<span class="s0">};</span>

<span class="s0">exports.cloneElement = </span><span class="s1">function </span><span class="s0">(a, b, c) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">=== a || </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">=== a) </span><span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;React.cloneElement(...): The argument must be a React element, but you passed &quot; </span><span class="s0">+ a + </span><span class="s2">&quot;.&quot;</span><span class="s0">);</span>
  <span class="s1">var </span><span class="s0">d = E({}, a.props),</span>
      <span class="s0">e = a.key,</span>
      <span class="s0">f = a.ref,</span>
      <span class="s0">g = a._owner;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">null </span><span class="s0">!= b) {</span>
    <span class="s1">void </span><span class="s4">0 </span><span class="s0">!== b.ref &amp;&amp; (f = b.ref, g = M.current);</span>
    <span class="s1">void </span><span class="s4">0 </span><span class="s0">!== b.key &amp;&amp; (e = </span><span class="s2">&quot;&quot; </span><span class="s0">+ b.key);</span>
    <span class="s1">if </span><span class="s0">(a.type &amp;&amp; a.type.defaultProps) </span><span class="s1">var </span><span class="s0">h = a.type.defaultProps;</span>

    <span class="s1">for </span><span class="s0">(k </span><span class="s1">in </span><span class="s0">b) {</span>
      <span class="s0">L.call(b, k) &amp;&amp; !N.hasOwnProperty(k) &amp;&amp; (d[k] = </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">=== b[k] &amp;&amp; </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">!== h ? h[k] : b[k]);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">k = arguments.length - </span><span class="s4">2</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s4">1 </span><span class="s0">=== k) d.children = c;</span><span class="s1">else if </span><span class="s0">(</span><span class="s4">1 </span><span class="s0">&lt; k) {</span>
    <span class="s0">h = Array(k);</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">m = </span><span class="s4">0</span><span class="s0">; m &lt; k; m++) {</span>
      <span class="s0">h[m] = arguments[m + </span><span class="s4">2</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s0">d.children = h;</span>
  <span class="s0">}</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">$$typeof: l,</span>
    <span class="s0">type: a.type,</span>
    <span class="s0">key: e,</span>
    <span class="s0">ref: f,</span>
    <span class="s0">props: d,</span>
    <span class="s0">_owner: g</span>
  <span class="s0">};</span>
<span class="s0">};</span>

<span class="s0">exports.createContext = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s0">a = {</span>
    <span class="s0">$$typeof: u,</span>
    <span class="s0">_currentValue: a,</span>
    <span class="s0">_currentValue2: a,</span>
    <span class="s0">_threadCount: </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">Provider: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">Consumer: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">_defaultValue: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">_globalName: </span><span class="s1">null</span>
  <span class="s0">};</span>
  <span class="s0">a.Provider = {</span>
    <span class="s0">$$typeof: t,</span>
    <span class="s0">_context: a</span>
  <span class="s0">};</span>
  <span class="s1">return </span><span class="s0">a.Consumer = a;</span>
<span class="s0">};</span>

<span class="s0">exports.createElement = O;</span>

<span class="s0">exports.createFactory = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">var </span><span class="s0">b = O.bind(</span><span class="s1">null</span><span class="s0">, a);</span>
  <span class="s0">b.type = a;</span>
  <span class="s1">return </span><span class="s0">b;</span>
<span class="s0">};</span>

<span class="s0">exports.createRef = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">current: </span><span class="s1">null</span>
  <span class="s0">};</span>
<span class="s0">};</span>

<span class="s0">exports.createServerContext = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">var </span><span class="s0">c = !</span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(!Z[a]) {</span>
    <span class="s0">c = !</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">d = {</span>
      <span class="s0">$$typeof: v,</span>
      <span class="s0">_currentValue: b,</span>
      <span class="s0">_currentValue2: b,</span>
      <span class="s0">_defaultValue: b,</span>
      <span class="s0">_threadCount: </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">Provider: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">Consumer: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">_globalName: a</span>
    <span class="s0">};</span>
    <span class="s0">d.Provider = {</span>
      <span class="s0">$$typeof: t,</span>
      <span class="s0">_context: d</span>
    <span class="s0">};</span>
    <span class="s0">Z[a] = d;</span>
  <span class="s0">}</span>

  <span class="s0">d = Z[a];</span>
  <span class="s1">if </span><span class="s0">(d._defaultValue === B) d._defaultValue = b, d._currentValue === B &amp;&amp; (d._currentValue = b), d._currentValue2 === B &amp;&amp; (d._currentValue2 = b);</span><span class="s1">else if </span><span class="s0">(c) </span><span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;ServerContext: &quot; </span><span class="s0">+ a + </span><span class="s2">&quot; already defined&quot;</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">d;</span>
<span class="s0">};</span>

<span class="s0">exports.experimental_useEffectEvent = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">W.current.useEffectEvent(a);</span>
<span class="s0">};</span>

<span class="s0">exports.experimental_useOptimistic = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">return </span><span class="s0">W.current.useOptimistic(a, b);</span>
<span class="s0">};</span>

<span class="s0">exports.forwardRef = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">$$typeof: w,</span>
    <span class="s0">render: a</span>
  <span class="s0">};</span>
<span class="s0">};</span>

<span class="s0">exports.isValidElement = P;</span>

<span class="s0">exports.lazy = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">$$typeof: A,</span>
    <span class="s0">_payload: {</span>
      <span class="s0">_status: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">_result: a</span>
    <span class="s0">},</span>
    <span class="s0">_init: fa</span>
  <span class="s0">};</span>
<span class="s0">};</span>

<span class="s0">exports.memo = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">$$typeof: z,</span>
    <span class="s0">type: a,</span>
    <span class="s0">compare: </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">=== b ? </span><span class="s1">null </span><span class="s0">: b</span>
  <span class="s0">};</span>
<span class="s0">};</span>

<span class="s0">exports.startTransition = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">var </span><span class="s0">b = X.transition;</span>
  <span class="s0">X.transition = {};</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s0">a();</span>
  <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
    <span class="s0">X.transition = b;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">exports.unstable_Cache = ca;</span>
<span class="s0">exports.unstable_DebugTracingMode = aa;</span>
<span class="s0">exports.unstable_Offscreen = ba;</span>

<span class="s0">exports.unstable_act = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;act(...) is not supported in production builds of React.&quot;</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">exports.unstable_getCacheForType = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">var </span><span class="s0">b = U.current;</span>
  <span class="s1">return </span><span class="s0">b ? b.getCacheForType(a) : a();</span>
<span class="s0">};</span>

<span class="s0">exports.unstable_getCacheSignal = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">var </span><span class="s0">a = U.current;</span>
  <span class="s1">return </span><span class="s0">a ? a.getCacheSignal() : (a = </span><span class="s1">new </span><span class="s0">AbortController(), a.abort(Error(</span><span class="s2">&quot;This CacheSignal was requested outside React which means that it is immediately aborted.&quot;</span><span class="s0">)), a.signal);</span>
<span class="s0">};</span>

<span class="s0">exports.unstable_useCacheRefresh = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">W.current.useCacheRefresh();</span>
<span class="s0">};</span>

<span class="s0">exports.unstable_useMemoCache = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">W.current.useMemoCache(a);</span>
<span class="s0">};</span>

<span class="s0">exports.use = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">W.current.use(a);</span>
<span class="s0">};</span>

<span class="s0">exports.useCallback = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">return </span><span class="s0">W.current.useCallback(a, b);</span>
<span class="s0">};</span>

<span class="s0">exports.useContext = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">W.current.useContext(a);</span>
<span class="s0">};</span>

<span class="s0">exports.useDebugValue = </span><span class="s1">function </span><span class="s0">() {};</span>

<span class="s0">exports.useDeferredValue = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">W.current.useDeferredValue(a);</span>
<span class="s0">};</span>

<span class="s0">exports.useEffect = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">return </span><span class="s0">W.current.useEffect(a, b);</span>
<span class="s0">};</span>

<span class="s0">exports.useId = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">W.current.useId();</span>
<span class="s0">};</span>

<span class="s0">exports.useImperativeHandle = </span><span class="s1">function </span><span class="s0">(a, b, c) {</span>
  <span class="s1">return </span><span class="s0">W.current.useImperativeHandle(a, b, c);</span>
<span class="s0">};</span>

<span class="s0">exports.useInsertionEffect = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">return </span><span class="s0">W.current.useInsertionEffect(a, b);</span>
<span class="s0">};</span>

<span class="s0">exports.useLayoutEffect = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">return </span><span class="s0">W.current.useLayoutEffect(a, b);</span>
<span class="s0">};</span>

<span class="s0">exports.useMemo = </span><span class="s1">function </span><span class="s0">(a, b) {</span>
  <span class="s1">return </span><span class="s0">W.current.useMemo(a, b);</span>
<span class="s0">};</span>

<span class="s0">exports.useReducer = </span><span class="s1">function </span><span class="s0">(a, b, c) {</span>
  <span class="s1">return </span><span class="s0">W.current.useReducer(a, b, c);</span>
<span class="s0">};</span>

<span class="s0">exports.useRef = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">W.current.useRef(a);</span>
<span class="s0">};</span>

<span class="s0">exports.useState = </span><span class="s1">function </span><span class="s0">(a) {</span>
  <span class="s1">return </span><span class="s0">W.current.useState(a);</span>
<span class="s0">};</span>

<span class="s0">exports.useSyncExternalStore = </span><span class="s1">function </span><span class="s0">(a, b, c) {</span>
  <span class="s1">return </span><span class="s0">W.current.useSyncExternalStore(a, b, c);</span>
<span class="s0">};</span>

<span class="s0">exports.useTransition = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">W.current.useTransition();</span>
<span class="s0">};</span>

<span class="s0">exports.version = </span><span class="s2">&quot;18.3.0-experimental-53ac21937-20230703&quot;</span><span class="s0">;</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">189</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span>

<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>


<span class="s1">if </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
  <span class="s0">module.exports = __webpack_require__(</span><span class="s4">978</span><span class="s0">);</span>
<span class="s0">} </span><span class="s1">else </span><span class="s0">{}</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">206</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports, __webpack_require__) {</span>

<span class="s1">var </span><span class="s0">__WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;</span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s0">(</span><span class="s1">function </span><span class="s0">(root, factory) {</span>
  <span class="s2">'use strict'</span><span class="s0">; </span><span class="s3">// Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.</span>

  <span class="s3">/* istanbul ignore next */</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
    <span class="s0">!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(</span><span class="s4">430</span><span class="s0">)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),</span>
		<span class="s0">__WEBPACK_AMD_DEFINE_RESULT__ = (</span><span class="s1">typeof </span><span class="s0">__WEBPACK_AMD_DEFINE_FACTORY__ === </span><span class="s2">'function' </span><span class="s0">?</span>
		<span class="s0">(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),</span>
		<span class="s0">__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{}</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function </span><span class="s0">ErrorStackParser(StackFrame) {</span>
  <span class="s2">'use strict'</span><span class="s0">;</span>

  <span class="s1">var </span><span class="s0">FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;</span>
  <span class="s1">var </span><span class="s0">CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;</span>
  <span class="s1">var </span><span class="s0">SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s3">/** 
     * Given an Error object, extract the most information from it. 
     * 
     * @param {Error} error object 
     * @return {Array} of StackFrames 
     */</span>
    <span class="s0">parse: </span><span class="s1">function </span><span class="s0">ErrorStackParser$$parse(error) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">error.stacktrace !== </span><span class="s2">'undefined' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">error[</span><span class="s2">'opera#sourceloc'</span><span class="s0">] !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
        <span class="s1">return this</span><span class="s0">.parseOpera(error);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(error.stack &amp;&amp; error.stack.match(CHROME_IE_STACK_REGEXP)) {</span>
        <span class="s1">return this</span><span class="s0">.parseV8OrIE(error);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(error.stack) {</span>
        <span class="s1">return this</span><span class="s0">.parseFFOrSafari(error);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Cannot parse given Error object'</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s3">// Separate line and column numbers from a string of the form: (URI:Line:Column)</span>
    <span class="s0">extractLocation: </span><span class="s1">function </span><span class="s0">ErrorStackParser$$extractLocation(urlLike) {</span>
      <span class="s3">// Fail-fast but return locations like &quot;(native)&quot;</span>
      <span class="s1">if </span><span class="s0">(urlLike.indexOf(</span><span class="s2">':'</span><span class="s0">) === -</span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">[urlLike];</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;</span>
      <span class="s1">var </span><span class="s0">parts = regExp.exec(urlLike.replace(/[()]/g, </span><span class="s2">''</span><span class="s0">));</span>
      <span class="s1">return </span><span class="s0">[parts[</span><span class="s4">1</span><span class="s0">], parts[</span><span class="s4">2</span><span class="s0">] || undefined, parts[</span><span class="s4">3</span><span class="s0">] || undefined];</span>
    <span class="s0">},</span>
    <span class="s0">parseV8OrIE: </span><span class="s1">function </span><span class="s0">ErrorStackParser$$parseV8OrIE(error) {</span>
      <span class="s1">var </span><span class="s0">filtered = error.stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).filter(</span><span class="s1">function </span><span class="s0">(line) {</span>
        <span class="s1">return </span><span class="s0">!!line.match(CHROME_IE_STACK_REGEXP);</span>
      <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
      <span class="s1">return </span><span class="s0">filtered.map(</span><span class="s1">function </span><span class="s0">(line) {</span>
        <span class="s1">if </span><span class="s0">(line.indexOf(</span><span class="s2">'(eval '</span><span class="s0">) &gt; -</span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s3">// Throw away eval information until we implement stacktrace.js/stackframe#8</span>
          <span class="s0">line = line.replace(/eval code/g, </span><span class="s2">'eval'</span><span class="s0">).replace(/(\(eval at [^()]*)|(\),.*$)/g, </span><span class="s2">''</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">sanitizedLine = line.replace(/^\s+/, </span><span class="s2">''</span><span class="s0">).replace(/\(eval code/g, </span><span class="s2">'('</span><span class="s0">); </span><span class="s3">// capture and preseve the parenthesized location &quot;(/foo/my bar.js:12:87)&quot; in</span>
        <span class="s3">// case it has spaces in it, as the string is split on \s+ later on</span>

        <span class="s1">var </span><span class="s0">location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/); </span><span class="s3">// remove the parenthesized location from the line, if it was matched</span>

        <span class="s0">sanitizedLine = location ? sanitizedLine.replace(location[</span><span class="s4">0</span><span class="s0">], </span><span class="s2">''</span><span class="s0">) : sanitizedLine;</span>
        <span class="s1">var </span><span class="s0">tokens = sanitizedLine.split(/\s+/).slice(</span><span class="s4">1</span><span class="s0">); </span><span class="s3">// if a location was matched, pass it to extractLocation() otherwise pop the last token</span>

        <span class="s1">var </span><span class="s0">locationParts = </span><span class="s1">this</span><span class="s0">.extractLocation(location ? location[</span><span class="s4">1</span><span class="s0">] : tokens.pop());</span>
        <span class="s1">var </span><span class="s0">functionName = tokens.join(</span><span class="s2">' '</span><span class="s0">) || undefined;</span>
        <span class="s1">var </span><span class="s0">fileName = [</span><span class="s2">'eval'</span><span class="s0">, </span><span class="s2">'&lt;anonymous&gt;'</span><span class="s0">].indexOf(locationParts[</span><span class="s4">0</span><span class="s0">]) &gt; -</span><span class="s4">1 </span><span class="s0">? undefined : locationParts[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">return new </span><span class="s0">StackFrame({</span>
          <span class="s0">functionName: functionName,</span>
          <span class="s0">fileName: fileName,</span>
          <span class="s0">lineNumber: locationParts[</span><span class="s4">1</span><span class="s0">],</span>
          <span class="s0">columnNumber: locationParts[</span><span class="s4">2</span><span class="s0">],</span>
          <span class="s0">source: line</span>
        <span class="s0">});</span>
      <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">},</span>
    <span class="s0">parseFFOrSafari: </span><span class="s1">function </span><span class="s0">ErrorStackParser$$parseFFOrSafari(error) {</span>
      <span class="s1">var </span><span class="s0">filtered = error.stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).filter(</span><span class="s1">function </span><span class="s0">(line) {</span>
        <span class="s1">return </span><span class="s0">!line.match(SAFARI_NATIVE_CODE_REGEXP);</span>
      <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
      <span class="s1">return </span><span class="s0">filtered.map(</span><span class="s1">function </span><span class="s0">(line) {</span>
        <span class="s3">// Throw away eval information until we implement stacktrace.js/stackframe#8</span>
        <span class="s1">if </span><span class="s0">(line.indexOf(</span><span class="s2">' &gt; eval'</span><span class="s0">) &gt; -</span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s0">line = line.replace(/ line (\d+)(?: &gt; eval line \d+)* &gt; eval:\d+:\d+/g, </span><span class="s2">':$1'</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(line.indexOf(</span><span class="s2">'@'</span><span class="s0">) === -</span><span class="s4">1 </span><span class="s0">&amp;&amp; line.indexOf(</span><span class="s2">':'</span><span class="s0">) === -</span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s3">// Safari eval frames only have function names and nothing else</span>
          <span class="s1">return new </span><span class="s0">StackFrame({</span>
            <span class="s0">functionName: line</span>
          <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">var </span><span class="s0">functionNameRegex = /((.*</span><span class="s2">&quot;.+&quot;</span><span class="s0">[^@]*)?[^@]*)(?:@)/;</span>
          <span class="s1">var </span><span class="s0">matches = line.match(functionNameRegex);</span>
          <span class="s1">var </span><span class="s0">functionName = matches &amp;&amp; matches[</span><span class="s4">1</span><span class="s0">] ? matches[</span><span class="s4">1</span><span class="s0">] : undefined;</span>
          <span class="s1">var </span><span class="s0">locationParts = </span><span class="s1">this</span><span class="s0">.extractLocation(line.replace(functionNameRegex, </span><span class="s2">''</span><span class="s0">));</span>
          <span class="s1">return new </span><span class="s0">StackFrame({</span>
            <span class="s0">functionName: functionName,</span>
            <span class="s0">fileName: locationParts[</span><span class="s4">0</span><span class="s0">],</span>
            <span class="s0">lineNumber: locationParts[</span><span class="s4">1</span><span class="s0">],</span>
            <span class="s0">columnNumber: locationParts[</span><span class="s4">2</span><span class="s0">],</span>
            <span class="s0">source: line</span>
          <span class="s0">});</span>
        <span class="s0">}</span>
      <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">},</span>
    <span class="s0">parseOpera: </span><span class="s1">function </span><span class="s0">ErrorStackParser$$parseOpera(e) {</span>
      <span class="s1">if </span><span class="s0">(!e.stacktrace || e.message.indexOf(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">) &gt; -</span><span class="s4">1 </span><span class="s0">&amp;&amp; e.message.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).length &gt; e.stacktrace.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).length) {</span>
        <span class="s1">return this</span><span class="s0">.parseOpera9(e);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!e.stack) {</span>
        <span class="s1">return this</span><span class="s0">.parseOpera10(e);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return this</span><span class="s0">.parseOpera11(e);</span>
      <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">parseOpera9: </span><span class="s1">function </span><span class="s0">ErrorStackParser$$parseOpera9(e) {</span>
      <span class="s1">var </span><span class="s0">lineRE = /Line (\d+).*script (?:</span><span class="s1">in </span><span class="s0">)?(\S+)/i;</span>
      <span class="s1">var </span><span class="s0">lines = e.message.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">);</span>
      <span class="s1">var </span><span class="s0">result = [];</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">2</span><span class="s0">, len = lines.length; i &lt; len; i += </span><span class="s4">2</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">match = lineRE.exec(lines[i]);</span>

        <span class="s1">if </span><span class="s0">(match) {</span>
          <span class="s0">result.push(</span><span class="s1">new </span><span class="s0">StackFrame({</span>
            <span class="s0">fileName: match[</span><span class="s4">2</span><span class="s0">],</span>
            <span class="s0">lineNumber: match[</span><span class="s4">1</span><span class="s0">],</span>
            <span class="s0">source: lines[i]</span>
          <span class="s0">}));</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">result;</span>
    <span class="s0">},</span>
    <span class="s0">parseOpera10: </span><span class="s1">function </span><span class="s0">ErrorStackParser$$parseOpera10(e) {</span>
      <span class="s1">var </span><span class="s0">lineRE = /Line (\d+).*script (?:</span><span class="s1">in </span><span class="s0">)?(\S+)(?:: In </span><span class="s1">function </span><span class="s0">(\S+))?$/i;</span>
      <span class="s1">var </span><span class="s0">lines = e.stacktrace.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">);</span>
      <span class="s1">var </span><span class="s0">result = [];</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = lines.length; i &lt; len; i += </span><span class="s4">2</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">match = lineRE.exec(lines[i]);</span>

        <span class="s1">if </span><span class="s0">(match) {</span>
          <span class="s0">result.push(</span><span class="s1">new </span><span class="s0">StackFrame({</span>
            <span class="s0">functionName: match[</span><span class="s4">3</span><span class="s0">] || undefined,</span>
            <span class="s0">fileName: match[</span><span class="s4">2</span><span class="s0">],</span>
            <span class="s0">lineNumber: match[</span><span class="s4">1</span><span class="s0">],</span>
            <span class="s0">source: lines[i]</span>
          <span class="s0">}));</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">result;</span>
    <span class="s0">},</span>
    <span class="s3">// Opera 10.65+ Error.stack very similar to FF/Safari</span>
    <span class="s0">parseOpera11: </span><span class="s1">function </span><span class="s0">ErrorStackParser$$parseOpera11(error) {</span>
      <span class="s1">var </span><span class="s0">filtered = error.stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).filter(</span><span class="s1">function </span><span class="s0">(line) {</span>
        <span class="s1">return </span><span class="s0">!!line.match(FIREFOX_SAFARI_STACK_REGEXP) &amp;&amp; !line.match(/^Error created at/);</span>
      <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
      <span class="s1">return </span><span class="s0">filtered.map(</span><span class="s1">function </span><span class="s0">(line) {</span>
        <span class="s1">var </span><span class="s0">tokens = line.split(</span><span class="s2">'@'</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">locationParts = </span><span class="s1">this</span><span class="s0">.extractLocation(tokens.pop());</span>
        <span class="s1">var </span><span class="s0">functionCall = tokens.shift() || </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">functionName = functionCall.replace(/&lt;anonymous </span><span class="s1">function</span><span class="s0">(: (\w+))?&gt;/, </span><span class="s2">'$2'</span><span class="s0">).replace(/\([^)]*\)/g, </span><span class="s2">''</span><span class="s0">) || undefined;</span>
        <span class="s1">var </span><span class="s0">argsRaw;</span>

        <span class="s1">if </span><span class="s0">(functionCall.match(/\(([^)]*)\)/)) {</span>
          <span class="s0">argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, </span><span class="s2">'$1'</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">args = argsRaw === undefined || argsRaw === </span><span class="s2">'[arguments not available]' </span><span class="s0">? undefined : argsRaw.split(</span><span class="s2">','</span><span class="s0">);</span>
        <span class="s1">return new </span><span class="s0">StackFrame({</span>
          <span class="s0">functionName: functionName,</span>
          <span class="s0">args: args,</span>
          <span class="s0">fileName: locationParts[</span><span class="s4">0</span><span class="s0">],</span>
          <span class="s0">lineNumber: locationParts[</span><span class="s4">1</span><span class="s0">],</span>
          <span class="s0">columnNumber: locationParts[</span><span class="s4">2</span><span class="s0">],</span>
          <span class="s0">source: line</span>
        <span class="s0">});</span>
      <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">};</span>
<span class="s0">});</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">172</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module) =&gt; {</span>

<span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s3">/** 
 * lodash (Custom Build) &lt;https://lodash.com/&gt; 
 * Build: `lodash modularize exports=&quot;npm&quot; -o ./` 
 * Copyright jQuery Foundation and other contributors &lt;https://jquery.org/&gt; 
 * Released under MIT license &lt;https://lodash.com/license&gt; 
 * Based on Underscore.js 1.8.3 &lt;http://underscorejs.org/LICENSE&gt; 
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors 
 */</span>

<span class="s3">/** Used as the `TypeError` message for &quot;Functions&quot; methods. */</span>
<span class="s1">var </span><span class="s0">FUNC_ERROR_TEXT = </span><span class="s2">'Expected a function'</span><span class="s0">;</span>
<span class="s3">/** Used as references for various `Number` constants. */</span>

<span class="s1">var </span><span class="s0">NAN = </span><span class="s4">0 </span><span class="s0">/ </span><span class="s4">0</span><span class="s0">;</span>
<span class="s3">/** `Object#toString` result references. */</span>

<span class="s1">var </span><span class="s0">symbolTag = </span><span class="s2">'[object Symbol]'</span><span class="s0">;</span>
<span class="s3">/** Used to match leading and trailing whitespace. */</span>

<span class="s1">var </span><span class="s0">reTrim = /^\s+|\s+$/g;</span>
<span class="s3">/** Used to detect bad signed hexadecimal string values. */</span>

<span class="s1">var </span><span class="s0">reIsBadHex = /^[-+]</span><span class="s4">0</span><span class="s0">x[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">a-f]+$/i;</span>
<span class="s3">/** Used to detect binary string values. */</span>

<span class="s1">var </span><span class="s0">reIsBinary = /^</span><span class="s4">0</span><span class="s0">b[</span><span class="s4">01</span><span class="s0">]+$/i;</span>
<span class="s3">/** Used to detect octal string values. */</span>

<span class="s1">var </span><span class="s0">reIsOctal = /^</span><span class="s4">0</span><span class="s0">o[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">7</span><span class="s0">]+$/i;</span>
<span class="s3">/** Built-in method references without a dependency on `root`. */</span>

<span class="s1">var </span><span class="s0">freeParseInt = parseInt;</span>
<span class="s3">/** Detect free variable `global` from Node.js. */</span>

<span class="s1">var </span><span class="s0">freeGlobal = (</span><span class="s1">typeof </span><span class="s0">global === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? </span><span class="s2">&quot;undefined&quot; </span><span class="s0">: _typeof(global)) == </span><span class="s2">'object' </span><span class="s0">&amp;&amp; global &amp;&amp; global.Object === Object &amp;&amp; global;</span>
<span class="s3">/** Detect free variable `self`. */</span>

<span class="s1">var </span><span class="s0">freeSelf = (</span><span class="s1">typeof </span><span class="s0">self === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? </span><span class="s2">&quot;undefined&quot; </span><span class="s0">: _typeof(self)) == </span><span class="s2">'object' </span><span class="s0">&amp;&amp; self &amp;&amp; self.Object === Object &amp;&amp; self;</span>
<span class="s3">/** Used as a reference to the global object. */</span>

<span class="s1">var </span><span class="s0">root = freeGlobal || freeSelf || Function(</span><span class="s2">'return this'</span><span class="s0">)();</span>
<span class="s3">/** Used for built-in method references. */</span>

<span class="s1">var </span><span class="s0">objectProto = Object.prototype;</span>
<span class="s3">/** 
 * Used to resolve the 
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring) 
 * of values. 
 */</span>

<span class="s1">var </span><span class="s0">objectToString = objectProto.toString;</span>
<span class="s3">/* Built-in method references for those with the same name as other `lodash` methods. */</span>

<span class="s1">var </span><span class="s0">nativeMax = Math.max,</span>
    <span class="s0">nativeMin = Math.min;</span>
<span class="s3">/** 
 * Gets the timestamp of the number of milliseconds that have elapsed since 
 * the Unix epoch (1 January 1970 00:00:00 UTC). 
 * 
 * @static 
 * @memberOf _ 
 * @since 2.4.0 
 * @category Date 
 * @returns {number} Returns the timestamp. 
 * @example 
 * 
 * _.defer(function(stamp) { 
 *   console.log(_.now() - stamp); 
 * }, _.now()); 
 * // =&gt; Logs the number of milliseconds it took for the deferred invocation. 
 */</span>

<span class="s1">var </span><span class="s0">now = </span><span class="s1">function </span><span class="s0">now() {</span>
  <span class="s1">return </span><span class="s0">root.Date.now();</span>
<span class="s0">};</span>
<span class="s3">/** 
 * Creates a debounced function that delays invoking `func` until after `wait` 
 * milliseconds have elapsed since the last time the debounced function was 
 * invoked. The debounced function comes with a `cancel` method to cancel 
 * delayed `func` invocations and a `flush` method to immediately invoke them. 
 * Provide `options` to indicate whether `func` should be invoked on the 
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked 
 * with the last arguments provided to the debounced function. Subsequent 
 * calls to the debounced function return the result of the last `func` 
 * invocation. 
 * 
 * **Note:** If `leading` and `trailing` options are `true`, `func` is 
 * invoked on the trailing edge of the timeout only if the debounced function 
 * is invoked more than once during the `wait` timeout. 
 * 
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred 
 * until to the next tick, similar to `setTimeout` with a timeout of `0`. 
 * 
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/) 
 * for details over the differences between `_.debounce` and `_.throttle`. 
 * 
 * @static 
 * @memberOf _ 
 * @since 0.1.0 
 * @category Function 
 * @param {Function} func The function to debounce. 
 * @param {number} [wait=0] The number of milliseconds to delay. 
 * @param {Object} [options={}] The options object. 
 * @param {boolean} [options.leading=false] 
 *  Specify invoking on the leading edge of the timeout. 
 * @param {number} [options.maxWait] 
 *  The maximum time `func` is allowed to be delayed before it's invoked. 
 * @param {boolean} [options.trailing=true] 
 *  Specify invoking on the trailing edge of the timeout. 
 * @returns {Function} Returns the new debounced function. 
 * @example 
 * 
 * // Avoid costly calculations while the window size is in flux. 
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150)); 
 * 
 * // Invoke `sendMail` when clicked, debouncing subsequent calls. 
 * jQuery(element).on('click', _.debounce(sendMail, 300, { 
 *   'leading': true, 
 *   'trailing': false 
 * })); 
 * 
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls. 
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 }); 
 * var source = new EventSource('/stream'); 
 * jQuery(source).on('message', debounced); 
 * 
 * // Cancel the trailing debounced invocation. 
 * jQuery(window).on('popstate', debounced.cancel); 
 */</span>


<span class="s1">function </span><span class="s0">debounce(func, wait, options) {</span>
  <span class="s1">var </span><span class="s0">lastArgs,</span>
      <span class="s0">lastThis,</span>
      <span class="s0">maxWait,</span>
      <span class="s0">result,</span>
      <span class="s0">timerId,</span>
      <span class="s0">lastCallTime,</span>
      <span class="s0">lastInvokeTime = </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">leading = </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">maxing = </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">trailing = </span><span class="s1">true</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">func != </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">throw new </span><span class="s0">TypeError(FUNC_ERROR_TEXT);</span>
  <span class="s0">}</span>

  <span class="s0">wait = toNumber(wait) || </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(isObject(options)) {</span>
    <span class="s0">leading = !!options.leading;</span>
    <span class="s0">maxing = </span><span class="s2">'maxWait' </span><span class="s1">in </span><span class="s0">options;</span>
    <span class="s0">maxWait = maxing ? nativeMax(toNumber(options.maxWait) || </span><span class="s4">0</span><span class="s0">, wait) : maxWait;</span>
    <span class="s0">trailing = </span><span class="s2">'trailing' </span><span class="s1">in </span><span class="s0">options ? !!options.trailing : trailing;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">invokeFunc(time) {</span>
    <span class="s1">var </span><span class="s0">args = lastArgs,</span>
        <span class="s0">thisArg = lastThis;</span>
    <span class="s0">lastArgs = lastThis = undefined;</span>
    <span class="s0">lastInvokeTime = time;</span>
    <span class="s0">result = func.apply(thisArg, args);</span>
    <span class="s1">return </span><span class="s0">result;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">leadingEdge(time) {</span>
    <span class="s3">// Reset any `maxWait` timer.</span>
    <span class="s0">lastInvokeTime = time; </span><span class="s3">// Start the timer for the trailing edge.</span>

    <span class="s0">timerId = setTimeout(timerExpired, wait); </span><span class="s3">// Invoke the leading edge.</span>

    <span class="s1">return </span><span class="s0">leading ? invokeFunc(time) : result;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">remainingWait(time) {</span>
    <span class="s1">var </span><span class="s0">timeSinceLastCall = time - lastCallTime,</span>
        <span class="s0">timeSinceLastInvoke = time - lastInvokeTime,</span>
        <span class="s0">result = wait - timeSinceLastCall;</span>
    <span class="s1">return </span><span class="s0">maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">shouldInvoke(time) {</span>
    <span class="s1">var </span><span class="s0">timeSinceLastCall = time - lastCallTime,</span>
        <span class="s0">timeSinceLastInvoke = time - lastInvokeTime; </span><span class="s3">// Either this is the first call, activity has stopped and we're at the</span>
    <span class="s3">// trailing edge, the system time has gone backwards and we're treating</span>
    <span class="s3">// it as the trailing edge, or we've hit the `maxWait` limit.</span>

    <span class="s1">return </span><span class="s0">lastCallTime === undefined || timeSinceLastCall &gt;= wait || timeSinceLastCall &lt; </span><span class="s4">0 </span><span class="s0">|| maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">timerExpired() {</span>
    <span class="s1">var </span><span class="s0">time = now();</span>

    <span class="s1">if </span><span class="s0">(shouldInvoke(time)) {</span>
      <span class="s1">return </span><span class="s0">trailingEdge(time);</span>
    <span class="s0">} </span><span class="s3">// Restart the timer.</span>


    <span class="s0">timerId = setTimeout(timerExpired, remainingWait(time));</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">trailingEdge(time) {</span>
    <span class="s0">timerId = undefined; </span><span class="s3">// Only invoke if we have `lastArgs` which means `func` has been</span>
    <span class="s3">// debounced at least once.</span>

    <span class="s1">if </span><span class="s0">(trailing &amp;&amp; lastArgs) {</span>
      <span class="s1">return </span><span class="s0">invokeFunc(time);</span>
    <span class="s0">}</span>

    <span class="s0">lastArgs = lastThis = undefined;</span>
    <span class="s1">return </span><span class="s0">result;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">cancel() {</span>
    <span class="s1">if </span><span class="s0">(timerId !== undefined) {</span>
      <span class="s0">clearTimeout(timerId);</span>
    <span class="s0">}</span>

    <span class="s0">lastInvokeTime = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">lastArgs = lastCallTime = lastThis = timerId = undefined;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">flush() {</span>
    <span class="s1">return </span><span class="s0">timerId === undefined ? result : trailingEdge(now());</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">debounced() {</span>
    <span class="s1">var </span><span class="s0">time = now(),</span>
        <span class="s0">isInvoking = shouldInvoke(time);</span>
    <span class="s0">lastArgs = arguments;</span>
    <span class="s0">lastThis = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">lastCallTime = time;</span>

    <span class="s1">if </span><span class="s0">(isInvoking) {</span>
      <span class="s1">if </span><span class="s0">(timerId === undefined) {</span>
        <span class="s1">return </span><span class="s0">leadingEdge(lastCallTime);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(maxing) {</span>
        <span class="s3">// Handle invocations in a tight loop.</span>
        <span class="s0">timerId = setTimeout(timerExpired, wait);</span>
        <span class="s1">return </span><span class="s0">invokeFunc(lastCallTime);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(timerId === undefined) {</span>
      <span class="s0">timerId = setTimeout(timerExpired, wait);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">result;</span>
  <span class="s0">}</span>

  <span class="s0">debounced.cancel = cancel;</span>
  <span class="s0">debounced.flush = flush;</span>
  <span class="s1">return </span><span class="s0">debounced;</span>
<span class="s0">}</span>
<span class="s3">/** 
 * Creates a throttled function that only invokes `func` at most once per 
 * every `wait` milliseconds. The throttled function comes with a `cancel` 
 * method to cancel delayed `func` invocations and a `flush` method to 
 * immediately invoke them. Provide `options` to indicate whether `func` 
 * should be invoked on the leading and/or trailing edge of the `wait` 
 * timeout. The `func` is invoked with the last arguments provided to the 
 * throttled function. Subsequent calls to the throttled function return the 
 * result of the last `func` invocation. 
 * 
 * **Note:** If `leading` and `trailing` options are `true`, `func` is 
 * invoked on the trailing edge of the timeout only if the throttled function 
 * is invoked more than once during the `wait` timeout. 
 * 
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred 
 * until to the next tick, similar to `setTimeout` with a timeout of `0`. 
 * 
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/) 
 * for details over the differences between `_.throttle` and `_.debounce`. 
 * 
 * @static 
 * @memberOf _ 
 * @since 0.1.0 
 * @category Function 
 * @param {Function} func The function to throttle. 
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to. 
 * @param {Object} [options={}] The options object. 
 * @param {boolean} [options.leading=true] 
 *  Specify invoking on the leading edge of the timeout. 
 * @param {boolean} [options.trailing=true] 
 *  Specify invoking on the trailing edge of the timeout. 
 * @returns {Function} Returns the new throttled function. 
 * @example 
 * 
 * // Avoid excessively updating the position while scrolling. 
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100)); 
 * 
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes. 
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false }); 
 * jQuery(element).on('click', throttled); 
 * 
 * // Cancel the trailing throttled invocation. 
 * jQuery(window).on('popstate', throttled.cancel); 
 */</span>


<span class="s1">function </span><span class="s0">throttle(func, wait, options) {</span>
  <span class="s1">var </span><span class="s0">leading = </span><span class="s1">true</span><span class="s0">,</span>
      <span class="s0">trailing = </span><span class="s1">true</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">func != </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">throw new </span><span class="s0">TypeError(FUNC_ERROR_TEXT);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(isObject(options)) {</span>
    <span class="s0">leading = </span><span class="s2">'leading' </span><span class="s1">in </span><span class="s0">options ? !!options.leading : leading;</span>
    <span class="s0">trailing = </span><span class="s2">'trailing' </span><span class="s1">in </span><span class="s0">options ? !!options.trailing : trailing;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">debounce(func, wait, {</span>
    <span class="s2">'leading'</span><span class="s0">: leading,</span>
    <span class="s2">'maxWait'</span><span class="s0">: wait,</span>
    <span class="s2">'trailing'</span><span class="s0">: trailing</span>
  <span class="s0">});</span>
<span class="s0">}</span>
<span class="s3">/** 
 * Checks if `value` is the 
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types) 
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`) 
 * 
 * @static 
 * @memberOf _ 
 * @since 0.1.0 
 * @category Lang 
 * @param {*} value The value to check. 
 * @returns {boolean} Returns `true` if `value` is an object, else `false`. 
 * @example 
 * 
 * _.isObject({}); 
 * // =&gt; true 
 * 
 * _.isObject([1, 2, 3]); 
 * // =&gt; true 
 * 
 * _.isObject(_.noop); 
 * // =&gt; true 
 * 
 * _.isObject(null); 
 * // =&gt; false 
 */</span>


<span class="s1">function </span><span class="s0">isObject(value) {</span>
  <span class="s1">var </span><span class="s0">type = _typeof(value);</span>

  <span class="s1">return </span><span class="s0">!!value &amp;&amp; (type == </span><span class="s2">'object' </span><span class="s0">|| type == </span><span class="s2">'function'</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s3">/** 
 * Checks if `value` is object-like. A value is object-like if it's not `null` 
 * and has a `typeof` result of &quot;object&quot;. 
 * 
 * @static 
 * @memberOf _ 
 * @since 4.0.0 
 * @category Lang 
 * @param {*} value The value to check. 
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`. 
 * @example 
 * 
 * _.isObjectLike({}); 
 * // =&gt; true 
 * 
 * _.isObjectLike([1, 2, 3]); 
 * // =&gt; true 
 * 
 * _.isObjectLike(_.noop); 
 * // =&gt; false 
 * 
 * _.isObjectLike(null); 
 * // =&gt; false 
 */</span>


<span class="s1">function </span><span class="s0">isObjectLike(value) {</span>
  <span class="s1">return </span><span class="s0">!!value &amp;&amp; _typeof(value) == </span><span class="s2">'object'</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s3">/** 
 * Checks if `value` is classified as a `Symbol` primitive or object. 
 * 
 * @static 
 * @memberOf _ 
 * @since 4.0.0 
 * @category Lang 
 * @param {*} value The value to check. 
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`. 
 * @example 
 * 
 * _.isSymbol(Symbol.iterator); 
 * // =&gt; true 
 * 
 * _.isSymbol('abc'); 
 * // =&gt; false 
 */</span>


<span class="s1">function </span><span class="s0">isSymbol(value) {</span>
  <span class="s1">return </span><span class="s0">_typeof(value) == </span><span class="s2">'symbol' </span><span class="s0">|| isObjectLike(value) &amp;&amp; objectToString.call(value) == symbolTag;</span>
<span class="s0">}</span>
<span class="s3">/** 
 * Converts `value` to a number. 
 * 
 * @static 
 * @memberOf _ 
 * @since 4.0.0 
 * @category Lang 
 * @param {*} value The value to process. 
 * @returns {number} Returns the number. 
 * @example 
 * 
 * _.toNumber(3.2); 
 * // =&gt; 3.2 
 * 
 * _.toNumber(Number.MIN_VALUE); 
 * // =&gt; 5e-324 
 * 
 * _.toNumber(Infinity); 
 * // =&gt; Infinity 
 * 
 * _.toNumber('3.2'); 
 * // =&gt; 3.2 
 */</span>


<span class="s1">function </span><span class="s0">toNumber(value) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value == </span><span class="s2">'number'</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">value;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(isSymbol(value)) {</span>
    <span class="s1">return </span><span class="s0">NAN;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(isObject(value)) {</span>
    <span class="s1">var </span><span class="s0">other = </span><span class="s1">typeof </span><span class="s0">value.valueOf == </span><span class="s2">'function' </span><span class="s0">? value.valueOf() : value;</span>
    <span class="s0">value = isObject(other) ? other + </span><span class="s2">'' </span><span class="s0">: other;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value != </span><span class="s2">'string'</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">value === </span><span class="s4">0 </span><span class="s0">? value : +value;</span>
  <span class="s0">}</span>

  <span class="s0">value = value.replace(reTrim, </span><span class="s2">''</span><span class="s0">);</span>
  <span class="s1">var </span><span class="s0">isBinary = reIsBinary.test(value);</span>
  <span class="s1">return </span><span class="s0">isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(</span><span class="s4">2</span><span class="s0">), isBinary ? </span><span class="s4">2 </span><span class="s0">: </span><span class="s4">8</span><span class="s0">) : reIsBadHex.test(value) ? NAN : +value;</span>
<span class="s0">}</span>

<span class="s0">module.exports = throttle;</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">730</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span>

<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s3">/* provided dependency */ </span><span class="s1">var </span><span class="s0">process = __webpack_require__(</span><span class="s4">169</span><span class="s0">);</span>


<span class="s0">module.exports = LRUCache; </span><span class="s3">// This will be a proper iterable 'Map' in engines that support it,</span>
<span class="s3">// or a fakey-fake PseudoMap in older versions.</span>

<span class="s1">var </span><span class="s0">Map = __webpack_require__(</span><span class="s4">307</span><span class="s0">);</span>

<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s4">82</span><span class="s0">); </span><span class="s3">// A linked list to keep track of recently-used-ness</span>


<span class="s1">var </span><span class="s0">Yallist = __webpack_require__(</span><span class="s4">695</span><span class="s0">); </span><span class="s3">// use symbols if possible, otherwise just _props</span>


<span class="s1">var </span><span class="s0">hasSymbol = </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; process.env._nodeLRUCacheForceNoSymbol !== </span><span class="s2">'1'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">makeSymbol;</span>

<span class="s1">if </span><span class="s0">(hasSymbol) {</span>
  <span class="s0">makeSymbol = </span><span class="s1">function </span><span class="s0">makeSymbol(key) {</span>
    <span class="s1">return </span><span class="s0">Symbol(key);</span>
  <span class="s0">};</span>
<span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
  <span class="s0">makeSymbol = </span><span class="s1">function </span><span class="s0">makeSymbol(key) {</span>
    <span class="s1">return </span><span class="s2">'_' </span><span class="s0">+ key;</span>
  <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">MAX = makeSymbol(</span><span class="s2">'max'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">LENGTH = makeSymbol(</span><span class="s2">'length'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">LENGTH_CALCULATOR = makeSymbol(</span><span class="s2">'lengthCalculator'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">ALLOW_STALE = makeSymbol(</span><span class="s2">'allowStale'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">MAX_AGE = makeSymbol(</span><span class="s2">'maxAge'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">DISPOSE = makeSymbol(</span><span class="s2">'dispose'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">NO_DISPOSE_ON_SET = makeSymbol(</span><span class="s2">'noDisposeOnSet'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">LRU_LIST = makeSymbol(</span><span class="s2">'lruList'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">CACHE = makeSymbol(</span><span class="s2">'cache'</span><span class="s0">);</span>

<span class="s1">function </span><span class="s0">naiveLength() {</span>
  <span class="s1">return </span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">} </span><span class="s3">// lruList is a yallist where the head is the youngest</span>
<span class="s3">// item, and the tail is the oldest.  the list contains the Hit</span>
<span class="s3">// objects as the entries.</span>
<span class="s3">// Each Hit object has a reference to its Yallist.Node.  This</span>
<span class="s3">// never changes.</span>
<span class="s3">//</span>
<span class="s3">// cache is a Map (or PseudoMap) that matches the keys to</span>
<span class="s3">// the Yallist.Node object.</span>


<span class="s1">function </span><span class="s0">LRUCache(options) {</span>
  <span class="s1">if </span><span class="s0">(!(</span><span class="s1">this instanceof </span><span class="s0">LRUCache)) {</span>
    <span class="s1">return new </span><span class="s0">LRUCache(options);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options === </span><span class="s2">'number'</span><span class="s0">) {</span>
    <span class="s0">options = {</span>
      <span class="s0">max: options</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(!options) {</span>
    <span class="s0">options = {};</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">max = </span><span class="s1">this</span><span class="s0">[MAX] = options.max; </span><span class="s3">// Kind of weird to have a default max of Infinity, but oh well.</span>

  <span class="s1">if </span><span class="s0">(!max || !(</span><span class="s1">typeof </span><span class="s0">max === </span><span class="s2">'number'</span><span class="s0">) || max &lt;= </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s1">this</span><span class="s0">[MAX] = Infinity;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">lc = options.length || naiveLength;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">lc !== </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s0">lc = naiveLength;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">[LENGTH_CALCULATOR] = lc;</span>
  <span class="s1">this</span><span class="s0">[ALLOW_STALE] = options.stale || </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">this</span><span class="s0">[MAX_AGE] = options.maxAge || </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">this</span><span class="s0">[DISPOSE] = options.dispose;</span>
  <span class="s1">this</span><span class="s0">[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">this</span><span class="s0">.reset();</span>
<span class="s0">} </span><span class="s3">// resize the cache when the max changes.</span>


<span class="s0">Object.defineProperty(LRUCache.prototype, </span><span class="s2">'max'</span><span class="s0">, {</span>
  <span class="s0">set: </span><span class="s1">function </span><span class="s0">set(mL) {</span>
    <span class="s1">if </span><span class="s0">(!mL || !(</span><span class="s1">typeof </span><span class="s0">mL === </span><span class="s2">'number'</span><span class="s0">) || mL &lt;= </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s0">mL = Infinity;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">[MAX] = mL;</span>
    <span class="s0">trim(</span><span class="s1">this</span><span class="s0">);</span>
  <span class="s0">},</span>
  <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
    <span class="s1">return this</span><span class="s0">[MAX];</span>
  <span class="s0">},</span>
  <span class="s0">enumerable: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(LRUCache.prototype, </span><span class="s2">'allowStale'</span><span class="s0">, {</span>
  <span class="s0">set: </span><span class="s1">function </span><span class="s0">set(allowStale) {</span>
    <span class="s1">this</span><span class="s0">[ALLOW_STALE] = !!allowStale;</span>
  <span class="s0">},</span>
  <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
    <span class="s1">return this</span><span class="s0">[ALLOW_STALE];</span>
  <span class="s0">},</span>
  <span class="s0">enumerable: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(LRUCache.prototype, </span><span class="s2">'maxAge'</span><span class="s0">, {</span>
  <span class="s0">set: </span><span class="s1">function </span><span class="s0">set(mA) {</span>
    <span class="s1">if </span><span class="s0">(!mA || !(</span><span class="s1">typeof </span><span class="s0">mA === </span><span class="s2">'number'</span><span class="s0">) || mA &lt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s0">mA = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">[MAX_AGE] = mA;</span>
    <span class="s0">trim(</span><span class="s1">this</span><span class="s0">);</span>
  <span class="s0">},</span>
  <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
    <span class="s1">return this</span><span class="s0">[MAX_AGE];</span>
  <span class="s0">},</span>
  <span class="s0">enumerable: </span><span class="s1">true</span>
<span class="s0">}); </span><span class="s3">// resize the cache when the lengthCalculator changes.</span>

<span class="s0">Object.defineProperty(LRUCache.prototype, </span><span class="s2">'lengthCalculator'</span><span class="s0">, {</span>
  <span class="s0">set: </span><span class="s1">function </span><span class="s0">set(lC) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">lC !== </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s0">lC = naiveLength;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(lC !== </span><span class="s1">this</span><span class="s0">[LENGTH_CALCULATOR]) {</span>
      <span class="s1">this</span><span class="s0">[LENGTH_CALCULATOR] = lC;</span>
      <span class="s1">this</span><span class="s0">[LENGTH] = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s1">this</span><span class="s0">[LRU_LIST].forEach(</span><span class="s1">function </span><span class="s0">(hit) {</span>
        <span class="s0">hit.length = </span><span class="s1">this</span><span class="s0">[LENGTH_CALCULATOR](hit.value, hit.key);</span>
        <span class="s1">this</span><span class="s0">[LENGTH] += hit.length;</span>
      <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">trim(</span><span class="s1">this</span><span class="s0">);</span>
  <span class="s0">},</span>
  <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
    <span class="s1">return this</span><span class="s0">[LENGTH_CALCULATOR];</span>
  <span class="s0">},</span>
  <span class="s0">enumerable: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(LRUCache.prototype, </span><span class="s2">'length'</span><span class="s0">, {</span>
  <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
    <span class="s1">return this</span><span class="s0">[LENGTH];</span>
  <span class="s0">},</span>
  <span class="s0">enumerable: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(LRUCache.prototype, </span><span class="s2">'itemCount'</span><span class="s0">, {</span>
  <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
    <span class="s1">return this</span><span class="s0">[LRU_LIST].length;</span>
  <span class="s0">},</span>
  <span class="s0">enumerable: </span><span class="s1">true</span>
<span class="s0">});</span>

<span class="s0">LRUCache.prototype.rforEach = </span><span class="s1">function </span><span class="s0">(fn, thisp) {</span>
  <span class="s0">thisp = thisp || </span><span class="s1">this</span><span class="s0">;</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">walker = </span><span class="s1">this</span><span class="s0">[LRU_LIST].tail; walker !== </span><span class="s1">null</span><span class="s0">;) {</span>
    <span class="s1">var </span><span class="s0">prev = walker.prev;</span>
    <span class="s0">forEachStep(</span><span class="s1">this</span><span class="s0">, fn, walker, thisp);</span>
    <span class="s0">walker = prev;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s1">function </span><span class="s0">forEachStep(self, fn, node, thisp) {</span>
  <span class="s1">var </span><span class="s0">hit = node.value;</span>

  <span class="s1">if </span><span class="s0">(isStale(self, hit)) {</span>
    <span class="s0">del(self, node);</span>

    <span class="s1">if </span><span class="s0">(!self[ALLOW_STALE]) {</span>
      <span class="s0">hit = undefined;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(hit) {</span>
    <span class="s0">fn.call(thisp, hit.value, hit.key, self);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">LRUCache.prototype.forEach = </span><span class="s1">function </span><span class="s0">(fn, thisp) {</span>
  <span class="s0">thisp = thisp || </span><span class="s1">this</span><span class="s0">;</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">walker = </span><span class="s1">this</span><span class="s0">[LRU_LIST].head; walker !== </span><span class="s1">null</span><span class="s0">;) {</span>
    <span class="s1">var </span><span class="s0">next = walker.next;</span>
    <span class="s0">forEachStep(</span><span class="s1">this</span><span class="s0">, fn, walker, thisp);</span>
    <span class="s0">walker = next;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.keys = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return this</span><span class="s0">[LRU_LIST].toArray().map(</span><span class="s1">function </span><span class="s0">(k) {</span>
    <span class="s1">return </span><span class="s0">k.key;</span>
  <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.values = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return this</span><span class="s0">[LRU_LIST].toArray().map(</span><span class="s1">function </span><span class="s0">(k) {</span>
    <span class="s1">return </span><span class="s0">k.value;</span>
  <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.reset = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">[DISPOSE] &amp;&amp; </span><span class="s1">this</span><span class="s0">[LRU_LIST] &amp;&amp; </span><span class="s1">this</span><span class="s0">[LRU_LIST].length) {</span>
    <span class="s1">this</span><span class="s0">[LRU_LIST].forEach(</span><span class="s1">function </span><span class="s0">(hit) {</span>
      <span class="s1">this</span><span class="s0">[DISPOSE](hit.key, hit.value);</span>
    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">[CACHE] = </span><span class="s1">new </span><span class="s0">Map(); </span><span class="s3">// hash of items by key</span>

  <span class="s1">this</span><span class="s0">[LRU_LIST] = </span><span class="s1">new </span><span class="s0">Yallist(); </span><span class="s3">// list of items in order of use recency</span>

  <span class="s1">this</span><span class="s0">[LENGTH] = </span><span class="s4">0</span><span class="s0">; </span><span class="s3">// length of items in the list</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.dump = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return this</span><span class="s0">[LRU_LIST].map(</span><span class="s1">function </span><span class="s0">(hit) {</span>
    <span class="s1">if </span><span class="s0">(!isStale(</span><span class="s1">this</span><span class="s0">, hit)) {</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">k: hit.key,</span>
        <span class="s0">v: hit.value,</span>
        <span class="s0">e: hit.now + (hit.maxAge || </span><span class="s4">0</span><span class="s0">)</span>
      <span class="s0">};</span>
    <span class="s0">}</span>
  <span class="s0">}, </span><span class="s1">this</span><span class="s0">).toArray().filter(</span><span class="s1">function </span><span class="s0">(h) {</span>
    <span class="s1">return </span><span class="s0">h;</span>
  <span class="s0">});</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.dumpLru = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return this</span><span class="s0">[LRU_LIST];</span>
<span class="s0">};</span>
<span class="s3">/* istanbul ignore next */</span>


<span class="s0">LRUCache.prototype.inspect = </span><span class="s1">function </span><span class="s0">(n, opts) {</span>
  <span class="s1">var </span><span class="s0">str = </span><span class="s2">'LRUCache {'</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">extras = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">as = </span><span class="s1">this</span><span class="s0">[ALLOW_STALE];</span>

  <span class="s1">if </span><span class="s0">(as) {</span>
    <span class="s0">str += </span><span class="s2">'</span><span class="s5">\n  </span><span class="s2">allowStale: true'</span><span class="s0">;</span>
    <span class="s0">extras = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">max = </span><span class="s1">this</span><span class="s0">[MAX];</span>

  <span class="s1">if </span><span class="s0">(max &amp;&amp; max !== Infinity) {</span>
    <span class="s1">if </span><span class="s0">(extras) {</span>
      <span class="s0">str += </span><span class="s2">','</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">str += </span><span class="s2">'</span><span class="s5">\n  </span><span class="s2">max: ' </span><span class="s0">+ util.inspect(max, opts);</span>
    <span class="s0">extras = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">maxAge = </span><span class="s1">this</span><span class="s0">[MAX_AGE];</span>

  <span class="s1">if </span><span class="s0">(maxAge) {</span>
    <span class="s1">if </span><span class="s0">(extras) {</span>
      <span class="s0">str += </span><span class="s2">','</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">str += </span><span class="s2">'</span><span class="s5">\n  </span><span class="s2">maxAge: ' </span><span class="s0">+ util.inspect(maxAge, opts);</span>
    <span class="s0">extras = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">lc = </span><span class="s1">this</span><span class="s0">[LENGTH_CALCULATOR];</span>

  <span class="s1">if </span><span class="s0">(lc &amp;&amp; lc !== naiveLength) {</span>
    <span class="s1">if </span><span class="s0">(extras) {</span>
      <span class="s0">str += </span><span class="s2">','</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">str += </span><span class="s2">'</span><span class="s5">\n  </span><span class="s2">length: ' </span><span class="s0">+ util.inspect(</span><span class="s1">this</span><span class="s0">[LENGTH], opts);</span>
    <span class="s0">extras = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">didFirst = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">this</span><span class="s0">[LRU_LIST].forEach(</span><span class="s1">function </span><span class="s0">(item) {</span>
    <span class="s1">if </span><span class="s0">(didFirst) {</span>
      <span class="s0">str += </span><span class="s2">',</span><span class="s5">\n  </span><span class="s2">'</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">if </span><span class="s0">(extras) {</span>
        <span class="s0">str += </span><span class="s2">',</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">didFirst = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">str += </span><span class="s2">'</span><span class="s5">\n  </span><span class="s2">'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">key = util.inspect(item.key).split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).join(</span><span class="s2">'</span><span class="s5">\n  </span><span class="s2">'</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">val = {</span>
      <span class="s0">value: item.value</span>
    <span class="s0">};</span>

    <span class="s1">if </span><span class="s0">(item.maxAge !== maxAge) {</span>
      <span class="s0">val.maxAge = item.maxAge;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(lc !== naiveLength) {</span>
      <span class="s0">val.length = item.length;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isStale(</span><span class="s1">this</span><span class="s0">, item)) {</span>
      <span class="s0">val.stale = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">val = util.inspect(val, opts).split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).join(</span><span class="s2">'</span><span class="s5">\n  </span><span class="s2">'</span><span class="s0">);</span>
    <span class="s0">str += key + </span><span class="s2">' =&gt; ' </span><span class="s0">+ val;</span>
  <span class="s0">});</span>

  <span class="s1">if </span><span class="s0">(didFirst || extras) {</span>
    <span class="s0">str += </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">str += </span><span class="s2">'}'</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s0">str;</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.set = </span><span class="s1">function </span><span class="s0">(key, value, maxAge) {</span>
  <span class="s0">maxAge = maxAge || </span><span class="s1">this</span><span class="s0">[MAX_AGE];</span>
  <span class="s1">var </span><span class="s0">now = maxAge ? Date.now() : </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">len = </span><span class="s1">this</span><span class="s0">[LENGTH_CALCULATOR](value, key);</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">[CACHE].has(key)) {</span>
    <span class="s1">if </span><span class="s0">(len &gt; </span><span class="s1">this</span><span class="s0">[MAX]) {</span>
      <span class="s0">del(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">this</span><span class="s0">[CACHE].get(key));</span>
      <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">[CACHE].get(key);</span>
    <span class="s1">var </span><span class="s0">item = node.value; </span><span class="s3">// dispose of the old one before overwriting</span>
    <span class="s3">// split out into 2 ifs for better coverage tracking</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">[DISPOSE]) {</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">[NO_DISPOSE_ON_SET]) {</span>
        <span class="s1">this</span><span class="s0">[DISPOSE](key, item.value);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">item.now = now;</span>
    <span class="s0">item.maxAge = maxAge;</span>
    <span class="s0">item.value = value;</span>
    <span class="s1">this</span><span class="s0">[LENGTH] += len - item.length;</span>
    <span class="s0">item.length = len;</span>
    <span class="s1">this</span><span class="s0">.get(key);</span>
    <span class="s0">trim(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s1">return true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">hit = </span><span class="s1">new </span><span class="s0">Entry(key, value, len, now, maxAge); </span><span class="s3">// oversized objects fall out of cache automatically.</span>

  <span class="s1">if </span><span class="s0">(hit.length &gt; </span><span class="s1">this</span><span class="s0">[MAX]) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">[DISPOSE]) {</span>
      <span class="s1">this</span><span class="s0">[DISPOSE](key, value);</span>
    <span class="s0">}</span>

    <span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">[LENGTH] += hit.length;</span>
  <span class="s1">this</span><span class="s0">[LRU_LIST].unshift(hit);</span>
  <span class="s1">this</span><span class="s0">[CACHE].set(key, </span><span class="s1">this</span><span class="s0">[LRU_LIST].head);</span>
  <span class="s0">trim(</span><span class="s1">this</span><span class="s0">);</span>
  <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.has = </span><span class="s1">function </span><span class="s0">(key) {</span>
  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">[CACHE].has(key)) </span><span class="s1">return false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">hit = </span><span class="s1">this</span><span class="s0">[CACHE].get(key).value;</span>

  <span class="s1">if </span><span class="s0">(isStale(</span><span class="s1">this</span><span class="s0">, hit)) {</span>
    <span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.get = </span><span class="s1">function </span><span class="s0">(key) {</span>
  <span class="s1">return </span><span class="s0">get(</span><span class="s1">this</span><span class="s0">, key, </span><span class="s1">true</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.peek = </span><span class="s1">function </span><span class="s0">(key) {</span>
  <span class="s1">return </span><span class="s0">get(</span><span class="s1">this</span><span class="s0">, key, </span><span class="s1">false</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.pop = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">[LRU_LIST].tail;</span>
  <span class="s1">if </span><span class="s0">(!node) </span><span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">del(</span><span class="s1">this</span><span class="s0">, node);</span>
  <span class="s1">return </span><span class="s0">node.value;</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.del = </span><span class="s1">function </span><span class="s0">(key) {</span>
  <span class="s0">del(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">this</span><span class="s0">[CACHE].get(key));</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.load = </span><span class="s1">function </span><span class="s0">(arr) {</span>
  <span class="s3">// reset the cache</span>
  <span class="s1">this</span><span class="s0">.reset();</span>
  <span class="s1">var </span><span class="s0">now = Date.now(); </span><span class="s3">// A previous serialized cache has the most recent items first</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">l = arr.length - </span><span class="s4">1</span><span class="s0">; l &gt;= </span><span class="s4">0</span><span class="s0">; l--) {</span>
    <span class="s1">var </span><span class="s0">hit = arr[l];</span>
    <span class="s1">var </span><span class="s0">expiresAt = hit.e || </span><span class="s4">0</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(expiresAt === </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s3">// the item was created without expiration in a non aged cache</span>
      <span class="s1">this</span><span class="s0">.set(hit.k, hit.v);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">maxAge = expiresAt - now; </span><span class="s3">// dont add already expired items</span>

      <span class="s1">if </span><span class="s0">(maxAge &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">this</span><span class="s0">.set(hit.k, hit.v, maxAge);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">LRUCache.prototype.prune = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
  <span class="s1">this</span><span class="s0">[CACHE].forEach(</span><span class="s1">function </span><span class="s0">(value, key) {</span>
    <span class="s0">get(self, key, </span><span class="s1">false</span><span class="s0">);</span>
  <span class="s0">});</span>
<span class="s0">};</span>

<span class="s1">function </span><span class="s0">get(self, key, doUse) {</span>
  <span class="s1">var </span><span class="s0">node = self[CACHE].get(key);</span>

  <span class="s1">if </span><span class="s0">(node) {</span>
    <span class="s1">var </span><span class="s0">hit = node.value;</span>

    <span class="s1">if </span><span class="s0">(isStale(self, hit)) {</span>
      <span class="s0">del(self, node);</span>
      <span class="s1">if </span><span class="s0">(!self[ALLOW_STALE]) hit = undefined;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">if </span><span class="s0">(doUse) {</span>
        <span class="s0">self[LRU_LIST].unshiftNode(node);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(hit) hit = hit.value;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">hit;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">isStale(self, hit) {</span>
  <span class="s1">if </span><span class="s0">(!hit || !hit.maxAge &amp;&amp; !self[MAX_AGE]) {</span>
    <span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">stale = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">diff = Date.now() - hit.now;</span>

  <span class="s1">if </span><span class="s0">(hit.maxAge) {</span>
    <span class="s0">stale = diff &gt; hit.maxAge;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">stale = self[MAX_AGE] &amp;&amp; diff &gt; self[MAX_AGE];</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">stale;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">trim(self) {</span>
  <span class="s1">if </span><span class="s0">(self[LENGTH] &gt; self[MAX]) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">walker = self[LRU_LIST].tail; self[LENGTH] &gt; self[MAX] &amp;&amp; walker !== </span><span class="s1">null</span><span class="s0">;) {</span>
      <span class="s3">// We know that we're about to delete this one, and also</span>
      <span class="s3">// what the next least recently used key will be, so just</span>
      <span class="s3">// go ahead and set it now.</span>
      <span class="s1">var </span><span class="s0">prev = walker.prev;</span>
      <span class="s0">del(self, walker);</span>
      <span class="s0">walker = prev;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">del(self, node) {</span>
  <span class="s1">if </span><span class="s0">(node) {</span>
    <span class="s1">var </span><span class="s0">hit = node.value;</span>

    <span class="s1">if </span><span class="s0">(self[DISPOSE]) {</span>
      <span class="s0">self[DISPOSE](hit.key, hit.value);</span>
    <span class="s0">}</span>

    <span class="s0">self[LENGTH] -= hit.length;</span>
    <span class="s0">self[CACHE].</span><span class="s1">delete</span><span class="s0">(hit.key);</span>
    <span class="s0">self[LRU_LIST].removeNode(node);</span>
  <span class="s0">}</span>
<span class="s0">} </span><span class="s3">// classy, since V8 prefers predictable objects.</span>


<span class="s1">function </span><span class="s0">Entry(key, value, length, now, maxAge) {</span>
  <span class="s1">this</span><span class="s0">.key = key;</span>
  <span class="s1">this</span><span class="s0">.value = value;</span>
  <span class="s1">this</span><span class="s0">.length = length;</span>
  <span class="s1">this</span><span class="s0">.now = now;</span>
  <span class="s1">this</span><span class="s0">.maxAge = maxAge || </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">169</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module) =&gt; {</span>

<span class="s3">// shim for using process in browser</span>
<span class="s1">var </span><span class="s0">process = module.exports = {}; </span><span class="s3">// cached from whatever global is present so that test runners that stub it</span>
<span class="s3">// don't break things.  But we need to wrap it in a try catch in case it is</span>
<span class="s3">// wrapped in strict mode code which doesn't define any globals.  It's inside a</span>
<span class="s3">// function because try/catches deoptimize in certain engines.</span>

<span class="s1">var </span><span class="s0">cachedSetTimeout;</span>
<span class="s1">var </span><span class="s0">cachedClearTimeout;</span>

<span class="s1">function </span><span class="s0">defaultSetTimout() {</span>
  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'setTimeout has not been defined'</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">defaultClearTimeout() {</span>
  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'clearTimeout has not been defined'</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s0">(</span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">setTimeout === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s0">cachedSetTimeout = setTimeout;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">cachedSetTimeout = defaultSetTimout;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
    <span class="s0">cachedSetTimeout = defaultSetTimout;</span>
  <span class="s0">}</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">clearTimeout === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s0">cachedClearTimeout = clearTimeout;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">cachedClearTimeout = defaultClearTimeout;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
    <span class="s0">cachedClearTimeout = defaultClearTimeout;</span>
  <span class="s0">}</span>
<span class="s0">})();</span>

<span class="s1">function </span><span class="s0">runTimeout(fun) {</span>
  <span class="s1">if </span><span class="s0">(cachedSetTimeout === setTimeout) {</span>
    <span class="s3">//normal enviroments in sane situations</span>
    <span class="s1">return </span><span class="s0">setTimeout(fun, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s3">// if setTimeout wasn't available but was latter defined</span>


  <span class="s1">if </span><span class="s0">((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {</span>
    <span class="s0">cachedSetTimeout = setTimeout;</span>
    <span class="s1">return </span><span class="s0">setTimeout(fun, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s3">// when when somebody has screwed with setTimeout but no I.E. maddness</span>
    <span class="s1">return </span><span class="s0">cachedSetTimeout(fun, </span><span class="s4">0</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
    <span class="s1">try </span><span class="s0">{</span>
      <span class="s3">// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally</span>
      <span class="s1">return </span><span class="s0">cachedSetTimeout.call(</span><span class="s1">null</span><span class="s0">, fun, </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
      <span class="s3">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error</span>
      <span class="s1">return </span><span class="s0">cachedSetTimeout.call(</span><span class="s1">this</span><span class="s0">, fun, </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">runClearTimeout(marker) {</span>
  <span class="s1">if </span><span class="s0">(cachedClearTimeout === clearTimeout) {</span>
    <span class="s3">//normal enviroments in sane situations</span>
    <span class="s1">return </span><span class="s0">clearTimeout(marker);</span>
  <span class="s0">} </span><span class="s3">// if clearTimeout wasn't available but was latter defined</span>


  <span class="s1">if </span><span class="s0">((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {</span>
    <span class="s0">cachedClearTimeout = clearTimeout;</span>
    <span class="s1">return </span><span class="s0">clearTimeout(marker);</span>
  <span class="s0">}</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s3">// when when somebody has screwed with setTimeout but no I.E. maddness</span>
    <span class="s1">return </span><span class="s0">cachedClearTimeout(marker);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
    <span class="s1">try </span><span class="s0">{</span>
      <span class="s3">// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally</span>
      <span class="s1">return </span><span class="s0">cachedClearTimeout.call(</span><span class="s1">null</span><span class="s0">, marker);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
      <span class="s3">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.</span>
      <span class="s3">// Some versions of I.E. have different rules for clearTimeout vs setTimeout</span>
      <span class="s1">return </span><span class="s0">cachedClearTimeout.call(</span><span class="s1">this</span><span class="s0">, marker);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">queue = [];</span>
<span class="s1">var </span><span class="s0">draining = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">currentQueue;</span>
<span class="s1">var </span><span class="s0">queueIndex = -</span><span class="s4">1</span><span class="s0">;</span>

<span class="s1">function </span><span class="s0">cleanUpNextTick() {</span>
  <span class="s1">if </span><span class="s0">(!draining || !currentQueue) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">draining = </span><span class="s1">false</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(currentQueue.length) {</span>
    <span class="s0">queue = currentQueue.concat(queue);</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">queueIndex = -</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(queue.length) {</span>
    <span class="s0">drainQueue();</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">drainQueue() {</span>
  <span class="s1">if </span><span class="s0">(draining) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">timeout = runTimeout(cleanUpNextTick);</span>
  <span class="s0">draining = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">len = queue.length;</span>

  <span class="s1">while </span><span class="s0">(len) {</span>
    <span class="s0">currentQueue = queue;</span>
    <span class="s0">queue = [];</span>

    <span class="s1">while </span><span class="s0">(++queueIndex &lt; len) {</span>
      <span class="s1">if </span><span class="s0">(currentQueue) {</span>
        <span class="s0">currentQueue[queueIndex].run();</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">queueIndex = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">len = queue.length;</span>
  <span class="s0">}</span>

  <span class="s0">currentQueue = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">draining = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s0">runClearTimeout(timeout);</span>
<span class="s0">}</span>

<span class="s0">process.nextTick = </span><span class="s1">function </span><span class="s0">(fun) {</span>
  <span class="s1">var </span><span class="s0">args = </span><span class="s1">new </span><span class="s0">Array(arguments.length - </span><span class="s4">1</span><span class="s0">);</span>

  <span class="s1">if </span><span class="s0">(arguments.length &gt; </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; arguments.length; i++) {</span>
      <span class="s0">args[i - </span><span class="s4">1</span><span class="s0">] = arguments[i];</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">queue.push(</span><span class="s1">new </span><span class="s0">Item(fun, args));</span>

  <span class="s1">if </span><span class="s0">(queue.length === </span><span class="s4">1 </span><span class="s0">&amp;&amp; !draining) {</span>
    <span class="s0">runTimeout(drainQueue);</span>
  <span class="s0">}</span>
<span class="s0">}; </span><span class="s3">// v8 likes predictible objects</span>


<span class="s1">function </span><span class="s0">Item(fun, array) {</span>
  <span class="s1">this</span><span class="s0">.fun = fun;</span>
  <span class="s1">this</span><span class="s0">.array = array;</span>
<span class="s0">}</span>

<span class="s0">Item.prototype.run = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">this</span><span class="s0">.fun.apply(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.array);</span>
<span class="s0">};</span>

<span class="s0">process.title = </span><span class="s2">'browser'</span><span class="s0">;</span>
<span class="s0">process.browser = </span><span class="s1">true</span><span class="s0">;</span>
<span class="s0">process.env = {};</span>
<span class="s0">process.argv = [];</span>
<span class="s0">process.version = </span><span class="s2">''</span><span class="s0">; </span><span class="s3">// empty string to avoid regexp issues</span>

<span class="s0">process.versions = {};</span>

<span class="s1">function </span><span class="s0">noop() {}</span>

<span class="s0">process.on = noop;</span>
<span class="s0">process.addListener = noop;</span>
<span class="s0">process.once = noop;</span>
<span class="s0">process.off = noop;</span>
<span class="s0">process.removeListener = noop;</span>
<span class="s0">process.removeAllListeners = noop;</span>
<span class="s0">process.emit = noop;</span>
<span class="s0">process.prependListener = noop;</span>
<span class="s0">process.prependOnceListener = noop;</span>

<span class="s0">process.listeners = </span><span class="s1">function </span><span class="s0">(name) {</span>
  <span class="s1">return </span><span class="s0">[];</span>
<span class="s0">};</span>

<span class="s0">process.binding = </span><span class="s1">function </span><span class="s0">(name) {</span>
  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'process.binding is not supported'</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">process.cwd = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s2">'/'</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">process.chdir = </span><span class="s1">function </span><span class="s0">(dir) {</span>
  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'process.chdir is not supported'</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">process.umask = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">307</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span>

<span class="s3">/* provided dependency */ </span><span class="s1">var </span><span class="s0">process = __webpack_require__(</span><span class="s4">169</span><span class="s0">);</span>
<span class="s1">if </span><span class="s0">(process.env.npm_package_name === </span><span class="s2">'pseudomap' </span><span class="s0">&amp;&amp; process.env.npm_lifecycle_script === </span><span class="s2">'test'</span><span class="s0">) process.env.TEST_PSEUDOMAP = </span><span class="s2">'true'</span><span class="s0">;</span>

<span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Map === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; !process.env.TEST_PSEUDOMAP) {</span>
  <span class="s0">module.exports = Map;</span>
<span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
  <span class="s0">module.exports = __webpack_require__(</span><span class="s4">761</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">761</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module) =&gt; {</span>

<span class="s1">var </span><span class="s0">hasOwnProperty = Object.prototype.hasOwnProperty;</span>
<span class="s0">module.exports = PseudoMap;</span>

<span class="s1">function </span><span class="s0">PseudoMap(set) {</span>
  <span class="s1">if </span><span class="s0">(!(</span><span class="s1">this instanceof </span><span class="s0">PseudoMap)) </span><span class="s3">// whyyyyyyy</span>
    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Constructor PseudoMap requires 'new'&quot;</span><span class="s0">);</span>
  <span class="s1">this</span><span class="s0">.clear();</span>

  <span class="s1">if </span><span class="s0">(set) {</span>
    <span class="s1">if </span><span class="s0">(set </span><span class="s1">instanceof </span><span class="s0">PseudoMap || </span><span class="s1">typeof </span><span class="s0">Map === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; set </span><span class="s1">instanceof </span><span class="s0">Map) set.forEach(</span><span class="s1">function </span><span class="s0">(value, key) {</span>
      <span class="s1">this</span><span class="s0">.set(key, value);</span>
    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span><span class="s1">else if </span><span class="s0">(Array.isArray(set)) set.forEach(</span><span class="s1">function </span><span class="s0">(kv) {</span>
      <span class="s1">this</span><span class="s0">.set(kv[</span><span class="s4">0</span><span class="s0">], kv[</span><span class="s4">1</span><span class="s0">]);</span>
    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span><span class="s1">else throw new </span><span class="s0">TypeError(</span><span class="s2">'invalid argument'</span><span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">PseudoMap.prototype.forEach = </span><span class="s1">function </span><span class="s0">(fn, thisp) {</span>
  <span class="s0">thisp = thisp || </span><span class="s1">this</span><span class="s0">;</span>
  <span class="s0">Object.keys(</span><span class="s1">this</span><span class="s0">._data).forEach(</span><span class="s1">function </span><span class="s0">(k) {</span>
    <span class="s1">if </span><span class="s0">(k !== </span><span class="s2">'size'</span><span class="s0">) fn.call(thisp, </span><span class="s1">this</span><span class="s0">._data[k].value, </span><span class="s1">this</span><span class="s0">._data[k].key);</span>
  <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">PseudoMap.prototype.has = </span><span class="s1">function </span><span class="s0">(k) {</span>
  <span class="s1">return </span><span class="s0">!!find(</span><span class="s1">this</span><span class="s0">._data, k);</span>
<span class="s0">};</span>

<span class="s0">PseudoMap.prototype.get = </span><span class="s1">function </span><span class="s0">(k) {</span>
  <span class="s1">var </span><span class="s0">res = find(</span><span class="s1">this</span><span class="s0">._data, k);</span>
  <span class="s1">return </span><span class="s0">res &amp;&amp; res.value;</span>
<span class="s0">};</span>

<span class="s0">PseudoMap.prototype.set = </span><span class="s1">function </span><span class="s0">(k, v) {</span>
  <span class="s0">set(</span><span class="s1">this</span><span class="s0">._data, k, v);</span>
<span class="s0">};</span>

<span class="s0">PseudoMap.prototype.</span><span class="s1">delete </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(k) {</span>
  <span class="s1">var </span><span class="s0">res = find(</span><span class="s1">this</span><span class="s0">._data, k);</span>

  <span class="s1">if </span><span class="s0">(res) {</span>
    <span class="s1">delete this</span><span class="s0">._data[res._index];</span>
    <span class="s1">this</span><span class="s0">._data.size--;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">PseudoMap.prototype.clear = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">var </span><span class="s0">data = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
  <span class="s0">data.size = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">'_data'</span><span class="s0">, {</span>
    <span class="s0">value: data,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">writable: </span><span class="s1">false</span>
  <span class="s0">});</span>
<span class="s0">};</span>

<span class="s0">Object.defineProperty(PseudoMap.prototype, </span><span class="s2">'size'</span><span class="s0">, {</span>
  <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
    <span class="s1">return this</span><span class="s0">._data.size;</span>
  <span class="s0">},</span>
  <span class="s0">set: </span><span class="s1">function </span><span class="s0">set(n) {},</span>
  <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
  <span class="s0">configurable: </span><span class="s1">true</span>
<span class="s0">});</span>

<span class="s0">PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'iterators are not implemented in this version'</span><span class="s0">);</span>
<span class="s0">}; </span><span class="s3">// Either identical, or both NaN</span>


<span class="s1">function </span><span class="s0">same(a, b) {</span>
  <span class="s1">return </span><span class="s0">a === b || a !== a &amp;&amp; b !== b;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">Entry(k, v, i) {</span>
  <span class="s1">this</span><span class="s0">.key = k;</span>
  <span class="s1">this</span><span class="s0">.value = v;</span>
  <span class="s1">this</span><span class="s0">._index = i;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">find(data, k) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, s = </span><span class="s2">'_' </span><span class="s0">+ k, key = s; hasOwnProperty.call(data, key); key = s + i++) {</span>
    <span class="s1">if </span><span class="s0">(same(data[key].key, k)) </span><span class="s1">return </span><span class="s0">data[key];</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">set(data, k, v) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, s = </span><span class="s2">'_' </span><span class="s0">+ k, key = s; hasOwnProperty.call(data, key); key = s + i++) {</span>
    <span class="s1">if </span><span class="s0">(same(data[key].key, k)) {</span>
      <span class="s0">data[key].value = v;</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">data.size++;</span>
  <span class="s0">data[key] = </span><span class="s1">new </span><span class="s0">Entry(k, v, key);</span>
<span class="s0">}</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">430</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports) {</span>

<span class="s1">var </span><span class="s0">__WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;</span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s0">(</span><span class="s1">function </span><span class="s0">(root, factory) {</span>
  <span class="s2">'use strict'</span><span class="s0">; </span><span class="s3">// Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.</span>

  <span class="s3">/* istanbul ignore next */</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
    <span class="s0">!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),</span>
		<span class="s0">__WEBPACK_AMD_DEFINE_RESULT__ = (</span><span class="s1">typeof </span><span class="s0">__WEBPACK_AMD_DEFINE_FACTORY__ === </span><span class="s2">'function' </span><span class="s0">?</span>
		<span class="s0">(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),</span>
		<span class="s0">__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{}</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s2">'use strict'</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">_isNumber(n) {</span>
    <span class="s1">return </span><span class="s0">!isNaN(parseFloat(n)) &amp;&amp; isFinite(n);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">_capitalize(str) {</span>
    <span class="s1">return </span><span class="s0">str.charAt(</span><span class="s4">0</span><span class="s0">).toUpperCase() + str.substring(</span><span class="s4">1</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">_getter(p) {</span>
    <span class="s1">return function </span><span class="s0">() {</span>
      <span class="s1">return this</span><span class="s0">[p];</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">booleanProps = [</span><span class="s2">'isConstructor'</span><span class="s0">, </span><span class="s2">'isEval'</span><span class="s0">, </span><span class="s2">'isNative'</span><span class="s0">, </span><span class="s2">'isToplevel'</span><span class="s0">];</span>
  <span class="s1">var </span><span class="s0">numericProps = [</span><span class="s2">'columnNumber'</span><span class="s0">, </span><span class="s2">'lineNumber'</span><span class="s0">];</span>
  <span class="s1">var </span><span class="s0">stringProps = [</span><span class="s2">'fileName'</span><span class="s0">, </span><span class="s2">'functionName'</span><span class="s0">, </span><span class="s2">'source'</span><span class="s0">];</span>
  <span class="s1">var </span><span class="s0">arrayProps = [</span><span class="s2">'args'</span><span class="s0">];</span>
  <span class="s1">var </span><span class="s0">props = booleanProps.concat(numericProps, stringProps, arrayProps);</span>

  <span class="s1">function </span><span class="s0">StackFrame(obj) {</span>
    <span class="s1">if </span><span class="s0">(!obj) </span><span class="s1">return</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; props.length; i++) {</span>
      <span class="s1">if </span><span class="s0">(obj[props[i]] !== undefined) {</span>
        <span class="s1">this</span><span class="s0">[</span><span class="s2">'set' </span><span class="s0">+ _capitalize(props[i])](obj[props[i]]);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">StackFrame.prototype = {</span>
    <span class="s0">getArgs: </span><span class="s1">function </span><span class="s0">getArgs() {</span>
      <span class="s1">return this</span><span class="s0">.args;</span>
    <span class="s0">},</span>
    <span class="s0">setArgs: </span><span class="s1">function </span><span class="s0">setArgs(v) {</span>
      <span class="s1">if </span><span class="s0">(Object.prototype.toString.call(v) !== </span><span class="s2">'[object Array]'</span><span class="s0">) {</span>
        <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Args must be an Array'</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s1">this</span><span class="s0">.args = v;</span>
    <span class="s0">},</span>
    <span class="s0">getEvalOrigin: </span><span class="s1">function </span><span class="s0">getEvalOrigin() {</span>
      <span class="s1">return this</span><span class="s0">.evalOrigin;</span>
    <span class="s0">},</span>
    <span class="s0">setEvalOrigin: </span><span class="s1">function </span><span class="s0">setEvalOrigin(v) {</span>
      <span class="s1">if </span><span class="s0">(v </span><span class="s1">instanceof </span><span class="s0">StackFrame) {</span>
        <span class="s1">this</span><span class="s0">.evalOrigin = v;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(v </span><span class="s1">instanceof </span><span class="s0">Object) {</span>
        <span class="s1">this</span><span class="s0">.evalOrigin = </span><span class="s1">new </span><span class="s0">StackFrame(v);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Eval Origin must be an Object or StackFrame'</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">toString: </span><span class="s1">function </span><span class="s0">toString() {</span>
      <span class="s1">var </span><span class="s0">fileName = </span><span class="s1">this</span><span class="s0">.getFileName() || </span><span class="s2">''</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">lineNumber = </span><span class="s1">this</span><span class="s0">.getLineNumber() || </span><span class="s2">''</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">columnNumber = </span><span class="s1">this</span><span class="s0">.getColumnNumber() || </span><span class="s2">''</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">functionName = </span><span class="s1">this</span><span class="s0">.getFunctionName() || </span><span class="s2">''</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.getIsEval()) {</span>
        <span class="s1">if </span><span class="s0">(fileName) {</span>
          <span class="s1">return </span><span class="s2">'[eval] (' </span><span class="s0">+ fileName + </span><span class="s2">':' </span><span class="s0">+ lineNumber + </span><span class="s2">':' </span><span class="s0">+ columnNumber + </span><span class="s2">')'</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">'[eval]:' </span><span class="s0">+ lineNumber + </span><span class="s2">':' </span><span class="s0">+ columnNumber;</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(functionName) {</span>
        <span class="s1">return </span><span class="s0">functionName + </span><span class="s2">' (' </span><span class="s0">+ fileName + </span><span class="s2">':' </span><span class="s0">+ lineNumber + </span><span class="s2">':' </span><span class="s0">+ columnNumber + </span><span class="s2">')'</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">fileName + </span><span class="s2">':' </span><span class="s0">+ lineNumber + </span><span class="s2">':' </span><span class="s0">+ columnNumber;</span>
    <span class="s0">}</span>
  <span class="s0">};</span>

  <span class="s0">StackFrame.fromString = </span><span class="s1">function </span><span class="s0">StackFrame$$fromString(str) {</span>
    <span class="s1">var </span><span class="s0">argsStartIndex = str.indexOf(</span><span class="s2">'('</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">argsEndIndex = str.lastIndexOf(</span><span class="s2">')'</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">functionName = str.substring(</span><span class="s4">0</span><span class="s0">, argsStartIndex);</span>
    <span class="s1">var </span><span class="s0">args = str.substring(argsStartIndex + </span><span class="s4">1</span><span class="s0">, argsEndIndex).split(</span><span class="s2">','</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">locationString = str.substring(argsEndIndex + </span><span class="s4">1</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(locationString.indexOf(</span><span class="s2">'@'</span><span class="s0">) === </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, </span><span class="s2">''</span><span class="s0">);</span>
      <span class="s1">var </span><span class="s0">fileName = parts[</span><span class="s4">1</span><span class="s0">];</span>
      <span class="s1">var </span><span class="s0">lineNumber = parts[</span><span class="s4">2</span><span class="s0">];</span>
      <span class="s1">var </span><span class="s0">columnNumber = parts[</span><span class="s4">3</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s1">return new </span><span class="s0">StackFrame({</span>
      <span class="s0">functionName: functionName,</span>
      <span class="s0">args: args || undefined,</span>
      <span class="s0">fileName: fileName,</span>
      <span class="s0">lineNumber: lineNumber || undefined,</span>
      <span class="s0">columnNumber: columnNumber || undefined</span>
    <span class="s0">});</span>
  <span class="s0">};</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; booleanProps.length; i++) {</span>
    <span class="s0">StackFrame.prototype[</span><span class="s2">'get' </span><span class="s0">+ _capitalize(booleanProps[i])] = _getter(booleanProps[i]);</span>

    <span class="s0">StackFrame.prototype[</span><span class="s2">'set' </span><span class="s0">+ _capitalize(booleanProps[i])] = </span><span class="s1">function </span><span class="s0">(p) {</span>
      <span class="s1">return function </span><span class="s0">(v) {</span>
        <span class="s1">this</span><span class="s0">[p] = Boolean(v);</span>
      <span class="s0">};</span>
    <span class="s0">}(booleanProps[i]);</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; numericProps.length; j++) {</span>
    <span class="s0">StackFrame.prototype[</span><span class="s2">'get' </span><span class="s0">+ _capitalize(numericProps[j])] = _getter(numericProps[j]);</span>

    <span class="s0">StackFrame.prototype[</span><span class="s2">'set' </span><span class="s0">+ _capitalize(numericProps[j])] = </span><span class="s1">function </span><span class="s0">(p) {</span>
      <span class="s1">return function </span><span class="s0">(v) {</span>
        <span class="s1">if </span><span class="s0">(!_isNumber(v)) {</span>
          <span class="s1">throw new </span><span class="s0">TypeError(p + </span><span class="s2">' must be a Number'</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">[p] = Number(v);</span>
      <span class="s0">};</span>
    <span class="s0">}(numericProps[j]);</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">k = </span><span class="s4">0</span><span class="s0">; k &lt; stringProps.length; k++) {</span>
    <span class="s0">StackFrame.prototype[</span><span class="s2">'get' </span><span class="s0">+ _capitalize(stringProps[k])] = _getter(stringProps[k]);</span>

    <span class="s0">StackFrame.prototype[</span><span class="s2">'set' </span><span class="s0">+ _capitalize(stringProps[k])] = </span><span class="s1">function </span><span class="s0">(p) {</span>
      <span class="s1">return function </span><span class="s0">(v) {</span>
        <span class="s1">this</span><span class="s0">[p] = String(v);</span>
      <span class="s0">};</span>
    <span class="s0">}(stringProps[k]);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">StackFrame;</span>
<span class="s0">});</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">718</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module) =&gt; {</span>

<span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Object.create === </span><span class="s2">'function'</span><span class="s0">) {</span>
  <span class="s3">// implementation from standard node.js 'util' module</span>
  <span class="s0">module.exports = </span><span class="s1">function </span><span class="s0">inherits(ctor, superCtor) {</span>
    <span class="s0">ctor.super_ = superCtor;</span>
    <span class="s0">ctor.prototype = Object.create(superCtor.prototype, {</span>
      <span class="s0">constructor: {</span>
        <span class="s0">value: ctor,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">};</span>
<span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
  <span class="s3">// old school shim for old browsers</span>
  <span class="s0">module.exports = </span><span class="s1">function </span><span class="s0">inherits(ctor, superCtor) {</span>
    <span class="s0">ctor.super_ = superCtor;</span>

    <span class="s1">var </span><span class="s0">TempCtor = </span><span class="s1">function </span><span class="s0">TempCtor() {};</span>

    <span class="s0">TempCtor.prototype = superCtor.prototype;</span>
    <span class="s0">ctor.prototype = </span><span class="s1">new </span><span class="s0">TempCtor();</span>
    <span class="s0">ctor.prototype.constructor = ctor;</span>
  <span class="s0">};</span>
<span class="s0">}</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">715</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module) =&gt; {</span>

<span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s0">module.exports = </span><span class="s1">function </span><span class="s0">isBuffer(arg) {</span>
  <span class="s1">return </span><span class="s0">arg &amp;&amp; _typeof(arg) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">arg.copy === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">arg.fill === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">arg.readUInt8 === </span><span class="s2">'function'</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">82</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>

<span class="s3">/* provided dependency */ </span><span class="s1">var </span><span class="s0">process = __webpack_require__(</span><span class="s4">169</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s3">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="s3">//</span>
<span class="s3">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s3">// copy of this software and associated documentation files (the</span>
<span class="s3">// &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s3">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s3">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="s3">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="s3">// following conditions:</span>
<span class="s3">//</span>
<span class="s3">// The above copyright notice and this permission notice shall be included</span>
<span class="s3">// in all copies or substantial portions of the Software.</span>
<span class="s3">//</span>
<span class="s3">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s3">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s3">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="s3">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="s3">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="s3">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="s3">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="s1">var </span><span class="s0">getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || </span><span class="s1">function </span><span class="s0">getOwnPropertyDescriptors(obj) {</span>
  <span class="s1">var </span><span class="s0">keys = Object.keys(obj);</span>
  <span class="s1">var </span><span class="s0">descriptors = {};</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; keys.length; i++) {</span>
    <span class="s0">descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">descriptors;</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">formatRegExp = /%[sdj%]/g;</span>

<span class="s0">exports.format = </span><span class="s1">function </span><span class="s0">(f) {</span>
  <span class="s1">if </span><span class="s0">(!isString(f)) {</span>
    <span class="s1">var </span><span class="s0">objects = [];</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; arguments.length; i++) {</span>
      <span class="s0">objects.push(inspect(arguments[i]));</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">objects.join(</span><span class="s2">' '</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">args = arguments;</span>
  <span class="s1">var </span><span class="s0">len = args.length;</span>
  <span class="s1">var </span><span class="s0">str = String(f).replace(formatRegExp, </span><span class="s1">function </span><span class="s0">(x) {</span>
    <span class="s1">if </span><span class="s0">(x === </span><span class="s2">'%%'</span><span class="s0">) </span><span class="s1">return </span><span class="s2">'%'</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(i &gt;= len) </span><span class="s1">return </span><span class="s0">x;</span>

    <span class="s1">switch </span><span class="s0">(x) {</span>
      <span class="s1">case </span><span class="s2">'%s'</span><span class="s0">:</span>
        <span class="s1">return </span><span class="s0">String(args[i++]);</span>

      <span class="s1">case </span><span class="s2">'%d'</span><span class="s0">:</span>
        <span class="s1">return </span><span class="s0">Number(args[i++]);</span>

      <span class="s1">case </span><span class="s2">'%j'</span><span class="s0">:</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s1">return </span><span class="s0">JSON.stringify(args[i++]);</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(_) {</span>
          <span class="s1">return </span><span class="s2">'[Circular]'</span><span class="s0">;</span>
        <span class="s0">}</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">return </span><span class="s0">x;</span>
    <span class="s0">}</span>
  <span class="s0">});</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">x = args[i]; i &lt; len; x = args[++i]) {</span>
    <span class="s1">if </span><span class="s0">(isNull(x) || !isObject(x)) {</span>
      <span class="s0">str += </span><span class="s2">' ' </span><span class="s0">+ x;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">str += </span><span class="s2">' ' </span><span class="s0">+ inspect(x);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">str;</span>
<span class="s0">}; </span><span class="s3">// Mark that a method should not be used.</span>
<span class="s3">// Returns a modified function which warns once by default.</span>
<span class="s3">// If --no-deprecation is set, then it is a no-op.</span>


<span class="s0">exports.deprecate = </span><span class="s1">function </span><span class="s0">(fn, msg) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">process !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; process.noDeprecation === </span><span class="s1">true</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">fn;</span>
  <span class="s0">} </span><span class="s3">// Allow for deprecating things in the process of starting up.</span>


  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">process === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s1">return function </span><span class="s0">() {</span>
      <span class="s1">return </span><span class="s0">exports.deprecate(fn, msg).apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">warned = </span><span class="s1">false</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">deprecated() {</span>
    <span class="s1">if </span><span class="s0">(!warned) {</span>
      <span class="s1">if </span><span class="s0">(process.throwDeprecation) {</span>
        <span class="s1">throw new </span><span class="s0">Error(msg);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(process.traceDeprecation) {</span>
        <span class="s0">console.trace(msg);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">console.error(msg);</span>
      <span class="s0">}</span>

      <span class="s0">warned = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">fn.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">deprecated;</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">debugs = {};</span>
<span class="s1">var </span><span class="s0">debugEnviron;</span>

<span class="s0">exports.debuglog = </span><span class="s1">function </span><span class="s0">(set) {</span>
  <span class="s1">if </span><span class="s0">(isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s0">set = set.toUpperCase();</span>

  <span class="s1">if </span><span class="s0">(!debugs[set]) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s2">'</span><span class="s5">\\</span><span class="s2">b' </span><span class="s0">+ set + </span><span class="s2">'</span><span class="s5">\\</span><span class="s2">b'</span><span class="s0">, </span><span class="s2">'i'</span><span class="s0">).test(debugEnviron)) {</span>
      <span class="s1">var </span><span class="s0">pid = process.pid;</span>

      <span class="s0">debugs[set] = </span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">var </span><span class="s0">msg = exports.format.apply(exports, arguments);</span>
        <span class="s0">console.error(</span><span class="s2">'%s %d: %s'</span><span class="s0">, set, pid, msg);</span>
      <span class="s0">};</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">debugs[set] = </span><span class="s1">function </span><span class="s0">() {};</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">debugs[set];</span>
<span class="s0">};</span>
<span class="s3">/** 
 * Echos the value of a value. Trys to print the value out 
 * in the best way possible given the different types. 
 * 
 * @param {Object} obj The object to print out. 
 * @param {Object} opts Optional options object that alters the output. 
 */</span>

<span class="s3">/* legacy: obj, showHidden, depth, colors*/</span>


<span class="s1">function </span><span class="s0">inspect(obj, opts) {</span>
  <span class="s3">// default options</span>
  <span class="s1">var </span><span class="s0">ctx = {</span>
    <span class="s0">seen: [],</span>
    <span class="s0">stylize: stylizeNoColor</span>
  <span class="s0">}; </span><span class="s3">// legacy...</span>

  <span class="s1">if </span><span class="s0">(arguments.length &gt;= </span><span class="s4">3</span><span class="s0">) ctx.depth = arguments[</span><span class="s4">2</span><span class="s0">];</span>
  <span class="s1">if </span><span class="s0">(arguments.length &gt;= </span><span class="s4">4</span><span class="s0">) ctx.colors = arguments[</span><span class="s4">3</span><span class="s0">];</span>

  <span class="s1">if </span><span class="s0">(isBoolean(opts)) {</span>
    <span class="s3">// legacy...</span>
    <span class="s0">ctx.showHidden = opts;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(opts) {</span>
    <span class="s3">// got an &quot;options&quot; object</span>
    <span class="s0">exports._extend(ctx, opts);</span>
  <span class="s0">} </span><span class="s3">// set default options</span>


  <span class="s1">if </span><span class="s0">(isUndefined(ctx.showHidden)) ctx.showHidden = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(isUndefined(ctx.depth)) ctx.depth = </span><span class="s4">2</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(isUndefined(ctx.colors)) ctx.colors = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(isUndefined(ctx.customInspect)) ctx.customInspect = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(ctx.colors) ctx.stylize = stylizeWithColor;</span>
  <span class="s1">return </span><span class="s0">formatValue(ctx, obj, ctx.depth);</span>
<span class="s0">}</span>

<span class="s0">exports.inspect = inspect; </span><span class="s3">// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics</span>

<span class="s0">inspect.colors = {</span>
  <span class="s2">'bold'</span><span class="s0">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">22</span><span class="s0">],</span>
  <span class="s2">'italic'</span><span class="s0">: [</span><span class="s4">3</span><span class="s0">, </span><span class="s4">23</span><span class="s0">],</span>
  <span class="s2">'underline'</span><span class="s0">: [</span><span class="s4">4</span><span class="s0">, </span><span class="s4">24</span><span class="s0">],</span>
  <span class="s2">'inverse'</span><span class="s0">: [</span><span class="s4">7</span><span class="s0">, </span><span class="s4">27</span><span class="s0">],</span>
  <span class="s2">'white'</span><span class="s0">: [</span><span class="s4">37</span><span class="s0">, </span><span class="s4">39</span><span class="s0">],</span>
  <span class="s2">'grey'</span><span class="s0">: [</span><span class="s4">90</span><span class="s0">, </span><span class="s4">39</span><span class="s0">],</span>
  <span class="s2">'black'</span><span class="s0">: [</span><span class="s4">30</span><span class="s0">, </span><span class="s4">39</span><span class="s0">],</span>
  <span class="s2">'blue'</span><span class="s0">: [</span><span class="s4">34</span><span class="s0">, </span><span class="s4">39</span><span class="s0">],</span>
  <span class="s2">'cyan'</span><span class="s0">: [</span><span class="s4">36</span><span class="s0">, </span><span class="s4">39</span><span class="s0">],</span>
  <span class="s2">'green'</span><span class="s0">: [</span><span class="s4">32</span><span class="s0">, </span><span class="s4">39</span><span class="s0">],</span>
  <span class="s2">'magenta'</span><span class="s0">: [</span><span class="s4">35</span><span class="s0">, </span><span class="s4">39</span><span class="s0">],</span>
  <span class="s2">'red'</span><span class="s0">: [</span><span class="s4">31</span><span class="s0">, </span><span class="s4">39</span><span class="s0">],</span>
  <span class="s2">'yellow'</span><span class="s0">: [</span><span class="s4">33</span><span class="s0">, </span><span class="s4">39</span><span class="s0">]</span>
<span class="s0">}; </span><span class="s3">// Don't use 'blue' not visible on cmd.exe</span>

<span class="s0">inspect.styles = {</span>
  <span class="s2">'special'</span><span class="s0">: </span><span class="s2">'cyan'</span><span class="s0">,</span>
  <span class="s2">'number'</span><span class="s0">: </span><span class="s2">'yellow'</span><span class="s0">,</span>
  <span class="s2">'boolean'</span><span class="s0">: </span><span class="s2">'yellow'</span><span class="s0">,</span>
  <span class="s2">'undefined'</span><span class="s0">: </span><span class="s2">'grey'</span><span class="s0">,</span>
  <span class="s2">'null'</span><span class="s0">: </span><span class="s2">'bold'</span><span class="s0">,</span>
  <span class="s2">'string'</span><span class="s0">: </span><span class="s2">'green'</span><span class="s0">,</span>
  <span class="s2">'date'</span><span class="s0">: </span><span class="s2">'magenta'</span><span class="s0">,</span>
  <span class="s3">// &quot;name&quot;: intentionally not styling</span>
  <span class="s2">'regexp'</span><span class="s0">: </span><span class="s2">'red'</span>
<span class="s0">};</span>

<span class="s1">function </span><span class="s0">stylizeWithColor(str, styleType) {</span>
  <span class="s1">var </span><span class="s0">style = inspect.styles[styleType];</span>

  <span class="s1">if </span><span class="s0">(style) {</span>
    <span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\x</span><span class="s2">1B[&quot; </span><span class="s0">+ inspect.colors[style][</span><span class="s4">0</span><span class="s0">] + </span><span class="s2">'m' </span><span class="s0">+ str + </span><span class="s2">&quot;</span><span class="s5">\x</span><span class="s2">1B[&quot; </span><span class="s0">+ inspect.colors[style][</span><span class="s4">1</span><span class="s0">] + </span><span class="s2">'m'</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">return </span><span class="s0">str;</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">stylizeNoColor(str, styleType) {</span>
  <span class="s1">return </span><span class="s0">str;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">arrayToHash(array) {</span>
  <span class="s1">var </span><span class="s0">hash = {};</span>
  <span class="s0">array.forEach(</span><span class="s1">function </span><span class="s0">(val, idx) {</span>
    <span class="s0">hash[val] = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">});</span>
  <span class="s1">return </span><span class="s0">hash;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">formatValue(ctx, value, recurseTimes) {</span>
  <span class="s3">// Provide a hook for user-specified inspect functions.</span>
  <span class="s3">// Check that value is an object with an inspect function on it</span>
  <span class="s1">if </span><span class="s0">(ctx.customInspect &amp;&amp; value &amp;&amp; isFunction(value.inspect) &amp;&amp; </span><span class="s3">// Filter out the util module, it's inspect function is special</span>
  <span class="s0">value.inspect !== exports.inspect &amp;&amp; </span><span class="s3">// Also filter out any prototype objects using the circular check.</span>
  <span class="s0">!(value.constructor &amp;&amp; value.constructor.prototype === value)) {</span>
    <span class="s1">var </span><span class="s0">ret = value.inspect(recurseTimes, ctx);</span>

    <span class="s1">if </span><span class="s0">(!isString(ret)) {</span>
      <span class="s0">ret = formatValue(ctx, ret, recurseTimes);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">ret;</span>
  <span class="s0">} </span><span class="s3">// Primitive types cannot have properties</span>


  <span class="s1">var </span><span class="s0">primitive = formatPrimitive(ctx, value);</span>

  <span class="s1">if </span><span class="s0">(primitive) {</span>
    <span class="s1">return </span><span class="s0">primitive;</span>
  <span class="s0">} </span><span class="s3">// Look up the keys of the object.</span>


  <span class="s1">var </span><span class="s0">keys = Object.keys(value);</span>
  <span class="s1">var </span><span class="s0">visibleKeys = arrayToHash(keys);</span>

  <span class="s1">if </span><span class="s0">(ctx.showHidden) {</span>
    <span class="s0">keys = Object.getOwnPropertyNames(value);</span>
  <span class="s0">} </span><span class="s3">// IE doesn't make error fields non-enumerable</span>
  <span class="s3">// http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx</span>


  <span class="s1">if </span><span class="s0">(isError(value) &amp;&amp; (keys.indexOf(</span><span class="s2">'message'</span><span class="s0">) &gt;= </span><span class="s4">0 </span><span class="s0">|| keys.indexOf(</span><span class="s2">'description'</span><span class="s0">) &gt;= </span><span class="s4">0</span><span class="s0">)) {</span>
    <span class="s1">return </span><span class="s0">formatError(value);</span>
  <span class="s0">} </span><span class="s3">// Some type of object without properties can be shortcutted.</span>


  <span class="s1">if </span><span class="s0">(keys.length === </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(isFunction(value)) {</span>
      <span class="s1">var </span><span class="s0">name = value.name ? </span><span class="s2">': ' </span><span class="s0">+ value.name : </span><span class="s2">''</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s0">ctx.stylize(</span><span class="s2">'[Function' </span><span class="s0">+ name + </span><span class="s2">']'</span><span class="s0">, </span><span class="s2">'special'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isRegExp(value)) {</span>
      <span class="s1">return </span><span class="s0">ctx.stylize(RegExp.prototype.toString.call(value), </span><span class="s2">'regexp'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isDate(value)) {</span>
      <span class="s1">return </span><span class="s0">ctx.stylize(Date.prototype.toString.call(value), </span><span class="s2">'date'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isError(value)) {</span>
      <span class="s1">return </span><span class="s0">formatError(value);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">base = </span><span class="s2">''</span><span class="s0">,</span>
      <span class="s0">array = </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">braces = [</span><span class="s2">'{'</span><span class="s0">, </span><span class="s2">'}'</span><span class="s0">]; </span><span class="s3">// Make Array say that they are Array</span>

  <span class="s1">if </span><span class="s0">(isArray(value)) {</span>
    <span class="s0">array = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">braces = [</span><span class="s2">'['</span><span class="s0">, </span><span class="s2">']'</span><span class="s0">];</span>
  <span class="s0">} </span><span class="s3">// Make functions say that they are functions</span>


  <span class="s1">if </span><span class="s0">(isFunction(value)) {</span>
    <span class="s1">var </span><span class="s0">n = value.name ? </span><span class="s2">': ' </span><span class="s0">+ value.name : </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">base = </span><span class="s2">' [Function' </span><span class="s0">+ n + </span><span class="s2">']'</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// Make RegExps say that they are RegExps</span>


  <span class="s1">if </span><span class="s0">(isRegExp(value)) {</span>
    <span class="s0">base = </span><span class="s2">' ' </span><span class="s0">+ RegExp.prototype.toString.call(value);</span>
  <span class="s0">} </span><span class="s3">// Make dates with properties first say the date</span>


  <span class="s1">if </span><span class="s0">(isDate(value)) {</span>
    <span class="s0">base = </span><span class="s2">' ' </span><span class="s0">+ Date.prototype.toUTCString.call(value);</span>
  <span class="s0">} </span><span class="s3">// Make error with message first say the error</span>


  <span class="s1">if </span><span class="s0">(isError(value)) {</span>
    <span class="s0">base = </span><span class="s2">' ' </span><span class="s0">+ formatError(value);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(keys.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; (!array || value.length == </span><span class="s4">0</span><span class="s0">)) {</span>
    <span class="s1">return </span><span class="s0">braces[</span><span class="s4">0</span><span class="s0">] + base + braces[</span><span class="s4">1</span><span class="s0">];</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(recurseTimes &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(isRegExp(value)) {</span>
      <span class="s1">return </span><span class="s0">ctx.stylize(RegExp.prototype.toString.call(value), </span><span class="s2">'regexp'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">return </span><span class="s0">ctx.stylize(</span><span class="s2">'[Object]'</span><span class="s0">, </span><span class="s2">'special'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">ctx.seen.push(value);</span>
  <span class="s1">var </span><span class="s0">output;</span>

  <span class="s1">if </span><span class="s0">(array) {</span>
    <span class="s0">output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">output = keys.map(</span><span class="s1">function </span><span class="s0">(key) {</span>
      <span class="s1">return </span><span class="s0">formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s0">ctx.seen.pop();</span>
  <span class="s1">return </span><span class="s0">reduceToSingleString(output, base, braces);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">formatPrimitive(ctx, value) {</span>
  <span class="s1">if </span><span class="s0">(isUndefined(value)) </span><span class="s1">return </span><span class="s0">ctx.stylize(</span><span class="s2">'undefined'</span><span class="s0">, </span><span class="s2">'undefined'</span><span class="s0">);</span>

  <span class="s1">if </span><span class="s0">(isString(value)) {</span>
    <span class="s1">var </span><span class="s0">simple = </span><span class="s2">'</span><span class="s5">\'</span><span class="s2">' </span><span class="s0">+ JSON.stringify(value).replace(/^</span><span class="s2">&quot;|&quot;</span><span class="s0">$/g, </span><span class="s2">''</span><span class="s0">).replace(/</span><span class="s2">'/g, &quot;</span><span class="s5">\\</span><span class="s2">'&quot;).replace(/</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">/g, </span><span class="s2">'&quot;'</span><span class="s0">) + </span><span class="s2">'</span><span class="s5">\'</span><span class="s2">'</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">ctx.stylize(simple, </span><span class="s2">'string'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(isNumber(value)) </span><span class="s1">return </span><span class="s0">ctx.stylize(</span><span class="s2">'' </span><span class="s0">+ value, </span><span class="s2">'number'</span><span class="s0">);</span>
  <span class="s1">if </span><span class="s0">(isBoolean(value)) </span><span class="s1">return </span><span class="s0">ctx.stylize(</span><span class="s2">'' </span><span class="s0">+ value, </span><span class="s2">'boolean'</span><span class="s0">); </span><span class="s3">// For some reason typeof null is &quot;object&quot;, so special case here.</span>

  <span class="s1">if </span><span class="s0">(isNull(value)) </span><span class="s1">return </span><span class="s0">ctx.stylize(</span><span class="s2">'null'</span><span class="s0">, </span><span class="s2">'null'</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">formatError(value) {</span>
  <span class="s1">return </span><span class="s2">'[' </span><span class="s0">+ Error.prototype.toString.call(value) + </span><span class="s2">']'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">formatArray(ctx, value, recurseTimes, visibleKeys, keys) {</span>
  <span class="s1">var </span><span class="s0">output = [];</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, l = value.length; i &lt; l; ++i) {</span>
    <span class="s1">if </span><span class="s0">(hasOwnProperty(value, String(i))) {</span>
      <span class="s0">output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), </span><span class="s1">true</span><span class="s0">));</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">output.push(</span><span class="s2">''</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">keys.forEach(</span><span class="s1">function </span><span class="s0">(key) {</span>
    <span class="s1">if </span><span class="s0">(!key.match(/^\d+$/)) {</span>
      <span class="s0">output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, </span><span class="s1">true</span><span class="s0">));</span>
    <span class="s0">}</span>
  <span class="s0">});</span>
  <span class="s1">return </span><span class="s0">output;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {</span>
  <span class="s1">var </span><span class="s0">name, str, desc;</span>
  <span class="s0">desc = Object.getOwnPropertyDescriptor(value, key) || {</span>
    <span class="s0">value: value[key]</span>
  <span class="s0">};</span>

  <span class="s1">if </span><span class="s0">(desc.get) {</span>
    <span class="s1">if </span><span class="s0">(desc.set) {</span>
      <span class="s0">str = ctx.stylize(</span><span class="s2">'[Getter/Setter]'</span><span class="s0">, </span><span class="s2">'special'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">str = ctx.stylize(</span><span class="s2">'[Getter]'</span><span class="s0">, </span><span class="s2">'special'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">if </span><span class="s0">(desc.set) {</span>
      <span class="s0">str = ctx.stylize(</span><span class="s2">'[Setter]'</span><span class="s0">, </span><span class="s2">'special'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(!hasOwnProperty(visibleKeys, key)) {</span>
    <span class="s0">name = </span><span class="s2">'[' </span><span class="s0">+ key + </span><span class="s2">']'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(!str) {</span>
    <span class="s1">if </span><span class="s0">(ctx.seen.indexOf(desc.value) &lt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(isNull(recurseTimes)) {</span>
        <span class="s0">str = formatValue(ctx, desc.value, </span><span class="s1">null</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">str = formatValue(ctx, desc.value, recurseTimes - </span><span class="s4">1</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(str.indexOf(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">) &gt; -</span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(array) {</span>
          <span class="s0">str = str.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).map(</span><span class="s1">function </span><span class="s0">(line) {</span>
            <span class="s1">return </span><span class="s2">'  ' </span><span class="s0">+ line;</span>
          <span class="s0">}).join(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).substr(</span><span class="s4">2</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s0">str = </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">' </span><span class="s0">+ str.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).map(</span><span class="s1">function </span><span class="s0">(line) {</span>
            <span class="s1">return </span><span class="s2">'   ' </span><span class="s0">+ line;</span>
          <span class="s0">}).join(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">str = ctx.stylize(</span><span class="s2">'[Circular]'</span><span class="s0">, </span><span class="s2">'special'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(isUndefined(name)) {</span>
    <span class="s1">if </span><span class="s0">(array &amp;&amp; key.match(/^\d+$/)) {</span>
      <span class="s1">return </span><span class="s0">str;</span>
    <span class="s0">}</span>

    <span class="s0">name = JSON.stringify(</span><span class="s2">'' </span><span class="s0">+ key);</span>

    <span class="s1">if </span><span class="s0">(name.match(/^</span><span class="s2">&quot;([a-zA-Z_][a-zA-Z_0-9]*)&quot;</span><span class="s0">$/)) {</span>
      <span class="s0">name = name.substr(</span><span class="s4">1</span><span class="s0">, name.length - </span><span class="s4">2</span><span class="s0">);</span>
      <span class="s0">name = ctx.stylize(name, </span><span class="s2">'name'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">name = name.replace(/</span><span class="s2">'/g, &quot;</span><span class="s5">\\</span><span class="s2">'&quot;).replace(/</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">/g, </span><span class="s2">'&quot;'</span><span class="s0">).replace(/(^</span><span class="s2">&quot;|&quot;</span><span class="s0">$)/g, </span><span class="s2">&quot;'&quot;</span><span class="s0">);</span>
      <span class="s0">name = ctx.stylize(name, </span><span class="s2">'string'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">name + </span><span class="s2">': ' </span><span class="s0">+ str;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">reduceToSingleString(output, base, braces) {</span>
  <span class="s1">var </span><span class="s0">numLinesEst = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">length = output.reduce(</span><span class="s1">function </span><span class="s0">(prev, cur) {</span>
    <span class="s0">numLinesEst++;</span>
    <span class="s1">if </span><span class="s0">(cur.indexOf(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">) &gt;= </span><span class="s4">0</span><span class="s0">) numLinesEst++;</span>
    <span class="s1">return </span><span class="s0">prev + cur.replace(/\u001b\[\d\d?m/g, </span><span class="s2">''</span><span class="s0">).length + </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">}, </span><span class="s4">0</span><span class="s0">);</span>

  <span class="s1">if </span><span class="s0">(length &gt; </span><span class="s4">60</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">braces[</span><span class="s4">0</span><span class="s0">] + (base === </span><span class="s2">'' </span><span class="s0">? </span><span class="s2">'' </span><span class="s0">: base + </span><span class="s2">'</span><span class="s5">\n </span><span class="s2">'</span><span class="s0">) + </span><span class="s2">' ' </span><span class="s0">+ output.join(</span><span class="s2">',</span><span class="s5">\n  </span><span class="s2">'</span><span class="s0">) + </span><span class="s2">' ' </span><span class="s0">+ braces[</span><span class="s4">1</span><span class="s0">];</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">braces[</span><span class="s4">0</span><span class="s0">] + base + </span><span class="s2">' ' </span><span class="s0">+ output.join(</span><span class="s2">', '</span><span class="s0">) + </span><span class="s2">' ' </span><span class="s0">+ braces[</span><span class="s4">1</span><span class="s0">];</span>
<span class="s0">} </span><span class="s3">// NOTE: These type checking functions intentionally don't use `instanceof`</span>
<span class="s3">// because it is fragile and can be easily faked with `Object.create()`.</span>


<span class="s1">function </span><span class="s0">isArray(ar) {</span>
  <span class="s1">return </span><span class="s0">Array.isArray(ar);</span>
<span class="s0">}</span>

<span class="s0">exports.isArray = isArray;</span>

<span class="s1">function </span><span class="s0">isBoolean(arg) {</span>
  <span class="s1">return typeof </span><span class="s0">arg === </span><span class="s2">'boolean'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isBoolean = isBoolean;</span>

<span class="s1">function </span><span class="s0">isNull(arg) {</span>
  <span class="s1">return </span><span class="s0">arg === </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isNull = isNull;</span>

<span class="s1">function </span><span class="s0">isNullOrUndefined(arg) {</span>
  <span class="s1">return </span><span class="s0">arg == </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isNullOrUndefined = isNullOrUndefined;</span>

<span class="s1">function </span><span class="s0">isNumber(arg) {</span>
  <span class="s1">return typeof </span><span class="s0">arg === </span><span class="s2">'number'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isNumber = isNumber;</span>

<span class="s1">function </span><span class="s0">isString(arg) {</span>
  <span class="s1">return typeof </span><span class="s0">arg === </span><span class="s2">'string'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isString = isString;</span>

<span class="s1">function </span><span class="s0">isSymbol(arg) {</span>
  <span class="s1">return </span><span class="s0">_typeof(arg) === </span><span class="s2">'symbol'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isSymbol = isSymbol;</span>

<span class="s1">function </span><span class="s0">isUndefined(arg) {</span>
  <span class="s1">return </span><span class="s0">arg === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isUndefined = isUndefined;</span>

<span class="s1">function </span><span class="s0">isRegExp(re) {</span>
  <span class="s1">return </span><span class="s0">isObject(re) &amp;&amp; objectToString(re) === </span><span class="s2">'[object RegExp]'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isRegExp = isRegExp;</span>

<span class="s1">function </span><span class="s0">isObject(arg) {</span>
  <span class="s1">return </span><span class="s0">_typeof(arg) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; arg !== </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isObject = isObject;</span>

<span class="s1">function </span><span class="s0">isDate(d) {</span>
  <span class="s1">return </span><span class="s0">isObject(d) &amp;&amp; objectToString(d) === </span><span class="s2">'[object Date]'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isDate = isDate;</span>

<span class="s1">function </span><span class="s0">isError(e) {</span>
  <span class="s1">return </span><span class="s0">isObject(e) &amp;&amp; (objectToString(e) === </span><span class="s2">'[object Error]' </span><span class="s0">|| e </span><span class="s1">instanceof </span><span class="s0">Error);</span>
<span class="s0">}</span>

<span class="s0">exports.isError = isError;</span>

<span class="s1">function </span><span class="s0">isFunction(arg) {</span>
  <span class="s1">return typeof </span><span class="s0">arg === </span><span class="s2">'function'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isFunction = isFunction;</span>

<span class="s1">function </span><span class="s0">isPrimitive(arg) {</span>
  <span class="s1">return </span><span class="s0">arg === </span><span class="s1">null </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">arg === </span><span class="s2">'boolean' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">arg === </span><span class="s2">'number' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">arg === </span><span class="s2">'string' </span><span class="s0">|| _typeof(arg) === </span><span class="s2">'symbol' </span><span class="s0">|| </span><span class="s3">// ES6 symbol</span>
  <span class="s1">typeof </span><span class="s0">arg === </span><span class="s2">'undefined'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">exports.isPrimitive = isPrimitive;</span>
<span class="s0">exports.isBuffer = __webpack_require__(</span><span class="s4">715</span><span class="s0">);</span>

<span class="s1">function </span><span class="s0">objectToString(o) {</span>
  <span class="s1">return </span><span class="s0">Object.prototype.toString.call(o);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">pad(n) {</span>
  <span class="s1">return </span><span class="s0">n &lt; </span><span class="s4">10 </span><span class="s0">? </span><span class="s2">'0' </span><span class="s0">+ n.toString(</span><span class="s4">10</span><span class="s0">) : n.toString(</span><span class="s4">10</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">months = [</span><span class="s2">'Jan'</span><span class="s0">, </span><span class="s2">'Feb'</span><span class="s0">, </span><span class="s2">'Mar'</span><span class="s0">, </span><span class="s2">'Apr'</span><span class="s0">, </span><span class="s2">'May'</span><span class="s0">, </span><span class="s2">'Jun'</span><span class="s0">, </span><span class="s2">'Jul'</span><span class="s0">, </span><span class="s2">'Aug'</span><span class="s0">, </span><span class="s2">'Sep'</span><span class="s0">, </span><span class="s2">'Oct'</span><span class="s0">, </span><span class="s2">'Nov'</span><span class="s0">, </span><span class="s2">'Dec'</span><span class="s0">]; </span><span class="s3">// 26 Feb 16:19:34</span>

<span class="s1">function </span><span class="s0">timestamp() {</span>
  <span class="s1">var </span><span class="s0">d = </span><span class="s1">new </span><span class="s0">Date();</span>
  <span class="s1">var </span><span class="s0">time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(</span><span class="s2">':'</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">[d.getDate(), months[d.getMonth()], time].join(</span><span class="s2">' '</span><span class="s0">);</span>
<span class="s0">} </span><span class="s3">// log is just a thin wrapper to console.log that prepends a timestamp</span>


<span class="s0">exports.log = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s0">console.log(</span><span class="s2">'%s - %s'</span><span class="s0">, timestamp(), exports.format.apply(exports, arguments));</span>
<span class="s0">};</span>
<span class="s3">/** 
 * Inherit the prototype methods from one constructor into another. 
 * 
 * The Function.prototype.inherits from lang.js rewritten as a standalone 
 * function (not on Function.prototype). NOTE: If this file is to be loaded 
 * during bootstrapping this function needs to be rewritten using some native 
 * functions as prototype setup using normal JavaScript does not work as 
 * expected during bootstrapping (see mirror.js in r114903). 
 * 
 * @param {function} ctor Constructor function which needs to inherit the 
 *     prototype. 
 * @param {function} superCtor Constructor function to inherit prototype from. 
 */</span>


<span class="s0">exports.inherits = __webpack_require__(</span><span class="s4">718</span><span class="s0">);</span>

<span class="s0">exports._extend = </span><span class="s1">function </span><span class="s0">(origin, add) {</span>
  <span class="s3">// Don't do anything if add isn't an object</span>
  <span class="s1">if </span><span class="s0">(!add || !isObject(add)) </span><span class="s1">return </span><span class="s0">origin;</span>
  <span class="s1">var </span><span class="s0">keys = Object.keys(add);</span>
  <span class="s1">var </span><span class="s0">i = keys.length;</span>

  <span class="s1">while </span><span class="s0">(i--) {</span>
    <span class="s0">origin[keys[i]] = add[keys[i]];</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">origin;</span>
<span class="s0">};</span>

<span class="s1">function </span><span class="s0">hasOwnProperty(obj, prop) {</span>
  <span class="s1">return </span><span class="s0">Object.prototype.hasOwnProperty.call(obj, prop);</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">kCustomPromisifiedSymbol = </span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">'undefined' </span><span class="s0">? Symbol(</span><span class="s2">'util.promisify.custom'</span><span class="s0">) : undefined;</span>

<span class="s0">exports.promisify = </span><span class="s1">function </span><span class="s0">promisify(original) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">original !== </span><span class="s2">'function'</span><span class="s0">) </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'The &quot;original&quot; argument must be of type Function'</span><span class="s0">);</span>

  <span class="s1">if </span><span class="s0">(kCustomPromisifiedSymbol &amp;&amp; original[kCustomPromisifiedSymbol]) {</span>
    <span class="s1">var </span><span class="s0">fn = original[kCustomPromisifiedSymbol];</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">fn !== </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'The &quot;util.promisify.custom&quot; argument must be of type Function'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">Object.defineProperty(fn, kCustomPromisifiedSymbol, {</span>
      <span class="s0">value: fn,</span>
      <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">writable: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">fn;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">fn() {</span>
    <span class="s1">var </span><span class="s0">promiseResolve, promiseReject;</span>
    <span class="s1">var </span><span class="s0">promise = </span><span class="s1">new </span><span class="s0">Promise(</span><span class="s1">function </span><span class="s0">(resolve, reject) {</span>
      <span class="s0">promiseResolve = resolve;</span>
      <span class="s0">promiseReject = reject;</span>
    <span class="s0">});</span>
    <span class="s1">var </span><span class="s0">args = [];</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; arguments.length; i++) {</span>
      <span class="s0">args.push(arguments[i]);</span>
    <span class="s0">}</span>

    <span class="s0">args.push(</span><span class="s1">function </span><span class="s0">(err, value) {</span>
      <span class="s1">if </span><span class="s0">(err) {</span>
        <span class="s0">promiseReject(err);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">promiseResolve(value);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s0">original.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
      <span class="s0">promiseReject(err);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">promise;</span>
  <span class="s0">}</span>

  <span class="s0">Object.setPrototypeOf(fn, Object.getPrototypeOf(original));</span>
  <span class="s1">if </span><span class="s0">(kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {</span>
    <span class="s0">value: fn,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">writable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">configurable: </span><span class="s1">true</span>
  <span class="s0">});</span>
  <span class="s1">return </span><span class="s0">Object.defineProperties(fn, getOwnPropertyDescriptors(original));</span>
<span class="s0">};</span>

<span class="s0">exports.promisify.custom = kCustomPromisifiedSymbol;</span>

<span class="s1">function </span><span class="s0">callbackifyOnRejected(reason, cb) {</span>
  <span class="s3">// `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).</span>
  <span class="s3">// Because `null` is a special error value in callbacks which means &quot;no error</span>
  <span class="s3">// occurred&quot;, we error-wrap so the callback consumer can distinguish between</span>
  <span class="s3">// &quot;the promise rejected with null&quot; or &quot;the promise fulfilled with undefined&quot;.</span>
  <span class="s1">if </span><span class="s0">(!reason) {</span>
    <span class="s1">var </span><span class="s0">newReason = </span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Promise was rejected with a falsy value'</span><span class="s0">);</span>
    <span class="s0">newReason.reason = reason;</span>
    <span class="s0">reason = newReason;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">cb(reason);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">callbackify(original) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">original !== </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'The &quot;original&quot; argument must be of type Function'</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s3">// We DO NOT return the promise as it gives the user a false sense that</span>
  <span class="s3">// the promise is actually somehow related to the callback's execution</span>
  <span class="s3">// and that the callback throwing will reject the promise.</span>


  <span class="s1">function </span><span class="s0">callbackified() {</span>
    <span class="s1">var </span><span class="s0">args = [];</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; arguments.length; i++) {</span>
      <span class="s0">args.push(arguments[i]);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">maybeCb = args.pop();</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">maybeCb !== </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'The last argument must be of type Function'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>

    <span class="s1">var </span><span class="s0">cb = </span><span class="s1">function </span><span class="s0">cb() {</span>
      <span class="s1">return </span><span class="s0">maybeCb.apply(self, arguments);</span>
    <span class="s0">}; </span><span class="s3">// In true node style we process the callback on `nextTick` with all the</span>
    <span class="s3">// implications (stack, `uncaughtException`, `async_hooks`)</span>


    <span class="s0">original.apply(</span><span class="s1">this</span><span class="s0">, args).then(</span><span class="s1">function </span><span class="s0">(ret) {</span>
      <span class="s0">process.nextTick(cb, </span><span class="s1">null</span><span class="s0">, ret);</span>
    <span class="s0">}, </span><span class="s1">function </span><span class="s0">(rej) {</span>
      <span class="s0">process.nextTick(callbackifyOnRejected, rej, cb);</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s0">Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));</span>
  <span class="s0">Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));</span>
  <span class="s1">return </span><span class="s0">callbackified;</span>
<span class="s0">}</span>

<span class="s0">exports.callbackify = callbackify;</span>

<span class="s3">/***/ </span><span class="s0">}),</span>

<span class="s3">/***/ </span><span class="s4">695</span><span class="s0">:</span>
<span class="s3">/***/ </span><span class="s0">((module) =&gt; {</span>

<span class="s0">module.exports = Yallist;</span>
<span class="s0">Yallist.Node = Node;</span>
<span class="s0">Yallist.create = Yallist;</span>

<span class="s1">function </span><span class="s0">Yallist(list) {</span>
  <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(!(self </span><span class="s1">instanceof </span><span class="s0">Yallist)) {</span>
    <span class="s0">self = </span><span class="s1">new </span><span class="s0">Yallist();</span>
  <span class="s0">}</span>

  <span class="s0">self.tail = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">self.head = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">self.length = </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(list &amp;&amp; </span><span class="s1">typeof </span><span class="s0">list.forEach === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s0">list.forEach(</span><span class="s1">function </span><span class="s0">(item) {</span>
      <span class="s0">self.push(item);</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(arguments.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, l = arguments.length; i &lt; l; i++) {</span>
      <span class="s0">self.push(arguments[i]);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">}</span>

<span class="s0">Yallist.prototype.removeNode = </span><span class="s1">function </span><span class="s0">(node) {</span>
  <span class="s1">if </span><span class="s0">(node.list !== </span><span class="s1">this</span><span class="s0">) {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'removing node which does not belong to this list'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">next = node.next;</span>
  <span class="s1">var </span><span class="s0">prev = node.prev;</span>

  <span class="s1">if </span><span class="s0">(next) {</span>
    <span class="s0">next.prev = prev;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(prev) {</span>
    <span class="s0">prev.next = next;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(node === </span><span class="s1">this</span><span class="s0">.head) {</span>
    <span class="s1">this</span><span class="s0">.head = next;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(node === </span><span class="s1">this</span><span class="s0">.tail) {</span>
    <span class="s1">this</span><span class="s0">.tail = prev;</span>
  <span class="s0">}</span>

  <span class="s0">node.list.length--;</span>
  <span class="s0">node.next = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">node.prev = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">node.list = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.unshiftNode = </span><span class="s1">function </span><span class="s0">(node) {</span>
  <span class="s1">if </span><span class="s0">(node === </span><span class="s1">this</span><span class="s0">.head) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(node.list) {</span>
    <span class="s0">node.list.removeNode(node);</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">head = </span><span class="s1">this</span><span class="s0">.head;</span>
  <span class="s0">node.list = </span><span class="s1">this</span><span class="s0">;</span>
  <span class="s0">node.next = head;</span>

  <span class="s1">if </span><span class="s0">(head) {</span>
    <span class="s0">head.prev = node;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.head = node;</span>

  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.tail) {</span>
    <span class="s1">this</span><span class="s0">.tail = node;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.length++;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.pushNode = </span><span class="s1">function </span><span class="s0">(node) {</span>
  <span class="s1">if </span><span class="s0">(node === </span><span class="s1">this</span><span class="s0">.tail) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(node.list) {</span>
    <span class="s0">node.list.removeNode(node);</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">tail = </span><span class="s1">this</span><span class="s0">.tail;</span>
  <span class="s0">node.list = </span><span class="s1">this</span><span class="s0">;</span>
  <span class="s0">node.prev = tail;</span>

  <span class="s1">if </span><span class="s0">(tail) {</span>
    <span class="s0">tail.next = node;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.tail = node;</span>

  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.head) {</span>
    <span class="s1">this</span><span class="s0">.head = node;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.length++;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.push = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, l = arguments.length; i &lt; l; i++) {</span>
    <span class="s0">push(</span><span class="s1">this</span><span class="s0">, arguments[i]);</span>
  <span class="s0">}</span>

  <span class="s1">return this</span><span class="s0">.length;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.unshift = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, l = arguments.length; i &lt; l; i++) {</span>
    <span class="s0">unshift(</span><span class="s1">this</span><span class="s0">, arguments[i]);</span>
  <span class="s0">}</span>

  <span class="s1">return this</span><span class="s0">.length;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.pop = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.tail) {</span>
    <span class="s1">return </span><span class="s0">undefined;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">res = </span><span class="s1">this</span><span class="s0">.tail.value;</span>
  <span class="s1">this</span><span class="s0">.tail = </span><span class="s1">this</span><span class="s0">.tail.prev;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tail) {</span>
    <span class="s1">this</span><span class="s0">.tail.next = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">this</span><span class="s0">.head = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.length--;</span>
  <span class="s1">return </span><span class="s0">res;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.shift = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.head) {</span>
    <span class="s1">return </span><span class="s0">undefined;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">res = </span><span class="s1">this</span><span class="s0">.head.value;</span>
  <span class="s1">this</span><span class="s0">.head = </span><span class="s1">this</span><span class="s0">.head.next;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.head) {</span>
    <span class="s1">this</span><span class="s0">.head.prev = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">this</span><span class="s0">.tail = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.length--;</span>
  <span class="s1">return </span><span class="s0">res;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.forEach = </span><span class="s1">function </span><span class="s0">(fn, thisp) {</span>
  <span class="s0">thisp = thisp || </span><span class="s1">this</span><span class="s0">;</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">walker = </span><span class="s1">this</span><span class="s0">.head, i = </span><span class="s4">0</span><span class="s0">; walker !== </span><span class="s1">null</span><span class="s0">; i++) {</span>
    <span class="s0">fn.call(thisp, walker.value, i, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">walker = walker.next;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.forEachReverse = </span><span class="s1">function </span><span class="s0">(fn, thisp) {</span>
  <span class="s0">thisp = thisp || </span><span class="s1">this</span><span class="s0">;</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">walker = </span><span class="s1">this</span><span class="s0">.tail, i = </span><span class="s1">this</span><span class="s0">.length - </span><span class="s4">1</span><span class="s0">; walker !== </span><span class="s1">null</span><span class="s0">; i--) {</span>
    <span class="s0">fn.call(thisp, walker.value, i, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">walker = walker.prev;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.get = </span><span class="s1">function </span><span class="s0">(n) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, walker = </span><span class="s1">this</span><span class="s0">.head; walker !== </span><span class="s1">null </span><span class="s0">&amp;&amp; i &lt; n; i++) {</span>
    <span class="s3">// abort out of the list early if we hit a cycle</span>
    <span class="s0">walker = walker.next;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(i === n &amp;&amp; walker !== </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">walker.value;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.getReverse = </span><span class="s1">function </span><span class="s0">(n) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, walker = </span><span class="s1">this</span><span class="s0">.tail; walker !== </span><span class="s1">null </span><span class="s0">&amp;&amp; i &lt; n; i++) {</span>
    <span class="s3">// abort out of the list early if we hit a cycle</span>
    <span class="s0">walker = walker.prev;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(i === n &amp;&amp; walker !== </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">walker.value;</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.map = </span><span class="s1">function </span><span class="s0">(fn, thisp) {</span>
  <span class="s0">thisp = thisp || </span><span class="s1">this</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">res = </span><span class="s1">new </span><span class="s0">Yallist();</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">walker = </span><span class="s1">this</span><span class="s0">.head; walker !== </span><span class="s1">null</span><span class="s0">;) {</span>
    <span class="s0">res.push(fn.call(thisp, walker.value, </span><span class="s1">this</span><span class="s0">));</span>
    <span class="s0">walker = walker.next;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">res;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.mapReverse = </span><span class="s1">function </span><span class="s0">(fn, thisp) {</span>
  <span class="s0">thisp = thisp || </span><span class="s1">this</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">res = </span><span class="s1">new </span><span class="s0">Yallist();</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">walker = </span><span class="s1">this</span><span class="s0">.tail; walker !== </span><span class="s1">null</span><span class="s0">;) {</span>
    <span class="s0">res.push(fn.call(thisp, walker.value, </span><span class="s1">this</span><span class="s0">));</span>
    <span class="s0">walker = walker.prev;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">res;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.reduce = </span><span class="s1">function </span><span class="s0">(fn, initial) {</span>
  <span class="s1">var </span><span class="s0">acc;</span>
  <span class="s1">var </span><span class="s0">walker = </span><span class="s1">this</span><span class="s0">.head;</span>

  <span class="s1">if </span><span class="s0">(arguments.length &gt; </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">acc = initial;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.head) {</span>
    <span class="s0">walker = </span><span class="s1">this</span><span class="s0">.head.next;</span>
    <span class="s0">acc = </span><span class="s1">this</span><span class="s0">.head.value;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Reduce of empty list with no initial value'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; walker !== </span><span class="s1">null</span><span class="s0">; i++) {</span>
    <span class="s0">acc = fn(acc, walker.value, i);</span>
    <span class="s0">walker = walker.next;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">acc;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.reduceReverse = </span><span class="s1">function </span><span class="s0">(fn, initial) {</span>
  <span class="s1">var </span><span class="s0">acc;</span>
  <span class="s1">var </span><span class="s0">walker = </span><span class="s1">this</span><span class="s0">.tail;</span>

  <span class="s1">if </span><span class="s0">(arguments.length &gt; </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">acc = initial;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tail) {</span>
    <span class="s0">walker = </span><span class="s1">this</span><span class="s0">.tail.prev;</span>
    <span class="s0">acc = </span><span class="s1">this</span><span class="s0">.tail.value;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Reduce of empty list with no initial value'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s1">this</span><span class="s0">.length - </span><span class="s4">1</span><span class="s0">; walker !== </span><span class="s1">null</span><span class="s0">; i--) {</span>
    <span class="s0">acc = fn(acc, walker.value, i);</span>
    <span class="s0">walker = walker.prev;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">acc;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.toArray = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">var </span><span class="s0">arr = </span><span class="s1">new </span><span class="s0">Array(</span><span class="s1">this</span><span class="s0">.length);</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, walker = </span><span class="s1">this</span><span class="s0">.head; walker !== </span><span class="s1">null</span><span class="s0">; i++) {</span>
    <span class="s0">arr[i] = walker.value;</span>
    <span class="s0">walker = walker.next;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">arr;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.toArrayReverse = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">var </span><span class="s0">arr = </span><span class="s1">new </span><span class="s0">Array(</span><span class="s1">this</span><span class="s0">.length);</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, walker = </span><span class="s1">this</span><span class="s0">.tail; walker !== </span><span class="s1">null</span><span class="s0">; i++) {</span>
    <span class="s0">arr[i] = walker.value;</span>
    <span class="s0">walker = walker.prev;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">arr;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.slice = </span><span class="s1">function </span><span class="s0">(from, to) {</span>
  <span class="s0">to = to || </span><span class="s1">this</span><span class="s0">.length;</span>

  <span class="s1">if </span><span class="s0">(to &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">to += </span><span class="s1">this</span><span class="s0">.length;</span>
  <span class="s0">}</span>

  <span class="s0">from = from || </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(from &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">from += </span><span class="s1">this</span><span class="s0">.length;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">ret = </span><span class="s1">new </span><span class="s0">Yallist();</span>

  <span class="s1">if </span><span class="s0">(to &lt; from || to &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">ret;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(from &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">from = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(to &gt; </span><span class="s1">this</span><span class="s0">.length) {</span>
    <span class="s0">to = </span><span class="s1">this</span><span class="s0">.length;</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, walker = </span><span class="s1">this</span><span class="s0">.head; walker !== </span><span class="s1">null </span><span class="s0">&amp;&amp; i &lt; from; i++) {</span>
    <span class="s0">walker = walker.next;</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(; walker !== </span><span class="s1">null </span><span class="s0">&amp;&amp; i &lt; to; i++, walker = walker.next) {</span>
    <span class="s0">ret.push(walker.value);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">ret;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.sliceReverse = </span><span class="s1">function </span><span class="s0">(from, to) {</span>
  <span class="s0">to = to || </span><span class="s1">this</span><span class="s0">.length;</span>

  <span class="s1">if </span><span class="s0">(to &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">to += </span><span class="s1">this</span><span class="s0">.length;</span>
  <span class="s0">}</span>

  <span class="s0">from = from || </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(from &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">from += </span><span class="s1">this</span><span class="s0">.length;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">ret = </span><span class="s1">new </span><span class="s0">Yallist();</span>

  <span class="s1">if </span><span class="s0">(to &lt; from || to &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">ret;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(from &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">from = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(to &gt; </span><span class="s1">this</span><span class="s0">.length) {</span>
    <span class="s0">to = </span><span class="s1">this</span><span class="s0">.length;</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s1">this</span><span class="s0">.length, walker = </span><span class="s1">this</span><span class="s0">.tail; walker !== </span><span class="s1">null </span><span class="s0">&amp;&amp; i &gt; to; i--) {</span>
    <span class="s0">walker = walker.prev;</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(; walker !== </span><span class="s1">null </span><span class="s0">&amp;&amp; i &gt; from; i--, walker = walker.prev) {</span>
    <span class="s0">ret.push(walker.value);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">ret;</span>
<span class="s0">};</span>

<span class="s0">Yallist.prototype.reverse = </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">var </span><span class="s0">head = </span><span class="s1">this</span><span class="s0">.head;</span>
  <span class="s1">var </span><span class="s0">tail = </span><span class="s1">this</span><span class="s0">.tail;</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">walker = head; walker !== </span><span class="s1">null</span><span class="s0">; walker = walker.prev) {</span>
    <span class="s1">var </span><span class="s0">p = walker.prev;</span>
    <span class="s0">walker.prev = walker.next;</span>
    <span class="s0">walker.next = p;</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.head = tail;</span>
  <span class="s1">this</span><span class="s0">.tail = head;</span>
  <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s1">function </span><span class="s0">push(self, item) {</span>
  <span class="s0">self.tail = </span><span class="s1">new </span><span class="s0">Node(item, self.tail, </span><span class="s1">null</span><span class="s0">, self);</span>

  <span class="s1">if </span><span class="s0">(!self.head) {</span>
    <span class="s0">self.head = self.tail;</span>
  <span class="s0">}</span>

  <span class="s0">self.length++;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">unshift(self, item) {</span>
  <span class="s0">self.head = </span><span class="s1">new </span><span class="s0">Node(item, </span><span class="s1">null</span><span class="s0">, self.head, self);</span>

  <span class="s1">if </span><span class="s0">(!self.tail) {</span>
    <span class="s0">self.tail = self.head;</span>
  <span class="s0">}</span>

  <span class="s0">self.length++;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">Node(value, prev, next, list) {</span>
  <span class="s1">if </span><span class="s0">(!(</span><span class="s1">this instanceof </span><span class="s0">Node)) {</span>
    <span class="s1">return new </span><span class="s0">Node(value, prev, next, list);</span>
  <span class="s0">}</span>

  <span class="s1">this</span><span class="s0">.list = list;</span>
  <span class="s1">this</span><span class="s0">.value = value;</span>

  <span class="s1">if </span><span class="s0">(prev) {</span>
    <span class="s0">prev.next = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.prev = prev;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">this</span><span class="s0">.prev = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(next) {</span>
    <span class="s0">next.prev = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.next = next;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">this</span><span class="s0">.next = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">/***/ </span><span class="s0">})</span>

<span class="s3">/******/ 	</span><span class="s0">});</span>
<span class="s3">/************************************************************************/</span>
<span class="s3">/******/ 	// The module cache</span>
<span class="s3">/******/ 	</span><span class="s1">var </span><span class="s0">__webpack_module_cache__ = {};</span>
<span class="s3">/******/ 	</span>
<span class="s3">/******/ 	// The require function</span>
<span class="s3">/******/ 	</span><span class="s1">function </span><span class="s0">__webpack_require__(moduleId) {</span>
<span class="s3">/******/ 		// Check if module is in cache</span>
<span class="s3">/******/ 		</span><span class="s1">var </span><span class="s0">cachedModule = __webpack_module_cache__[moduleId];</span>
<span class="s3">/******/ 		</span><span class="s1">if </span><span class="s0">(cachedModule !== undefined) {</span>
<span class="s3">/******/ 			</span><span class="s1">return </span><span class="s0">cachedModule.exports;</span>
<span class="s3">/******/ 		</span><span class="s0">}</span>
<span class="s3">/******/ 		// Create a new module (and put it into the cache)</span>
<span class="s3">/******/ 		</span><span class="s1">var </span><span class="s0">module = __webpack_module_cache__[moduleId] = {</span>
<span class="s3">/******/ 			// no module.id needed</span>
<span class="s3">/******/ 			// no module.loaded needed</span>
<span class="s3">/******/ 			</span><span class="s0">exports: {}</span>
<span class="s3">/******/ 		</span><span class="s0">};</span>
<span class="s3">/******/ 	</span>
<span class="s3">/******/ 		// Execute the module function</span>
<span class="s3">/******/ 		</span><span class="s0">__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span>
<span class="s3">/******/ 	</span>
<span class="s3">/******/ 		// Return the exports of the module</span>
<span class="s3">/******/ 		</span><span class="s1">return </span><span class="s0">module.exports;</span>
<span class="s3">/******/ 	</span><span class="s0">}</span>
<span class="s3">/******/ 	</span>
<span class="s3">/************************************************************************/</span>
<span class="s3">/******/ 	/* webpack/runtime/compat get default export */</span>
<span class="s3">/******/ 	</span><span class="s0">(() =&gt; {</span>
<span class="s3">/******/ 		// getDefaultExport function for compatibility with non-harmony modules</span>
<span class="s3">/******/ 		</span><span class="s0">__webpack_require__.n = (module) =&gt; {</span>
<span class="s3">/******/ 			</span><span class="s1">var </span><span class="s0">getter = module &amp;&amp; module.__esModule ?</span>
<span class="s3">/******/ 				</span><span class="s0">() =&gt; (module[</span><span class="s2">'default'</span><span class="s0">]) :</span>
<span class="s3">/******/ 				</span><span class="s0">() =&gt; (module);</span>
<span class="s3">/******/ 			</span><span class="s0">__webpack_require__.d(getter, { a: getter });</span>
<span class="s3">/******/ 			</span><span class="s1">return </span><span class="s0">getter;</span>
<span class="s3">/******/ 		</span><span class="s0">};</span>
<span class="s3">/******/ 	</span><span class="s0">})();</span>
<span class="s3">/******/ 	</span>
<span class="s3">/******/ 	/* webpack/runtime/define property getters */</span>
<span class="s3">/******/ 	</span><span class="s0">(() =&gt; {</span>
<span class="s3">/******/ 		// define getter functions for harmony exports</span>
<span class="s3">/******/ 		</span><span class="s0">__webpack_require__.d = (exports, definition) =&gt; {</span>
<span class="s3">/******/ 			</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">key </span><span class="s1">in </span><span class="s0">definition) {</span>
<span class="s3">/******/ 				</span><span class="s1">if</span><span class="s0">(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) {</span>
<span class="s3">/******/ 					</span><span class="s0">Object.defineProperty(exports, key, { enumerable: </span><span class="s1">true</span><span class="s0">, get: definition[key] });</span>
<span class="s3">/******/ 				</span><span class="s0">}</span>
<span class="s3">/******/ 			</span><span class="s0">}</span>
<span class="s3">/******/ 		</span><span class="s0">};</span>
<span class="s3">/******/ 	</span><span class="s0">})();</span>
<span class="s3">/******/ 	</span>
<span class="s3">/******/ 	/* webpack/runtime/hasOwnProperty shorthand */</span>
<span class="s3">/******/ 	</span><span class="s0">(() =&gt; {</span>
<span class="s3">/******/ 		</span><span class="s0">__webpack_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop))</span>
<span class="s3">/******/ 	</span><span class="s0">})();</span>
<span class="s3">/******/ 	</span>
<span class="s3">/******/ 	/* webpack/runtime/make namespace object */</span>
<span class="s3">/******/ 	</span><span class="s0">(() =&gt; {</span>
<span class="s3">/******/ 		// define __esModule on exports</span>
<span class="s3">/******/ 		</span><span class="s0">__webpack_require__.r = (exports) =&gt; {</span>
<span class="s3">/******/ 			</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; Symbol.toStringTag) {</span>
<span class="s3">/******/ 				</span><span class="s0">Object.defineProperty(exports, Symbol.toStringTag, { value: </span><span class="s2">'Module' </span><span class="s0">});</span>
<span class="s3">/******/ 			</span><span class="s0">}</span>
<span class="s3">/******/ 			</span><span class="s0">Object.defineProperty(exports, </span><span class="s2">'__esModule'</span><span class="s0">, { value: </span><span class="s1">true </span><span class="s0">});</span>
<span class="s3">/******/ 		</span><span class="s0">};</span>
<span class="s3">/******/ 	</span><span class="s0">})();</span>
<span class="s3">/******/ 	</span>
<span class="s3">/************************************************************************/</span>
<span class="s1">var </span><span class="s0">__webpack_exports__ = {};</span>
<span class="s3">// This entry need to be wrapped in an IIFE because it need to be in strict mode.</span>
<span class="s0">(() =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s3">// ESM COMPAT FLAG</span>
<span class="s0">__webpack_require__.r(__webpack_exports__);</span>

<span class="s3">// EXPORTS</span>
<span class="s0">__webpack_require__.d(__webpack_exports__, {</span>
  <span class="s2">&quot;connectToDevTools&quot;</span><span class="s0">: () =&gt; (</span><span class="s3">/* binding */ </span><span class="s0">connectToDevTools)</span>
<span class="s0">});</span>

<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/events.js</span>
<span class="s1">function </span><span class="s0">_classCallCheck(instance, Constructor) { </span><span class="s1">if </span><span class="s0">(!(instance </span><span class="s1">instanceof </span><span class="s0">Constructor)) { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Cannot call a class as a function&quot;</span><span class="s0">); } }</span>

<span class="s1">function </span><span class="s0">_defineProperties(target, props) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; props.length; i++) { </span><span class="s1">var </span><span class="s0">descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || </span><span class="s1">false</span><span class="s0">; descriptor.configurable = </span><span class="s1">true</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;value&quot; </span><span class="s1">in </span><span class="s0">descriptor) descriptor.writable = </span><span class="s1">true</span><span class="s0">; Object.defineProperty(target, descriptor.key, descriptor); } }</span>

<span class="s1">function </span><span class="s0">_createClass(Constructor, protoProps, staticProps) { </span><span class="s1">if </span><span class="s0">(protoProps) _defineProperties(Constructor.prototype, protoProps); </span><span class="s1">if </span><span class="s0">(staticProps) _defineProperties(Constructor, staticProps); </span><span class="s1">return </span><span class="s0">Constructor; }</span>

<span class="s1">function </span><span class="s0">_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s1">var </span><span class="s0">EventEmitter = </span><span class="s3">/*#__PURE__*/</span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">function </span><span class="s0">EventEmitter() {</span>
    <span class="s0">_classCallCheck(</span><span class="s1">this</span><span class="s0">, EventEmitter);</span>

    <span class="s0">_defineProperty(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">&quot;listenersMap&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">Map());</span>
  <span class="s0">}</span>

  <span class="s0">_createClass(EventEmitter, [{</span>
    <span class="s0">key: </span><span class="s2">&quot;addListener&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">addListener(event, listener) {</span>
      <span class="s1">var </span><span class="s0">listeners = </span><span class="s1">this</span><span class="s0">.listenersMap.get(event);</span>

      <span class="s1">if </span><span class="s0">(listeners === undefined) {</span>
        <span class="s1">this</span><span class="s0">.listenersMap.set(event, [listener]);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">index = listeners.indexOf(listener);</span>

        <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s4">0</span><span class="s0">) {</span>
          <span class="s0">listeners.push(listener);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;emit&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">emit(event) {</span>
      <span class="s1">var </span><span class="s0">listeners = </span><span class="s1">this</span><span class="s0">.listenersMap.get(event);</span>

      <span class="s1">if </span><span class="s0">(listeners !== undefined) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, args = </span><span class="s1">new </span><span class="s0">Array(_len &gt; </span><span class="s4">1 </span><span class="s0">? _len - </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">), _key = </span><span class="s4">1</span><span class="s0">; _key &lt; _len; _key++) {</span>
          <span class="s0">args[_key - </span><span class="s4">1</span><span class="s0">] = arguments[_key];</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(listeners.length === </span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s3">// No need to clone or try/catch</span>
          <span class="s1">var </span><span class="s0">listener = listeners[</span><span class="s4">0</span><span class="s0">];</span>
          <span class="s0">listener.apply(</span><span class="s1">null</span><span class="s0">, args);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">var </span><span class="s0">didThrow = </span><span class="s1">false</span><span class="s0">;</span>
          <span class="s1">var </span><span class="s0">caughtError = </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s1">var </span><span class="s0">clonedListeners = Array.from(listeners);</span>

          <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; clonedListeners.length; i++) {</span>
            <span class="s1">var </span><span class="s0">_listener = clonedListeners[i];</span>

            <span class="s1">try </span><span class="s0">{</span>
              <span class="s0">_listener.apply(</span><span class="s1">null</span><span class="s0">, args);</span>
            <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
              <span class="s1">if </span><span class="s0">(caughtError === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">didThrow = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">caughtError = error;</span>
              <span class="s0">}</span>
            <span class="s0">}</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(didThrow) {</span>
            <span class="s1">throw </span><span class="s0">caughtError;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;removeAllListeners&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">removeAllListeners() {</span>
      <span class="s1">this</span><span class="s0">.listenersMap.clear();</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;removeListener&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">removeListener(event, listener) {</span>
      <span class="s1">var </span><span class="s0">listeners = </span><span class="s1">this</span><span class="s0">.listenersMap.get(event);</span>

      <span class="s1">if </span><span class="s0">(listeners !== undefined) {</span>
        <span class="s1">var </span><span class="s0">index = listeners.indexOf(listener);</span>

        <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
          <span class="s0">listeners.splice(index, </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}]);</span>

  <span class="s1">return </span><span class="s0">EventEmitter;</span>
<span class="s0">}();</span>


<span class="s3">// EXTERNAL MODULE: ../../node_modules/lodash.throttle/index.js</span>
<span class="s1">var </span><span class="s0">lodash_throttle = __webpack_require__(</span><span class="s4">172</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">lodash_throttle_default = </span><span class="s3">/*#__PURE__*/</span><span class="s0">__webpack_require__.n(lodash_throttle);</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/constants.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s1">var </span><span class="s0">CHROME_WEBSTORE_EXTENSION_ID = </span><span class="s2">'fmkadmapgofadopljbjfkapdkoienihi'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">INTERNAL_EXTENSION_ID = </span><span class="s2">'dnjnjgbfilfphmojnmhliehogmojhclc'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">LOCAL_EXTENSION_ID = </span><span class="s2">'ikiahnapldjmdmpkmfhjdjilojjhgcbf'</span><span class="s0">; </span><span class="s3">// Flip this flag to true to enable verbose console debug logging.</span>

<span class="s1">var </span><span class="s0">__DEBUG__ = </span><span class="s1">false</span><span class="s0">; </span><span class="s3">// Flip this flag to true to enable performance.mark() and performance.measure() timings.</span>

<span class="s1">var </span><span class="s0">__PERFORMANCE_PROFILE__ = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">TREE_OPERATION_ADD = </span><span class="s4">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">TREE_OPERATION_REMOVE = </span><span class="s4">2</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">TREE_OPERATION_REORDER_CHILDREN = </span><span class="s4">3</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">TREE_OPERATION_UPDATE_TREE_BASE_DURATION = </span><span class="s4">4</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = </span><span class="s4">5</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">TREE_OPERATION_REMOVE_ROOT = </span><span class="s4">6</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">TREE_OPERATION_SET_SUBTREE_MODE = </span><span class="s4">7</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">PROFILING_FLAG_BASIC_SUPPORT = </span><span class="s4">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">PROFILING_FLAG_TIMELINE_SUPPORT = </span><span class="s4">2</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">LOCAL_STORAGE_DEFAULT_TAB_KEY = </span><span class="s2">'React::DevTools::defaultTab'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">constants_LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = </span><span class="s2">'React::DevTools::componentFilters'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SESSION_STORAGE_LAST_SELECTION_KEY = </span><span class="s2">'React::DevTools::lastSelection'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">constants_LOCAL_STORAGE_OPEN_IN_EDITOR_URL = </span><span class="s2">'React::DevTools::openInEditorUrl'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = </span><span class="s2">'React::DevTools::parseHookNames'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = </span><span class="s2">'React::DevTools::recordChangeDescriptions'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = </span><span class="s2">'React::DevTools::reloadAndProfile'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">constants_LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = </span><span class="s2">'React::DevTools::breakOnConsoleErrors'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">LOCAL_STORAGE_BROWSER_THEME = </span><span class="s2">'React::DevTools::theme'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">constants_LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY = </span><span class="s2">'React::DevTools::appendComponentStack'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">constants_LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY = </span><span class="s2">'React::DevTools::showInlineWarningsAndErrors'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = </span><span class="s2">'React::DevTools::traceUpdatesEnabled'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">constants_LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE = </span><span class="s2">'React::DevTools::hideConsoleLogsInStrictMode'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">PROFILER_EXPORT_VERSION = </span><span class="s4">5</span><span class="s0">;</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/storage.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s1">function </span><span class="s0">storage_localStorageGetItem(key) {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">return </span><span class="s0">localStorage.getItem(key);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">localStorageRemoveItem(key) {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s0">localStorage.removeItem(key);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">storage_localStorageSetItem(key, value) {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">return </span><span class="s0">localStorage.setItem(key, value);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sessionStorageGetItem(key) {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">return </span><span class="s0">sessionStorage.getItem(key);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sessionStorageRemoveItem(key) {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s0">sessionStorage.removeItem(key);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">sessionStorageSetItem(key, value) {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">return </span><span class="s0">sessionStorage.setItem(key, value);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../../node_modules/memoize-one/esm/index.js</span>
<span class="s1">var </span><span class="s0">simpleIsEqual = </span><span class="s1">function </span><span class="s0">simpleIsEqual(a, b) {</span>
  <span class="s1">return </span><span class="s0">a === b;</span>
<span class="s0">};</span>

<span class="s3">/* harmony default export */ </span><span class="s1">function </span><span class="s0">esm(resultFn) {</span>
  <span class="s1">var </span><span class="s0">isEqual = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : simpleIsEqual;</span>
  <span class="s1">var </span><span class="s0">lastThis = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">lastArgs = [];</span>
  <span class="s1">var </span><span class="s0">lastResult = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">calledOnce = </span><span class="s1">false</span><span class="s0">;</span>

  <span class="s1">var </span><span class="s0">isNewArgEqualToLast = </span><span class="s1">function </span><span class="s0">isNewArgEqualToLast(newArg, index) {</span>
    <span class="s1">return </span><span class="s0">isEqual(newArg, lastArgs[index]);</span>
  <span class="s0">};</span>

  <span class="s1">var </span><span class="s0">result = </span><span class="s1">function </span><span class="s0">result() {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, newArgs = Array(_len), _key = </span><span class="s4">0</span><span class="s0">; _key &lt; _len; _key++) {</span>
      <span class="s0">newArgs[_key] = arguments[_key];</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(calledOnce &amp;&amp; lastThis === </span><span class="s1">this </span><span class="s0">&amp;&amp; newArgs.length === lastArgs.length &amp;&amp; newArgs.every(isNewArgEqualToLast)) {</span>
      <span class="s1">return </span><span class="s0">lastResult;</span>
    <span class="s0">}</span>

    <span class="s0">calledOnce = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">lastThis = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">lastArgs = newArgs;</span>
    <span class="s0">lastResult = resultFn.apply(</span><span class="s1">this</span><span class="s0">, newArgs);</span>
    <span class="s1">return </span><span class="s0">lastResult;</span>
  <span class="s0">};</span>

  <span class="s1">return </span><span class="s0">result;</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/utils.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s3">// Get the window object for the document that a node belongs to,</span>
<span class="s3">// or return null if it cannot be found (node not attached to DOM,</span>
<span class="s3">// etc).</span>
<span class="s1">function </span><span class="s0">getOwnerWindow(node) {</span>
  <span class="s1">if </span><span class="s0">(!node.ownerDocument) {</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">node.ownerDocument.defaultView;</span>
<span class="s0">} </span><span class="s3">// Get the iframe containing a node, or return null if it cannot</span>
<span class="s3">// be found (node not within iframe, etc).</span>

<span class="s1">function </span><span class="s0">getOwnerIframe(node) {</span>
  <span class="s1">var </span><span class="s0">nodeWindow = getOwnerWindow(node);</span>

  <span class="s1">if </span><span class="s0">(nodeWindow) {</span>
    <span class="s1">return </span><span class="s0">nodeWindow.frameElement;</span>
  <span class="s0">}</span>

  <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">} </span><span class="s3">// Get a bounding client rect for a node, with an</span>
<span class="s3">// offset added to compensate for its border.</span>

<span class="s1">function </span><span class="s0">getBoundingClientRectWithBorderOffset(node) {</span>
  <span class="s1">var </span><span class="s0">dimensions = getElementDimensions(node);</span>
  <span class="s1">return </span><span class="s0">mergeRectOffsets([node.getBoundingClientRect(), {</span>
    <span class="s0">top: dimensions.borderTop,</span>
    <span class="s0">left: dimensions.borderLeft,</span>
    <span class="s0">bottom: dimensions.borderBottom,</span>
    <span class="s0">right: dimensions.borderRight,</span>
    <span class="s3">// This width and height won't get used by mergeRectOffsets (since this</span>
    <span class="s3">// is not the first rect in the array), but we set them so that this</span>
    <span class="s3">// object type checks as a ClientRect.</span>
    <span class="s0">width: </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">height: </span><span class="s4">0</span>
  <span class="s0">}]);</span>
<span class="s0">} </span><span class="s3">// Add together the top, left, bottom, and right properties of</span>
<span class="s3">// each ClientRect, but keep the width and height of the first one.</span>

<span class="s1">function </span><span class="s0">mergeRectOffsets(rects) {</span>
  <span class="s1">return </span><span class="s0">rects.reduce(</span><span class="s1">function </span><span class="s0">(previousRect, rect) {</span>
    <span class="s1">if </span><span class="s0">(previousRect == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">rect;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">top: previousRect.top + rect.top,</span>
      <span class="s0">left: previousRect.left + rect.left,</span>
      <span class="s0">width: previousRect.width,</span>
      <span class="s0">height: previousRect.height,</span>
      <span class="s0">bottom: previousRect.bottom + rect.bottom,</span>
      <span class="s0">right: previousRect.right + rect.right</span>
    <span class="s0">};</span>
  <span class="s0">});</span>
<span class="s0">} </span><span class="s3">// Calculate a boundingClientRect for a node relative to boundaryWindow,</span>
<span class="s3">// taking into account any offsets caused by intermediate iframes.</span>

<span class="s1">function </span><span class="s0">getNestedBoundingClientRect(node, boundaryWindow) {</span>
  <span class="s1">var </span><span class="s0">ownerIframe = getOwnerIframe(node);</span>

  <span class="s1">if </span><span class="s0">(ownerIframe &amp;&amp; ownerIframe !== boundaryWindow) {</span>
    <span class="s1">var </span><span class="s0">rects = [node.getBoundingClientRect()];</span>
    <span class="s1">var </span><span class="s0">currentIframe = ownerIframe;</span>
    <span class="s1">var </span><span class="s0">onlyOneMore = </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">while </span><span class="s0">(currentIframe) {</span>
      <span class="s1">var </span><span class="s0">rect = getBoundingClientRectWithBorderOffset(currentIframe);</span>
      <span class="s0">rects.push(rect);</span>
      <span class="s0">currentIframe = getOwnerIframe(currentIframe);</span>

      <span class="s1">if </span><span class="s0">(onlyOneMore) {</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s3">// We don't want to calculate iframe offsets upwards beyond</span>
      <span class="s3">// the iframe containing the boundaryWindow, but we</span>
      <span class="s3">// need to calculate the offset relative to the boundaryWindow.</span>


      <span class="s1">if </span><span class="s0">(currentIframe &amp;&amp; getOwnerWindow(currentIframe) === boundaryWindow) {</span>
        <span class="s0">onlyOneMore = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">mergeRectOffsets(rects);</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">return </span><span class="s0">node.getBoundingClientRect();</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getElementDimensions(domElement) {</span>
  <span class="s1">var </span><span class="s0">calculatedStyle = window.getComputedStyle(domElement);</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">borderLeft: parseInt(calculatedStyle.borderLeftWidth, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">borderRight: parseInt(calculatedStyle.borderRightWidth, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">borderTop: parseInt(calculatedStyle.borderTopWidth, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">borderBottom: parseInt(calculatedStyle.borderBottomWidth, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">marginLeft: parseInt(calculatedStyle.marginLeft, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">marginRight: parseInt(calculatedStyle.marginRight, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">marginTop: parseInt(calculatedStyle.marginTop, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">marginBottom: parseInt(calculatedStyle.marginBottom, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">paddingLeft: parseInt(calculatedStyle.paddingLeft, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">paddingRight: parseInt(calculatedStyle.paddingRight, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">paddingTop: parseInt(calculatedStyle.paddingTop, </span><span class="s4">10</span><span class="s0">),</span>
    <span class="s0">paddingBottom: parseInt(calculatedStyle.paddingBottom, </span><span class="s4">10</span><span class="s0">)</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js</span>
<span class="s1">function </span><span class="s0">Overlay_classCallCheck(instance, Constructor) { </span><span class="s1">if </span><span class="s0">(!(instance </span><span class="s1">instanceof </span><span class="s0">Constructor)) { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Cannot call a class as a function&quot;</span><span class="s0">); } }</span>

<span class="s1">function </span><span class="s0">Overlay_defineProperties(target, props) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; props.length; i++) { </span><span class="s1">var </span><span class="s0">descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || </span><span class="s1">false</span><span class="s0">; descriptor.configurable = </span><span class="s1">true</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;value&quot; </span><span class="s1">in </span><span class="s0">descriptor) descriptor.writable = </span><span class="s1">true</span><span class="s0">; Object.defineProperty(target, descriptor.key, descriptor); } }</span>

<span class="s1">function </span><span class="s0">Overlay_createClass(Constructor, protoProps, staticProps) { </span><span class="s1">if </span><span class="s0">(protoProps) Overlay_defineProperties(Constructor.prototype, protoProps); </span><span class="s1">if </span><span class="s0">(staticProps) Overlay_defineProperties(Constructor, staticProps); </span><span class="s1">return </span><span class="s0">Constructor; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s1">var </span><span class="s0">Overlay_assign = Object.assign; </span><span class="s3">// Note that the Overlay components are not affected by the active Theme,</span>
<span class="s3">// because they highlight elements in the main Chrome window (outside of devtools).</span>
<span class="s3">// The colors below were chosen to roughly match those used by Chrome devtools.</span>

<span class="s1">var </span><span class="s0">OverlayRect = </span><span class="s3">/*#__PURE__*/</span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">function </span><span class="s0">OverlayRect(doc, container) {</span>
    <span class="s0">Overlay_classCallCheck(</span><span class="s1">this</span><span class="s0">, OverlayRect);</span>

    <span class="s1">this</span><span class="s0">.node = doc.createElement(</span><span class="s2">'div'</span><span class="s0">);</span>
    <span class="s1">this</span><span class="s0">.border = doc.createElement(</span><span class="s2">'div'</span><span class="s0">);</span>
    <span class="s1">this</span><span class="s0">.padding = doc.createElement(</span><span class="s2">'div'</span><span class="s0">);</span>
    <span class="s1">this</span><span class="s0">.content = doc.createElement(</span><span class="s2">'div'</span><span class="s0">);</span>
    <span class="s1">this</span><span class="s0">.border.style.borderColor = overlayStyles.border;</span>
    <span class="s1">this</span><span class="s0">.padding.style.borderColor = overlayStyles.padding;</span>
    <span class="s1">this</span><span class="s0">.content.style.backgroundColor = overlayStyles.background;</span>
    <span class="s0">Overlay_assign(</span><span class="s1">this</span><span class="s0">.node.style, {</span>
      <span class="s0">borderColor: overlayStyles.margin,</span>
      <span class="s0">pointerEvents: </span><span class="s2">'none'</span><span class="s0">,</span>
      <span class="s0">position: </span><span class="s2">'fixed'</span>
    <span class="s0">});</span>
    <span class="s1">this</span><span class="s0">.node.style.zIndex = </span><span class="s2">'10000000'</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.node.appendChild(</span><span class="s1">this</span><span class="s0">.border);</span>
    <span class="s1">this</span><span class="s0">.border.appendChild(</span><span class="s1">this</span><span class="s0">.padding);</span>
    <span class="s1">this</span><span class="s0">.padding.appendChild(</span><span class="s1">this</span><span class="s0">.content);</span>
    <span class="s0">container.appendChild(</span><span class="s1">this</span><span class="s0">.node);</span>
  <span class="s0">}</span>

  <span class="s0">Overlay_createClass(OverlayRect, [{</span>
    <span class="s0">key: </span><span class="s2">&quot;remove&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">remove() {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.node.parentNode) {</span>
        <span class="s1">this</span><span class="s0">.node.parentNode.removeChild(</span><span class="s1">this</span><span class="s0">.node);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;update&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">update(box, dims) {</span>
      <span class="s0">boxWrap(dims, </span><span class="s2">'margin'</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.node);</span>
      <span class="s0">boxWrap(dims, </span><span class="s2">'border'</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.border);</span>
      <span class="s0">boxWrap(dims, </span><span class="s2">'padding'</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.padding);</span>
      <span class="s0">Overlay_assign(</span><span class="s1">this</span><span class="s0">.content.style, {</span>
        <span class="s0">height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + </span><span class="s2">'px'</span><span class="s0">,</span>
        <span class="s0">width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + </span><span class="s2">'px'</span>
      <span class="s0">});</span>
      <span class="s0">Overlay_assign(</span><span class="s1">this</span><span class="s0">.node.style, {</span>
        <span class="s0">top: box.top - dims.marginTop + </span><span class="s2">'px'</span><span class="s0">,</span>
        <span class="s0">left: box.left - dims.marginLeft + </span><span class="s2">'px'</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">}]);</span>

  <span class="s1">return </span><span class="s0">OverlayRect;</span>
<span class="s0">}();</span>

<span class="s1">var </span><span class="s0">OverlayTip = </span><span class="s3">/*#__PURE__*/</span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">function </span><span class="s0">OverlayTip(doc, container) {</span>
    <span class="s0">Overlay_classCallCheck(</span><span class="s1">this</span><span class="s0">, OverlayTip);</span>

    <span class="s1">this</span><span class="s0">.tip = doc.createElement(</span><span class="s2">'div'</span><span class="s0">);</span>
    <span class="s0">Overlay_assign(</span><span class="s1">this</span><span class="s0">.tip.style, {</span>
      <span class="s0">display: </span><span class="s2">'flex'</span><span class="s0">,</span>
      <span class="s0">flexFlow: </span><span class="s2">'row nowrap'</span><span class="s0">,</span>
      <span class="s0">backgroundColor: </span><span class="s2">'#333740'</span><span class="s0">,</span>
      <span class="s0">borderRadius: </span><span class="s2">'2px'</span><span class="s0">,</span>
      <span class="s0">fontFamily: </span><span class="s2">'&quot;SFMono-Regular&quot;, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace'</span><span class="s0">,</span>
      <span class="s0">fontWeight: </span><span class="s2">'bold'</span><span class="s0">,</span>
      <span class="s0">padding: </span><span class="s2">'3px 5px'</span><span class="s0">,</span>
      <span class="s0">pointerEvents: </span><span class="s2">'none'</span><span class="s0">,</span>
      <span class="s0">position: </span><span class="s2">'fixed'</span><span class="s0">,</span>
      <span class="s0">fontSize: </span><span class="s2">'12px'</span><span class="s0">,</span>
      <span class="s0">whiteSpace: </span><span class="s2">'nowrap'</span>
    <span class="s0">});</span>
    <span class="s1">this</span><span class="s0">.nameSpan = doc.createElement(</span><span class="s2">'span'</span><span class="s0">);</span>
    <span class="s1">this</span><span class="s0">.tip.appendChild(</span><span class="s1">this</span><span class="s0">.nameSpan);</span>
    <span class="s0">Overlay_assign(</span><span class="s1">this</span><span class="s0">.nameSpan.style, {</span>
      <span class="s0">color: </span><span class="s2">'#ee78e6'</span><span class="s0">,</span>
      <span class="s0">borderRight: </span><span class="s2">'1px solid #aaaaaa'</span><span class="s0">,</span>
      <span class="s0">paddingRight: </span><span class="s2">'0.5rem'</span><span class="s0">,</span>
      <span class="s0">marginRight: </span><span class="s2">'0.5rem'</span>
    <span class="s0">});</span>
    <span class="s1">this</span><span class="s0">.dimSpan = doc.createElement(</span><span class="s2">'span'</span><span class="s0">);</span>
    <span class="s1">this</span><span class="s0">.tip.appendChild(</span><span class="s1">this</span><span class="s0">.dimSpan);</span>
    <span class="s0">Overlay_assign(</span><span class="s1">this</span><span class="s0">.dimSpan.style, {</span>
      <span class="s0">color: </span><span class="s2">'#d7d7d7'</span>
    <span class="s0">});</span>
    <span class="s1">this</span><span class="s0">.tip.style.zIndex = </span><span class="s2">'10000000'</span><span class="s0">;</span>
    <span class="s0">container.appendChild(</span><span class="s1">this</span><span class="s0">.tip);</span>
  <span class="s0">}</span>

  <span class="s0">Overlay_createClass(OverlayTip, [{</span>
    <span class="s0">key: </span><span class="s2">&quot;remove&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">remove() {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.tip.parentNode) {</span>
        <span class="s1">this</span><span class="s0">.tip.parentNode.removeChild(</span><span class="s1">this</span><span class="s0">.tip);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;updateText&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">updateText(name, width, height) {</span>
      <span class="s1">this</span><span class="s0">.nameSpan.textContent = name;</span>
      <span class="s1">this</span><span class="s0">.dimSpan.textContent = Math.round(width) + </span><span class="s2">'px  ' </span><span class="s0">+ Math.round(height) + </span><span class="s2">'px'</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;updatePosition&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">updatePosition(dims, bounds) {</span>
      <span class="s1">var </span><span class="s0">tipRect = </span><span class="s1">this</span><span class="s0">.tip.getBoundingClientRect();</span>
      <span class="s1">var </span><span class="s0">tipPos = findTipPos(dims, bounds, {</span>
        <span class="s0">width: tipRect.width,</span>
        <span class="s0">height: tipRect.height</span>
      <span class="s0">});</span>
      <span class="s0">Overlay_assign(</span><span class="s1">this</span><span class="s0">.tip.style, tipPos.style);</span>
    <span class="s0">}</span>
  <span class="s0">}]);</span>

  <span class="s1">return </span><span class="s0">OverlayTip;</span>
<span class="s0">}();</span>

<span class="s1">var </span><span class="s0">Overlay = </span><span class="s3">/*#__PURE__*/</span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">function </span><span class="s0">Overlay(agent) {</span>
    <span class="s0">Overlay_classCallCheck(</span><span class="s1">this</span><span class="s0">, Overlay);</span>

    <span class="s3">// Find the root window, because overlays are positioned relative to it.</span>
    <span class="s1">var </span><span class="s0">currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;</span>
    <span class="s1">this</span><span class="s0">.window = currentWindow; </span><span class="s3">// When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.</span>

    <span class="s1">var </span><span class="s0">tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;</span>
    <span class="s1">this</span><span class="s0">.tipBoundsWindow = tipBoundsWindow;</span>
    <span class="s1">var </span><span class="s0">doc = currentWindow.document;</span>
    <span class="s1">this</span><span class="s0">.container = doc.createElement(</span><span class="s2">'div'</span><span class="s0">);</span>
    <span class="s1">this</span><span class="s0">.container.style.zIndex = </span><span class="s2">'10000000'</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.tip = </span><span class="s1">new </span><span class="s0">OverlayTip(doc, </span><span class="s1">this</span><span class="s0">.container);</span>
    <span class="s1">this</span><span class="s0">.rects = [];</span>
    <span class="s1">this</span><span class="s0">.agent = agent;</span>
    <span class="s0">doc.body.appendChild(</span><span class="s1">this</span><span class="s0">.container);</span>
  <span class="s0">}</span>

  <span class="s0">Overlay_createClass(Overlay, [{</span>
    <span class="s0">key: </span><span class="s2">&quot;remove&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">remove() {</span>
      <span class="s1">this</span><span class="s0">.tip.remove();</span>
      <span class="s1">this</span><span class="s0">.rects.forEach(</span><span class="s1">function </span><span class="s0">(rect) {</span>
        <span class="s0">rect.remove();</span>
      <span class="s0">});</span>
      <span class="s1">this</span><span class="s0">.rects.length = </span><span class="s4">0</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.container.parentNode) {</span>
        <span class="s1">this</span><span class="s0">.container.parentNode.removeChild(</span><span class="s1">this</span><span class="s0">.container);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;inspect&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">inspect(nodes, name) {</span>
      <span class="s1">var </span><span class="s0">_this = </span><span class="s1">this</span><span class="s0">;</span>

      <span class="s3">// We can't get the size of text nodes or comment nodes. React as of v15</span>
      <span class="s3">// heavily uses comment nodes to delimit text.</span>
      <span class="s1">var </span><span class="s0">elements = nodes.filter(</span><span class="s1">function </span><span class="s0">(node) {</span>
        <span class="s1">return </span><span class="s0">node.nodeType === Node.ELEMENT_NODE;</span>
      <span class="s0">});</span>

      <span class="s1">while </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.rects.length &gt; elements.length) {</span>
        <span class="s1">var </span><span class="s0">rect = </span><span class="s1">this</span><span class="s0">.rects.pop();</span>
        <span class="s0">rect.remove();</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(elements.length === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">while </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.rects.length &lt; elements.length) {</span>
        <span class="s1">this</span><span class="s0">.rects.push(</span><span class="s1">new </span><span class="s0">OverlayRect(</span><span class="s1">this</span><span class="s0">.window.document, </span><span class="s1">this</span><span class="s0">.container));</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">outerBox = {</span>
        <span class="s0">top: Number.POSITIVE_INFINITY,</span>
        <span class="s0">right: Number.NEGATIVE_INFINITY,</span>
        <span class="s0">bottom: Number.NEGATIVE_INFINITY,</span>
        <span class="s0">left: Number.POSITIVE_INFINITY</span>
      <span class="s0">};</span>
      <span class="s0">elements.forEach(</span><span class="s1">function </span><span class="s0">(element, index) {</span>
        <span class="s1">var </span><span class="s0">box = getNestedBoundingClientRect(element, _this.window);</span>
        <span class="s1">var </span><span class="s0">dims = getElementDimensions(element);</span>
        <span class="s0">outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);</span>
        <span class="s0">outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);</span>
        <span class="s0">outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);</span>
        <span class="s0">outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);</span>
        <span class="s1">var </span><span class="s0">rect = _this.rects[index];</span>
        <span class="s0">rect.update(box, dims);</span>
      <span class="s0">});</span>

      <span class="s1">if </span><span class="s0">(!name) {</span>
        <span class="s0">name = elements[</span><span class="s4">0</span><span class="s0">].nodeName.toLowerCase();</span>
        <span class="s1">var </span><span class="s0">node = elements[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">var </span><span class="s0">rendererInterface = </span><span class="s1">this</span><span class="s0">.agent.getBestMatchingRendererInterface(node);</span>

        <span class="s1">if </span><span class="s0">(rendererInterface) {</span>
          <span class="s1">var </span><span class="s0">id = rendererInterface.getFiberIDForNative(node, </span><span class="s1">true</span><span class="s0">);</span>

          <span class="s1">if </span><span class="s0">(id) {</span>
            <span class="s1">var </span><span class="s0">ownerName = rendererInterface.getDisplayNameForFiberID(id, </span><span class="s1">true</span><span class="s0">);</span>

            <span class="s1">if </span><span class="s0">(ownerName) {</span>
              <span class="s0">name += </span><span class="s2">' (in ' </span><span class="s0">+ ownerName + </span><span class="s2">')'</span><span class="s0">;</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">this</span><span class="s0">.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);</span>
      <span class="s1">var </span><span class="s0">tipBounds = getNestedBoundingClientRect(</span><span class="s1">this</span><span class="s0">.tipBoundsWindow.document.documentElement, </span><span class="s1">this</span><span class="s0">.window);</span>
      <span class="s1">this</span><span class="s0">.tip.updatePosition({</span>
        <span class="s0">top: outerBox.top,</span>
        <span class="s0">left: outerBox.left,</span>
        <span class="s0">height: outerBox.bottom - outerBox.top,</span>
        <span class="s0">width: outerBox.right - outerBox.left</span>
      <span class="s0">}, {</span>
        <span class="s0">top: tipBounds.top + </span><span class="s1">this</span><span class="s0">.tipBoundsWindow.scrollY,</span>
        <span class="s0">left: tipBounds.left + </span><span class="s1">this</span><span class="s0">.tipBoundsWindow.scrollX,</span>
        <span class="s0">height: </span><span class="s1">this</span><span class="s0">.tipBoundsWindow.innerHeight,</span>
        <span class="s0">width: </span><span class="s1">this</span><span class="s0">.tipBoundsWindow.innerWidth</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">}]);</span>

  <span class="s1">return </span><span class="s0">Overlay;</span>
<span class="s0">}();</span>



<span class="s1">function </span><span class="s0">findTipPos(dims, bounds, tipSize) {</span>
  <span class="s1">var </span><span class="s0">tipHeight = Math.max(tipSize.height, </span><span class="s4">20</span><span class="s0">);</span>
  <span class="s1">var </span><span class="s0">tipWidth = Math.max(tipSize.width, </span><span class="s4">60</span><span class="s0">);</span>
  <span class="s1">var </span><span class="s0">margin = </span><span class="s4">5</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">top;</span>

  <span class="s1">if </span><span class="s0">(dims.top + dims.height + tipHeight &lt;= bounds.top + bounds.height) {</span>
    <span class="s1">if </span><span class="s0">(dims.top + dims.height &lt; bounds.top + </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s0">top = bounds.top + margin;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">top = dims.top + dims.height + margin;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(dims.top - tipHeight &lt;= bounds.top + bounds.height) {</span>
    <span class="s1">if </span><span class="s0">(dims.top - tipHeight - margin &lt; bounds.top + margin) {</span>
      <span class="s0">top = bounds.top + margin;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">top = dims.top - tipHeight - margin;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">top = bounds.top + bounds.height - tipHeight - margin;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">left = dims.left + margin;</span>

  <span class="s1">if </span><span class="s0">(dims.left &lt; bounds.left) {</span>
    <span class="s0">left = bounds.left + margin;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(dims.left + tipWidth &gt; bounds.left + bounds.width) {</span>
    <span class="s0">left = bounds.left + bounds.width - tipWidth - margin;</span>
  <span class="s0">}</span>

  <span class="s0">top += </span><span class="s2">'px'</span><span class="s0">;</span>
  <span class="s0">left += </span><span class="s2">'px'</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">style: {</span>
      <span class="s0">top: top,</span>
      <span class="s0">left: left</span>
    <span class="s0">}</span>
  <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">boxWrap(dims, what, node) {</span>
  <span class="s0">Overlay_assign(node.style, {</span>
    <span class="s0">borderTopWidth: dims[what + </span><span class="s2">'Top'</span><span class="s0">] + </span><span class="s2">'px'</span><span class="s0">,</span>
    <span class="s0">borderLeftWidth: dims[what + </span><span class="s2">'Left'</span><span class="s0">] + </span><span class="s2">'px'</span><span class="s0">,</span>
    <span class="s0">borderRightWidth: dims[what + </span><span class="s2">'Right'</span><span class="s0">] + </span><span class="s2">'px'</span><span class="s0">,</span>
    <span class="s0">borderBottomWidth: dims[what + </span><span class="s2">'Bottom'</span><span class="s0">] + </span><span class="s2">'px'</span><span class="s0">,</span>
    <span class="s0">borderStyle: </span><span class="s2">'solid'</span>
  <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">overlayStyles = {</span>
  <span class="s0">background: </span><span class="s2">'rgba(120, 170, 210, 0.7)'</span><span class="s0">,</span>
  <span class="s0">padding: </span><span class="s2">'rgba(77, 200, 0, 0.3)'</span><span class="s0">,</span>
  <span class="s0">margin: </span><span class="s2">'rgba(255, 155, 0, 0.3)'</span><span class="s0">,</span>
  <span class="s0">border: </span><span class="s2">'rgba(255, 200, 50, 0.3)'</span>
<span class="s0">};</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s1">var </span><span class="s0">SHOW_DURATION = </span><span class="s4">2000</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">timeoutID = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">overlay = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">hideOverlay(agent) {</span>
  <span class="s1">if </span><span class="s0">(window.document == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">agent.emit(</span><span class="s2">'hideNativeHighlight'</span><span class="s0">);</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">timeoutID = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(overlay !== </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">overlay.remove();</span>
    <span class="s0">overlay = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">showOverlay(elements, componentName, agent, hideAfterTimeout) {</span>
  <span class="s1">if </span><span class="s0">(window.document == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(elements != </span><span class="s1">null </span><span class="s0">&amp;&amp; elements[</span><span class="s4">0</span><span class="s0">] != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">agent.emit(</span><span class="s2">'showNativeHighlight'</span><span class="s0">, elements[</span><span class="s4">0</span><span class="s0">]);</span>
    <span class="s0">}</span>

    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(timeoutID !== </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">clearTimeout(timeoutID);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(elements == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(overlay === </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">overlay = </span><span class="s1">new </span><span class="s0">Overlay(agent);</span>
  <span class="s0">}</span>

  <span class="s0">overlay.inspect(elements, componentName);</span>

  <span class="s1">if </span><span class="s0">(hideAfterTimeout) {</span>
    <span class="s0">timeoutID = setTimeout(</span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s1">return </span><span class="s0">hideOverlay(agent);</span>
    <span class="s0">}, SHOW_DURATION);</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/index.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>




<span class="s3">// This plug-in provides in-page highlighting of the selected element.</span>
<span class="s3">// It is used by the browser extension and the standalone DevTools shell (when connected to a browser).</span>
<span class="s3">// It is not currently the mechanism used to highlight React Native views.</span>
<span class="s3">// That is done by the React Native Inspector component.</span>
<span class="s1">var </span><span class="s0">iframesListeningTo = </span><span class="s1">new </span><span class="s0">Set();</span>
<span class="s1">function </span><span class="s0">setupHighlighter(bridge, agent) {</span>
  <span class="s0">bridge.addListener(</span><span class="s2">'clearNativeElementHighlight'</span><span class="s0">, clearNativeElementHighlight);</span>
  <span class="s0">bridge.addListener(</span><span class="s2">'highlightNativeElement'</span><span class="s0">, highlightNativeElement);</span>
  <span class="s0">bridge.addListener(</span><span class="s2">'shutdown'</span><span class="s0">, stopInspectingNative);</span>
  <span class="s0">bridge.addListener(</span><span class="s2">'startInspectingNative'</span><span class="s0">, startInspectingNative);</span>
  <span class="s0">bridge.addListener(</span><span class="s2">'stopInspectingNative'</span><span class="s0">, stopInspectingNative);</span>

  <span class="s1">function </span><span class="s0">startInspectingNative() {</span>
    <span class="s0">registerListenersOnWindow(window);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">registerListenersOnWindow(window) {</span>
    <span class="s3">// This plug-in may run in non-DOM environments (e.g. React Native).</span>
    <span class="s1">if </span><span class="s0">(window &amp;&amp; </span><span class="s1">typeof </span><span class="s0">window.addEventListener === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s0">window.addEventListener(</span><span class="s2">'click'</span><span class="s0">, onClick, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.addEventListener(</span><span class="s2">'mousedown'</span><span class="s0">, onMouseEvent, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.addEventListener(</span><span class="s2">'mouseover'</span><span class="s0">, onMouseEvent, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.addEventListener(</span><span class="s2">'mouseup'</span><span class="s0">, onMouseEvent, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.addEventListener(</span><span class="s2">'pointerdown'</span><span class="s0">, onPointerDown, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.addEventListener(</span><span class="s2">'pointermove'</span><span class="s0">, onPointerMove, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.addEventListener(</span><span class="s2">'pointerup'</span><span class="s0">, onPointerUp, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">agent.emit(</span><span class="s2">'startInspectingNative'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">stopInspectingNative() {</span>
    <span class="s0">hideOverlay(agent);</span>
    <span class="s0">removeListenersOnWindow(window);</span>
    <span class="s0">iframesListeningTo.forEach(</span><span class="s1">function </span><span class="s0">(frame) {</span>
      <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">removeListenersOnWindow(frame.contentWindow);</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span><span class="s3">// This can error when the iframe is on a cross-origin.</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">iframesListeningTo = </span><span class="s1">new </span><span class="s0">Set();</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">removeListenersOnWindow(window) {</span>
    <span class="s3">// This plug-in may run in non-DOM environments (e.g. React Native).</span>
    <span class="s1">if </span><span class="s0">(window &amp;&amp; </span><span class="s1">typeof </span><span class="s0">window.removeEventListener === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s0">window.removeEventListener(</span><span class="s2">'click'</span><span class="s0">, onClick, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.removeEventListener(</span><span class="s2">'mousedown'</span><span class="s0">, onMouseEvent, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.removeEventListener(</span><span class="s2">'mouseover'</span><span class="s0">, onMouseEvent, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.removeEventListener(</span><span class="s2">'mouseup'</span><span class="s0">, onMouseEvent, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.removeEventListener(</span><span class="s2">'pointerdown'</span><span class="s0">, onPointerDown, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.removeEventListener(</span><span class="s2">'pointermove'</span><span class="s0">, onPointerMove, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">window.removeEventListener(</span><span class="s2">'pointerup'</span><span class="s0">, onPointerUp, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">agent.emit(</span><span class="s2">'stopInspectingNative'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">clearNativeElementHighlight() {</span>
    <span class="s0">hideOverlay(agent);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">highlightNativeElement(_ref) {</span>
    <span class="s1">var </span><span class="s0">displayName = _ref.displayName,</span>
        <span class="s0">hideAfterTimeout = _ref.hideAfterTimeout,</span>
        <span class="s0">id = _ref.id,</span>
        <span class="s0">openNativeElementsPanel = _ref.openNativeElementsPanel,</span>
        <span class="s0">rendererID = _ref.rendererID,</span>
        <span class="s0">scrollIntoView = _ref.scrollIntoView;</span>
    <span class="s1">var </span><span class="s0">renderer = agent.rendererInterfaces[rendererID];</span>

    <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">hideOverlay(agent);</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s3">// In some cases fiber may already be unmounted</span>


    <span class="s1">if </span><span class="s0">(!renderer.hasFiberWithId(id)) {</span>
      <span class="s0">hideOverlay(agent);</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">nodes = renderer.findNativeNodesForFiberID(id);</span>

    <span class="s1">if </span><span class="s0">(nodes != </span><span class="s1">null </span><span class="s0">&amp;&amp; nodes[</span><span class="s4">0</span><span class="s0">] != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">node = nodes[</span><span class="s4">0</span><span class="s0">]; </span><span class="s3">// $FlowFixMe[method-unbinding]</span>

      <span class="s1">if </span><span class="s0">(scrollIntoView &amp;&amp; </span><span class="s1">typeof </span><span class="s0">node.scrollIntoView === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s3">// If the node isn't visible show it before highlighting it.</span>
        <span class="s3">// We may want to reconsider this; it might be a little disruptive.</span>
        <span class="s0">node.scrollIntoView({</span>
          <span class="s0">block: </span><span class="s2">'nearest'</span><span class="s0">,</span>
          <span class="s0">inline: </span><span class="s2">'nearest'</span>
        <span class="s0">});</span>
      <span class="s0">}</span>

      <span class="s0">showOverlay(nodes, displayName, agent, hideAfterTimeout);</span>

      <span class="s1">if </span><span class="s0">(openNativeElementsPanel) {</span>
        <span class="s0">window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;</span>
        <span class="s0">bridge.send(</span><span class="s2">'syncSelectionToNativeElementsPanel'</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">hideOverlay(agent);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">onClick(event) {</span>
    <span class="s0">event.preventDefault();</span>
    <span class="s0">event.stopPropagation();</span>
    <span class="s0">stopInspectingNative();</span>
    <span class="s0">bridge.send(</span><span class="s2">'stopInspectingNative'</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">onMouseEvent(event) {</span>
    <span class="s0">event.preventDefault();</span>
    <span class="s0">event.stopPropagation();</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">onPointerDown(event) {</span>
    <span class="s0">event.preventDefault();</span>
    <span class="s0">event.stopPropagation();</span>
    <span class="s0">selectFiberForNode(getEventTarget(event));</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">lastHoveredNode = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">onPointerMove(event) {</span>
    <span class="s0">event.preventDefault();</span>
    <span class="s0">event.stopPropagation();</span>
    <span class="s1">var </span><span class="s0">target = getEventTarget(event);</span>
    <span class="s1">if </span><span class="s0">(lastHoveredNode === target) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">lastHoveredNode = target;</span>

    <span class="s1">if </span><span class="s0">(target.tagName === </span><span class="s2">'IFRAME'</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">iframe = target;</span>

      <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">if </span><span class="s0">(!iframesListeningTo.has(iframe)) {</span>
          <span class="s1">var </span><span class="s0">_window = iframe.contentWindow;</span>
          <span class="s0">registerListenersOnWindow(_window);</span>
          <span class="s0">iframesListeningTo.add(iframe);</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span><span class="s3">// This can error when the iframe is on a cross-origin.</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">// Don't pass the name explicitly.</span>
    <span class="s3">// It will be inferred from DOM tag and Fiber owner.</span>


    <span class="s0">showOverlay([target], </span><span class="s1">null</span><span class="s0">, agent, </span><span class="s1">false</span><span class="s0">);</span>
    <span class="s0">selectFiberForNode(target);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">onPointerUp(event) {</span>
    <span class="s0">event.preventDefault();</span>
    <span class="s0">event.stopPropagation();</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">selectFiberForNode = lodash_throttle_default()(esm(</span><span class="s1">function </span><span class="s0">(node) {</span>
    <span class="s1">var </span><span class="s0">id = agent.getIDForNode(node);</span>

    <span class="s1">if </span><span class="s0">(id !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">bridge.send(</span><span class="s2">'selectFiber'</span><span class="s0">, id);</span>
    <span class="s0">}</span>
  <span class="s0">}), </span><span class="s4">200</span><span class="s0">, </span><span class="s3">// Don't change the selection in the very first 200ms</span>
  <span class="s3">// because those are usually unintentional as you lift the cursor.</span>
  <span class="s0">{</span>
    <span class="s0">leading: </span><span class="s1">false</span>
  <span class="s0">});</span>

  <span class="s1">function </span><span class="s0">getEventTarget(event) {</span>
    <span class="s1">if </span><span class="s0">(event.composed) {</span>
      <span class="s1">return </span><span class="s0">event.composedPath()[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">event.target;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s1">var </span><span class="s0">OUTLINE_COLOR = </span><span class="s2">'#f0f0f0'</span><span class="s0">; </span><span class="s3">// Note these colors are in sync with DevTools Profiler chart colors.</span>

<span class="s1">var </span><span class="s0">COLORS = [</span><span class="s2">'#37afa9'</span><span class="s0">, </span><span class="s2">'#63b19e'</span><span class="s0">, </span><span class="s2">'#80b393'</span><span class="s0">, </span><span class="s2">'#97b488'</span><span class="s0">, </span><span class="s2">'#abb67d'</span><span class="s0">, </span><span class="s2">'#beb771'</span><span class="s0">, </span><span class="s2">'#cfb965'</span><span class="s0">, </span><span class="s2">'#dfba57'</span><span class="s0">, </span><span class="s2">'#efbb49'</span><span class="s0">, </span><span class="s2">'#febc38'</span><span class="s0">];</span>
<span class="s1">var </span><span class="s0">canvas = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">draw(nodeToData, agent) {</span>
  <span class="s1">if </span><span class="s0">(window.document == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">nodesToDraw = [];</span>
    <span class="s0">iterateNodes(nodeToData, </span><span class="s1">function </span><span class="s0">(_, color, node) {</span>
      <span class="s0">nodesToDraw.push({</span>
        <span class="s0">node: node,</span>
        <span class="s0">color: color</span>
      <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s0">agent.emit(</span><span class="s2">'drawTraceUpdates'</span><span class="s0">, nodesToDraw);</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(canvas === </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">initialize();</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">canvasFlow = canvas;</span>
  <span class="s0">canvasFlow.width = window.innerWidth;</span>
  <span class="s0">canvasFlow.height = window.innerHeight;</span>
  <span class="s1">var </span><span class="s0">context = canvasFlow.getContext(</span><span class="s2">'2d'</span><span class="s0">);</span>
  <span class="s0">context.clearRect(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, canvasFlow.width, canvasFlow.height);</span>
  <span class="s0">iterateNodes(nodeToData, </span><span class="s1">function </span><span class="s0">(rect, color) {</span>
    <span class="s1">if </span><span class="s0">(rect !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">drawBorder(context, rect, color);</span>
    <span class="s0">}</span>
  <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">iterateNodes(nodeToData, execute) {</span>
  <span class="s0">nodeToData.forEach(</span><span class="s1">function </span><span class="s0">(_ref, node) {</span>
    <span class="s1">var </span><span class="s0">count = _ref.count,</span>
        <span class="s0">rect = _ref.rect;</span>
    <span class="s1">var </span><span class="s0">colorIndex = Math.min(COLORS.length - </span><span class="s4">1</span><span class="s0">, count - </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">color = COLORS[colorIndex];</span>
    <span class="s0">execute(rect, color, node);</span>
  <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">drawBorder(context, rect, color) {</span>
  <span class="s1">var </span><span class="s0">height = rect.height,</span>
      <span class="s0">left = rect.left,</span>
      <span class="s0">top = rect.top,</span>
      <span class="s0">width = rect.width; </span><span class="s3">// outline</span>

  <span class="s0">context.lineWidth = </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">context.strokeStyle = OUTLINE_COLOR;</span>
  <span class="s0">context.strokeRect(left - </span><span class="s4">1</span><span class="s0">, top - </span><span class="s4">1</span><span class="s0">, width + </span><span class="s4">2</span><span class="s0">, height + </span><span class="s4">2</span><span class="s0">); </span><span class="s3">// inset</span>

  <span class="s0">context.lineWidth = </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">context.strokeStyle = OUTLINE_COLOR;</span>
  <span class="s0">context.strokeRect(left + </span><span class="s4">1</span><span class="s0">, top + </span><span class="s4">1</span><span class="s0">, width - </span><span class="s4">1</span><span class="s0">, height - </span><span class="s4">1</span><span class="s0">);</span>
  <span class="s0">context.strokeStyle = color;</span>
  <span class="s0">context.setLineDash([</span><span class="s4">0</span><span class="s0">]); </span><span class="s3">// border</span>

  <span class="s0">context.lineWidth = </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">context.strokeRect(left, top, width - </span><span class="s4">1</span><span class="s0">, height - </span><span class="s4">1</span><span class="s0">);</span>
  <span class="s0">context.setLineDash([</span><span class="s4">0</span><span class="s0">]);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">destroy(agent) {</span>
  <span class="s1">if </span><span class="s0">(window.document == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">agent.emit(</span><span class="s2">'disableTraceUpdates'</span><span class="s0">);</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(canvas !== </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(canvas.parentNode != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">canvas.parentNode.removeChild(canvas);</span>
    <span class="s0">}</span>

    <span class="s0">canvas = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">initialize() {</span>
  <span class="s0">canvas = window.document.createElement(</span><span class="s2">'canvas'</span><span class="s0">);</span>
  <span class="s0">canvas.style.cssText = </span><span class="s2">&quot;</span><span class="s5">\n    </span><span class="s2">xx-background-color: red;</span><span class="s5">\n    </span><span class="s2">xx-opacity: 0.5;</span><span class="s5">\n    </span><span class="s2">bottom: 0;</span><span class="s5">\n    </span><span class="s2">left: 0;</span><span class="s5">\n    </span><span class="s2">pointer-events: none;</span><span class="s5">\n    </span><span class="s2">position: fixed;</span><span class="s5">\n    </span><span class="s2">right: 0;</span><span class="s5">\n    </span><span class="s2">top: 0;</span><span class="s5">\n    </span><span class="s2">z-index: 1000000000;</span><span class="s5">\n  </span><span class="s2">&quot;</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">root = window.document.documentElement;</span>
  <span class="s0">root.insertBefore(canvas, root.firstChild);</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/index.js</span>
<span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ _typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">_typeof(obj); }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>



<span class="s3">// How long the rect should be shown for?</span>
<span class="s1">var </span><span class="s0">DISPLAY_DURATION = </span><span class="s4">250</span><span class="s0">; </span><span class="s3">// What's the longest we are willing to show the overlay for?</span>
<span class="s3">// This can be important if we're getting a flurry of events (e.g. scroll update).</span>

<span class="s1">var </span><span class="s0">MAX_DISPLAY_DURATION = </span><span class="s4">3000</span><span class="s0">; </span><span class="s3">// How long should a rect be considered valid for?</span>

<span class="s1">var </span><span class="s0">REMEASUREMENT_AFTER_DURATION = </span><span class="s4">250</span><span class="s0">; </span><span class="s3">// Some environments (e.g. React Native / Hermes) don't support the performance API yet.</span>

<span class="s1">var </span><span class="s0">getCurrentTime = </span><span class="s3">// $FlowFixMe[method-unbinding]</span>
<span class="s0">(</span><span class="s1">typeof </span><span class="s0">performance === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? </span><span class="s2">&quot;undefined&quot; </span><span class="s0">: _typeof(performance)) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">performance.now === </span><span class="s2">'function' </span><span class="s0">? </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">performance.now();</span>
<span class="s0">} : </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">Date.now();</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">nodeToData = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">var </span><span class="s0">agent = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">drawAnimationFrameID = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">isEnabled = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">redrawTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">TraceUpdates_initialize(injectedAgent) {</span>
  <span class="s0">agent = injectedAgent;</span>
  <span class="s0">agent.addListener(</span><span class="s2">'traceUpdates'</span><span class="s0">, traceUpdates);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">toggleEnabled(value) {</span>
  <span class="s0">isEnabled = value;</span>

  <span class="s1">if </span><span class="s0">(!isEnabled) {</span>
    <span class="s0">nodeToData.clear();</span>

    <span class="s1">if </span><span class="s0">(drawAnimationFrameID !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">cancelAnimationFrame(drawAnimationFrameID);</span>
      <span class="s0">drawAnimationFrameID = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(redrawTimeoutID !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">clearTimeout(redrawTimeoutID);</span>
      <span class="s0">redrawTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">destroy(agent);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">traceUpdates(nodes) {</span>
  <span class="s1">if </span><span class="s0">(!isEnabled) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">nodes.forEach(</span><span class="s1">function </span><span class="s0">(node) {</span>
    <span class="s1">var </span><span class="s0">data = nodeToData.get(node);</span>
    <span class="s1">var </span><span class="s0">now = getCurrentTime();</span>
    <span class="s1">var </span><span class="s0">lastMeasuredAt = data != </span><span class="s1">null </span><span class="s0">? data.lastMeasuredAt : </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">rect = data != </span><span class="s1">null </span><span class="s0">? data.rect : </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(rect === </span><span class="s1">null </span><span class="s0">|| lastMeasuredAt + REMEASUREMENT_AFTER_DURATION &lt; now) {</span>
      <span class="s0">lastMeasuredAt = now;</span>
      <span class="s0">rect = measureNode(node);</span>
    <span class="s0">}</span>

    <span class="s0">nodeToData.set(node, {</span>
      <span class="s0">count: data != </span><span class="s1">null </span><span class="s0">? data.count + </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">expirationTime: data != </span><span class="s1">null </span><span class="s0">? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,</span>
      <span class="s0">lastMeasuredAt: lastMeasuredAt,</span>
      <span class="s0">rect: rect</span>
    <span class="s0">});</span>
  <span class="s0">});</span>

  <span class="s1">if </span><span class="s0">(redrawTimeoutID !== </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">clearTimeout(redrawTimeoutID);</span>
    <span class="s0">redrawTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(drawAnimationFrameID === </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">drawAnimationFrameID = requestAnimationFrame(prepareToDraw);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">prepareToDraw() {</span>
  <span class="s0">drawAnimationFrameID = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">redrawTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">now = getCurrentTime();</span>
  <span class="s1">var </span><span class="s0">earliestExpiration = Number.MAX_VALUE; </span><span class="s3">// Remove any items that have already expired.</span>

  <span class="s0">nodeToData.forEach(</span><span class="s1">function </span><span class="s0">(data, node) {</span>
    <span class="s1">if </span><span class="s0">(data.expirationTime &lt; now) {</span>
      <span class="s0">nodeToData.</span><span class="s1">delete</span><span class="s0">(node);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">earliestExpiration = Math.min(earliestExpiration, data.expirationTime);</span>
    <span class="s0">}</span>
  <span class="s0">});</span>
  <span class="s0">draw(nodeToData, agent);</span>

  <span class="s1">if </span><span class="s0">(earliestExpiration !== Number.MAX_VALUE) {</span>
    <span class="s0">redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">measureNode(node) {</span>
  <span class="s1">if </span><span class="s0">(!node || </span><span class="s1">typeof </span><span class="s0">node.getBoundingClientRect !== </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;</span>
  <span class="s1">return </span><span class="s0">getNestedBoundingClientRect(node, currentWindow);</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../../node_modules/compare-versions/lib/esm/index.js</span>
<span class="s1">function </span><span class="s0">esm_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { esm_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ esm_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">esm_typeof(obj); }</span>

<span class="s1">function </span><span class="s0">_slicedToArray(arr, i) { </span><span class="s1">return </span><span class="s0">_arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }</span>

<span class="s1">function </span><span class="s0">_nonIterableRest() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to destructure non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">_unsupportedIterableToArray(o, minLen) { </span><span class="s1">if </span><span class="s0">(!o) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">o === </span><span class="s2">&quot;string&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">_arrayLikeToArray(o, minLen); </span><span class="s1">var </span><span class="s0">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s0">&amp;&amp; o.constructor) n = o.constructor.name; </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s0">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">Array.from(o); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s0">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s0">|</span><span class="s4">16</span><span class="s0">|</span><span class="s4">32</span><span class="s0">)(?:Clamped)?Array$/.test(n)) </span><span class="s1">return </span><span class="s0">_arrayLikeToArray(o, minLen); }</span>

<span class="s1">function </span><span class="s0">_arrayLikeToArray(arr, len) { </span><span class="s1">if </span><span class="s0">(len == </span><span class="s1">null </span><span class="s0">|| len &gt; arr.length) len = arr.length; </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, arr2 = </span><span class="s1">new </span><span class="s0">Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } </span><span class="s1">return </span><span class="s0">arr2; }</span>

<span class="s1">function </span><span class="s0">_iterableToArrayLimit(arr, i) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">|| !(Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(arr))) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_arr = []; </span><span class="s1">var </span><span class="s0">_n = </span><span class="s1">true</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_d = </span><span class="s1">false</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_e = undefined; </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = </span><span class="s1">true</span><span class="s0">) { _arr.push(_s.value); </span><span class="s1">if </span><span class="s0">(i &amp;&amp; _arr.length === i) </span><span class="s1">break</span><span class="s0">; } } </span><span class="s1">catch </span><span class="s0">(err) { _d = </span><span class="s1">true</span><span class="s0">; _e = err; } </span><span class="s1">finally </span><span class="s0">{ </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(!_n &amp;&amp; _i[</span><span class="s2">&quot;return&quot;</span><span class="s0">] != </span><span class="s1">null</span><span class="s0">) _i[</span><span class="s2">&quot;return&quot;</span><span class="s0">](); } </span><span class="s1">finally </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(_d) </span><span class="s1">throw </span><span class="s0">_e; } } </span><span class="s1">return </span><span class="s0">_arr; }</span>

<span class="s1">function </span><span class="s0">_arrayWithHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">arr; }</span>

<span class="s3">/** 
 * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser. 
 * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`. 
 * @param v1 - First version to compare 
 * @param v2 - Second version to compare 
 * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters). 
 */</span>
<span class="s1">var </span><span class="s0">compareVersions = </span><span class="s1">function </span><span class="s0">compareVersions(v1, v2) {</span>
  <span class="s3">// validate input and split into segments</span>
  <span class="s1">var </span><span class="s0">n1 = validateAndParse(v1);</span>
  <span class="s1">var </span><span class="s0">n2 = validateAndParse(v2); </span><span class="s3">// pop off the patch</span>

  <span class="s1">var </span><span class="s0">p1 = n1.pop();</span>
  <span class="s1">var </span><span class="s0">p2 = n2.pop(); </span><span class="s3">// validate numbers</span>

  <span class="s1">var </span><span class="s0">r = compareSegments(n1, n2);</span>
  <span class="s1">if </span><span class="s0">(r !== </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">r; </span><span class="s3">// validate pre-release</span>

  <span class="s1">if </span><span class="s0">(p1 &amp;&amp; p2) {</span>
    <span class="s1">return </span><span class="s0">compareSegments(p1.split(</span><span class="s2">'.'</span><span class="s0">), p2.split(</span><span class="s2">'.'</span><span class="s0">));</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(p1 || p2) {</span>
    <span class="s1">return </span><span class="s0">p1 ? -</span><span class="s4">1 </span><span class="s0">: </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s3">/** 
 * Validate [semver](https://semver.org/) version strings. 
 * 
 * @param version Version number to validate 
 * @returns `true` if the version number is a valid semver version number, `false` otherwise. 
 * 
 * @example 
 * ``` 
 * validate('1.0.0-rc.1'); // return true 
 * validate('1.0-rc.1'); // return false 
 * validate('foo'); // return false 
 * ``` 
 */</span>

<span class="s1">var </span><span class="s0">validate = </span><span class="s1">function </span><span class="s0">validate(version) {</span>
  <span class="s1">return typeof </span><span class="s0">version === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; /^[v\d]/.test(version) &amp;&amp; semver.test(version);</span>
<span class="s0">};</span>
<span class="s3">/** 
 * Compare [semver](https://semver.org/) version strings using the specified operator. 
 * 
 * @param v1 First version to compare 
 * @param v2 Second version to compare 
 * @param operator Allowed arithmetic operator to use 
 * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise. 
 * 
 * @example 
 * ``` 
 * compare('10.1.8', '10.0.4', '&gt;'); // return true 
 * compare('10.0.1', '10.0.1', '='); // return true 
 * compare('10.1.1', '10.2.2', '&lt;'); // return true 
 * compare('10.1.1', '10.2.2', '&lt;='); // return true 
 * compare('10.1.1', '10.2.2', '&gt;='); // return false 
 * ``` 
 */</span>

<span class="s1">var </span><span class="s0">compare = </span><span class="s1">function </span><span class="s0">compare(v1, v2, operator) {</span>
  <span class="s3">// validate input operator</span>
  <span class="s0">assertValidOperator(operator); </span><span class="s3">// since result of compareVersions can only be -1 or 0 or 1</span>
  <span class="s3">// a simple map can be used to replace switch</span>

  <span class="s1">var </span><span class="s0">res = compareVersions(v1, v2);</span>
  <span class="s1">return </span><span class="s0">operatorResMap[operator].includes(res);</span>
<span class="s0">};</span>
<span class="s3">/** 
 * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range. 
 * 
 * @param version Version number to match 
 * @param range Range pattern for version 
 * @returns `true` if the version number is within the range, `false` otherwise. 
 * 
 * @example 
 * ``` 
 * satisfies('1.1.0', '^1.0.0'); // return true 
 * satisfies('1.1.0', '~1.0.0'); // return false 
 * ``` 
 */</span>

<span class="s1">var </span><span class="s0">satisfies = </span><span class="s1">function </span><span class="s0">satisfies(version, range) {</span>
  <span class="s3">// if no range operator then &quot;=&quot;</span>
  <span class="s1">var </span><span class="s0">m = range.match(/^([&lt;&gt;=~^]+)/);</span>
  <span class="s1">var </span><span class="s0">op = m ? m[</span><span class="s4">1</span><span class="s0">] : </span><span class="s2">'='</span><span class="s0">; </span><span class="s3">// if gt/lt/eq then operator compare</span>

  <span class="s1">if </span><span class="s0">(op !== </span><span class="s2">'^' </span><span class="s0">&amp;&amp; op !== </span><span class="s2">'~'</span><span class="s0">) </span><span class="s1">return </span><span class="s0">compare(version, range, op); </span><span class="s3">// else range of either &quot;~&quot; or &quot;^&quot; is assumed</span>

  <span class="s1">var </span><span class="s0">_validateAndParse = validateAndParse(version),</span>
      <span class="s0">_validateAndParse2 = _slicedToArray(_validateAndParse, </span><span class="s4">5</span><span class="s0">),</span>
      <span class="s0">v1 = _validateAndParse2[</span><span class="s4">0</span><span class="s0">],</span>
      <span class="s0">v2 = _validateAndParse2[</span><span class="s4">1</span><span class="s0">],</span>
      <span class="s0">v3 = _validateAndParse2[</span><span class="s4">2</span><span class="s0">],</span>
      <span class="s0">vp = _validateAndParse2[</span><span class="s4">4</span><span class="s0">];</span>

  <span class="s1">var </span><span class="s0">_validateAndParse3 = validateAndParse(range),</span>
      <span class="s0">_validateAndParse4 = _slicedToArray(_validateAndParse3, </span><span class="s4">5</span><span class="s0">),</span>
      <span class="s0">r1 = _validateAndParse4[</span><span class="s4">0</span><span class="s0">],</span>
      <span class="s0">r2 = _validateAndParse4[</span><span class="s4">1</span><span class="s0">],</span>
      <span class="s0">r3 = _validateAndParse4[</span><span class="s4">2</span><span class="s0">],</span>
      <span class="s0">rp = _validateAndParse4[</span><span class="s4">4</span><span class="s0">];</span>

  <span class="s1">var </span><span class="s0">v = [v1, v2, v3];</span>
  <span class="s1">var </span><span class="s0">r = [r1, r2 !== </span><span class="s1">null </span><span class="s0">&amp;&amp; r2 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? r2 : </span><span class="s2">'x'</span><span class="s0">, r3 !== </span><span class="s1">null </span><span class="s0">&amp;&amp; r3 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? r3 : </span><span class="s2">'x'</span><span class="s0">]; </span><span class="s3">// validate pre-release</span>

  <span class="s1">if </span><span class="s0">(rp) {</span>
    <span class="s1">if </span><span class="s0">(!vp) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(compareSegments(v, r) !== </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(compareSegments(vp.split(</span><span class="s2">'.'</span><span class="s0">), rp.split(</span><span class="s2">'.'</span><span class="s0">)) === -</span><span class="s4">1</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// first non-zero number</span>


  <span class="s1">var </span><span class="s0">nonZero = r.findIndex(</span><span class="s1">function </span><span class="s0">(v) {</span>
    <span class="s1">return </span><span class="s0">v !== </span><span class="s2">'0'</span><span class="s0">;</span>
  <span class="s0">}) + </span><span class="s4">1</span><span class="s0">; </span><span class="s3">// pointer to where segments can be &gt;=</span>

  <span class="s1">var </span><span class="s0">i = op === </span><span class="s2">'~' </span><span class="s0">? </span><span class="s4">2 </span><span class="s0">: nonZero &gt; </span><span class="s4">1 </span><span class="s0">? nonZero : </span><span class="s4">1</span><span class="s0">; </span><span class="s3">// before pointer must be equal</span>

  <span class="s1">if </span><span class="s0">(compareSegments(v.slice(</span><span class="s4">0</span><span class="s0">, i), r.slice(</span><span class="s4">0</span><span class="s0">, i)) !== </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">; </span><span class="s3">// after pointer must be &gt;=</span>

  <span class="s1">if </span><span class="s0">(compareSegments(v.slice(i), r.slice(i)) === -</span><span class="s4">1</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
  <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">semver = /^[v^~&lt;&gt;=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;</span>

<span class="s1">var </span><span class="s0">validateAndParse = </span><span class="s1">function </span><span class="s0">validateAndParse(version) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">version !== </span><span class="s2">'string'</span><span class="s0">) {</span>
    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Invalid argument expected string'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">match = version.match(semver);</span>

  <span class="s1">if </span><span class="s0">(!match) {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Invalid argument not valid semver ('&quot;</span><span class="s0">.concat(version, </span><span class="s2">&quot;' received)&quot;</span><span class="s0">));</span>
  <span class="s0">}</span>

  <span class="s0">match.shift();</span>
  <span class="s1">return </span><span class="s0">match;</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">isWildcard = </span><span class="s1">function </span><span class="s0">isWildcard(s) {</span>
  <span class="s1">return </span><span class="s0">s === </span><span class="s2">'*' </span><span class="s0">|| s === </span><span class="s2">'x' </span><span class="s0">|| s === </span><span class="s2">'X'</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">tryParse = </span><span class="s1">function </span><span class="s0">tryParse(v) {</span>
  <span class="s1">var </span><span class="s0">n = parseInt(v, </span><span class="s4">10</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">isNaN(n) ? v : n;</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">forceType = </span><span class="s1">function </span><span class="s0">forceType(a, b) {</span>
  <span class="s1">return </span><span class="s0">esm_typeof(a) !== esm_typeof(b) ? [String(a), String(b)] : [a, b];</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">compareStrings = </span><span class="s1">function </span><span class="s0">compareStrings(a, b) {</span>
  <span class="s1">if </span><span class="s0">(isWildcard(a) || isWildcard(b)) </span><span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">var </span><span class="s0">_forceType = forceType(tryParse(a), tryParse(b)),</span>
      <span class="s0">_forceType2 = _slicedToArray(_forceType, </span><span class="s4">2</span><span class="s0">),</span>
      <span class="s0">ap = _forceType2[</span><span class="s4">0</span><span class="s0">],</span>
      <span class="s0">bp = _forceType2[</span><span class="s4">1</span><span class="s0">];</span>

  <span class="s1">if </span><span class="s0">(ap &gt; bp) </span><span class="s1">return </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">if </span><span class="s0">(ap &lt; bp) </span><span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">compareSegments = </span><span class="s1">function </span><span class="s0">compareSegments(a, b) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; Math.max(a.length, b.length); i++) {</span>
    <span class="s1">var </span><span class="s0">r = compareStrings(a[i] || </span><span class="s2">'0'</span><span class="s0">, b[i] || </span><span class="s2">'0'</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(r !== </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">r;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">operatorResMap = {</span>
  <span class="s2">'&gt;'</span><span class="s0">: [</span><span class="s4">1</span><span class="s0">],</span>
  <span class="s2">'&gt;='</span><span class="s0">: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">],</span>
  <span class="s2">'='</span><span class="s0">: [</span><span class="s4">0</span><span class="s0">],</span>
  <span class="s2">'&lt;='</span><span class="s0">: [-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">],</span>
  <span class="s2">'&lt;'</span><span class="s0">: [-</span><span class="s4">1</span><span class="s0">]</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">allowedOperators = Object.keys(operatorResMap);</span>

<span class="s1">var </span><span class="s0">assertValidOperator = </span><span class="s1">function </span><span class="s0">assertValidOperator(op) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">op !== </span><span class="s2">'string'</span><span class="s0">) {</span>
    <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid operator type, expected string but got &quot;</span><span class="s0">.concat(esm_typeof(op)));</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(allowedOperators.indexOf(op) === -</span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Invalid operator, expected one of &quot;</span><span class="s0">.concat(allowedOperators.join(</span><span class="s2">'|'</span><span class="s0">)));</span>
  <span class="s0">}</span>
<span class="s0">};</span>
<span class="s3">// EXTERNAL MODULE: ../../node_modules/lru-cache/index.js</span>
<span class="s1">var </span><span class="s0">lru_cache = __webpack_require__(</span><span class="s4">730</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">lru_cache_default = </span><span class="s3">/*#__PURE__*/</span><span class="s0">__webpack_require__.n(lru_cache);</span>
<span class="s3">// EXTERNAL MODULE: ../../build/oss-experimental/react-is/index.js</span>
<span class="s1">var </span><span class="s0">react_is = __webpack_require__(</span><span class="s4">550</span><span class="s0">);</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../shared/ReactSymbols.js</span>
<span class="s1">function </span><span class="s0">ReactSymbols_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { ReactSymbols_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ ReactSymbols_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">ReactSymbols_typeof(obj); }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s3">// ATTENTION</span>
<span class="s3">// When adding new symbols to this file,</span>
<span class="s3">// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'</span>
<span class="s3">// The Symbol used to tag the ReactElement-like types.</span>
<span class="s1">var </span><span class="s0">REACT_ELEMENT_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.element'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_PORTAL_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.portal'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_FRAGMENT_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.fragment'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_STRICT_MODE_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.strict_mode'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_PROFILER_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.profiler'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_PROVIDER_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.provider'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_CONTEXT_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.context'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_SERVER_CONTEXT_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.server_context'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_FORWARD_REF_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.forward_ref'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_SUSPENSE_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.suspense'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_SUSPENSE_LIST_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.suspense_list'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_MEMO_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.memo'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_LAZY_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.lazy'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_SCOPE_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.scope'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_DEBUG_TRACING_MODE_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.debug_trace_mode'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_OFFSCREEN_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.offscreen'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_LEGACY_HIDDEN_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.legacy_hidden'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_CACHE_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.cache'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_TRACING_MARKER_TYPE = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.tracing_marker'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.default_value'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">REACT_MEMO_CACHE_SENTINEL = Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">'react.memo_cache_sentinel'</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
<span class="s1">var </span><span class="s0">FAUX_ITERATOR_SYMBOL = </span><span class="s2">'@@iterator'</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">getIteratorFn(maybeIterable) {</span>
  <span class="s1">if </span><span class="s0">(maybeIterable === </span><span class="s1">null </span><span class="s0">|| ReactSymbols_typeof(maybeIterable) !== </span><span class="s2">'object'</span><span class="s0">) {</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">maybeIterator = MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">maybeIterator === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">maybeIterator;</span>
  <span class="s0">}</span>

  <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/types.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s3">/** 
 * WARNING: 
 * This file contains types that are designed for React DevTools UI and how it interacts with the backend. 
 * They might be used in different versions of DevTools backends. 
 * Be mindful of backwards compatibility when making changes. 
 */</span>
<span class="s3">// WARNING</span>
<span class="s3">// The values below are referenced by ComponentFilters (which are saved via localStorage).</span>
<span class="s3">// Do not change them or it will break previously saved user customizations.</span>
<span class="s3">// If new element types are added, use new numbers rather than re-ordering existing ones.</span>
<span class="s3">//</span>
<span class="s3">// Changing these types is also a backwards breaking change for the standalone shell,</span>
<span class="s3">// since the frontend and backend must share the same values-</span>
<span class="s3">// and the backend is embedded in certain environments (like React Native).</span>
<span class="s1">var </span><span class="s0">types_ElementTypeClass = </span><span class="s4">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ElementTypeContext = </span><span class="s4">2</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">types_ElementTypeFunction = </span><span class="s4">5</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">types_ElementTypeForwardRef = </span><span class="s4">6</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ElementTypeHostComponent = </span><span class="s4">7</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">types_ElementTypeMemo = </span><span class="s4">8</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ElementTypeOtherOrUnknown = </span><span class="s4">9</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ElementTypeProfiler = </span><span class="s4">10</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ElementTypeRoot = </span><span class="s4">11</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ElementTypeSuspense = </span><span class="s4">12</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ElementTypeSuspenseList = </span><span class="s4">13</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ElementTypeTracingMarker = </span><span class="s4">14</span><span class="s0">; </span><span class="s3">// Different types of elements displayed in the Elements tree.</span>
<span class="s3">// These types may be used to visually distinguish types,</span>
<span class="s3">// or to enable/disable certain functionality.</span>

<span class="s3">// WARNING</span>
<span class="s3">// The values below are referenced by ComponentFilters (which are saved via localStorage).</span>
<span class="s3">// Do not change them or it will break previously saved user customizations.</span>
<span class="s3">// If new filter types are added, use new numbers rather than re-ordering existing ones.</span>
<span class="s1">var </span><span class="s0">ComponentFilterElementType = </span><span class="s4">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ComponentFilterDisplayName = </span><span class="s4">2</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ComponentFilterLocation = </span><span class="s4">3</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ComponentFilterHOC = </span><span class="s4">4</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">StrictMode = </span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/isArray.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s1">var </span><span class="s0">isArray = Array.isArray;</span>
<span class="s3">/* harmony default export */ </span><span class="s0">const src_isArray = (isArray);</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/utils.js</span>
<span class="s3">/* provided dependency */ </span><span class="s1">var </span><span class="s0">process = __webpack_require__(</span><span class="s4">169</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">utils_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { utils_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ utils_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">utils_typeof(obj); }</span>

<span class="s1">function </span><span class="s0">_toConsumableArray(arr) { </span><span class="s1">return </span><span class="s0">_arrayWithoutHoles(arr) || _iterableToArray(arr) || utils_unsupportedIterableToArray(arr) || _nonIterableSpread(); }</span>

<span class="s1">function </span><span class="s0">_nonIterableSpread() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to spread non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">utils_unsupportedIterableToArray(o, minLen) { </span><span class="s1">if </span><span class="s0">(!o) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">o === </span><span class="s2">&quot;string&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">utils_arrayLikeToArray(o, minLen); </span><span class="s1">var </span><span class="s0">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s0">&amp;&amp; o.constructor) n = o.constructor.name; </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s0">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">Array.from(o); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s0">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s0">|</span><span class="s4">16</span><span class="s0">|</span><span class="s4">32</span><span class="s0">)(?:Clamped)?Array$/.test(n)) </span><span class="s1">return </span><span class="s0">utils_arrayLikeToArray(o, minLen); }</span>

<span class="s1">function </span><span class="s0">_iterableToArray(iter) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">&amp;&amp; Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(iter)) </span><span class="s1">return </span><span class="s0">Array.from(iter); }</span>

<span class="s1">function </span><span class="s0">_arrayWithoutHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">utils_arrayLikeToArray(arr); }</span>

<span class="s1">function </span><span class="s0">utils_arrayLikeToArray(arr, len) { </span><span class="s1">if </span><span class="s0">(len == </span><span class="s1">null </span><span class="s0">|| len &gt; arr.length) len = arr.length; </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, arr2 = </span><span class="s1">new </span><span class="s0">Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } </span><span class="s1">return </span><span class="s0">arr2; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>









<span class="s3">// $FlowFixMe[method-unbinding]</span>
<span class="s1">var </span><span class="s0">utils_hasOwnProperty = Object.prototype.hasOwnProperty;</span>
<span class="s1">var </span><span class="s0">cachedDisplayNames = </span><span class="s1">new </span><span class="s0">WeakMap(); </span><span class="s3">// On large trees, encoding takes significant time.</span>
<span class="s3">// Try to reuse the already encoded strings.</span>

<span class="s1">var </span><span class="s0">encodedStringCache = </span><span class="s1">new </span><span class="s0">(lru_cache_default())({</span>
  <span class="s0">max: </span><span class="s4">1000</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">alphaSortKeys(a, b) {</span>
  <span class="s1">if </span><span class="s0">(a.toString() &gt; b.toString()) {</span>
    <span class="s1">return </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(b.toString() &gt; a.toString()) {</span>
    <span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getAllEnumerableKeys(obj) {</span>
  <span class="s1">var </span><span class="s0">keys = </span><span class="s1">new </span><span class="s0">Set();</span>
  <span class="s1">var </span><span class="s0">current = obj;</span>

  <span class="s1">var </span><span class="s0">_loop = </span><span class="s1">function </span><span class="s0">_loop() {</span>
    <span class="s1">var </span><span class="s0">currentKeys = [].concat(_toConsumableArray(Object.keys(current)), _toConsumableArray(Object.getOwnPropertySymbols(current)));</span>
    <span class="s1">var </span><span class="s0">descriptors = Object.getOwnPropertyDescriptors(current);</span>
    <span class="s0">currentKeys.forEach(</span><span class="s1">function </span><span class="s0">(key) {</span>
      <span class="s3">// $FlowFixMe[incompatible-type]: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor</span>
      <span class="s1">if </span><span class="s0">(descriptors[key].enumerable) {</span>
        <span class="s0">keys.add(key);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">current = Object.getPrototypeOf(current);</span>
  <span class="s0">};</span>

  <span class="s1">while </span><span class="s0">(current != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">_loop();</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">keys;</span>
<span class="s0">} </span><span class="s3">// Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37</span>

<span class="s1">function </span><span class="s0">getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {</span>
  <span class="s1">var </span><span class="s0">displayName = outerType.displayName;</span>
  <span class="s1">return </span><span class="s0">displayName || </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(wrapperName, </span><span class="s2">&quot;(&quot;</span><span class="s0">).concat(getDisplayName(innerType, fallbackName), </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getDisplayName(type) {</span>
  <span class="s1">var </span><span class="s0">fallbackName = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : </span><span class="s2">'Anonymous'</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">nameFromCache = cachedDisplayNames.get(type);</span>

  <span class="s1">if </span><span class="s0">(nameFromCache != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">nameFromCache;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">displayName = fallbackName; </span><span class="s3">// The displayName property is not guaranteed to be a string.</span>
  <span class="s3">// It's only safe to use for our purposes if it's a string.</span>
  <span class="s3">// github.com/facebook/react-devtools/issues/803</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">type.displayName === </span><span class="s2">'string'</span><span class="s0">) {</span>
    <span class="s0">displayName = type.displayName;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">type.name === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; type.name !== </span><span class="s2">''</span><span class="s0">) {</span>
    <span class="s0">displayName = type.name;</span>
  <span class="s0">}</span>

  <span class="s0">cachedDisplayNames.set(type, displayName);</span>
  <span class="s1">return </span><span class="s0">displayName;</span>
<span class="s0">}</span>
<span class="s1">var </span><span class="s0">uidCounter = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">getUID() {</span>
  <span class="s1">return </span><span class="s0">++uidCounter;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">utfDecodeString(array) {</span>
  <span class="s3">// Avoid spreading the array (e.g. String.fromCodePoint(...array))</span>
  <span class="s3">// Functions arguments are first placed on the stack before the function is called</span>
  <span class="s3">// which throws a RangeError for large arrays.</span>
  <span class="s3">// See github.com/facebook/react/issues/22293</span>
  <span class="s1">var </span><span class="s0">string = </span><span class="s2">''</span><span class="s0">;</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; array.length; i++) {</span>
    <span class="s1">var </span><span class="s0">char = array[i];</span>
    <span class="s0">string += String.fromCodePoint(char);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">string;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">surrogatePairToCodePoint(charCode1, charCode2) {</span>
  <span class="s1">return </span><span class="s0">((charCode1 &amp; </span><span class="s4">0</span><span class="s0">x3ff) &lt;&lt; </span><span class="s4">10</span><span class="s0">) + (charCode2 &amp; </span><span class="s4">0</span><span class="s0">x3ff) + </span><span class="s4">0</span><span class="s0">x10000;</span>
<span class="s0">} </span><span class="s3">// Credit for this encoding approach goes to Tim Down:</span>
<span class="s3">// https://stackoverflow.com/questions/4877326/how-can-i-tell-if-a-string-contains-multibyte-characters-in-javascript</span>


<span class="s1">function </span><span class="s0">utfEncodeString(string) {</span>
  <span class="s1">var </span><span class="s0">cached = encodedStringCache.get(string);</span>

  <span class="s1">if </span><span class="s0">(cached !== undefined) {</span>
    <span class="s1">return </span><span class="s0">cached;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">encoded = [];</span>
  <span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">charCode;</span>

  <span class="s1">while </span><span class="s0">(i &lt; string.length) {</span>
    <span class="s0">charCode = string.charCodeAt(i); </span><span class="s3">// Handle multibyte unicode characters (like emoji).</span>

    <span class="s1">if </span><span class="s0">((charCode &amp; </span><span class="s4">0</span><span class="s0">xf800) === </span><span class="s4">0</span><span class="s0">xd800) {</span>
      <span class="s0">encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">encoded.push(charCode);</span>
    <span class="s0">}</span>

    <span class="s0">++i;</span>
  <span class="s0">}</span>

  <span class="s0">encodedStringCache.set(string, encoded);</span>
  <span class="s1">return </span><span class="s0">encoded;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">printOperationsArray(operations) {</span>
  <span class="s3">// The first two values are always rendererID and rootID</span>
  <span class="s1">var </span><span class="s0">rendererID = operations[</span><span class="s4">0</span><span class="s0">];</span>
  <span class="s1">var </span><span class="s0">rootID = operations[</span><span class="s4">1</span><span class="s0">];</span>
  <span class="s1">var </span><span class="s0">logs = [</span><span class="s2">&quot;operations for renderer:&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot; and root:&quot;</span><span class="s0">).concat(rootID)];</span>
  <span class="s1">var </span><span class="s0">i = </span><span class="s4">2</span><span class="s0">; </span><span class="s3">// Reassemble the string table.</span>

  <span class="s1">var </span><span class="s0">stringTable = [</span><span class="s1">null </span><span class="s3">// ID = 0 corresponds to the null string.</span>
  <span class="s0">];</span>
  <span class="s1">var </span><span class="s0">stringTableSize = operations[i++];</span>
  <span class="s1">var </span><span class="s0">stringTableEnd = i + stringTableSize;</span>

  <span class="s1">while </span><span class="s0">(i &lt; stringTableEnd) {</span>
    <span class="s1">var </span><span class="s0">nextLength = operations[i++];</span>
    <span class="s1">var </span><span class="s0">nextString = utfDecodeString(operations.slice(i, i + nextLength));</span>
    <span class="s0">stringTable.push(nextString);</span>
    <span class="s0">i += nextLength;</span>
  <span class="s0">}</span>

  <span class="s1">while </span><span class="s0">(i &lt; operations.length) {</span>
    <span class="s1">var </span><span class="s0">operation = operations[i];</span>

    <span class="s1">switch </span><span class="s0">(operation) {</span>
      <span class="s1">case </span><span class="s0">TREE_OPERATION_ADD:</span>
        <span class="s0">{</span>
          <span class="s1">var </span><span class="s0">_id = operations[i + </span><span class="s4">1</span><span class="s0">];</span>
          <span class="s1">var </span><span class="s0">type = operations[i + </span><span class="s4">2</span><span class="s0">];</span>
          <span class="s0">i += </span><span class="s4">3</span><span class="s0">;</span>

          <span class="s1">if </span><span class="s0">(type === ElementTypeRoot) {</span>
            <span class="s0">logs.push(</span><span class="s2">&quot;Add new root node &quot;</span><span class="s0">.concat(_id));</span>
            <span class="s0">i++; </span><span class="s3">// isStrictModeCompliant</span>

            <span class="s0">i++; </span><span class="s3">// supportsProfiling</span>

            <span class="s0">i++; </span><span class="s3">// supportsStrictMode</span>

            <span class="s0">i++; </span><span class="s3">// hasOwnerMetadata</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">var </span><span class="s0">parentID = operations[i];</span>
            <span class="s0">i++;</span>
            <span class="s0">i++; </span><span class="s3">// ownerID</span>

            <span class="s1">var </span><span class="s0">displayNameStringID = operations[i];</span>
            <span class="s1">var </span><span class="s0">displayName = stringTable[displayNameStringID];</span>
            <span class="s0">i++;</span>
            <span class="s0">i++; </span><span class="s3">// key</span>

            <span class="s0">logs.push(</span><span class="s2">&quot;Add node &quot;</span><span class="s0">.concat(_id, </span><span class="s2">&quot; (&quot;</span><span class="s0">).concat(displayName || </span><span class="s2">'null'</span><span class="s0">, </span><span class="s2">&quot;) as child of &quot;</span><span class="s0">).concat(parentID));</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>

      <span class="s1">case </span><span class="s0">TREE_OPERATION_REMOVE:</span>
        <span class="s0">{</span>
          <span class="s1">var </span><span class="s0">removeLength = operations[i + </span><span class="s4">1</span><span class="s0">];</span>
          <span class="s0">i += </span><span class="s4">2</span><span class="s0">;</span>

          <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">removeIndex = </span><span class="s4">0</span><span class="s0">; removeIndex &lt; removeLength; removeIndex++) {</span>
            <span class="s1">var </span><span class="s0">_id2 = operations[i];</span>
            <span class="s0">i += </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s0">logs.push(</span><span class="s2">&quot;Remove node &quot;</span><span class="s0">.concat(_id2));</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>

      <span class="s1">case </span><span class="s0">TREE_OPERATION_REMOVE_ROOT:</span>
        <span class="s0">{</span>
          <span class="s0">i += </span><span class="s4">1</span><span class="s0">;</span>
          <span class="s0">logs.push(</span><span class="s2">&quot;Remove root &quot;</span><span class="s0">.concat(rootID));</span>
          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>

      <span class="s1">case </span><span class="s0">TREE_OPERATION_SET_SUBTREE_MODE:</span>
        <span class="s0">{</span>
          <span class="s1">var </span><span class="s0">_id3 = operations[i + </span><span class="s4">1</span><span class="s0">];</span>
          <span class="s1">var </span><span class="s0">mode = operations[i + </span><span class="s4">1</span><span class="s0">];</span>
          <span class="s0">i += </span><span class="s4">3</span><span class="s0">;</span>
          <span class="s0">logs.push(</span><span class="s2">&quot;Mode &quot;</span><span class="s0">.concat(mode, </span><span class="s2">&quot; set for subtree with root &quot;</span><span class="s0">).concat(_id3));</span>
          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>

      <span class="s1">case </span><span class="s0">TREE_OPERATION_REORDER_CHILDREN:</span>
        <span class="s0">{</span>
          <span class="s1">var </span><span class="s0">_id4 = operations[i + </span><span class="s4">1</span><span class="s0">];</span>
          <span class="s1">var </span><span class="s0">numChildren = operations[i + </span><span class="s4">2</span><span class="s0">];</span>
          <span class="s0">i += </span><span class="s4">3</span><span class="s0">;</span>
          <span class="s1">var </span><span class="s0">children = operations.slice(i, i + numChildren);</span>
          <span class="s0">i += numChildren;</span>
          <span class="s0">logs.push(</span><span class="s2">&quot;Re-order node &quot;</span><span class="s0">.concat(_id4, </span><span class="s2">&quot; children &quot;</span><span class="s0">).concat(children.join(</span><span class="s2">','</span><span class="s0">)));</span>
          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>

      <span class="s1">case </span><span class="s0">TREE_OPERATION_UPDATE_TREE_BASE_DURATION:</span>
        <span class="s3">// Base duration updates are only sent while profiling is in progress.</span>
        <span class="s3">// We can ignore them at this point.</span>
        <span class="s3">// The profiler UI uses them lazily in order to generate the tree.</span>
        <span class="s0">i += </span><span class="s4">3</span><span class="s0">;</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:</span>
        <span class="s1">var </span><span class="s0">id = operations[i + </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">var </span><span class="s0">numErrors = operations[i + </span><span class="s4">2</span><span class="s0">];</span>
        <span class="s1">var </span><span class="s0">numWarnings = operations[i + </span><span class="s4">3</span><span class="s0">];</span>
        <span class="s0">i += </span><span class="s4">4</span><span class="s0">;</span>
        <span class="s0">logs.push(</span><span class="s2">&quot;Node &quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot; has &quot;</span><span class="s0">).concat(numErrors, </span><span class="s2">&quot; errors and &quot;</span><span class="s0">).concat(numWarnings, </span><span class="s2">&quot; warnings&quot;</span><span class="s0">));</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;Unsupported Bridge operation </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(operation, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">console.log(logs.join(</span><span class="s2">'</span><span class="s5">\n  </span><span class="s2">'</span><span class="s0">));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getDefaultComponentFilters() {</span>
  <span class="s1">return </span><span class="s0">[{</span>
    <span class="s0">type: ComponentFilterElementType,</span>
    <span class="s0">value: ElementTypeHostComponent,</span>
    <span class="s0">isEnabled: </span><span class="s1">true</span>
  <span class="s0">}];</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getSavedComponentFilters() {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">raw = localStorageGetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY);</span>

    <span class="s1">if </span><span class="s0">(raw != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">JSON.parse(raw);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>

  <span class="s1">return </span><span class="s0">getDefaultComponentFilters();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">setSavedComponentFilters(componentFilters) {</span>
  <span class="s0">localStorageSetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY, JSON.stringify(componentFilters));</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">parseBool(s) {</span>
  <span class="s1">if </span><span class="s0">(s === </span><span class="s2">'true'</span><span class="s0">) {</span>
    <span class="s1">return true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(s === </span><span class="s2">'false'</span><span class="s0">) {</span>
    <span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">castBool(v) {</span>
  <span class="s1">if </span><span class="s0">(v === </span><span class="s1">true </span><span class="s0">|| v === </span><span class="s1">false</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">v;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">castBrowserTheme(v) {</span>
  <span class="s1">if </span><span class="s0">(v === </span><span class="s2">'light' </span><span class="s0">|| v === </span><span class="s2">'dark' </span><span class="s0">|| v === </span><span class="s2">'auto'</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">v;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getAppendComponentStack() {</span>
  <span class="s1">var </span><span class="s0">_parseBool;</span>

  <span class="s1">var </span><span class="s0">raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY);</span>
  <span class="s1">return </span><span class="s0">(_parseBool = parseBool(raw)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _parseBool !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _parseBool : </span><span class="s1">true</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getBreakOnConsoleErrors() {</span>
  <span class="s1">var </span><span class="s0">_parseBool2;</span>

  <span class="s1">var </span><span class="s0">raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS);</span>
  <span class="s1">return </span><span class="s0">(_parseBool2 = parseBool(raw)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _parseBool2 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _parseBool2 : </span><span class="s1">false</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getHideConsoleLogsInStrictMode() {</span>
  <span class="s1">var </span><span class="s0">_parseBool3;</span>

  <span class="s1">var </span><span class="s0">raw = localStorageGetItem(LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE);</span>
  <span class="s1">return </span><span class="s0">(_parseBool3 = parseBool(raw)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _parseBool3 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _parseBool3 : </span><span class="s1">false</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getShowInlineWarningsAndErrors() {</span>
  <span class="s1">var </span><span class="s0">_parseBool4;</span>

  <span class="s1">var </span><span class="s0">raw = localStorageGetItem(LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY);</span>
  <span class="s1">return </span><span class="s0">(_parseBool4 = parseBool(raw)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _parseBool4 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _parseBool4 : </span><span class="s1">true</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getDefaultOpenInEditorURL() {</span>
  <span class="s1">return typeof </span><span class="s0">process.env.EDITOR_URL === </span><span class="s2">'string' </span><span class="s0">? process.env.EDITOR_URL : </span><span class="s2">''</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getOpenInEditorURL() {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">raw = localStorageGetItem(LOCAL_STORAGE_OPEN_IN_EDITOR_URL);</span>

    <span class="s1">if </span><span class="s0">(raw != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">JSON.parse(raw);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>

  <span class="s1">return </span><span class="s0">getDefaultOpenInEditorURL();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">separateDisplayNameAndHOCs(displayName, type) {</span>
  <span class="s1">if </span><span class="s0">(displayName === </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">[</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">];</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">hocDisplayNames = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">switch </span><span class="s0">(type) {</span>
    <span class="s1">case </span><span class="s0">ElementTypeClass:</span>
    <span class="s1">case </span><span class="s0">ElementTypeForwardRef:</span>
    <span class="s1">case </span><span class="s0">ElementTypeFunction:</span>
    <span class="s1">case </span><span class="s0">ElementTypeMemo:</span>
      <span class="s1">if </span><span class="s0">(displayName.indexOf(</span><span class="s2">'('</span><span class="s0">) &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">matches = displayName.match(/[^()]+/g);</span>

        <span class="s1">if </span><span class="s0">(matches != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">displayName = matches.pop();</span>
          <span class="s0">hocDisplayNames = matches;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">break</span><span class="s0">;</span>

    <span class="s1">default</span><span class="s0">:</span>
      <span class="s1">break</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">[displayName, hocDisplayNames];</span>
<span class="s0">} </span><span class="s3">// Pulled from react-compat</span>
<span class="s3">// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349</span>

<span class="s1">function </span><span class="s0">shallowDiffers(prev, next) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">attribute </span><span class="s1">in </span><span class="s0">prev) {</span>
    <span class="s1">if </span><span class="s0">(!(attribute </span><span class="s1">in </span><span class="s0">next)) {</span>
      <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_attribute </span><span class="s1">in </span><span class="s0">next) {</span>
    <span class="s1">if </span><span class="s0">(prev[_attribute] !== next[_attribute]) {</span>
      <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">utils_getInObject(object, path) {</span>
  <span class="s1">return </span><span class="s0">path.reduce(</span><span class="s1">function </span><span class="s0">(reduced, attr) {</span>
    <span class="s1">if </span><span class="s0">(reduced) {</span>
      <span class="s1">if </span><span class="s0">(utils_hasOwnProperty.call(reduced, attr)) {</span>
        <span class="s1">return </span><span class="s0">reduced[attr];</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">reduced[Symbol.iterator] === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s3">// Convert iterable to array and return array[index]</span>
        <span class="s3">//</span>
        <span class="s3">// TRICKY</span>
        <span class="s3">// Don't use [...spread] syntax for this purpose.</span>
        <span class="s3">// This project uses @babel/plugin-transform-spread in &quot;loose&quot; mode which only works with Array values.</span>
        <span class="s3">// Other types (e.g. typed arrays, Sets) will not spread correctly.</span>
        <span class="s1">return </span><span class="s0">Array.from(reduced)[attr];</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}, object);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">deletePathInObject(object, path) {</span>
  <span class="s1">var </span><span class="s0">length = path.length;</span>
  <span class="s1">var </span><span class="s0">last = path[length - </span><span class="s4">1</span><span class="s0">];</span>

  <span class="s1">if </span><span class="s0">(object != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">parent = utils_getInObject(object, path.slice(</span><span class="s4">0</span><span class="s0">, length - </span><span class="s4">1</span><span class="s0">));</span>

    <span class="s1">if </span><span class="s0">(parent) {</span>
      <span class="s1">if </span><span class="s0">(src_isArray(parent)) {</span>
        <span class="s0">parent.splice(last, </span><span class="s4">1</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">delete </span><span class="s0">parent[last];</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">renamePathInObject(object, oldPath, newPath) {</span>
  <span class="s1">var </span><span class="s0">length = oldPath.length;</span>

  <span class="s1">if </span><span class="s0">(object != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">parent = utils_getInObject(object, oldPath.slice(</span><span class="s4">0</span><span class="s0">, length - </span><span class="s4">1</span><span class="s0">));</span>

    <span class="s1">if </span><span class="s0">(parent) {</span>
      <span class="s1">var </span><span class="s0">lastOld = oldPath[length - </span><span class="s4">1</span><span class="s0">];</span>
      <span class="s1">var </span><span class="s0">lastNew = newPath[length - </span><span class="s4">1</span><span class="s0">];</span>
      <span class="s0">parent[lastNew] = parent[lastOld];</span>

      <span class="s1">if </span><span class="s0">(src_isArray(parent)) {</span>
        <span class="s0">parent.splice(lastOld, </span><span class="s4">1</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">delete </span><span class="s0">parent[lastOld];</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">utils_setInObject(object, path, value) {</span>
  <span class="s1">var </span><span class="s0">length = path.length;</span>
  <span class="s1">var </span><span class="s0">last = path[length - </span><span class="s4">1</span><span class="s0">];</span>

  <span class="s1">if </span><span class="s0">(object != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">parent = utils_getInObject(object, path.slice(</span><span class="s4">0</span><span class="s0">, length - </span><span class="s4">1</span><span class="s0">));</span>

    <span class="s1">if </span><span class="s0">(parent) {</span>
      <span class="s0">parent[last] = value;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">/** 
 * Get a enhanced/artificial type string based on the object instance 
 */</span>
<span class="s1">function </span><span class="s0">getDataType(data) {</span>
  <span class="s1">if </span><span class="s0">(data === </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">'null'</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(data === undefined) {</span>
    <span class="s1">return </span><span class="s2">'undefined'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">,react_is.isElement)(data)) {</span>
    <span class="s1">return </span><span class="s2">'react_element'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">HTMLElement !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; data </span><span class="s1">instanceof </span><span class="s0">HTMLElement) {</span>
    <span class="s1">return </span><span class="s2">'html_element'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">type = utils_typeof(data);</span>

  <span class="s1">switch </span><span class="s0">(type) {</span>
    <span class="s1">case </span><span class="s2">'bigint'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">'bigint'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">'boolean'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">'boolean'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">'function'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">'function'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">'number'</span><span class="s0">:</span>
      <span class="s1">if </span><span class="s0">(Number.isNaN(data)) {</span>
        <span class="s1">return </span><span class="s2">'nan'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!Number.isFinite(data)) {</span>
        <span class="s1">return </span><span class="s2">'infinity'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s2">'number'</span><span class="s0">;</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'object'</span><span class="s0">:</span>
      <span class="s1">if </span><span class="s0">(src_isArray(data)) {</span>
        <span class="s1">return </span><span class="s2">'array'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ArrayBuffer.isView(data)) {</span>
        <span class="s1">return </span><span class="s0">utils_hasOwnProperty.call(data.constructor, </span><span class="s2">'BYTES_PER_ELEMENT'</span><span class="s0">) ? </span><span class="s2">'typed_array' </span><span class="s0">: </span><span class="s2">'data_view'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(data.constructor &amp;&amp; data.constructor.name === </span><span class="s2">'ArrayBuffer'</span><span class="s0">) {</span>
        <span class="s3">// HACK This ArrayBuffer check is gross; is there a better way?</span>
        <span class="s3">// We could try to create a new DataView with the value.</span>
        <span class="s3">// If it doesn't error, we know it's an ArrayBuffer,</span>
        <span class="s3">// but this seems kind of awkward and expensive.</span>
        <span class="s1">return </span><span class="s2">'array_buffer'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">data[Symbol.iterator] === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">iterator = data[Symbol.iterator]();</span>

        <span class="s1">if </span><span class="s0">(!iterator) {</span><span class="s3">// Proxies might break assumptoins about iterators.</span>
          <span class="s3">// See github.com/facebook/react/issues/21654</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">return </span><span class="s0">iterator === data ? </span><span class="s2">'opaque_iterator' </span><span class="s0">: </span><span class="s2">'iterator'</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(data.constructor &amp;&amp; data.constructor.name === </span><span class="s2">'RegExp'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s2">'regexp'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// $FlowFixMe[method-unbinding]</span>
        <span class="s1">var </span><span class="s0">toStringValue = Object.prototype.toString.call(data);</span>

        <span class="s1">if </span><span class="s0">(toStringValue === </span><span class="s2">'[object Date]'</span><span class="s0">) {</span>
          <span class="s1">return </span><span class="s2">'date'</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(toStringValue === </span><span class="s2">'[object HTMLAllCollection]'</span><span class="s0">) {</span>
          <span class="s1">return </span><span class="s2">'html_all_collection'</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(!isPlainObject(data)) {</span>
        <span class="s1">return </span><span class="s2">'class_instance'</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s2">'object'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">'string'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">'string'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">'symbol'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">'symbol'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">'undefined'</span><span class="s0">:</span>
      <span class="s1">if </span><span class="s0">( </span><span class="s3">// $FlowFixMe[method-unbinding]</span>
      <span class="s0">Object.prototype.toString.call(data) === </span><span class="s2">'[object HTMLAllCollection]'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s2">'html_all_collection'</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s2">'undefined'</span><span class="s0">;</span>

    <span class="s1">default</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">'unknown'</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getDisplayNameForReactElement(element) {</span>
  <span class="s1">var </span><span class="s0">elementType = (</span><span class="s4">0</span><span class="s0">,react_is.typeOf)(element);</span>

  <span class="s1">switch </span><span class="s0">(elementType) {</span>
    <span class="s1">case </span><span class="s0">react_is.ContextConsumer:</span>
      <span class="s1">return </span><span class="s2">'ContextConsumer'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.ContextProvider:</span>
      <span class="s1">return </span><span class="s2">'ContextProvider'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.ForwardRef:</span>
      <span class="s1">return </span><span class="s2">'ForwardRef'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.Fragment:</span>
      <span class="s1">return </span><span class="s2">'Fragment'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.Lazy:</span>
      <span class="s1">return </span><span class="s2">'Lazy'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.Memo:</span>
      <span class="s1">return </span><span class="s2">'Memo'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.Portal:</span>
      <span class="s1">return </span><span class="s2">'Portal'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.Profiler:</span>
      <span class="s1">return </span><span class="s2">'Profiler'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.StrictMode:</span>
      <span class="s1">return </span><span class="s2">'StrictMode'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">react_is.Suspense:</span>
      <span class="s1">return </span><span class="s2">'Suspense'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">REACT_SUSPENSE_LIST_TYPE:</span>
      <span class="s1">return </span><span class="s2">'SuspenseList'</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s0">REACT_TRACING_MARKER_TYPE:</span>
      <span class="s1">return </span><span class="s2">'TracingMarker'</span><span class="s0">;</span>

    <span class="s1">default</span><span class="s0">:</span>
      <span class="s1">var </span><span class="s0">type = element.type;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">type === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">type;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">type === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">getDisplayName(type, </span><span class="s2">'Anonymous'</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(type != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s2">'NotImplementedInDevtools'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s2">'Element'</span><span class="s0">;</span>
      <span class="s0">}</span>

  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">var </span><span class="s0">MAX_PREVIEW_STRING_LENGTH = </span><span class="s4">50</span><span class="s0">;</span>

<span class="s1">function </span><span class="s0">truncateForDisplay(string) {</span>
  <span class="s1">var </span><span class="s0">length = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : MAX_PREVIEW_STRING_LENGTH;</span>

  <span class="s1">if </span><span class="s0">(string.length &gt; length) {</span>
    <span class="s1">return </span><span class="s0">string.slice(</span><span class="s4">0</span><span class="s0">, length) + </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">return </span><span class="s0">string;</span>
  <span class="s0">}</span>
<span class="s0">} </span><span class="s3">// Attempts to mimic Chrome's inline preview for values.</span>
<span class="s3">// For example, the following value...</span>
<span class="s3">//   {</span>
<span class="s3">//      foo: 123,</span>
<span class="s3">//      bar: &quot;abc&quot;,</span>
<span class="s3">//      baz: [true, false],</span>
<span class="s3">//      qux: { ab: 1, cd: 2 }</span>
<span class="s3">//   };</span>
<span class="s3">//</span>
<span class="s3">// Would show a preview of...</span>
<span class="s3">//   {foo: 123, bar: &quot;abc&quot;, baz: Array(2), qux: {}}</span>
<span class="s3">//</span>
<span class="s3">// And the following value...</span>
<span class="s3">//   [</span>
<span class="s3">//     123,</span>
<span class="s3">//     &quot;abc&quot;,</span>
<span class="s3">//     [true, false],</span>
<span class="s3">//     { foo: 123, bar: &quot;abc&quot; }</span>
<span class="s3">//   ];</span>
<span class="s3">//</span>
<span class="s3">// Would show a preview of...</span>
<span class="s3">//   [123, &quot;abc&quot;, Array(2), {}]</span>


<span class="s1">function </span><span class="s0">formatDataForPreview(data, showFormattedValue) {</span>
  <span class="s1">if </span><span class="s0">(data != </span><span class="s1">null </span><span class="s0">&amp;&amp; utils_hasOwnProperty.call(data, meta.type)) {</span>
    <span class="s1">return </span><span class="s0">showFormattedValue ? data[meta.preview_long] : data[meta.preview_short];</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">type = getDataType(data);</span>

  <span class="s1">switch </span><span class="s0">(type) {</span>
    <span class="s1">case </span><span class="s2">'html_element'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">&quot;&lt;&quot;</span><span class="s0">.concat(truncateForDisplay(data.tagName.toLowerCase()), </span><span class="s2">&quot; /&gt;&quot;</span><span class="s0">);</span>

    <span class="s1">case </span><span class="s2">'function'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">truncateForDisplay(</span><span class="s2">&quot;</span><span class="s5">\u0192 </span><span class="s2">&quot;</span><span class="s0">.concat(</span><span class="s1">typeof </span><span class="s0">data.name === </span><span class="s2">'function' </span><span class="s0">? </span><span class="s2">'' </span><span class="s0">: data.name, </span><span class="s2">&quot;() {}&quot;</span><span class="s0">));</span>

    <span class="s1">case </span><span class="s2">'string'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(data, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">);</span>

    <span class="s1">case </span><span class="s2">'bigint'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">truncateForDisplay(data.toString() + </span><span class="s2">'n'</span><span class="s0">);</span>

    <span class="s1">case </span><span class="s2">'regexp'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">truncateForDisplay(data.toString());</span>

    <span class="s1">case </span><span class="s2">'symbol'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">truncateForDisplay(data.toString());</span>

    <span class="s1">case </span><span class="s2">'react_element'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">&quot;&lt;&quot;</span><span class="s0">.concat(truncateForDisplay(getDisplayNameForReactElement(data) || </span><span class="s2">'Unknown'</span><span class="s0">), </span><span class="s2">&quot; /&gt;&quot;</span><span class="s0">);</span>

    <span class="s1">case </span><span class="s2">'array_buffer'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">&quot;ArrayBuffer(&quot;</span><span class="s0">.concat(data.byteLength, </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>

    <span class="s1">case </span><span class="s2">'data_view'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">&quot;DataView(&quot;</span><span class="s0">.concat(data.buffer.byteLength, </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>

    <span class="s1">case </span><span class="s2">'array'</span><span class="s0">:</span>
      <span class="s1">if </span><span class="s0">(showFormattedValue) {</span>
        <span class="s1">var </span><span class="s0">formatted = </span><span class="s2">''</span><span class="s0">;</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; data.length; i++) {</span>
          <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">formatted += </span><span class="s2">', '</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s0">formatted += formatDataForPreview(data[i], </span><span class="s1">false</span><span class="s0">);</span>

          <span class="s1">if </span><span class="s0">(formatted.length &gt; MAX_PREVIEW_STRING_LENGTH) {</span>
            <span class="s3">// Prevent doing a lot of unnecessary iteration...</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">&quot;[&quot;</span><span class="s0">.concat(truncateForDisplay(formatted), </span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">length = utils_hasOwnProperty.call(data, meta.size) ? data[meta.size] : data.length;</span>
        <span class="s1">return </span><span class="s2">&quot;Array(&quot;</span><span class="s0">.concat(length, </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'typed_array'</span><span class="s0">:</span>
      <span class="s1">var </span><span class="s0">shortName = </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(data.constructor.name, </span><span class="s2">&quot;(&quot;</span><span class="s0">).concat(data.length, </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(showFormattedValue) {</span>
        <span class="s1">var </span><span class="s0">_formatted = </span><span class="s2">''</span><span class="s0">;</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_i = </span><span class="s4">0</span><span class="s0">; _i &lt; data.length; _i++) {</span>
          <span class="s1">if </span><span class="s0">(_i &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">_formatted += </span><span class="s2">', '</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s0">_formatted += data[_i];</span>

          <span class="s1">if </span><span class="s0">(_formatted.length &gt; MAX_PREVIEW_STRING_LENGTH) {</span>
            <span class="s3">// Prevent doing a lot of unnecessary iteration...</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(shortName, </span><span class="s2">&quot; [&quot;</span><span class="s0">).concat(truncateForDisplay(_formatted), </span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">shortName;</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'iterator'</span><span class="s0">:</span>
      <span class="s1">var </span><span class="s0">name = data.constructor.name;</span>

      <span class="s1">if </span><span class="s0">(showFormattedValue) {</span>
        <span class="s3">// TRICKY</span>
        <span class="s3">// Don't use [...spread] syntax for this purpose.</span>
        <span class="s3">// This project uses @babel/plugin-transform-spread in &quot;loose&quot; mode which only works with Array values.</span>
        <span class="s3">// Other types (e.g. typed arrays, Sets) will not spread correctly.</span>
        <span class="s1">var </span><span class="s0">array = Array.from(data);</span>
        <span class="s1">var </span><span class="s0">_formatted2 = </span><span class="s2">''</span><span class="s0">;</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_i2 = </span><span class="s4">0</span><span class="s0">; _i2 &lt; array.length; _i2++) {</span>
          <span class="s1">var </span><span class="s0">entryOrEntries = array[_i2];</span>

          <span class="s1">if </span><span class="s0">(_i2 &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">_formatted2 += </span><span class="s2">', '</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s3">// TRICKY</span>
          <span class="s3">// Browsers display Maps and Sets differently.</span>
          <span class="s3">// To mimic their behavior, detect if we've been given an entries tuple.</span>
          <span class="s3">//   Map(2) {&quot;abc&quot; =&gt; 123, &quot;def&quot; =&gt; 123}</span>
          <span class="s3">//   Set(2) {&quot;abc&quot;, 123}</span>


          <span class="s1">if </span><span class="s0">(src_isArray(entryOrEntries)) {</span>
            <span class="s1">var </span><span class="s0">key = formatDataForPreview(entryOrEntries[</span><span class="s4">0</span><span class="s0">], </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">var </span><span class="s0">value = formatDataForPreview(entryOrEntries[</span><span class="s4">1</span><span class="s0">], </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">_formatted2 += </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(key, </span><span class="s2">&quot; =&gt; &quot;</span><span class="s0">).concat(value);</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">_formatted2 += formatDataForPreview(entryOrEntries, </span><span class="s1">false</span><span class="s0">);</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(_formatted2.length &gt; MAX_PREVIEW_STRING_LENGTH) {</span>
            <span class="s3">// Prevent doing a lot of unnecessary iteration...</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(name, </span><span class="s2">&quot;(&quot;</span><span class="s0">).concat(data.size, </span><span class="s2">&quot;) {&quot;</span><span class="s0">).concat(truncateForDisplay(_formatted2), </span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(name, </span><span class="s2">&quot;(&quot;</span><span class="s0">).concat(data.size, </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'opaque_iterator'</span><span class="s0">:</span>
      <span class="s0">{</span>
        <span class="s1">return </span><span class="s0">data[Symbol.toStringTag];</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'date'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">data.toString();</span>

    <span class="s1">case </span><span class="s2">'class_instance'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">data.constructor.name;</span>

    <span class="s1">case </span><span class="s2">'object'</span><span class="s0">:</span>
      <span class="s1">if </span><span class="s0">(showFormattedValue) {</span>
        <span class="s1">var </span><span class="s0">keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);</span>
        <span class="s1">var </span><span class="s0">_formatted3 = </span><span class="s2">''</span><span class="s0">;</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_i3 = </span><span class="s4">0</span><span class="s0">; _i3 &lt; keys.length; _i3++) {</span>
          <span class="s1">var </span><span class="s0">_key = keys[_i3];</span>

          <span class="s1">if </span><span class="s0">(_i3 &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">_formatted3 += </span><span class="s2">', '</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s0">_formatted3 += </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(_key.toString(), </span><span class="s2">&quot;: &quot;</span><span class="s0">).concat(formatDataForPreview(data[_key], </span><span class="s1">false</span><span class="s0">));</span>

          <span class="s1">if </span><span class="s0">(_formatted3.length &gt; MAX_PREVIEW_STRING_LENGTH) {</span>
            <span class="s3">// Prevent doing a lot of unnecessary iteration...</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">&quot;{&quot;</span><span class="s0">.concat(truncateForDisplay(_formatted3), </span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s2">'{}'</span><span class="s0">;</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'boolean'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'number'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'infinity'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'nan'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'null'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'undefined'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">data;</span>

    <span class="s1">default</span><span class="s0">:</span>
      <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">truncateForDisplay(String(data));</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
        <span class="s1">return </span><span class="s2">'unserializable'</span><span class="s0">;</span>
      <span class="s0">}</span>

  <span class="s0">}</span>
<span class="s0">} </span><span class="s3">// Basically checking that the object only has Object in its prototype chain</span>

<span class="s1">var </span><span class="s0">isPlainObject = </span><span class="s1">function </span><span class="s0">isPlainObject(object) {</span>
  <span class="s1">var </span><span class="s0">objectPrototype = Object.getPrototypeOf(object);</span>
  <span class="s1">if </span><span class="s0">(!objectPrototype) </span><span class="s1">return true</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">objectParentPrototype = Object.getPrototypeOf(objectPrototype);</span>
  <span class="s1">return </span><span class="s0">!objectParentPrototype;</span>
<span class="s0">};</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/hydration.js</span>
<span class="s1">function </span><span class="s0">ownKeys(object, enumerableOnly) { </span><span class="s1">var </span><span class="s0">keys = Object.keys(object); </span><span class="s1">if </span><span class="s0">(Object.getOwnPropertySymbols) { </span><span class="s1">var </span><span class="s0">symbols = Object.getOwnPropertySymbols(object); </span><span class="s1">if </span><span class="s0">(enumerableOnly) symbols = symbols.filter(</span><span class="s1">function </span><span class="s0">(sym) { </span><span class="s1">return </span><span class="s0">Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } </span><span class="s1">return </span><span class="s0">keys; }</span>

<span class="s1">function </span><span class="s0">_objectSpread(target) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; arguments.length; i++) { </span><span class="s1">var </span><span class="s0">source = arguments[i] != </span><span class="s1">null </span><span class="s0">? arguments[i] : {}; </span><span class="s1">if </span><span class="s0">(i % </span><span class="s4">2</span><span class="s0">) { ownKeys(Object(source), </span><span class="s1">true</span><span class="s0">).forEach(</span><span class="s1">function </span><span class="s0">(key) { hydration_defineProperty(target, key, source[key]); }); } </span><span class="s1">else if </span><span class="s0">(Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } </span><span class="s1">else </span><span class="s0">{ ownKeys(Object(source)).forEach(</span><span class="s1">function </span><span class="s0">(key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } </span><span class="s1">return </span><span class="s0">target; }</span>

<span class="s1">function </span><span class="s0">hydration_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s1">var </span><span class="s0">meta = {</span>
  <span class="s0">inspectable: Symbol(</span><span class="s2">'inspectable'</span><span class="s0">),</span>
  <span class="s0">inspected: Symbol(</span><span class="s2">'inspected'</span><span class="s0">),</span>
  <span class="s0">name: Symbol(</span><span class="s2">'name'</span><span class="s0">),</span>
  <span class="s0">preview_long: Symbol(</span><span class="s2">'preview_long'</span><span class="s0">),</span>
  <span class="s0">preview_short: Symbol(</span><span class="s2">'preview_short'</span><span class="s0">),</span>
  <span class="s0">readonly: Symbol(</span><span class="s2">'readonly'</span><span class="s0">),</span>
  <span class="s0">size: Symbol(</span><span class="s2">'size'</span><span class="s0">),</span>
  <span class="s0">type: Symbol(</span><span class="s2">'type'</span><span class="s0">),</span>
  <span class="s0">unserializable: Symbol(</span><span class="s2">'unserializable'</span><span class="s0">)</span>
<span class="s0">};</span>
<span class="s3">// This threshold determines the depth at which the bridge &quot;dehydrates&quot; nested data.</span>
<span class="s3">// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,</span>
<span class="s3">// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).</span>
<span class="s3">//</span>
<span class="s3">// Reducing this threshold will improve the speed of initial component inspection,</span>
<span class="s3">// but may decrease the responsiveness of expanding objects/arrays to inspect further.</span>
<span class="s1">var </span><span class="s0">LEVEL_THRESHOLD = </span><span class="s4">2</span><span class="s0">;</span>
<span class="s3">/** 
 * Generate the dehydrated metadata for complex object instances 
 */</span>

<span class="s1">function </span><span class="s0">createDehydrated(type, inspectable, data, cleaned, path) {</span>
  <span class="s0">cleaned.push(path);</span>
  <span class="s1">var </span><span class="s0">dehydrated = {</span>
    <span class="s0">inspectable: inspectable,</span>
    <span class="s0">type: type,</span>
    <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
    <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
    <span class="s0">name: !data.constructor || data.constructor.name === </span><span class="s2">'Object' </span><span class="s0">? </span><span class="s2">'' </span><span class="s0">: data.constructor.name</span>
  <span class="s0">};</span>

  <span class="s1">if </span><span class="s0">(type === </span><span class="s2">'array' </span><span class="s0">|| type === </span><span class="s2">'typed_array'</span><span class="s0">) {</span>
    <span class="s0">dehydrated.size = data.length;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(type === </span><span class="s2">'object'</span><span class="s0">) {</span>
    <span class="s0">dehydrated.size = Object.keys(data).length;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(type === </span><span class="s2">'iterator' </span><span class="s0">|| type === </span><span class="s2">'typed_array'</span><span class="s0">) {</span>
    <span class="s0">dehydrated.readonly = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">dehydrated;</span>
<span class="s0">}</span>
<span class="s3">/** 
 * Strip out complex data (instances, functions, and data nested &gt; LEVEL_THRESHOLD levels deep). 
 * The paths of the stripped out objects are appended to the `cleaned` list. 
 * On the other side of the barrier, the cleaned list is used to &quot;re-hydrate&quot; the cleaned representation into 
 * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object. 
 * 
 * Input: {&quot;some&quot;: {&quot;attr&quot;: fn()}, &quot;other&quot;: AnInstance} 
 * Output: { 
 *   &quot;some&quot;: { 
 *     &quot;attr&quot;: {&quot;name&quot;: the fn.name, type: &quot;function&quot;} 
 *   }, 
 *   &quot;other&quot;: { 
 *     &quot;name&quot;: &quot;AnInstance&quot;, 
 *     &quot;type&quot;: &quot;object&quot;, 
 *   }, 
 * } 
 * and cleaned = [[&quot;some&quot;, &quot;attr&quot;], [&quot;other&quot;]] 
 */</span>


<span class="s1">function </span><span class="s0">dehydrate(data, cleaned, unserializable, path, isPathAllowed) {</span>
  <span class="s1">var </span><span class="s0">level = arguments.length &gt; </span><span class="s4">5 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">5</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">5</span><span class="s0">] : </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">type = getDataType(data);</span>
  <span class="s1">var </span><span class="s0">isPathAllowedCheck;</span>

  <span class="s1">switch </span><span class="s0">(type) {</span>
    <span class="s1">case </span><span class="s2">'html_element'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: data.tagName,</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>

    <span class="s1">case </span><span class="s2">'function'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: </span><span class="s1">typeof </span><span class="s0">data.name === </span><span class="s2">'function' </span><span class="s0">|| !data.name ? </span><span class="s2">'function' </span><span class="s0">: data.name,</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>

    <span class="s1">case </span><span class="s2">'string'</span><span class="s0">:</span>
      <span class="s0">isPathAllowedCheck = isPathAllowed(path);</span>

      <span class="s1">if </span><span class="s0">(isPathAllowedCheck) {</span>
        <span class="s1">return </span><span class="s0">data;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">data.length &lt;= </span><span class="s4">500 </span><span class="s0">? data : data.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">500</span><span class="s0">) + </span><span class="s2">'...'</span><span class="s0">;</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'bigint'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: data.toString(),</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>

    <span class="s1">case </span><span class="s2">'symbol'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: data.toString(),</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>
    <span class="s3">// React Elements aren't very inspector-friendly,</span>
    <span class="s3">// and often contain private fields or circular references.</span>

    <span class="s1">case </span><span class="s2">'react_element'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: getDisplayNameForReactElement(data) || </span><span class="s2">'Unknown'</span><span class="s0">,</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>
    <span class="s3">// ArrayBuffers error if you try to inspect them.</span>

    <span class="s1">case </span><span class="s2">'array_buffer'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'data_view'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: type === </span><span class="s2">'data_view' </span><span class="s0">? </span><span class="s2">'DataView' </span><span class="s0">: </span><span class="s2">'ArrayBuffer'</span><span class="s0">,</span>
        <span class="s0">size: data.byteLength,</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>

    <span class="s1">case </span><span class="s2">'array'</span><span class="s0">:</span>
      <span class="s0">isPathAllowedCheck = isPathAllowed(path);</span>

      <span class="s1">if </span><span class="s0">(level &gt;= LEVEL_THRESHOLD &amp;&amp; !isPathAllowedCheck) {</span>
        <span class="s1">return </span><span class="s0">createDehydrated(type, </span><span class="s1">true</span><span class="s0">, data, cleaned, path);</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">data.map(</span><span class="s1">function </span><span class="s0">(item, i) {</span>
        <span class="s1">return </span><span class="s0">dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? </span><span class="s4">1 </span><span class="s0">: level + </span><span class="s4">1</span><span class="s0">);</span>
      <span class="s0">});</span>

    <span class="s1">case </span><span class="s2">'html_all_collection'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'typed_array'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'iterator'</span><span class="s0">:</span>
      <span class="s0">isPathAllowedCheck = isPathAllowed(path);</span>

      <span class="s1">if </span><span class="s0">(level &gt;= LEVEL_THRESHOLD &amp;&amp; !isPathAllowedCheck) {</span>
        <span class="s1">return </span><span class="s0">createDehydrated(type, </span><span class="s1">true</span><span class="s0">, data, cleaned, path);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">unserializableValue = {</span>
          <span class="s0">unserializable: </span><span class="s1">true</span><span class="s0">,</span>
          <span class="s0">type: type,</span>
          <span class="s0">readonly: </span><span class="s1">true</span><span class="s0">,</span>
          <span class="s0">size: type === </span><span class="s2">'typed_array' </span><span class="s0">? data.length : undefined,</span>
          <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
          <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
          <span class="s0">name: !data.constructor || data.constructor.name === </span><span class="s2">'Object' </span><span class="s0">? </span><span class="s2">'' </span><span class="s0">: data.constructor.name</span>
        <span class="s0">}; </span><span class="s3">// TRICKY</span>
        <span class="s3">// Don't use [...spread] syntax for this purpose.</span>
        <span class="s3">// This project uses @babel/plugin-transform-spread in &quot;loose&quot; mode which only works with Array values.</span>
        <span class="s3">// Other types (e.g. typed arrays, Sets) will not spread correctly.</span>

        <span class="s0">Array.from(data).forEach(</span><span class="s1">function </span><span class="s0">(item, i) {</span>
          <span class="s1">return </span><span class="s0">unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? </span><span class="s4">1 </span><span class="s0">: level + </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">});</span>
        <span class="s0">unserializable.push(path);</span>
        <span class="s1">return </span><span class="s0">unserializableValue;</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'opaque_iterator'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: data[Symbol.toStringTag],</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>

    <span class="s1">case </span><span class="s2">'date'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: data.toString(),</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>

    <span class="s1">case </span><span class="s2">'regexp'</span><span class="s0">:</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">inspectable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: data.toString(),</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>

    <span class="s1">case </span><span class="s2">'object'</span><span class="s0">:</span>
      <span class="s0">isPathAllowedCheck = isPathAllowed(path);</span>

      <span class="s1">if </span><span class="s0">(level &gt;= LEVEL_THRESHOLD &amp;&amp; !isPathAllowedCheck) {</span>
        <span class="s1">return </span><span class="s0">createDehydrated(type, </span><span class="s1">true</span><span class="s0">, data, cleaned, path);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">object = {};</span>
        <span class="s0">getAllEnumerableKeys(data).forEach(</span><span class="s1">function </span><span class="s0">(key) {</span>
          <span class="s1">var </span><span class="s0">name = key.toString();</span>
          <span class="s0">object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? </span><span class="s4">1 </span><span class="s0">: level + </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">object;</span>
      <span class="s0">}</span>

    <span class="s1">case </span><span class="s2">'class_instance'</span><span class="s0">:</span>
      <span class="s0">isPathAllowedCheck = isPathAllowed(path);</span>

      <span class="s1">if </span><span class="s0">(level &gt;= LEVEL_THRESHOLD &amp;&amp; !isPathAllowedCheck) {</span>
        <span class="s1">return </span><span class="s0">createDehydrated(type, </span><span class="s1">true</span><span class="s0">, data, cleaned, path);</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">value = {</span>
        <span class="s0">unserializable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">type: type,</span>
        <span class="s0">readonly: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">preview_short: formatDataForPreview(data, </span><span class="s1">false</span><span class="s0">),</span>
        <span class="s0">preview_long: formatDataForPreview(data, </span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">name: data.constructor.name</span>
      <span class="s0">};</span>
      <span class="s0">getAllEnumerableKeys(data).forEach(</span><span class="s1">function </span><span class="s0">(key) {</span>
        <span class="s1">var </span><span class="s0">keyAsString = key.toString();</span>
        <span class="s0">value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? </span><span class="s4">1 </span><span class="s0">: level + </span><span class="s4">1</span><span class="s0">);</span>
      <span class="s0">});</span>
      <span class="s0">unserializable.push(path);</span>
      <span class="s1">return </span><span class="s0">value;</span>

    <span class="s1">case </span><span class="s2">'infinity'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'nan'</span><span class="s0">:</span>
    <span class="s1">case </span><span class="s2">'undefined'</span><span class="s0">:</span>
      <span class="s3">// Some values are lossy when sent through a WebSocket.</span>
      <span class="s3">// We dehydrate+rehydrate them to preserve their type.</span>
      <span class="s0">cleaned.push(path);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">type: type</span>
      <span class="s0">};</span>

    <span class="s1">default</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">data;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">fillInPath(object, data, path, value) {</span>
  <span class="s1">var </span><span class="s0">target = getInObject(object, path);</span>

  <span class="s1">if </span><span class="s0">(target != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(!target[meta.unserializable]) {</span>
      <span class="s1">delete </span><span class="s0">target[meta.inspectable];</span>
      <span class="s1">delete </span><span class="s0">target[meta.inspected];</span>
      <span class="s1">delete </span><span class="s0">target[meta.name];</span>
      <span class="s1">delete </span><span class="s0">target[meta.preview_long];</span>
      <span class="s1">delete </span><span class="s0">target[meta.preview_short];</span>
      <span class="s1">delete </span><span class="s0">target[meta.readonly];</span>
      <span class="s1">delete </span><span class="s0">target[meta.size];</span>
      <span class="s1">delete </span><span class="s0">target[meta.type];</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(value !== </span><span class="s1">null </span><span class="s0">&amp;&amp; data.unserializable.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">unserializablePath = data.unserializable[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">var </span><span class="s0">isMatch = unserializablePath.length === path.length;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; path.length; i++) {</span>
      <span class="s1">if </span><span class="s0">(path[i] !== unserializablePath[i]) {</span>
        <span class="s0">isMatch = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isMatch) {</span>
      <span class="s0">upgradeUnserializable(value, value);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s0">setInObject(object, path, value);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">hydrate(object, cleaned, unserializable) {</span>
  <span class="s0">cleaned.forEach(</span><span class="s1">function </span><span class="s0">(path) {</span>
    <span class="s1">var </span><span class="s0">length = path.length;</span>
    <span class="s1">var </span><span class="s0">last = path[length - </span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">var </span><span class="s0">parent = getInObject(object, path.slice(</span><span class="s4">0</span><span class="s0">, length - </span><span class="s4">1</span><span class="s0">));</span>

    <span class="s1">if </span><span class="s0">(!parent || !parent.hasOwnProperty(last)) {</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">value = parent[last];</span>

    <span class="s1">if </span><span class="s0">(!value) {</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(value.type === </span><span class="s2">'infinity'</span><span class="s0">) {</span>
      <span class="s0">parent[last] = Infinity;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(value.type === </span><span class="s2">'nan'</span><span class="s0">) {</span>
      <span class="s0">parent[last] = NaN;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(value.type === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
      <span class="s0">parent[last] = undefined;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s3">// Replace the string keys with Symbols so they're non-enumerable.</span>
      <span class="s1">var </span><span class="s0">replaced = {};</span>
      <span class="s0">replaced[meta.inspectable] = !!value.inspectable;</span>
      <span class="s0">replaced[meta.inspected] = </span><span class="s1">false</span><span class="s0">;</span>
      <span class="s0">replaced[meta.name] = value.name;</span>
      <span class="s0">replaced[meta.preview_long] = value.preview_long;</span>
      <span class="s0">replaced[meta.preview_short] = value.preview_short;</span>
      <span class="s0">replaced[meta.size] = value.size;</span>
      <span class="s0">replaced[meta.readonly] = !!value.readonly;</span>
      <span class="s0">replaced[meta.type] = value.type;</span>
      <span class="s0">parent[last] = replaced;</span>
    <span class="s0">}</span>
  <span class="s0">});</span>
  <span class="s0">unserializable.forEach(</span><span class="s1">function </span><span class="s0">(path) {</span>
    <span class="s1">var </span><span class="s0">length = path.length;</span>
    <span class="s1">var </span><span class="s0">last = path[length - </span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">var </span><span class="s0">parent = getInObject(object, path.slice(</span><span class="s4">0</span><span class="s0">, length - </span><span class="s4">1</span><span class="s0">));</span>

    <span class="s1">if </span><span class="s0">(!parent || !parent.hasOwnProperty(last)) {</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">node = parent[last];</span>

    <span class="s1">var </span><span class="s0">replacement = _objectSpread({}, node);</span>

    <span class="s0">upgradeUnserializable(replacement, node);</span>
    <span class="s0">parent[last] = replacement;</span>
  <span class="s0">});</span>
  <span class="s1">return </span><span class="s0">object;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">upgradeUnserializable(destination, source) {</span>
  <span class="s1">var </span><span class="s0">_Object$definePropert;</span>

  <span class="s0">Object.defineProperties(destination, (_Object$definePropert = {}, hydration_defineProperty(_Object$definePropert, meta.inspected, {</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">value: !!source.inspected</span>
  <span class="s0">}), hydration_defineProperty(_Object$definePropert, meta.name, {</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">value: source.name</span>
  <span class="s0">}), hydration_defineProperty(_Object$definePropert, meta.preview_long, {</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">value: source.preview_long</span>
  <span class="s0">}), hydration_defineProperty(_Object$definePropert, meta.preview_short, {</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">value: source.preview_short</span>
  <span class="s0">}), hydration_defineProperty(_Object$definePropert, meta.size, {</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">value: source.size</span>
  <span class="s0">}), hydration_defineProperty(_Object$definePropert, meta.readonly, {</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">value: !!source.readonly</span>
  <span class="s0">}), hydration_defineProperty(_Object$definePropert, meta.type, {</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">value: source.type</span>
  <span class="s0">}), hydration_defineProperty(_Object$definePropert, meta.unserializable, {</span>
    <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">value: !!source.unserializable</span>
  <span class="s0">}), _Object$definePropert));</span>
  <span class="s1">delete </span><span class="s0">destination.inspected;</span>
  <span class="s1">delete </span><span class="s0">destination.name;</span>
  <span class="s1">delete </span><span class="s0">destination.preview_long;</span>
  <span class="s1">delete </span><span class="s0">destination.preview_short;</span>
  <span class="s1">delete </span><span class="s0">destination.size;</span>
  <span class="s1">delete </span><span class="s0">destination.readonly;</span>
  <span class="s1">delete </span><span class="s0">destination.type;</span>
  <span class="s1">delete </span><span class="s0">destination.unserializable;</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../shared/isArray.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s1">var </span><span class="s0">isArrayImpl = Array.isArray; </span><span class="s3">// eslint-disable-next-line no-redeclare</span>

<span class="s1">function </span><span class="s0">isArray_isArray(a) {</span>
  <span class="s1">return </span><span class="s0">isArrayImpl(a);</span>
<span class="s0">}</span>

<span class="s3">/* harmony default export */ </span><span class="s0">const shared_isArray = (isArray_isArray);</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/utils.js</span>
<span class="s1">function </span><span class="s0">utils_toConsumableArray(arr) { </span><span class="s1">return </span><span class="s0">utils_arrayWithoutHoles(arr) || utils_iterableToArray(arr) || backend_utils_unsupportedIterableToArray(arr) || utils_nonIterableSpread(); }</span>

<span class="s1">function </span><span class="s0">utils_nonIterableSpread() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to spread non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">backend_utils_unsupportedIterableToArray(o, minLen) { </span><span class="s1">if </span><span class="s0">(!o) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">o === </span><span class="s2">&quot;string&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">backend_utils_arrayLikeToArray(o, minLen); </span><span class="s1">var </span><span class="s0">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s0">&amp;&amp; o.constructor) n = o.constructor.name; </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s0">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">Array.from(o); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s0">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s0">|</span><span class="s4">16</span><span class="s0">|</span><span class="s4">32</span><span class="s0">)(?:Clamped)?Array$/.test(n)) </span><span class="s1">return </span><span class="s0">backend_utils_arrayLikeToArray(o, minLen); }</span>

<span class="s1">function </span><span class="s0">utils_iterableToArray(iter) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">&amp;&amp; Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(iter)) </span><span class="s1">return </span><span class="s0">Array.from(iter); }</span>

<span class="s1">function </span><span class="s0">utils_arrayWithoutHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">backend_utils_arrayLikeToArray(arr); }</span>

<span class="s1">function </span><span class="s0">backend_utils_arrayLikeToArray(arr, len) { </span><span class="s1">if </span><span class="s0">(len == </span><span class="s1">null </span><span class="s0">|| len &gt; arr.length) len = arr.length; </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, arr2 = </span><span class="s1">new </span><span class="s0">Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } </span><span class="s1">return </span><span class="s0">arr2; }</span>

<span class="s1">function </span><span class="s0">backend_utils_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { backend_utils_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ backend_utils_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">backend_utils_typeof(obj); }</span>

<span class="s1">function </span><span class="s0">utils_ownKeys(object, enumerableOnly) { </span><span class="s1">var </span><span class="s0">keys = Object.keys(object); </span><span class="s1">if </span><span class="s0">(Object.getOwnPropertySymbols) { </span><span class="s1">var </span><span class="s0">symbols = Object.getOwnPropertySymbols(object); </span><span class="s1">if </span><span class="s0">(enumerableOnly) symbols = symbols.filter(</span><span class="s1">function </span><span class="s0">(sym) { </span><span class="s1">return </span><span class="s0">Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } </span><span class="s1">return </span><span class="s0">keys; }</span>

<span class="s1">function </span><span class="s0">utils_objectSpread(target) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; arguments.length; i++) { </span><span class="s1">var </span><span class="s0">source = arguments[i] != </span><span class="s1">null </span><span class="s0">? arguments[i] : {}; </span><span class="s1">if </span><span class="s0">(i % </span><span class="s4">2</span><span class="s0">) { utils_ownKeys(Object(source), </span><span class="s1">true</span><span class="s0">).forEach(</span><span class="s1">function </span><span class="s0">(key) { utils_defineProperty(target, key, source[key]); }); } </span><span class="s1">else if </span><span class="s0">(Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } </span><span class="s1">else </span><span class="s0">{ utils_ownKeys(Object(source)).forEach(</span><span class="s1">function </span><span class="s0">(key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } </span><span class="s1">return </span><span class="s0">target; }</span>

<span class="s1">function </span><span class="s0">utils_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s3">/** 
/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>



<span class="s3">// TODO: update this to the first React version that has a corresponding DevTools backend</span>
<span class="s1">var </span><span class="s0">FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER = </span><span class="s2">'999.9.9'</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">hasAssignedBackend(version) {</span>
  <span class="s1">if </span><span class="s0">(version == </span><span class="s1">null </span><span class="s0">|| version === </span><span class="s2">''</span><span class="s0">) {</span>
    <span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">gte(version, FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">cleanForBridge(data, isPathAllowed) {</span>
  <span class="s1">var </span><span class="s0">path = arguments.length &gt; </span><span class="s4">2 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">2</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">2</span><span class="s0">] : [];</span>

  <span class="s1">if </span><span class="s0">(data !== </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">cleanedPaths = [];</span>
    <span class="s1">var </span><span class="s0">unserializablePaths = [];</span>
    <span class="s1">var </span><span class="s0">cleanedData = dehydrate(data, cleanedPaths, unserializablePaths, path, isPathAllowed);</span>
    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">data: cleanedData,</span>
      <span class="s0">cleaned: cleanedPaths,</span>
      <span class="s0">unserializable: unserializablePaths</span>
    <span class="s0">};</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">copyWithDelete(obj, path) {</span>
  <span class="s1">var </span><span class="s0">index = arguments.length &gt; </span><span class="s4">2 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">2</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">2</span><span class="s0">] : </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">key = path[index];</span>
  <span class="s1">var </span><span class="s0">updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);</span>

  <span class="s1">if </span><span class="s0">(index + </span><span class="s4">1 </span><span class="s0">=== path.length) {</span>
    <span class="s1">if </span><span class="s0">(shared_isArray(updated)) {</span>
      <span class="s0">updated.splice(key, </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">delete </span><span class="s0">updated[key];</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s3">// $FlowFixMe[incompatible-use] number or string is fine here</span>
    <span class="s0">updated[key] = copyWithDelete(obj[key], path, index + </span><span class="s4">1</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">updated;</span>
<span class="s0">} </span><span class="s3">// This function expects paths to be the same except for the final value.</span>
<span class="s3">// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']</span>

<span class="s1">function </span><span class="s0">copyWithRename(obj, oldPath, newPath) {</span>
  <span class="s1">var </span><span class="s0">index = arguments.length &gt; </span><span class="s4">3 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">3</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">3</span><span class="s0">] : </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">oldKey = oldPath[index];</span>
  <span class="s1">var </span><span class="s0">updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);</span>

  <span class="s1">if </span><span class="s0">(index + </span><span class="s4">1 </span><span class="s0">=== oldPath.length) {</span>
    <span class="s1">var </span><span class="s0">newKey = newPath[index]; </span><span class="s3">// $FlowFixMe[incompatible-use] number or string is fine here</span>

    <span class="s0">updated[newKey] = updated[oldKey];</span>

    <span class="s1">if </span><span class="s0">(shared_isArray(updated)) {</span>
      <span class="s0">updated.splice(oldKey, </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">delete </span><span class="s0">updated[oldKey];</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s3">// $FlowFixMe[incompatible-use] number or string is fine here</span>
    <span class="s0">updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + </span><span class="s4">1</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">updated;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">copyWithSet(obj, path, value) {</span>
  <span class="s1">var </span><span class="s0">index = arguments.length &gt; </span><span class="s4">3 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">3</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">3</span><span class="s0">] : </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(index &gt;= path.length) {</span>
    <span class="s1">return </span><span class="s0">value;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">key = path[index];</span>
  <span class="s1">var </span><span class="s0">updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj); </span><span class="s3">// $FlowFixMe[incompatible-use] number or string is fine here</span>

  <span class="s0">updated[key] = copyWithSet(obj[key], path, value, index + </span><span class="s4">1</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">updated;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getEffectDurations(root) {</span>
  <span class="s3">// Profiling durations are only available for certain builds.</span>
  <span class="s3">// If available, they'll be stored on the HostRoot.</span>
  <span class="s1">var </span><span class="s0">effectDuration = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">passiveEffectDuration = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">hostRoot = root.current;</span>

  <span class="s1">if </span><span class="s0">(hostRoot != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">stateNode = hostRoot.stateNode;</span>

    <span class="s1">if </span><span class="s0">(stateNode != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">effectDuration = stateNode.effectDuration != </span><span class="s1">null </span><span class="s0">? stateNode.effectDuration : </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">passiveEffectDuration = stateNode.passiveEffectDuration != </span><span class="s1">null </span><span class="s0">? stateNode.passiveEffectDuration : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">effectDuration: effectDuration,</span>
    <span class="s0">passiveEffectDuration: passiveEffectDuration</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">serializeToString(data) {</span>
  <span class="s1">if </span><span class="s0">(data === undefined) {</span>
    <span class="s1">return </span><span class="s2">'undefined'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">cache = </span><span class="s1">new </span><span class="s0">Set(); </span><span class="s3">// Use a custom replacer function to protect against circular references.</span>

  <span class="s1">return </span><span class="s0">JSON.stringify(data, </span><span class="s1">function </span><span class="s0">(key, value) {</span>
    <span class="s1">if </span><span class="s0">(backend_utils_typeof(value) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; value !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(cache.has(value)) {</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">cache.add(value);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">'bigint'</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">value.toString() + </span><span class="s2">'n'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">value;</span>
  <span class="s0">}, </span><span class="s4">2</span><span class="s0">);</span>
<span class="s0">} </span><span class="s3">// Formats an array of args with a style for console methods, using</span>
<span class="s3">// the following algorithm:</span>
<span class="s3">//     1. The first param is a string that contains %c</span>
<span class="s3">//          - Bail out and return the args without modifying the styles.</span>
<span class="s3">//            We don't want to affect styles that the developer deliberately set.</span>
<span class="s3">//     2. The first param is a string that doesn't contain %c but contains</span>
<span class="s3">//        string formatting</span>
<span class="s3">//          - [`%c${args[0]}`, style, ...args.slice(1)]</span>
<span class="s3">//          - Note: we assume that the string formatting that the developer uses</span>
<span class="s3">//            is correct.</span>
<span class="s3">//     3. The first param is a string that doesn't contain string formatting</span>
<span class="s3">//        OR is not a string</span>
<span class="s3">//          - Create a formatting string where:</span>
<span class="s3">//                 boolean, string, symbol -&gt; %s</span>
<span class="s3">//                 number -&gt; %f OR %i depending on if it's an int or float</span>
<span class="s3">//                 default -&gt; %o</span>

<span class="s1">function </span><span class="s0">formatWithStyles(inputArgs, style) {</span>
  <span class="s1">if </span><span class="s0">(inputArgs === undefined || inputArgs === </span><span class="s1">null </span><span class="s0">|| inputArgs.length === </span><span class="s4">0 </span><span class="s0">|| </span><span class="s3">// Matches any of %c but not %%c</span>
  <span class="s1">typeof </span><span class="s0">inputArgs[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; inputArgs[</span><span class="s4">0</span><span class="s0">].match(/([^%]|^)(%c)/g) || style === undefined) {</span>
    <span class="s1">return </span><span class="s0">inputArgs;</span>
  <span class="s0">} </span><span class="s3">// Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)</span>


  <span class="s1">var </span><span class="s0">REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">inputArgs[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; inputArgs[</span><span class="s4">0</span><span class="s0">].match(REGEXP)) {</span>
    <span class="s1">return </span><span class="s0">[</span><span class="s2">&quot;%c&quot;</span><span class="s0">.concat(inputArgs[</span><span class="s4">0</span><span class="s0">]), style].concat(utils_toConsumableArray(inputArgs.slice(</span><span class="s4">1</span><span class="s0">)));</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">firstArg = inputArgs.reduce(</span><span class="s1">function </span><span class="s0">(formatStr, elem, i) {</span>
      <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">formatStr += </span><span class="s2">' '</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">switch </span><span class="s0">(backend_utils_typeof(elem)) {</span>
        <span class="s1">case </span><span class="s2">'string'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'boolean'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'symbol'</span><span class="s0">:</span>
          <span class="s1">return </span><span class="s0">formatStr += </span><span class="s2">'%s'</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'number'</span><span class="s0">:</span>
          <span class="s1">var </span><span class="s0">formatting = Number.isInteger(elem) ? </span><span class="s2">'%i' </span><span class="s0">: </span><span class="s2">'%f'</span><span class="s0">;</span>
          <span class="s1">return </span><span class="s0">formatStr += formatting;</span>

        <span class="s1">default</span><span class="s0">:</span>
          <span class="s1">return </span><span class="s0">formatStr += </span><span class="s2">'%o'</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}, </span><span class="s2">'%c'</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s0">[firstArg, style].concat(utils_toConsumableArray(inputArgs));</span>
  <span class="s0">}</span>
<span class="s0">} </span><span class="s3">// based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1</span>
<span class="s3">// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions</span>
<span class="s3">// Implements s, d, i and f placeholders</span>
<span class="s3">// NOTE: KEEP IN SYNC with src/hook.js</span>

<span class="s1">function </span><span class="s0">format(maybeMessage) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, inputArgs = </span><span class="s1">new </span><span class="s0">Array(_len &gt; </span><span class="s4">1 </span><span class="s0">? _len - </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">), _key = </span><span class="s4">1</span><span class="s0">; _key &lt; _len; _key++) {</span>
    <span class="s0">inputArgs[_key - </span><span class="s4">1</span><span class="s0">] = arguments[_key];</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">args = inputArgs.slice();</span>
  <span class="s1">var </span><span class="s0">formatted = String(maybeMessage); </span><span class="s3">// If the first argument is a string, check for substitutions.</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">maybeMessage === </span><span class="s2">'string'</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(args.length) {</span>
      <span class="s1">var </span><span class="s0">REGEXP = /(%?)(%([jds]))/g;</span>
      <span class="s0">formatted = formatted.replace(REGEXP, </span><span class="s1">function </span><span class="s0">(match, escaped, ptn, flag) {</span>
        <span class="s1">var </span><span class="s0">arg = args.shift();</span>

        <span class="s1">switch </span><span class="s0">(flag) {</span>
          <span class="s1">case </span><span class="s2">'s'</span><span class="s0">:</span>
            <span class="s0">arg += </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s1">break</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'d'</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">'i'</span><span class="s0">:</span>
            <span class="s0">arg = parseInt(arg, </span><span class="s4">10</span><span class="s0">).toString();</span>
            <span class="s1">break</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'f'</span><span class="s0">:</span>
            <span class="s0">arg = parseFloat(arg).toString();</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(!escaped) {</span>
          <span class="s1">return </span><span class="s0">arg;</span>
        <span class="s0">}</span>

        <span class="s0">args.unshift(arg);</span>
        <span class="s1">return </span><span class="s0">match;</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Arguments that remain after formatting.</span>


  <span class="s1">if </span><span class="s0">(args.length) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; args.length; i++) {</span>
      <span class="s0">formatted += </span><span class="s2">' ' </span><span class="s0">+ String(args[i]);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Update escaped %% values.</span>


  <span class="s0">formatted = formatted.replace(/%{</span><span class="s4">2</span><span class="s0">,</span><span class="s4">2</span><span class="s0">}/g, </span><span class="s2">'%'</span><span class="s0">);</span>
  <span class="s1">return </span><span class="s0">String(formatted);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isSynchronousXHRSupported() {</span>
  <span class="s1">return </span><span class="s0">!!(window.document &amp;&amp; window.document.featurePolicy &amp;&amp; window.document.featurePolicy.allowsFeature(</span><span class="s2">'sync-xhr'</span><span class="s0">));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">gt() {</span>
  <span class="s1">var </span><span class="s0">a = arguments.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">0</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">0</span><span class="s0">] : </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">b = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s0">compareVersions(a, b) === </span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">gte() {</span>
  <span class="s1">var </span><span class="s0">a = arguments.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">0</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">0</span><span class="s0">] : </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">b = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s1">return </span><span class="s0">compareVersions(a, b) &gt; -</span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s3">// EXTERNAL MODULE: ../../build/oss-experimental/react-debug-tools/index.js</span>
<span class="s1">var </span><span class="s0">react_debug_tools = __webpack_require__(</span><span class="s4">987</span><span class="s0">);</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s3">// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.</span>
<span class="s3">// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:</span>
<span class="s3">// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)</span>
<span class="s3">// 2. DevTools must support both Symbol and numeric forms of each symbol;</span>
<span class="s3">//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.</span>
<span class="s1">var </span><span class="s0">CONCURRENT_MODE_NUMBER = </span><span class="s4">0</span><span class="s0">xeacf;</span>
<span class="s1">var </span><span class="s0">CONCURRENT_MODE_SYMBOL_STRING = </span><span class="s2">'Symbol(react.concurrent_mode)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">CONTEXT_NUMBER = </span><span class="s4">0</span><span class="s0">xeace;</span>
<span class="s1">var </span><span class="s0">CONTEXT_SYMBOL_STRING = </span><span class="s2">'Symbol(react.context)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SERVER_CONTEXT_SYMBOL_STRING = </span><span class="s2">'Symbol(react.server_context)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">DEPRECATED_ASYNC_MODE_SYMBOL_STRING = </span><span class="s2">'Symbol(react.async_mode)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ELEMENT_NUMBER = </span><span class="s4">0</span><span class="s0">xeac7;</span>
<span class="s1">var </span><span class="s0">ELEMENT_SYMBOL_STRING = </span><span class="s2">'Symbol(react.element)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">DEBUG_TRACING_MODE_NUMBER = </span><span class="s4">0</span><span class="s0">xeae1;</span>
<span class="s1">var </span><span class="s0">DEBUG_TRACING_MODE_SYMBOL_STRING = </span><span class="s2">'Symbol(react.debug_trace_mode)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_FORWARD_REF_NUMBER = </span><span class="s4">0</span><span class="s0">xead0;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_FORWARD_REF_SYMBOL_STRING = </span><span class="s2">'Symbol(react.forward_ref)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">FRAGMENT_NUMBER = </span><span class="s4">0</span><span class="s0">xeacb;</span>
<span class="s1">var </span><span class="s0">FRAGMENT_SYMBOL_STRING = </span><span class="s2">'Symbol(react.fragment)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_LAZY_NUMBER = </span><span class="s4">0</span><span class="s0">xead4;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_LAZY_SYMBOL_STRING = </span><span class="s2">'Symbol(react.lazy)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_MEMO_NUMBER = </span><span class="s4">0</span><span class="s0">xead3;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_MEMO_SYMBOL_STRING = </span><span class="s2">'Symbol(react.memo)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">PORTAL_NUMBER = </span><span class="s4">0</span><span class="s0">xeaca;</span>
<span class="s1">var </span><span class="s0">PORTAL_SYMBOL_STRING = </span><span class="s2">'Symbol(react.portal)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">PROFILER_NUMBER = </span><span class="s4">0</span><span class="s0">xead2;</span>
<span class="s1">var </span><span class="s0">PROFILER_SYMBOL_STRING = </span><span class="s2">'Symbol(react.profiler)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">PROVIDER_NUMBER = </span><span class="s4">0</span><span class="s0">xeacd;</span>
<span class="s1">var </span><span class="s0">PROVIDER_SYMBOL_STRING = </span><span class="s2">'Symbol(react.provider)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SCOPE_NUMBER = </span><span class="s4">0</span><span class="s0">xead7;</span>
<span class="s1">var </span><span class="s0">SCOPE_SYMBOL_STRING = </span><span class="s2">'Symbol(react.scope)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">STRICT_MODE_NUMBER = </span><span class="s4">0</span><span class="s0">xeacc;</span>
<span class="s1">var </span><span class="s0">STRICT_MODE_SYMBOL_STRING = </span><span class="s2">'Symbol(react.strict_mode)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_SUSPENSE_NUMBER = </span><span class="s4">0</span><span class="s0">xead1;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_SUSPENSE_SYMBOL_STRING = </span><span class="s2">'Symbol(react.suspense)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_SUSPENSE_LIST_NUMBER = </span><span class="s4">0</span><span class="s0">xead8;</span>
<span class="s1">var </span><span class="s0">ReactSymbols_SUSPENSE_LIST_SYMBOL_STRING = </span><span class="s2">'Symbol(react.suspense_list)'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING = </span><span class="s2">'Symbol(react.server_context.defaultValue)'</span><span class="s0">;</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s3">/************************************************************************ 
 * This file is forked between different DevTools implementations. 
 * It should never be imported directly! 
 * It should always be imported from &quot;react-devtools-feature-flags&quot;. 
 ************************************************************************/</span>
<span class="s1">var </span><span class="s0">consoleManagedByDevToolsDuringStrictMode = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">enableLogger = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">enableStyleXFeatures = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">isInternalFacebookBuild = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s3">/************************************************************************ 
 * Do not edit the code below. 
 * It ensures this fork exports the same types as the default flags file. 
 ************************************************************************/</span>

<span class="s3">// Flow magic to verify the exports of this file match the original version.</span>
<span class="s1">null</span><span class="s0">;</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../shared/objectIs.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s3">/** 
 * inlined Object.is polyfill to avoid requiring consumers ship their own 
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is 
 */</span>
<span class="s1">function </span><span class="s0">is(x, y) {</span>
  <span class="s1">return </span><span class="s0">x === y &amp;&amp; (x !== </span><span class="s4">0 </span><span class="s0">|| </span><span class="s4">1 </span><span class="s0">/ x === </span><span class="s4">1 </span><span class="s0">/ y) || x !== x &amp;&amp; y !== y </span><span class="s3">// eslint-disable-line no-self-compare</span>
  <span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">objectIs = </span><span class="s3">// $FlowFixMe[method-unbinding]</span>
<span class="s1">typeof </span><span class="s0">Object.is === </span><span class="s2">'function' </span><span class="s0">? Object.is : is;</span>
<span class="s3">/* harmony default export */ </span><span class="s0">const shared_objectIs = (objectIs);</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../shared/hasOwnProperty.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s3">// $FlowFixMe[method-unbinding]</span>
<span class="s1">var </span><span class="s0">hasOwnProperty_hasOwnProperty = Object.prototype.hasOwnProperty;</span>
<span class="s3">/* harmony default export */ </span><span class="s0">const shared_hasOwnProperty = (hasOwnProperty_hasOwnProperty);</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/StyleX/utils.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s1">var </span><span class="s0">cachedStyleNameToValueMap = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">function </span><span class="s0">getStyleXData(data) {</span>
  <span class="s1">var </span><span class="s0">sources = </span><span class="s1">new </span><span class="s0">Set();</span>
  <span class="s1">var </span><span class="s0">resolvedStyles = {};</span>
  <span class="s0">crawlData(data, sources, resolvedStyles);</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">sources: Array.from(sources).sort(),</span>
    <span class="s0">resolvedStyles: resolvedStyles</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">crawlData(data, sources, resolvedStyles) {</span>
  <span class="s1">if </span><span class="s0">(data == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(src_isArray(data)) {</span>
    <span class="s0">data.forEach(</span><span class="s1">function </span><span class="s0">(entry) {</span>
      <span class="s1">if </span><span class="s0">(entry == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(src_isArray(entry)) {</span>
        <span class="s0">crawlData(entry, sources, resolvedStyles);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">crawlObjectProperties(entry, sources, resolvedStyles);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">crawlObjectProperties(data, sources, resolvedStyles);</span>
  <span class="s0">}</span>

  <span class="s0">resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">crawlObjectProperties(entry, sources, resolvedStyles) {</span>
  <span class="s1">var </span><span class="s0">keys = Object.keys(entry);</span>
  <span class="s0">keys.forEach(</span><span class="s1">function </span><span class="s0">(key) {</span>
    <span class="s1">var </span><span class="s0">value = entry[key];</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">'string'</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(key === value) {</span>
        <span class="s3">// Special case; this key is the name of the style's source/file/module.</span>
        <span class="s0">sources.add(key);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">propertyValue = getPropertyValueForStyleName(value);</span>

        <span class="s1">if </span><span class="s0">(propertyValue != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">resolvedStyles[key] = propertyValue;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">nestedStyle = {};</span>
      <span class="s0">resolvedStyles[key] = nestedStyle;</span>
      <span class="s0">crawlData([value], sources, nestedStyle);</span>
    <span class="s0">}</span>
  <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">getPropertyValueForStyleName(styleName) {</span>
  <span class="s1">if </span><span class="s0">(cachedStyleNameToValueMap.has(styleName)) {</span>
    <span class="s1">return </span><span class="s0">cachedStyleNameToValueMap.get(styleName);</span>
  <span class="s0">}</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">styleSheetIndex = </span><span class="s4">0</span><span class="s0">; styleSheetIndex &lt; document.styleSheets.length; styleSheetIndex++) {</span>
    <span class="s1">var </span><span class="s0">styleSheet = document.styleSheets[styleSheetIndex];</span>
    <span class="s1">var </span><span class="s0">rules = </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// this might throw if CORS rules are enforced https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s0">rules = styleSheet.cssRules;</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(_e) {</span>
      <span class="s1">continue</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">ruleIndex = </span><span class="s4">0</span><span class="s0">; ruleIndex &lt; rules.length; ruleIndex++) {</span>
      <span class="s1">if </span><span class="s0">(!(rules[ruleIndex] </span><span class="s1">instanceof </span><span class="s0">CSSStyleRule)) {</span>
        <span class="s1">continue</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">rule = rules[ruleIndex];</span>
      <span class="s1">var </span><span class="s0">cssText = rule.cssText,</span>
          <span class="s0">selectorText = rule.selectorText,</span>
          <span class="s0">style = rule.style;</span>

      <span class="s1">if </span><span class="s0">(selectorText != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(selectorText.startsWith(</span><span class="s2">&quot;.&quot;</span><span class="s0">.concat(styleName))) {</span>
          <span class="s1">var </span><span class="s0">match = cssText.match(/{ *([a-z\-]+):/);</span>

          <span class="s1">if </span><span class="s0">(match !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">property = match[</span><span class="s4">1</span><span class="s0">];</span>
            <span class="s1">var </span><span class="s0">value = style.getPropertyValue(property);</span>
            <span class="s0">cachedStyleNameToValueMap.set(styleName, value);</span>
            <span class="s1">return </span><span class="s0">value;</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return null</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/constants.js</span>
<span class="s1">var </span><span class="s0">CHANGE_LOG_URL = </span><span class="s2">'https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">UNSUPPORTED_VERSION_URL = </span><span class="s2">'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">REACT_DEVTOOLS_WORKPLACE_URL = </span><span class="s2">'https://fburl.com/react-devtools-workplace-group'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">THEME_STYLES = {</span>
  <span class="s0">light: {</span>
    <span class="s2">'--color-attribute-name'</span><span class="s0">: </span><span class="s2">'#ef6632'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-name-not-editable'</span><span class="s0">: </span><span class="s2">'#23272f'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-name-inverted'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.7)'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-value'</span><span class="s0">: </span><span class="s2">'#1a1aa6'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-value-inverted'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-editable-value'</span><span class="s0">: </span><span class="s2">'#1a1aa6'</span><span class="s0">,</span>
    <span class="s2">'--color-background'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-background-hover'</span><span class="s0">: </span><span class="s2">'rgba(0, 136, 250, 0.1)'</span><span class="s0">,</span>
    <span class="s2">'--color-background-inactive'</span><span class="s0">: </span><span class="s2">'#e5e5e5'</span><span class="s0">,</span>
    <span class="s2">'--color-background-invalid'</span><span class="s0">: </span><span class="s2">'#fff0f0'</span><span class="s0">,</span>
    <span class="s2">'--color-background-selected'</span><span class="s0">: </span><span class="s2">'#0088fa'</span><span class="s0">,</span>
    <span class="s2">'--color-button-background'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-button-background-focus'</span><span class="s0">: </span><span class="s2">'#ededed'</span><span class="s0">,</span>
    <span class="s2">'--color-button'</span><span class="s0">: </span><span class="s2">'#5f6673'</span><span class="s0">,</span>
    <span class="s2">'--color-button-disabled'</span><span class="s0">: </span><span class="s2">'#cfd1d5'</span><span class="s0">,</span>
    <span class="s2">'--color-button-active'</span><span class="s0">: </span><span class="s2">'#0088fa'</span><span class="s0">,</span>
    <span class="s2">'--color-button-focus'</span><span class="s0">: </span><span class="s2">'#23272f'</span><span class="s0">,</span>
    <span class="s2">'--color-button-hover'</span><span class="s0">: </span><span class="s2">'#23272f'</span><span class="s0">,</span>
    <span class="s2">'--color-border'</span><span class="s0">: </span><span class="s2">'#eeeeee'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-did-not-render-fill'</span><span class="s0">: </span><span class="s2">'#cfd1d5'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-did-not-render-fill-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-did-not-render-pattern'</span><span class="s0">: </span><span class="s2">'#cfd1d5'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-did-not-render-pattern-text'</span><span class="s0">: </span><span class="s2">'#333333'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-0'</span><span class="s0">: </span><span class="s2">'#37afa9'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-1'</span><span class="s0">: </span><span class="s2">'#63b19e'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-2'</span><span class="s0">: </span><span class="s2">'#80b393'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-3'</span><span class="s0">: </span><span class="s2">'#97b488'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-4'</span><span class="s0">: </span><span class="s2">'#abb67d'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-5'</span><span class="s0">: </span><span class="s2">'#beb771'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-6'</span><span class="s0">: </span><span class="s2">'#cfb965'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-7'</span><span class="s0">: </span><span class="s2">'#dfba57'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-8'</span><span class="s0">: </span><span class="s2">'#efbb49'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-9'</span><span class="s0">: </span><span class="s2">'#febc38'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-component-name'</span><span class="s0">: </span><span class="s2">'#6a51b2'</span><span class="s0">,</span>
    <span class="s2">'--color-component-name-inverted'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-component-badge-background'</span><span class="s0">: </span><span class="s2">'rgba(0, 0, 0, 0.1)'</span><span class="s0">,</span>
    <span class="s2">'--color-component-badge-background-inverted'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.25)'</span><span class="s0">,</span>
    <span class="s2">'--color-component-badge-count'</span><span class="s0">: </span><span class="s2">'#777d88'</span><span class="s0">,</span>
    <span class="s2">'--color-component-badge-count-inverted'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.7)'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-badge-text'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-background'</span><span class="s0">: </span><span class="s2">'#fff0f0'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-border'</span><span class="s0">: </span><span class="s2">'#ffd6d6'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-icon'</span><span class="s0">: </span><span class="s2">'#eb3941'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-text'</span><span class="s0">: </span><span class="s2">'#fe2e31'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-badge-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-background'</span><span class="s0">: </span><span class="s2">'#fffbe5'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-border'</span><span class="s0">: </span><span class="s2">'#fff5c1'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-icon'</span><span class="s0">: </span><span class="s2">'#f4bd00'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-text'</span><span class="s0">: </span><span class="s2">'#64460c'</span><span class="s0">,</span>
    <span class="s2">'--color-context-background'</span><span class="s0">: </span><span class="s2">'rgba(0,0,0,.9)'</span><span class="s0">,</span>
    <span class="s2">'--color-context-background-hover'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.1)'</span><span class="s0">,</span>
    <span class="s2">'--color-context-background-selected'</span><span class="s0">: </span><span class="s2">'#178fb9'</span><span class="s0">,</span>
    <span class="s2">'--color-context-border'</span><span class="s0">: </span><span class="s2">'#3d424a'</span><span class="s0">,</span>
    <span class="s2">'--color-context-text'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-context-text-selected'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-dim'</span><span class="s0">: </span><span class="s2">'#777d88'</span><span class="s0">,</span>
    <span class="s2">'--color-dimmer'</span><span class="s0">: </span><span class="s2">'#cfd1d5'</span><span class="s0">,</span>
    <span class="s2">'--color-dimmest'</span><span class="s0">: </span><span class="s2">'#eff0f1'</span><span class="s0">,</span>
    <span class="s2">'--color-error-background'</span><span class="s0">: </span><span class="s2">'hsl(0, 100%, 97%)'</span><span class="s0">,</span>
    <span class="s2">'--color-error-border'</span><span class="s0">: </span><span class="s2">'hsl(0, 100%, 92%)'</span><span class="s0">,</span>
    <span class="s2">'--color-error-text'</span><span class="s0">: </span><span class="s2">'#ff0000'</span><span class="s0">,</span>
    <span class="s2">'--color-expand-collapse-toggle'</span><span class="s0">: </span><span class="s2">'#777d88'</span><span class="s0">,</span>
    <span class="s2">'--color-link'</span><span class="s0">: </span><span class="s2">'#0000ff'</span><span class="s0">,</span>
    <span class="s2">'--color-modal-background'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.75)'</span><span class="s0">,</span>
    <span class="s2">'--color-bridge-version-npm-background'</span><span class="s0">: </span><span class="s2">'#eff0f1'</span><span class="s0">,</span>
    <span class="s2">'--color-bridge-version-npm-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-bridge-version-number'</span><span class="s0">: </span><span class="s2">'#0088fa'</span><span class="s0">,</span>
    <span class="s2">'--color-primitive-hook-badge-background'</span><span class="s0">: </span><span class="s2">'#e5e5e5'</span><span class="s0">,</span>
    <span class="s2">'--color-primitive-hook-badge-text'</span><span class="s0">: </span><span class="s2">'#5f6673'</span><span class="s0">,</span>
    <span class="s2">'--color-record-active'</span><span class="s0">: </span><span class="s2">'#fc3a4b'</span><span class="s0">,</span>
    <span class="s2">'--color-record-hover'</span><span class="s0">: </span><span class="s2">'#3578e5'</span><span class="s0">,</span>
    <span class="s2">'--color-record-inactive'</span><span class="s0">: </span><span class="s2">'#0088fa'</span><span class="s0">,</span>
    <span class="s2">'--color-resize-bar'</span><span class="s0">: </span><span class="s2">'#eeeeee'</span><span class="s0">,</span>
    <span class="s2">'--color-resize-bar-active'</span><span class="s0">: </span><span class="s2">'#dcdcdc'</span><span class="s0">,</span>
    <span class="s2">'--color-resize-bar-border'</span><span class="s0">: </span><span class="s2">'#d1d1d1'</span><span class="s0">,</span>
    <span class="s2">'--color-resize-bar-dot'</span><span class="s0">: </span><span class="s2">'#333333'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-internal-module'</span><span class="s0">: </span><span class="s2">'#d1d1d1'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-internal-module-hover'</span><span class="s0">: </span><span class="s2">'#c9c9c9'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-internal-module-text'</span><span class="s0">: </span><span class="s2">'#444'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-native-event'</span><span class="s0">: </span><span class="s2">'#ccc'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-native-event-hover'</span><span class="s0">: </span><span class="s2">'#aaa'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-network-primary'</span><span class="s0">: </span><span class="s2">'#fcf3dc'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-network-primary-hover'</span><span class="s0">: </span><span class="s2">'#f0e7d1'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-network-secondary'</span><span class="s0">: </span><span class="s2">'#efc457'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-network-secondary-hover'</span><span class="s0">: </span><span class="s2">'#e3ba52'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-priority-background'</span><span class="s0">: </span><span class="s2">'#f6f6f6'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-priority-border'</span><span class="s0">: </span><span class="s2">'#eeeeee'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-user-timing'</span><span class="s0">: </span><span class="s2">'#c9cacd'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-user-timing-hover'</span><span class="s0">: </span><span class="s2">'#93959a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-idle'</span><span class="s0">: </span><span class="s2">'#d3e5f6'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-idle-hover'</span><span class="s0">: </span><span class="s2">'#c3d9ef'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-render'</span><span class="s0">: </span><span class="s2">'#9fc3f3'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-render-hover'</span><span class="s0">: </span><span class="s2">'#83afe9'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-render-text'</span><span class="s0">: </span><span class="s2">'#11365e'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-commit'</span><span class="s0">: </span><span class="s2">'#c88ff0'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-commit-hover'</span><span class="s0">: </span><span class="s2">'#b281d6'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-commit-text'</span><span class="s0">: </span><span class="s2">'#3e2c4a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-layout-effects'</span><span class="s0">: </span><span class="s2">'#b281d6'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-layout-effects-hover'</span><span class="s0">: </span><span class="s2">'#9d71bd'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-layout-effects-text'</span><span class="s0">: </span><span class="s2">'#3e2c4a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-passive-effects'</span><span class="s0">: </span><span class="s2">'#b281d6'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-passive-effects-hover'</span><span class="s0">: </span><span class="s2">'#9d71bd'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-passive-effects-text'</span><span class="s0">: </span><span class="s2">'#3e2c4a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-schedule'</span><span class="s0">: </span><span class="s2">'#9fc3f3'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-schedule-hover'</span><span class="s0">: </span><span class="s2">'#2683E2'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-rejected'</span><span class="s0">: </span><span class="s2">'#f1cc14'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-rejected-hover'</span><span class="s0">: </span><span class="s2">'#ffdf37'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-resolved'</span><span class="s0">: </span><span class="s2">'#a6e59f'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-resolved-hover'</span><span class="s0">: </span><span class="s2">'#89d281'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-unresolved'</span><span class="s0">: </span><span class="s2">'#c9cacd'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-unresolved-hover'</span><span class="s0">: </span><span class="s2">'#93959a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-thrown-error'</span><span class="s0">: </span><span class="s2">'#ee1638'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-thrown-error-hover'</span><span class="s0">: </span><span class="s2">'#da1030'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-text-color'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-text-dim-color'</span><span class="s0">: </span><span class="s2">'#ccc'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-work-border'</span><span class="s0">: </span><span class="s2">'#eeeeee'</span><span class="s0">,</span>
    <span class="s2">'--color-search-match'</span><span class="s0">: </span><span class="s2">'yellow'</span><span class="s0">,</span>
    <span class="s2">'--color-search-match-current'</span><span class="s0">: </span><span class="s2">'#f7923b'</span><span class="s0">,</span>
    <span class="s2">'--color-selected-tree-highlight-active'</span><span class="s0">: </span><span class="s2">'rgba(0, 136, 250, 0.1)'</span><span class="s0">,</span>
    <span class="s2">'--color-selected-tree-highlight-inactive'</span><span class="s0">: </span><span class="s2">'rgba(0, 0, 0, 0.05)'</span><span class="s0">,</span>
    <span class="s2">'--color-scroll-caret'</span><span class="s0">: </span><span class="s2">'rgba(150, 150, 150, 0.5)'</span><span class="s0">,</span>
    <span class="s2">'--color-tab-selected-border'</span><span class="s0">: </span><span class="s2">'#0088fa'</span><span class="s0">,</span>
    <span class="s2">'--color-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-text-invalid'</span><span class="s0">: </span><span class="s2">'#ff0000'</span><span class="s0">,</span>
    <span class="s2">'--color-text-selected'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-toggle-background-invalid'</span><span class="s0">: </span><span class="s2">'#fc3a4b'</span><span class="s0">,</span>
    <span class="s2">'--color-toggle-background-on'</span><span class="s0">: </span><span class="s2">'#0088fa'</span><span class="s0">,</span>
    <span class="s2">'--color-toggle-background-off'</span><span class="s0">: </span><span class="s2">'#cfd1d5'</span><span class="s0">,</span>
    <span class="s2">'--color-toggle-text'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-warning-background'</span><span class="s0">: </span><span class="s2">'#fb3655'</span><span class="s0">,</span>
    <span class="s2">'--color-warning-background-hover'</span><span class="s0">: </span><span class="s2">'#f82042'</span><span class="s0">,</span>
    <span class="s2">'--color-warning-text-color'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-warning-text-color-inverted'</span><span class="s0">: </span><span class="s2">'#fd4d69'</span><span class="s0">,</span>
    <span class="s3">// The styles below should be kept in sync with 'root.css'</span>
    <span class="s3">// They are repeated there because they're used by e.g. tooltips or context menus</span>
    <span class="s3">// which get rendered outside of the DOM subtree (where normal theme/styles are written).</span>
    <span class="s2">'--color-scroll-thumb'</span><span class="s0">: </span><span class="s2">'#c2c2c2'</span><span class="s0">,</span>
    <span class="s2">'--color-scroll-track'</span><span class="s0">: </span><span class="s2">'#fafafa'</span><span class="s0">,</span>
    <span class="s2">'--color-tooltip-background'</span><span class="s0">: </span><span class="s2">'rgba(0, 0, 0, 0.9)'</span><span class="s0">,</span>
    <span class="s2">'--color-tooltip-text'</span><span class="s0">: </span><span class="s2">'#ffffff'</span>
  <span class="s0">},</span>
  <span class="s0">dark: {</span>
    <span class="s2">'--color-attribute-name'</span><span class="s0">: </span><span class="s2">'#9d87d2'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-name-not-editable'</span><span class="s0">: </span><span class="s2">'#ededed'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-name-inverted'</span><span class="s0">: </span><span class="s2">'#282828'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-value'</span><span class="s0">: </span><span class="s2">'#cedae0'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-value-inverted'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-attribute-editable-value'</span><span class="s0">: </span><span class="s2">'yellow'</span><span class="s0">,</span>
    <span class="s2">'--color-background'</span><span class="s0">: </span><span class="s2">'#282c34'</span><span class="s0">,</span>
    <span class="s2">'--color-background-hover'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.1)'</span><span class="s0">,</span>
    <span class="s2">'--color-background-inactive'</span><span class="s0">: </span><span class="s2">'#3d424a'</span><span class="s0">,</span>
    <span class="s2">'--color-background-invalid'</span><span class="s0">: </span><span class="s2">'#5c0000'</span><span class="s0">,</span>
    <span class="s2">'--color-background-selected'</span><span class="s0">: </span><span class="s2">'#178fb9'</span><span class="s0">,</span>
    <span class="s2">'--color-button-background'</span><span class="s0">: </span><span class="s2">'#282c34'</span><span class="s0">,</span>
    <span class="s2">'--color-button-background-focus'</span><span class="s0">: </span><span class="s2">'#3d424a'</span><span class="s0">,</span>
    <span class="s2">'--color-button'</span><span class="s0">: </span><span class="s2">'#afb3b9'</span><span class="s0">,</span>
    <span class="s2">'--color-button-active'</span><span class="s0">: </span><span class="s2">'#61dafb'</span><span class="s0">,</span>
    <span class="s2">'--color-button-disabled'</span><span class="s0">: </span><span class="s2">'#4f5766'</span><span class="s0">,</span>
    <span class="s2">'--color-button-focus'</span><span class="s0">: </span><span class="s2">'#a2e9fc'</span><span class="s0">,</span>
    <span class="s2">'--color-button-hover'</span><span class="s0">: </span><span class="s2">'#ededed'</span><span class="s0">,</span>
    <span class="s2">'--color-border'</span><span class="s0">: </span><span class="s2">'#3d424a'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-did-not-render-fill'</span><span class="s0">: </span><span class="s2">'#777d88'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-did-not-render-fill-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-did-not-render-pattern'</span><span class="s0">: </span><span class="s2">'#666c77'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-did-not-render-pattern-text'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-0'</span><span class="s0">: </span><span class="s2">'#37afa9'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-1'</span><span class="s0">: </span><span class="s2">'#63b19e'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-2'</span><span class="s0">: </span><span class="s2">'#80b393'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-3'</span><span class="s0">: </span><span class="s2">'#97b488'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-4'</span><span class="s0">: </span><span class="s2">'#abb67d'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-5'</span><span class="s0">: </span><span class="s2">'#beb771'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-6'</span><span class="s0">: </span><span class="s2">'#cfb965'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-7'</span><span class="s0">: </span><span class="s2">'#dfba57'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-8'</span><span class="s0">: </span><span class="s2">'#efbb49'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-9'</span><span class="s0">: </span><span class="s2">'#febc38'</span><span class="s0">,</span>
    <span class="s2">'--color-commit-gradient-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-component-name'</span><span class="s0">: </span><span class="s2">'#61dafb'</span><span class="s0">,</span>
    <span class="s2">'--color-component-name-inverted'</span><span class="s0">: </span><span class="s2">'#282828'</span><span class="s0">,</span>
    <span class="s2">'--color-component-badge-background'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.25)'</span><span class="s0">,</span>
    <span class="s2">'--color-component-badge-background-inverted'</span><span class="s0">: </span><span class="s2">'rgba(0, 0, 0, 0.25)'</span><span class="s0">,</span>
    <span class="s2">'--color-component-badge-count'</span><span class="s0">: </span><span class="s2">'#8f949d'</span><span class="s0">,</span>
    <span class="s2">'--color-component-badge-count-inverted'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.7)'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-badge-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-background'</span><span class="s0">: </span><span class="s2">'#290000'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-border'</span><span class="s0">: </span><span class="s2">'#5c0000'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-icon'</span><span class="s0">: </span><span class="s2">'#eb3941'</span><span class="s0">,</span>
    <span class="s2">'--color-console-error-text'</span><span class="s0">: </span><span class="s2">'#fc7f7f'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-badge-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-background'</span><span class="s0">: </span><span class="s2">'#332b00'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-border'</span><span class="s0">: </span><span class="s2">'#665500'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-icon'</span><span class="s0">: </span><span class="s2">'#f4bd00'</span><span class="s0">,</span>
    <span class="s2">'--color-console-warning-text'</span><span class="s0">: </span><span class="s2">'#f5f2ed'</span><span class="s0">,</span>
    <span class="s2">'--color-context-background'</span><span class="s0">: </span><span class="s2">'rgba(255,255,255,.95)'</span><span class="s0">,</span>
    <span class="s2">'--color-context-background-hover'</span><span class="s0">: </span><span class="s2">'rgba(0, 136, 250, 0.1)'</span><span class="s0">,</span>
    <span class="s2">'--color-context-background-selected'</span><span class="s0">: </span><span class="s2">'#0088fa'</span><span class="s0">,</span>
    <span class="s2">'--color-context-border'</span><span class="s0">: </span><span class="s2">'#eeeeee'</span><span class="s0">,</span>
    <span class="s2">'--color-context-text'</span><span class="s0">: </span><span class="s2">'#000000'</span><span class="s0">,</span>
    <span class="s2">'--color-context-text-selected'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-dim'</span><span class="s0">: </span><span class="s2">'#8f949d'</span><span class="s0">,</span>
    <span class="s2">'--color-dimmer'</span><span class="s0">: </span><span class="s2">'#777d88'</span><span class="s0">,</span>
    <span class="s2">'--color-dimmest'</span><span class="s0">: </span><span class="s2">'#4f5766'</span><span class="s0">,</span>
    <span class="s2">'--color-error-background'</span><span class="s0">: </span><span class="s2">'#200'</span><span class="s0">,</span>
    <span class="s2">'--color-error-border'</span><span class="s0">: </span><span class="s2">'#900'</span><span class="s0">,</span>
    <span class="s2">'--color-error-text'</span><span class="s0">: </span><span class="s2">'#f55'</span><span class="s0">,</span>
    <span class="s2">'--color-expand-collapse-toggle'</span><span class="s0">: </span><span class="s2">'#8f949d'</span><span class="s0">,</span>
    <span class="s2">'--color-link'</span><span class="s0">: </span><span class="s2">'#61dafb'</span><span class="s0">,</span>
    <span class="s2">'--color-modal-background'</span><span class="s0">: </span><span class="s2">'rgba(0, 0, 0, 0.75)'</span><span class="s0">,</span>
    <span class="s2">'--color-bridge-version-npm-background'</span><span class="s0">: </span><span class="s2">'rgba(0, 0, 0, 0.25)'</span><span class="s0">,</span>
    <span class="s2">'--color-bridge-version-npm-text'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-bridge-version-number'</span><span class="s0">: </span><span class="s2">'yellow'</span><span class="s0">,</span>
    <span class="s2">'--color-primitive-hook-badge-background'</span><span class="s0">: </span><span class="s2">'rgba(0, 0, 0, 0.25)'</span><span class="s0">,</span>
    <span class="s2">'--color-primitive-hook-badge-text'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.7)'</span><span class="s0">,</span>
    <span class="s2">'--color-record-active'</span><span class="s0">: </span><span class="s2">'#fc3a4b'</span><span class="s0">,</span>
    <span class="s2">'--color-record-hover'</span><span class="s0">: </span><span class="s2">'#a2e9fc'</span><span class="s0">,</span>
    <span class="s2">'--color-record-inactive'</span><span class="s0">: </span><span class="s2">'#61dafb'</span><span class="s0">,</span>
    <span class="s2">'--color-resize-bar'</span><span class="s0">: </span><span class="s2">'#282c34'</span><span class="s0">,</span>
    <span class="s2">'--color-resize-bar-active'</span><span class="s0">: </span><span class="s2">'#31363f'</span><span class="s0">,</span>
    <span class="s2">'--color-resize-bar-border'</span><span class="s0">: </span><span class="s2">'#3d424a'</span><span class="s0">,</span>
    <span class="s2">'--color-resize-bar-dot'</span><span class="s0">: </span><span class="s2">'#cfd1d5'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-internal-module'</span><span class="s0">: </span><span class="s2">'#303542'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-internal-module-hover'</span><span class="s0">: </span><span class="s2">'#363b4a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-internal-module-text'</span><span class="s0">: </span><span class="s2">'#7f8899'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-native-event'</span><span class="s0">: </span><span class="s2">'#b2b2b2'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-native-event-hover'</span><span class="s0">: </span><span class="s2">'#949494'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-network-primary'</span><span class="s0">: </span><span class="s2">'#fcf3dc'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-network-primary-hover'</span><span class="s0">: </span><span class="s2">'#e3dbc5'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-network-secondary'</span><span class="s0">: </span><span class="s2">'#efc457'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-network-secondary-hover'</span><span class="s0">: </span><span class="s2">'#d6af4d'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-priority-background'</span><span class="s0">: </span><span class="s2">'#1d2129'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-priority-border'</span><span class="s0">: </span><span class="s2">'#282c34'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-user-timing'</span><span class="s0">: </span><span class="s2">'#c9cacd'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-user-timing-hover'</span><span class="s0">: </span><span class="s2">'#93959a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-idle'</span><span class="s0">: </span><span class="s2">'#3d485b'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-idle-hover'</span><span class="s0">: </span><span class="s2">'#465269'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-render'</span><span class="s0">: </span><span class="s2">'#2683E2'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-render-hover'</span><span class="s0">: </span><span class="s2">'#1a76d4'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-render-text'</span><span class="s0">: </span><span class="s2">'#11365e'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-commit'</span><span class="s0">: </span><span class="s2">'#731fad'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-commit-hover'</span><span class="s0">: </span><span class="s2">'#611b94'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-commit-text'</span><span class="s0">: </span><span class="s2">'#e5c1ff'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-layout-effects'</span><span class="s0">: </span><span class="s2">'#611b94'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-layout-effects-hover'</span><span class="s0">: </span><span class="s2">'#51167a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-layout-effects-text'</span><span class="s0">: </span><span class="s2">'#e5c1ff'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-passive-effects'</span><span class="s0">: </span><span class="s2">'#611b94'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-passive-effects-hover'</span><span class="s0">: </span><span class="s2">'#51167a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-passive-effects-text'</span><span class="s0">: </span><span class="s2">'#e5c1ff'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-schedule'</span><span class="s0">: </span><span class="s2">'#2683E2'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-schedule-hover'</span><span class="s0">: </span><span class="s2">'#1a76d4'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-rejected'</span><span class="s0">: </span><span class="s2">'#f1cc14'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-rejected-hover'</span><span class="s0">: </span><span class="s2">'#e4c00f'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-resolved'</span><span class="s0">: </span><span class="s2">'#a6e59f'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-resolved-hover'</span><span class="s0">: </span><span class="s2">'#89d281'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-unresolved'</span><span class="s0">: </span><span class="s2">'#c9cacd'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-suspense-unresolved-hover'</span><span class="s0">: </span><span class="s2">'#93959a'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-thrown-error'</span><span class="s0">: </span><span class="s2">'#fb3655'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-thrown-error-hover'</span><span class="s0">: </span><span class="s2">'#f82042'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-text-color'</span><span class="s0">: </span><span class="s2">'#282c34'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-text-dim-color'</span><span class="s0">: </span><span class="s2">'#555b66'</span><span class="s0">,</span>
    <span class="s2">'--color-timeline-react-work-border'</span><span class="s0">: </span><span class="s2">'#3d424a'</span><span class="s0">,</span>
    <span class="s2">'--color-search-match'</span><span class="s0">: </span><span class="s2">'yellow'</span><span class="s0">,</span>
    <span class="s2">'--color-search-match-current'</span><span class="s0">: </span><span class="s2">'#f7923b'</span><span class="s0">,</span>
    <span class="s2">'--color-selected-tree-highlight-active'</span><span class="s0">: </span><span class="s2">'rgba(23, 143, 185, 0.15)'</span><span class="s0">,</span>
    <span class="s2">'--color-selected-tree-highlight-inactive'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.05)'</span><span class="s0">,</span>
    <span class="s2">'--color-scroll-caret'</span><span class="s0">: </span><span class="s2">'#4f5766'</span><span class="s0">,</span>
    <span class="s2">'--color-shadow'</span><span class="s0">: </span><span class="s2">'rgba(0, 0, 0, 0.5)'</span><span class="s0">,</span>
    <span class="s2">'--color-tab-selected-border'</span><span class="s0">: </span><span class="s2">'#178fb9'</span><span class="s0">,</span>
    <span class="s2">'--color-text'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-text-invalid'</span><span class="s0">: </span><span class="s2">'#ff8080'</span><span class="s0">,</span>
    <span class="s2">'--color-text-selected'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-toggle-background-invalid'</span><span class="s0">: </span><span class="s2">'#fc3a4b'</span><span class="s0">,</span>
    <span class="s2">'--color-toggle-background-on'</span><span class="s0">: </span><span class="s2">'#178fb9'</span><span class="s0">,</span>
    <span class="s2">'--color-toggle-background-off'</span><span class="s0">: </span><span class="s2">'#777d88'</span><span class="s0">,</span>
    <span class="s2">'--color-toggle-text'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-warning-background'</span><span class="s0">: </span><span class="s2">'#ee1638'</span><span class="s0">,</span>
    <span class="s2">'--color-warning-background-hover'</span><span class="s0">: </span><span class="s2">'#da1030'</span><span class="s0">,</span>
    <span class="s2">'--color-warning-text-color'</span><span class="s0">: </span><span class="s2">'#ffffff'</span><span class="s0">,</span>
    <span class="s2">'--color-warning-text-color-inverted'</span><span class="s0">: </span><span class="s2">'#ee1638'</span><span class="s0">,</span>
    <span class="s3">// The styles below should be kept in sync with 'root.css'</span>
    <span class="s3">// They are repeated there because they're used by e.g. tooltips or context menus</span>
    <span class="s3">// which get rendered outside of the DOM subtree (where normal theme/styles are written).</span>
    <span class="s2">'--color-scroll-thumb'</span><span class="s0">: </span><span class="s2">'#afb3b9'</span><span class="s0">,</span>
    <span class="s2">'--color-scroll-track'</span><span class="s0">: </span><span class="s2">'#313640'</span><span class="s0">,</span>
    <span class="s2">'--color-tooltip-background'</span><span class="s0">: </span><span class="s2">'rgba(255, 255, 255, 0.95)'</span><span class="s0">,</span>
    <span class="s2">'--color-tooltip-text'</span><span class="s0">: </span><span class="s2">'#000000'</span>
  <span class="s0">},</span>
  <span class="s0">compact: {</span>
    <span class="s2">'--font-size-monospace-small'</span><span class="s0">: </span><span class="s2">'9px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-monospace-normal'</span><span class="s0">: </span><span class="s2">'11px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-monospace-large'</span><span class="s0">: </span><span class="s2">'15px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-sans-small'</span><span class="s0">: </span><span class="s2">'10px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-sans-normal'</span><span class="s0">: </span><span class="s2">'12px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-sans-large'</span><span class="s0">: </span><span class="s2">'14px'</span><span class="s0">,</span>
    <span class="s2">'--line-height-data'</span><span class="s0">: </span><span class="s2">'18px'</span>
  <span class="s0">},</span>
  <span class="s0">comfortable: {</span>
    <span class="s2">'--font-size-monospace-small'</span><span class="s0">: </span><span class="s2">'10px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-monospace-normal'</span><span class="s0">: </span><span class="s2">'13px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-monospace-large'</span><span class="s0">: </span><span class="s2">'17px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-sans-small'</span><span class="s0">: </span><span class="s2">'12px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-sans-normal'</span><span class="s0">: </span><span class="s2">'14px'</span><span class="s0">,</span>
    <span class="s2">'--font-size-sans-large'</span><span class="s0">: </span><span class="s2">'16px'</span><span class="s0">,</span>
    <span class="s2">'--line-height-data'</span><span class="s0">: </span><span class="s2">'22px'</span>
  <span class="s0">}</span>
<span class="s0">}; </span><span class="s3">// HACK</span>
<span class="s3">//</span>
<span class="s3">// Sometimes the inline target is rendered before root styles are applied,</span>
<span class="s3">// which would result in e.g. NaN itemSize being passed to react-window list.</span>

<span class="s1">var </span><span class="s0">COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable[</span><span class="s2">'--line-height-data'</span><span class="s0">], </span><span class="s4">10</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact[</span><span class="s2">'--line-height-data'</span><span class="s0">], </span><span class="s4">10</span><span class="s0">);</span>

<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-timeline/src/constants.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s1">var </span><span class="s0">REACT_TOTAL_NUM_LANES = </span><span class="s4">31</span><span class="s0">; </span><span class="s3">// Increment this number any time a backwards breaking change is made to the profiler metadata.</span>

<span class="s1">var </span><span class="s0">SCHEDULING_PROFILER_VERSION = </span><span class="s4">1</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">SNAPSHOT_MAX_HEIGHT = </span><span class="s4">60</span><span class="s0">;</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsConsolePatching.js</span>
<span class="s1">function </span><span class="s0">DevToolsConsolePatching_ownKeys(object, enumerableOnly) { </span><span class="s1">var </span><span class="s0">keys = Object.keys(object); </span><span class="s1">if </span><span class="s0">(Object.getOwnPropertySymbols) { </span><span class="s1">var </span><span class="s0">symbols = Object.getOwnPropertySymbols(object); </span><span class="s1">if </span><span class="s0">(enumerableOnly) symbols = symbols.filter(</span><span class="s1">function </span><span class="s0">(sym) { </span><span class="s1">return </span><span class="s0">Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } </span><span class="s1">return </span><span class="s0">keys; }</span>

<span class="s1">function </span><span class="s0">DevToolsConsolePatching_objectSpread(target) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; arguments.length; i++) { </span><span class="s1">var </span><span class="s0">source = arguments[i] != </span><span class="s1">null </span><span class="s0">? arguments[i] : {}; </span><span class="s1">if </span><span class="s0">(i % </span><span class="s4">2</span><span class="s0">) { DevToolsConsolePatching_ownKeys(Object(source), </span><span class="s1">true</span><span class="s0">).forEach(</span><span class="s1">function </span><span class="s0">(key) { DevToolsConsolePatching_defineProperty(target, key, source[key]); }); } </span><span class="s1">else if </span><span class="s0">(Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } </span><span class="s1">else </span><span class="s0">{ DevToolsConsolePatching_ownKeys(Object(source)).forEach(</span><span class="s1">function </span><span class="s0">(key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } </span><span class="s1">return </span><span class="s0">target; }</span>

<span class="s1">function </span><span class="s0">DevToolsConsolePatching_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s3">// This is a DevTools fork of shared/ConsolePatchingDev.</span>
<span class="s3">// The shared console patching code is DEV-only.</span>
<span class="s3">// We can't use it since DevTools only ships production builds.</span>
<span class="s3">// Helpers to patch console.logs to avoid logging during side-effect free</span>
<span class="s3">// replaying on render function. This currently only patches the object</span>
<span class="s3">// lazily which won't cover if the log function was extracted eagerly.</span>
<span class="s3">// We could also eagerly patch the method.</span>
<span class="s1">var </span><span class="s0">disabledDepth = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">prevLog;</span>
<span class="s1">var </span><span class="s0">prevInfo;</span>
<span class="s1">var </span><span class="s0">prevWarn;</span>
<span class="s1">var </span><span class="s0">prevError;</span>
<span class="s1">var </span><span class="s0">prevGroup;</span>
<span class="s1">var </span><span class="s0">prevGroupCollapsed;</span>
<span class="s1">var </span><span class="s0">prevGroupEnd;</span>

<span class="s1">function </span><span class="s0">disabledLog() {}</span>

<span class="s0">disabledLog.__reactDisabledLog = </span><span class="s1">true</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">disableLogs() {</span>
  <span class="s1">if </span><span class="s0">(disabledDepth === </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s3">/* eslint-disable react-internal/no-production-logging */</span>
    <span class="s0">prevLog = console.log;</span>
    <span class="s0">prevInfo = console.info;</span>
    <span class="s0">prevWarn = console.warn;</span>
    <span class="s0">prevError = console.error;</span>
    <span class="s0">prevGroup = console.group;</span>
    <span class="s0">prevGroupCollapsed = console.groupCollapsed;</span>
    <span class="s0">prevGroupEnd = console.groupEnd; </span><span class="s3">// https://github.com/facebook/react/issues/19099</span>

    <span class="s1">var </span><span class="s0">props = {</span>
      <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
      <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
      <span class="s0">value: disabledLog,</span>
      <span class="s0">writable: </span><span class="s1">true</span>
    <span class="s0">}; </span><span class="s3">// $FlowFixMe[cannot-write] Flow thinks console is immutable.</span>

    <span class="s0">Object.defineProperties(console, {</span>
      <span class="s0">info: props,</span>
      <span class="s0">log: props,</span>
      <span class="s0">warn: props,</span>
      <span class="s0">error: props,</span>
      <span class="s0">group: props,</span>
      <span class="s0">groupCollapsed: props,</span>
      <span class="s0">groupEnd: props</span>
    <span class="s0">});</span>
    <span class="s3">/* eslint-enable react-internal/no-production-logging */</span>
  <span class="s0">}</span>

  <span class="s0">disabledDepth++;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">reenableLogs() {</span>
  <span class="s0">disabledDepth--;</span>

  <span class="s1">if </span><span class="s0">(disabledDepth === </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s3">/* eslint-disable react-internal/no-production-logging */</span>
    <span class="s1">var </span><span class="s0">props = {</span>
      <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
      <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
      <span class="s0">writable: </span><span class="s1">true</span>
    <span class="s0">}; </span><span class="s3">// $FlowFixMe[cannot-write] Flow thinks console is immutable.</span>

    <span class="s0">Object.defineProperties(console, {</span>
      <span class="s0">log: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {</span>
        <span class="s0">value: prevLog</span>
      <span class="s0">}),</span>
      <span class="s0">info: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {</span>
        <span class="s0">value: prevInfo</span>
      <span class="s0">}),</span>
      <span class="s0">warn: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {</span>
        <span class="s0">value: prevWarn</span>
      <span class="s0">}),</span>
      <span class="s0">error: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {</span>
        <span class="s0">value: prevError</span>
      <span class="s0">}),</span>
      <span class="s0">group: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {</span>
        <span class="s0">value: prevGroup</span>
      <span class="s0">}),</span>
      <span class="s0">groupCollapsed: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {</span>
        <span class="s0">value: prevGroupCollapsed</span>
      <span class="s0">}),</span>
      <span class="s0">groupEnd: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {</span>
        <span class="s0">value: prevGroupEnd</span>
      <span class="s0">})</span>
    <span class="s0">});</span>
    <span class="s3">/* eslint-enable react-internal/no-production-logging */</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(disabledDepth &lt; </span><span class="s4">0</span><span class="s0">) {</span>
    <span class="s0">console.error(</span><span class="s2">'disabledDepth fell below zero. ' </span><span class="s0">+ </span><span class="s2">'This is a bug in React. Please file an issue.'</span><span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js</span>
<span class="s1">function </span><span class="s0">DevToolsComponentStackFrame_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { DevToolsComponentStackFrame_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ DevToolsComponentStackFrame_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">DevToolsComponentStackFrame_typeof(obj); }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s3">// This is a DevTools fork of ReactComponentStackFrame.</span>
<span class="s3">// This fork enables DevTools to use the same &quot;native&quot; component stack format,</span>
<span class="s3">// while still maintaining support for multiple renderer versions</span>
<span class="s3">// (which use different values for ReactTypeOfWork).</span>
 <span class="s3">// The shared console patching code is DEV-only.</span>
<span class="s3">// We can't use it since DevTools only ships production builds.</span>


<span class="s1">var </span><span class="s0">prefix;</span>
<span class="s1">function </span><span class="s0">describeBuiltInComponentFrame(name, ownerFn) {</span>
  <span class="s1">if </span><span class="s0">(prefix === undefined) {</span>
    <span class="s3">// Extract the VM specific prefix used by each line.</span>
    <span class="s1">try </span><span class="s0">{</span>
      <span class="s1">throw </span><span class="s0">Error();</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(x) {</span>
      <span class="s1">var </span><span class="s0">match = x.stack.trim().match(/\n( *(at )?)/);</span>
      <span class="s0">prefix = match &amp;&amp; match[</span><span class="s4">1</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// We use the prefix to ensure our stacks line up with native stack frames.</span>


  <span class="s1">return </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">' </span><span class="s0">+ prefix + name;</span>
<span class="s0">}</span>
<span class="s1">var </span><span class="s0">reentry = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">componentFrameCache;</span>

<span class="s1">if </span><span class="s0">(</span><span class="s1">false</span><span class="s0">) { </span><span class="s1">var </span><span class="s0">PossiblyWeakMap; }</span>

<span class="s1">function </span><span class="s0">describeNativeComponentFrame(fn, construct, currentDispatcherRef) {</span>
  <span class="s3">// If something asked for a stack inside a fake render, it should get ignored.</span>
  <span class="s1">if </span><span class="s0">(!fn || reentry) {</span>
    <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">false</span><span class="s0">) { </span><span class="s1">var </span><span class="s0">frame; }</span>

  <span class="s1">var </span><span class="s0">control;</span>
  <span class="s1">var </span><span class="s0">previousPrepareStackTrace = Error.prepareStackTrace; </span><span class="s3">// $FlowFixMe[incompatible-type] It does accept undefined.</span>

  <span class="s0">Error.prepareStackTrace = undefined;</span>
  <span class="s0">reentry = </span><span class="s1">true</span><span class="s0">; </span><span class="s3">// Override the dispatcher so effects scheduled by this shallow render are thrown away.</span>
  <span class="s3">//</span>
  <span class="s3">// Note that unlike the code this was forked from (in ReactComponentStackFrame)</span>
  <span class="s3">// DevTools should override the dispatcher even when DevTools is compiled in production mode,</span>
  <span class="s3">// because the app itself may be in development mode and log errors/warnings.</span>

  <span class="s1">var </span><span class="s0">previousDispatcher = currentDispatcherRef.current;</span>
  <span class="s0">currentDispatcherRef.current = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">disableLogs();</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s3">// This should throw.</span>
    <span class="s1">if </span><span class="s0">(construct) {</span>
      <span class="s3">// Something should be setting the props in the constructor.</span>
      <span class="s1">var </span><span class="s0">Fake = </span><span class="s1">function </span><span class="s0">Fake() {</span>
        <span class="s1">throw </span><span class="s0">Error();</span>
      <span class="s0">}; </span><span class="s3">// $FlowFixMe[prop-missing]</span>


      <span class="s0">Object.defineProperty(Fake.prototype, </span><span class="s2">'props'</span><span class="s0">, {</span>
        <span class="s0">set: </span><span class="s1">function </span><span class="s0">set() {</span>
          <span class="s3">// We use a throwing setter instead of frozen or non-writable props</span>
          <span class="s3">// because that won't throw in a non-strict mode function.</span>
          <span class="s1">throw </span><span class="s0">Error();</span>
        <span class="s0">}</span>
      <span class="s0">});</span>

      <span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">Reflect === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? </span><span class="s2">&quot;undefined&quot; </span><span class="s0">: DevToolsComponentStackFrame_typeof(Reflect)) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; Reflect.construct) {</span>
        <span class="s3">// We construct a different control for this case to include any extra</span>
        <span class="s3">// frames added by the construct call.</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s0">Reflect.construct(Fake, []);</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(x) {</span>
          <span class="s0">control = x;</span>
        <span class="s0">}</span>

        <span class="s0">Reflect.construct(fn, [], Fake);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s0">Fake.call();</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(x) {</span>
          <span class="s0">control = x;</span>
        <span class="s0">} </span><span class="s3">// $FlowFixMe[prop-missing] found when upgrading Flow</span>


        <span class="s0">fn.call(Fake.prototype);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">throw </span><span class="s0">Error();</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(x) {</span>
        <span class="s0">control = x;</span>
      <span class="s0">}</span>

      <span class="s0">fn();</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(sample) {</span>
    <span class="s3">// This is inlined manually because closure doesn't do it for us.</span>
    <span class="s1">if </span><span class="s0">(sample &amp;&amp; control &amp;&amp; </span><span class="s1">typeof </span><span class="s0">sample.stack === </span><span class="s2">'string'</span><span class="s0">) {</span>
      <span class="s3">// This extracts the first frame from the sample that isn't also in the control.</span>
      <span class="s3">// Skipping one frame that we assume is the frame that calls the two.</span>
      <span class="s1">var </span><span class="s0">sampleLines = sample.stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">);</span>
      <span class="s1">var </span><span class="s0">controlLines = control.stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">);</span>
      <span class="s1">var </span><span class="s0">s = sampleLines.length - </span><span class="s4">1</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">c = controlLines.length - </span><span class="s4">1</span><span class="s0">;</span>

      <span class="s1">while </span><span class="s0">(s &gt;= </span><span class="s4">1 </span><span class="s0">&amp;&amp; c &gt;= </span><span class="s4">0 </span><span class="s0">&amp;&amp; sampleLines[s] !== controlLines[c]) {</span>
        <span class="s3">// We expect at least one stack frame to be shared.</span>
        <span class="s3">// Typically this will be the root most one. However, stack frames may be</span>
        <span class="s3">// cut off due to maximum stack limits. In this case, one maybe cut off</span>
        <span class="s3">// earlier than the other. We assume that the sample is longer or the same</span>
        <span class="s3">// and there for cut off earlier. So we should find the root most frame in</span>
        <span class="s3">// the sample somewhere in the control.</span>
        <span class="s0">c--;</span>
      <span class="s0">}</span>

      <span class="s1">for </span><span class="s0">(; s &gt;= </span><span class="s4">1 </span><span class="s0">&amp;&amp; c &gt;= </span><span class="s4">0</span><span class="s0">; s--, c--) {</span>
        <span class="s3">// Next we find the first one that isn't the same which should be the</span>
        <span class="s3">// frame that called our sample function and the control.</span>
        <span class="s1">if </span><span class="s0">(sampleLines[s] !== controlLines[c]) {</span>
          <span class="s3">// In V8, the first line is describing the message but other VMs don't.</span>
          <span class="s3">// If we're about to return the first line, and the control is also on the same</span>
          <span class="s3">// line, that's a pretty good indicator that our sample threw at same line as</span>
          <span class="s3">// the control. I.e. before we entered the sample frame. So we ignore this result.</span>
          <span class="s3">// This can happen if you passed a class to function component, or non-function.</span>
          <span class="s1">if </span><span class="s0">(s !== </span><span class="s4">1 </span><span class="s0">|| c !== </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">do </span><span class="s0">{</span>
              <span class="s0">s--;</span>
              <span class="s0">c--; </span><span class="s3">// We may still have similar intermediate frames from the construct call.</span>
              <span class="s3">// The next one that isn't the same should be our match though.</span>

              <span class="s1">if </span><span class="s0">(c &lt; </span><span class="s4">0 </span><span class="s0">|| sampleLines[s] !== controlLines[c]) {</span>
                <span class="s3">// V8 adds a &quot;new&quot; prefix for native classes. Let's remove it to make it prettier.</span>
                <span class="s1">var </span><span class="s0">_frame = </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">' </span><span class="s0">+ sampleLines[s].replace(</span><span class="s2">' at new '</span><span class="s0">, </span><span class="s2">' at '</span><span class="s0">);</span>

                <span class="s1">if </span><span class="s0">(</span><span class="s1">false</span><span class="s0">) {} </span><span class="s3">// Return the line we found.</span>


                <span class="s1">return </span><span class="s0">_frame;</span>
              <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">while </span><span class="s0">(s &gt;= </span><span class="s4">1 </span><span class="s0">&amp;&amp; c &gt;= </span><span class="s4">0</span><span class="s0">);</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
    <span class="s0">reentry = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">Error.prepareStackTrace = previousPrepareStackTrace;</span>
    <span class="s0">currentDispatcherRef.current = previousDispatcher;</span>
    <span class="s0">reenableLogs();</span>
  <span class="s0">} </span><span class="s3">// Fallback to just using the name if we couldn't make it throw.</span>


  <span class="s1">var </span><span class="s0">name = fn ? fn.displayName || fn.name : </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">syntheticFrame = name ? describeBuiltInComponentFrame(name) : </span><span class="s2">''</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">false</span><span class="s0">) {}</span>

  <span class="s1">return </span><span class="s0">syntheticFrame;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">describeClassComponentFrame(ctor, ownerFn, currentDispatcherRef) {</span>
  <span class="s1">return </span><span class="s0">describeNativeComponentFrame(ctor, </span><span class="s1">true</span><span class="s0">, currentDispatcherRef);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">describeFunctionComponentFrame(fn, ownerFn, currentDispatcherRef) {</span>
  <span class="s1">return </span><span class="s0">describeNativeComponentFrame(fn, </span><span class="s1">false</span><span class="s0">, currentDispatcherRef);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">shouldConstruct(Component) {</span>
  <span class="s1">var </span><span class="s0">prototype = Component.prototype;</span>
  <span class="s1">return </span><span class="s0">!!(prototype &amp;&amp; prototype.isReactComponent);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">describeUnknownElementTypeFrameInDEV(type, ownerFn, currentDispatcherRef) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(type == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">type === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">type === </span><span class="s2">'string'</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s0">describeBuiltInComponentFrame(type, ownerFn);</span>
  <span class="s0">}</span>

  <span class="s1">switch </span><span class="s0">(type) {</span>
    <span class="s1">case </span><span class="s0">SUSPENSE_NUMBER:</span>
    <span class="s1">case </span><span class="s0">SUSPENSE_SYMBOL_STRING:</span>
      <span class="s1">return </span><span class="s0">describeBuiltInComponentFrame(</span><span class="s2">'Suspense'</span><span class="s0">, ownerFn);</span>

    <span class="s1">case </span><span class="s0">SUSPENSE_LIST_NUMBER:</span>
    <span class="s1">case </span><span class="s0">SUSPENSE_LIST_SYMBOL_STRING:</span>
      <span class="s1">return </span><span class="s0">describeBuiltInComponentFrame(</span><span class="s2">'SuspenseList'</span><span class="s0">, ownerFn);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(DevToolsComponentStackFrame_typeof(type) === </span><span class="s2">'object'</span><span class="s0">) {</span>
    <span class="s1">switch </span><span class="s0">(type.$$typeof) {</span>
      <span class="s1">case </span><span class="s0">FORWARD_REF_NUMBER:</span>
      <span class="s1">case </span><span class="s0">FORWARD_REF_SYMBOL_STRING:</span>
        <span class="s1">return </span><span class="s0">describeFunctionComponentFrame(type.render, ownerFn, currentDispatcherRef);</span>

      <span class="s1">case </span><span class="s0">MEMO_NUMBER:</span>
      <span class="s1">case </span><span class="s0">MEMO_SYMBOL_STRING:</span>
        <span class="s3">// Memo may contain any component type so we recursively resolve it.</span>
        <span class="s1">return </span><span class="s0">describeUnknownElementTypeFrameInDEV(type.type, ownerFn, currentDispatcherRef);</span>

      <span class="s1">case </span><span class="s0">LAZY_NUMBER:</span>
      <span class="s1">case </span><span class="s0">LAZY_SYMBOL_STRING:</span>
        <span class="s0">{</span>
          <span class="s1">var </span><span class="s0">lazyComponent = type;</span>
          <span class="s1">var </span><span class="s0">payload = lazyComponent._payload;</span>
          <span class="s1">var </span><span class="s0">init = lazyComponent._init;</span>

          <span class="s1">try </span><span class="s0">{</span>
            <span class="s3">// Lazy may contain any component type so we recursively resolve it.</span>
            <span class="s1">return </span><span class="s0">describeUnknownElementTypeFrameInDEV(init(payload), ownerFn, currentDispatcherRef);</span>
          <span class="s0">} </span><span class="s1">catch </span><span class="s0">(x) {}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s3">// This is a DevTools fork of ReactFiberComponentStack.</span>
<span class="s3">// This fork enables DevTools to use the same &quot;native&quot; component stack format,</span>
<span class="s3">// while still maintaining support for multiple renderer versions</span>
<span class="s3">// (which use different values for ReactTypeOfWork).</span>

<span class="s1">function </span><span class="s0">describeFiber(workTagMap, workInProgress, currentDispatcherRef) {</span>
  <span class="s1">var </span><span class="s0">HostComponent = workTagMap.HostComponent,</span>
      <span class="s0">LazyComponent = workTagMap.LazyComponent,</span>
      <span class="s0">SuspenseComponent = workTagMap.SuspenseComponent,</span>
      <span class="s0">SuspenseListComponent = workTagMap.SuspenseListComponent,</span>
      <span class="s0">FunctionComponent = workTagMap.FunctionComponent,</span>
      <span class="s0">IndeterminateComponent = workTagMap.IndeterminateComponent,</span>
      <span class="s0">SimpleMemoComponent = workTagMap.SimpleMemoComponent,</span>
      <span class="s0">ForwardRef = workTagMap.ForwardRef,</span>
      <span class="s0">ClassComponent = workTagMap.ClassComponent;</span>
  <span class="s1">var </span><span class="s0">owner =  </span><span class="s1">false </span><span class="s0">? </span><span class="s4">0 </span><span class="s0">: </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">switch </span><span class="s0">(workInProgress.tag) {</span>
    <span class="s1">case </span><span class="s0">HostComponent:</span>
      <span class="s1">return </span><span class="s0">describeBuiltInComponentFrame(workInProgress.type, owner);</span>

    <span class="s1">case </span><span class="s0">LazyComponent:</span>
      <span class="s1">return </span><span class="s0">describeBuiltInComponentFrame(</span><span class="s2">'Lazy'</span><span class="s0">, owner);</span>

    <span class="s1">case </span><span class="s0">SuspenseComponent:</span>
      <span class="s1">return </span><span class="s0">describeBuiltInComponentFrame(</span><span class="s2">'Suspense'</span><span class="s0">, owner);</span>

    <span class="s1">case </span><span class="s0">SuspenseListComponent:</span>
      <span class="s1">return </span><span class="s0">describeBuiltInComponentFrame(</span><span class="s2">'SuspenseList'</span><span class="s0">, owner);</span>

    <span class="s1">case </span><span class="s0">FunctionComponent:</span>
    <span class="s1">case </span><span class="s0">IndeterminateComponent:</span>
    <span class="s1">case </span><span class="s0">SimpleMemoComponent:</span>
      <span class="s1">return </span><span class="s0">describeFunctionComponentFrame(workInProgress.type, owner, currentDispatcherRef);</span>

    <span class="s1">case </span><span class="s0">ForwardRef:</span>
      <span class="s1">return </span><span class="s0">describeFunctionComponentFrame(workInProgress.type.render, owner, currentDispatcherRef);</span>

    <span class="s1">case </span><span class="s0">ClassComponent:</span>
      <span class="s1">return </span><span class="s0">describeClassComponentFrame(workInProgress.type, owner, currentDispatcherRef);</span>

    <span class="s1">default</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {</span>
  <span class="s1">try </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">info = </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">node = workInProgress;</span>

    <span class="s1">do </span><span class="s0">{</span>
      <span class="s0">info += describeFiber(workTagMap, node, currentDispatcherRef); </span><span class="s3">// $FlowFixMe[incompatible-type] we bail out when we get a null</span>

      <span class="s0">node = node.</span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">while </span><span class="s0">(node);</span>

    <span class="s1">return </span><span class="s0">info;</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(x) {</span>
    <span class="s1">return </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">Error generating stack: ' </span><span class="s0">+ x.message + </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">' </span><span class="s0">+ x.stack;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/profilingHooks.js</span>
<span class="s1">function </span><span class="s0">profilingHooks_slicedToArray(arr, i) { </span><span class="s1">return </span><span class="s0">profilingHooks_arrayWithHoles(arr) || profilingHooks_iterableToArrayLimit(arr, i) || profilingHooks_unsupportedIterableToArray(arr, i) || profilingHooks_nonIterableRest(); }</span>

<span class="s1">function </span><span class="s0">profilingHooks_nonIterableRest() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to destructure non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">profilingHooks_unsupportedIterableToArray(o, minLen) { </span><span class="s1">if </span><span class="s0">(!o) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">o === </span><span class="s2">&quot;string&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">profilingHooks_arrayLikeToArray(o, minLen); </span><span class="s1">var </span><span class="s0">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s0">&amp;&amp; o.constructor) n = o.constructor.name; </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s0">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">Array.from(o); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s0">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s0">|</span><span class="s4">16</span><span class="s0">|</span><span class="s4">32</span><span class="s0">)(?:Clamped)?Array$/.test(n)) </span><span class="s1">return </span><span class="s0">profilingHooks_arrayLikeToArray(o, minLen); }</span>

<span class="s1">function </span><span class="s0">profilingHooks_arrayLikeToArray(arr, len) { </span><span class="s1">if </span><span class="s0">(len == </span><span class="s1">null </span><span class="s0">|| len &gt; arr.length) len = arr.length; </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, arr2 = </span><span class="s1">new </span><span class="s0">Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } </span><span class="s1">return </span><span class="s0">arr2; }</span>

<span class="s1">function </span><span class="s0">profilingHooks_iterableToArrayLimit(arr, i) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">|| !(Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(arr))) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_arr = []; </span><span class="s1">var </span><span class="s0">_n = </span><span class="s1">true</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_d = </span><span class="s1">false</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_e = undefined; </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = </span><span class="s1">true</span><span class="s0">) { _arr.push(_s.value); </span><span class="s1">if </span><span class="s0">(i &amp;&amp; _arr.length === i) </span><span class="s1">break</span><span class="s0">; } } </span><span class="s1">catch </span><span class="s0">(err) { _d = </span><span class="s1">true</span><span class="s0">; _e = err; } </span><span class="s1">finally </span><span class="s0">{ </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(!_n &amp;&amp; _i[</span><span class="s2">&quot;return&quot;</span><span class="s0">] != </span><span class="s1">null</span><span class="s0">) _i[</span><span class="s2">&quot;return&quot;</span><span class="s0">](); } </span><span class="s1">finally </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(_d) </span><span class="s1">throw </span><span class="s0">_e; } } </span><span class="s1">return </span><span class="s0">_arr; }</span>

<span class="s1">function </span><span class="s0">profilingHooks_arrayWithHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">arr; }</span>

<span class="s1">function </span><span class="s0">profilingHooks_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { profilingHooks_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ profilingHooks_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">profilingHooks_typeof(obj); }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>


 <span class="s3">// Add padding to the start/stop time of the profile.</span>
<span class="s3">// This makes the UI nicer to use.</span>

<span class="s1">var </span><span class="s0">TIME_OFFSET = </span><span class="s4">10</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">performanceTarget = </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// If performance exists and supports the subset of the User Timing API that we require.</span>

<span class="s1">var </span><span class="s0">supportsUserTiming = </span><span class="s1">typeof </span><span class="s0">performance !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s3">// $FlowFixMe[method-unbinding]</span>
<span class="s1">typeof </span><span class="s0">performance.mark === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; </span><span class="s3">// $FlowFixMe[method-unbinding]</span>
<span class="s1">typeof </span><span class="s0">performance.clearMarks === </span><span class="s2">'function'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">supportsUserTimingV3 = </span><span class="s1">false</span><span class="s0">;</span>

<span class="s1">if </span><span class="s0">(supportsUserTiming) {</span>
  <span class="s1">var </span><span class="s0">CHECK_V3_MARK = </span><span class="s2">'__v3'</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">markOptions = {};</span>
  <span class="s0">Object.defineProperty(markOptions, </span><span class="s2">'startTime'</span><span class="s0">, {</span>
    <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
      <span class="s0">supportsUserTimingV3 = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">set: </span><span class="s1">function </span><span class="s0">set() {}</span>
  <span class="s0">});</span>

  <span class="s1">try </span><span class="s0">{</span>
    <span class="s0">performance.mark(CHECK_V3_MARK, markOptions);</span>
  <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span><span class="s3">// Ignore</span>
  <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
    <span class="s0">performance.clearMarks(CHECK_V3_MARK);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
  <span class="s0">performanceTarget = performance;</span>
<span class="s0">} </span><span class="s3">// Some environments (e.g. React Native / Hermes) don't support the performance API yet.</span>


<span class="s1">var </span><span class="s0">profilingHooks_getCurrentTime = </span><span class="s3">// $FlowFixMe[method-unbinding]</span>
<span class="s0">(</span><span class="s1">typeof </span><span class="s0">performance === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? </span><span class="s2">&quot;undefined&quot; </span><span class="s0">: profilingHooks_typeof(performance)) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">performance.now === </span><span class="s2">'function' </span><span class="s0">? </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">performance.now();</span>
<span class="s0">} : </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">Date.now();</span>
<span class="s0">}; </span><span class="s3">// Mocking the Performance Object (and User Timing APIs) for testing is fragile.</span>
<span class="s3">// This API allows tests to directly override the User Timing APIs.</span>

<span class="s1">function </span><span class="s0">setPerformanceMock_ONLY_FOR_TESTING(performanceMock) {</span>
  <span class="s0">performanceTarget = performanceMock;</span>
  <span class="s0">supportsUserTiming = performanceMock !== </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">supportsUserTimingV3 = performanceMock !== </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createProfilingHooks(_ref) {</span>
  <span class="s1">var </span><span class="s0">getDisplayNameForFiber = _ref.getDisplayNameForFiber,</span>
      <span class="s0">getIsProfiling = _ref.getIsProfiling,</span>
      <span class="s0">getLaneLabelMap = _ref.getLaneLabelMap,</span>
      <span class="s0">workTagMap = _ref.workTagMap,</span>
      <span class="s0">currentDispatcherRef = _ref.currentDispatcherRef,</span>
      <span class="s0">reactVersion = _ref.reactVersion;</span>
  <span class="s1">var </span><span class="s0">currentBatchUID = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">currentReactComponentMeasure = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">currentReactMeasuresStack = [];</span>
  <span class="s1">var </span><span class="s0">currentTimelineData = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">currentFiberStacks = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">isProfiling = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">nextRenderShouldStartNewBatch = </span><span class="s1">false</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">getRelativeTime() {</span>
    <span class="s1">var </span><span class="s0">currentTime = profilingHooks_getCurrentTime();</span>

    <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
      <span class="s1">if </span><span class="s0">(currentTimelineData.startTime === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">currentTimelineData.startTime = currentTime - TIME_OFFSET;</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">currentTime - currentTimelineData.startTime;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getInternalModuleRanges() {</span>
    <span class="s3">/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">__REACT_DEVTOOLS_GLOBAL_HOOK__ !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">__REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s3">// Ask the DevTools hook for module ranges that may have been reported by the current renderer(s).</span>
      <span class="s3">// Don't do this eagerly like the laneToLabelMap,</span>
      <span class="s3">// because some modules might not yet have registered their boundaries when the renderer is injected.</span>
      <span class="s1">var </span><span class="s0">ranges = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges(); </span><span class="s3">// This check would not be required,</span>
      <span class="s3">// except that it's possible for things to override __REACT_DEVTOOLS_GLOBAL_HOOK__.</span>


      <span class="s1">if </span><span class="s0">(shared_isArray(ranges)) {</span>
        <span class="s1">return </span><span class="s0">ranges;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getTimelineData() {</span>
    <span class="s1">return </span><span class="s0">currentTimelineData;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">laneToLanesArray(lanes) {</span>
    <span class="s1">var </span><span class="s0">lanesArray = [];</span>
    <span class="s1">var </span><span class="s0">lane = </span><span class="s4">1</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">index = </span><span class="s4">0</span><span class="s0">; index &lt; REACT_TOTAL_NUM_LANES; index++) {</span>
      <span class="s1">if </span><span class="s0">(lane &amp; lanes) {</span>
        <span class="s0">lanesArray.push(lane);</span>
      <span class="s0">}</span>

      <span class="s0">lane *= </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">lanesArray;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">laneToLabelMap = </span><span class="s1">typeof </span><span class="s0">getLaneLabelMap === </span><span class="s2">'function' </span><span class="s0">? getLaneLabelMap() : </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">markMetadata() {</span>
    <span class="s0">markAndClear(</span><span class="s2">&quot;--react-version-&quot;</span><span class="s0">.concat(reactVersion));</span>
    <span class="s0">markAndClear(</span><span class="s2">&quot;--profiler-version-&quot;</span><span class="s0">.concat(SCHEDULING_PROFILER_VERSION));</span>
    <span class="s1">var </span><span class="s0">ranges = getInternalModuleRanges();</span>

    <span class="s1">if </span><span class="s0">(ranges) {</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; ranges.length; i++) {</span>
        <span class="s1">var </span><span class="s0">range = ranges[i];</span>

        <span class="s1">if </span><span class="s0">(shared_isArray(range) &amp;&amp; range.length === </span><span class="s4">2</span><span class="s0">) {</span>
          <span class="s1">var </span><span class="s0">_ranges$i = profilingHooks_slicedToArray(ranges[i], </span><span class="s4">2</span><span class="s0">),</span>
              <span class="s0">startStackFrame = _ranges$i[</span><span class="s4">0</span><span class="s0">],</span>
              <span class="s0">stopStackFrame = _ranges$i[</span><span class="s4">1</span><span class="s0">];</span>

          <span class="s0">markAndClear(</span><span class="s2">&quot;--react-internal-module-start-&quot;</span><span class="s0">.concat(startStackFrame));</span>
          <span class="s0">markAndClear(</span><span class="s2">&quot;--react-internal-module-stop-&quot;</span><span class="s0">.concat(stopStackFrame));</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(laneToLabelMap != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">labels = Array.from(laneToLabelMap.values()).join(</span><span class="s2">','</span><span class="s0">);</span>
      <span class="s0">markAndClear(</span><span class="s2">&quot;--react-lane-labels-&quot;</span><span class="s0">.concat(labels));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markAndClear(markName) {</span>
    <span class="s3">// This method won't be called unless these functions are defined, so we can skip the extra typeof check.</span>
    <span class="s0">performanceTarget.mark(markName);</span>
    <span class="s0">performanceTarget.clearMarks(markName);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordReactMeasureStarted(type, lanes) {</span>
    <span class="s3">// Decide what depth thi work should be rendered at, based on what's on the top of the stack.</span>
    <span class="s3">// It's okay to render over top of &quot;idle&quot; work but everything else should be on its own row.</span>
    <span class="s1">var </span><span class="s0">depth = </span><span class="s4">0</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(currentReactMeasuresStack.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">top = currentReactMeasuresStack[currentReactMeasuresStack.length - </span><span class="s4">1</span><span class="s0">];</span>
      <span class="s0">depth = top.type === </span><span class="s2">'render-idle' </span><span class="s0">? top.depth : top.depth + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">lanesArray = laneToLanesArray(lanes);</span>
    <span class="s1">var </span><span class="s0">reactMeasure = {</span>
      <span class="s0">type: type,</span>
      <span class="s0">batchUID: currentBatchUID,</span>
      <span class="s0">depth: depth,</span>
      <span class="s0">lanes: lanesArray,</span>
      <span class="s0">timestamp: getRelativeTime(),</span>
      <span class="s0">duration: </span><span class="s4">0</span>
    <span class="s0">};</span>
    <span class="s0">currentReactMeasuresStack.push(reactMeasure);</span>

    <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
      <span class="s1">var </span><span class="s0">_currentTimelineData = currentTimelineData,</span>
          <span class="s0">batchUIDToMeasuresMap = _currentTimelineData.batchUIDToMeasuresMap,</span>
          <span class="s0">laneToReactMeasureMap = _currentTimelineData.laneToReactMeasureMap;</span>
      <span class="s1">var </span><span class="s0">reactMeasures = batchUIDToMeasuresMap.get(currentBatchUID);</span>

      <span class="s1">if </span><span class="s0">(reactMeasures != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">reactMeasures.push(reactMeasure);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">batchUIDToMeasuresMap.set(currentBatchUID, [reactMeasure]);</span>
      <span class="s0">}</span>

      <span class="s0">lanesArray.forEach(</span><span class="s1">function </span><span class="s0">(lane) {</span>
        <span class="s0">reactMeasures = laneToReactMeasureMap.get(lane);</span>

        <span class="s1">if </span><span class="s0">(reactMeasures) {</span>
          <span class="s0">reactMeasures.push(reactMeasure);</span>
        <span class="s0">}</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordReactMeasureCompleted(type) {</span>
    <span class="s1">var </span><span class="s0">currentTime = getRelativeTime();</span>

    <span class="s1">if </span><span class="s0">(currentReactMeasuresStack.length === </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s0">console.error(</span><span class="s2">'Unexpected type &quot;%s&quot; completed at %sms while currentReactMeasuresStack is empty.'</span><span class="s0">, type, currentTime); </span><span class="s3">// Ignore work &quot;completion&quot; user timing mark that doesn't complete anything</span>

      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">top = currentReactMeasuresStack.pop();</span>

    <span class="s1">if </span><span class="s0">(top.type !== type) {</span>
      <span class="s0">console.error(</span><span class="s2">'Unexpected type &quot;%s&quot; completed at %sms before &quot;%s&quot; completed.'</span><span class="s0">, type, currentTime, top.type);</span>
    <span class="s0">} </span><span class="s3">// $FlowFixMe[cannot-write] This property should not be writable outside of this function.</span>


    <span class="s0">top.duration = currentTime - top.timestamp;</span>

    <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
      <span class="s0">currentTimelineData.duration = getRelativeTime() + TIME_OFFSET;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markCommitStarted(lanes) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s0">recordReactMeasureStarted(</span><span class="s2">'commit'</span><span class="s0">, lanes); </span><span class="s3">// TODO (timeline) Re-think this approach to &quot;batching&quot;; I don't think it works for Suspense or pre-rendering.</span>
      <span class="s3">// This issue applies to the User Timing data also.</span>

      <span class="s0">nextRenderShouldStartNewBatch = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">&quot;--commit-start-&quot;</span><span class="s0">.concat(lanes)); </span><span class="s3">// Some metadata only needs to be logged once per session,</span>
      <span class="s3">// but if profiling information is being recorded via the Performance tab,</span>
      <span class="s3">// DevTools has no way of knowing when the recording starts.</span>
      <span class="s3">// Because of that, we log thie type of data periodically (once per commit).</span>

      <span class="s0">markMetadata();</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markCommitStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s0">recordReactMeasureCompleted(</span><span class="s2">'commit'</span><span class="s0">);</span>
      <span class="s0">recordReactMeasureCompleted(</span><span class="s2">'render-idle'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--commit-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentRenderStarted(fiber) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s1">if </span><span class="s0">(isProfiling) {</span>
          <span class="s0">currentReactComponentMeasure = {</span>
            <span class="s0">componentName: componentName,</span>
            <span class="s0">duration: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">timestamp: getRelativeTime(),</span>
            <span class="s0">type: </span><span class="s2">'render'</span><span class="s0">,</span>
            <span class="s0">warning: </span><span class="s1">null</span>
          <span class="s0">};</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--component-render-start-&quot;</span><span class="s0">.concat(componentName));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentRenderStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">if </span><span class="s0">(currentReactComponentMeasure) {</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s0">currentTimelineData.componentMeasures.push(currentReactComponentMeasure);</span>
        <span class="s0">} </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>


        <span class="s0">currentReactComponentMeasure.duration = </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
        <span class="s0">getRelativeTime() - currentReactComponentMeasure.timestamp;</span>
        <span class="s0">currentReactComponentMeasure = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--component-render-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentLayoutEffectMountStarted(fiber) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s1">if </span><span class="s0">(isProfiling) {</span>
          <span class="s0">currentReactComponentMeasure = {</span>
            <span class="s0">componentName: componentName,</span>
            <span class="s0">duration: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">timestamp: getRelativeTime(),</span>
            <span class="s0">type: </span><span class="s2">'layout-effect-mount'</span><span class="s0">,</span>
            <span class="s0">warning: </span><span class="s1">null</span>
          <span class="s0">};</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--component-layout-effect-mount-start-&quot;</span><span class="s0">.concat(componentName));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentLayoutEffectMountStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">if </span><span class="s0">(currentReactComponentMeasure) {</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s0">currentTimelineData.componentMeasures.push(currentReactComponentMeasure);</span>
        <span class="s0">} </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>


        <span class="s0">currentReactComponentMeasure.duration = </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
        <span class="s0">getRelativeTime() - currentReactComponentMeasure.timestamp;</span>
        <span class="s0">currentReactComponentMeasure = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--component-layout-effect-mount-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentLayoutEffectUnmountStarted(fiber) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s1">if </span><span class="s0">(isProfiling) {</span>
          <span class="s0">currentReactComponentMeasure = {</span>
            <span class="s0">componentName: componentName,</span>
            <span class="s0">duration: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">timestamp: getRelativeTime(),</span>
            <span class="s0">type: </span><span class="s2">'layout-effect-unmount'</span><span class="s0">,</span>
            <span class="s0">warning: </span><span class="s1">null</span>
          <span class="s0">};</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--component-layout-effect-unmount-start-&quot;</span><span class="s0">.concat(componentName));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentLayoutEffectUnmountStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">if </span><span class="s0">(currentReactComponentMeasure) {</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s0">currentTimelineData.componentMeasures.push(currentReactComponentMeasure);</span>
        <span class="s0">} </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>


        <span class="s0">currentReactComponentMeasure.duration = </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
        <span class="s0">getRelativeTime() - currentReactComponentMeasure.timestamp;</span>
        <span class="s0">currentReactComponentMeasure = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--component-layout-effect-unmount-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentPassiveEffectMountStarted(fiber) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s1">if </span><span class="s0">(isProfiling) {</span>
          <span class="s0">currentReactComponentMeasure = {</span>
            <span class="s0">componentName: componentName,</span>
            <span class="s0">duration: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">timestamp: getRelativeTime(),</span>
            <span class="s0">type: </span><span class="s2">'passive-effect-mount'</span><span class="s0">,</span>
            <span class="s0">warning: </span><span class="s1">null</span>
          <span class="s0">};</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--component-passive-effect-mount-start-&quot;</span><span class="s0">.concat(componentName));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentPassiveEffectMountStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">if </span><span class="s0">(currentReactComponentMeasure) {</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s0">currentTimelineData.componentMeasures.push(currentReactComponentMeasure);</span>
        <span class="s0">} </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>


        <span class="s0">currentReactComponentMeasure.duration = </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
        <span class="s0">getRelativeTime() - currentReactComponentMeasure.timestamp;</span>
        <span class="s0">currentReactComponentMeasure = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--component-passive-effect-mount-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentPassiveEffectUnmountStarted(fiber) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s1">if </span><span class="s0">(isProfiling) {</span>
          <span class="s0">currentReactComponentMeasure = {</span>
            <span class="s0">componentName: componentName,</span>
            <span class="s0">duration: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">timestamp: getRelativeTime(),</span>
            <span class="s0">type: </span><span class="s2">'passive-effect-unmount'</span><span class="s0">,</span>
            <span class="s0">warning: </span><span class="s1">null</span>
          <span class="s0">};</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--component-passive-effect-unmount-start-&quot;</span><span class="s0">.concat(componentName));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentPassiveEffectUnmountStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">if </span><span class="s0">(currentReactComponentMeasure) {</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s0">currentTimelineData.componentMeasures.push(currentReactComponentMeasure);</span>
        <span class="s0">} </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>


        <span class="s0">currentReactComponentMeasure.duration = </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
        <span class="s0">getRelativeTime() - currentReactComponentMeasure.timestamp;</span>
        <span class="s0">currentReactComponentMeasure = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--component-passive-effect-unmount-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentErrored(fiber, thrownValue, lanes) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">phase = fiber.alternate === </span><span class="s1">null </span><span class="s0">? </span><span class="s2">'mount' </span><span class="s0">: </span><span class="s2">'update'</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">message = </span><span class="s2">''</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(thrownValue !== </span><span class="s1">null </span><span class="s0">&amp;&amp; profilingHooks_typeof(thrownValue) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">thrownValue.message === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s0">message = thrownValue.message;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">thrownValue === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s0">message = thrownValue;</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s0">currentTimelineData.thrownErrors.push({</span>
            <span class="s0">componentName: componentName,</span>
            <span class="s0">message: message,</span>
            <span class="s0">phase: phase,</span>
            <span class="s0">timestamp: getRelativeTime(),</span>
            <span class="s0">type: </span><span class="s2">'thrown-error'</span>
          <span class="s0">});</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--error-&quot;</span><span class="s0">.concat(componentName, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(phase, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(message));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">PossiblyWeakMap = </span><span class="s1">typeof </span><span class="s0">WeakMap === </span><span class="s2">'function' </span><span class="s0">? WeakMap : Map; </span><span class="s3">// $FlowFixMe[incompatible-type]: Flow cannot handle polymorphic WeakMaps</span>

  <span class="s1">var </span><span class="s0">wakeableIDs = </span><span class="s1">new </span><span class="s0">PossiblyWeakMap();</span>
  <span class="s1">var </span><span class="s0">wakeableID = </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">getWakeableID(wakeable) {</span>
    <span class="s1">if </span><span class="s0">(!wakeableIDs.has(wakeable)) {</span>
      <span class="s0">wakeableIDs.set(wakeable, wakeableID++);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">wakeableIDs.get(wakeable);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markComponentSuspended(fiber, wakeable, lanes) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">eventType = wakeableIDs.has(wakeable) ? </span><span class="s2">'resuspend' </span><span class="s0">: </span><span class="s2">'suspend'</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">id = getWakeableID(wakeable);</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">phase = fiber.alternate === </span><span class="s1">null </span><span class="s0">? </span><span class="s2">'mount' </span><span class="s0">: </span><span class="s2">'update'</span><span class="s0">; </span><span class="s3">// Following the non-standard fn.displayName convention,</span>
      <span class="s3">// frameworks like Relay may also annotate Promises with a displayName,</span>
      <span class="s3">// describing what operation/data the thrown Promise is related to.</span>
      <span class="s3">// When this is available we should pass it along to the Timeline.</span>

      <span class="s1">var </span><span class="s0">displayName = wakeable.displayName || </span><span class="s2">''</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">suspenseEvent = </span><span class="s1">null</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s0">suspenseEvent = {</span>
          <span class="s0">componentName: componentName,</span>
          <span class="s0">depth: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s0">duration: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s0">id: </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(id),</span>
          <span class="s0">phase: phase,</span>
          <span class="s0">promiseName: displayName,</span>
          <span class="s0">resolution: </span><span class="s2">'unresolved'</span><span class="s0">,</span>
          <span class="s0">timestamp: getRelativeTime(),</span>
          <span class="s0">type: </span><span class="s2">'suspense'</span><span class="s0">,</span>
          <span class="s0">warning: </span><span class="s1">null</span>
        <span class="s0">};</span>

        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s0">currentTimelineData.suspenseEvents.push(suspenseEvent);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--suspense-&quot;</span><span class="s0">.concat(eventType, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(componentName, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(phase, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(lanes, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(displayName));</span>
      <span class="s0">}</span>

      <span class="s0">wakeable.then(</span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">if </span><span class="s0">(suspenseEvent) {</span>
          <span class="s0">suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;</span>
          <span class="s0">suspenseEvent.resolution = </span><span class="s2">'resolved'</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
          <span class="s0">markAndClear(</span><span class="s2">&quot;--suspense-resolved-&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(componentName));</span>
        <span class="s0">}</span>
      <span class="s0">}, </span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">if </span><span class="s0">(suspenseEvent) {</span>
          <span class="s0">suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;</span>
          <span class="s0">suspenseEvent.resolution = </span><span class="s2">'rejected'</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
          <span class="s0">markAndClear(</span><span class="s2">&quot;--suspense-rejected-&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(componentName));</span>
        <span class="s0">}</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markLayoutEffectsStarted(lanes) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s0">recordReactMeasureStarted(</span><span class="s2">'layout-effects'</span><span class="s0">, lanes);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">&quot;--layout-effects-start-&quot;</span><span class="s0">.concat(lanes));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markLayoutEffectsStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s0">recordReactMeasureCompleted(</span><span class="s2">'layout-effects'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--layout-effects-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markPassiveEffectsStarted(lanes) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s0">recordReactMeasureStarted(</span><span class="s2">'passive-effects'</span><span class="s0">, lanes);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">&quot;--passive-effects-start-&quot;</span><span class="s0">.concat(lanes));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markPassiveEffectsStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s0">recordReactMeasureCompleted(</span><span class="s2">'passive-effects'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--passive-effects-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markRenderStarted(lanes) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">if </span><span class="s0">(nextRenderShouldStartNewBatch) {</span>
        <span class="s0">nextRenderShouldStartNewBatch = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">currentBatchUID++;</span>
      <span class="s0">} </span><span class="s3">// If this is a new batch of work, wrap an &quot;idle&quot; measure around it.</span>
      <span class="s3">// Log it before the &quot;render&quot; measure to preserve the stack ordering.</span>


      <span class="s1">if </span><span class="s0">(currentReactMeasuresStack.length === </span><span class="s4">0 </span><span class="s0">|| currentReactMeasuresStack[currentReactMeasuresStack.length - </span><span class="s4">1</span><span class="s0">].type !== </span><span class="s2">'render-idle'</span><span class="s0">) {</span>
        <span class="s0">recordReactMeasureStarted(</span><span class="s2">'render-idle'</span><span class="s0">, lanes);</span>
      <span class="s0">}</span>

      <span class="s0">recordReactMeasureStarted(</span><span class="s2">'render'</span><span class="s0">, lanes);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">&quot;--render-start-&quot;</span><span class="s0">.concat(lanes));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markRenderYielded() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s0">recordReactMeasureCompleted(</span><span class="s2">'render'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--render-yield'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markRenderStopped() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s0">recordReactMeasureCompleted(</span><span class="s2">'render'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">'--render-stop'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markRenderScheduled(lane) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
        <span class="s0">currentTimelineData.schedulingEvents.push({</span>
          <span class="s0">lanes: laneToLanesArray(lane),</span>
          <span class="s0">timestamp: getRelativeTime(),</span>
          <span class="s0">type: </span><span class="s2">'schedule-render'</span><span class="s0">,</span>
          <span class="s0">warning: </span><span class="s1">null</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
      <span class="s0">markAndClear(</span><span class="s2">&quot;--schedule-render-&quot;</span><span class="s0">.concat(lane));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markForceUpdateScheduled(fiber, lane) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s0">currentTimelineData.schedulingEvents.push({</span>
            <span class="s0">componentName: componentName,</span>
            <span class="s0">lanes: laneToLanesArray(lane),</span>
            <span class="s0">timestamp: getRelativeTime(),</span>
            <span class="s0">type: </span><span class="s2">'schedule-force-update'</span><span class="s0">,</span>
            <span class="s0">warning: </span><span class="s1">null</span>
          <span class="s0">});</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--schedule-forced-update-&quot;</span><span class="s0">.concat(lane, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(componentName));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getParentFibers(fiber) {</span>
    <span class="s1">var </span><span class="s0">parents = [];</span>
    <span class="s1">var </span><span class="s0">parent = fiber;</span>

    <span class="s1">while </span><span class="s0">(parent !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">parents.push(parent);</span>
      <span class="s0">parent = parent.</span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">parents;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">markStateUpdateScheduled(fiber, lane) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling || supportsUserTimingV3) {</span>
      <span class="s1">var </span><span class="s0">componentName = getDisplayNameForFiber(fiber) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s3">// TODO (timeline) Record and cache component stack</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
          <span class="s1">var </span><span class="s0">event = {</span>
            <span class="s0">componentName: componentName,</span>
            <span class="s3">// Store the parent fibers so we can post process</span>
            <span class="s3">// them after we finish profiling</span>
            <span class="s0">lanes: laneToLanesArray(lane),</span>
            <span class="s0">timestamp: getRelativeTime(),</span>
            <span class="s0">type: </span><span class="s2">'schedule-state-update'</span><span class="s0">,</span>
            <span class="s0">warning: </span><span class="s1">null</span>
          <span class="s0">};</span>
          <span class="s0">currentFiberStacks.set(event, getParentFibers(fiber)); </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>

          <span class="s0">currentTimelineData.schedulingEvents.push(event);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
        <span class="s0">markAndClear(</span><span class="s2">&quot;--schedule-state-update-&quot;</span><span class="s0">.concat(lane, </span><span class="s2">&quot;-&quot;</span><span class="s0">).concat(componentName));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">toggleProfilingStatus(value) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling !== value) {</span>
      <span class="s0">isProfiling = value;</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s1">var </span><span class="s0">internalModuleSourceToRanges = </span><span class="s1">new </span><span class="s0">Map();</span>

        <span class="s1">if </span><span class="s0">(supportsUserTimingV3) {</span>
          <span class="s1">var </span><span class="s0">ranges = getInternalModuleRanges();</span>

          <span class="s1">if </span><span class="s0">(ranges) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; ranges.length; i++) {</span>
              <span class="s1">var </span><span class="s0">range = ranges[i];</span>

              <span class="s1">if </span><span class="s0">(shared_isArray(range) &amp;&amp; range.length === </span><span class="s4">2</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">_ranges$i2 = profilingHooks_slicedToArray(ranges[i], </span><span class="s4">2</span><span class="s0">),</span>
                    <span class="s0">startStackFrame = _ranges$i2[</span><span class="s4">0</span><span class="s0">],</span>
                    <span class="s0">stopStackFrame = _ranges$i2[</span><span class="s4">1</span><span class="s0">];</span>

                <span class="s0">markAndClear(</span><span class="s2">&quot;--react-internal-module-start-&quot;</span><span class="s0">.concat(startStackFrame));</span>
                <span class="s0">markAndClear(</span><span class="s2">&quot;--react-internal-module-stop-&quot;</span><span class="s0">.concat(stopStackFrame));</span>
              <span class="s0">}</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">laneToReactMeasureMap = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s1">var </span><span class="s0">lane = </span><span class="s4">1</span><span class="s0">;</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">index = </span><span class="s4">0</span><span class="s0">; index &lt; REACT_TOTAL_NUM_LANES; index++) {</span>
          <span class="s0">laneToReactMeasureMap.set(lane, []);</span>
          <span class="s0">lane *= </span><span class="s4">2</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s0">currentBatchUID = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">currentReactComponentMeasure = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">currentReactMeasuresStack = [];</span>
        <span class="s0">currentFiberStacks = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">currentTimelineData = {</span>
          <span class="s3">// Session wide metadata; only collected once.</span>
          <span class="s0">internalModuleSourceToRanges: internalModuleSourceToRanges,</span>
          <span class="s0">laneToLabelMap: laneToLabelMap || </span><span class="s1">new </span><span class="s0">Map(),</span>
          <span class="s0">reactVersion: reactVersion,</span>
          <span class="s3">// Data logged by React during profiling session.</span>
          <span class="s0">componentMeasures: [],</span>
          <span class="s0">schedulingEvents: [],</span>
          <span class="s0">suspenseEvents: [],</span>
          <span class="s0">thrownErrors: [],</span>
          <span class="s3">// Data inferred based on what React logs.</span>
          <span class="s0">batchUIDToMeasuresMap: </span><span class="s1">new </span><span class="s0">Map(),</span>
          <span class="s0">duration: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s0">laneToReactMeasureMap: laneToReactMeasureMap,</span>
          <span class="s0">startTime: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s3">// Data only available in Chrome profiles.</span>
          <span class="s0">flamechart: [],</span>
          <span class="s0">nativeEvents: [],</span>
          <span class="s0">networkMeasures: [],</span>
          <span class="s0">otherUserTimingMarks: [],</span>
          <span class="s0">snapshots: [],</span>
          <span class="s0">snapshotHeight: </span><span class="s4">0</span>
        <span class="s0">};</span>
        <span class="s0">nextRenderShouldStartNewBatch = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// Postprocess Profile data</span>
        <span class="s1">if </span><span class="s0">(currentTimelineData !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">currentTimelineData.schedulingEvents.forEach(</span><span class="s1">function </span><span class="s0">(event) {</span>
            <span class="s1">if </span><span class="s0">(event.type === </span><span class="s2">'schedule-state-update'</span><span class="s0">) {</span>
              <span class="s3">// TODO(luna): We can optimize this by creating a map of</span>
              <span class="s3">// fiber to component stack instead of generating the stack</span>
              <span class="s3">// for every fiber every time</span>
              <span class="s1">var </span><span class="s0">fiberStack = currentFiberStacks.get(event);</span>

              <span class="s1">if </span><span class="s0">(fiberStack &amp;&amp; currentDispatcherRef != </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">event.componentStack = fiberStack.reduce(</span><span class="s1">function </span><span class="s0">(trace, fiber) {</span>
                  <span class="s1">return </span><span class="s0">trace + describeFiber(workTagMap, fiber, currentDispatcherRef);</span>
                <span class="s0">}, </span><span class="s2">''</span><span class="s0">);</span>
              <span class="s0">}</span>
            <span class="s0">}</span>
          <span class="s0">});</span>
        <span class="s0">} </span><span class="s3">// Clear the current fiber stacks so we don't hold onto the fibers</span>
        <span class="s3">// in memory after profiling finishes</span>


        <span class="s0">currentFiberStacks.clear();</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">getTimelineData: getTimelineData,</span>
    <span class="s0">profilingHooks: {</span>
      <span class="s0">markCommitStarted: markCommitStarted,</span>
      <span class="s0">markCommitStopped: markCommitStopped,</span>
      <span class="s0">markComponentRenderStarted: markComponentRenderStarted,</span>
      <span class="s0">markComponentRenderStopped: markComponentRenderStopped,</span>
      <span class="s0">markComponentPassiveEffectMountStarted: markComponentPassiveEffectMountStarted,</span>
      <span class="s0">markComponentPassiveEffectMountStopped: markComponentPassiveEffectMountStopped,</span>
      <span class="s0">markComponentPassiveEffectUnmountStarted: markComponentPassiveEffectUnmountStarted,</span>
      <span class="s0">markComponentPassiveEffectUnmountStopped: markComponentPassiveEffectUnmountStopped,</span>
      <span class="s0">markComponentLayoutEffectMountStarted: markComponentLayoutEffectMountStarted,</span>
      <span class="s0">markComponentLayoutEffectMountStopped: markComponentLayoutEffectMountStopped,</span>
      <span class="s0">markComponentLayoutEffectUnmountStarted: markComponentLayoutEffectUnmountStarted,</span>
      <span class="s0">markComponentLayoutEffectUnmountStopped: markComponentLayoutEffectUnmountStopped,</span>
      <span class="s0">markComponentErrored: markComponentErrored,</span>
      <span class="s0">markComponentSuspended: markComponentSuspended,</span>
      <span class="s0">markLayoutEffectsStarted: markLayoutEffectsStarted,</span>
      <span class="s0">markLayoutEffectsStopped: markLayoutEffectsStopped,</span>
      <span class="s0">markPassiveEffectsStarted: markPassiveEffectsStarted,</span>
      <span class="s0">markPassiveEffectsStopped: markPassiveEffectsStopped,</span>
      <span class="s0">markRenderStarted: markRenderStarted,</span>
      <span class="s0">markRenderYielded: markRenderYielded,</span>
      <span class="s0">markRenderStopped: markRenderStopped,</span>
      <span class="s0">markRenderScheduled: markRenderScheduled,</span>
      <span class="s0">markForceUpdateScheduled: markForceUpdateScheduled,</span>
      <span class="s0">markStateUpdateScheduled: markStateUpdateScheduled</span>
    <span class="s0">},</span>
    <span class="s0">toggleProfilingStatus: toggleProfilingStatus</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/renderer.js</span>
<span class="s1">function </span><span class="s0">_objectWithoutProperties(source, excluded) { </span><span class="s1">if </span><span class="s0">(source == </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return </span><span class="s0">{}; </span><span class="s1">var </span><span class="s0">target = _objectWithoutPropertiesLoose(source, excluded); </span><span class="s1">var </span><span class="s0">key, i; </span><span class="s1">if </span><span class="s0">(Object.getOwnPropertySymbols) { </span><span class="s1">var </span><span class="s0">sourceSymbolKeys = Object.getOwnPropertySymbols(source); </span><span class="s1">for </span><span class="s0">(i = </span><span class="s4">0</span><span class="s0">; i &lt; sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; </span><span class="s1">if </span><span class="s0">(excluded.indexOf(key) &gt;= </span><span class="s4">0</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(!Object.prototype.propertyIsEnumerable.call(source, key)) </span><span class="s1">continue</span><span class="s0">; target[key] = source[key]; } } </span><span class="s1">return </span><span class="s0">target; }</span>

<span class="s1">function </span><span class="s0">_objectWithoutPropertiesLoose(source, excluded) { </span><span class="s1">if </span><span class="s0">(source == </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return </span><span class="s0">{}; </span><span class="s1">var </span><span class="s0">target = {}; </span><span class="s1">var </span><span class="s0">sourceKeys = Object.keys(source); </span><span class="s1">var </span><span class="s0">key, i; </span><span class="s1">for </span><span class="s0">(i = </span><span class="s4">0</span><span class="s0">; i &lt; sourceKeys.length; i++) { key = sourceKeys[i]; </span><span class="s1">if </span><span class="s0">(excluded.indexOf(key) &gt;= </span><span class="s4">0</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">; target[key] = source[key]; } </span><span class="s1">return </span><span class="s0">target; }</span>

<span class="s1">function </span><span class="s0">renderer_ownKeys(object, enumerableOnly) { </span><span class="s1">var </span><span class="s0">keys = Object.keys(object); </span><span class="s1">if </span><span class="s0">(Object.getOwnPropertySymbols) { </span><span class="s1">var </span><span class="s0">symbols = Object.getOwnPropertySymbols(object); </span><span class="s1">if </span><span class="s0">(enumerableOnly) symbols = symbols.filter(</span><span class="s1">function </span><span class="s0">(sym) { </span><span class="s1">return </span><span class="s0">Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } </span><span class="s1">return </span><span class="s0">keys; }</span>

<span class="s1">function </span><span class="s0">renderer_objectSpread(target) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; arguments.length; i++) { </span><span class="s1">var </span><span class="s0">source = arguments[i] != </span><span class="s1">null </span><span class="s0">? arguments[i] : {}; </span><span class="s1">if </span><span class="s0">(i % </span><span class="s4">2</span><span class="s0">) { renderer_ownKeys(Object(source), </span><span class="s1">true</span><span class="s0">).forEach(</span><span class="s1">function </span><span class="s0">(key) { renderer_defineProperty(target, key, source[key]); }); } </span><span class="s1">else if </span><span class="s0">(Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } </span><span class="s1">else </span><span class="s0">{ renderer_ownKeys(Object(source)).forEach(</span><span class="s1">function </span><span class="s0">(key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } </span><span class="s1">return </span><span class="s0">target; }</span>

<span class="s1">function </span><span class="s0">renderer_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s1">function </span><span class="s0">renderer_slicedToArray(arr, i) { </span><span class="s1">return </span><span class="s0">renderer_arrayWithHoles(arr) || renderer_iterableToArrayLimit(arr, i) || renderer_unsupportedIterableToArray(arr, i) || renderer_nonIterableRest(); }</span>

<span class="s1">function </span><span class="s0">renderer_nonIterableRest() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to destructure non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">renderer_iterableToArrayLimit(arr, i) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">|| !(Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(arr))) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_arr = []; </span><span class="s1">var </span><span class="s0">_n = </span><span class="s1">true</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_d = </span><span class="s1">false</span><span class="s0">; </span><span class="s1">var </span><span class="s0">_e = undefined; </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = </span><span class="s1">true</span><span class="s0">) { _arr.push(_s.value); </span><span class="s1">if </span><span class="s0">(i &amp;&amp; _arr.length === i) </span><span class="s1">break</span><span class="s0">; } } </span><span class="s1">catch </span><span class="s0">(err) { _d = </span><span class="s1">true</span><span class="s0">; _e = err; } </span><span class="s1">finally </span><span class="s0">{ </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(!_n &amp;&amp; _i[</span><span class="s2">&quot;return&quot;</span><span class="s0">] != </span><span class="s1">null</span><span class="s0">) _i[</span><span class="s2">&quot;return&quot;</span><span class="s0">](); } </span><span class="s1">finally </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(_d) </span><span class="s1">throw </span><span class="s0">_e; } } </span><span class="s1">return </span><span class="s0">_arr; }</span>

<span class="s1">function </span><span class="s0">renderer_arrayWithHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">arr; }</span>

<span class="s1">function </span><span class="s0">renderer_toConsumableArray(arr) { </span><span class="s1">return </span><span class="s0">renderer_arrayWithoutHoles(arr) || renderer_iterableToArray(arr) || renderer_unsupportedIterableToArray(arr) || renderer_nonIterableSpread(); }</span>

<span class="s1">function </span><span class="s0">renderer_nonIterableSpread() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to spread non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">renderer_iterableToArray(iter) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">&amp;&amp; Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(iter)) </span><span class="s1">return </span><span class="s0">Array.from(iter); }</span>

<span class="s1">function </span><span class="s0">renderer_arrayWithoutHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">renderer_arrayLikeToArray(arr); }</span>

<span class="s1">function </span><span class="s0">_createForOfIteratorHelper(o, allowArrayLike) { </span><span class="s1">var </span><span class="s0">it; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">|| o[Symbol.iterator] == </span><span class="s1">null</span><span class="s0">) { </span><span class="s1">if </span><span class="s0">(Array.isArray(o) || (it = renderer_unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; </span><span class="s1">typeof </span><span class="s0">o.length === </span><span class="s2">&quot;number&quot;</span><span class="s0">) { </span><span class="s1">if </span><span class="s0">(it) o = it; </span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">var </span><span class="s0">F = </span><span class="s1">function </span><span class="s0">F() {}; </span><span class="s1">return </span><span class="s0">{ s: F, n: </span><span class="s1">function </span><span class="s0">n() { </span><span class="s1">if </span><span class="s0">(i &gt;= o.length) </span><span class="s1">return </span><span class="s0">{ done: </span><span class="s1">true </span><span class="s0">}; </span><span class="s1">return </span><span class="s0">{ done: </span><span class="s1">false</span><span class="s0">, value: o[i++] }; }, e: </span><span class="s1">function </span><span class="s0">e(_e2) { </span><span class="s1">throw </span><span class="s0">_e2; }, f: F }; } </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to iterate non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); } </span><span class="s1">var </span><span class="s0">normalCompletion = </span><span class="s1">true</span><span class="s0">, didErr = </span><span class="s1">false</span><span class="s0">, err; </span><span class="s1">return </span><span class="s0">{ s: </span><span class="s1">function </span><span class="s0">s() { it = o[Symbol.iterator](); }, n: </span><span class="s1">function </span><span class="s0">n() { </span><span class="s1">var </span><span class="s0">step = it.next(); normalCompletion = step.done; </span><span class="s1">return </span><span class="s0">step; }, e: </span><span class="s1">function </span><span class="s0">e(_e3) { didErr = </span><span class="s1">true</span><span class="s0">; err = _e3; }, f: </span><span class="s1">function </span><span class="s0">f() { </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(!normalCompletion &amp;&amp; it.</span><span class="s1">return </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) it.</span><span class="s1">return</span><span class="s0">(); } </span><span class="s1">finally </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(didErr) </span><span class="s1">throw </span><span class="s0">err; } } }; }</span>

<span class="s1">function </span><span class="s0">renderer_unsupportedIterableToArray(o, minLen) { </span><span class="s1">if </span><span class="s0">(!o) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">o === </span><span class="s2">&quot;string&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">renderer_arrayLikeToArray(o, minLen); </span><span class="s1">var </span><span class="s0">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s0">&amp;&amp; o.constructor) n = o.constructor.name; </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s0">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">Array.from(o); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s0">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s0">|</span><span class="s4">16</span><span class="s0">|</span><span class="s4">32</span><span class="s0">)(?:Clamped)?Array$/.test(n)) </span><span class="s1">return </span><span class="s0">renderer_arrayLikeToArray(o, minLen); }</span>

<span class="s1">function </span><span class="s0">renderer_arrayLikeToArray(arr, len) { </span><span class="s1">if </span><span class="s0">(len == </span><span class="s1">null </span><span class="s0">|| len &gt; arr.length) len = arr.length; </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, arr2 = </span><span class="s1">new </span><span class="s0">Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } </span><span class="s1">return </span><span class="s0">arr2; }</span>

<span class="s1">function </span><span class="s0">renderer_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { renderer_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ renderer_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">renderer_typeof(obj); }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
















<span class="s1">function </span><span class="s0">getFiberFlags(fiber) {</span>
  <span class="s3">// The name of this field changed from &quot;effectTag&quot; to &quot;flags&quot;</span>
  <span class="s1">return </span><span class="s0">fiber.flags !== undefined ? fiber.flags : fiber.effectTag;</span>
<span class="s0">} </span><span class="s3">// Some environments (e.g. React Native / Hermes) don't support the performance API yet.</span>


<span class="s1">var </span><span class="s0">renderer_getCurrentTime = </span><span class="s3">// $FlowFixMe[method-unbinding]</span>
<span class="s0">(</span><span class="s1">typeof </span><span class="s0">performance === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? </span><span class="s2">&quot;undefined&quot; </span><span class="s0">: renderer_typeof(performance)) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">performance.now === </span><span class="s2">'function' </span><span class="s0">? </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">performance.now();</span>
<span class="s0">} : </span><span class="s1">function </span><span class="s0">() {</span>
  <span class="s1">return </span><span class="s0">Date.now();</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">getInternalReactConstants(version) {</span>
  <span class="s3">// **********************************************************</span>
  <span class="s3">// The section below is copied from files in React repo.</span>
  <span class="s3">// Keep it in sync, and add version guards if it changes.</span>
  <span class="s3">//</span>
  <span class="s3">// Technically these priority levels are invalid for versions before 16.9,</span>
  <span class="s3">// but 16.9 is the first version to report priority level to DevTools,</span>
  <span class="s3">// so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.</span>
  <span class="s1">var </span><span class="s0">ReactPriorityLevels = {</span>
    <span class="s0">ImmediatePriority: </span><span class="s4">99</span><span class="s0">,</span>
    <span class="s0">UserBlockingPriority: </span><span class="s4">98</span><span class="s0">,</span>
    <span class="s0">NormalPriority: </span><span class="s4">97</span><span class="s0">,</span>
    <span class="s0">LowPriority: </span><span class="s4">96</span><span class="s0">,</span>
    <span class="s0">IdlePriority: </span><span class="s4">95</span><span class="s0">,</span>
    <span class="s0">NoPriority: </span><span class="s4">90</span>
  <span class="s0">};</span>

  <span class="s1">if </span><span class="s0">(gt(version, </span><span class="s2">'17.0.2'</span><span class="s0">)) {</span>
    <span class="s0">ReactPriorityLevels = {</span>
      <span class="s0">ImmediatePriority: </span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">UserBlockingPriority: </span><span class="s4">2</span><span class="s0">,</span>
      <span class="s0">NormalPriority: </span><span class="s4">3</span><span class="s0">,</span>
      <span class="s0">LowPriority: </span><span class="s4">4</span><span class="s0">,</span>
      <span class="s0">IdlePriority: </span><span class="s4">5</span><span class="s0">,</span>
      <span class="s0">NoPriority: </span><span class="s4">0</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">StrictModeBits = </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(gte(version, </span><span class="s2">'18.0.0-alpha'</span><span class="s0">)) {</span>
    <span class="s3">// 18+</span>
    <span class="s0">StrictModeBits = </span><span class="s4">24</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(gte(version, </span><span class="s2">'16.9.0'</span><span class="s0">)) {</span>
    <span class="s3">// 16.9 - 17</span>
    <span class="s0">StrictModeBits = </span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(gte(version, </span><span class="s2">'16.3.0'</span><span class="s0">)) {</span>
    <span class="s3">// 16.3 - 16.8</span>
    <span class="s0">StrictModeBits = </span><span class="s4">2</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">ReactTypeOfWork = </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// **********************************************************</span>
  <span class="s3">// The section below is copied from files in React repo.</span>
  <span class="s3">// Keep it in sync, and add version guards if it changes.</span>
  <span class="s3">//</span>
  <span class="s3">// TODO Update the gt() check below to be gte() whichever the next version number is.</span>
  <span class="s3">// Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).</span>

  <span class="s1">if </span><span class="s0">(gt(version, </span><span class="s2">'17.0.1'</span><span class="s0">)) {</span>
    <span class="s0">ReactTypeOfWork = {</span>
      <span class="s0">CacheComponent: </span><span class="s4">24</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">ClassComponent: </span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">ContextConsumer: </span><span class="s4">9</span><span class="s0">,</span>
      <span class="s0">ContextProvider: </span><span class="s4">10</span><span class="s0">,</span>
      <span class="s0">CoroutineComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Removed</span>
      <span class="s0">CoroutineHandlerPhase: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Removed</span>
      <span class="s0">DehydratedSuspenseComponent: </span><span class="s4">18</span><span class="s0">,</span>
      <span class="s3">// Behind a flag</span>
      <span class="s0">ForwardRef: </span><span class="s4">11</span><span class="s0">,</span>
      <span class="s0">Fragment: </span><span class="s4">7</span><span class="s0">,</span>
      <span class="s0">FunctionComponent: </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">HostComponent: </span><span class="s4">5</span><span class="s0">,</span>
      <span class="s0">HostPortal: </span><span class="s4">4</span><span class="s0">,</span>
      <span class="s0">HostRoot: </span><span class="s4">3</span><span class="s0">,</span>
      <span class="s0">HostHoistable: </span><span class="s4">26</span><span class="s0">,</span>
      <span class="s3">// In reality, 18.2+. But doesn't hurt to include it here</span>
      <span class="s0">HostSingleton: </span><span class="s4">27</span><span class="s0">,</span>
      <span class="s3">// Same as above</span>
      <span class="s0">HostText: </span><span class="s4">6</span><span class="s0">,</span>
      <span class="s0">IncompleteClassComponent: </span><span class="s4">17</span><span class="s0">,</span>
      <span class="s0">IndeterminateComponent: </span><span class="s4">2</span><span class="s0">,</span>
      <span class="s0">LazyComponent: </span><span class="s4">16</span><span class="s0">,</span>
      <span class="s0">LegacyHiddenComponent: </span><span class="s4">23</span><span class="s0">,</span>
      <span class="s0">MemoComponent: </span><span class="s4">14</span><span class="s0">,</span>
      <span class="s0">Mode: </span><span class="s4">8</span><span class="s0">,</span>
      <span class="s0">OffscreenComponent: </span><span class="s4">22</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">Profiler: </span><span class="s4">12</span><span class="s0">,</span>
      <span class="s0">ScopeComponent: </span><span class="s4">21</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">SimpleMemoComponent: </span><span class="s4">15</span><span class="s0">,</span>
      <span class="s0">SuspenseComponent: </span><span class="s4">13</span><span class="s0">,</span>
      <span class="s0">SuspenseListComponent: </span><span class="s4">19</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">TracingMarkerComponent: </span><span class="s4">25</span><span class="s0">,</span>
      <span class="s3">// Experimental - This is technically in 18 but we don't</span>
      <span class="s3">// want to fork again so we're adding it here instead</span>
      <span class="s0">YieldComponent: -</span><span class="s4">1 </span><span class="s3">// Removed</span>

    <span class="s0">};</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(gte(version, </span><span class="s2">'17.0.0-alpha'</span><span class="s0">)) {</span>
    <span class="s0">ReactTypeOfWork = {</span>
      <span class="s0">CacheComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">ClassComponent: </span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">ContextConsumer: </span><span class="s4">9</span><span class="s0">,</span>
      <span class="s0">ContextProvider: </span><span class="s4">10</span><span class="s0">,</span>
      <span class="s0">CoroutineComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Removed</span>
      <span class="s0">CoroutineHandlerPhase: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Removed</span>
      <span class="s0">DehydratedSuspenseComponent: </span><span class="s4">18</span><span class="s0">,</span>
      <span class="s3">// Behind a flag</span>
      <span class="s0">ForwardRef: </span><span class="s4">11</span><span class="s0">,</span>
      <span class="s0">Fragment: </span><span class="s4">7</span><span class="s0">,</span>
      <span class="s0">FunctionComponent: </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">HostComponent: </span><span class="s4">5</span><span class="s0">,</span>
      <span class="s0">HostPortal: </span><span class="s4">4</span><span class="s0">,</span>
      <span class="s0">HostRoot: </span><span class="s4">3</span><span class="s0">,</span>
      <span class="s0">HostHoistable: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">HostSingleton: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">HostText: </span><span class="s4">6</span><span class="s0">,</span>
      <span class="s0">IncompleteClassComponent: </span><span class="s4">17</span><span class="s0">,</span>
      <span class="s0">IndeterminateComponent: </span><span class="s4">2</span><span class="s0">,</span>
      <span class="s0">LazyComponent: </span><span class="s4">16</span><span class="s0">,</span>
      <span class="s0">LegacyHiddenComponent: </span><span class="s4">24</span><span class="s0">,</span>
      <span class="s0">MemoComponent: </span><span class="s4">14</span><span class="s0">,</span>
      <span class="s0">Mode: </span><span class="s4">8</span><span class="s0">,</span>
      <span class="s0">OffscreenComponent: </span><span class="s4">23</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">Profiler: </span><span class="s4">12</span><span class="s0">,</span>
      <span class="s0">ScopeComponent: </span><span class="s4">21</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">SimpleMemoComponent: </span><span class="s4">15</span><span class="s0">,</span>
      <span class="s0">SuspenseComponent: </span><span class="s4">13</span><span class="s0">,</span>
      <span class="s0">SuspenseListComponent: </span><span class="s4">19</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">TracingMarkerComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">YieldComponent: -</span><span class="s4">1 </span><span class="s3">// Removed</span>

    <span class="s0">};</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(gte(version, </span><span class="s2">'16.6.0-beta.0'</span><span class="s0">)) {</span>
    <span class="s0">ReactTypeOfWork = {</span>
      <span class="s0">CacheComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">ClassComponent: </span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">ContextConsumer: </span><span class="s4">9</span><span class="s0">,</span>
      <span class="s0">ContextProvider: </span><span class="s4">10</span><span class="s0">,</span>
      <span class="s0">CoroutineComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Removed</span>
      <span class="s0">CoroutineHandlerPhase: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Removed</span>
      <span class="s0">DehydratedSuspenseComponent: </span><span class="s4">18</span><span class="s0">,</span>
      <span class="s3">// Behind a flag</span>
      <span class="s0">ForwardRef: </span><span class="s4">11</span><span class="s0">,</span>
      <span class="s0">Fragment: </span><span class="s4">7</span><span class="s0">,</span>
      <span class="s0">FunctionComponent: </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">HostComponent: </span><span class="s4">5</span><span class="s0">,</span>
      <span class="s0">HostPortal: </span><span class="s4">4</span><span class="s0">,</span>
      <span class="s0">HostRoot: </span><span class="s4">3</span><span class="s0">,</span>
      <span class="s0">HostHoistable: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">HostSingleton: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">HostText: </span><span class="s4">6</span><span class="s0">,</span>
      <span class="s0">IncompleteClassComponent: </span><span class="s4">17</span><span class="s0">,</span>
      <span class="s0">IndeterminateComponent: </span><span class="s4">2</span><span class="s0">,</span>
      <span class="s0">LazyComponent: </span><span class="s4">16</span><span class="s0">,</span>
      <span class="s0">LegacyHiddenComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">MemoComponent: </span><span class="s4">14</span><span class="s0">,</span>
      <span class="s0">Mode: </span><span class="s4">8</span><span class="s0">,</span>
      <span class="s0">OffscreenComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">Profiler: </span><span class="s4">12</span><span class="s0">,</span>
      <span class="s0">ScopeComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">SimpleMemoComponent: </span><span class="s4">15</span><span class="s0">,</span>
      <span class="s0">SuspenseComponent: </span><span class="s4">13</span><span class="s0">,</span>
      <span class="s0">SuspenseListComponent: </span><span class="s4">19</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">TracingMarkerComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">YieldComponent: -</span><span class="s4">1 </span><span class="s3">// Removed</span>

    <span class="s0">};</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(gte(version, </span><span class="s2">'16.4.3-alpha'</span><span class="s0">)) {</span>
    <span class="s0">ReactTypeOfWork = {</span>
      <span class="s0">CacheComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">ClassComponent: </span><span class="s4">2</span><span class="s0">,</span>
      <span class="s0">ContextConsumer: </span><span class="s4">11</span><span class="s0">,</span>
      <span class="s0">ContextProvider: </span><span class="s4">12</span><span class="s0">,</span>
      <span class="s0">CoroutineComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Removed</span>
      <span class="s0">CoroutineHandlerPhase: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Removed</span>
      <span class="s0">DehydratedSuspenseComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">ForwardRef: </span><span class="s4">13</span><span class="s0">,</span>
      <span class="s0">Fragment: </span><span class="s4">9</span><span class="s0">,</span>
      <span class="s0">FunctionComponent: </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">HostComponent: </span><span class="s4">7</span><span class="s0">,</span>
      <span class="s0">HostPortal: </span><span class="s4">6</span><span class="s0">,</span>
      <span class="s0">HostRoot: </span><span class="s4">5</span><span class="s0">,</span>
      <span class="s0">HostHoistable: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">HostSingleton: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">HostText: </span><span class="s4">8</span><span class="s0">,</span>
      <span class="s0">IncompleteClassComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">IndeterminateComponent: </span><span class="s4">4</span><span class="s0">,</span>
      <span class="s0">LazyComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">LegacyHiddenComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">MemoComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">Mode: </span><span class="s4">10</span><span class="s0">,</span>
      <span class="s0">OffscreenComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">Profiler: </span><span class="s4">15</span><span class="s0">,</span>
      <span class="s0">ScopeComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">SimpleMemoComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">SuspenseComponent: </span><span class="s4">16</span><span class="s0">,</span>
      <span class="s0">SuspenseListComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">TracingMarkerComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">YieldComponent: -</span><span class="s4">1 </span><span class="s3">// Removed</span>

    <span class="s0">};</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">ReactTypeOfWork = {</span>
      <span class="s0">CacheComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">ClassComponent: </span><span class="s4">2</span><span class="s0">,</span>
      <span class="s0">ContextConsumer: </span><span class="s4">12</span><span class="s0">,</span>
      <span class="s0">ContextProvider: </span><span class="s4">13</span><span class="s0">,</span>
      <span class="s0">CoroutineComponent: </span><span class="s4">7</span><span class="s0">,</span>
      <span class="s0">CoroutineHandlerPhase: </span><span class="s4">8</span><span class="s0">,</span>
      <span class="s0">DehydratedSuspenseComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">ForwardRef: </span><span class="s4">14</span><span class="s0">,</span>
      <span class="s0">Fragment: </span><span class="s4">10</span><span class="s0">,</span>
      <span class="s0">FunctionComponent: </span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">HostComponent: </span><span class="s4">5</span><span class="s0">,</span>
      <span class="s0">HostPortal: </span><span class="s4">4</span><span class="s0">,</span>
      <span class="s0">HostRoot: </span><span class="s4">3</span><span class="s0">,</span>
      <span class="s0">HostHoistable: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">HostSingleton: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">HostText: </span><span class="s4">6</span><span class="s0">,</span>
      <span class="s0">IncompleteClassComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">IndeterminateComponent: </span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">LazyComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">LegacyHiddenComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s0">MemoComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">Mode: </span><span class="s4">11</span><span class="s0">,</span>
      <span class="s0">OffscreenComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">Profiler: </span><span class="s4">15</span><span class="s0">,</span>
      <span class="s0">ScopeComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Experimental</span>
      <span class="s0">SimpleMemoComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">SuspenseComponent: </span><span class="s4">16</span><span class="s0">,</span>
      <span class="s0">SuspenseListComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">TracingMarkerComponent: -</span><span class="s4">1</span><span class="s0">,</span>
      <span class="s3">// Doesn't exist yet</span>
      <span class="s0">YieldComponent: </span><span class="s4">9</span>
    <span class="s0">};</span>
  <span class="s0">} </span><span class="s3">// **********************************************************</span>
  <span class="s3">// End of copied code.</span>
  <span class="s3">// **********************************************************</span>


  <span class="s1">function </span><span class="s0">getTypeSymbol(type) {</span>
    <span class="s1">var </span><span class="s0">symbolOrNumber = renderer_typeof(type) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; type !== </span><span class="s1">null </span><span class="s0">? type.$$typeof : type;</span>
    <span class="s1">return </span><span class="s0">renderer_typeof(symbolOrNumber) === </span><span class="s2">'symbol' </span><span class="s0">? </span><span class="s3">// $FlowFixMe[incompatible-return] `toString()` doesn't match the type signature?</span>
    <span class="s0">symbolOrNumber.toString() : symbolOrNumber;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">_ReactTypeOfWork = ReactTypeOfWork,</span>
      <span class="s0">CacheComponent = _ReactTypeOfWork.CacheComponent,</span>
      <span class="s0">ClassComponent = _ReactTypeOfWork.ClassComponent,</span>
      <span class="s0">IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent,</span>
      <span class="s0">FunctionComponent = _ReactTypeOfWork.FunctionComponent,</span>
      <span class="s0">IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent,</span>
      <span class="s0">ForwardRef = _ReactTypeOfWork.ForwardRef,</span>
      <span class="s0">HostRoot = _ReactTypeOfWork.HostRoot,</span>
      <span class="s0">HostHoistable = _ReactTypeOfWork.HostHoistable,</span>
      <span class="s0">HostSingleton = _ReactTypeOfWork.HostSingleton,</span>
      <span class="s0">HostComponent = _ReactTypeOfWork.HostComponent,</span>
      <span class="s0">HostPortal = _ReactTypeOfWork.HostPortal,</span>
      <span class="s0">HostText = _ReactTypeOfWork.HostText,</span>
      <span class="s0">Fragment = _ReactTypeOfWork.Fragment,</span>
      <span class="s0">LazyComponent = _ReactTypeOfWork.LazyComponent,</span>
      <span class="s0">LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent,</span>
      <span class="s0">MemoComponent = _ReactTypeOfWork.MemoComponent,</span>
      <span class="s0">OffscreenComponent = _ReactTypeOfWork.OffscreenComponent,</span>
      <span class="s0">Profiler = _ReactTypeOfWork.Profiler,</span>
      <span class="s0">ScopeComponent = _ReactTypeOfWork.ScopeComponent,</span>
      <span class="s0">SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent,</span>
      <span class="s0">SuspenseComponent = _ReactTypeOfWork.SuspenseComponent,</span>
      <span class="s0">SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent,</span>
      <span class="s0">TracingMarkerComponent = _ReactTypeOfWork.TracingMarkerComponent;</span>

  <span class="s1">function </span><span class="s0">resolveFiberType(type) {</span>
    <span class="s1">var </span><span class="s0">typeSymbol = getTypeSymbol(type);</span>

    <span class="s1">switch </span><span class="s0">(typeSymbol) {</span>
      <span class="s1">case </span><span class="s0">ReactSymbols_MEMO_NUMBER:</span>
      <span class="s1">case </span><span class="s0">ReactSymbols_MEMO_SYMBOL_STRING:</span>
        <span class="s3">// recursively resolving memo type in case of memo(forwardRef(Component))</span>
        <span class="s1">return </span><span class="s0">resolveFiberType(type.type);</span>

      <span class="s1">case </span><span class="s0">ReactSymbols_FORWARD_REF_NUMBER:</span>
      <span class="s1">case </span><span class="s0">ReactSymbols_FORWARD_REF_SYMBOL_STRING:</span>
        <span class="s1">return </span><span class="s0">type.render;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">return </span><span class="s0">type;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods</span>


  <span class="s1">function </span><span class="s0">getDisplayNameForFiber(fiber) {</span>
    <span class="s1">var </span><span class="s0">elementType = fiber.elementType,</span>
        <span class="s0">type = fiber.type,</span>
        <span class="s0">tag = fiber.tag;</span>
    <span class="s1">var </span><span class="s0">resolvedType = type;</span>

    <span class="s1">if </span><span class="s0">(renderer_typeof(type) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; type !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">resolvedType = resolveFiberType(type);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">resolvedContext = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">switch </span><span class="s0">(tag) {</span>
      <span class="s1">case </span><span class="s0">CacheComponent:</span>
        <span class="s1">return </span><span class="s2">'Cache'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">ClassComponent:</span>
      <span class="s1">case </span><span class="s0">IncompleteClassComponent:</span>
        <span class="s1">return </span><span class="s0">getDisplayName(resolvedType);</span>

      <span class="s1">case </span><span class="s0">FunctionComponent:</span>
      <span class="s1">case </span><span class="s0">IndeterminateComponent:</span>
        <span class="s1">return </span><span class="s0">getDisplayName(resolvedType);</span>

      <span class="s1">case </span><span class="s0">ForwardRef:</span>
        <span class="s1">return </span><span class="s0">getWrappedDisplayName(elementType, resolvedType, </span><span class="s2">'ForwardRef'</span><span class="s0">, </span><span class="s2">'Anonymous'</span><span class="s0">);</span>

      <span class="s1">case </span><span class="s0">HostRoot:</span>
        <span class="s1">var </span><span class="s0">fiberRoot = fiber.stateNode;</span>

        <span class="s1">if </span><span class="s0">(fiberRoot != </span><span class="s1">null </span><span class="s0">&amp;&amp; fiberRoot._debugRootType !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s1">return </span><span class="s0">fiberRoot._debugRootType;</span>
        <span class="s0">}</span>

        <span class="s1">return null</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">HostComponent:</span>
      <span class="s1">case </span><span class="s0">HostSingleton:</span>
      <span class="s1">case </span><span class="s0">HostHoistable:</span>
        <span class="s1">return </span><span class="s0">type;</span>

      <span class="s1">case </span><span class="s0">HostPortal:</span>
      <span class="s1">case </span><span class="s0">HostText:</span>
        <span class="s1">return null</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">Fragment:</span>
        <span class="s1">return </span><span class="s2">'Fragment'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">LazyComponent:</span>
        <span class="s3">// This display name will not be user visible.</span>
        <span class="s3">// Once a Lazy component loads its inner component, React replaces the tag and type.</span>
        <span class="s3">// This display name will only show up in console logs when DevTools DEBUG mode is on.</span>
        <span class="s1">return </span><span class="s2">'Lazy'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">MemoComponent:</span>
      <span class="s1">case </span><span class="s0">SimpleMemoComponent:</span>
        <span class="s3">// Display name in React does not use `Memo` as a wrapper but fallback name.</span>
        <span class="s1">return </span><span class="s0">getWrappedDisplayName(elementType, resolvedType, </span><span class="s2">'Memo'</span><span class="s0">, </span><span class="s2">'Anonymous'</span><span class="s0">);</span>

      <span class="s1">case </span><span class="s0">SuspenseComponent:</span>
        <span class="s1">return </span><span class="s2">'Suspense'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">LegacyHiddenComponent:</span>
        <span class="s1">return </span><span class="s2">'LegacyHidden'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">OffscreenComponent:</span>
        <span class="s1">return </span><span class="s2">'Offscreen'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">ScopeComponent:</span>
        <span class="s1">return </span><span class="s2">'Scope'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">SuspenseListComponent:</span>
        <span class="s1">return </span><span class="s2">'SuspenseList'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">Profiler:</span>
        <span class="s1">return </span><span class="s2">'Profiler'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">TracingMarkerComponent:</span>
        <span class="s1">return </span><span class="s2">'TracingMarker'</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">var </span><span class="s0">typeSymbol = getTypeSymbol(type);</span>

        <span class="s1">switch </span><span class="s0">(typeSymbol) {</span>
          <span class="s1">case </span><span class="s0">CONCURRENT_MODE_NUMBER:</span>
          <span class="s1">case </span><span class="s0">CONCURRENT_MODE_SYMBOL_STRING:</span>
          <span class="s1">case </span><span class="s0">DEPRECATED_ASYNC_MODE_SYMBOL_STRING:</span>
            <span class="s1">return null</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s0">PROVIDER_NUMBER:</span>
          <span class="s1">case </span><span class="s0">PROVIDER_SYMBOL_STRING:</span>
            <span class="s3">// 16.3.0 exposed the context object as &quot;context&quot;</span>
            <span class="s3">// PR #12501 changed it to &quot;_context&quot; for 16.3.1+</span>
            <span class="s3">// NOTE Keep in sync with inspectElementRaw()</span>
            <span class="s0">resolvedContext = fiber.type._context || fiber.type.context;</span>
            <span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(resolvedContext.displayName || </span><span class="s2">'Context'</span><span class="s0">, </span><span class="s2">&quot;.Provider&quot;</span><span class="s0">);</span>

          <span class="s1">case </span><span class="s0">CONTEXT_NUMBER:</span>
          <span class="s1">case </span><span class="s0">CONTEXT_SYMBOL_STRING:</span>
          <span class="s1">case </span><span class="s0">SERVER_CONTEXT_SYMBOL_STRING:</span>
            <span class="s3">// 16.3-16.5 read from &quot;type&quot; because the Consumer is the actual context object.</span>
            <span class="s3">// 16.6+ should read from &quot;type._context&quot; because Consumer can be different (in DEV).</span>
            <span class="s3">// NOTE Keep in sync with inspectElementRaw()</span>
            <span class="s0">resolvedContext = fiber.type._context || fiber.type; </span><span class="s3">// NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'</span>
            <span class="s3">// If you change the name, figure out a more resilient way to detect it.</span>

            <span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(resolvedContext.displayName || </span><span class="s2">'Context'</span><span class="s0">, </span><span class="s2">&quot;.Consumer&quot;</span><span class="s0">);</span>

          <span class="s1">case </span><span class="s0">STRICT_MODE_NUMBER:</span>
          <span class="s1">case </span><span class="s0">STRICT_MODE_SYMBOL_STRING:</span>
            <span class="s1">return null</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s0">PROFILER_NUMBER:</span>
          <span class="s1">case </span><span class="s0">PROFILER_SYMBOL_STRING:</span>
            <span class="s1">return </span><span class="s2">&quot;Profiler(&quot;</span><span class="s0">.concat(fiber.memoizedProps.id, </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>

          <span class="s1">case </span><span class="s0">SCOPE_NUMBER:</span>
          <span class="s1">case </span><span class="s0">SCOPE_SYMBOL_STRING:</span>
            <span class="s1">return </span><span class="s2">'Scope'</span><span class="s0">;</span>

          <span class="s1">default</span><span class="s0">:</span>
            <span class="s3">// Unknown element type.</span>
            <span class="s3">// This may mean a new element type that has not yet been added to DevTools.</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>

    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">getDisplayNameForFiber: getDisplayNameForFiber,</span>
    <span class="s0">getTypeSymbol: getTypeSymbol,</span>
    <span class="s0">ReactPriorityLevels: ReactPriorityLevels,</span>
    <span class="s0">ReactTypeOfWork: ReactTypeOfWork,</span>
    <span class="s0">StrictModeBits: StrictModeBits</span>
  <span class="s0">};</span>
<span class="s0">} </span><span class="s3">// Map of one or more Fibers in a pair to their unique id number.</span>
<span class="s3">// We track both Fibers to support Fast Refresh,</span>
<span class="s3">// which may forcefully replace one of the pair as part of hot reloading.</span>
<span class="s3">// In that case it's still important to be able to locate the previous ID during subsequent renders.</span>

<span class="s1">var </span><span class="s0">fiberToIDMap = </span><span class="s1">new </span><span class="s0">Map(); </span><span class="s3">// Map of id to one (arbitrary) Fiber in a pair.</span>
<span class="s3">// This Map is used to e.g. get the display name for a Fiber or schedule an update,</span>
<span class="s3">// operations that should be the same whether the current and work-in-progress Fiber is used.</span>

<span class="s1">var </span><span class="s0">idToArbitraryFiberMap = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">function </span><span class="s0">attach(hook, rendererID, renderer, global) {</span>
  <span class="s3">// Newer versions of the reconciler package also specific reconciler version.</span>
  <span class="s3">// If that version number is present, use it.</span>
  <span class="s3">// Third party renderer versions may not match the reconciler version,</span>
  <span class="s3">// and the latter is what's important in terms of tags and symbols.</span>
  <span class="s1">var </span><span class="s0">version = renderer.reconcilerVersion || renderer.version;</span>

  <span class="s1">var </span><span class="s0">_getInternalReactCons = getInternalReactConstants(version),</span>
      <span class="s0">getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber,</span>
      <span class="s0">getTypeSymbol = _getInternalReactCons.getTypeSymbol,</span>
      <span class="s0">ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels,</span>
      <span class="s0">ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,</span>
      <span class="s0">StrictModeBits = _getInternalReactCons.StrictModeBits;</span>

  <span class="s1">var </span><span class="s0">CacheComponent = ReactTypeOfWork.CacheComponent,</span>
      <span class="s0">ClassComponent = ReactTypeOfWork.ClassComponent,</span>
      <span class="s0">ContextConsumer = ReactTypeOfWork.ContextConsumer,</span>
      <span class="s0">DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent,</span>
      <span class="s0">ForwardRef = ReactTypeOfWork.ForwardRef,</span>
      <span class="s0">Fragment = ReactTypeOfWork.Fragment,</span>
      <span class="s0">FunctionComponent = ReactTypeOfWork.FunctionComponent,</span>
      <span class="s0">HostRoot = ReactTypeOfWork.HostRoot,</span>
      <span class="s0">HostHoistable = ReactTypeOfWork.HostHoistable,</span>
      <span class="s0">HostSingleton = ReactTypeOfWork.HostSingleton,</span>
      <span class="s0">HostPortal = ReactTypeOfWork.HostPortal,</span>
      <span class="s0">HostComponent = ReactTypeOfWork.HostComponent,</span>
      <span class="s0">HostText = ReactTypeOfWork.HostText,</span>
      <span class="s0">IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent,</span>
      <span class="s0">IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,</span>
      <span class="s0">LegacyHiddenComponent = ReactTypeOfWork.LegacyHiddenComponent,</span>
      <span class="s0">MemoComponent = ReactTypeOfWork.MemoComponent,</span>
      <span class="s0">OffscreenComponent = ReactTypeOfWork.OffscreenComponent,</span>
      <span class="s0">SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent,</span>
      <span class="s0">SuspenseComponent = ReactTypeOfWork.SuspenseComponent,</span>
      <span class="s0">SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent,</span>
      <span class="s0">TracingMarkerComponent = ReactTypeOfWork.TracingMarkerComponent;</span>
  <span class="s1">var </span><span class="s0">ImmediatePriority = ReactPriorityLevels.ImmediatePriority,</span>
      <span class="s0">UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority,</span>
      <span class="s0">NormalPriority = ReactPriorityLevels.NormalPriority,</span>
      <span class="s0">LowPriority = ReactPriorityLevels.LowPriority,</span>
      <span class="s0">IdlePriority = ReactPriorityLevels.IdlePriority,</span>
      <span class="s0">NoPriority = ReactPriorityLevels.NoPriority;</span>
  <span class="s1">var </span><span class="s0">getLaneLabelMap = renderer.getLaneLabelMap,</span>
      <span class="s0">injectProfilingHooks = renderer.injectProfilingHooks,</span>
      <span class="s0">overrideHookState = renderer.overrideHookState,</span>
      <span class="s0">overrideHookStateDeletePath = renderer.overrideHookStateDeletePath,</span>
      <span class="s0">overrideHookStateRenamePath = renderer.overrideHookStateRenamePath,</span>
      <span class="s0">overrideProps = renderer.overrideProps,</span>
      <span class="s0">overridePropsDeletePath = renderer.overridePropsDeletePath,</span>
      <span class="s0">overridePropsRenamePath = renderer.overridePropsRenamePath,</span>
      <span class="s0">scheduleRefresh = renderer.scheduleRefresh,</span>
      <span class="s0">setErrorHandler = renderer.setErrorHandler,</span>
      <span class="s0">setSuspenseHandler = renderer.setSuspenseHandler,</span>
      <span class="s0">scheduleUpdate = renderer.scheduleUpdate;</span>
  <span class="s1">var </span><span class="s0">supportsTogglingError = </span><span class="s1">typeof </span><span class="s0">setErrorHandler === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">scheduleUpdate === </span><span class="s2">'function'</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">supportsTogglingSuspense = </span><span class="s1">typeof </span><span class="s0">setSuspenseHandler === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">scheduleUpdate === </span><span class="s2">'function'</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">scheduleRefresh === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s3">// When Fast Refresh updates a component, the frontend may need to purge cached information.</span>
    <span class="s3">// For example, ASTs cached for the component (for named hooks) may no longer be valid.</span>
    <span class="s3">// Send a signal to the frontend to purge this cached information.</span>
    <span class="s3">// The &quot;fastRefreshScheduled&quot; dispatched is global (not Fiber or even Renderer specific).</span>
    <span class="s3">// This is less effecient since it means the front-end will need to purge the entire cache,</span>
    <span class="s3">// but this is probably an okay trade off in order to reduce coupling between the DevTools and Fast Refresh.</span>
    <span class="s0">renderer.scheduleRefresh = </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">hook.emit(</span><span class="s2">'fastRefreshScheduled'</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">scheduleRefresh.apply(</span><span class="s1">void </span><span class="s4">0</span><span class="s0">, arguments);</span>
      <span class="s0">}</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">getTimelineData = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">toggleProfilingStatus = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">injectProfilingHooks === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">response = createProfilingHooks({</span>
      <span class="s0">getDisplayNameForFiber: getDisplayNameForFiber,</span>
      <span class="s0">getIsProfiling: </span><span class="s1">function </span><span class="s0">getIsProfiling() {</span>
        <span class="s1">return </span><span class="s0">isProfiling;</span>
      <span class="s0">},</span>
      <span class="s0">getLaneLabelMap: getLaneLabelMap,</span>
      <span class="s0">currentDispatcherRef: renderer.currentDispatcherRef,</span>
      <span class="s0">workTagMap: ReactTypeOfWork,</span>
      <span class="s0">reactVersion: version</span>
    <span class="s0">}); </span><span class="s3">// Pass the Profiling hooks to the reconciler for it to call during render.</span>

    <span class="s0">injectProfilingHooks(response.profilingHooks); </span><span class="s3">// Hang onto this toggle so we can notify the external methods of profiling status changes.</span>

    <span class="s0">getTimelineData = response.getTimelineData;</span>
    <span class="s0">toggleProfilingStatus = response.toggleProfilingStatus;</span>
  <span class="s0">} </span><span class="s3">// Tracks Fibers with recently changed number of error/warning messages.</span>
  <span class="s3">// These collections store the Fiber rather than the ID,</span>
  <span class="s3">// in order to avoid generating an ID for Fibers that never get mounted</span>
  <span class="s3">// (due to e.g. Suspense or error boundaries).</span>
  <span class="s3">// onErrorOrWarning() adds Fibers and recordPendingErrorsAndWarnings() later clears them.</span>


  <span class="s1">var </span><span class="s0">fibersWithChangedErrorOrWarningCounts = </span><span class="s1">new </span><span class="s0">Set();</span>
  <span class="s1">var </span><span class="s0">pendingFiberToErrorsMap = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">pendingFiberToWarningsMap = </span><span class="s1">new </span><span class="s0">Map(); </span><span class="s3">// Mapping of fiber IDs to error/warning messages and counts.</span>

  <span class="s1">var </span><span class="s0">fiberIDToErrorsMap = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">fiberIDToWarningsMap = </span><span class="s1">new </span><span class="s0">Map();</span>

  <span class="s1">function </span><span class="s0">clearErrorsAndWarnings() {</span>
    <span class="s3">// eslint-disable-next-line no-for-of-loops/no-for-of-loops</span>
    <span class="s1">var </span><span class="s0">_iterator = _createForOfIteratorHelper(fiberIDToErrorsMap.keys()),</span>
        <span class="s0">_step;</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s1">for </span><span class="s0">(_iterator.s(); !(_step = _iterator.n()).done;) {</span>
        <span class="s1">var </span><span class="s0">id = _step.value;</span>

        <span class="s1">var </span><span class="s0">_fiber = idToArbitraryFiberMap.get(id);</span>

        <span class="s1">if </span><span class="s0">(_fiber != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">fibersWithChangedErrorOrWarningCounts.add(_fiber);</span>
          <span class="s0">updateMostRecentlyInspectedElementIfNecessary(id);</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s3">// eslint-disable-next-line no-for-of-loops/no-for-of-loops</span>

    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
      <span class="s0">_iterator.e(err);</span>
    <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
      <span class="s0">_iterator.f();</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">_iterator2 = _createForOfIteratorHelper(fiberIDToWarningsMap.keys()),</span>
        <span class="s0">_step2;</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s1">for </span><span class="s0">(_iterator2.s(); !(_step2 = _iterator2.n()).done;) {</span>
        <span class="s1">var </span><span class="s0">_id = _step2.value;</span>

        <span class="s1">var </span><span class="s0">_fiber2 = idToArbitraryFiberMap.get(_id);</span>

        <span class="s1">if </span><span class="s0">(_fiber2 != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">fibersWithChangedErrorOrWarningCounts.add(_fiber2);</span>
          <span class="s0">updateMostRecentlyInspectedElementIfNecessary(_id);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
      <span class="s0">_iterator2.e(err);</span>
    <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
      <span class="s0">_iterator2.f();</span>
    <span class="s0">}</span>

    <span class="s0">fiberIDToErrorsMap.clear();</span>
    <span class="s0">fiberIDToWarningsMap.clear();</span>
    <span class="s0">flushPendingEvents();</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">clearMessageCountHelper(fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {</span>
    <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(fiberID);</span>

    <span class="s1">if </span><span class="s0">(fiber != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Throw out any pending changes.</span>
      <span class="s0">pendingFiberToErrorsMap.</span><span class="s1">delete</span><span class="s0">(fiber);</span>

      <span class="s1">if </span><span class="s0">(fiberIDToMessageCountMap.has(fiberID)) {</span>
        <span class="s0">fiberIDToMessageCountMap.</span><span class="s1">delete</span><span class="s0">(fiberID); </span><span class="s3">// If previous flushed counts have changed, schedule an update too.</span>

        <span class="s0">fibersWithChangedErrorOrWarningCounts.add(fiber);</span>
        <span class="s0">flushPendingEvents();</span>
        <span class="s0">updateMostRecentlyInspectedElementIfNecessary(fiberID);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">fibersWithChangedErrorOrWarningCounts.</span><span class="s1">delete</span><span class="s0">(fiber);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">clearErrorsForFiberID(fiberID) {</span>
    <span class="s0">clearMessageCountHelper(fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">clearWarningsForFiberID(fiberID) {</span>
    <span class="s0">clearMessageCountHelper(fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">updateMostRecentlyInspectedElementIfNecessary(fiberID) {</span>
    <span class="s1">if </span><span class="s0">(mostRecentlyInspectedElement !== </span><span class="s1">null </span><span class="s0">&amp;&amp; mostRecentlyInspectedElement.id === fiberID) {</span>
      <span class="s0">hasElementUpdatedSinceLastInspected = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Called when an error or warning is logged during render, commit, or passive (including unmount functions).</span>


  <span class="s1">function </span><span class="s0">onErrorOrWarning(fiber, type, args) {</span>
    <span class="s1">if </span><span class="s0">(type === </span><span class="s2">'error'</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">maybeID = getFiberIDUnsafe(fiber); </span><span class="s3">// if this is an error simulated by us to trigger error boundary, ignore</span>

      <span class="s1">if </span><span class="s0">(maybeID != </span><span class="s1">null </span><span class="s0">&amp;&amp; forceErrorForFiberIDs.get(maybeID) === </span><span class="s1">true</span><span class="s0">) {</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">message = format.apply(</span><span class="s1">void </span><span class="s4">0</span><span class="s0">, renderer_toConsumableArray(args));</span>

    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">debug(</span><span class="s2">'onErrorOrWarning'</span><span class="s0">, fiber, </span><span class="s1">null</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(type, </span><span class="s2">&quot;: </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(message, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
    <span class="s0">} </span><span class="s3">// Mark this Fiber as needed its warning/error count updated during the next flush.</span>


    <span class="s0">fibersWithChangedErrorOrWarningCounts.add(fiber); </span><span class="s3">// Track the warning/error for later.</span>

    <span class="s1">var </span><span class="s0">fiberMap = type === </span><span class="s2">'error' </span><span class="s0">? pendingFiberToErrorsMap : pendingFiberToWarningsMap;</span>
    <span class="s1">var </span><span class="s0">messageMap = fiberMap.get(fiber);</span>

    <span class="s1">if </span><span class="s0">(messageMap != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">count = messageMap.get(message) || </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">messageMap.set(message, count + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">fiberMap.set(fiber, </span><span class="s1">new </span><span class="s0">Map([[message, </span><span class="s4">1</span><span class="s0">]]));</span>
    <span class="s0">} </span><span class="s3">// Passive effects may trigger errors or warnings too;</span>
    <span class="s3">// In this case, we should wait until the rest of the passive effects have run,</span>
    <span class="s3">// but we shouldn't wait until the next commit because that might be a long time.</span>
    <span class="s3">// This would also cause &quot;tearing&quot; between an inspected Component and the tree view.</span>
    <span class="s3">// Then again we don't want to flush too soon because this could be an error during async rendering.</span>
    <span class="s3">// Use a debounce technique to ensure that we'll eventually flush.</span>


    <span class="s0">flushPendingErrorsAndWarningsAfterDelay();</span>
  <span class="s0">} </span><span class="s3">// Patching the console enables DevTools to do a few useful things:</span>
  <span class="s3">// * Append component stacks to warnings and error messages</span>
  <span class="s3">// * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)</span>


  <span class="s0">registerRenderer(renderer, onErrorOrWarning); </span><span class="s3">// The renderer interface can't read these preferences directly,</span>
  <span class="s3">// because it is stored in localStorage within the context of the extension.</span>
  <span class="s3">// It relies on the extension to pass the preference through via the global.</span>

  <span class="s0">patchConsoleUsingWindowValues();</span>

  <span class="s1">var </span><span class="s0">debug = </span><span class="s1">function </span><span class="s0">debug(name, fiber, parentFiber) {</span>
    <span class="s1">var </span><span class="s0">extraString = arguments.length &gt; </span><span class="s4">3 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">3</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">3</span><span class="s0">] : </span><span class="s2">''</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s1">var </span><span class="s0">displayName = fiber.tag + </span><span class="s2">':' </span><span class="s0">+ (getDisplayNameForFiber(fiber) || </span><span class="s2">'null'</span><span class="s0">);</span>
      <span class="s1">var </span><span class="s0">maybeID = getFiberIDUnsafe(fiber) || </span><span class="s2">'&lt;no id&gt;'</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">parentDisplayName = parentFiber ? parentFiber.tag + </span><span class="s2">':' </span><span class="s0">+ (getDisplayNameForFiber(parentFiber) || </span><span class="s2">'null'</span><span class="s0">) : </span><span class="s2">''</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">maybeParentID = parentFiber ? getFiberIDUnsafe(parentFiber) || </span><span class="s2">'&lt;no-id&gt;' </span><span class="s0">: </span><span class="s2">''</span><span class="s0">;</span>
      <span class="s0">console.groupCollapsed(</span><span class="s2">&quot;[renderer] %c&quot;</span><span class="s0">.concat(name, </span><span class="s2">&quot; %c&quot;</span><span class="s0">).concat(displayName, </span><span class="s2">&quot; (&quot;</span><span class="s0">).concat(maybeID, </span><span class="s2">&quot;) %c&quot;</span><span class="s0">).concat(parentFiber ? </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(parentDisplayName, </span><span class="s2">&quot; (&quot;</span><span class="s0">).concat(maybeParentID, </span><span class="s2">&quot;)&quot;</span><span class="s0">) : </span><span class="s2">''</span><span class="s0">, </span><span class="s2">&quot; %c&quot;</span><span class="s0">).concat(extraString), </span><span class="s2">'color: red; font-weight: bold;'</span><span class="s0">, </span><span class="s2">'color: blue;'</span><span class="s0">, </span><span class="s2">'color: purple;'</span><span class="s0">, </span><span class="s2">'color: black;'</span><span class="s0">);</span>
      <span class="s0">console.log(</span><span class="s1">new </span><span class="s0">Error().stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">).slice(</span><span class="s4">1</span><span class="s0">).join(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">));</span>
      <span class="s0">console.groupEnd();</span>
    <span class="s0">}</span>
  <span class="s0">}; </span><span class="s3">// Configurable Components tree filters.</span>


  <span class="s1">var </span><span class="s0">hideElementsWithDisplayNames = </span><span class="s1">new </span><span class="s0">Set();</span>
  <span class="s1">var </span><span class="s0">hideElementsWithPaths = </span><span class="s1">new </span><span class="s0">Set();</span>
  <span class="s1">var </span><span class="s0">hideElementsWithTypes = </span><span class="s1">new </span><span class="s0">Set(); </span><span class="s3">// Highlight updates</span>

  <span class="s1">var </span><span class="s0">traceUpdatesEnabled = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">traceUpdatesForNodes = </span><span class="s1">new </span><span class="s0">Set();</span>

  <span class="s1">function </span><span class="s0">applyComponentFilters(componentFilters) {</span>
    <span class="s0">hideElementsWithTypes.clear();</span>
    <span class="s0">hideElementsWithDisplayNames.clear();</span>
    <span class="s0">hideElementsWithPaths.clear();</span>
    <span class="s0">componentFilters.forEach(</span><span class="s1">function </span><span class="s0">(componentFilter) {</span>
      <span class="s1">if </span><span class="s0">(!componentFilter.isEnabled) {</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">switch </span><span class="s0">(componentFilter.type) {</span>
        <span class="s1">case </span><span class="s0">ComponentFilterDisplayName:</span>
          <span class="s1">if </span><span class="s0">(componentFilter.isValid &amp;&amp; componentFilter.value !== </span><span class="s2">''</span><span class="s0">) {</span>
            <span class="s0">hideElementsWithDisplayNames.add(</span><span class="s1">new </span><span class="s0">RegExp(componentFilter.value, </span><span class="s2">'i'</span><span class="s0">));</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s0">ComponentFilterElementType:</span>
          <span class="s0">hideElementsWithTypes.add(componentFilter.value);</span>
          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s0">ComponentFilterLocation:</span>
          <span class="s1">if </span><span class="s0">(componentFilter.isValid &amp;&amp; componentFilter.value !== </span><span class="s2">''</span><span class="s0">) {</span>
            <span class="s0">hideElementsWithPaths.add(</span><span class="s1">new </span><span class="s0">RegExp(componentFilter.value, </span><span class="s2">'i'</span><span class="s0">));</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s0">ComponentFilterHOC:</span>
          <span class="s0">hideElementsWithDisplayNames.add(</span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s2">'</span><span class="s5">\\</span><span class="s2">('</span><span class="s0">));</span>
          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">default</span><span class="s0">:</span>
          <span class="s0">console.warn(</span><span class="s2">&quot;Invalid component filter type </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(componentFilter.type, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
          <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s3">// The renderer interface can't read saved component filters directly,</span>
  <span class="s3">// because they are stored in localStorage within the context of the extension.</span>
  <span class="s3">// Instead it relies on the extension to pass filters through.</span>


  <span class="s1">if </span><span class="s0">(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s3">// Unfortunately this feature is not expected to work for React Native for now.</span>
    <span class="s3">// It would be annoying for us to spam YellowBox warnings with unactionable stuff,</span>
    <span class="s3">// so for now just skip this message...</span>
    <span class="s3">//console.warn(' DevTools: Could not locate saved component filters');</span>
    <span class="s3">// Fallback to assuming the default filters in this case.</span>
    <span class="s0">applyComponentFilters(getDefaultComponentFilters());</span>
  <span class="s0">} </span><span class="s3">// If necessary, we can revisit optimizing this operation.</span>
  <span class="s3">// For example, we could add a new recursive unmount tree operation.</span>
  <span class="s3">// The unmount operations are already significantly smaller than mount operations though.</span>
  <span class="s3">// This is something to keep in mind for later.</span>


  <span class="s1">function </span><span class="s0">updateComponentFilters(componentFilters) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s3">// Re-mounting a tree while profiling is in progress might break a lot of assumptions.</span>
      <span class="s3">// If necessary, we could support this- but it doesn't seem like a necessary use case.</span>
      <span class="s1">throw </span><span class="s0">Error(</span><span class="s2">'Cannot modify filter preferences while profiling'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s3">// Recursively unmount all roots.</span>


    <span class="s0">hook.getFiberRoots(rendererID).forEach(</span><span class="s1">function </span><span class="s0">(root) {</span>
      <span class="s0">currentRootID = getOrGenerateFiberID(root.current); </span><span class="s3">// The TREE_OPERATION_REMOVE_ROOT operation serves two purposes:</span>
      <span class="s3">// 1. It avoids sending unnecessary bridge traffic to clear a root.</span>
      <span class="s3">// 2. It preserves Fiber IDs when remounting (below) which in turn ID to error/warning mapping.</span>

      <span class="s0">pushOperation(TREE_OPERATION_REMOVE_ROOT);</span>
      <span class="s0">flushPendingEvents(root);</span>
      <span class="s0">currentRootID = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s0">applyComponentFilters(componentFilters); </span><span class="s3">// Reset pseudo counters so that new path selections will be persisted.</span>

    <span class="s0">rootDisplayNameCounter.clear(); </span><span class="s3">// Recursively re-mount all roots with new filter criteria applied.</span>

    <span class="s0">hook.getFiberRoots(rendererID).forEach(</span><span class="s1">function </span><span class="s0">(root) {</span>
      <span class="s0">currentRootID = getOrGenerateFiberID(root.current);</span>
      <span class="s0">setRootPseudoKey(currentRootID, root.current);</span>
      <span class="s0">mountFiberRecursively(root.current, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
      <span class="s0">flushPendingEvents(root);</span>
      <span class="s0">currentRootID = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}); </span><span class="s3">// Also re-evaluate all error and warning counts given the new filters.</span>

    <span class="s0">reevaluateErrorsAndWarnings();</span>
    <span class="s0">flushPendingEvents();</span>
  <span class="s0">} </span><span class="s3">// NOTICE Keep in sync with get*ForFiber methods</span>


  <span class="s1">function </span><span class="s0">shouldFilterFiber(fiber) {</span>
    <span class="s1">var </span><span class="s0">_debugSource = fiber._debugSource,</span>
        <span class="s0">tag = fiber.tag,</span>
        <span class="s0">type = fiber.type,</span>
        <span class="s0">key = fiber.key;</span>

    <span class="s1">switch </span><span class="s0">(tag) {</span>
      <span class="s1">case </span><span class="s0">DehydratedSuspenseComponent:</span>
        <span class="s3">// TODO: ideally we would show dehydrated Suspense immediately.</span>
        <span class="s3">// However, it has some special behavior (like disconnecting</span>
        <span class="s3">// an alternate and turning into real Suspense) which breaks DevTools.</span>
        <span class="s3">// For now, ignore it, and only show it once it gets hydrated.</span>
        <span class="s3">// https://github.com/bvaughn/react-devtools-experimental/issues/197</span>
        <span class="s1">return true</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">HostPortal:</span>
      <span class="s1">case </span><span class="s0">HostText:</span>
      <span class="s1">case </span><span class="s0">LegacyHiddenComponent:</span>
      <span class="s1">case </span><span class="s0">OffscreenComponent:</span>
        <span class="s1">return true</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">HostRoot:</span>
        <span class="s3">// It is never valid to filter the root element.</span>
        <span class="s1">return false</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">Fragment:</span>
        <span class="s1">return </span><span class="s0">key === </span><span class="s1">null</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">var </span><span class="s0">typeSymbol = getTypeSymbol(type);</span>

        <span class="s1">switch </span><span class="s0">(typeSymbol) {</span>
          <span class="s1">case </span><span class="s0">CONCURRENT_MODE_NUMBER:</span>
          <span class="s1">case </span><span class="s0">CONCURRENT_MODE_SYMBOL_STRING:</span>
          <span class="s1">case </span><span class="s0">DEPRECATED_ASYNC_MODE_SYMBOL_STRING:</span>
          <span class="s1">case </span><span class="s0">STRICT_MODE_NUMBER:</span>
          <span class="s1">case </span><span class="s0">STRICT_MODE_SYMBOL_STRING:</span>
            <span class="s1">return true</span><span class="s0">;</span>

          <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>

    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">elementType = getElementTypeForFiber(fiber);</span>

    <span class="s1">if </span><span class="s0">(hideElementsWithTypes.has(elementType)) {</span>
      <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(hideElementsWithDisplayNames.size &gt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">displayName = getDisplayNameForFiber(fiber);</span>

      <span class="s1">if </span><span class="s0">(displayName != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// eslint-disable-next-line no-for-of-loops/no-for-of-loops</span>
        <span class="s1">var </span><span class="s0">_iterator3 = _createForOfIteratorHelper(hideElementsWithDisplayNames),</span>
            <span class="s0">_step3;</span>

        <span class="s1">try </span><span class="s0">{</span>
          <span class="s1">for </span><span class="s0">(_iterator3.s(); !(_step3 = _iterator3.n()).done;) {</span>
            <span class="s1">var </span><span class="s0">displayNameRegExp = _step3.value;</span>

            <span class="s1">if </span><span class="s0">(displayNameRegExp.test(displayName)) {</span>
              <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
          <span class="s0">_iterator3.e(err);</span>
        <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
          <span class="s0">_iterator3.f();</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(_debugSource != </span><span class="s1">null </span><span class="s0">&amp;&amp; hideElementsWithPaths.size &gt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">fileName = _debugSource.fileName; </span><span class="s3">// eslint-disable-next-line no-for-of-loops/no-for-of-loops</span>

      <span class="s1">var </span><span class="s0">_iterator4 = _createForOfIteratorHelper(hideElementsWithPaths),</span>
          <span class="s0">_step4;</span>

      <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">for </span><span class="s0">(_iterator4.s(); !(_step4 = _iterator4.n()).done;) {</span>
          <span class="s1">var </span><span class="s0">pathRegExp = _step4.value;</span>

          <span class="s1">if </span><span class="s0">(pathRegExp.test(fileName)) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
        <span class="s0">_iterator4.e(err);</span>
      <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
        <span class="s0">_iterator4.f();</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods</span>


  <span class="s1">function </span><span class="s0">getElementTypeForFiber(fiber) {</span>
    <span class="s1">var </span><span class="s0">type = fiber.type,</span>
        <span class="s0">tag = fiber.tag;</span>

    <span class="s1">switch </span><span class="s0">(tag) {</span>
      <span class="s1">case </span><span class="s0">ClassComponent:</span>
      <span class="s1">case </span><span class="s0">IncompleteClassComponent:</span>
        <span class="s1">return </span><span class="s0">types_ElementTypeClass;</span>

      <span class="s1">case </span><span class="s0">FunctionComponent:</span>
      <span class="s1">case </span><span class="s0">IndeterminateComponent:</span>
        <span class="s1">return </span><span class="s0">types_ElementTypeFunction;</span>

      <span class="s1">case </span><span class="s0">ForwardRef:</span>
        <span class="s1">return </span><span class="s0">types_ElementTypeForwardRef;</span>

      <span class="s1">case </span><span class="s0">HostRoot:</span>
        <span class="s1">return </span><span class="s0">ElementTypeRoot;</span>

      <span class="s1">case </span><span class="s0">HostComponent:</span>
      <span class="s1">case </span><span class="s0">HostHoistable:</span>
      <span class="s1">case </span><span class="s0">HostSingleton:</span>
        <span class="s1">return </span><span class="s0">ElementTypeHostComponent;</span>

      <span class="s1">case </span><span class="s0">HostPortal:</span>
      <span class="s1">case </span><span class="s0">HostText:</span>
      <span class="s1">case </span><span class="s0">Fragment:</span>
        <span class="s1">return </span><span class="s0">ElementTypeOtherOrUnknown;</span>

      <span class="s1">case </span><span class="s0">MemoComponent:</span>
      <span class="s1">case </span><span class="s0">SimpleMemoComponent:</span>
        <span class="s1">return </span><span class="s0">types_ElementTypeMemo;</span>

      <span class="s1">case </span><span class="s0">SuspenseComponent:</span>
        <span class="s1">return </span><span class="s0">ElementTypeSuspense;</span>

      <span class="s1">case </span><span class="s0">SuspenseListComponent:</span>
        <span class="s1">return </span><span class="s0">ElementTypeSuspenseList;</span>

      <span class="s1">case </span><span class="s0">TracingMarkerComponent:</span>
        <span class="s1">return </span><span class="s0">ElementTypeTracingMarker;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">var </span><span class="s0">typeSymbol = getTypeSymbol(type);</span>

        <span class="s1">switch </span><span class="s0">(typeSymbol) {</span>
          <span class="s1">case </span><span class="s0">CONCURRENT_MODE_NUMBER:</span>
          <span class="s1">case </span><span class="s0">CONCURRENT_MODE_SYMBOL_STRING:</span>
          <span class="s1">case </span><span class="s0">DEPRECATED_ASYNC_MODE_SYMBOL_STRING:</span>
            <span class="s1">return </span><span class="s0">ElementTypeOtherOrUnknown;</span>

          <span class="s1">case </span><span class="s0">PROVIDER_NUMBER:</span>
          <span class="s1">case </span><span class="s0">PROVIDER_SYMBOL_STRING:</span>
            <span class="s1">return </span><span class="s0">ElementTypeContext;</span>

          <span class="s1">case </span><span class="s0">CONTEXT_NUMBER:</span>
          <span class="s1">case </span><span class="s0">CONTEXT_SYMBOL_STRING:</span>
            <span class="s1">return </span><span class="s0">ElementTypeContext;</span>

          <span class="s1">case </span><span class="s0">STRICT_MODE_NUMBER:</span>
          <span class="s1">case </span><span class="s0">STRICT_MODE_SYMBOL_STRING:</span>
            <span class="s1">return </span><span class="s0">ElementTypeOtherOrUnknown;</span>

          <span class="s1">case </span><span class="s0">PROFILER_NUMBER:</span>
          <span class="s1">case </span><span class="s0">PROFILER_SYMBOL_STRING:</span>
            <span class="s1">return </span><span class="s0">ElementTypeProfiler;</span>

          <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">ElementTypeOtherOrUnknown;</span>
        <span class="s0">}</span>

    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// When profiling is supported, we store the latest tree base durations for each Fiber.</span>
  <span class="s3">// This is so that we can quickly capture a snapshot of those values if profiling starts.</span>
  <span class="s3">// If we didn't store these values, we'd have to crawl the tree when profiling started,</span>
  <span class="s3">// and use a slow path to find each of the current Fibers.</span>


  <span class="s1">var </span><span class="s0">idToTreeBaseDurationMap = </span><span class="s1">new </span><span class="s0">Map(); </span><span class="s3">// When profiling is supported, we store the latest tree base durations for each Fiber.</span>
  <span class="s3">// This map enables us to filter these times by root when sending them to the frontend.</span>

  <span class="s1">var </span><span class="s0">idToRootMap = </span><span class="s1">new </span><span class="s0">Map(); </span><span class="s3">// When a mount or update is in progress, this value tracks the root that is being operated on.</span>

  <span class="s1">var </span><span class="s0">currentRootID = -</span><span class="s4">1</span><span class="s0">; </span><span class="s3">// Returns the unique ID for a Fiber or generates and caches a new one if the Fiber hasn't been seen before.</span>
  <span class="s3">// Once this method has been called for a Fiber, untrackFiberID() should always be called later to avoid leaking.</span>

  <span class="s1">function </span><span class="s0">getOrGenerateFiberID(fiber) {</span>
    <span class="s1">var </span><span class="s0">id = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(fiberToIDMap.has(fiber)) {</span>
      <span class="s0">id = fiberToIDMap.get(fiber);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">_alternate = fiber.alternate;</span>

      <span class="s1">if </span><span class="s0">(_alternate !== </span><span class="s1">null </span><span class="s0">&amp;&amp; fiberToIDMap.has(_alternate)) {</span>
        <span class="s0">id = fiberToIDMap.get(_alternate);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">didGenerateID = </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(id === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">didGenerateID = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">id = getUID();</span>
    <span class="s0">} </span><span class="s3">// This refinement is for Flow purposes only.</span>


    <span class="s1">var </span><span class="s0">refinedID = id; </span><span class="s3">// Make sure we're tracking this Fiber</span>
    <span class="s3">// e.g. if it just mounted or an error was logged during initial render.</span>

    <span class="s1">if </span><span class="s0">(!fiberToIDMap.has(fiber)) {</span>
      <span class="s0">fiberToIDMap.set(fiber, refinedID);</span>
      <span class="s0">idToArbitraryFiberMap.set(refinedID, fiber);</span>
    <span class="s0">} </span><span class="s3">// Also make sure we're tracking its alternate,</span>
    <span class="s3">// e.g. in case this is the first update after mount.</span>


    <span class="s1">var </span><span class="s0">alternate = fiber.alternate;</span>

    <span class="s1">if </span><span class="s0">(alternate !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(!fiberToIDMap.has(alternate)) {</span>
        <span class="s0">fiberToIDMap.set(alternate, refinedID);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s1">if </span><span class="s0">(didGenerateID) {</span>
        <span class="s0">debug(</span><span class="s2">'getOrGenerateFiberID()'</span><span class="s0">, fiber, fiber.</span><span class="s1">return</span><span class="s0">, </span><span class="s2">'Generated a new UID'</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">refinedID;</span>
  <span class="s0">} </span><span class="s3">// Returns an ID if one has already been generated for the Fiber or throws.</span>


  <span class="s1">function </span><span class="s0">getFiberIDThrows(fiber) {</span>
    <span class="s1">var </span><span class="s0">maybeID = getFiberIDUnsafe(fiber);</span>

    <span class="s1">if </span><span class="s0">(maybeID !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">maybeID;</span>
    <span class="s0">}</span>

    <span class="s1">throw </span><span class="s0">Error(</span><span class="s2">&quot;Could not find ID for Fiber </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(getDisplayNameForFiber(fiber) || </span><span class="s2">''</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
  <span class="s0">} </span><span class="s3">// Returns an ID if one has already been generated for the Fiber or null if one has not been generated.</span>
  <span class="s3">// Use this method while e.g. logging to avoid over-retaining Fibers.</span>


  <span class="s1">function </span><span class="s0">getFiberIDUnsafe(fiber) {</span>
    <span class="s1">if </span><span class="s0">(fiberToIDMap.has(fiber)) {</span>
      <span class="s1">return </span><span class="s0">fiberToIDMap.get(fiber);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">alternate = fiber.alternate;</span>

      <span class="s1">if </span><span class="s0">(alternate !== </span><span class="s1">null </span><span class="s0">&amp;&amp; fiberToIDMap.has(alternate)) {</span>
        <span class="s1">return </span><span class="s0">fiberToIDMap.get(alternate);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// Removes a Fiber (and its alternate) from the Maps used to track their id.</span>
  <span class="s3">// This method should always be called when a Fiber is unmounting.</span>


  <span class="s1">function </span><span class="s0">untrackFiberID(fiber) {</span>
    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">debug(</span><span class="s2">'untrackFiberID()'</span><span class="s0">, fiber, fiber.</span><span class="s1">return</span><span class="s0">, </span><span class="s2">'schedule after delay'</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s3">// Untrack Fibers after a slight delay in order to support a Fast Refresh edge case:</span>
    <span class="s3">// 1. Component type is updated and Fast Refresh schedules an update+remount.</span>
    <span class="s3">// 2. flushPendingErrorsAndWarningsAfterDelay() runs, sees the old Fiber is no longer mounted</span>
    <span class="s3">//    (it's been disconnected by Fast Refresh), and calls untrackFiberID() to clear it from the Map.</span>
    <span class="s3">// 3. React flushes pending passive effects before it runs the next render,</span>
    <span class="s3">//    which logs an error or warning, which causes a new ID to be generated for this Fiber.</span>
    <span class="s3">// 4. DevTools now tries to unmount the old Component with the new ID.</span>
    <span class="s3">//</span>
    <span class="s3">// The underlying problem here is the premature clearing of the Fiber ID,</span>
    <span class="s3">// but DevTools has no way to detect that a given Fiber has been scheduled for Fast Refresh.</span>
    <span class="s3">// (The &quot;_debugNeedsRemount&quot; flag won't necessarily be set.)</span>
    <span class="s3">//</span>
    <span class="s3">// The best we can do is to delay untracking by a small amount,</span>
    <span class="s3">// and give React time to process the Fast Refresh delay.</span>


    <span class="s0">untrackFibersSet.add(fiber); </span><span class="s3">// React may detach alternate pointers during unmount;</span>
    <span class="s3">// Since our untracking code is async, we should explicily track the pending alternate here as well.</span>

    <span class="s1">var </span><span class="s0">alternate = fiber.alternate;</span>

    <span class="s1">if </span><span class="s0">(alternate !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">untrackFibersSet.add(alternate);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(untrackFibersTimeoutID === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">untrackFibersTimeoutID = setTimeout(untrackFibers, </span><span class="s4">1000</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">untrackFibersSet = </span><span class="s1">new </span><span class="s0">Set();</span>
  <span class="s1">var </span><span class="s0">untrackFibersTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">untrackFibers() {</span>
    <span class="s1">if </span><span class="s0">(untrackFibersTimeoutID !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">clearTimeout(untrackFibersTimeoutID);</span>
      <span class="s0">untrackFibersTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">untrackFibersSet.forEach(</span><span class="s1">function </span><span class="s0">(fiber) {</span>
      <span class="s1">var </span><span class="s0">fiberID = getFiberIDUnsafe(fiber);</span>

      <span class="s1">if </span><span class="s0">(fiberID !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">idToArbitraryFiberMap.</span><span class="s1">delete</span><span class="s0">(fiberID); </span><span class="s3">// Also clear any errors/warnings associated with this fiber.</span>

        <span class="s0">clearErrorsForFiberID(fiberID);</span>
        <span class="s0">clearWarningsForFiberID(fiberID);</span>
      <span class="s0">}</span>

      <span class="s0">fiberToIDMap.</span><span class="s1">delete</span><span class="s0">(fiber);</span>
      <span class="s1">var </span><span class="s0">alternate = fiber.alternate;</span>

      <span class="s1">if </span><span class="s0">(alternate !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">fiberToIDMap.</span><span class="s1">delete</span><span class="s0">(alternate);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(forceErrorForFiberIDs.has(fiberID)) {</span>
        <span class="s0">forceErrorForFiberIDs.</span><span class="s1">delete</span><span class="s0">(fiberID);</span>

        <span class="s1">if </span><span class="s0">(forceErrorForFiberIDs.size === </span><span class="s4">0 </span><span class="s0">&amp;&amp; setErrorHandler != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">setErrorHandler(shouldErrorFiberAlwaysNull);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">untrackFibersSet.clear();</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getChangeDescription(prevFiber, nextFiber) {</span>
    <span class="s1">switch </span><span class="s0">(getElementTypeForFiber(nextFiber)) {</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeClass:</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeFunction:</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeMemo:</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeForwardRef:</span>
        <span class="s1">if </span><span class="s0">(prevFiber === </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">context: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">didHooksChange: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">isFirstMount: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">props: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">state: </span><span class="s1">null</span>
          <span class="s0">};</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">var </span><span class="s0">data = {</span>
            <span class="s0">context: getContextChangedKeys(nextFiber),</span>
            <span class="s0">didHooksChange: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">isFirstMount: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),</span>
            <span class="s0">state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)</span>
          <span class="s0">}; </span><span class="s3">// Only traverse the hooks list once, depending on what info we're returning.</span>

          <span class="s1">var </span><span class="s0">indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);</span>
          <span class="s0">data.hooks = indices;</span>
          <span class="s0">data.didHooksChange = indices !== </span><span class="s1">null </span><span class="s0">&amp;&amp; indices.length &gt; </span><span class="s4">0</span><span class="s0">;</span>
          <span class="s1">return </span><span class="s0">data;</span>
        <span class="s0">}</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">updateContextsForFiber(fiber) {</span>
    <span class="s1">switch </span><span class="s0">(getElementTypeForFiber(fiber)) {</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeClass:</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeForwardRef:</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeFunction:</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeMemo:</span>
        <span class="s1">if </span><span class="s0">(idToContextsMap !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s1">var </span><span class="s0">id = getFiberIDThrows(fiber);</span>
          <span class="s1">var </span><span class="s0">contexts = getContextsForFiber(fiber);</span>

          <span class="s1">if </span><span class="s0">(contexts !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
            <span class="s0">idToContextsMap.set(id, contexts);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Differentiates between a null context value and no context.</span>


  <span class="s1">var </span><span class="s0">NO_CONTEXT = {};</span>

  <span class="s1">function </span><span class="s0">getContextsForFiber(fiber) {</span>
    <span class="s1">var </span><span class="s0">legacyContext = NO_CONTEXT;</span>
    <span class="s1">var </span><span class="s0">modernContext = NO_CONTEXT;</span>

    <span class="s1">switch </span><span class="s0">(getElementTypeForFiber(fiber)) {</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeClass:</span>
        <span class="s1">var </span><span class="s0">instance = fiber.stateNode;</span>

        <span class="s1">if </span><span class="s0">(instance != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s1">if </span><span class="s0">(instance.constructor &amp;&amp; instance.constructor.contextType != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">modernContext = instance.context;</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">legacyContext = instance.context;</span>

            <span class="s1">if </span><span class="s0">(legacyContext &amp;&amp; Object.keys(legacyContext).length === </span><span class="s4">0</span><span class="s0">) {</span>
              <span class="s0">legacyContext = NO_CONTEXT;</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">[legacyContext, modernContext];</span>

      <span class="s1">case </span><span class="s0">types_ElementTypeForwardRef:</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeFunction:</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeMemo:</span>
        <span class="s1">var </span><span class="s0">dependencies = fiber.dependencies;</span>

        <span class="s1">if </span><span class="s0">(dependencies &amp;&amp; dependencies.firstContext) {</span>
          <span class="s0">modernContext = dependencies.firstContext;</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">[legacyContext, modernContext];</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Record all contexts at the time profiling is started.</span>
  <span class="s3">// Fibers only store the current context value,</span>
  <span class="s3">// so we need to track them separately in order to determine changed keys.</span>


  <span class="s1">function </span><span class="s0">crawlToInitializeContextsMap(fiber) {</span>
    <span class="s1">var </span><span class="s0">id = getFiberIDUnsafe(fiber); </span><span class="s3">// Not all Fibers in the subtree have mounted yet.</span>
    <span class="s3">// For example, Offscreen (hidden) or Suspense (suspended) subtrees won't yet be tracked.</span>
    <span class="s3">// We can safely skip these subtrees.</span>

    <span class="s1">if </span><span class="s0">(id !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">updateContextsForFiber(fiber);</span>
      <span class="s1">var </span><span class="s0">current = fiber.child;</span>

      <span class="s1">while </span><span class="s0">(current !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">crawlToInitializeContextsMap(current);</span>
        <span class="s0">current = current.sibling;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getContextChangedKeys(fiber) {</span>
    <span class="s1">if </span><span class="s0">(idToContextsMap !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">id = getFiberIDThrows(fiber); </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>

      <span class="s1">var </span><span class="s0">prevContexts = idToContextsMap.has(id) ? </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
      <span class="s0">idToContextsMap.get(id) : </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">nextContexts = getContextsForFiber(fiber);</span>

      <span class="s1">if </span><span class="s0">(prevContexts == </span><span class="s1">null </span><span class="s0">|| nextContexts == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">_prevContexts = renderer_slicedToArray(prevContexts, </span><span class="s4">2</span><span class="s0">),</span>
          <span class="s0">prevLegacyContext = _prevContexts[</span><span class="s4">0</span><span class="s0">],</span>
          <span class="s0">prevModernContext = _prevContexts[</span><span class="s4">1</span><span class="s0">];</span>

      <span class="s1">var </span><span class="s0">_nextContexts = renderer_slicedToArray(nextContexts, </span><span class="s4">2</span><span class="s0">),</span>
          <span class="s0">nextLegacyContext = _nextContexts[</span><span class="s4">0</span><span class="s0">],</span>
          <span class="s0">nextModernContext = _nextContexts[</span><span class="s4">1</span><span class="s0">];</span>

      <span class="s1">switch </span><span class="s0">(getElementTypeForFiber(fiber)) {</span>
        <span class="s1">case </span><span class="s0">types_ElementTypeClass:</span>
          <span class="s1">if </span><span class="s0">(prevContexts &amp;&amp; nextContexts) {</span>
            <span class="s1">if </span><span class="s0">(nextLegacyContext !== NO_CONTEXT) {</span>
              <span class="s1">return </span><span class="s0">getChangedKeys(prevLegacyContext, nextLegacyContext);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(nextModernContext !== NO_CONTEXT) {</span>
              <span class="s1">return </span><span class="s0">prevModernContext !== nextModernContext;</span>
            <span class="s0">}</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s0">types_ElementTypeForwardRef:</span>
        <span class="s1">case </span><span class="s0">types_ElementTypeFunction:</span>
        <span class="s1">case </span><span class="s0">types_ElementTypeMemo:</span>
          <span class="s1">if </span><span class="s0">(nextModernContext !== NO_CONTEXT) {</span>
            <span class="s1">var </span><span class="s0">prevContext = prevModernContext;</span>
            <span class="s1">var </span><span class="s0">nextContext = nextModernContext;</span>

            <span class="s1">while </span><span class="s0">(prevContext &amp;&amp; nextContext) {</span>
              <span class="s3">// Note this only works for versions of React that support this key (e.v. 18+)</span>
              <span class="s3">// For older versions, there's no good way to read the current context value after render has completed.</span>
              <span class="s3">// This is because React maintains a stack of context values during render,</span>
              <span class="s3">// but by the time DevTools is called, render has finished and the stack is empty.</span>
              <span class="s1">if </span><span class="s0">(!shared_objectIs(prevContext.memoizedValue, nextContext.memoizedValue)) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
              <span class="s0">}</span>

              <span class="s0">prevContext = prevContext.next;</span>
              <span class="s0">nextContext = nextContext.next;</span>
            <span class="s0">}</span>

            <span class="s1">return false</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">default</span><span class="s0">:</span>
          <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">isHookThatCanScheduleUpdate(hookObject) {</span>
    <span class="s1">var </span><span class="s0">queue = hookObject.queue;</span>

    <span class="s1">if </span><span class="s0">(!queue) {</span>
      <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">boundHasOwnProperty = shared_hasOwnProperty.bind(queue); </span><span class="s3">// Detect the shape of useState() or useReducer()</span>
    <span class="s3">// using the attributes that are unique to these hooks</span>
    <span class="s3">// but also stable (e.g. not tied to current Lanes implementation)</span>

    <span class="s1">var </span><span class="s0">isStateOrReducer = boundHasOwnProperty(</span><span class="s2">'pending'</span><span class="s0">) &amp;&amp; boundHasOwnProperty(</span><span class="s2">'dispatch'</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">queue.dispatch === </span><span class="s2">'function'</span><span class="s0">; </span><span class="s3">// Detect useSyncExternalStore()</span>

    <span class="s1">var </span><span class="s0">isSyncExternalStore = boundHasOwnProperty(</span><span class="s2">'value'</span><span class="s0">) &amp;&amp; boundHasOwnProperty(</span><span class="s2">'getSnapshot'</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">queue.getSnapshot === </span><span class="s2">'function'</span><span class="s0">; </span><span class="s3">// These are the only types of hooks that can schedule an update.</span>

    <span class="s1">return </span><span class="s0">isStateOrReducer || isSyncExternalStore;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">didStatefulHookChange(prev, next) {</span>
    <span class="s1">var </span><span class="s0">prevMemoizedState = prev.memoizedState;</span>
    <span class="s1">var </span><span class="s0">nextMemoizedState = next.memoizedState;</span>

    <span class="s1">if </span><span class="s0">(isHookThatCanScheduleUpdate(prev)) {</span>
      <span class="s1">return </span><span class="s0">prevMemoizedState !== nextMemoizedState;</span>
    <span class="s0">}</span>

    <span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getChangedHooksIndices(prev, next) {</span>
    <span class="s1">if </span><span class="s0">(prev == </span><span class="s1">null </span><span class="s0">|| next == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">indices = [];</span>
    <span class="s1">var </span><span class="s0">index = </span><span class="s4">0</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(next.hasOwnProperty(</span><span class="s2">'baseState'</span><span class="s0">) &amp;&amp; next.hasOwnProperty(</span><span class="s2">'memoizedState'</span><span class="s0">) &amp;&amp; next.hasOwnProperty(</span><span class="s2">'next'</span><span class="s0">) &amp;&amp; next.hasOwnProperty(</span><span class="s2">'queue'</span><span class="s0">)) {</span>
      <span class="s1">while </span><span class="s0">(next !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(didStatefulHookChange(prev, next)) {</span>
          <span class="s0">indices.push(index);</span>
        <span class="s0">}</span>

        <span class="s0">next = next.next;</span>
        <span class="s0">prev = prev.next;</span>
        <span class="s0">index++;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">indices;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getChangedKeys(prev, next) {</span>
    <span class="s1">if </span><span class="s0">(prev == </span><span class="s1">null </span><span class="s0">|| next == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s3">// We can't report anything meaningful for hooks changes.</span>


    <span class="s1">if </span><span class="s0">(next.hasOwnProperty(</span><span class="s2">'baseState'</span><span class="s0">) &amp;&amp; next.hasOwnProperty(</span><span class="s2">'memoizedState'</span><span class="s0">) &amp;&amp; next.hasOwnProperty(</span><span class="s2">'next'</span><span class="s0">) &amp;&amp; next.hasOwnProperty(</span><span class="s2">'queue'</span><span class="s0">)) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">keys = </span><span class="s1">new </span><span class="s0">Set([].concat(renderer_toConsumableArray(Object.keys(prev)), renderer_toConsumableArray(Object.keys(next))));</span>
    <span class="s1">var </span><span class="s0">changedKeys = []; </span><span class="s3">// eslint-disable-next-line no-for-of-loops/no-for-of-loops</span>

    <span class="s1">var </span><span class="s0">_iterator5 = _createForOfIteratorHelper(keys),</span>
        <span class="s0">_step5;</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s1">for </span><span class="s0">(_iterator5.s(); !(_step5 = _iterator5.n()).done;) {</span>
        <span class="s1">var </span><span class="s0">key = _step5.value;</span>

        <span class="s1">if </span><span class="s0">(prev[key] !== next[key]) {</span>
          <span class="s0">changedKeys.push(key);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
      <span class="s0">_iterator5.e(err);</span>
    <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
      <span class="s0">_iterator5.f();</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">changedKeys;</span>
  <span class="s0">} </span><span class="s3">// eslint-disable-next-line no-unused-vars</span>


  <span class="s1">function </span><span class="s0">didFiberRender(prevFiber, nextFiber) {</span>
    <span class="s1">switch </span><span class="s0">(nextFiber.tag) {</span>
      <span class="s1">case </span><span class="s0">ClassComponent:</span>
      <span class="s1">case </span><span class="s0">FunctionComponent:</span>
      <span class="s1">case </span><span class="s0">ContextConsumer:</span>
      <span class="s1">case </span><span class="s0">MemoComponent:</span>
      <span class="s1">case </span><span class="s0">SimpleMemoComponent:</span>
      <span class="s1">case </span><span class="s0">ForwardRef:</span>
        <span class="s3">// For types that execute user code, we check PerformedWork effect.</span>
        <span class="s3">// We don't reflect bailouts (either referential or sCU) in DevTools.</span>
        <span class="s3">// TODO: This flag is a leaked implementation detail. Once we start</span>
        <span class="s3">// releasing DevTools in lockstep with React, we should import a</span>
        <span class="s3">// function from the reconciler instead.</span>
        <span class="s1">var </span><span class="s0">PerformedWork = </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">(getFiberFlags(nextFiber) &amp; PerformedWork) === PerformedWork;</span>
      <span class="s3">// Note: ContextConsumer only gets PerformedWork effect in 16.3.3+</span>
      <span class="s3">// so it won't get highlighted with React 16.3.0 to 16.3.2.</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s3">// For host components and other types, we compare inputs</span>
        <span class="s3">// to determine whether something is an update.</span>
        <span class="s1">return </span><span class="s0">prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">pendingOperations = [];</span>
  <span class="s1">var </span><span class="s0">pendingRealUnmountedIDs = [];</span>
  <span class="s1">var </span><span class="s0">pendingSimulatedUnmountedIDs = [];</span>
  <span class="s1">var </span><span class="s0">pendingOperationsQueue = [];</span>
  <span class="s1">var </span><span class="s0">pendingStringTable = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">pendingStringTableLength = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">pendingUnmountedRootID = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">pushOperation(op) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">false</span><span class="s0">) {}</span>

    <span class="s0">pendingOperations.push(op);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">shouldBailoutWithPendingOperations() {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">if </span><span class="s0">(currentCommitProfilingMetadata != </span><span class="s1">null </span><span class="s0">&amp;&amp; currentCommitProfilingMetadata.durations.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">pendingOperations.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; pendingRealUnmountedIDs.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; pendingSimulatedUnmountedIDs.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; pendingUnmountedRootID === </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">flushOrQueueOperations(operations) {</span>
    <span class="s1">if </span><span class="s0">(shouldBailoutWithPendingOperations()) {</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(pendingOperationsQueue !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">pendingOperationsQueue.push(operations);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">hook.emit(</span><span class="s2">'operations'</span><span class="s0">, operations);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">flushPendingErrorsAndWarningsAfterDelayTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">clearPendingErrorsAndWarningsAfterDelay() {</span>
    <span class="s1">if </span><span class="s0">(flushPendingErrorsAndWarningsAfterDelayTimeoutID !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">clearTimeout(flushPendingErrorsAndWarningsAfterDelayTimeoutID);</span>
      <span class="s0">flushPendingErrorsAndWarningsAfterDelayTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">flushPendingErrorsAndWarningsAfterDelay() {</span>
    <span class="s0">clearPendingErrorsAndWarningsAfterDelay();</span>
    <span class="s0">flushPendingErrorsAndWarningsAfterDelayTimeoutID = setTimeout(</span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s0">flushPendingErrorsAndWarningsAfterDelayTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(pendingOperations.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s3">// On the off chance that something else has pushed pending operations,</span>
        <span class="s3">// we should bail on warnings; it's probably not safe to push midway.</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">recordPendingErrorsAndWarnings();</span>

      <span class="s1">if </span><span class="s0">(shouldBailoutWithPendingOperations()) {</span>
        <span class="s3">// No warnings or errors to flush; we can bail out early here too.</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s3">// We can create a smaller operations array than flushPendingEvents()</span>
      <span class="s3">// because we only need to flush warning and error counts.</span>
      <span class="s3">// Only a few pieces of fixed information are required up front.</span>


      <span class="s1">var </span><span class="s0">operations = </span><span class="s1">new </span><span class="s0">Array(</span><span class="s4">3 </span><span class="s0">+ pendingOperations.length);</span>
      <span class="s0">operations[</span><span class="s4">0</span><span class="s0">] = rendererID;</span>
      <span class="s0">operations[</span><span class="s4">1</span><span class="s0">] = currentRootID;</span>
      <span class="s0">operations[</span><span class="s4">2</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">; </span><span class="s3">// String table size</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; pendingOperations.length; j++) {</span>
        <span class="s0">operations[</span><span class="s4">3 </span><span class="s0">+ j] = pendingOperations[j];</span>
      <span class="s0">}</span>

      <span class="s0">flushOrQueueOperations(operations);</span>
      <span class="s0">pendingOperations.length = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}, </span><span class="s4">1000</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">reevaluateErrorsAndWarnings() {</span>
    <span class="s0">fibersWithChangedErrorOrWarningCounts.clear();</span>
    <span class="s0">fiberIDToErrorsMap.forEach(</span><span class="s1">function </span><span class="s0">(countMap, fiberID) {</span>
      <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(fiberID);</span>

      <span class="s1">if </span><span class="s0">(fiber != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">fibersWithChangedErrorOrWarningCounts.add(fiber);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">fiberIDToWarningsMap.forEach(</span><span class="s1">function </span><span class="s0">(countMap, fiberID) {</span>
      <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(fiberID);</span>

      <span class="s1">if </span><span class="s0">(fiber != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">fibersWithChangedErrorOrWarningCounts.add(fiber);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">recordPendingErrorsAndWarnings();</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {</span>
    <span class="s1">var </span><span class="s0">newCount = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">messageCountMap = fiberIDToMessageCountMap.get(fiberID);</span>
    <span class="s1">var </span><span class="s0">pendingMessageCountMap = pendingFiberToMessageCountMap.get(fiber);</span>

    <span class="s1">if </span><span class="s0">(pendingMessageCountMap != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(messageCountMap == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">messageCountMap = pendingMessageCountMap;</span>
        <span class="s0">fiberIDToMessageCountMap.set(fiberID, pendingMessageCountMap);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// This Flow refinement should not be necessary and yet...</span>
        <span class="s1">var </span><span class="s0">refinedMessageCountMap = messageCountMap;</span>
        <span class="s0">pendingMessageCountMap.forEach(</span><span class="s1">function </span><span class="s0">(pendingCount, message) {</span>
          <span class="s1">var </span><span class="s0">previousCount = refinedMessageCountMap.get(message) || </span><span class="s4">0</span><span class="s0">;</span>
          <span class="s0">refinedMessageCountMap.set(message, previousCount + pendingCount);</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!shouldFilterFiber(fiber)) {</span>
      <span class="s1">if </span><span class="s0">(messageCountMap != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">messageCountMap.forEach(</span><span class="s1">function </span><span class="s0">(count) {</span>
          <span class="s0">newCount += count;</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">pendingFiberToMessageCountMap.</span><span class="s1">delete</span><span class="s0">(fiber);</span>
    <span class="s1">return </span><span class="s0">newCount;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordPendingErrorsAndWarnings() {</span>
    <span class="s0">clearPendingErrorsAndWarningsAfterDelay();</span>
    <span class="s0">fibersWithChangedErrorOrWarningCounts.forEach(</span><span class="s1">function </span><span class="s0">(fiber) {</span>
      <span class="s1">var </span><span class="s0">fiberID = getFiberIDUnsafe(fiber);</span>

      <span class="s1">if </span><span class="s0">(fiberID === </span><span class="s1">null</span><span class="s0">) {</span><span class="s3">// Don't send updates for Fibers that didn't mount due to e.g. Suspense or an error boundary.</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">errorCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);</span>
        <span class="s1">var </span><span class="s0">warningCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);</span>
        <span class="s0">pushOperation(TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS);</span>
        <span class="s0">pushOperation(fiberID);</span>
        <span class="s0">pushOperation(errorCount);</span>
        <span class="s0">pushOperation(warningCount);</span>
      <span class="s0">} </span><span class="s3">// Always clean up so that we don't leak.</span>


      <span class="s0">pendingFiberToErrorsMap.</span><span class="s1">delete</span><span class="s0">(fiber);</span>
      <span class="s0">pendingFiberToWarningsMap.</span><span class="s1">delete</span><span class="s0">(fiber);</span>
    <span class="s0">});</span>
    <span class="s0">fibersWithChangedErrorOrWarningCounts.clear();</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">flushPendingEvents(root) {</span>
    <span class="s3">// Add any pending errors and warnings to the operations array.</span>
    <span class="s3">// We do this just before flushing, so we can ignore errors for no-longer-mounted Fibers.</span>
    <span class="s0">recordPendingErrorsAndWarnings();</span>

    <span class="s1">if </span><span class="s0">(shouldBailoutWithPendingOperations()) {</span>
      <span class="s3">// If we aren't profiling, we can just bail out here.</span>
      <span class="s3">// No use sending an empty update over the bridge.</span>
      <span class="s3">//</span>
      <span class="s3">// The Profiler stores metadata for each commit and reconstructs the app tree per commit using:</span>
      <span class="s3">// (1) an initial tree snapshot and</span>
      <span class="s3">// (2) the operations array for each commit</span>
      <span class="s3">// Because of this, it's important that the operations and metadata arrays align,</span>
      <span class="s3">// So it's important not to omit even empty operations while profiling is active.</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === </span><span class="s1">null </span><span class="s0">? </span><span class="s4">0 </span><span class="s0">: </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">operations = </span><span class="s1">new </span><span class="s0">Array( </span><span class="s3">// Identify which renderer this update is coming from.</span>
    <span class="s4">2 </span><span class="s0">+ </span><span class="s3">// [rendererID, rootFiberID]</span>
    <span class="s3">// How big is the string table?</span>
    <span class="s4">1 </span><span class="s0">+ </span><span class="s3">// [stringTableLength]</span>
    <span class="s3">// Then goes the actual string table.</span>
    <span class="s0">pendingStringTableLength + ( </span><span class="s3">// All unmounts are batched in a single message.</span>
    <span class="s3">// [TREE_OPERATION_REMOVE, removedIDLength, ...ids]</span>
    <span class="s0">numUnmountIDs &gt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s4">2 </span><span class="s0">+ numUnmountIDs : </span><span class="s4">0</span><span class="s0">) + </span><span class="s3">// Regular operations</span>
    <span class="s0">pendingOperations.length); </span><span class="s3">// Identify which renderer this update is coming from.</span>
    <span class="s3">// This enables roots to be mapped to renderers,</span>
    <span class="s3">// Which in turn enables fiber props, states, and hooks to be inspected.</span>

    <span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">operations[i++] = rendererID;</span>
    <span class="s0">operations[i++] = currentRootID; </span><span class="s3">// Now fill in the string table.</span>
    <span class="s3">// [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]</span>

    <span class="s0">operations[i++] = pendingStringTableLength;</span>
    <span class="s0">pendingStringTable.forEach(</span><span class="s1">function </span><span class="s0">(entry, stringKey) {</span>
      <span class="s1">var </span><span class="s0">encodedString = entry.encodedString; </span><span class="s3">// Don't use the string length.</span>
      <span class="s3">// It won't work for multibyte characters (like emoji).</span>

      <span class="s1">var </span><span class="s0">length = encodedString.length;</span>
      <span class="s0">operations[i++] = length;</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; length; j++) {</span>
        <span class="s0">operations[i + j] = encodedString[j];</span>
      <span class="s0">}</span>

      <span class="s0">i += length;</span>
    <span class="s0">});</span>

    <span class="s1">if </span><span class="s0">(numUnmountIDs &gt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s3">// All unmounts except roots are batched in a single message.</span>
      <span class="s0">operations[i++] = TREE_OPERATION_REMOVE; </span><span class="s3">// The first number is how many unmounted IDs we're gonna send.</span>

      <span class="s0">operations[i++] = numUnmountIDs; </span><span class="s3">// Fill in the real unmounts in the reverse order.</span>
      <span class="s3">// They were inserted parents-first by React, but we want children-first.</span>
      <span class="s3">// So we traverse our array backwards.</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = pendingRealUnmountedIDs.length - </span><span class="s4">1</span><span class="s0">; j &gt;= </span><span class="s4">0</span><span class="s0">; j--) {</span>
        <span class="s0">operations[i++] = pendingRealUnmountedIDs[j];</span>
      <span class="s0">} </span><span class="s3">// Fill in the simulated unmounts (hidden Suspense subtrees) in their order.</span>
      <span class="s3">// (We want children to go before parents.)</span>
      <span class="s3">// They go *after* the real unmounts because we know for sure they won't be</span>
      <span class="s3">// children of already pushed &quot;real&quot; IDs. If they were, we wouldn't be able</span>
      <span class="s3">// to discover them during the traversal, as they would have been deleted.</span>


      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_j = </span><span class="s4">0</span><span class="s0">; _j &lt; pendingSimulatedUnmountedIDs.length; _j++) {</span>
        <span class="s0">operations[i + _j] = pendingSimulatedUnmountedIDs[_j];</span>
      <span class="s0">}</span>

      <span class="s0">i += pendingSimulatedUnmountedIDs.length; </span><span class="s3">// The root ID should always be unmounted last.</span>

      <span class="s1">if </span><span class="s0">(pendingUnmountedRootID !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">operations[i] = pendingUnmountedRootID;</span>
        <span class="s0">i++;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">// Fill in the rest of the operations.</span>


    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_j2 = </span><span class="s4">0</span><span class="s0">; _j2 &lt; pendingOperations.length; _j2++) {</span>
      <span class="s0">operations[i + _j2] = pendingOperations[_j2];</span>
    <span class="s0">}</span>

    <span class="s0">i += pendingOperations.length; </span><span class="s3">// Let the frontend know about tree operations.</span>

    <span class="s0">flushOrQueueOperations(operations); </span><span class="s3">// Reset all of the pending state now that we've told the frontend about it.</span>

    <span class="s0">pendingOperations.length = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">pendingRealUnmountedIDs.length = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">pendingSimulatedUnmountedIDs.length = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">pendingUnmountedRootID = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">pendingStringTable.clear();</span>
    <span class="s0">pendingStringTableLength = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getStringID(string) {</span>
    <span class="s1">if </span><span class="s0">(string === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">existingEntry = pendingStringTable.get(string);</span>

    <span class="s1">if </span><span class="s0">(existingEntry !== undefined) {</span>
      <span class="s1">return </span><span class="s0">existingEntry.id;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">id = pendingStringTable.size + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">encodedString = utfEncodeString(string);</span>
    <span class="s0">pendingStringTable.set(string, {</span>
      <span class="s0">encodedString: encodedString,</span>
      <span class="s0">id: id</span>
    <span class="s0">}); </span><span class="s3">// The string table total length needs to account both for the string length,</span>
    <span class="s3">// and for the array item that contains the length itself.</span>
    <span class="s3">//</span>
    <span class="s3">// Don't use string length for this table.</span>
    <span class="s3">// It won't work for multibyte characters (like emoji).</span>

    <span class="s0">pendingStringTableLength += encodedString.length + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">id;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordMount(fiber, parentFiber) {</span>
    <span class="s1">var </span><span class="s0">isRoot = fiber.tag === HostRoot;</span>
    <span class="s1">var </span><span class="s0">id = getOrGenerateFiberID(fiber);</span>

    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">debug(</span><span class="s2">'recordMount()'</span><span class="s0">, fiber, parentFiber);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">hasOwnerMetadata = fiber.hasOwnProperty(</span><span class="s2">'_debugOwner'</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">isProfilingSupported = fiber.hasOwnProperty(</span><span class="s2">'treeBaseDuration'</span><span class="s0">); </span><span class="s3">// Adding a new field here would require a bridge protocol version bump (a backwads breaking change).</span>
    <span class="s3">// Instead let's re-purpose a pre-existing field to carry more information.</span>

    <span class="s1">var </span><span class="s0">profilingFlags = </span><span class="s4">0</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(isProfilingSupported) {</span>
      <span class="s0">profilingFlags = PROFILING_FLAG_BASIC_SUPPORT;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">injectProfilingHooks === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s0">profilingFlags |= PROFILING_FLAG_TIMELINE_SUPPORT;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isRoot) {</span>
      <span class="s0">pushOperation(TREE_OPERATION_ADD);</span>
      <span class="s0">pushOperation(id);</span>
      <span class="s0">pushOperation(ElementTypeRoot);</span>
      <span class="s0">pushOperation((fiber.mode &amp; StrictModeBits) !== </span><span class="s4">0 </span><span class="s0">? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>
      <span class="s0">pushOperation(profilingFlags);</span>
      <span class="s0">pushOperation(StrictModeBits !== </span><span class="s4">0 </span><span class="s0">? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>
      <span class="s0">pushOperation(hasOwnerMetadata ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(isProfiling) {</span>
        <span class="s1">if </span><span class="s0">(displayNamesByRootID !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">key = fiber.key;</span>
      <span class="s1">var </span><span class="s0">displayName = getDisplayNameForFiber(fiber);</span>
      <span class="s1">var </span><span class="s0">elementType = getElementTypeForFiber(fiber);</span>
      <span class="s1">var </span><span class="s0">_debugOwner = fiber._debugOwner; </span><span class="s3">// Ideally we should call getFiberIDThrows() for _debugOwner,</span>
      <span class="s3">// since owners are almost always higher in the tree (and so have already been processed),</span>
      <span class="s3">// but in some (rare) instances reported in open source, a descendant mounts before an owner.</span>
      <span class="s3">// Since this is a DEV only field it's probably okay to also just lazily generate and ID here if needed.</span>
      <span class="s3">// See https://github.com/facebook/react/issues/21445</span>

      <span class="s1">var </span><span class="s0">ownerID = _debugOwner != </span><span class="s1">null </span><span class="s0">? getOrGenerateFiberID(_debugOwner) : </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">parentID = parentFiber ? getFiberIDThrows(parentFiber) : </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">displayNameStringID = getStringID(displayName); </span><span class="s3">// This check is a guard to handle a React element that has been modified</span>
      <span class="s3">// in such a way as to bypass the default stringification of the &quot;key&quot; property.</span>

      <span class="s1">var </span><span class="s0">keyString = key === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: String(key);</span>
      <span class="s1">var </span><span class="s0">keyStringID = getStringID(keyString);</span>
      <span class="s0">pushOperation(TREE_OPERATION_ADD);</span>
      <span class="s0">pushOperation(id);</span>
      <span class="s0">pushOperation(elementType);</span>
      <span class="s0">pushOperation(parentID);</span>
      <span class="s0">pushOperation(ownerID);</span>
      <span class="s0">pushOperation(displayNameStringID);</span>
      <span class="s0">pushOperation(keyStringID); </span><span class="s3">// If this subtree has a new mode, let the frontend know.</span>

      <span class="s1">if </span><span class="s0">((fiber.mode &amp; StrictModeBits) !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; (parentFiber.mode &amp; StrictModeBits) === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">pushOperation(TREE_OPERATION_SET_SUBTREE_MODE);</span>
        <span class="s0">pushOperation(id);</span>
        <span class="s0">pushOperation(StrictMode);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isProfilingSupported) {</span>
      <span class="s0">idToRootMap.set(id, currentRootID);</span>
      <span class="s0">recordProfilingDurations(fiber);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordUnmount(fiber, isSimulated) {</span>
    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">debug(</span><span class="s2">'recordUnmount()'</span><span class="s0">, fiber, </span><span class="s1">null</span><span class="s0">, isSimulated ? </span><span class="s2">'unmount is simulated' </span><span class="s0">: </span><span class="s2">''</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(trackedPathMatchFiber !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// We're in the process of trying to restore previous selection.</span>
      <span class="s3">// If this fiber matched but is being unmounted, there's no use trying.</span>
      <span class="s3">// Reset the state so we don't keep holding onto it.</span>
      <span class="s1">if </span><span class="s0">(fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {</span>
        <span class="s0">setTrackedPath(</span><span class="s1">null</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">unsafeID = getFiberIDUnsafe(fiber);</span>

    <span class="s1">if </span><span class="s0">(unsafeID === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// If we've never seen this Fiber, it might be inside of a legacy render Suspense fragment (so the store is not even aware of it).</span>
      <span class="s3">// In that case we can just ignore it or it will cause errors later on.</span>
      <span class="s3">// One example of this is a Lazy component that never resolves before being unmounted.</span>
      <span class="s3">//</span>
      <span class="s3">// This also might indicate a Fast Refresh force-remount scenario.</span>
      <span class="s3">//</span>
      <span class="s3">// TODO: This is fragile and can obscure actual bugs.</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s3">// Flow refinement.</span>


    <span class="s1">var </span><span class="s0">id = unsafeID;</span>
    <span class="s1">var </span><span class="s0">isRoot = fiber.tag === HostRoot;</span>

    <span class="s1">if </span><span class="s0">(isRoot) {</span>
      <span class="s3">// Roots must be removed only after all children (pending and simulated) have been removed.</span>
      <span class="s3">// So we track it separately.</span>
      <span class="s0">pendingUnmountedRootID = id;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!shouldFilterFiber(fiber)) {</span>
      <span class="s3">// To maintain child-first ordering,</span>
      <span class="s3">// we'll push it into one of these queues,</span>
      <span class="s3">// and later arrange them in the correct order.</span>
      <span class="s1">if </span><span class="s0">(isSimulated) {</span>
        <span class="s0">pendingSimulatedUnmountedIDs.push(id);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">pendingRealUnmountedIDs.push(id);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!fiber._debugNeedsRemount) {</span>
      <span class="s0">untrackFiberID(fiber);</span>
      <span class="s1">var </span><span class="s0">isProfilingSupported = fiber.hasOwnProperty(</span><span class="s2">'treeBaseDuration'</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(isProfilingSupported) {</span>
        <span class="s0">idToRootMap.</span><span class="s1">delete</span><span class="s0">(id);</span>
        <span class="s0">idToTreeBaseDurationMap.</span><span class="s1">delete</span><span class="s0">(id);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">mountFiberRecursively(firstChild, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {</span>
    <span class="s3">// Iterate over siblings rather than recursing.</span>
    <span class="s3">// This reduces the chance of stack overflow for wide trees (e.g. lists with many items).</span>
    <span class="s1">var </span><span class="s0">fiber = firstChild;</span>

    <span class="s1">while </span><span class="s0">(fiber !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Generate an ID even for filtered Fibers, in case it's needed later (e.g. for Profiling).</span>
      <span class="s0">getOrGenerateFiberID(fiber);</span>

      <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
        <span class="s0">debug(</span><span class="s2">'mountFiberRecursively()'</span><span class="s0">, fiber, parentFiber);</span>
      <span class="s0">} </span><span class="s3">// If we have the tree selection from previous reload, try to match this Fiber.</span>
      <span class="s3">// Also remember whether to do the same for siblings.</span>


      <span class="s1">var </span><span class="s0">mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);</span>
      <span class="s1">var </span><span class="s0">shouldIncludeInTree = !shouldFilterFiber(fiber);</span>

      <span class="s1">if </span><span class="s0">(shouldIncludeInTree) {</span>
        <span class="s0">recordMount(fiber, parentFiber);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(traceUpdatesEnabled) {</span>
        <span class="s1">if </span><span class="s0">(traceNearestHostComponentUpdate) {</span>
          <span class="s1">var </span><span class="s0">elementType = getElementTypeForFiber(fiber); </span><span class="s3">// If an ancestor updated, we should mark the nearest host nodes for highlighting.</span>

          <span class="s1">if </span><span class="s0">(elementType === ElementTypeHostComponent) {</span>
            <span class="s0">traceUpdatesForNodes.add(fiber.stateNode);</span>
            <span class="s0">traceNearestHostComponentUpdate = </span><span class="s1">false</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s3">// We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,</span>
        <span class="s3">// because we don't want to highlight every host node inside of a newly mounted subtree.</span>

      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;</span>

      <span class="s1">if </span><span class="s0">(isSuspense) {</span>
        <span class="s1">var </span><span class="s0">isTimedOut = fiber.memoizedState !== </span><span class="s1">null</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(isTimedOut) {</span>
          <span class="s3">// Special case: if Suspense mounts in a timed-out state,</span>
          <span class="s3">// get the fallback child from the inner fragment and mount</span>
          <span class="s3">// it as if it was our own child. Updates handle this too.</span>
          <span class="s1">var </span><span class="s0">primaryChildFragment = fiber.child;</span>
          <span class="s1">var </span><span class="s0">fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s1">var </span><span class="s0">fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : </span><span class="s1">null</span><span class="s0">;</span>

          <span class="s1">if </span><span class="s0">(fallbackChild !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, </span><span class="s1">true</span><span class="s0">, traceNearestHostComponentUpdate);</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">var </span><span class="s0">primaryChild = </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s1">var </span><span class="s0">areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -</span><span class="s4">1</span><span class="s0">;</span>

          <span class="s1">if </span><span class="s0">(areSuspenseChildrenConditionallyWrapped) {</span>
            <span class="s0">primaryChild = fiber.child;</span>
          <span class="s0">} </span><span class="s1">else if </span><span class="s0">(fiber.child !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">primaryChild = fiber.child.child;</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(primaryChild !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, </span><span class="s1">true</span><span class="s0">, traceNearestHostComponentUpdate);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">if </span><span class="s0">(fiber.child !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, </span><span class="s1">true</span><span class="s0">, traceNearestHostComponentUpdate);</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s3">// We're exiting this Fiber now, and entering its siblings.</span>
      <span class="s3">// If we have selection to restore, we might need to re-activate tracking.</span>


      <span class="s0">updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);</span>
      <span class="s0">fiber = traverseSiblings ? fiber.sibling : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// We use this to simulate unmounting for Suspense trees</span>
  <span class="s3">// when we switch from primary to fallback.</span>


  <span class="s1">function </span><span class="s0">unmountFiberChildrenRecursively(fiber) {</span>
    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">debug(</span><span class="s2">'unmountFiberChildrenRecursively()'</span><span class="s0">, fiber);</span>
    <span class="s0">} </span><span class="s3">// We might meet a nested Suspense on our way.</span>


    <span class="s1">var </span><span class="s0">isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent &amp;&amp; fiber.memoizedState !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">child = fiber.child;</span>

    <span class="s1">if </span><span class="s0">(isTimedOutSuspense) {</span>
      <span class="s3">// If it's showing fallback tree, let's traverse it instead.</span>
      <span class="s1">var </span><span class="s0">primaryChildFragment = fiber.child;</span>
      <span class="s1">var </span><span class="s0">fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// Skip over to the real Fiber child.</span>

      <span class="s0">child = fallbackChildFragment ? fallbackChildFragment.child : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">while </span><span class="s0">(child !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Record simulated unmounts children-first.</span>
      <span class="s3">// We skip nodes without return because those are real unmounts.</span>
      <span class="s1">if </span><span class="s0">(child.</span><span class="s1">return </span><span class="s0">!== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">unmountFiberChildrenRecursively(child);</span>
        <span class="s0">recordUnmount(child, </span><span class="s1">true</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s0">child = child.sibling;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordProfilingDurations(fiber) {</span>
    <span class="s1">var </span><span class="s0">id = getFiberIDThrows(fiber);</span>
    <span class="s1">var </span><span class="s0">actualDuration = fiber.actualDuration,</span>
        <span class="s0">treeBaseDuration = fiber.treeBaseDuration;</span>
    <span class="s0">idToTreeBaseDurationMap.set(id, treeBaseDuration || </span><span class="s4">0</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">var </span><span class="s0">alternate = fiber.alternate; </span><span class="s3">// It's important to update treeBaseDuration even if the current Fiber did not render,</span>
      <span class="s3">// because it's possible that one of its descendants did.</span>

      <span class="s1">if </span><span class="s0">(alternate == </span><span class="s1">null </span><span class="s0">|| treeBaseDuration !== alternate.treeBaseDuration) {</span>
        <span class="s3">// Tree base duration updates are included in the operations typed array.</span>
        <span class="s3">// So we have to convert them from milliseconds to microseconds so we can send them as ints.</span>
        <span class="s1">var </span><span class="s0">convertedTreeBaseDuration = Math.floor((treeBaseDuration || </span><span class="s4">0</span><span class="s0">) * </span><span class="s4">1000</span><span class="s0">);</span>
        <span class="s0">pushOperation(TREE_OPERATION_UPDATE_TREE_BASE_DURATION);</span>
        <span class="s0">pushOperation(id);</span>
        <span class="s0">pushOperation(convertedTreeBaseDuration);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(alternate == </span><span class="s1">null </span><span class="s0">|| didFiberRender(alternate, fiber)) {</span>
        <span class="s1">if </span><span class="s0">(actualDuration != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s3">// The actual duration reported by React includes time spent working on children.</span>
          <span class="s3">// This is useful information, but it's also useful to be able to exclude child durations.</span>
          <span class="s3">// The frontend can't compute this, since the immediate children may have been filtered out.</span>
          <span class="s3">// So we need to do this on the backend.</span>
          <span class="s3">// Note that this calculated self duration is not the same thing as the base duration.</span>
          <span class="s3">// The two are calculated differently (tree duration does not accumulate).</span>
          <span class="s1">var </span><span class="s0">selfDuration = actualDuration;</span>
          <span class="s1">var </span><span class="s0">child = fiber.child;</span>

          <span class="s1">while </span><span class="s0">(child !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">selfDuration -= child.actualDuration || </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">child = child.sibling;</span>
          <span class="s0">} </span><span class="s3">// If profiling is active, store durations for elements that were rendered during the commit.</span>
          <span class="s3">// Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.</span>
          <span class="s3">// In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)</span>
          <span class="s3">// In other cases (e.g. Memo) actualDuration might be greater than 0 even if we &quot;bailed out&quot;.</span>


          <span class="s1">var </span><span class="s0">metadata = currentCommitProfilingMetadata;</span>
          <span class="s0">metadata.durations.push(id, actualDuration, selfDuration);</span>
          <span class="s0">metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);</span>

          <span class="s1">if </span><span class="s0">(recordChangeDescriptions) {</span>
            <span class="s1">var </span><span class="s0">changeDescription = getChangeDescription(alternate, fiber);</span>

            <span class="s1">if </span><span class="s0">(changeDescription !== </span><span class="s1">null</span><span class="s0">) {</span>
              <span class="s1">if </span><span class="s0">(metadata.changeDescriptions !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">metadata.changeDescriptions.set(id, changeDescription);</span>
              <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s0">updateContextsForFiber(fiber);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordResetChildren(fiber, childSet) {</span>
    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">debug(</span><span class="s2">'recordResetChildren()'</span><span class="s0">, childSet, fiber);</span>
    <span class="s0">} </span><span class="s3">// The frontend only really cares about the displayName, key, and children.</span>
    <span class="s3">// The first two don't really change, so we are only concerned with the order of children here.</span>
    <span class="s3">// This is trickier than a simple comparison though, since certain types of fibers are filtered.</span>


    <span class="s1">var </span><span class="s0">nextChildren = []; </span><span class="s3">// This is a naive implementation that shallowly recourses children.</span>
    <span class="s3">// We might want to revisit this if it proves to be too inefficient.</span>

    <span class="s1">var </span><span class="s0">child = childSet;</span>

    <span class="s1">while </span><span class="s0">(child !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">findReorderedChildrenRecursively(child, nextChildren);</span>
      <span class="s0">child = child.sibling;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">numChildren = nextChildren.length;</span>

    <span class="s1">if </span><span class="s0">(numChildren &lt; </span><span class="s4">2</span><span class="s0">) {</span>
      <span class="s3">// No need to reorder.</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">pushOperation(TREE_OPERATION_REORDER_CHILDREN);</span>
    <span class="s0">pushOperation(getFiberIDThrows(fiber));</span>
    <span class="s0">pushOperation(numChildren);</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; nextChildren.length; i++) {</span>
      <span class="s0">pushOperation(nextChildren[i]);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">findReorderedChildrenRecursively(fiber, nextChildren) {</span>
    <span class="s1">if </span><span class="s0">(!shouldFilterFiber(fiber)) {</span>
      <span class="s0">nextChildren.push(getFiberIDThrows(fiber));</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">child = fiber.child;</span>
      <span class="s1">var </span><span class="s0">isTimedOutSuspense = fiber.tag === SuspenseComponent &amp;&amp; fiber.memoizedState !== </span><span class="s1">null</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(isTimedOutSuspense) {</span>
        <span class="s3">// Special case: if Suspense mounts in a timed-out state,</span>
        <span class="s3">// get the fallback child from the inner fragment,</span>
        <span class="s3">// and skip over the primary child.</span>
        <span class="s1">var </span><span class="s0">primaryChildFragment = fiber.child;</span>
        <span class="s1">var </span><span class="s0">fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : </span><span class="s1">null</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(fallbackChild !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">child = fallbackChild;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">while </span><span class="s0">(child !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">findReorderedChildrenRecursively(child, nextChildren);</span>
        <span class="s0">child = child.sibling;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Returns whether closest unfiltered fiber parent needs to reset its child list.</span>


  <span class="s1">function </span><span class="s0">updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {</span>
    <span class="s1">var </span><span class="s0">id = getOrGenerateFiberID(nextFiber);</span>

    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">debug(</span><span class="s2">'updateFiberRecursively()'</span><span class="s0">, nextFiber, parentFiber);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(traceUpdatesEnabled) {</span>
      <span class="s1">var </span><span class="s0">elementType = getElementTypeForFiber(nextFiber);</span>

      <span class="s1">if </span><span class="s0">(traceNearestHostComponentUpdate) {</span>
        <span class="s3">// If an ancestor updated, we should mark the nearest host nodes for highlighting.</span>
        <span class="s1">if </span><span class="s0">(elementType === ElementTypeHostComponent) {</span>
          <span class="s0">traceUpdatesForNodes.add(nextFiber.stateNode);</span>
          <span class="s0">traceNearestHostComponentUpdate = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">if </span><span class="s0">(elementType === types_ElementTypeFunction || elementType === types_ElementTypeClass || elementType === ElementTypeContext || elementType === types_ElementTypeMemo || elementType === types_ElementTypeForwardRef) {</span>
          <span class="s3">// Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).</span>
          <span class="s0">traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(mostRecentlyInspectedElement !== </span><span class="s1">null </span><span class="s0">&amp;&amp; mostRecentlyInspectedElement.id === id &amp;&amp; didFiberRender(prevFiber, nextFiber)) {</span>
      <span class="s3">// If this Fiber has updated, clear cached inspected data.</span>
      <span class="s3">// If it is inspected again, it may need to be re-run to obtain updated hooks values.</span>
      <span class="s0">hasElementUpdatedSinceLastInspected = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">shouldIncludeInTree = !shouldFilterFiber(nextFiber);</span>
    <span class="s1">var </span><span class="s0">isSuspense = nextFiber.tag === SuspenseComponent;</span>
    <span class="s1">var </span><span class="s0">shouldResetChildren = </span><span class="s1">false</span><span class="s0">; </span><span class="s3">// The behavior of timed-out Suspense trees is unique.</span>
    <span class="s3">// Rather than unmount the timed out content (and possibly lose important state),</span>
    <span class="s3">// React re-parents this content within a hidden Fragment while the fallback is showing.</span>
    <span class="s3">// This behavior doesn't need to be observable in the DevTools though.</span>
    <span class="s3">// It might even result in a bad user experience for e.g. node selection in the Elements panel.</span>
    <span class="s3">// The easiest fix is to strip out the intermediate Fragment fibers,</span>
    <span class="s3">// so the Elements panel and Profiler don't need to special case them.</span>
    <span class="s3">// Suspense components only have a non-null memoizedState if they're timed-out.</span>

    <span class="s1">var </span><span class="s0">prevDidTimeout = isSuspense &amp;&amp; prevFiber.memoizedState !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">nextDidTimeOut = isSuspense &amp;&amp; nextFiber.memoizedState !== </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// The logic below is inspired by the code paths in updateSuspenseComponent()</span>
    <span class="s3">// inside ReactFiberBeginWork in the React source code.</span>

    <span class="s1">if </span><span class="s0">(prevDidTimeout &amp;&amp; nextDidTimeOut) {</span>
      <span class="s3">// Fallback -&gt; Fallback:</span>
      <span class="s3">// 1. Reconcile fallback set.</span>
      <span class="s1">var </span><span class="s0">nextFiberChild = nextFiber.child;</span>
      <span class="s1">var </span><span class="s0">nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// Note: We can't use nextFiber.child.sibling.alternate</span>
      <span class="s3">// because the set is special and alternate may not exist.</span>

      <span class="s1">var </span><span class="s0">prevFiberChild = prevFiber.child;</span>
      <span class="s1">var </span><span class="s0">prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : </span><span class="s1">null</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(nextFallbackChildSet != </span><span class="s1">null </span><span class="s0">&amp;&amp; prevFallbackChildSet != </span><span class="s1">null </span><span class="s0">&amp;&amp; updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {</span>
        <span class="s0">shouldResetChildren = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prevDidTimeout &amp;&amp; !nextDidTimeOut) {</span>
      <span class="s3">// Fallback -&gt; Primary:</span>
      <span class="s3">// 1. Unmount fallback set</span>
      <span class="s3">// Note: don't emulate fallback unmount because React actually did it.</span>
      <span class="s3">// 2. Mount primary set</span>
      <span class="s1">var </span><span class="s0">nextPrimaryChildSet = nextFiber.child;</span>

      <span class="s1">if </span><span class="s0">(nextPrimaryChildSet !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, </span><span class="s1">true</span><span class="s0">, traceNearestHostComponentUpdate);</span>
      <span class="s0">}</span>

      <span class="s0">shouldResetChildren = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!prevDidTimeout &amp;&amp; nextDidTimeOut) {</span>
      <span class="s3">// Primary -&gt; Fallback:</span>
      <span class="s3">// 1. Hide primary set</span>
      <span class="s3">// This is not a real unmount, so it won't get reported by React.</span>
      <span class="s3">// We need to manually walk the previous tree and record unmounts.</span>
      <span class="s0">unmountFiberChildrenRecursively(prevFiber); </span><span class="s3">// 2. Mount fallback set</span>

      <span class="s1">var </span><span class="s0">_nextFiberChild = nextFiber.child;</span>

      <span class="s1">var </span><span class="s0">_nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : </span><span class="s1">null</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(_nextFallbackChildSet != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">mountFiberRecursively(_nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, </span><span class="s1">true</span><span class="s0">, traceNearestHostComponentUpdate);</span>
        <span class="s0">shouldResetChildren = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s3">// Common case: Primary -&gt; Primary.</span>
      <span class="s3">// This is the same code path as for non-Suspense fibers.</span>
      <span class="s1">if </span><span class="s0">(nextFiber.child !== prevFiber.child) {</span>
        <span class="s3">// If the first child is different, we need to traverse them.</span>
        <span class="s3">// Each next child will be either a new child (mount) or an alternate (update).</span>
        <span class="s1">var </span><span class="s0">nextChild = nextFiber.child;</span>
        <span class="s1">var </span><span class="s0">prevChildAtSameIndex = prevFiber.child;</span>

        <span class="s1">while </span><span class="s0">(nextChild) {</span>
          <span class="s3">// We already know children will be referentially different because</span>
          <span class="s3">// they are either new mounts or alternates of previous children.</span>
          <span class="s3">// Schedule updates and mounts depending on whether alternates exist.</span>
          <span class="s3">// We don't track deletions here because they are reported separately.</span>
          <span class="s1">if </span><span class="s0">(nextChild.alternate) {</span>
            <span class="s1">var </span><span class="s0">prevChild = nextChild.alternate;</span>

            <span class="s1">if </span><span class="s0">(updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {</span>
              <span class="s3">// If a nested tree child order changed but it can't handle its own</span>
              <span class="s3">// child order invalidation (e.g. because it's filtered out like host nodes),</span>
              <span class="s3">// propagate the need to reset child order upwards to this Fiber.</span>
              <span class="s0">shouldResetChildren = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s3">// However we also keep track if the order of the children matches</span>
            <span class="s3">// the previous order. They are always different referentially, but</span>
            <span class="s3">// if the instances line up conceptually we'll want to know that.</span>


            <span class="s1">if </span><span class="s0">(prevChild !== prevChildAtSameIndex) {</span>
              <span class="s0">shouldResetChildren = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, </span><span class="s1">false</span><span class="s0">, traceNearestHostComponentUpdate);</span>
            <span class="s0">shouldResetChildren = </span><span class="s1">true</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s3">// Try the next child.</span>


          <span class="s0">nextChild = nextChild.sibling; </span><span class="s3">// Advance the pointer in the previous list so that we can</span>
          <span class="s3">// keep comparing if they line up.</span>

          <span class="s1">if </span><span class="s0">(!shouldResetChildren &amp;&amp; prevChildAtSameIndex !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">prevChildAtSameIndex = prevChildAtSameIndex.sibling;</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s3">// If we have no more children, but used to, they don't line up.</span>


        <span class="s1">if </span><span class="s0">(prevChildAtSameIndex !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">shouldResetChildren = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">if </span><span class="s0">(traceUpdatesEnabled) {</span>
          <span class="s3">// If we're tracing updates and we've bailed out before reaching a host node,</span>
          <span class="s3">// we should fall back to recursively marking the nearest host descendants for highlight.</span>
          <span class="s1">if </span><span class="s0">(traceNearestHostComponentUpdate) {</span>
            <span class="s1">var </span><span class="s0">hostFibers = findAllCurrentHostFibers(getFiberIDThrows(nextFiber));</span>
            <span class="s0">hostFibers.forEach(</span><span class="s1">function </span><span class="s0">(hostFiber) {</span>
              <span class="s0">traceUpdatesForNodes.add(hostFiber.stateNode);</span>
            <span class="s0">});</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(shouldIncludeInTree) {</span>
      <span class="s1">var </span><span class="s0">isProfilingSupported = nextFiber.hasOwnProperty(</span><span class="s2">'treeBaseDuration'</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(isProfilingSupported) {</span>
        <span class="s0">recordProfilingDurations(nextFiber);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(shouldResetChildren) {</span>
      <span class="s3">// We need to crawl the subtree for closest non-filtered Fibers</span>
      <span class="s3">// so that we can display them in a flat children set.</span>
      <span class="s1">if </span><span class="s0">(shouldIncludeInTree) {</span>
        <span class="s3">// Normally, search for children from the rendered child.</span>
        <span class="s1">var </span><span class="s0">nextChildSet = nextFiber.child;</span>

        <span class="s1">if </span><span class="s0">(nextDidTimeOut) {</span>
          <span class="s3">// Special case: timed-out Suspense renders the fallback set.</span>
          <span class="s1">var </span><span class="s0">_nextFiberChild2 = nextFiber.child;</span>
          <span class="s0">nextChildSet = _nextFiberChild2 ? _nextFiberChild2.sibling : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(nextChildSet != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">recordResetChildren(nextFiber, nextChildSet);</span>
        <span class="s0">} </span><span class="s3">// We've handled the child order change for this Fiber.</span>
        <span class="s3">// Since it's included, there's no need to invalidate parent child order.</span>


        <span class="s1">return false</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// Let the closest unfiltered parent Fiber reset its child order instead.</span>
        <span class="s1">return true</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">cleanup() {</span><span class="s3">// We don't patch any methods so there is no cleanup.</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">rootSupportsProfiling(root) {</span>
    <span class="s1">if </span><span class="s0">(root.memoizedInteractions != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// v16 builds include this field for the scheduler/tracing API.</span>
      <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(root.current != </span><span class="s1">null </span><span class="s0">&amp;&amp; root.current.hasOwnProperty(</span><span class="s2">'treeBaseDuration'</span><span class="s0">)) {</span>
      <span class="s3">// The scheduler/tracing API was removed in v17 though</span>
      <span class="s3">// so we need to check a non-root Fiber.</span>
      <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">flushInitialOperations() {</span>
    <span class="s1">var </span><span class="s0">localPendingOperationsQueue = pendingOperationsQueue;</span>
    <span class="s0">pendingOperationsQueue = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(localPendingOperationsQueue !== </span><span class="s1">null </span><span class="s0">&amp;&amp; localPendingOperationsQueue.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s3">// We may have already queued up some operations before the frontend connected</span>
      <span class="s3">// If so, let the frontend know about them.</span>
      <span class="s0">localPendingOperationsQueue.forEach(</span><span class="s1">function </span><span class="s0">(operations) {</span>
        <span class="s0">hook.emit(</span><span class="s2">'operations'</span><span class="s0">, operations);</span>
      <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s3">// Before the traversals, remember to start tracking</span>
      <span class="s3">// our path in case we have selection to restore.</span>
      <span class="s1">if </span><span class="s0">(trackedPath !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">mightBeOnTrackedPath = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s3">// If we have not been profiling, then we can just walk the tree and build up its current state as-is.</span>


      <span class="s0">hook.getFiberRoots(rendererID).forEach(</span><span class="s1">function </span><span class="s0">(root) {</span>
        <span class="s0">currentRootID = getOrGenerateFiberID(root.current);</span>
        <span class="s0">setRootPseudoKey(currentRootID, root.current); </span><span class="s3">// Handle multi-renderer edge-case where only some v16 renderers support profiling.</span>

        <span class="s1">if </span><span class="s0">(isProfiling &amp;&amp; rootSupportsProfiling(root)) {</span>
          <span class="s3">// If profiling is active, store commit time and duration.</span>
          <span class="s3">// The frontend may request this information after profiling has stopped.</span>
          <span class="s0">currentCommitProfilingMetadata = {</span>
            <span class="s0">changeDescriptions: recordChangeDescriptions ? </span><span class="s1">new </span><span class="s0">Map() : </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">durations: [],</span>
            <span class="s0">commitTime: renderer_getCurrentTime() - profilingStartTime,</span>
            <span class="s0">maxActualDuration: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">priorityLevel: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">updaters: getUpdatersList(root),</span>
            <span class="s0">effectDuration: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">passiveEffectDuration: </span><span class="s1">null</span>
          <span class="s0">};</span>
        <span class="s0">}</span>

        <span class="s0">mountFiberRecursively(root.current, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">flushPendingEvents(root);</span>
        <span class="s0">currentRootID = -</span><span class="s4">1</span><span class="s0">;</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getUpdatersList(root) {</span>
    <span class="s1">return </span><span class="s0">root.memoizedUpdaters != </span><span class="s1">null </span><span class="s0">? Array.from(root.memoizedUpdaters).filter(</span><span class="s1">function </span><span class="s0">(fiber) {</span>
      <span class="s1">return </span><span class="s0">getFiberIDUnsafe(fiber) !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}).map(fiberToSerializedElement) : </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">handleCommitFiberUnmount(fiber) {</span>
    <span class="s3">// If the untrackFiberSet already has the unmounted Fiber, this means we've already</span>
    <span class="s3">// recordedUnmount, so we don't need to do it again. If we don't do this, we might</span>
    <span class="s3">// end up double-deleting Fibers in some cases (like Legacy Suspense).</span>
    <span class="s1">if </span><span class="s0">(!untrackFibersSet.has(fiber)) {</span>
      <span class="s3">// This is not recursive.</span>
      <span class="s3">// We can't traverse fibers after unmounting so instead</span>
      <span class="s3">// we rely on React telling us about each unmount.</span>
      <span class="s0">recordUnmount(fiber, </span><span class="s1">false</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">handlePostCommitFiberRoot(root) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling &amp;&amp; rootSupportsProfiling(root)) {</span>
      <span class="s1">if </span><span class="s0">(currentCommitProfilingMetadata !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">_getEffectDurations = getEffectDurations(root),</span>
            <span class="s0">effectDuration = _getEffectDurations.effectDuration,</span>
            <span class="s0">passiveEffectDuration = _getEffectDurations.passiveEffectDuration; </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>


        <span class="s0">currentCommitProfilingMetadata.effectDuration = effectDuration; </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>

        <span class="s0">currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">handleCommitFiberRoot(root, priorityLevel) {</span>
    <span class="s1">var </span><span class="s0">current = root.current;</span>
    <span class="s1">var </span><span class="s0">alternate = current.alternate; </span><span class="s3">// Flush any pending Fibers that we are untracking before processing the new commit.</span>
    <span class="s3">// If we don't do this, we might end up double-deleting Fibers in some cases (like Legacy Suspense).</span>

    <span class="s0">untrackFibers();</span>
    <span class="s0">currentRootID = getOrGenerateFiberID(current); </span><span class="s3">// Before the traversals, remember to start tracking</span>
    <span class="s3">// our path in case we have selection to restore.</span>

    <span class="s1">if </span><span class="s0">(trackedPath !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">mightBeOnTrackedPath = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(traceUpdatesEnabled) {</span>
      <span class="s0">traceUpdatesForNodes.clear();</span>
    <span class="s0">} </span><span class="s3">// Handle multi-renderer edge-case where only some v16 renderers support profiling.</span>


    <span class="s1">var </span><span class="s0">isProfilingSupported = rootSupportsProfiling(root);</span>

    <span class="s1">if </span><span class="s0">(isProfiling &amp;&amp; isProfilingSupported) {</span>
      <span class="s3">// If profiling is active, store commit time and duration.</span>
      <span class="s3">// The frontend may request this information after profiling has stopped.</span>
      <span class="s0">currentCommitProfilingMetadata = {</span>
        <span class="s0">changeDescriptions: recordChangeDescriptions ? </span><span class="s1">new </span><span class="s0">Map() : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">durations: [],</span>
        <span class="s0">commitTime: renderer_getCurrentTime() - profilingStartTime,</span>
        <span class="s0">maxActualDuration: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">priorityLevel: priorityLevel == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: formatPriorityLevel(priorityLevel),</span>
        <span class="s0">updaters: getUpdatersList(root),</span>
        <span class="s3">// Initialize to null; if new enough React version is running,</span>
        <span class="s3">// these values will be read during separate handlePostCommitFiberRoot() call.</span>
        <span class="s0">effectDuration: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">passiveEffectDuration: </span><span class="s1">null</span>
      <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(alternate) {</span>
      <span class="s3">// TODO: relying on this seems a bit fishy.</span>
      <span class="s1">var </span><span class="s0">wasMounted = alternate.memoizedState != </span><span class="s1">null </span><span class="s0">&amp;&amp; alternate.memoizedState.element != </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s3">// A dehydrated root is not considered mounted</span>
      <span class="s0">alternate.memoizedState.isDehydrated !== </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">isMounted = current.memoizedState != </span><span class="s1">null </span><span class="s0">&amp;&amp; current.memoizedState.element != </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s3">// A dehydrated root is not considered mounted</span>
      <span class="s0">current.memoizedState.isDehydrated !== </span><span class="s1">true</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(!wasMounted &amp;&amp; isMounted) {</span>
        <span class="s3">// Mount a new root.</span>
        <span class="s0">setRootPseudoKey(currentRootID, current);</span>
        <span class="s0">mountFiberRecursively(current, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(wasMounted &amp;&amp; isMounted) {</span>
        <span class="s3">// Update an existing root.</span>
        <span class="s0">updateFiberRecursively(current, alternate, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(wasMounted &amp;&amp; !isMounted) {</span>
        <span class="s3">// Unmount an existing root.</span>
        <span class="s0">removeRootPseudoKey(currentRootID);</span>
        <span class="s0">recordUnmount(current, </span><span class="s1">false</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s3">// Mount a new root.</span>
      <span class="s0">setRootPseudoKey(currentRootID, current);</span>
      <span class="s0">mountFiberRecursively(current, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isProfiling &amp;&amp; isProfilingSupported) {</span>
      <span class="s1">if </span><span class="s0">(!shouldBailoutWithPendingOperations()) {</span>
        <span class="s1">var </span><span class="s0">commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);</span>

        <span class="s1">if </span><span class="s0">(commitProfilingMetadata != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">commitProfilingMetadata.push(currentCommitProfilingMetadata);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s0">rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">// We're done here.</span>


    <span class="s0">flushPendingEvents(root);</span>

    <span class="s1">if </span><span class="s0">(traceUpdatesEnabled) {</span>
      <span class="s0">hook.emit(</span><span class="s2">'traceUpdates'</span><span class="s0">, traceUpdatesForNodes);</span>
    <span class="s0">}</span>

    <span class="s0">currentRootID = -</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">findAllCurrentHostFibers(id) {</span>
    <span class="s1">var </span><span class="s0">fibers = [];</span>
    <span class="s1">var </span><span class="s0">fiber = findCurrentFiberUsingSlowPathById(id);</span>

    <span class="s1">if </span><span class="s0">(!fiber) {</span>
      <span class="s1">return </span><span class="s0">fibers;</span>
    <span class="s0">} </span><span class="s3">// Next we'll drill down this component to find all HostComponent/Text.</span>


    <span class="s1">var </span><span class="s0">node = fiber;</span>

    <span class="s1">while </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(node.tag === HostComponent || node.tag === HostText) {</span>
        <span class="s0">fibers.push(node);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node.child) {</span>
        <span class="s0">node.child.</span><span class="s1">return </span><span class="s0">= node;</span>
        <span class="s0">node = node.child;</span>
        <span class="s1">continue</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(node === fiber) {</span>
        <span class="s1">return </span><span class="s0">fibers;</span>
      <span class="s0">}</span>

      <span class="s1">while </span><span class="s0">(!node.sibling) {</span>
        <span class="s1">if </span><span class="s0">(!node.</span><span class="s1">return </span><span class="s0">|| node.</span><span class="s1">return </span><span class="s0">=== fiber) {</span>
          <span class="s1">return </span><span class="s0">fibers;</span>
        <span class="s0">}</span>

        <span class="s0">node = node.</span><span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">node.sibling.</span><span class="s1">return </span><span class="s0">= node.</span><span class="s1">return</span><span class="s0">;</span>
      <span class="s0">node = node.sibling;</span>
    <span class="s0">} </span><span class="s3">// Flow needs the return here, but ESLint complains about it.</span>
    <span class="s3">// eslint-disable-next-line no-unreachable</span>


    <span class="s1">return </span><span class="s0">fibers;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">findNativeNodesForFiberID(id) {</span>
    <span class="s1">try </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">_fiber3 = findCurrentFiberUsingSlowPathById(id);</span>

      <span class="s1">if </span><span class="s0">(_fiber3 === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">hostFibers = findAllCurrentHostFibers(id);</span>
      <span class="s1">return </span><span class="s0">hostFibers.map(</span><span class="s1">function </span><span class="s0">(hostFiber) {</span>
        <span class="s1">return </span><span class="s0">hostFiber.stateNode;</span>
      <span class="s0">}).filter(Boolean);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
      <span class="s3">// The fiber might have unmounted by now.</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getDisplayNameForFiberID(id) {</span>
    <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(id);</span>
    <span class="s1">return </span><span class="s0">fiber != </span><span class="s1">null </span><span class="s0">? getDisplayNameForFiber(fiber) : </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getFiberForNative(hostInstance) {</span>
    <span class="s1">return </span><span class="s0">renderer.findFiberByHostInstance(hostInstance);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getFiberIDForNative(hostInstance) {</span>
    <span class="s1">var </span><span class="s0">findNearestUnfilteredAncestor = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">fiber = renderer.findFiberByHostInstance(hostInstance);</span>

    <span class="s1">if </span><span class="s0">(fiber != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(findNearestUnfilteredAncestor) {</span>
        <span class="s1">while </span><span class="s0">(fiber !== </span><span class="s1">null </span><span class="s0">&amp;&amp; shouldFilterFiber(fiber)) {</span>
          <span class="s0">fiber = fiber.</span><span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">getFiberIDThrows(fiber);</span>
    <span class="s0">}</span>

    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// This function is copied from React and should be kept in sync:</span>
  <span class="s3">// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js</span>


  <span class="s1">function </span><span class="s0">assertIsMounted(fiber) {</span>
    <span class="s1">if </span><span class="s0">(getNearestMountedFiber(fiber) !== fiber) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Unable to find node on an unmounted component.'</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// This function is copied from React and should be kept in sync:</span>
  <span class="s3">// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js</span>


  <span class="s1">function </span><span class="s0">getNearestMountedFiber(fiber) {</span>
    <span class="s1">var </span><span class="s0">node = fiber;</span>
    <span class="s1">var </span><span class="s0">nearestMounted = fiber;</span>

    <span class="s1">if </span><span class="s0">(!fiber.alternate) {</span>
      <span class="s3">// If there is no alternate, this might be a new tree that isn't inserted</span>
      <span class="s3">// yet. If it is, then it will have a pending insertion effect on it.</span>
      <span class="s1">var </span><span class="s0">nextNode = node;</span>

      <span class="s1">do </span><span class="s0">{</span>
        <span class="s0">node = nextNode; </span><span class="s3">// TODO: This function, and these flags, are a leaked implementation</span>
        <span class="s3">// detail. Once we start releasing DevTools in lockstep with React, we</span>
        <span class="s3">// should import a function from the reconciler instead.</span>

        <span class="s1">var </span><span class="s0">Placement = </span><span class="s4">2</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">Hydrating = </span><span class="s4">4096</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">((node.flags &amp; (Placement | Hydrating)) !== </span><span class="s4">0</span><span class="s0">) {</span>
          <span class="s3">// This is an insertion or in-progress hydration. The nearest possible</span>
          <span class="s3">// mounted fiber is the parent but we need to continue to figure out</span>
          <span class="s3">// if that one is still mounted.</span>
          <span class="s0">nearestMounted = node.</span><span class="s1">return</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">// $FlowFixMe[incompatible-type] we bail out when we get a null</span>


        <span class="s0">nextNode = node.</span><span class="s1">return</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">while </span><span class="s0">(nextNode);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">while </span><span class="s0">(node.</span><span class="s1">return</span><span class="s0">) {</span>
        <span class="s0">node = node.</span><span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(node.tag === HostRoot) {</span>
      <span class="s3">// TODO: Check if this was a nested HostRoot when used with</span>
      <span class="s3">// renderContainerIntoSubtree.</span>
      <span class="s1">return </span><span class="s0">nearestMounted;</span>
    <span class="s0">} </span><span class="s3">// If we didn't hit the root, that means that we're in an disconnected tree</span>
    <span class="s3">// that has been unmounted.</span>


    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// This function is copied from React and should be kept in sync:</span>
  <span class="s3">// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js</span>
  <span class="s3">// It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).</span>
  <span class="s3">// BEGIN copied code</span>


  <span class="s1">function </span><span class="s0">findCurrentFiberUsingSlowPathById(id) {</span>
    <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(fiber == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Could not find Fiber with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">alternate = fiber.alternate;</span>

    <span class="s1">if </span><span class="s0">(!alternate) {</span>
      <span class="s3">// If there is no alternate, then we only need to check if it is mounted.</span>
      <span class="s1">var </span><span class="s0">nearestMounted = getNearestMountedFiber(fiber);</span>

      <span class="s1">if </span><span class="s0">(nearestMounted === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Unable to find node on an unmounted component.'</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(nearestMounted !== fiber) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">fiber;</span>
    <span class="s0">} </span><span class="s3">// If we have two possible branches, we'll walk backwards up to the root</span>
    <span class="s3">// to see what path the root points to. On the way we may hit one of the</span>
    <span class="s3">// special cases and we'll deal with them.</span>


    <span class="s1">var </span><span class="s0">a = fiber;</span>
    <span class="s1">var </span><span class="s0">b = alternate;</span>

    <span class="s1">while </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">parentA = a.</span><span class="s1">return</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(parentA === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// We're at the root.</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">parentB = parentA.alternate;</span>

      <span class="s1">if </span><span class="s0">(parentB === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// There is no alternate. This is an unusual case. Currently, it only</span>
        <span class="s3">// happens when a Suspense component is hidden. An extra fragment fiber</span>
        <span class="s3">// is inserted in between the Suspense fiber and its children. Skip</span>
        <span class="s3">// over this extra fragment fiber and proceed to the next parent.</span>
        <span class="s1">var </span><span class="s0">nextParent = parentA.</span><span class="s1">return</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(nextParent !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">a = b = nextParent;</span>
          <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">// If there's no parent, we're at the root.</span>


        <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s3">// If both copies of the parent fiber point to the same child, we can</span>
      <span class="s3">// assume that the child is current. This happens when we bailout on low</span>
      <span class="s3">// priority: the bailed out fiber's child reuses the current child.</span>


      <span class="s1">if </span><span class="s0">(parentA.child === parentB.child) {</span>
        <span class="s1">var </span><span class="s0">child = parentA.child;</span>

        <span class="s1">while </span><span class="s0">(child) {</span>
          <span class="s1">if </span><span class="s0">(child === a) {</span>
            <span class="s3">// We've determined that A is the current branch.</span>
            <span class="s0">assertIsMounted(parentA);</span>
            <span class="s1">return </span><span class="s0">fiber;</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(child === b) {</span>
            <span class="s3">// We've determined that B is the current branch.</span>
            <span class="s0">assertIsMounted(parentA);</span>
            <span class="s1">return </span><span class="s0">alternate;</span>
          <span class="s0">}</span>

          <span class="s0">child = child.sibling;</span>
        <span class="s0">} </span><span class="s3">// We should never have an alternate for any mounting node. So the only</span>
        <span class="s3">// way this could possibly happen is if this was unmounted, if at all.</span>


        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Unable to find node on an unmounted component.'</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(a.</span><span class="s1">return </span><span class="s0">!== b.</span><span class="s1">return</span><span class="s0">) {</span>
        <span class="s3">// The return pointer of A and the return pointer of B point to different</span>
        <span class="s3">// fibers. We assume that return pointers never criss-cross, so A must</span>
        <span class="s3">// belong to the child set of A.return, and B must belong to the child</span>
        <span class="s3">// set of B.return.</span>
        <span class="s0">a = parentA;</span>
        <span class="s0">b = parentB;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// The return pointers point to the same fiber. We'll have to use the</span>
        <span class="s3">// default, slow path: scan the child sets of each parent alternate to see</span>
        <span class="s3">// which child belongs to which set.</span>
        <span class="s3">//</span>
        <span class="s3">// Search parent A's child set</span>
        <span class="s1">var </span><span class="s0">didFindChild = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">_child = parentA.child;</span>

        <span class="s1">while </span><span class="s0">(_child) {</span>
          <span class="s1">if </span><span class="s0">(_child === a) {</span>
            <span class="s0">didFindChild = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">a = parentA;</span>
            <span class="s0">b = parentB;</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(_child === b) {</span>
            <span class="s0">didFindChild = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">b = parentA;</span>
            <span class="s0">a = parentB;</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s0">_child = _child.sibling;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(!didFindChild) {</span>
          <span class="s3">// Search parent B's child set</span>
          <span class="s0">_child = parentB.child;</span>

          <span class="s1">while </span><span class="s0">(_child) {</span>
            <span class="s1">if </span><span class="s0">(_child === a) {</span>
              <span class="s0">didFindChild = </span><span class="s1">true</span><span class="s0">;</span>
              <span class="s0">a = parentB;</span>
              <span class="s0">b = parentA;</span>
              <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(_child === b) {</span>
              <span class="s0">didFindChild = </span><span class="s1">true</span><span class="s0">;</span>
              <span class="s0">b = parentB;</span>
              <span class="s0">a = parentA;</span>
              <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s0">_child = _child.sibling;</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(!didFindChild) {</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Child was not found in either parent set. This indicates a bug ' </span><span class="s0">+ </span><span class="s2">'in React related to the return pointer. Please file an issue.'</span><span class="s0">);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(a.alternate !== b) {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Return fibers should always be each others' alternates. &quot; </span><span class="s0">+ </span><span class="s2">'This error is likely caused by a bug in React. Please file an issue.'</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">// If the root is not a host container, we're in a disconnected tree. I.e.</span>
    <span class="s3">// unmounted.</span>


    <span class="s1">if </span><span class="s0">(a.tag !== HostRoot) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Unable to find node on an unmounted component.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(a.stateNode.current === a) {</span>
      <span class="s3">// We've determined that A is the current branch.</span>
      <span class="s1">return </span><span class="s0">fiber;</span>
    <span class="s0">} </span><span class="s3">// Otherwise B has to be current branch.</span>


    <span class="s1">return </span><span class="s0">alternate;</span>
  <span class="s0">} </span><span class="s3">// END copied code</span>


  <span class="s1">function </span><span class="s0">prepareViewAttributeSource(id, path) {</span>
    <span class="s1">if </span><span class="s0">(isMostRecentlyInspectedElement(id)) {</span>
      <span class="s0">window.$attribute = utils_getInObject(mostRecentlyInspectedElement, path);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">prepareViewElementSource(id) {</span>
    <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(fiber == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Could not find Fiber with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">elementType = fiber.elementType,</span>
        <span class="s0">tag = fiber.tag,</span>
        <span class="s0">type = fiber.type;</span>

    <span class="s1">switch </span><span class="s0">(tag) {</span>
      <span class="s1">case </span><span class="s0">ClassComponent:</span>
      <span class="s1">case </span><span class="s0">IncompleteClassComponent:</span>
      <span class="s1">case </span><span class="s0">IndeterminateComponent:</span>
      <span class="s1">case </span><span class="s0">FunctionComponent:</span>
        <span class="s0">global.$type = type;</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">ForwardRef:</span>
        <span class="s0">global.$type = type.render;</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">MemoComponent:</span>
      <span class="s1">case </span><span class="s0">SimpleMemoComponent:</span>
        <span class="s0">global.$type = elementType != </span><span class="s1">null </span><span class="s0">&amp;&amp; elementType.type != </span><span class="s1">null </span><span class="s0">? elementType.type : type;</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s0">global.$type = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">fiberToSerializedElement(fiber) {</span>
    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">displayName: getDisplayNameForFiber(fiber) || </span><span class="s2">'Anonymous'</span><span class="s0">,</span>
      <span class="s0">id: getFiberIDThrows(fiber),</span>
      <span class="s0">key: fiber.key,</span>
      <span class="s0">type: getElementTypeForFiber(fiber)</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getOwnersList(id) {</span>
    <span class="s1">var </span><span class="s0">fiber = findCurrentFiberUsingSlowPathById(id);</span>

    <span class="s1">if </span><span class="s0">(fiber == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">_debugOwner = fiber._debugOwner;</span>
    <span class="s1">var </span><span class="s0">owners = [fiberToSerializedElement(fiber)];</span>

    <span class="s1">if </span><span class="s0">(_debugOwner) {</span>
      <span class="s1">var </span><span class="s0">owner = _debugOwner;</span>

      <span class="s1">while </span><span class="s0">(owner !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">owners.unshift(fiberToSerializedElement(owner));</span>
        <span class="s0">owner = owner._debugOwner || </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">owners;</span>
  <span class="s0">} </span><span class="s3">// Fast path props lookup for React Native style editor.</span>
  <span class="s3">// Could use inspectElementRaw() but that would require shallow rendering hooks components,</span>
  <span class="s3">// and could also mess with memoization.</span>


  <span class="s1">function </span><span class="s0">getInstanceAndStyle(id) {</span>
    <span class="s1">var </span><span class="s0">instance = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">style = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">fiber = findCurrentFiberUsingSlowPathById(id);</span>

    <span class="s1">if </span><span class="s0">(fiber !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">instance = fiber.stateNode;</span>

      <span class="s1">if </span><span class="s0">(fiber.memoizedProps !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">style = fiber.memoizedProps.style;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">instance: instance,</span>
      <span class="s0">style: style</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">isErrorBoundary(fiber) {</span>
    <span class="s1">var </span><span class="s0">tag = fiber.tag,</span>
        <span class="s0">type = fiber.type;</span>

    <span class="s1">switch </span><span class="s0">(tag) {</span>
      <span class="s1">case </span><span class="s0">ClassComponent:</span>
      <span class="s1">case </span><span class="s0">IncompleteClassComponent:</span>
        <span class="s1">var </span><span class="s0">instance = fiber.stateNode;</span>
        <span class="s1">return typeof </span><span class="s0">type.getDerivedStateFromError === </span><span class="s2">'function' </span><span class="s0">|| instance !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">instance.componentDidCatch === </span><span class="s2">'function'</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getNearestErrorBoundaryID(fiber) {</span>
    <span class="s1">var </span><span class="s0">parent = fiber.</span><span class="s1">return</span><span class="s0">;</span>

    <span class="s1">while </span><span class="s0">(parent !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(isErrorBoundary(parent)) {</span>
        <span class="s1">return </span><span class="s0">getFiberIDUnsafe(parent);</span>
      <span class="s0">}</span>

      <span class="s0">parent = parent.</span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">inspectElementRaw(id) {</span>
    <span class="s1">var </span><span class="s0">fiber = findCurrentFiberUsingSlowPathById(id);</span>

    <span class="s1">if </span><span class="s0">(fiber == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">_debugOwner = fiber._debugOwner,</span>
        <span class="s0">_debugSource = fiber._debugSource,</span>
        <span class="s0">stateNode = fiber.stateNode,</span>
        <span class="s0">key = fiber.key,</span>
        <span class="s0">memoizedProps = fiber.memoizedProps,</span>
        <span class="s0">memoizedState = fiber.memoizedState,</span>
        <span class="s0">dependencies = fiber.dependencies,</span>
        <span class="s0">tag = fiber.tag,</span>
        <span class="s0">type = fiber.type;</span>
    <span class="s1">var </span><span class="s0">elementType = getElementTypeForFiber(fiber);</span>
    <span class="s1">var </span><span class="s0">usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) &amp;&amp; (!!memoizedState || !!dependencies); </span><span class="s3">// TODO Show custom UI for Cache like we do for Suspense</span>
    <span class="s3">// For now, just hide state data entirely since it's not meant to be inspected.</span>

    <span class="s1">var </span><span class="s0">showState = !usesHooks &amp;&amp; tag !== CacheComponent;</span>
    <span class="s1">var </span><span class="s0">typeSymbol = getTypeSymbol(type);</span>
    <span class="s1">var </span><span class="s0">canViewSource = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">context = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {</span>
      <span class="s0">canViewSource = </span><span class="s1">true</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(stateNode &amp;&amp; stateNode.context != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// Don't show an empty context object for class components that don't use the context API.</span>
        <span class="s1">var </span><span class="s0">shouldHideContext = elementType === types_ElementTypeClass &amp;&amp; !(type.contextTypes || type.contextType);</span>

        <span class="s1">if </span><span class="s0">(!shouldHideContext) {</span>
          <span class="s0">context = stateNode.context;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(typeSymbol === CONTEXT_NUMBER || typeSymbol === CONTEXT_SYMBOL_STRING) {</span>
      <span class="s3">// 16.3-16.5 read from &quot;type&quot; because the Consumer is the actual context object.</span>
      <span class="s3">// 16.6+ should read from &quot;type._context&quot; because Consumer can be different (in DEV).</span>
      <span class="s3">// NOTE Keep in sync with getDisplayNameForFiber()</span>
      <span class="s1">var </span><span class="s0">consumerResolvedContext = type._context || type; </span><span class="s3">// Global context value.</span>

      <span class="s0">context = consumerResolvedContext._currentValue || </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// Look for overridden value.</span>

      <span class="s1">var </span><span class="s0">_current = fiber.</span><span class="s1">return</span><span class="s0">;</span>

      <span class="s1">while </span><span class="s0">(_current !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">currentType = _current.type;</span>
        <span class="s1">var </span><span class="s0">currentTypeSymbol = getTypeSymbol(currentType);</span>

        <span class="s1">if </span><span class="s0">(currentTypeSymbol === PROVIDER_NUMBER || currentTypeSymbol === PROVIDER_SYMBOL_STRING) {</span>
          <span class="s3">// 16.3.0 exposed the context object as &quot;context&quot;</span>
          <span class="s3">// PR #12501 changed it to &quot;_context&quot; for 16.3.1+</span>
          <span class="s3">// NOTE Keep in sync with getDisplayNameForFiber()</span>
          <span class="s1">var </span><span class="s0">providerResolvedContext = currentType._context || currentType.context;</span>

          <span class="s1">if </span><span class="s0">(providerResolvedContext === consumerResolvedContext) {</span>
            <span class="s0">context = _current.memoizedProps.value;</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s0">_current = _current.</span><span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">hasLegacyContext = </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(context !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">hasLegacyContext = !!type.contextTypes; </span><span class="s3">// To simplify hydration and display logic for context, wrap in a value object.</span>
      <span class="s3">// Otherwise simple values (e.g. strings, booleans) become harder to handle.</span>

      <span class="s0">context = {</span>
        <span class="s0">value: context</span>
      <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">owners = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(_debugOwner) {</span>
      <span class="s0">owners = [];</span>
      <span class="s1">var </span><span class="s0">owner = _debugOwner;</span>

      <span class="s1">while </span><span class="s0">(owner !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">owners.push(fiberToSerializedElement(owner));</span>
        <span class="s0">owner = owner._debugOwner || </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">isTimedOutSuspense = tag === SuspenseComponent &amp;&amp; memoizedState !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">hooks = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(usesHooks) {</span>
      <span class="s1">var </span><span class="s0">originalConsoleMethods = {}; </span><span class="s3">// Temporarily disable all console logging before re-running the hook.</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">method </span><span class="s1">in </span><span class="s0">console) {</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s0">originalConsoleMethods[method] = console[method]; </span><span class="s3">// $FlowFixMe[prop-missing]</span>

          <span class="s0">console[method] = </span><span class="s1">function </span><span class="s0">() {};</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
      <span class="s0">}</span>

      <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">hooks = (</span><span class="s4">0</span><span class="s0">,react_debug_tools.inspectHooksOfFiber)(fiber, renderer.currentDispatcherRef, </span><span class="s1">true </span><span class="s3">// Include source location info for hooks</span>
        <span class="s0">);</span>
      <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
        <span class="s3">// Restore original console functionality.</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_method </span><span class="s1">in </span><span class="s0">originalConsoleMethods) {</span>
          <span class="s1">try </span><span class="s0">{</span>
            <span class="s3">// $FlowFixMe[prop-missing]</span>
            <span class="s0">console[_method] = originalConsoleMethods[_method];</span>
          <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">rootType = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">current = fiber;</span>

    <span class="s1">while </span><span class="s0">(current.</span><span class="s1">return </span><span class="s0">!== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">current = current.</span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">fiberRoot = current.stateNode;</span>

    <span class="s1">if </span><span class="s0">(fiberRoot != </span><span class="s1">null </span><span class="s0">&amp;&amp; fiberRoot._debugRootType !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">rootType = fiberRoot._debugRootType;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">errors = fiberIDToErrorsMap.get(id) || </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">var </span><span class="s0">warnings = fiberIDToWarningsMap.get(id) || </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">var </span><span class="s0">isErrored = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">targetErrorBoundaryID;</span>

    <span class="s1">if </span><span class="s0">(isErrorBoundary(fiber)) {</span>
      <span class="s3">// if the current inspected element is an error boundary,</span>
      <span class="s3">// either that we want to use it to toggle off error state</span>
      <span class="s3">// or that we allow to force error state on it if it's within another</span>
      <span class="s3">// error boundary</span>
      <span class="s3">//</span>
      <span class="s3">// TODO: This flag is a leaked implementation detail. Once we start</span>
      <span class="s3">// releasing DevTools in lockstep with React, we should import a function</span>
      <span class="s3">// from the reconciler instead.</span>
      <span class="s1">var </span><span class="s0">DidCapture = </span><span class="s4">128</span><span class="s0">;</span>
      <span class="s0">isErrored = (fiber.flags &amp; DidCapture) !== </span><span class="s4">0 </span><span class="s0">|| forceErrorForFiberIDs.get(id) === </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">targetErrorBoundaryID = isErrored ? id : getNearestErrorBoundaryID(fiber);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">targetErrorBoundaryID = getNearestErrorBoundaryID(fiber);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">plugins = {</span>
      <span class="s0">stylex: </span><span class="s1">null</span>
    <span class="s0">};</span>

    <span class="s1">if </span><span class="s0">(enableStyleXFeatures) {</span>
      <span class="s1">if </span><span class="s0">(memoizedProps.hasOwnProperty(</span><span class="s2">'xstyle'</span><span class="s0">)) {</span>
        <span class="s0">plugins.stylex = getStyleXData(memoizedProps.xstyle);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">id: id,</span>
      <span class="s3">// Does the current renderer support editable hooks and function props?</span>
      <span class="s0">canEditHooks: </span><span class="s1">typeof </span><span class="s0">overrideHookState === </span><span class="s2">'function'</span><span class="s0">,</span>
      <span class="s0">canEditFunctionProps: </span><span class="s1">typeof </span><span class="s0">overrideProps === </span><span class="s2">'function'</span><span class="s0">,</span>
      <span class="s3">// Does the current renderer support advanced editing interface?</span>
      <span class="s0">canEditHooksAndDeletePaths: </span><span class="s1">typeof </span><span class="s0">overrideHookStateDeletePath === </span><span class="s2">'function'</span><span class="s0">,</span>
      <span class="s0">canEditHooksAndRenamePaths: </span><span class="s1">typeof </span><span class="s0">overrideHookStateRenamePath === </span><span class="s2">'function'</span><span class="s0">,</span>
      <span class="s0">canEditFunctionPropsDeletePaths: </span><span class="s1">typeof </span><span class="s0">overridePropsDeletePath === </span><span class="s2">'function'</span><span class="s0">,</span>
      <span class="s0">canEditFunctionPropsRenamePaths: </span><span class="s1">typeof </span><span class="s0">overridePropsRenamePath === </span><span class="s2">'function'</span><span class="s0">,</span>
      <span class="s0">canToggleError: supportsTogglingError &amp;&amp; targetErrorBoundaryID != </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s3">// Is this error boundary in error state.</span>
      <span class="s0">isErrored: isErrored,</span>
      <span class="s0">targetErrorBoundaryID: targetErrorBoundaryID,</span>
      <span class="s0">canToggleSuspense: supportsTogglingSuspense &amp;&amp; ( </span><span class="s3">// If it's showing the real content, we can always flip fallback.</span>
      <span class="s0">!isTimedOutSuspense || </span><span class="s3">// If it's showing fallback because we previously forced it to,</span>
      <span class="s3">// allow toggling it back to remove the fallback override.</span>
      <span class="s0">forceFallbackForSuspenseIDs.has(id)),</span>
      <span class="s3">// Can view component source location.</span>
      <span class="s0">canViewSource: canViewSource,</span>
      <span class="s3">// Does the component have legacy context attached to it.</span>
      <span class="s0">hasLegacyContext: hasLegacyContext,</span>
      <span class="s0">key: key != </span><span class="s1">null </span><span class="s0">? key : </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">displayName: getDisplayNameForFiber(fiber),</span>
      <span class="s0">type: elementType,</span>
      <span class="s3">// Inspectable properties.</span>
      <span class="s3">// TODO Review sanitization approach for the below inspectable values.</span>
      <span class="s0">context: context,</span>
      <span class="s0">hooks: hooks,</span>
      <span class="s0">props: memoizedProps,</span>
      <span class="s0">state: showState ? memoizedState : </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">errors: Array.from(errors.entries()),</span>
      <span class="s0">warnings: Array.from(warnings.entries()),</span>
      <span class="s3">// List of owners</span>
      <span class="s0">owners: owners,</span>
      <span class="s3">// Location of component in source code.</span>
      <span class="s0">source: _debugSource || </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">rootType: rootType,</span>
      <span class="s0">rendererPackageName: renderer.rendererPackageName,</span>
      <span class="s0">rendererVersion: renderer.version,</span>
      <span class="s0">plugins: plugins</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">mostRecentlyInspectedElement = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">hasElementUpdatedSinceLastInspected = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">currentlyInspectedPaths = {};</span>

  <span class="s1">function </span><span class="s0">isMostRecentlyInspectedElement(id) {</span>
    <span class="s1">return </span><span class="s0">mostRecentlyInspectedElement !== </span><span class="s1">null </span><span class="s0">&amp;&amp; mostRecentlyInspectedElement.id === id;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">isMostRecentlyInspectedElementCurrent(id) {</span>
    <span class="s1">return </span><span class="s0">isMostRecentlyInspectedElement(id) &amp;&amp; !hasElementUpdatedSinceLastInspected;</span>
  <span class="s0">} </span><span class="s3">// Track the intersection of currently inspected paths,</span>
  <span class="s3">// so that we can send their data along if the element is re-rendered.</span>


  <span class="s1">function </span><span class="s0">mergeInspectedPaths(path) {</span>
    <span class="s1">var </span><span class="s0">current = currentlyInspectedPaths;</span>
    <span class="s0">path.forEach(</span><span class="s1">function </span><span class="s0">(key) {</span>
      <span class="s1">if </span><span class="s0">(!current[key]) {</span>
        <span class="s0">current[key] = {};</span>
      <span class="s0">}</span>

      <span class="s0">current = current[key];</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">createIsPathAllowed(key, secondaryCategory) {</span>
    <span class="s3">// This function helps prevent previously-inspected paths from being dehydrated in updates.</span>
    <span class="s3">// This is important to avoid a bad user experience where expanded toggles collapse on update.</span>
    <span class="s1">return function </span><span class="s0">isPathAllowed(path) {</span>
      <span class="s1">switch </span><span class="s0">(secondaryCategory) {</span>
        <span class="s1">case </span><span class="s2">'hooks'</span><span class="s0">:</span>
          <span class="s1">if </span><span class="s0">(path.length === </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s3">// Never dehydrate the &quot;hooks&quot; object at the top levels.</span>
            <span class="s1">return true</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(path[path.length - </span><span class="s4">2</span><span class="s0">] === </span><span class="s2">'hookSource' </span><span class="s0">&amp;&amp; path[path.length - </span><span class="s4">1</span><span class="s0">] === </span><span class="s2">'fileName'</span><span class="s0">) {</span>
            <span class="s3">// It's important to preserve the full file name (URL) for hook sources</span>
            <span class="s3">// in case the user has enabled the named hooks feature.</span>
            <span class="s3">// Otherwise the frontend may end up with a partial URL which it can't load.</span>
            <span class="s1">return true</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(path[path.length - </span><span class="s4">1</span><span class="s0">] === </span><span class="s2">'subHooks' </span><span class="s0">|| path[path.length - </span><span class="s4">2</span><span class="s0">] === </span><span class="s2">'subHooks'</span><span class="s0">) {</span>
            <span class="s3">// Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,</span>
            <span class="s3">// so it's easiest for now if we just don't break on this boundary.</span>
            <span class="s3">// We can always dehydrate a level deeper (in the value object).</span>
            <span class="s1">return true</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">default</span><span class="s0">:</span>
          <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">current = key === </span><span class="s1">null </span><span class="s0">? currentlyInspectedPaths : currentlyInspectedPaths[key];</span>

      <span class="s1">if </span><span class="s0">(!current) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; path.length; i++) {</span>
        <span class="s0">current = current[path[i]];</span>

        <span class="s1">if </span><span class="s0">(!current) {</span>
          <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">updateSelectedElement(inspectedElement) {</span>
    <span class="s1">var </span><span class="s0">hooks = inspectedElement.hooks,</span>
        <span class="s0">id = inspectedElement.id,</span>
        <span class="s0">props = inspectedElement.props;</span>
    <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(fiber == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Could not find Fiber with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">elementType = fiber.elementType,</span>
        <span class="s0">stateNode = fiber.stateNode,</span>
        <span class="s0">tag = fiber.tag,</span>
        <span class="s0">type = fiber.type;</span>

    <span class="s1">switch </span><span class="s0">(tag) {</span>
      <span class="s1">case </span><span class="s0">ClassComponent:</span>
      <span class="s1">case </span><span class="s0">IncompleteClassComponent:</span>
      <span class="s1">case </span><span class="s0">IndeterminateComponent:</span>
        <span class="s0">global.$r = stateNode;</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">FunctionComponent:</span>
        <span class="s0">global.$r = {</span>
          <span class="s0">hooks: hooks,</span>
          <span class="s0">props: props,</span>
          <span class="s0">type: type</span>
        <span class="s0">};</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">ForwardRef:</span>
        <span class="s0">global.$r = {</span>
          <span class="s0">hooks: hooks,</span>
          <span class="s0">props: props,</span>
          <span class="s0">type: type.render</span>
        <span class="s0">};</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">MemoComponent:</span>
      <span class="s1">case </span><span class="s0">SimpleMemoComponent:</span>
        <span class="s0">global.$r = {</span>
          <span class="s0">hooks: hooks,</span>
          <span class="s0">props: props,</span>
          <span class="s0">type: elementType != </span><span class="s1">null </span><span class="s0">&amp;&amp; elementType.type != </span><span class="s1">null </span><span class="s0">? elementType.type : type</span>
        <span class="s0">};</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s0">global.$r = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">storeAsGlobal(id, path, count) {</span>
    <span class="s1">if </span><span class="s0">(isMostRecentlyInspectedElement(id)) {</span>
      <span class="s1">var </span><span class="s0">value = utils_getInObject(mostRecentlyInspectedElement, path);</span>
      <span class="s1">var </span><span class="s0">key = </span><span class="s2">&quot;$reactTemp&quot;</span><span class="s0">.concat(count);</span>
      <span class="s0">window[key] = value;</span>
      <span class="s0">console.log(key);</span>
      <span class="s0">console.log(value);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getSerializedElementValueByPath(id, path) {</span>
    <span class="s1">if </span><span class="s0">(isMostRecentlyInspectedElement(id)) {</span>
      <span class="s1">var </span><span class="s0">valueToCopy = utils_getInObject(mostRecentlyInspectedElement, path);</span>
      <span class="s1">return </span><span class="s0">serializeToString(valueToCopy);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">inspectElement(requestID, id, path, forceFullData) {</span>
    <span class="s1">if </span><span class="s0">(path !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">mergeInspectedPaths(path);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isMostRecentlyInspectedElement(id) &amp;&amp; !forceFullData) {</span>
      <span class="s1">if </span><span class="s0">(!hasElementUpdatedSinceLastInspected) {</span>
        <span class="s1">if </span><span class="s0">(path !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s1">var </span><span class="s0">secondaryCategory = </span><span class="s1">null</span><span class="s0">;</span>

          <span class="s1">if </span><span class="s0">(path[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'hooks'</span><span class="s0">) {</span>
            <span class="s0">secondaryCategory = </span><span class="s2">'hooks'</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s3">// If this element has not been updated since it was last inspected,</span>
          <span class="s3">// we can just return the subset of data in the newly-inspected path.</span>


          <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">id: id,</span>
            <span class="s0">responseID: requestID,</span>
            <span class="s0">type: </span><span class="s2">'hydrated-path'</span><span class="s0">,</span>
            <span class="s0">path: path,</span>
            <span class="s0">value: cleanForBridge(utils_getInObject(mostRecentlyInspectedElement, path), createIsPathAllowed(</span><span class="s1">null</span><span class="s0">, secondaryCategory), path)</span>
          <span class="s0">};</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s3">// If this element has not been updated since it was last inspected, we don't need to return it.</span>
          <span class="s3">// Instead we can just return the ID to indicate that it has not changed.</span>
          <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">id: id,</span>
            <span class="s0">responseID: requestID,</span>
            <span class="s0">type: </span><span class="s2">'no-change'</span>
          <span class="s0">};</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">currentlyInspectedPaths = {};</span>
    <span class="s0">}</span>

    <span class="s0">hasElementUpdatedSinceLastInspected = </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s0">mostRecentlyInspectedElement = inspectElementRaw(id);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
      <span class="s3">// the error name is synced with ReactDebugHooks</span>
      <span class="s1">if </span><span class="s0">(error.name === </span><span class="s2">'ReactDebugToolsRenderError'</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">message = </span><span class="s2">'Error rendering inspected element.'</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">stack; </span><span class="s3">// Log error &amp; cause for user to debug</span>

        <span class="s0">console.error(message + </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">'</span><span class="s0">, error);</span>

        <span class="s1">if </span><span class="s0">(error.cause != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s1">var </span><span class="s0">_fiber4 = findCurrentFiberUsingSlowPathById(id);</span>

          <span class="s1">var </span><span class="s0">componentName = _fiber4 != </span><span class="s1">null </span><span class="s0">? getDisplayNameForFiber(_fiber4) : </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s0">console.error(</span><span class="s2">'React DevTools encountered an error while trying to inspect hooks. ' </span><span class="s0">+ </span><span class="s2">'This is most likely caused by an error in current inspected component' </span><span class="s0">+ (componentName != </span><span class="s1">null </span><span class="s0">? </span><span class="s2">&quot;: </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(componentName, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">.&quot;</span><span class="s0">) : </span><span class="s2">'.'</span><span class="s0">) + </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">The error thrown in the component is: </span><span class="s5">\n\n</span><span class="s2">'</span><span class="s0">, error.cause);</span>

          <span class="s1">if </span><span class="s0">(error.cause </span><span class="s1">instanceof </span><span class="s0">Error) {</span>
            <span class="s0">message = error.cause.message || message;</span>
            <span class="s0">stack = error.cause.stack;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">{</span>
          <span class="s0">type: </span><span class="s2">'error'</span><span class="s0">,</span>
          <span class="s0">errorType: </span><span class="s2">'user'</span><span class="s0">,</span>
          <span class="s0">id: id,</span>
          <span class="s0">responseID: requestID,</span>
          <span class="s0">message: message,</span>
          <span class="s0">stack: stack</span>
        <span class="s0">};</span>
      <span class="s0">} </span><span class="s3">// the error name is synced with ReactDebugHooks</span>


      <span class="s1">if </span><span class="s0">(error.name === </span><span class="s2">'ReactDebugToolsUnsupportedHookError'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">{</span>
          <span class="s0">type: </span><span class="s2">'error'</span><span class="s0">,</span>
          <span class="s0">errorType: </span><span class="s2">'unknown-hook'</span><span class="s0">,</span>
          <span class="s0">id: id,</span>
          <span class="s0">responseID: requestID,</span>
          <span class="s0">message: </span><span class="s2">'Unsupported hook in the react-debug-tools package: ' </span><span class="s0">+ error.message</span>
        <span class="s0">};</span>
      <span class="s0">} </span><span class="s3">// Log Uncaught Error</span>


      <span class="s0">console.error(</span><span class="s2">'Error inspecting element.</span><span class="s5">\n\n</span><span class="s2">'</span><span class="s0">, error);</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">type: </span><span class="s2">'error'</span><span class="s0">,</span>
        <span class="s0">errorType: </span><span class="s2">'uncaught'</span><span class="s0">,</span>
        <span class="s0">id: id,</span>
        <span class="s0">responseID: requestID,</span>
        <span class="s0">message: error.message,</span>
        <span class="s0">stack: error.stack</span>
      <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(mostRecentlyInspectedElement === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">id: id,</span>
        <span class="s0">responseID: requestID,</span>
        <span class="s0">type: </span><span class="s2">'not-found'</span>
      <span class="s0">};</span>
    <span class="s0">} </span><span class="s3">// Any time an inspected element has an update,</span>
    <span class="s3">// we should update the selected $r value as wel.</span>
    <span class="s3">// Do this before dehydration (cleanForBridge).</span>


    <span class="s0">updateSelectedElement(mostRecentlyInspectedElement); </span><span class="s3">// Clone before cleaning so that we preserve the full data.</span>
    <span class="s3">// This will enable us to send patches without re-inspecting if hydrated paths are requested.</span>
    <span class="s3">// (Reducing how often we shallow-render is a better DX for function components that use hooks.)</span>

    <span class="s1">var </span><span class="s0">cleanedInspectedElement = renderer_objectSpread({}, mostRecentlyInspectedElement); </span><span class="s3">// $FlowFixMe[prop-missing] found when upgrading Flow</span>


    <span class="s0">cleanedInspectedElement.context = cleanForBridge(cleanedInspectedElement.context, createIsPathAllowed(</span><span class="s2">'context'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">)); </span><span class="s3">// $FlowFixMe[prop-missing] found when upgrading Flow</span>

    <span class="s0">cleanedInspectedElement.hooks = cleanForBridge(cleanedInspectedElement.hooks, createIsPathAllowed(</span><span class="s2">'hooks'</span><span class="s0">, </span><span class="s2">'hooks'</span><span class="s0">)); </span><span class="s3">// $FlowFixMe[prop-missing] found when upgrading Flow</span>

    <span class="s0">cleanedInspectedElement.props = cleanForBridge(cleanedInspectedElement.props, createIsPathAllowed(</span><span class="s2">'props'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">)); </span><span class="s3">// $FlowFixMe[prop-missing] found when upgrading Flow</span>

    <span class="s0">cleanedInspectedElement.state = cleanForBridge(cleanedInspectedElement.state, createIsPathAllowed(</span><span class="s2">'state'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">));</span>
    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">id: id,</span>
      <span class="s0">responseID: requestID,</span>
      <span class="s0">type: </span><span class="s2">'full-data'</span><span class="s0">,</span>
      <span class="s3">// $FlowFixMe[prop-missing] found when upgrading Flow</span>
      <span class="s0">value: cleanedInspectedElement</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">logElementToConsole(id) {</span>
    <span class="s1">var </span><span class="s0">result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);</span>

    <span class="s1">if </span><span class="s0">(result === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Could not find Fiber with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">supportsGroup = </span><span class="s1">typeof </span><span class="s0">console.groupCollapsed === </span><span class="s2">'function'</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(supportsGroup) {</span>
      <span class="s0">console.groupCollapsed(</span><span class="s2">&quot;[Click to expand] %c&lt;&quot;</span><span class="s0">.concat(result.displayName || </span><span class="s2">'Component'</span><span class="s0">, </span><span class="s2">&quot; /&gt;&quot;</span><span class="s0">), </span><span class="s3">// --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.</span>
      <span class="s2">'color: var(--dom-tag-name-color); font-weight: normal;'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(result.props !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'Props:'</span><span class="s0">, result.props);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(result.state !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'State:'</span><span class="s0">, result.state);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(result.hooks !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'Hooks:'</span><span class="s0">, result.hooks);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">nativeNodes = findNativeNodesForFiberID(id);</span>

    <span class="s1">if </span><span class="s0">(nativeNodes !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'Nodes:'</span><span class="s0">, nativeNodes);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(result.source !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'Location:'</span><span class="s0">, result.source);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(window.chrome || /firefox/i.test(navigator.userAgent)) {</span>
      <span class="s0">console.log(</span><span class="s2">'Right-click any value to save it as a global variable for further inspection.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsGroup) {</span>
      <span class="s0">console.groupEnd();</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">deletePath(type, id, hookID, path) {</span>
    <span class="s1">var </span><span class="s0">fiber = findCurrentFiberUsingSlowPathById(id);</span>

    <span class="s1">if </span><span class="s0">(fiber !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">instance = fiber.stateNode;</span>

      <span class="s1">switch </span><span class="s0">(type) {</span>
        <span class="s1">case </span><span class="s2">'context'</span><span class="s0">:</span>
          <span class="s3">// To simplify hydration and display of primitive context values (e.g. number, string)</span>
          <span class="s3">// the inspectElement() method wraps context in a {value: ...} object.</span>
          <span class="s3">// We need to remove the first part of the path (the &quot;value&quot;) before continuing.</span>
          <span class="s0">path = path.slice(</span><span class="s4">1</span><span class="s0">);</span>

          <span class="s1">switch </span><span class="s0">(fiber.tag) {</span>
            <span class="s1">case </span><span class="s0">ClassComponent:</span>
              <span class="s1">if </span><span class="s0">(path.length === </span><span class="s4">0</span><span class="s0">) {</span><span class="s3">// Simple context value (noop)</span>
              <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">deletePathInObject(instance.context, path);</span>
              <span class="s0">}</span>

              <span class="s0">instance.forceUpdate();</span>
              <span class="s1">break</span><span class="s0">;</span>

            <span class="s1">case </span><span class="s0">FunctionComponent:</span>
              <span class="s3">// Function components using legacy context are not editable</span>
              <span class="s3">// because there's no instance on which to create a cloned, mutated context.</span>
              <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'hooks'</span><span class="s0">:</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">overrideHookStateDeletePath === </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s0">overrideHookStateDeletePath(fiber, hookID, path);</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'props'</span><span class="s0">:</span>
          <span class="s1">if </span><span class="s0">(instance === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">overridePropsDeletePath === </span><span class="s2">'function'</span><span class="s0">) {</span>
              <span class="s0">overridePropsDeletePath(fiber, path);</span>
            <span class="s0">}</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">fiber.pendingProps = copyWithDelete(instance.props, path);</span>
            <span class="s0">instance.forceUpdate();</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'state'</span><span class="s0">:</span>
          <span class="s0">deletePathInObject(instance.state, path);</span>
          <span class="s0">instance.forceUpdate();</span>
          <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">renamePath(type, id, hookID, oldPath, newPath) {</span>
    <span class="s1">var </span><span class="s0">fiber = findCurrentFiberUsingSlowPathById(id);</span>

    <span class="s1">if </span><span class="s0">(fiber !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">instance = fiber.stateNode;</span>

      <span class="s1">switch </span><span class="s0">(type) {</span>
        <span class="s1">case </span><span class="s2">'context'</span><span class="s0">:</span>
          <span class="s3">// To simplify hydration and display of primitive context values (e.g. number, string)</span>
          <span class="s3">// the inspectElement() method wraps context in a {value: ...} object.</span>
          <span class="s3">// We need to remove the first part of the path (the &quot;value&quot;) before continuing.</span>
          <span class="s0">oldPath = oldPath.slice(</span><span class="s4">1</span><span class="s0">);</span>
          <span class="s0">newPath = newPath.slice(</span><span class="s4">1</span><span class="s0">);</span>

          <span class="s1">switch </span><span class="s0">(fiber.tag) {</span>
            <span class="s1">case </span><span class="s0">ClassComponent:</span>
              <span class="s1">if </span><span class="s0">(oldPath.length === </span><span class="s4">0</span><span class="s0">) {</span><span class="s3">// Simple context value (noop)</span>
              <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">renamePathInObject(instance.context, oldPath, newPath);</span>
              <span class="s0">}</span>

              <span class="s0">instance.forceUpdate();</span>
              <span class="s1">break</span><span class="s0">;</span>

            <span class="s1">case </span><span class="s0">FunctionComponent:</span>
              <span class="s3">// Function components using legacy context are not editable</span>
              <span class="s3">// because there's no instance on which to create a cloned, mutated context.</span>
              <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'hooks'</span><span class="s0">:</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">overrideHookStateRenamePath === </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s0">overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'props'</span><span class="s0">:</span>
          <span class="s1">if </span><span class="s0">(instance === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">overridePropsRenamePath === </span><span class="s2">'function'</span><span class="s0">) {</span>
              <span class="s0">overridePropsRenamePath(fiber, oldPath, newPath);</span>
            <span class="s0">}</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">fiber.pendingProps = copyWithRename(instance.props, oldPath, newPath);</span>
            <span class="s0">instance.forceUpdate();</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'state'</span><span class="s0">:</span>
          <span class="s0">renamePathInObject(instance.state, oldPath, newPath);</span>
          <span class="s0">instance.forceUpdate();</span>
          <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">overrideValueAtPath(type, id, hookID, path, value) {</span>
    <span class="s1">var </span><span class="s0">fiber = findCurrentFiberUsingSlowPathById(id);</span>

    <span class="s1">if </span><span class="s0">(fiber !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">instance = fiber.stateNode;</span>

      <span class="s1">switch </span><span class="s0">(type) {</span>
        <span class="s1">case </span><span class="s2">'context'</span><span class="s0">:</span>
          <span class="s3">// To simplify hydration and display of primitive context values (e.g. number, string)</span>
          <span class="s3">// the inspectElement() method wraps context in a {value: ...} object.</span>
          <span class="s3">// We need to remove the first part of the path (the &quot;value&quot;) before continuing.</span>
          <span class="s0">path = path.slice(</span><span class="s4">1</span><span class="s0">);</span>

          <span class="s1">switch </span><span class="s0">(fiber.tag) {</span>
            <span class="s1">case </span><span class="s0">ClassComponent:</span>
              <span class="s1">if </span><span class="s0">(path.length === </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s3">// Simple context value</span>
                <span class="s0">instance.context = value;</span>
              <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">utils_setInObject(instance.context, path, value);</span>
              <span class="s0">}</span>

              <span class="s0">instance.forceUpdate();</span>
              <span class="s1">break</span><span class="s0">;</span>

            <span class="s1">case </span><span class="s0">FunctionComponent:</span>
              <span class="s3">// Function components using legacy context are not editable</span>
              <span class="s3">// because there's no instance on which to create a cloned, mutated context.</span>
              <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'hooks'</span><span class="s0">:</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">overrideHookState === </span><span class="s2">'function'</span><span class="s0">) {</span>
            <span class="s0">overrideHookState(fiber, hookID, path, value);</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'props'</span><span class="s0">:</span>
          <span class="s1">switch </span><span class="s0">(fiber.tag) {</span>
            <span class="s1">case </span><span class="s0">ClassComponent:</span>
              <span class="s0">fiber.pendingProps = copyWithSet(instance.props, path, value);</span>
              <span class="s0">instance.forceUpdate();</span>
              <span class="s1">break</span><span class="s0">;</span>

            <span class="s1">default</span><span class="s0">:</span>
              <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">overrideProps === </span><span class="s2">'function'</span><span class="s0">) {</span>
                <span class="s0">overrideProps(fiber, path, value);</span>
              <span class="s0">}</span>

              <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'state'</span><span class="s0">:</span>
          <span class="s1">switch </span><span class="s0">(fiber.tag) {</span>
            <span class="s1">case </span><span class="s0">ClassComponent:</span>
              <span class="s0">utils_setInObject(instance.state, path, value);</span>
              <span class="s0">instance.forceUpdate();</span>
              <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">currentCommitProfilingMetadata = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">displayNamesByRootID = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">idToContextsMap = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">initialTreeBaseDurationsMap = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">initialIDToRootMap = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">isProfiling = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">profilingStartTime = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">recordChangeDescriptions = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">rootToCommitProfilingMetadataMap = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">getProfilingData() {</span>
    <span class="s1">var </span><span class="s0">dataForRoots = [];</span>

    <span class="s1">if </span><span class="s0">(rootToCommitProfilingMetadataMap === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">throw </span><span class="s0">Error(</span><span class="s2">'getProfilingData() called before any profiling data was recorded'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">rootToCommitProfilingMetadataMap.forEach(</span><span class="s1">function </span><span class="s0">(commitProfilingMetadata, rootID) {</span>
      <span class="s1">var </span><span class="s0">commitData = [];</span>
      <span class="s1">var </span><span class="s0">initialTreeBaseDurations = [];</span>
      <span class="s1">var </span><span class="s0">displayName = displayNamesByRootID !== </span><span class="s1">null </span><span class="s0">&amp;&amp; displayNamesByRootID.get(rootID) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(initialTreeBaseDurationsMap != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">initialTreeBaseDurationsMap.forEach(</span><span class="s1">function </span><span class="s0">(treeBaseDuration, id) {</span>
          <span class="s1">if </span><span class="s0">(initialIDToRootMap != </span><span class="s1">null </span><span class="s0">&amp;&amp; initialIDToRootMap.get(id) === rootID) {</span>
            <span class="s3">// We don't need to convert milliseconds to microseconds in this case,</span>
            <span class="s3">// because the profiling summary is JSON serialized.</span>
            <span class="s0">initialTreeBaseDurations.push([id, treeBaseDuration]);</span>
          <span class="s0">}</span>
        <span class="s0">});</span>
      <span class="s0">}</span>

      <span class="s0">commitProfilingMetadata.forEach(</span><span class="s1">function </span><span class="s0">(commitProfilingData, commitIndex) {</span>
        <span class="s1">var </span><span class="s0">changeDescriptions = commitProfilingData.changeDescriptions,</span>
            <span class="s0">durations = commitProfilingData.durations,</span>
            <span class="s0">effectDuration = commitProfilingData.effectDuration,</span>
            <span class="s0">maxActualDuration = commitProfilingData.maxActualDuration,</span>
            <span class="s0">passiveEffectDuration = commitProfilingData.passiveEffectDuration,</span>
            <span class="s0">priorityLevel = commitProfilingData.priorityLevel,</span>
            <span class="s0">commitTime = commitProfilingData.commitTime,</span>
            <span class="s0">updaters = commitProfilingData.updaters;</span>
        <span class="s1">var </span><span class="s0">fiberActualDurations = [];</span>
        <span class="s1">var </span><span class="s0">fiberSelfDurations = [];</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; durations.length; i += </span><span class="s4">3</span><span class="s0">) {</span>
          <span class="s1">var </span><span class="s0">fiberID = durations[i];</span>
          <span class="s0">fiberActualDurations.push([fiberID, durations[i + </span><span class="s4">1</span><span class="s0">]]);</span>
          <span class="s0">fiberSelfDurations.push([fiberID, durations[i + </span><span class="s4">2</span><span class="s0">]]);</span>
        <span class="s0">}</span>

        <span class="s0">commitData.push({</span>
          <span class="s0">changeDescriptions: changeDescriptions !== </span><span class="s1">null </span><span class="s0">? Array.from(changeDescriptions.entries()) : </span><span class="s1">null</span><span class="s0">,</span>
          <span class="s0">duration: maxActualDuration,</span>
          <span class="s0">effectDuration: effectDuration,</span>
          <span class="s0">fiberActualDurations: fiberActualDurations,</span>
          <span class="s0">fiberSelfDurations: fiberSelfDurations,</span>
          <span class="s0">passiveEffectDuration: passiveEffectDuration,</span>
          <span class="s0">priorityLevel: priorityLevel,</span>
          <span class="s0">timestamp: commitTime,</span>
          <span class="s0">updaters: updaters</span>
        <span class="s0">});</span>
      <span class="s0">});</span>
      <span class="s0">dataForRoots.push({</span>
        <span class="s0">commitData: commitData,</span>
        <span class="s0">displayName: displayName,</span>
        <span class="s0">initialTreeBaseDurations: initialTreeBaseDurations,</span>
        <span class="s0">rootID: rootID</span>
      <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s1">var </span><span class="s0">timelineData = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">getTimelineData === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">currentTimelineData = getTimelineData();</span>

      <span class="s1">if </span><span class="s0">(currentTimelineData) {</span>
        <span class="s1">var </span><span class="s0">batchUIDToMeasuresMap = currentTimelineData.batchUIDToMeasuresMap,</span>
            <span class="s0">internalModuleSourceToRanges = currentTimelineData.internalModuleSourceToRanges,</span>
            <span class="s0">laneToLabelMap = currentTimelineData.laneToLabelMap,</span>
            <span class="s0">laneToReactMeasureMap = currentTimelineData.laneToReactMeasureMap,</span>
            <span class="s0">rest = _objectWithoutProperties(currentTimelineData, [</span><span class="s2">&quot;batchUIDToMeasuresMap&quot;</span><span class="s0">, </span><span class="s2">&quot;internalModuleSourceToRanges&quot;</span><span class="s0">, </span><span class="s2">&quot;laneToLabelMap&quot;</span><span class="s0">, </span><span class="s2">&quot;laneToReactMeasureMap&quot;</span><span class="s0">]);</span>

        <span class="s0">timelineData = renderer_objectSpread(renderer_objectSpread({}, rest), {}, {</span>
          <span class="s3">// Most of the data is safe to parse as-is,</span>
          <span class="s3">// but we need to convert the nested Arrays back to Maps.</span>
          <span class="s3">// Most of the data is safe to serialize as-is,</span>
          <span class="s3">// but we need to convert the Maps to nested Arrays.</span>
          <span class="s0">batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),</span>
          <span class="s0">internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),</span>
          <span class="s0">laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),</span>
          <span class="s0">laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries())</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">dataForRoots: dataForRoots,</span>
      <span class="s0">rendererID: rendererID,</span>
      <span class="s0">timelineData: timelineData</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">startProfiling(shouldRecordChangeDescriptions) {</span>
    <span class="s1">if </span><span class="s0">(isProfiling) {</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">recordChangeDescriptions = shouldRecordChangeDescriptions; </span><span class="s3">// Capture initial values as of the time profiling starts.</span>
    <span class="s3">// It's important we snapshot both the durations and the id-to-root map,</span>
    <span class="s3">// since either of these may change during the profiling session</span>
    <span class="s3">// (e.g. when a fiber is re-rendered or when a fiber gets removed).</span>

    <span class="s0">displayNamesByRootID = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s0">initialTreeBaseDurationsMap = </span><span class="s1">new </span><span class="s0">Map(idToTreeBaseDurationMap);</span>
    <span class="s0">initialIDToRootMap = </span><span class="s1">new </span><span class="s0">Map(idToRootMap);</span>
    <span class="s0">idToContextsMap = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s0">hook.getFiberRoots(rendererID).forEach(</span><span class="s1">function </span><span class="s0">(root) {</span>
      <span class="s1">var </span><span class="s0">rootID = getFiberIDThrows(root.current);</span>
      <span class="s0">displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));</span>

      <span class="s1">if </span><span class="s0">(shouldRecordChangeDescriptions) {</span>
        <span class="s3">// Record all contexts at the time profiling is started.</span>
        <span class="s3">// Fibers only store the current context value,</span>
        <span class="s3">// so we need to track them separately in order to determine changed keys.</span>
        <span class="s0">crawlToInitializeContextsMap(root.current);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">isProfiling = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">profilingStartTime = renderer_getCurrentTime();</span>
    <span class="s0">rootToCommitProfilingMetadataMap = </span><span class="s1">new </span><span class="s0">Map();</span>

    <span class="s1">if </span><span class="s0">(toggleProfilingStatus !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">toggleProfilingStatus(</span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">stopProfiling() {</span>
    <span class="s0">isProfiling = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">recordChangeDescriptions = </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(toggleProfilingStatus !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">toggleProfilingStatus(</span><span class="s1">false</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Automatically start profiling so that we don't miss timing info from initial &quot;mount&quot;.</span>


  <span class="s1">if </span><span class="s0">(sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === </span><span class="s2">'true'</span><span class="s0">) {</span>
    <span class="s0">startProfiling(sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === </span><span class="s2">'true'</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s3">// React will switch between these implementations depending on whether</span>
  <span class="s3">// we have any manually suspended/errored-out Fibers or not.</span>


  <span class="s1">function </span><span class="s0">shouldErrorFiberAlwaysNull() {</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// Map of id and its force error status: true (error), false (toggled off),</span>
  <span class="s3">// null (do nothing)</span>


  <span class="s1">var </span><span class="s0">forceErrorForFiberIDs = </span><span class="s1">new </span><span class="s0">Map();</span>

  <span class="s1">function </span><span class="s0">shouldErrorFiberAccordingToMap(fiber) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">setErrorHandler !== </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected overrideError() to not get called for earlier React versions.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">id = getFiberIDUnsafe(fiber);</span>

    <span class="s1">if </span><span class="s0">(id === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">status = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(forceErrorForFiberIDs.has(id)) {</span>
      <span class="s0">status = forceErrorForFiberIDs.get(id);</span>

      <span class="s1">if </span><span class="s0">(status === </span><span class="s1">false</span><span class="s0">) {</span>
        <span class="s3">// TRICKY overrideError adds entries to this Map,</span>
        <span class="s3">// so ideally it would be the method that clears them too,</span>
        <span class="s3">// but that would break the functionality of the feature,</span>
        <span class="s3">// since DevTools needs to tell React to act differently than it normally would</span>
        <span class="s3">// (don't just re-render the failed boundary, but reset its errored state too).</span>
        <span class="s3">// So we can only clear it after telling React to reset the state.</span>
        <span class="s3">// Technically this is premature and we should schedule it for later,</span>
        <span class="s3">// since the render could always fail without committing the updated error boundary,</span>
        <span class="s3">// but since this is a DEV-only feature, the simplicity is worth the trade off.</span>
        <span class="s0">forceErrorForFiberIDs.</span><span class="s1">delete</span><span class="s0">(id);</span>

        <span class="s1">if </span><span class="s0">(forceErrorForFiberIDs.size === </span><span class="s4">0</span><span class="s0">) {</span>
          <span class="s3">// Last override is gone. Switch React back to fast path.</span>
          <span class="s0">setErrorHandler(shouldErrorFiberAlwaysNull);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">status;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">overrideError(id, forceError) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">setErrorHandler !== </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">scheduleUpdate !== </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected overrideError() to not get called for earlier React versions.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">forceErrorForFiberIDs.set(id, forceError);</span>

    <span class="s1">if </span><span class="s0">(forceErrorForFiberIDs.size === </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s3">// First override is added. Switch React to slower path.</span>
      <span class="s0">setErrorHandler(shouldErrorFiberAccordingToMap);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(fiber != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">scheduleUpdate(fiber);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">shouldSuspendFiberAlwaysFalse() {</span>
    <span class="s1">return false</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">forceFallbackForSuspenseIDs = </span><span class="s1">new </span><span class="s0">Set();</span>

  <span class="s1">function </span><span class="s0">shouldSuspendFiberAccordingToSet(fiber) {</span>
    <span class="s1">var </span><span class="s0">maybeID = getFiberIDUnsafe(fiber);</span>
    <span class="s1">return </span><span class="s0">maybeID !== </span><span class="s1">null </span><span class="s0">&amp;&amp; forceFallbackForSuspenseIDs.has(maybeID);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">overrideSuspense(id, forceFallback) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">setSuspenseHandler !== </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">scheduleUpdate !== </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected overrideSuspense() to not get called for earlier React versions.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(forceFallback) {</span>
      <span class="s0">forceFallbackForSuspenseIDs.add(id);</span>

      <span class="s1">if </span><span class="s0">(forceFallbackForSuspenseIDs.size === </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s3">// First override is added. Switch React to slower path.</span>
        <span class="s0">setSuspenseHandler(shouldSuspendFiberAccordingToSet);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">forceFallbackForSuspenseIDs.</span><span class="s1">delete</span><span class="s0">(id);</span>

      <span class="s1">if </span><span class="s0">(forceFallbackForSuspenseIDs.size === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s3">// Last override is gone. Switch React back to fast path.</span>
        <span class="s0">setSuspenseHandler(shouldSuspendFiberAlwaysFalse);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(fiber != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">scheduleUpdate(fiber);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Remember if we're trying to restore the selection after reload.</span>
  <span class="s3">// In that case, we'll do some extra checks for matching mounts.</span>


  <span class="s1">var </span><span class="s0">trackedPath = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">trackedPathMatchFiber = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">trackedPathMatchDepth = -</span><span class="s4">1</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">mightBeOnTrackedPath = </span><span class="s1">false</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">setTrackedPath(path) {</span>
    <span class="s1">if </span><span class="s0">(path === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">trackedPathMatchFiber = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">trackedPathMatchDepth = -</span><span class="s4">1</span><span class="s0">;</span>
      <span class="s0">mightBeOnTrackedPath = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">trackedPath = path;</span>
  <span class="s0">} </span><span class="s3">// We call this before traversing a new mount.</span>
  <span class="s3">// It remembers whether this Fiber is the next best match for tracked path.</span>
  <span class="s3">// The return value signals whether we should keep matching siblings or not.</span>


  <span class="s1">function </span><span class="s0">updateTrackedPathStateBeforeMount(fiber) {</span>
    <span class="s1">if </span><span class="s0">(trackedPath === </span><span class="s1">null </span><span class="s0">|| !mightBeOnTrackedPath) {</span>
      <span class="s3">// Fast path: there's nothing to track so do nothing and ignore siblings.</span>
      <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">returnFiber = fiber.</span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">returnAlternate = returnFiber !== </span><span class="s1">null </span><span class="s0">? returnFiber.alternate : </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// By now we know there's some selection to restore, and this is a new Fiber.</span>
    <span class="s3">// Is this newly mounted Fiber a direct child of the current best match?</span>
    <span class="s3">// (This will also be true for new roots if we haven't matched anything yet.)</span>

    <span class="s1">if </span><span class="s0">(trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate &amp;&amp; returnAlternate !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Is this the next Fiber we should select? Let's compare the frames.</span>
      <span class="s1">var </span><span class="s0">actualFrame = getPathFrame(fiber); </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>

      <span class="s1">var </span><span class="s0">expectedFrame = trackedPath[trackedPathMatchDepth + </span><span class="s4">1</span><span class="s0">];</span>

      <span class="s1">if </span><span class="s0">(expectedFrame === undefined) {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected to see a frame at the next depth.'</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(actualFrame.index === expectedFrame.index &amp;&amp; actualFrame.key === expectedFrame.key &amp;&amp; actualFrame.displayName === expectedFrame.displayName) {</span>
        <span class="s3">// We have our next match.</span>
        <span class="s0">trackedPathMatchFiber = fiber;</span>
        <span class="s0">trackedPathMatchDepth++; </span><span class="s3">// Are we out of frames to match?</span>
        <span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>

        <span class="s1">if </span><span class="s0">(trackedPathMatchDepth === trackedPath.length - </span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s3">// There's nothing that can possibly match afterwards.</span>
          <span class="s3">// Don't check the children.</span>
          <span class="s0">mightBeOnTrackedPath = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s3">// Check the children, as they might reveal the next match.</span>
          <span class="s0">mightBeOnTrackedPath = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">// In either case, since we have a match, we don't need</span>
        <span class="s3">// to check the siblings. They'll never match.</span>


        <span class="s1">return false</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">// This Fiber's parent is on the path, but this Fiber itself isn't.</span>
    <span class="s3">// There's no need to check its children--they won't be on the path either.</span>


    <span class="s0">mightBeOnTrackedPath = </span><span class="s1">false</span><span class="s0">; </span><span class="s3">// However, one of its siblings may be on the path so keep searching.</span>

    <span class="s1">return true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {</span>
    <span class="s3">// updateTrackedPathStateBeforeMount() told us whether to match siblings.</span>
    <span class="s3">// Now that we're entering siblings, let's use that information.</span>
    <span class="s0">mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;</span>
  <span class="s0">} </span><span class="s3">// Roots don't have a real persistent identity.</span>
  <span class="s3">// A root's &quot;pseudo key&quot; is &quot;childDisplayName:indexWithThatName&quot;.</span>
  <span class="s3">// For example, &quot;App:0&quot; or, in case of similar roots, &quot;Story:0&quot;, &quot;Story:1&quot;, etc.</span>
  <span class="s3">// We will use this to try to disambiguate roots when restoring selection between reloads.</span>


  <span class="s1">var </span><span class="s0">rootPseudoKeys = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">rootDisplayNameCounter = </span><span class="s1">new </span><span class="s0">Map();</span>

  <span class="s1">function </span><span class="s0">setRootPseudoKey(id, fiber) {</span>
    <span class="s1">var </span><span class="s0">name = getDisplayNameForRoot(fiber);</span>
    <span class="s1">var </span><span class="s0">counter = rootDisplayNameCounter.get(name) || </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">rootDisplayNameCounter.set(name, counter + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">pseudoKey = </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(name, </span><span class="s2">&quot;:&quot;</span><span class="s0">).concat(counter);</span>
    <span class="s0">rootPseudoKeys.set(id, pseudoKey);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">removeRootPseudoKey(id) {</span>
    <span class="s1">var </span><span class="s0">pseudoKey = rootPseudoKeys.get(id);</span>

    <span class="s1">if </span><span class="s0">(pseudoKey === undefined) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected root pseudo key to be known.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">name = pseudoKey.slice(</span><span class="s4">0</span><span class="s0">, pseudoKey.lastIndexOf(</span><span class="s2">':'</span><span class="s0">));</span>
    <span class="s1">var </span><span class="s0">counter = rootDisplayNameCounter.get(name);</span>

    <span class="s1">if </span><span class="s0">(counter === undefined) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected counter to be known.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(counter &gt; </span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">rootDisplayNameCounter.set(name, counter - </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">rootDisplayNameCounter.</span><span class="s1">delete</span><span class="s0">(name);</span>
    <span class="s0">}</span>

    <span class="s0">rootPseudoKeys.</span><span class="s1">delete</span><span class="s0">(id);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getDisplayNameForRoot(fiber) {</span>
    <span class="s1">var </span><span class="s0">preferredDisplayName = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">fallbackDisplayName = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">child = fiber.child; </span><span class="s3">// Go at most three levels deep into direct children</span>
    <span class="s3">// while searching for a child that has a displayName.</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s4">3</span><span class="s0">; i++) {</span>
      <span class="s1">if </span><span class="s0">(child === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">var </span><span class="s0">displayName = getDisplayNameForFiber(child);</span>

      <span class="s1">if </span><span class="s0">(displayName !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// Prefer display names that we get from user-defined components.</span>
        <span class="s3">// We want to avoid using e.g. 'Suspense' unless we find nothing else.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">child.type === </span><span class="s2">'function'</span><span class="s0">) {</span>
          <span class="s3">// There's a few user-defined tags, but we'll prefer the ones</span>
          <span class="s3">// that are usually explicitly named (function or class components).</span>
          <span class="s0">preferredDisplayName = displayName;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(fallbackDisplayName === </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">fallbackDisplayName = displayName;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(preferredDisplayName !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">child = child.child;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">preferredDisplayName || fallbackDisplayName || </span><span class="s2">'Anonymous'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getPathFrame(fiber) {</span>
    <span class="s1">var </span><span class="s0">key = fiber.key;</span>
    <span class="s1">var </span><span class="s0">displayName = getDisplayNameForFiber(fiber);</span>
    <span class="s1">var </span><span class="s0">index = fiber.index;</span>

    <span class="s1">switch </span><span class="s0">(fiber.tag) {</span>
      <span class="s1">case </span><span class="s0">HostRoot:</span>
        <span class="s3">// Roots don't have a real displayName, index, or key.</span>
        <span class="s3">// Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).</span>
        <span class="s1">var </span><span class="s0">id = getFiberIDThrows(fiber);</span>
        <span class="s1">var </span><span class="s0">pseudoKey = rootPseudoKeys.get(id);</span>

        <span class="s1">if </span><span class="s0">(pseudoKey === undefined) {</span>
          <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected mounted root to have known pseudo key.'</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s0">displayName = pseudoKey;</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">HostComponent:</span>
        <span class="s0">displayName = fiber.type;</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">displayName: displayName,</span>
      <span class="s0">key: key,</span>
      <span class="s0">index: index</span>
    <span class="s0">};</span>
  <span class="s0">} </span><span class="s3">// Produces a serializable representation that does a best effort</span>
  <span class="s3">// of identifying a particular Fiber between page reloads.</span>
  <span class="s3">// The return path will contain Fibers that are &quot;invisible&quot; to the store</span>
  <span class="s3">// because their keys and indexes are important to restoring the selection.</span>


  <span class="s1">function </span><span class="s0">getPathForElement(id) {</span>
    <span class="s1">var </span><span class="s0">fiber = idToArbitraryFiberMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(fiber == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">keyPath = [];</span>

    <span class="s1">while </span><span class="s0">(fiber !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// $FlowFixMe[incompatible-call] found when upgrading Flow</span>
      <span class="s0">keyPath.push(getPathFrame(fiber)); </span><span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>

      <span class="s0">fiber = fiber.</span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">keyPath.reverse();</span>
    <span class="s1">return </span><span class="s0">keyPath;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getBestMatchForTrackedPath() {</span>
    <span class="s1">if </span><span class="s0">(trackedPath === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Nothing to match.</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(trackedPathMatchFiber === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// We didn't find anything.</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s3">// Find the closest Fiber store is aware of.</span>


    <span class="s1">var </span><span class="s0">fiber = trackedPathMatchFiber;</span>

    <span class="s1">while </span><span class="s0">(fiber !== </span><span class="s1">null </span><span class="s0">&amp;&amp; shouldFilterFiber(fiber)) {</span>
      <span class="s0">fiber = fiber.</span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(fiber === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">id: getFiberIDThrows(fiber),</span>
      <span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
      <span class="s0">isFullMatch: trackedPathMatchDepth === trackedPath.length - </span><span class="s4">1</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">formatPriorityLevel = </span><span class="s1">function </span><span class="s0">formatPriorityLevel(priorityLevel) {</span>
    <span class="s1">if </span><span class="s0">(priorityLevel == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s2">'Unknown'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">switch </span><span class="s0">(priorityLevel) {</span>
      <span class="s1">case </span><span class="s0">ImmediatePriority:</span>
        <span class="s1">return </span><span class="s2">'Immediate'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">UserBlockingPriority:</span>
        <span class="s1">return </span><span class="s2">'User-Blocking'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">NormalPriority:</span>
        <span class="s1">return </span><span class="s2">'Normal'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">LowPriority:</span>
        <span class="s1">return </span><span class="s2">'Low'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">IdlePriority:</span>
        <span class="s1">return </span><span class="s2">'Idle'</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">NoPriority:</span>
      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">return </span><span class="s2">'Unknown'</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">};</span>

  <span class="s1">function </span><span class="s0">setTraceUpdatesEnabled(isEnabled) {</span>
    <span class="s0">traceUpdatesEnabled = isEnabled;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">hasFiberWithId(id) {</span>
    <span class="s1">return </span><span class="s0">idToArbitraryFiberMap.has(id);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">cleanup: cleanup,</span>
    <span class="s0">clearErrorsAndWarnings: clearErrorsAndWarnings,</span>
    <span class="s0">clearErrorsForFiberID: clearErrorsForFiberID,</span>
    <span class="s0">clearWarningsForFiberID: clearWarningsForFiberID,</span>
    <span class="s0">getSerializedElementValueByPath: getSerializedElementValueByPath,</span>
    <span class="s0">deletePath: deletePath,</span>
    <span class="s0">findNativeNodesForFiberID: findNativeNodesForFiberID,</span>
    <span class="s0">flushInitialOperations: flushInitialOperations,</span>
    <span class="s0">getBestMatchForTrackedPath: getBestMatchForTrackedPath,</span>
    <span class="s0">getDisplayNameForFiberID: getDisplayNameForFiberID,</span>
    <span class="s0">getFiberForNative: getFiberForNative,</span>
    <span class="s0">getFiberIDForNative: getFiberIDForNative,</span>
    <span class="s0">getInstanceAndStyle: getInstanceAndStyle,</span>
    <span class="s0">getOwnersList: getOwnersList,</span>
    <span class="s0">getPathForElement: getPathForElement,</span>
    <span class="s0">getProfilingData: getProfilingData,</span>
    <span class="s0">handleCommitFiberRoot: handleCommitFiberRoot,</span>
    <span class="s0">handleCommitFiberUnmount: handleCommitFiberUnmount,</span>
    <span class="s0">handlePostCommitFiberRoot: handlePostCommitFiberRoot,</span>
    <span class="s0">hasFiberWithId: hasFiberWithId,</span>
    <span class="s0">inspectElement: inspectElement,</span>
    <span class="s0">logElementToConsole: logElementToConsole,</span>
    <span class="s0">patchConsoleForStrictMode: patchForStrictMode,</span>
    <span class="s0">prepareViewAttributeSource: prepareViewAttributeSource,</span>
    <span class="s0">prepareViewElementSource: prepareViewElementSource,</span>
    <span class="s0">overrideError: overrideError,</span>
    <span class="s0">overrideSuspense: overrideSuspense,</span>
    <span class="s0">overrideValueAtPath: overrideValueAtPath,</span>
    <span class="s0">renamePath: renamePath,</span>
    <span class="s0">renderer: renderer,</span>
    <span class="s0">setTraceUpdatesEnabled: setTraceUpdatesEnabled,</span>
    <span class="s0">setTrackedPath: setTrackedPath,</span>
    <span class="s0">startProfiling: startProfiling,</span>
    <span class="s0">stopProfiling: stopProfiling,</span>
    <span class="s0">storeAsGlobal: storeAsGlobal,</span>
    <span class="s0">unpatchConsoleForStrictMode: unpatchForStrictMode,</span>
    <span class="s0">updateComponentFilters: updateComponentFilters</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/console.js</span>
<span class="s1">function </span><span class="s0">console_toConsumableArray(arr) { </span><span class="s1">return </span><span class="s0">console_arrayWithoutHoles(arr) || console_iterableToArray(arr) || console_unsupportedIterableToArray(arr) || console_nonIterableSpread(); }</span>

<span class="s1">function </span><span class="s0">console_nonIterableSpread() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to spread non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">console_iterableToArray(iter) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">&amp;&amp; Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(iter)) </span><span class="s1">return </span><span class="s0">Array.from(iter); }</span>

<span class="s1">function </span><span class="s0">console_arrayWithoutHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">console_arrayLikeToArray(arr); }</span>

<span class="s1">function </span><span class="s0">console_createForOfIteratorHelper(o, allowArrayLike) { </span><span class="s1">var </span><span class="s0">it; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">|| o[Symbol.iterator] == </span><span class="s1">null</span><span class="s0">) { </span><span class="s1">if </span><span class="s0">(Array.isArray(o) || (it = console_unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; </span><span class="s1">typeof </span><span class="s0">o.length === </span><span class="s2">&quot;number&quot;</span><span class="s0">) { </span><span class="s1">if </span><span class="s0">(it) o = it; </span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">var </span><span class="s0">F = </span><span class="s1">function </span><span class="s0">F() {}; </span><span class="s1">return </span><span class="s0">{ s: F, n: </span><span class="s1">function </span><span class="s0">n() { </span><span class="s1">if </span><span class="s0">(i &gt;= o.length) </span><span class="s1">return </span><span class="s0">{ done: </span><span class="s1">true </span><span class="s0">}; </span><span class="s1">return </span><span class="s0">{ done: </span><span class="s1">false</span><span class="s0">, value: o[i++] }; }, e: </span><span class="s1">function </span><span class="s0">e(_e) { </span><span class="s1">throw </span><span class="s0">_e; }, f: F }; } </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to iterate non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); } </span><span class="s1">var </span><span class="s0">normalCompletion = </span><span class="s1">true</span><span class="s0">, didErr = </span><span class="s1">false</span><span class="s0">, err; </span><span class="s1">return </span><span class="s0">{ s: </span><span class="s1">function </span><span class="s0">s() { it = o[Symbol.iterator](); }, n: </span><span class="s1">function </span><span class="s0">n() { </span><span class="s1">var </span><span class="s0">step = it.next(); normalCompletion = step.done; </span><span class="s1">return </span><span class="s0">step; }, e: </span><span class="s1">function </span><span class="s0">e(_e2) { didErr = </span><span class="s1">true</span><span class="s0">; err = _e2; }, f: </span><span class="s1">function </span><span class="s0">f() { </span><span class="s1">try </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(!normalCompletion &amp;&amp; it.</span><span class="s1">return </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) it.</span><span class="s1">return</span><span class="s0">(); } </span><span class="s1">finally </span><span class="s0">{ </span><span class="s1">if </span><span class="s0">(didErr) </span><span class="s1">throw </span><span class="s0">err; } } }; }</span>

<span class="s1">function </span><span class="s0">console_unsupportedIterableToArray(o, minLen) { </span><span class="s1">if </span><span class="s0">(!o) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">o === </span><span class="s2">&quot;string&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">console_arrayLikeToArray(o, minLen); </span><span class="s1">var </span><span class="s0">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s0">&amp;&amp; o.constructor) n = o.constructor.name; </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s0">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">Array.from(o); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s0">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s0">|</span><span class="s4">16</span><span class="s0">|</span><span class="s4">32</span><span class="s0">)(?:Clamped)?Array$/.test(n)) </span><span class="s1">return </span><span class="s0">console_arrayLikeToArray(o, minLen); }</span>

<span class="s1">function </span><span class="s0">console_arrayLikeToArray(arr, len) { </span><span class="s1">if </span><span class="s0">(len == </span><span class="s1">null </span><span class="s0">|| len &gt; arr.length) len = arr.length; </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, arr2 = </span><span class="s1">new </span><span class="s0">Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } </span><span class="s1">return </span><span class="s0">arr2; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>





<span class="s1">var </span><span class="s0">OVERRIDE_CONSOLE_METHODS = [</span><span class="s2">'error'</span><span class="s0">, </span><span class="s2">'trace'</span><span class="s0">, </span><span class="s2">'warn'</span><span class="s0">];</span>
<span class="s1">var </span><span class="s0">DIMMED_NODE_CONSOLE_COLOR = </span><span class="s2">'</span><span class="s5">\x</span><span class="s2">1b[2m%s</span><span class="s5">\x</span><span class="s2">1b[0m'</span><span class="s0">; </span><span class="s3">// React's custom built component stack strings match &quot;\s{4}in&quot;</span>
<span class="s3">// Chrome's prefix matches &quot;\s{4}at&quot;</span>

<span class="s1">var </span><span class="s0">PREFIX_REGEX = /\s{</span><span class="s4">4</span><span class="s0">}(</span><span class="s1">in</span><span class="s0">|at)\s{</span><span class="s4">1</span><span class="s0">}/; </span><span class="s3">// Firefox and Safari have no prefix (&quot;&quot;)</span>
<span class="s3">// but we can fallback to looking for location info (e.g. &quot;foo.js:12:345&quot;)</span>

<span class="s1">var </span><span class="s0">ROW_COLUMN_NUMBER_REGEX = /:\d+:\d+(\n|$)/;</span>
<span class="s1">function </span><span class="s0">isStringComponentStack(text) {</span>
  <span class="s1">return </span><span class="s0">PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);</span>
<span class="s0">}</span>
<span class="s1">var </span><span class="s0">STYLE_DIRECTIVE_REGEX = /^%c/; </span><span class="s3">// This function tells whether or not the arguments for a console</span>
<span class="s3">// method has been overridden by the patchForStrictMode function.</span>
<span class="s3">// If it has we'll need to do some special formatting of the arguments</span>
<span class="s3">// so the console color stays consistent</span>

<span class="s1">function </span><span class="s0">isStrictModeOverride(args, method) {</span>
  <span class="s1">return </span><span class="s0">args.length &gt;= </span><span class="s4">2 </span><span class="s0">&amp;&amp; STYLE_DIRECTIVE_REGEX.test(args[</span><span class="s4">0</span><span class="s0">]) &amp;&amp; args[</span><span class="s4">1</span><span class="s0">] === </span><span class="s2">&quot;color: &quot;</span><span class="s0">.concat(getConsoleColor(method) || </span><span class="s2">''</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">getConsoleColor(method) {</span>
  <span class="s1">switch </span><span class="s0">(method) {</span>
    <span class="s1">case </span><span class="s2">'warn'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">consoleSettingsRef.browserTheme === </span><span class="s2">'light' </span><span class="s0">? </span><span class="s2">&quot;rgba(250, 180, 50, 0.75)&quot; </span><span class="s0">: </span><span class="s2">&quot;rgba(250, 180, 50, 0.5)&quot;</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">'error'</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">consoleSettingsRef.browserTheme === </span><span class="s2">'light' </span><span class="s0">? </span><span class="s2">&quot;rgba(250, 123, 130, 0.75)&quot; </span><span class="s0">: </span><span class="s2">&quot;rgba(250, 123, 130, 0.5)&quot;</span><span class="s0">;</span>

    <span class="s1">case </span><span class="s2">'log'</span><span class="s0">:</span>
    <span class="s1">default</span><span class="s0">:</span>
      <span class="s1">return </span><span class="s0">consoleSettingsRef.browserTheme === </span><span class="s2">'light' </span><span class="s0">? </span><span class="s2">&quot;rgba(125, 125, 125, 0.75)&quot; </span><span class="s0">: </span><span class="s2">&quot;rgba(125, 125, 125, 0.5)&quot;</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">injectedRenderers = </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s1">var </span><span class="s0">targetConsole = console;</span>
<span class="s1">var </span><span class="s0">targetConsoleMethods = {};</span>

<span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">method </span><span class="s1">in </span><span class="s0">console) {</span>
  <span class="s0">targetConsoleMethods[method] = console[method];</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">unpatchFn = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">isNode = </span><span class="s1">false</span><span class="s0">;</span>

<span class="s1">try </span><span class="s0">{</span>
  <span class="s0">isNode = undefined === global;</span>
<span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {} </span><span class="s3">// Enables e.g. Jest tests to inject a mock console object.</span>


<span class="s1">function </span><span class="s0">dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {</span>
  <span class="s0">targetConsole = targetConsoleForTesting;</span>
  <span class="s0">targetConsoleMethods = {};</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_method </span><span class="s1">in </span><span class="s0">targetConsole) {</span>
    <span class="s0">targetConsoleMethods[_method] = console[_method];</span>
  <span class="s0">}</span>
<span class="s0">} </span><span class="s3">// v16 renderers should use this method to inject internals necessary to generate a component stack.</span>
<span class="s3">// These internals will be used if the console is patched.</span>
<span class="s3">// Injecting them separately allows the console to easily be patched or un-patched later (at runtime).</span>

<span class="s1">function </span><span class="s0">registerRenderer(renderer, onErrorOrWarning) {</span>
  <span class="s1">var </span><span class="s0">currentDispatcherRef = renderer.currentDispatcherRef,</span>
      <span class="s0">getCurrentFiber = renderer.getCurrentFiber,</span>
      <span class="s0">findFiberByHostInstance = renderer.findFiberByHostInstance,</span>
      <span class="s0">version = renderer.version; </span><span class="s3">// Ignore React v15 and older because they don't expose a component stack anyway.</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">findFiberByHostInstance !== </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// currentDispatcherRef gets injected for v16.8+ to support hooks inspection.</span>
  <span class="s3">// getCurrentFiber gets injected for v16.9+.</span>


  <span class="s1">if </span><span class="s0">(currentDispatcherRef != </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">getCurrentFiber === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">_getInternalReactCons = getInternalReactConstants(version),</span>
        <span class="s0">ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork;</span>

    <span class="s0">injectedRenderers.set(renderer, {</span>
      <span class="s0">currentDispatcherRef: currentDispatcherRef,</span>
      <span class="s0">getCurrentFiber: getCurrentFiber,</span>
      <span class="s0">workTagMap: ReactTypeOfWork,</span>
      <span class="s0">onErrorOrWarning: onErrorOrWarning</span>
    <span class="s0">});</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">var </span><span class="s0">consoleSettingsRef = {</span>
  <span class="s0">appendComponentStack: </span><span class="s1">false</span><span class="s0">,</span>
  <span class="s0">breakOnConsoleErrors: </span><span class="s1">false</span><span class="s0">,</span>
  <span class="s0">showInlineWarningsAndErrors: </span><span class="s1">false</span><span class="s0">,</span>
  <span class="s0">hideConsoleLogsInStrictMode: </span><span class="s1">false</span><span class="s0">,</span>
  <span class="s0">browserTheme: </span><span class="s2">'dark'</span>
<span class="s0">}; </span><span class="s3">// Patches console methods to append component stack for the current fiber.</span>
<span class="s3">// Call unpatch() to remove the injected behavior.</span>

<span class="s1">function </span><span class="s0">patch(_ref) {</span>
  <span class="s1">var </span><span class="s0">appendComponentStack = _ref.appendComponentStack,</span>
      <span class="s0">breakOnConsoleErrors = _ref.breakOnConsoleErrors,</span>
      <span class="s0">showInlineWarningsAndErrors = _ref.showInlineWarningsAndErrors,</span>
      <span class="s0">hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode,</span>
      <span class="s0">browserTheme = _ref.browserTheme;</span>
  <span class="s3">// Settings may change after we've patched the console.</span>
  <span class="s3">// Using a shared ref allows the patch function to read the latest values.</span>
  <span class="s0">consoleSettingsRef.appendComponentStack = appendComponentStack;</span>
  <span class="s0">consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;</span>
  <span class="s0">consoleSettingsRef.showInlineWarningsAndErrors = showInlineWarningsAndErrors;</span>
  <span class="s0">consoleSettingsRef.hideConsoleLogsInStrictMode = hideConsoleLogsInStrictMode;</span>
  <span class="s0">consoleSettingsRef.browserTheme = browserTheme;</span>

  <span class="s1">if </span><span class="s0">(appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {</span>
    <span class="s1">if </span><span class="s0">(unpatchFn !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Don't patch twice.</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">originalConsoleMethods = {};</span>

    <span class="s0">unpatchFn = </span><span class="s1">function </span><span class="s0">unpatchFn() {</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_method2 </span><span class="s1">in </span><span class="s0">originalConsoleMethods) {</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s0">targetConsole[_method2] = originalConsoleMethods[_method2];</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
      <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s0">OVERRIDE_CONSOLE_METHODS.forEach(</span><span class="s1">function </span><span class="s0">(method) {</span>
      <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ : targetConsole[method]; </span><span class="s3">// $FlowFixMe[missing-local-annot]</span>

        <span class="s1">var </span><span class="s0">overrideMethod = </span><span class="s1">function </span><span class="s0">overrideMethod() {</span>
          <span class="s1">var </span><span class="s0">shouldAppendWarningStack = </span><span class="s1">false</span><span class="s0">;</span>

          <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, args = </span><span class="s1">new </span><span class="s0">Array(_len), _key = </span><span class="s4">0</span><span class="s0">; _key &lt; _len; _key++) {</span>
            <span class="s0">args[_key] = arguments[_key];</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(method !== </span><span class="s2">'log'</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(consoleSettingsRef.appendComponentStack) {</span>
              <span class="s1">var </span><span class="s0">lastArg = args.length &gt; </span><span class="s4">0 </span><span class="s0">? args[args.length - </span><span class="s4">1</span><span class="s0">] : </span><span class="s1">null</span><span class="s0">;</span>
              <span class="s1">var </span><span class="s0">alreadyHasComponentStack = </span><span class="s1">typeof </span><span class="s0">lastArg === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; isStringComponentStack(lastArg); </span><span class="s3">// If we are ever called with a string that already has a component stack,</span>
              <span class="s3">// e.g. a React error/warning, don't append a second stack.</span>

              <span class="s0">shouldAppendWarningStack = !alreadyHasComponentStack;</span>
            <span class="s0">}</span>
          <span class="s0">}</span>

          <span class="s1">var </span><span class="s0">shouldShowInlineWarningsAndErrors = consoleSettingsRef.showInlineWarningsAndErrors &amp;&amp; (method === </span><span class="s2">'error' </span><span class="s0">|| method === </span><span class="s2">'warn'</span><span class="s0">); </span><span class="s3">// Search for the first renderer that has a current Fiber.</span>
          <span class="s3">// We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)</span>
          <span class="s3">// eslint-disable-next-line no-for-of-loops/no-for-of-loops</span>

          <span class="s1">var </span><span class="s0">_iterator = console_createForOfIteratorHelper(injectedRenderers.values()),</span>
              <span class="s0">_step;</span>

          <span class="s1">try </span><span class="s0">{</span>
            <span class="s1">for </span><span class="s0">(_iterator.s(); !(_step = _iterator.n()).done;) {</span>
              <span class="s1">var </span><span class="s0">_step$value = _step.value,</span>
                  <span class="s0">currentDispatcherRef = _step$value.currentDispatcherRef,</span>
                  <span class="s0">getCurrentFiber = _step$value.getCurrentFiber,</span>
                  <span class="s0">onErrorOrWarning = _step$value.onErrorOrWarning,</span>
                  <span class="s0">workTagMap = _step$value.workTagMap;</span>
              <span class="s1">var </span><span class="s0">current = getCurrentFiber();</span>

              <span class="s1">if </span><span class="s0">(current != </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">try </span><span class="s0">{</span>
                  <span class="s1">if </span><span class="s0">(shouldShowInlineWarningsAndErrors) {</span>
                    <span class="s3">// patch() is called by two places: (1) the hook and (2) the renderer backend.</span>
                    <span class="s3">// The backend is what implements a message queue, so it's the only one that injects onErrorOrWarning.</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">onErrorOrWarning === </span><span class="s2">'function'</span><span class="s0">) {</span>
                      <span class="s0">onErrorOrWarning(current, method, </span><span class="s3">// Copy args before we mutate them (e.g. adding the component stack)</span>
                      <span class="s0">args.slice());</span>
                    <span class="s0">}</span>
                  <span class="s0">}</span>

                  <span class="s1">if </span><span class="s0">(shouldAppendWarningStack) {</span>
                    <span class="s1">var </span><span class="s0">componentStack = getStackByFiberInDevAndProd(workTagMap, current, currentDispatcherRef);</span>

                    <span class="s1">if </span><span class="s0">(componentStack !== </span><span class="s2">''</span><span class="s0">) {</span>
                      <span class="s1">if </span><span class="s0">(isStrictModeOverride(args, method)) {</span>
                        <span class="s0">args[</span><span class="s4">0</span><span class="s0">] = </span><span class="s2">&quot;&quot;</span><span class="s0">.concat(args[</span><span class="s4">0</span><span class="s0">], </span><span class="s2">&quot; %s&quot;</span><span class="s0">);</span>
                        <span class="s0">args.push(componentStack);</span>
                      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">args.push(componentStack);</span>
                      <span class="s0">}</span>
                    <span class="s0">}</span>
                  <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
                  <span class="s3">// Don't let a DevTools or React internal error interfere with logging.</span>
                  <span class="s0">setTimeout(</span><span class="s1">function </span><span class="s0">() {</span>
                    <span class="s1">throw </span><span class="s0">error;</span>
                  <span class="s0">}, </span><span class="s4">0</span><span class="s0">);</span>
                <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
                  <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
              <span class="s0">}</span>
            <span class="s0">}</span>
          <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
            <span class="s0">_iterator.e(err);</span>
          <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
            <span class="s0">_iterator.f();</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(consoleSettingsRef.breakOnConsoleErrors) {</span>
            <span class="s3">// --- Welcome to debugging with React DevTools ---</span>
            <span class="s3">// This debugger statement means that you've enabled the &quot;break on warnings&quot; feature.</span>
            <span class="s3">// Use the browser's Call Stack panel to step out of this override function-</span>
            <span class="s3">// to where the original warning or error was logged.</span>
            <span class="s3">// eslint-disable-next-line no-debugger</span>
            <span class="s0">debugger;</span>
          <span class="s0">}</span>

          <span class="s0">originalMethod.apply(</span><span class="s1">void </span><span class="s4">0</span><span class="s0">, args);</span>
        <span class="s0">};</span>

        <span class="s0">overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod;</span>
        <span class="s0">originalMethod.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = overrideMethod;</span>
        <span class="s0">targetConsole[method] = overrideMethod;</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">unpatch();</span>
  <span class="s0">}</span>
<span class="s0">} </span><span class="s3">// Removed component stack patch from console methods.</span>

<span class="s1">function </span><span class="s0">unpatch() {</span>
  <span class="s1">if </span><span class="s0">(unpatchFn !== </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">unpatchFn();</span>
    <span class="s0">unpatchFn = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">var </span><span class="s0">unpatchForStrictModeFn = </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// NOTE: KEEP IN SYNC with src/hook.js:patchConsoleForInitialRenderInStrictMode</span>

<span class="s1">function </span><span class="s0">patchForStrictMode() {</span>
  <span class="s1">if </span><span class="s0">(consoleManagedByDevToolsDuringStrictMode) {</span>
    <span class="s1">var </span><span class="s0">overrideConsoleMethods = [</span><span class="s2">'error'</span><span class="s0">, </span><span class="s2">'group'</span><span class="s0">, </span><span class="s2">'groupCollapsed'</span><span class="s0">, </span><span class="s2">'info'</span><span class="s0">, </span><span class="s2">'log'</span><span class="s0">, </span><span class="s2">'trace'</span><span class="s0">, </span><span class="s2">'warn'</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(unpatchForStrictModeFn !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Don't patch twice.</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">originalConsoleMethods = {};</span>

    <span class="s0">unpatchForStrictModeFn = </span><span class="s1">function </span><span class="s0">unpatchForStrictModeFn() {</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_method3 </span><span class="s1">in </span><span class="s0">originalConsoleMethods) {</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s0">targetConsole[_method3] = originalConsoleMethods[_method3];</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
      <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s0">overrideConsoleMethods.forEach(</span><span class="s1">function </span><span class="s0">(method) {</span>
      <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method]; </span><span class="s3">// $FlowFixMe[missing-local-annot]</span>

        <span class="s1">var </span><span class="s0">overrideMethod = </span><span class="s1">function </span><span class="s0">overrideMethod() {</span>
          <span class="s1">if </span><span class="s0">(!consoleSettingsRef.hideConsoleLogsInStrictMode) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len2 = arguments.length, args = </span><span class="s1">new </span><span class="s0">Array(_len2), _key2 = </span><span class="s4">0</span><span class="s0">; _key2 &lt; _len2; _key2++) {</span>
              <span class="s0">args[_key2] = arguments[_key2];</span>
            <span class="s0">}</span>

            <span class="s3">// Dim the text color of the double logs if we're not</span>
            <span class="s3">// hiding them.</span>
            <span class="s1">if </span><span class="s0">(isNode) {</span>
              <span class="s0">originalMethod(DIMMED_NODE_CONSOLE_COLOR, format.apply(</span><span class="s1">void </span><span class="s4">0</span><span class="s0">, args));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
              <span class="s1">var </span><span class="s0">color = getConsoleColor(method);</span>

              <span class="s1">if </span><span class="s0">(color) {</span>
                <span class="s0">originalMethod.apply(</span><span class="s1">void </span><span class="s4">0</span><span class="s0">, console_toConsumableArray(formatWithStyles(args, </span><span class="s2">&quot;color: &quot;</span><span class="s0">.concat(color))));</span>
              <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">throw </span><span class="s0">Error(</span><span class="s2">'Console color is not defined'</span><span class="s0">);</span>
              <span class="s0">}</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">};</span>

        <span class="s0">overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;</span>
        <span class="s0">originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;</span>
        <span class="s0">targetConsole[method] = overrideMethod;</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
    <span class="s0">});</span>
  <span class="s0">}</span>
<span class="s0">} </span><span class="s3">// NOTE: KEEP IN SYNC with src/hook.js:unpatchConsoleForInitialRenderInStrictMode</span>

<span class="s1">function </span><span class="s0">unpatchForStrictMode() {</span>
  <span class="s1">if </span><span class="s0">(consoleManagedByDevToolsDuringStrictMode) {</span>
    <span class="s1">if </span><span class="s0">(unpatchForStrictModeFn !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">unpatchForStrictModeFn();</span>
      <span class="s0">unpatchForStrictModeFn = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">patchConsoleUsingWindowValues() {</span>
  <span class="s1">var </span><span class="s0">_castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;</span>

  <span class="s1">var </span><span class="s0">appendComponentStack = (_castBool = castBool(window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBool !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBool : </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">breakOnConsoleErrors = (_castBool2 = castBool(window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBool2 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBool2 : </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">showInlineWarningsAndErrors = (_castBool3 = castBool(window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBool3 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBool3 : </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">hideConsoleLogsInStrictMode = (_castBool4 = castBool(window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBool4 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBool4 : </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">browserTheme = (_castBrowserTheme = castBrowserTheme(window.__REACT_DEVTOOLS_BROWSER_THEME__)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBrowserTheme !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBrowserTheme : </span><span class="s2">'dark'</span><span class="s0">;</span>
  <span class="s0">patch({</span>
    <span class="s0">appendComponentStack: appendComponentStack,</span>
    <span class="s0">breakOnConsoleErrors: breakOnConsoleErrors,</span>
    <span class="s0">showInlineWarningsAndErrors: showInlineWarningsAndErrors,</span>
    <span class="s0">hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,</span>
    <span class="s0">browserTheme: browserTheme</span>
  <span class="s0">});</span>
<span class="s0">} </span><span class="s3">// After receiving cached console patch settings from React Native, we set them on window.</span>
<span class="s3">// When the console is initially patched (in renderer.js and hook.js), these values are read.</span>
<span class="s3">// The browser extension (etc.) sets these values on window, but through another method.</span>

<span class="s1">function </span><span class="s0">writeConsolePatchSettingsToWindow(settings) {</span>
  <span class="s0">window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = settings.appendComponentStack;</span>
  <span class="s0">window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = settings.breakOnConsoleErrors;</span>
  <span class="s0">window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = settings.showInlineWarningsAndErrors;</span>
  <span class="s0">window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = settings.hideConsoleLogsInStrictMode;</span>
  <span class="s0">window.__REACT_DEVTOOLS_BROWSER_THEME__ = settings.browserTheme;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">installConsoleFunctionsToWindow() {</span>
  <span class="s0">window.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__ = {</span>
    <span class="s0">patchConsoleUsingWindowValues: patchConsoleUsingWindowValues,</span>
    <span class="s0">registerRendererWithConsole: registerRenderer</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/bridge.js</span>
<span class="s1">function </span><span class="s0">bridge_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { bridge_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ bridge_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">bridge_typeof(obj); }</span>

<span class="s1">function </span><span class="s0">bridge_toConsumableArray(arr) { </span><span class="s1">return </span><span class="s0">bridge_arrayWithoutHoles(arr) || bridge_iterableToArray(arr) || bridge_unsupportedIterableToArray(arr) || bridge_nonIterableSpread(); }</span>

<span class="s1">function </span><span class="s0">bridge_nonIterableSpread() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to spread non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">bridge_unsupportedIterableToArray(o, minLen) { </span><span class="s1">if </span><span class="s0">(!o) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">o === </span><span class="s2">&quot;string&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">bridge_arrayLikeToArray(o, minLen); </span><span class="s1">var </span><span class="s0">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s0">&amp;&amp; o.constructor) n = o.constructor.name; </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s0">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">Array.from(o); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s0">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s0">|</span><span class="s4">16</span><span class="s0">|</span><span class="s4">32</span><span class="s0">)(?:Clamped)?Array$/.test(n)) </span><span class="s1">return </span><span class="s0">bridge_arrayLikeToArray(o, minLen); }</span>

<span class="s1">function </span><span class="s0">bridge_iterableToArray(iter) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">&amp;&amp; Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(iter)) </span><span class="s1">return </span><span class="s0">Array.from(iter); }</span>

<span class="s1">function </span><span class="s0">bridge_arrayWithoutHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">bridge_arrayLikeToArray(arr); }</span>

<span class="s1">function </span><span class="s0">bridge_arrayLikeToArray(arr, len) { </span><span class="s1">if </span><span class="s0">(len == </span><span class="s1">null </span><span class="s0">|| len &gt; arr.length) len = arr.length; </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, arr2 = </span><span class="s1">new </span><span class="s0">Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } </span><span class="s1">return </span><span class="s0">arr2; }</span>

<span class="s1">function </span><span class="s0">bridge_classCallCheck(instance, Constructor) { </span><span class="s1">if </span><span class="s0">(!(instance </span><span class="s1">instanceof </span><span class="s0">Constructor)) { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Cannot call a class as a function&quot;</span><span class="s0">); } }</span>

<span class="s1">function </span><span class="s0">bridge_defineProperties(target, props) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; props.length; i++) { </span><span class="s1">var </span><span class="s0">descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || </span><span class="s1">false</span><span class="s0">; descriptor.configurable = </span><span class="s1">true</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;value&quot; </span><span class="s1">in </span><span class="s0">descriptor) descriptor.writable = </span><span class="s1">true</span><span class="s0">; Object.defineProperty(target, descriptor.key, descriptor); } }</span>

<span class="s1">function </span><span class="s0">bridge_createClass(Constructor, protoProps, staticProps) { </span><span class="s1">if </span><span class="s0">(protoProps) bridge_defineProperties(Constructor.prototype, protoProps); </span><span class="s1">if </span><span class="s0">(staticProps) bridge_defineProperties(Constructor, staticProps); </span><span class="s1">return </span><span class="s0">Constructor; }</span>

<span class="s1">function </span><span class="s0">_inherits(subClass, superClass) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">superClass !== </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; superClass !== </span><span class="s1">null</span><span class="s0">) { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Super expression must either be null or a function&quot;</span><span class="s0">); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, writable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true </span><span class="s0">} }); </span><span class="s1">if </span><span class="s0">(superClass) _setPrototypeOf(subClass, superClass); }</span>

<span class="s1">function </span><span class="s0">_setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s1">function </span><span class="s0">_setPrototypeOf(o, p) { o.__proto__ = p; </span><span class="s1">return </span><span class="s0">o; }; </span><span class="s1">return </span><span class="s0">_setPrototypeOf(o, p); }</span>

<span class="s1">function </span><span class="s0">_createSuper(Derived) { </span><span class="s1">var </span><span class="s0">hasNativeReflectConstruct = _isNativeReflectConstruct(); </span><span class="s1">return function </span><span class="s0">_createSuperInternal() { </span><span class="s1">var </span><span class="s0">Super = _getPrototypeOf(Derived), result; </span><span class="s1">if </span><span class="s0">(hasNativeReflectConstruct) { </span><span class="s1">var </span><span class="s0">NewTarget = _getPrototypeOf(</span><span class="s1">this</span><span class="s0">).constructor; result = Reflect.construct(Super, arguments, NewTarget); } </span><span class="s1">else </span><span class="s0">{ result = Super.apply(</span><span class="s1">this</span><span class="s0">, arguments); } </span><span class="s1">return </span><span class="s0">_possibleConstructorReturn(</span><span class="s1">this</span><span class="s0">, result); }; }</span>

<span class="s1">function </span><span class="s0">_possibleConstructorReturn(self, call) { </span><span class="s1">if </span><span class="s0">(call &amp;&amp; (bridge_typeof(call) === </span><span class="s2">&quot;object&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">call === </span><span class="s2">&quot;function&quot;</span><span class="s0">)) { </span><span class="s1">return </span><span class="s0">call; } </span><span class="s1">return </span><span class="s0">_assertThisInitialized(self); }</span>

<span class="s1">function </span><span class="s0">_assertThisInitialized(self) { </span><span class="s1">if </span><span class="s0">(self === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) { </span><span class="s1">throw new </span><span class="s0">ReferenceError(</span><span class="s2">&quot;this hasn't been initialised - super() hasn't been called&quot;</span><span class="s0">); } </span><span class="s1">return </span><span class="s0">self; }</span>

<span class="s1">function </span><span class="s0">_isNativeReflectConstruct() { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Reflect === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">|| !Reflect.construct) </span><span class="s1">return false</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(Reflect.construct.sham) </span><span class="s1">return false</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Proxy === </span><span class="s2">&quot;function&quot;</span><span class="s0">) </span><span class="s1">return true</span><span class="s0">; </span><span class="s1">try </span><span class="s0">{ Date.prototype.toString.call(Reflect.construct(Date, [], </span><span class="s1">function </span><span class="s0">() {})); </span><span class="s1">return true</span><span class="s0">; } </span><span class="s1">catch </span><span class="s0">(e) { </span><span class="s1">return false</span><span class="s0">; } }</span>

<span class="s1">function </span><span class="s0">_getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : </span><span class="s1">function </span><span class="s0">_getPrototypeOf(o) { </span><span class="s1">return </span><span class="s0">o.__proto__ || Object.getPrototypeOf(o); }; </span><span class="s1">return </span><span class="s0">_getPrototypeOf(o); }</span>

<span class="s1">function </span><span class="s0">bridge_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s1">var </span><span class="s0">BATCH_DURATION = </span><span class="s4">100</span><span class="s0">; </span><span class="s3">// This message specifies the version of the DevTools protocol currently supported by the backend,</span>
<span class="s3">// as well as the earliest NPM version (e.g. &quot;4.13.0&quot;) that protocol is supported by on the frontend.</span>
<span class="s3">// This enables an older frontend to display an upgrade message to users for a newer, unsupported backend.</span>

<span class="s3">// Bump protocol version whenever a backwards breaking change is made</span>
<span class="s3">// in the messages sent between BackendBridge and FrontendBridge.</span>
<span class="s3">// This mapping is embedded in both frontend and backend builds.</span>
<span class="s3">//</span>
<span class="s3">// The backend protocol will always be the latest entry in the BRIDGE_PROTOCOL array.</span>
<span class="s3">//</span>
<span class="s3">// When an older frontend connects to a newer backend,</span>
<span class="s3">// the backend can send the minNpmVersion and the frontend can display an NPM upgrade prompt.</span>
<span class="s3">//</span>
<span class="s3">// When a newer frontend connects with an older protocol version,</span>
<span class="s3">// the frontend can use the embedded minNpmVersion/maxNpmVersion values to display a downgrade prompt.</span>
<span class="s1">var </span><span class="s0">BRIDGE_PROTOCOL = [</span><span class="s3">// This version technically never existed,</span>
<span class="s3">// but a backwards breaking change was added in 4.11,</span>
<span class="s3">// so the safest guess to downgrade the frontend would be to version 4.10.</span>
<span class="s0">{</span>
  <span class="s0">version: </span><span class="s4">0</span><span class="s0">,</span>
  <span class="s0">minNpmVersion: </span><span class="s2">'&quot;&lt;4.11.0&quot;'</span><span class="s0">,</span>
  <span class="s0">maxNpmVersion: </span><span class="s2">'&quot;&lt;4.11.0&quot;'</span>
<span class="s0">}, </span><span class="s3">// Versions 4.11.x  4.12.x contained the backwards breaking change,</span>
<span class="s3">// but we didn't add the &quot;fix&quot; of checking the protocol version until 4.13,</span>
<span class="s3">// so we don't recommend downgrading to 4.11 or 4.12.</span>
<span class="s0">{</span>
  <span class="s0">version: </span><span class="s4">1</span><span class="s0">,</span>
  <span class="s0">minNpmVersion: </span><span class="s2">'4.13.0'</span><span class="s0">,</span>
  <span class="s0">maxNpmVersion: </span><span class="s2">'4.21.0'</span>
<span class="s0">}, </span><span class="s3">// Version 2 adds a StrictMode-enabled and supports-StrictMode bits to add-root operation.</span>
<span class="s0">{</span>
  <span class="s0">version: </span><span class="s4">2</span><span class="s0">,</span>
  <span class="s0">minNpmVersion: </span><span class="s2">'4.22.0'</span><span class="s0">,</span>
  <span class="s0">maxNpmVersion: </span><span class="s1">null</span>
<span class="s0">}];</span>
<span class="s1">var </span><span class="s0">currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - </span><span class="s4">1</span><span class="s0">];</span>

<span class="s1">var </span><span class="s0">Bridge = </span><span class="s3">/*#__PURE__*/</span><span class="s1">function </span><span class="s0">(_EventEmitter) {</span>
  <span class="s0">_inherits(Bridge, _EventEmitter);</span>

  <span class="s1">var </span><span class="s0">_super = _createSuper(Bridge);</span>

  <span class="s1">function </span><span class="s0">Bridge(wall) {</span>
    <span class="s1">var </span><span class="s0">_this;</span>

    <span class="s0">bridge_classCallCheck(</span><span class="s1">this</span><span class="s0">, Bridge);</span>

    <span class="s0">_this = _super.call(</span><span class="s1">this</span><span class="s0">);</span>

    <span class="s0">bridge_defineProperty(_assertThisInitialized(_this), </span><span class="s2">&quot;_isShutdown&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>

    <span class="s0">bridge_defineProperty(_assertThisInitialized(_this), </span><span class="s2">&quot;_messageQueue&quot;</span><span class="s0">, []);</span>

    <span class="s0">bridge_defineProperty(_assertThisInitialized(_this), </span><span class="s2">&quot;_timeoutID&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>

    <span class="s0">bridge_defineProperty(_assertThisInitialized(_this), </span><span class="s2">&quot;_wallUnlisten&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>

    <span class="s0">bridge_defineProperty(_assertThisInitialized(_this), </span><span class="s2">&quot;_flush&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s3">// This method is used after the bridge is marked as destroyed in shutdown sequence,</span>
      <span class="s3">// so we do not bail out if the bridge marked as destroyed.</span>
      <span class="s3">// It is a private method that the bridge ensures is only called at the right times.</span>
      <span class="s1">if </span><span class="s0">(_this._timeoutID !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">clearTimeout(_this._timeoutID);</span>
        <span class="s0">_this._timeoutID = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(_this._messageQueue.length) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; _this._messageQueue.length; i += </span><span class="s4">2</span><span class="s0">) {</span>
          <span class="s1">var </span><span class="s0">_this$_wall;</span>

          <span class="s0">(_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(bridge_toConsumableArray(_this._messageQueue[i + </span><span class="s4">1</span><span class="s0">])));</span>
        <span class="s0">}</span>

        <span class="s0">_this._messageQueue.length = </span><span class="s4">0</span><span class="s0">; </span><span class="s3">// Check again for queued messages in BATCH_DURATION ms. This will keep</span>
        <span class="s3">// flushing in a loop as long as messages continue to be added. Once no</span>
        <span class="s3">// more are, the timer expires.</span>

        <span class="s0">_this._timeoutID = setTimeout(_this._flush, BATCH_DURATION);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">bridge_defineProperty(_assertThisInitialized(_this), </span><span class="s2">&quot;overrideValueAtPath&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref) {</span>
      <span class="s1">var </span><span class="s0">id = _ref.id,</span>
          <span class="s0">path = _ref.path,</span>
          <span class="s0">rendererID = _ref.rendererID,</span>
          <span class="s0">type = _ref.type,</span>
          <span class="s0">value = _ref.value;</span>

      <span class="s1">switch </span><span class="s0">(type) {</span>
        <span class="s1">case </span><span class="s2">'context'</span><span class="s0">:</span>
          <span class="s0">_this.send(</span><span class="s2">'overrideContext'</span><span class="s0">, {</span>
            <span class="s0">id: id,</span>
            <span class="s0">path: path,</span>
            <span class="s0">rendererID: rendererID,</span>
            <span class="s0">wasForwarded: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: value</span>
          <span class="s0">});</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'hooks'</span><span class="s0">:</span>
          <span class="s0">_this.send(</span><span class="s2">'overrideHookState'</span><span class="s0">, {</span>
            <span class="s0">id: id,</span>
            <span class="s0">path: path,</span>
            <span class="s0">rendererID: rendererID,</span>
            <span class="s0">wasForwarded: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: value</span>
          <span class="s0">});</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'props'</span><span class="s0">:</span>
          <span class="s0">_this.send(</span><span class="s2">'overrideProps'</span><span class="s0">, {</span>
            <span class="s0">id: id,</span>
            <span class="s0">path: path,</span>
            <span class="s0">rendererID: rendererID,</span>
            <span class="s0">wasForwarded: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: value</span>
          <span class="s0">});</span>

          <span class="s1">break</span><span class="s0">;</span>

        <span class="s1">case </span><span class="s2">'state'</span><span class="s0">:</span>
          <span class="s0">_this.send(</span><span class="s2">'overrideState'</span><span class="s0">, {</span>
            <span class="s0">id: id,</span>
            <span class="s0">path: path,</span>
            <span class="s0">rendererID: rendererID,</span>
            <span class="s0">wasForwarded: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: value</span>
          <span class="s0">});</span>

          <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">_this._wall = wall;</span>
    <span class="s0">_this._wallUnlisten = wall.listen(</span><span class="s1">function </span><span class="s0">(message) {</span>
      <span class="s1">if </span><span class="s0">(message &amp;&amp; message.event) {</span>
        <span class="s0">_assertThisInitialized(_this).emit(message.event, message.payload);</span>
      <span class="s0">}</span>
    <span class="s0">}) || </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// Temporarily support older standalone front-ends sending commands to newer embedded backends.</span>
    <span class="s3">// We do this because React Native embeds the React DevTools backend,</span>
    <span class="s3">// but cannot control which version of the frontend users use.</span>

    <span class="s0">_this.addListener(</span><span class="s2">'overrideValueAtPath'</span><span class="s0">, _this.overrideValueAtPath);</span>

    <span class="s1">return </span><span class="s0">_this;</span>
  <span class="s0">} </span><span class="s3">// Listening directly to the wall isn't advised.</span>
  <span class="s3">// It can be used to listen for legacy (v3) messages (since they use a different format).</span>


  <span class="s0">bridge_createClass(Bridge, [{</span>
    <span class="s0">key: </span><span class="s2">&quot;send&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">send(event) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._isShutdown) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Cannot send message </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(event, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">through a Bridge that has been shutdown.&quot;</span><span class="s0">));</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s3">// When we receive a message:</span>
      <span class="s3">// - we add it to our queue of messages to be sent</span>
      <span class="s3">// - if there hasn't been a message recently, we set a timer for 0 ms in</span>
      <span class="s3">//   the future, allowing all messages created in the same tick to be sent</span>
      <span class="s3">//   together</span>
      <span class="s3">// - if there *has* been a message flushed in the last BATCH_DURATION ms</span>
      <span class="s3">//   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will</span>
      <span class="s3">//   be set, and we'll simply add to the queue and wait for that</span>


      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, payload = </span><span class="s1">new </span><span class="s0">Array(_len &gt; </span><span class="s4">1 </span><span class="s0">? _len - </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">), _key = </span><span class="s4">1</span><span class="s0">; _key &lt; _len; _key++) {</span>
        <span class="s0">payload[_key - </span><span class="s4">1</span><span class="s0">] = arguments[_key];</span>
      <span class="s0">}</span>

      <span class="s1">this</span><span class="s0">._messageQueue.push(event, payload);</span>

      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._timeoutID) {</span>
        <span class="s1">this</span><span class="s0">._timeoutID = setTimeout(</span><span class="s1">this</span><span class="s0">._flush, </span><span class="s4">0</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;shutdown&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">shutdown() {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._isShutdown) {</span>
        <span class="s0">console.warn(</span><span class="s2">'Bridge was already shutdown.'</span><span class="s0">);</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s3">// Queue the shutdown outgoing message for subscribers.</span>


      <span class="s1">this</span><span class="s0">.emit(</span><span class="s2">'shutdown'</span><span class="s0">);</span>
      <span class="s1">this</span><span class="s0">.send(</span><span class="s2">'shutdown'</span><span class="s0">); </span><span class="s3">// Mark this bridge as destroyed, i.e. disable its public API.</span>

      <span class="s1">this</span><span class="s0">._isShutdown = </span><span class="s1">true</span><span class="s0">; </span><span class="s3">// Disable the API inherited from EventEmitter that can add more listeners and send more messages.</span>
      <span class="s3">// $FlowFixMe[cannot-write] This property is not writable.</span>

      <span class="s1">this</span><span class="s0">.addListener = </span><span class="s1">function </span><span class="s0">() {}; </span><span class="s3">// $FlowFixMe[cannot-write] This property is not writable.</span>


      <span class="s1">this</span><span class="s0">.emit = </span><span class="s1">function </span><span class="s0">() {}; </span><span class="s3">// NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.</span>
      <span class="s3">// Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.</span>


      <span class="s1">this</span><span class="s0">.removeAllListeners(); </span><span class="s3">// Stop accepting and emitting incoming messages from the wall.</span>

      <span class="s1">var </span><span class="s0">wallUnlisten = </span><span class="s1">this</span><span class="s0">._wallUnlisten;</span>

      <span class="s1">if </span><span class="s0">(wallUnlisten) {</span>
        <span class="s0">wallUnlisten();</span>
      <span class="s0">} </span><span class="s3">// Synchronously flush all queued outgoing messages.</span>
      <span class="s3">// At this step the subscribers' code may run in this call stack.</span>


      <span class="s1">do </span><span class="s0">{</span>
        <span class="s1">this</span><span class="s0">._flush();</span>
      <span class="s0">} </span><span class="s1">while </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._messageQueue.length); </span><span class="s3">// Make sure once again that there is no dangling timer.</span>


      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._timeoutID !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">clearTimeout(</span><span class="s1">this</span><span class="s0">._timeoutID);</span>
        <span class="s1">this</span><span class="s0">._timeoutID = </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;wall&quot;</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
      <span class="s1">return this</span><span class="s0">._wall;</span>
    <span class="s0">}</span>
  <span class="s0">}]);</span>

  <span class="s1">return </span><span class="s0">Bridge;</span>
<span class="s0">}(EventEmitter);</span>

<span class="s3">/* harmony default export */ </span><span class="s0">const src_bridge = (Bridge);</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/agent.js</span>
<span class="s1">function </span><span class="s0">agent_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { agent_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ agent_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">agent_typeof(obj); }</span>

<span class="s1">function </span><span class="s0">agent_classCallCheck(instance, Constructor) { </span><span class="s1">if </span><span class="s0">(!(instance </span><span class="s1">instanceof </span><span class="s0">Constructor)) { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Cannot call a class as a function&quot;</span><span class="s0">); } }</span>

<span class="s1">function </span><span class="s0">agent_defineProperties(target, props) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; props.length; i++) { </span><span class="s1">var </span><span class="s0">descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || </span><span class="s1">false</span><span class="s0">; descriptor.configurable = </span><span class="s1">true</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;value&quot; </span><span class="s1">in </span><span class="s0">descriptor) descriptor.writable = </span><span class="s1">true</span><span class="s0">; Object.defineProperty(target, descriptor.key, descriptor); } }</span>

<span class="s1">function </span><span class="s0">agent_createClass(Constructor, protoProps, staticProps) { </span><span class="s1">if </span><span class="s0">(protoProps) agent_defineProperties(Constructor.prototype, protoProps); </span><span class="s1">if </span><span class="s0">(staticProps) agent_defineProperties(Constructor, staticProps); </span><span class="s1">return </span><span class="s0">Constructor; }</span>

<span class="s1">function </span><span class="s0">agent_inherits(subClass, superClass) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">superClass !== </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; superClass !== </span><span class="s1">null</span><span class="s0">) { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Super expression must either be null or a function&quot;</span><span class="s0">); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, writable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true </span><span class="s0">} }); </span><span class="s1">if </span><span class="s0">(superClass) agent_setPrototypeOf(subClass, superClass); }</span>

<span class="s1">function </span><span class="s0">agent_setPrototypeOf(o, p) { agent_setPrototypeOf = Object.setPrototypeOf || </span><span class="s1">function </span><span class="s0">_setPrototypeOf(o, p) { o.__proto__ = p; </span><span class="s1">return </span><span class="s0">o; }; </span><span class="s1">return </span><span class="s0">agent_setPrototypeOf(o, p); }</span>

<span class="s1">function </span><span class="s0">agent_createSuper(Derived) { </span><span class="s1">var </span><span class="s0">hasNativeReflectConstruct = agent_isNativeReflectConstruct(); </span><span class="s1">return function </span><span class="s0">_createSuperInternal() { </span><span class="s1">var </span><span class="s0">Super = agent_getPrototypeOf(Derived), result; </span><span class="s1">if </span><span class="s0">(hasNativeReflectConstruct) { </span><span class="s1">var </span><span class="s0">NewTarget = agent_getPrototypeOf(</span><span class="s1">this</span><span class="s0">).constructor; result = Reflect.construct(Super, arguments, NewTarget); } </span><span class="s1">else </span><span class="s0">{ result = Super.apply(</span><span class="s1">this</span><span class="s0">, arguments); } </span><span class="s1">return </span><span class="s0">agent_possibleConstructorReturn(</span><span class="s1">this</span><span class="s0">, result); }; }</span>

<span class="s1">function </span><span class="s0">agent_possibleConstructorReturn(self, call) { </span><span class="s1">if </span><span class="s0">(call &amp;&amp; (agent_typeof(call) === </span><span class="s2">&quot;object&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">call === </span><span class="s2">&quot;function&quot;</span><span class="s0">)) { </span><span class="s1">return </span><span class="s0">call; } </span><span class="s1">return </span><span class="s0">agent_assertThisInitialized(self); }</span>

<span class="s1">function </span><span class="s0">agent_assertThisInitialized(self) { </span><span class="s1">if </span><span class="s0">(self === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) { </span><span class="s1">throw new </span><span class="s0">ReferenceError(</span><span class="s2">&quot;this hasn't been initialised - super() hasn't been called&quot;</span><span class="s0">); } </span><span class="s1">return </span><span class="s0">self; }</span>

<span class="s1">function </span><span class="s0">agent_isNativeReflectConstruct() { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Reflect === </span><span class="s2">&quot;undefined&quot; </span><span class="s0">|| !Reflect.construct) </span><span class="s1">return false</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(Reflect.construct.sham) </span><span class="s1">return false</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Proxy === </span><span class="s2">&quot;function&quot;</span><span class="s0">) </span><span class="s1">return true</span><span class="s0">; </span><span class="s1">try </span><span class="s0">{ Date.prototype.toString.call(Reflect.construct(Date, [], </span><span class="s1">function </span><span class="s0">() {})); </span><span class="s1">return true</span><span class="s0">; } </span><span class="s1">catch </span><span class="s0">(e) { </span><span class="s1">return false</span><span class="s0">; } }</span>

<span class="s1">function </span><span class="s0">agent_getPrototypeOf(o) { agent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : </span><span class="s1">function </span><span class="s0">_getPrototypeOf(o) { </span><span class="s1">return </span><span class="s0">o.__proto__ || Object.getPrototypeOf(o); }; </span><span class="s1">return </span><span class="s0">agent_getPrototypeOf(o); }</span>

<span class="s1">function </span><span class="s0">agent_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>










<span class="s1">var </span><span class="s0">debug = </span><span class="s1">function </span><span class="s0">debug(methodName) {</span>
  <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
    <span class="s1">var </span><span class="s0">_console;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, args = </span><span class="s1">new </span><span class="s0">Array(_len &gt; </span><span class="s4">1 </span><span class="s0">? _len - </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">), _key = </span><span class="s4">1</span><span class="s0">; _key &lt; _len; _key++) {</span>
      <span class="s0">args[_key - </span><span class="s4">1</span><span class="s0">] = arguments[_key];</span>
    <span class="s0">}</span>

    <span class="s0">(_console = console).log.apply(_console, [</span><span class="s2">&quot;%cAgent %c&quot;</span><span class="s0">.concat(methodName), </span><span class="s2">'color: purple; font-weight: bold;'</span><span class="s0">, </span><span class="s2">'font-weight: bold;'</span><span class="s0">].concat(args));</span>
  <span class="s0">}</span>
<span class="s0">};</span>

<span class="s1">var </span><span class="s0">Agent = </span><span class="s3">/*#__PURE__*/</span><span class="s1">function </span><span class="s0">(_EventEmitter) {</span>
  <span class="s0">agent_inherits(Agent, _EventEmitter);</span>

  <span class="s1">var </span><span class="s0">_super = agent_createSuper(Agent);</span>

  <span class="s1">function </span><span class="s0">Agent(bridge) {</span>
    <span class="s1">var </span><span class="s0">_this;</span>

    <span class="s0">agent_classCallCheck(</span><span class="s1">this</span><span class="s0">, Agent);</span>

    <span class="s0">_this = _super.call(</span><span class="s1">this</span><span class="s0">);</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;_isProfiling&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;_recordChangeDescriptions&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;_rendererInterfaces&quot;</span><span class="s0">, {});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;_persistedSelection&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;_persistedSelectionMatch&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;_traceUpdatesEnabled&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;clearErrorsAndWarnings&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref) {</span>
      <span class="s1">var </span><span class="s0">rendererID = _ref.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.clearErrorsAndWarnings();</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;clearErrorsForFiberID&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref2) {</span>
      <span class="s1">var </span><span class="s0">id = _ref2.id,</span>
          <span class="s0">rendererID = _ref2.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.clearErrorsForFiberID(id);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;clearWarningsForFiberID&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref3) {</span>
      <span class="s1">var </span><span class="s0">id = _ref3.id,</span>
          <span class="s0">rendererID = _ref3.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.clearWarningsForFiberID(id);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;copyElementPath&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref4) {</span>
      <span class="s1">var </span><span class="s0">id = _ref4.id,</span>
          <span class="s0">path = _ref4.path,</span>
          <span class="s0">rendererID = _ref4.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">value = renderer.getSerializedElementValueByPath(id, path);</span>

        <span class="s1">if </span><span class="s0">(value != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">_this._bridge.send(</span><span class="s2">'saveToClipboard'</span><span class="s0">, value);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s0">console.warn(</span><span class="s2">&quot;Unable to obtain serialized value for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;deletePath&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref5) {</span>
      <span class="s1">var </span><span class="s0">hookID = _ref5.hookID,</span>
          <span class="s0">id = _ref5.id,</span>
          <span class="s0">path = _ref5.path,</span>
          <span class="s0">rendererID = _ref5.rendererID,</span>
          <span class="s0">type = _ref5.type;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.deletePath(type, id, hookID, path);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;getBackendVersion&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s1">var </span><span class="s0">version = </span><span class="s2">&quot;4.28.0-9b95b131b&quot;</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(version) {</span>
        <span class="s0">_this._bridge.send(</span><span class="s2">'backendVersion'</span><span class="s0">, version);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;getBridgeProtocol&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s0">_this._bridge.send(</span><span class="s2">'bridgeProtocol'</span><span class="s0">, currentBridgeProtocol);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;getProfilingData&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref6) {</span>
      <span class="s1">var </span><span class="s0">rendererID = _ref6.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">}</span>

      <span class="s0">_this._bridge.send(</span><span class="s2">'profilingData'</span><span class="s0">, renderer.getProfilingData());</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;getProfilingStatus&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s0">_this._bridge.send(</span><span class="s2">'profilingStatus'</span><span class="s0">, _this._isProfiling);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;getOwnersList&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref7) {</span>
      <span class="s1">var </span><span class="s0">id = _ref7.id,</span>
          <span class="s0">rendererID = _ref7.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">owners = renderer.getOwnersList(id);</span>

        <span class="s0">_this._bridge.send(</span><span class="s2">'ownersList'</span><span class="s0">, {</span>
          <span class="s0">id: id,</span>
          <span class="s0">owners: owners</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;inspectElement&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref8) {</span>
      <span class="s1">var </span><span class="s0">forceFullData = _ref8.forceFullData,</span>
          <span class="s0">id = _ref8.id,</span>
          <span class="s0">path = _ref8.path,</span>
          <span class="s0">rendererID = _ref8.rendererID,</span>
          <span class="s0">requestID = _ref8.requestID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">_this._bridge.send(</span><span class="s2">'inspectedElement'</span><span class="s0">, renderer.inspectElement(requestID, id, path, forceFullData)); </span><span class="s3">// When user selects an element, stop trying to restore the selection,</span>
        <span class="s3">// and instead remember the current selection for the next reload.</span>


        <span class="s1">if </span><span class="s0">(_this._persistedSelectionMatch === </span><span class="s1">null </span><span class="s0">|| _this._persistedSelectionMatch.id !== id) {</span>
          <span class="s0">_this._persistedSelection = </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s0">_this._persistedSelectionMatch = </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s0">renderer.setTrackedPath(</span><span class="s1">null</span><span class="s0">);</span>

          <span class="s0">_this._throttledPersistSelection(rendererID, id);</span>
        <span class="s0">} </span><span class="s3">// TODO: If there was a way to change the selected DOM element</span>
        <span class="s3">// in native Elements tab without forcing a switch to it, we'd do it here.</span>
        <span class="s3">// For now, it doesn't seem like there is a way to do that:</span>
        <span class="s3">// https://github.com/bvaughn/react-devtools-experimental/issues/102</span>
        <span class="s3">// (Setting $0 doesn't work, and calling inspect() switches the tab.)</span>

      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;logElementToConsole&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref9) {</span>
      <span class="s1">var </span><span class="s0">id = _ref9.id,</span>
          <span class="s0">rendererID = _ref9.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.logElementToConsole(id);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;overrideError&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref10) {</span>
      <span class="s1">var </span><span class="s0">id = _ref10.id,</span>
          <span class="s0">rendererID = _ref10.rendererID,</span>
          <span class="s0">forceError = _ref10.forceError;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.overrideError(id, forceError);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;overrideSuspense&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref11) {</span>
      <span class="s1">var </span><span class="s0">id = _ref11.id,</span>
          <span class="s0">rendererID = _ref11.rendererID,</span>
          <span class="s0">forceFallback = _ref11.forceFallback;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.overrideSuspense(id, forceFallback);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;overrideValueAtPath&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref12) {</span>
      <span class="s1">var </span><span class="s0">hookID = _ref12.hookID,</span>
          <span class="s0">id = _ref12.id,</span>
          <span class="s0">path = _ref12.path,</span>
          <span class="s0">rendererID = _ref12.rendererID,</span>
          <span class="s0">type = _ref12.type,</span>
          <span class="s0">value = _ref12.value;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.overrideValueAtPath(type, id, hookID, path, value);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;overrideContext&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref13) {</span>
      <span class="s1">var </span><span class="s0">id = _ref13.id,</span>
          <span class="s0">path = _ref13.path,</span>
          <span class="s0">rendererID = _ref13.rendererID,</span>
          <span class="s0">wasForwarded = _ref13.wasForwarded,</span>
          <span class="s0">value = _ref13.value;</span>

      <span class="s3">// Don't forward a message that's already been forwarded by the front-end Bridge.</span>
      <span class="s3">// We only need to process the override command once!</span>
      <span class="s1">if </span><span class="s0">(!wasForwarded) {</span>
        <span class="s0">_this.overrideValueAtPath({</span>
          <span class="s0">id: id,</span>
          <span class="s0">path: path,</span>
          <span class="s0">rendererID: rendererID,</span>
          <span class="s0">type: </span><span class="s2">'context'</span><span class="s0">,</span>
          <span class="s0">value: value</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;overrideHookState&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref14) {</span>
      <span class="s1">var </span><span class="s0">id = _ref14.id,</span>
          <span class="s0">hookID = _ref14.hookID,</span>
          <span class="s0">path = _ref14.path,</span>
          <span class="s0">rendererID = _ref14.rendererID,</span>
          <span class="s0">wasForwarded = _ref14.wasForwarded,</span>
          <span class="s0">value = _ref14.value;</span>

      <span class="s3">// Don't forward a message that's already been forwarded by the front-end Bridge.</span>
      <span class="s3">// We only need to process the override command once!</span>
      <span class="s1">if </span><span class="s0">(!wasForwarded) {</span>
        <span class="s0">_this.overrideValueAtPath({</span>
          <span class="s0">id: id,</span>
          <span class="s0">path: path,</span>
          <span class="s0">rendererID: rendererID,</span>
          <span class="s0">type: </span><span class="s2">'hooks'</span><span class="s0">,</span>
          <span class="s0">value: value</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;overrideProps&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref15) {</span>
      <span class="s1">var </span><span class="s0">id = _ref15.id,</span>
          <span class="s0">path = _ref15.path,</span>
          <span class="s0">rendererID = _ref15.rendererID,</span>
          <span class="s0">wasForwarded = _ref15.wasForwarded,</span>
          <span class="s0">value = _ref15.value;</span>

      <span class="s3">// Don't forward a message that's already been forwarded by the front-end Bridge.</span>
      <span class="s3">// We only need to process the override command once!</span>
      <span class="s1">if </span><span class="s0">(!wasForwarded) {</span>
        <span class="s0">_this.overrideValueAtPath({</span>
          <span class="s0">id: id,</span>
          <span class="s0">path: path,</span>
          <span class="s0">rendererID: rendererID,</span>
          <span class="s0">type: </span><span class="s2">'props'</span><span class="s0">,</span>
          <span class="s0">value: value</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;overrideState&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref16) {</span>
      <span class="s1">var </span><span class="s0">id = _ref16.id,</span>
          <span class="s0">path = _ref16.path,</span>
          <span class="s0">rendererID = _ref16.rendererID,</span>
          <span class="s0">wasForwarded = _ref16.wasForwarded,</span>
          <span class="s0">value = _ref16.value;</span>

      <span class="s3">// Don't forward a message that's already been forwarded by the front-end Bridge.</span>
      <span class="s3">// We only need to process the override command once!</span>
      <span class="s1">if </span><span class="s0">(!wasForwarded) {</span>
        <span class="s0">_this.overrideValueAtPath({</span>
          <span class="s0">id: id,</span>
          <span class="s0">path: path,</span>
          <span class="s0">rendererID: rendererID,</span>
          <span class="s0">type: </span><span class="s2">'state'</span><span class="s0">,</span>
          <span class="s0">value: value</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;reloadAndProfile&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(recordChangeDescriptions) {</span>
      <span class="s0">sessionStorageSetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, </span><span class="s2">'true'</span><span class="s0">);</span>
      <span class="s0">sessionStorageSetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, recordChangeDescriptions ? </span><span class="s2">'true' </span><span class="s0">: </span><span class="s2">'false'</span><span class="s0">); </span><span class="s3">// This code path should only be hit if the shell has explicitly told the Store that it supports profiling.</span>
      <span class="s3">// In that case, the shell must also listen for this specific message to know when it needs to reload the app.</span>
      <span class="s3">// The agent can't do this in a way that is renderer agnostic.</span>

      <span class="s0">_this._bridge.send(</span><span class="s2">'reloadAppForProfiling'</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;renamePath&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref17) {</span>
      <span class="s1">var </span><span class="s0">hookID = _ref17.hookID,</span>
          <span class="s0">id = _ref17.id,</span>
          <span class="s0">newPath = _ref17.newPath,</span>
          <span class="s0">oldPath = _ref17.oldPath,</span>
          <span class="s0">rendererID = _ref17.rendererID,</span>
          <span class="s0">type = _ref17.type;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.renamePath(type, id, hookID, oldPath, newPath);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;setTraceUpdatesEnabled&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(traceUpdatesEnabled) {</span>
      <span class="s0">_this._traceUpdatesEnabled = traceUpdatesEnabled;</span>
      <span class="s0">toggleEnabled(traceUpdatesEnabled);</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">rendererID </span><span class="s1">in </span><span class="s0">_this._rendererInterfaces) {</span>
        <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>
        <span class="s0">renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;syncSelectionFromNativeElementsPanel&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s1">var </span><span class="s0">target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;</span>

      <span class="s1">if </span><span class="s0">(target == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s0">_this.selectNode(target);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;shutdown&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s3">// Clean up the overlay if visible, and associated events.</span>
      <span class="s0">_this.emit(</span><span class="s2">'shutdown'</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;startProfiling&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(recordChangeDescriptions) {</span>
      <span class="s0">_this._recordChangeDescriptions = recordChangeDescriptions;</span>
      <span class="s0">_this._isProfiling = </span><span class="s1">true</span><span class="s0">;</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">rendererID </span><span class="s1">in </span><span class="s0">_this._rendererInterfaces) {</span>
        <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>
        <span class="s0">renderer.startProfiling(recordChangeDescriptions);</span>
      <span class="s0">}</span>

      <span class="s0">_this._bridge.send(</span><span class="s2">'profilingStatus'</span><span class="s0">, _this._isProfiling);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;stopProfiling&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s0">_this._isProfiling = </span><span class="s1">false</span><span class="s0">;</span>
      <span class="s0">_this._recordChangeDescriptions = </span><span class="s1">false</span><span class="s0">;</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">rendererID </span><span class="s1">in </span><span class="s0">_this._rendererInterfaces) {</span>
        <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>
        <span class="s0">renderer.stopProfiling();</span>
      <span class="s0">}</span>

      <span class="s0">_this._bridge.send(</span><span class="s2">'profilingStatus'</span><span class="s0">, _this._isProfiling);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;stopInspectingNative&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(selected) {</span>
      <span class="s0">_this._bridge.send(</span><span class="s2">'stopInspectingNative'</span><span class="s0">, selected);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;storeAsGlobal&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref18) {</span>
      <span class="s1">var </span><span class="s0">count = _ref18.count,</span>
          <span class="s0">id = _ref18.id,</span>
          <span class="s0">path = _ref18.path,</span>
          <span class="s0">rendererID = _ref18.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.storeAsGlobal(id, path, count);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;updateConsolePatchSettings&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref19) {</span>
      <span class="s1">var </span><span class="s0">appendComponentStack = _ref19.appendComponentStack,</span>
          <span class="s0">breakOnConsoleErrors = _ref19.breakOnConsoleErrors,</span>
          <span class="s0">showInlineWarningsAndErrors = _ref19.showInlineWarningsAndErrors,</span>
          <span class="s0">hideConsoleLogsInStrictMode = _ref19.hideConsoleLogsInStrictMode,</span>
          <span class="s0">browserTheme = _ref19.browserTheme;</span>
      <span class="s3">// If the frontend preferences have changed,</span>
      <span class="s3">// or in the case of React Native- if the backend is just finding out the preferences-</span>
      <span class="s3">// then reinstall the console overrides.</span>
      <span class="s3">// It's safe to call `patchConsole` multiple times.</span>
      <span class="s0">patch({</span>
        <span class="s0">appendComponentStack: appendComponentStack,</span>
        <span class="s0">breakOnConsoleErrors: breakOnConsoleErrors,</span>
        <span class="s0">showInlineWarningsAndErrors: showInlineWarningsAndErrors,</span>
        <span class="s0">hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,</span>
        <span class="s0">browserTheme: browserTheme</span>
      <span class="s0">});</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;updateComponentFilters&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(componentFilters) {</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">rendererID </span><span class="s1">in </span><span class="s0">_this._rendererInterfaces) {</span>
        <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>
        <span class="s0">renderer.updateComponentFilters(componentFilters);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;viewAttributeSource&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref20) {</span>
      <span class="s1">var </span><span class="s0">id = _ref20.id,</span>
          <span class="s0">path = _ref20.path,</span>
          <span class="s0">rendererID = _ref20.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.prepareViewAttributeSource(id, path);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;viewElementSource&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref21) {</span>
      <span class="s1">var </span><span class="s0">id = _ref21.id,</span>
          <span class="s0">rendererID = _ref21.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">for element </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">).concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">renderer.prepareViewElementSource(id);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;onTraceUpdates&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(nodes) {</span>
      <span class="s0">_this.emit(</span><span class="s2">'traceUpdates'</span><span class="s0">, nodes);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;onFastRefreshScheduled&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
        <span class="s0">debug(</span><span class="s2">'onFastRefreshScheduled'</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s0">_this._bridge.send(</span><span class="s2">'fastRefreshScheduled'</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;onHookOperations&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(operations) {</span>
      <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
        <span class="s0">debug(</span><span class="s2">'onHookOperations'</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">.concat(operations.length, </span><span class="s2">&quot;) [&quot;</span><span class="s0">).concat(operations.join(</span><span class="s2">', '</span><span class="s0">), </span><span class="s2">&quot;]&quot;</span><span class="s0">));</span>
      <span class="s0">} </span><span class="s3">// TODO:</span>
      <span class="s3">// The chrome.runtime does not currently support transferables; it forces JSON serialization.</span>
      <span class="s3">// See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134</span>
      <span class="s3">//</span>
      <span class="s3">// Regarding transferables, the postMessage doc states:</span>
      <span class="s3">// If the ownership of an object is transferred, it becomes unusable (neutered)</span>
      <span class="s3">// in the context it was sent from and becomes available only to the worker it was sent to.</span>
      <span class="s3">//</span>
      <span class="s3">// Even though Chrome is eventually JSON serializing the array buffer,</span>
      <span class="s3">// using the transferable approach also sometimes causes it to throw:</span>
      <span class="s3">//   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.</span>
      <span class="s3">//</span>
      <span class="s3">// See bug https://github.com/bvaughn/react-devtools-experimental/issues/25</span>
      <span class="s3">//</span>
      <span class="s3">// The Store has a fallback in place that parses the message as JSON if the type isn't an array.</span>
      <span class="s3">// For now the simplest fix seems to be to not transfer the array.</span>
      <span class="s3">// This will negatively impact performance on Firefox so it's unfortunate,</span>
      <span class="s3">// but until we're able to fix the Chrome error mentioned above, it seems necessary.</span>
      <span class="s3">//</span>
      <span class="s3">// this._bridge.send('operations', operations, [operations.buffer]);</span>


      <span class="s0">_this._bridge.send(</span><span class="s2">'operations'</span><span class="s0">, operations);</span>

      <span class="s1">if </span><span class="s0">(_this._persistedSelection !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">rendererID = operations[</span><span class="s4">0</span><span class="s0">];</span>

        <span class="s1">if </span><span class="s0">(_this._persistedSelection.rendererID === rendererID) {</span>
          <span class="s3">// Check if we can select a deeper match for the persisted selection.</span>
          <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>

          <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">var </span><span class="s0">prevMatch = _this._persistedSelectionMatch;</span>
            <span class="s1">var </span><span class="s0">nextMatch = renderer.getBestMatchForTrackedPath();</span>
            <span class="s0">_this._persistedSelectionMatch = nextMatch;</span>
            <span class="s1">var </span><span class="s0">prevMatchID = prevMatch !== </span><span class="s1">null </span><span class="s0">? prevMatch.id : </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">nextMatchID = nextMatch !== </span><span class="s1">null </span><span class="s0">? nextMatch.id : </span><span class="s1">null</span><span class="s0">;</span>

            <span class="s1">if </span><span class="s0">(prevMatchID !== nextMatchID) {</span>
              <span class="s1">if </span><span class="s0">(nextMatchID !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s3">// We moved forward, unlocking a deeper node.</span>
                <span class="s0">_this._bridge.send(</span><span class="s2">'selectFiber'</span><span class="s0">, nextMatchID);</span>
              <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(nextMatch !== </span><span class="s1">null </span><span class="s0">&amp;&amp; nextMatch.isFullMatch) {</span>
              <span class="s3">// We've just unlocked the innermost selected node.</span>
              <span class="s3">// There's no point tracking it further.</span>
              <span class="s0">_this._persistedSelection = </span><span class="s1">null</span><span class="s0">;</span>
              <span class="s0">_this._persistedSelectionMatch = </span><span class="s1">null</span><span class="s0">;</span>
              <span class="s0">renderer.setTrackedPath(</span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">agent_defineProperty(agent_assertThisInitialized(_this), </span><span class="s2">&quot;_throttledPersistSelection&quot;</span><span class="s0">, lodash_throttle_default()(</span><span class="s1">function </span><span class="s0">(rendererID, id) {</span>
      <span class="s3">// This is throttled, so both renderer and selected ID</span>
      <span class="s3">// might not be available by the time we read them.</span>
      <span class="s3">// This is why we need the defensive checks here.</span>
      <span class="s1">var </span><span class="s0">renderer = _this._rendererInterfaces[rendererID];</span>
      <span class="s1">var </span><span class="s0">path = renderer != </span><span class="s1">null </span><span class="s0">? renderer.getPathForElement(id) : </span><span class="s1">null</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(path !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">sessionStorageSetItem(SESSION_STORAGE_LAST_SELECTION_KEY, JSON.stringify({</span>
          <span class="s0">rendererID: rendererID,</span>
          <span class="s0">path: path</span>
        <span class="s0">}));</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">sessionStorageRemoveItem(SESSION_STORAGE_LAST_SELECTION_KEY);</span>
      <span class="s0">}</span>
    <span class="s0">}, </span><span class="s4">1000</span><span class="s0">));</span>

    <span class="s1">if </span><span class="s0">(sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === </span><span class="s2">'true'</span><span class="s0">) {</span>
      <span class="s0">_this._recordChangeDescriptions = sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === </span><span class="s2">'true'</span><span class="s0">;</span>
      <span class="s0">_this._isProfiling = </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">sessionStorageRemoveItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY);</span>
      <span class="s0">sessionStorageRemoveItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">persistedSelectionString = sessionStorageGetItem(SESSION_STORAGE_LAST_SELECTION_KEY);</span>

    <span class="s1">if </span><span class="s0">(persistedSelectionString != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">_this._persistedSelection = JSON.parse(persistedSelectionString);</span>
    <span class="s0">}</span>

    <span class="s0">_this._bridge = bridge;</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'clearErrorsAndWarnings'</span><span class="s0">, _this.clearErrorsAndWarnings);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'clearErrorsForFiberID'</span><span class="s0">, _this.clearErrorsForFiberID);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'clearWarningsForFiberID'</span><span class="s0">, _this.clearWarningsForFiberID);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'copyElementPath'</span><span class="s0">, _this.copyElementPath);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'deletePath'</span><span class="s0">, _this.deletePath);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'getBackendVersion'</span><span class="s0">, _this.getBackendVersion);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'getBridgeProtocol'</span><span class="s0">, _this.getBridgeProtocol);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'getProfilingData'</span><span class="s0">, _this.getProfilingData);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'getProfilingStatus'</span><span class="s0">, _this.getProfilingStatus);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'getOwnersList'</span><span class="s0">, _this.getOwnersList);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'inspectElement'</span><span class="s0">, _this.inspectElement);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'logElementToConsole'</span><span class="s0">, _this.logElementToConsole);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'overrideError'</span><span class="s0">, _this.overrideError);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'overrideSuspense'</span><span class="s0">, _this.overrideSuspense);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'overrideValueAtPath'</span><span class="s0">, _this.overrideValueAtPath);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'reloadAndProfile'</span><span class="s0">, _this.reloadAndProfile);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'renamePath'</span><span class="s0">, _this.renamePath);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'setTraceUpdatesEnabled'</span><span class="s0">, _this.setTraceUpdatesEnabled);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'startProfiling'</span><span class="s0">, _this.startProfiling);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'stopProfiling'</span><span class="s0">, _this.stopProfiling);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'storeAsGlobal'</span><span class="s0">, _this.storeAsGlobal);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'syncSelectionFromNativeElementsPanel'</span><span class="s0">, _this.syncSelectionFromNativeElementsPanel);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'shutdown'</span><span class="s0">, _this.shutdown);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'updateConsolePatchSettings'</span><span class="s0">, _this.updateConsolePatchSettings);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'updateComponentFilters'</span><span class="s0">, _this.updateComponentFilters);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'viewAttributeSource'</span><span class="s0">, _this.viewAttributeSource);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'viewElementSource'</span><span class="s0">, _this.viewElementSource); </span><span class="s3">// Temporarily support older standalone front-ends sending commands to newer embedded backends.</span>
    <span class="s3">// We do this because React Native embeds the React DevTools backend,</span>
    <span class="s3">// but cannot control which version of the frontend users use.</span>

    <span class="s0">bridge.addListener(</span><span class="s2">'overrideContext'</span><span class="s0">, _this.overrideContext);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'overrideHookState'</span><span class="s0">, _this.overrideHookState);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'overrideProps'</span><span class="s0">, _this.overrideProps);</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'overrideState'</span><span class="s0">, _this.overrideState);</span>

    <span class="s1">if </span><span class="s0">(_this._isProfiling) {</span>
      <span class="s0">bridge.send(</span><span class="s2">'profilingStatus'</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s3">// Send the Bridge protocol and backend versions, after initialization, in case the frontend has already requested it.</span>
    <span class="s3">// The Store may be instantiated beore the agent.</span>


    <span class="s1">var </span><span class="s0">_version = </span><span class="s2">&quot;4.28.0-9b95b131b&quot;</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(_version) {</span>
      <span class="s0">_this._bridge.send(</span><span class="s2">'backendVersion'</span><span class="s0">, _version);</span>
    <span class="s0">}</span>

    <span class="s0">_this._bridge.send(</span><span class="s2">'bridgeProtocol'</span><span class="s0">, currentBridgeProtocol); </span><span class="s3">// Notify the frontend if the backend supports the Storage API (e.g. localStorage).</span>
    <span class="s3">// If not, features like reload-and-profile will not work correctly and must be disabled.</span>


    <span class="s1">var </span><span class="s0">isBackendStorageAPISupported = </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s0">localStorage.getItem(</span><span class="s2">'test'</span><span class="s0">);</span>
      <span class="s0">isBackendStorageAPISupported = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>

    <span class="s0">bridge.send(</span><span class="s2">'isBackendStorageAPISupported'</span><span class="s0">, isBackendStorageAPISupported);</span>
    <span class="s0">bridge.send(</span><span class="s2">'isSynchronousXHRSupported'</span><span class="s0">, isSynchronousXHRSupported());</span>
    <span class="s0">setupHighlighter(bridge, agent_assertThisInitialized(_this));</span>
    <span class="s0">TraceUpdates_initialize(agent_assertThisInitialized(_this));</span>
    <span class="s1">return </span><span class="s0">_this;</span>
  <span class="s0">}</span>

  <span class="s0">agent_createClass(Agent, [{</span>
    <span class="s0">key: </span><span class="s2">&quot;getInstanceAndStyle&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">getInstanceAndStyle(_ref22) {</span>
      <span class="s1">var </span><span class="s0">id = _ref22.id,</span>
          <span class="s0">rendererID = _ref22.rendererID;</span>
      <span class="s1">var </span><span class="s0">renderer = </span><span class="s1">this</span><span class="s0">._rendererInterfaces[rendererID];</span>

      <span class="s1">if </span><span class="s0">(renderer == </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;Invalid renderer id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(rendererID, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
        <span class="s1">return null</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s0">renderer.getInstanceAndStyle(id);</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;getBestMatchingRendererInterface&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">getBestMatchingRendererInterface(node) {</span>
      <span class="s1">var </span><span class="s0">bestMatch = </span><span class="s1">null</span><span class="s0">;</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">rendererID </span><span class="s1">in this</span><span class="s0">._rendererInterfaces) {</span>
        <span class="s1">var </span><span class="s0">renderer = </span><span class="s1">this</span><span class="s0">._rendererInterfaces[rendererID];</span>
        <span class="s1">var </span><span class="s0">fiber = renderer.getFiberForNative(node);</span>

        <span class="s1">if </span><span class="s0">(fiber !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s3">// check if fiber.stateNode is matching the original hostInstance</span>
          <span class="s1">if </span><span class="s0">(fiber.stateNode === node) {</span>
            <span class="s1">return </span><span class="s0">renderer;</span>
          <span class="s0">} </span><span class="s1">else if </span><span class="s0">(bestMatch === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">bestMatch = renderer;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s3">// if an exact match is not found, return the first valid renderer as fallback</span>


      <span class="s1">return </span><span class="s0">bestMatch;</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;getIDForNode&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">getIDForNode(node) {</span>
      <span class="s1">var </span><span class="s0">rendererInterface = </span><span class="s1">this</span><span class="s0">.getBestMatchingRendererInterface(node);</span>

      <span class="s1">if </span><span class="s0">(rendererInterface != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s1">return </span><span class="s0">rendererInterface.getFiberIDForNative(node, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span><span class="s3">// Some old React versions might throw if they can't find a match.</span>
          <span class="s3">// If so we should ignore it...</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;selectNode&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">selectNode(target) {</span>
      <span class="s1">var </span><span class="s0">id = </span><span class="s1">this</span><span class="s0">.getIDForNode(target);</span>

      <span class="s1">if </span><span class="s0">(id !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">this</span><span class="s0">._bridge.send(</span><span class="s2">'selectFiber'</span><span class="s0">, id);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;setRendererInterface&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">setRendererInterface(rendererID, rendererInterface) {</span>
      <span class="s1">this</span><span class="s0">._rendererInterfaces[rendererID] = rendererInterface;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._isProfiling) {</span>
        <span class="s0">rendererInterface.startProfiling(</span><span class="s1">this</span><span class="s0">._recordChangeDescriptions);</span>
      <span class="s0">}</span>

      <span class="s0">rendererInterface.setTraceUpdatesEnabled(</span><span class="s1">this</span><span class="s0">._traceUpdatesEnabled); </span><span class="s3">// When the renderer is attached, we need to tell it whether</span>
      <span class="s3">// we remember the previous selection that we'd like to restore.</span>
      <span class="s3">// It'll start tracking mounts for matches to the last selection path.</span>

      <span class="s1">var </span><span class="s0">selection = </span><span class="s1">this</span><span class="s0">._persistedSelection;</span>

      <span class="s1">if </span><span class="s0">(selection !== </span><span class="s1">null </span><span class="s0">&amp;&amp; selection.rendererID === rendererID) {</span>
        <span class="s0">rendererInterface.setTrackedPath(selection.path);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;onUnsupportedRenderer&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">function </span><span class="s0">onUnsupportedRenderer(rendererID) {</span>
      <span class="s1">this</span><span class="s0">._bridge.send(</span><span class="s2">'unsupportedRendererVersion'</span><span class="s0">, rendererID);</span>
    <span class="s0">}</span>
  <span class="s0">}, {</span>
    <span class="s0">key: </span><span class="s2">&quot;rendererInterfaces&quot;</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
      <span class="s1">return this</span><span class="s0">._rendererInterfaces;</span>
    <span class="s0">}</span>
  <span class="s0">}]);</span>

  <span class="s1">return </span><span class="s0">Agent;</span>
<span class="s0">}(EventEmitter);</span>


<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/hook.js</span>
<span class="s1">function </span><span class="s0">hook_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { hook_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ hook_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">hook_typeof(obj); }</span>

<span class="s1">function </span><span class="s0">hook_toConsumableArray(arr) { </span><span class="s1">return </span><span class="s0">hook_arrayWithoutHoles(arr) || hook_iterableToArray(arr) || hook_unsupportedIterableToArray(arr) || hook_nonIterableSpread(); }</span>

<span class="s1">function </span><span class="s0">hook_nonIterableSpread() { </span><span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Invalid attempt to spread non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s0">); }</span>

<span class="s1">function </span><span class="s0">hook_unsupportedIterableToArray(o, minLen) { </span><span class="s1">if </span><span class="s0">(!o) </span><span class="s1">return</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">o === </span><span class="s2">&quot;string&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">hook_arrayLikeToArray(o, minLen); </span><span class="s1">var </span><span class="s0">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s0">&amp;&amp; o.constructor) n = o.constructor.name; </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s0">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">Array.from(o); </span><span class="s1">if </span><span class="s0">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s0">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s0">|</span><span class="s4">16</span><span class="s0">|</span><span class="s4">32</span><span class="s0">)(?:Clamped)?Array$/.test(n)) </span><span class="s1">return </span><span class="s0">hook_arrayLikeToArray(o, minLen); }</span>

<span class="s1">function </span><span class="s0">hook_iterableToArray(iter) { </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">&amp;&amp; Symbol.iterator </span><span class="s1">in </span><span class="s0">Object(iter)) </span><span class="s1">return </span><span class="s0">Array.from(iter); }</span>

<span class="s1">function </span><span class="s0">hook_arrayWithoutHoles(arr) { </span><span class="s1">if </span><span class="s0">(Array.isArray(arr)) </span><span class="s1">return </span><span class="s0">hook_arrayLikeToArray(arr); }</span>

<span class="s1">function </span><span class="s0">hook_arrayLikeToArray(arr, len) { </span><span class="s1">if </span><span class="s0">(len == </span><span class="s1">null </span><span class="s0">|| len &gt; arr.length) len = arr.length; </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, arr2 = </span><span class="s1">new </span><span class="s0">Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } </span><span class="s1">return </span><span class="s0">arr2; }</span>

<span class="s3">/** 
 * Install the hook on window, which is an event emitter. 
 * Note: this global hook __REACT_DEVTOOLS_GLOBAL_HOOK__ is a de facto public API. 
 * It's especially important to avoid creating direct dependency on the DevTools Backend. 
 * That's why we still inline the whole event emitter implementation, 
 * the string format implementation, and part of the console implementation here. 
 * 
 *  
 */</span>
<span class="s1">function </span><span class="s0">installHook(target) {</span>
  <span class="s1">if </span><span class="s0">(target.hasOwnProperty(</span><span class="s2">'__REACT_DEVTOOLS_GLOBAL_HOOK__'</span><span class="s0">)) {</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">targetConsole = console;</span>
  <span class="s1">var </span><span class="s0">targetConsoleMethods = {};</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">method </span><span class="s1">in </span><span class="s0">console) {</span>
    <span class="s0">targetConsoleMethods[method] = console[method];</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {</span>
    <span class="s0">targetConsole = targetConsoleForTesting;</span>
    <span class="s0">targetConsoleMethods = {};</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_method </span><span class="s1">in </span><span class="s0">targetConsole) {</span>
      <span class="s0">targetConsoleMethods[_method] = console[_method];</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">detectReactBuildType(renderer) {</span>
    <span class="s1">try </span><span class="s0">{</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">renderer.version === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s3">// React DOM Fiber (16+)</span>
        <span class="s1">if </span><span class="s0">(renderer.bundleType &gt; </span><span class="s4">0</span><span class="s0">) {</span>
          <span class="s3">// This is not a production build.</span>
          <span class="s3">// We are currently only using 0 (PROD) and 1 (DEV)</span>
          <span class="s3">// but might add 2 (PROFILE) in the future.</span>
          <span class="s1">return </span><span class="s2">'development'</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">// React 16 uses flat bundles. If we report the bundle as production</span>
        <span class="s3">// version, it means we also minified and envified it ourselves.</span>


        <span class="s1">return </span><span class="s2">'production'</span><span class="s0">; </span><span class="s3">// Note: There is still a risk that the CommonJS entry point has not</span>
        <span class="s3">// been envified or uglified. In this case the user would have *both*</span>
        <span class="s3">// development and production bundle, but only the prod one would run.</span>
        <span class="s3">// This would be really bad. We have a separate check for this because</span>
        <span class="s3">// it happens *outside* of the renderer injection. See `checkDCE` below.</span>
      <span class="s0">} </span><span class="s3">// $FlowFixMe[method-unbinding]</span>


      <span class="s1">var </span><span class="s0">_toString = Function.prototype.toString;</span>

      <span class="s1">if </span><span class="s0">(renderer.Mount &amp;&amp; renderer.Mount._renderNewRootComponent) {</span>
        <span class="s3">// React DOM Stack</span>
        <span class="s1">var </span><span class="s0">renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent); </span><span class="s3">// Filter out bad results (if that is even possible):</span>


        <span class="s1">if </span><span class="s0">(renderRootCode.indexOf(</span><span class="s2">'function'</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
          <span class="s3">// Hope for the best if we're not sure.</span>
          <span class="s1">return </span><span class="s2">'production'</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">// Check for React DOM Stack &lt; 15.1.0 in development.</span>
        <span class="s3">// If it contains &quot;storedMeasure&quot; call, it's wrapped in ReactPerf (DEV only).</span>
        <span class="s3">// This would be true even if it's minified, as method name still matches.</span>


        <span class="s1">if </span><span class="s0">(renderRootCode.indexOf(</span><span class="s2">'storedMeasure'</span><span class="s0">) !== -</span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s1">return </span><span class="s2">'development'</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">// For other versions (and configurations) it's not so easy.</span>
        <span class="s3">// Let's quickly exclude proper production builds.</span>
        <span class="s3">// If it contains a warning message, it's either a DEV build,</span>
        <span class="s3">// or an PROD build without proper dead code elimination.</span>


        <span class="s1">if </span><span class="s0">(renderRootCode.indexOf(</span><span class="s2">'should be a pure function'</span><span class="s0">) !== -</span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s3">// Now how do we tell a DEV build from a bad PROD build?</span>
          <span class="s3">// If we see NODE_ENV, we're going to assume this is a dev build</span>
          <span class="s3">// because most likely it is referring to an empty shim.</span>
          <span class="s1">if </span><span class="s0">(renderRootCode.indexOf(</span><span class="s2">'NODE_ENV'</span><span class="s0">) !== -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s2">'development'</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s3">// If we see &quot;development&quot;, we're dealing with an envified DEV build</span>
          <span class="s3">// (such as the official React DEV UMD).</span>


          <span class="s1">if </span><span class="s0">(renderRootCode.indexOf(</span><span class="s2">'development'</span><span class="s0">) !== -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s2">'development'</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s3">// I've seen process.env.NODE_ENV !== 'production' being smartly</span>
          <span class="s3">// replaced by `true` in DEV by Webpack. I don't know how that</span>
          <span class="s3">// works but we can safely guard against it because `true` was</span>
          <span class="s3">// never used in the function source since it was written.</span>


          <span class="s1">if </span><span class="s0">(renderRootCode.indexOf(</span><span class="s2">'true'</span><span class="s0">) !== -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s2">'development'</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s3">// By now either it is a production build that has not been minified,</span>
          <span class="s3">// or (worse) this is a minified development build using non-standard</span>
          <span class="s3">// environment (e.g. &quot;staging&quot;). We're going to look at whether</span>
          <span class="s3">// the function argument name is mangled:</span>


          <span class="s1">if </span><span class="s0">( </span><span class="s3">// 0.13 to 15</span>
          <span class="s0">renderRootCode.indexOf(</span><span class="s2">'nextElement'</span><span class="s0">) !== -</span><span class="s4">1 </span><span class="s0">|| </span><span class="s3">// 0.12</span>
          <span class="s0">renderRootCode.indexOf(</span><span class="s2">'nextComponent'</span><span class="s0">) !== -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s3">// We can't be certain whether this is a development build or not,</span>
            <span class="s3">// but it is definitely unminified.</span>
            <span class="s1">return </span><span class="s2">'unminified'</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// This is likely a minified development build.</span>
            <span class="s1">return </span><span class="s2">'development'</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s3">// By now we know that it's envified and dead code elimination worked,</span>
        <span class="s3">// but what if it's still not minified? (Is this even possible?)</span>
        <span class="s3">// Let's check matches for the first argument name.</span>


        <span class="s1">if </span><span class="s0">( </span><span class="s3">// 0.13 to 15</span>
        <span class="s0">renderRootCode.indexOf(</span><span class="s2">'nextElement'</span><span class="s0">) !== -</span><span class="s4">1 </span><span class="s0">|| </span><span class="s3">// 0.12</span>
        <span class="s0">renderRootCode.indexOf(</span><span class="s2">'nextComponent'</span><span class="s0">) !== -</span><span class="s4">1</span><span class="s0">) {</span>
          <span class="s1">return </span><span class="s2">'unminified'</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">// Seems like we're using the production version.</span>
        <span class="s3">// However, the branch above is Stack-only so this is 15 or earlier.</span>


        <span class="s1">return </span><span class="s2">'outdated'</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span><span class="s3">// Weird environments may exist.</span>
      <span class="s3">// This code needs a higher fault tolerance</span>
      <span class="s3">// because it runs even with closed DevTools.</span>
      <span class="s3">// TODO: should we catch errors in all injected code, and not just this part?</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">'production'</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">checkDCE(fn) {</span>
    <span class="s3">// This runs for production versions of React.</span>
    <span class="s3">// Needs to be super safe.</span>
    <span class="s1">try </span><span class="s0">{</span>
      <span class="s3">// $FlowFixMe[method-unbinding]</span>
      <span class="s1">var </span><span class="s0">_toString2 = Function.prototype.toString;</span>

      <span class="s1">var </span><span class="s0">code = _toString2.call(fn); </span><span class="s3">// This is a string embedded in the passed function under DEV-only</span>
      <span class="s3">// condition. However the function executes only in PROD. Therefore,</span>
      <span class="s3">// if we see it, dead code elimination did not work.</span>


      <span class="s1">if </span><span class="s0">(code.indexOf(</span><span class="s2">'^_^'</span><span class="s0">) &gt; -</span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s3">// Remember to report during next injection.</span>
        <span class="s0">hasDetectedBadDCE = </span><span class="s1">true</span><span class="s0">; </span><span class="s3">// Bonus: throw an exception hoping that it gets picked up by a reporting system.</span>
        <span class="s3">// Not synchronously so that it doesn't break the calling code.</span>

        <span class="s0">setTimeout(</span><span class="s1">function </span><span class="s0">() {</span>
          <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'React is running in production mode, but dead code ' </span><span class="s0">+ </span><span class="s2">'elimination has not been applied. Read how to correctly ' </span><span class="s0">+ </span><span class="s2">'configure React for production: ' </span><span class="s0">+ </span><span class="s2">'https://reactjs.org/link/perf-use-production-build'</span><span class="s0">);</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {}</span>
  <span class="s0">} </span><span class="s3">// NOTE: KEEP IN SYNC with src/backend/utils.js</span>


  <span class="s1">function </span><span class="s0">formatWithStyles(inputArgs, style) {</span>
    <span class="s1">if </span><span class="s0">(inputArgs === undefined || inputArgs === </span><span class="s1">null </span><span class="s0">|| inputArgs.length === </span><span class="s4">0 </span><span class="s0">|| </span><span class="s3">// Matches any of %c but not %%c</span>
    <span class="s1">typeof </span><span class="s0">inputArgs[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; inputArgs[</span><span class="s4">0</span><span class="s0">].match(/([^%]|^)(%c)/g) || style === undefined) {</span>
      <span class="s1">return </span><span class="s0">inputArgs;</span>
    <span class="s0">} </span><span class="s3">// Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)</span>


    <span class="s1">var </span><span class="s0">REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">inputArgs[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; inputArgs[</span><span class="s4">0</span><span class="s0">].match(REGEXP)) {</span>
      <span class="s1">return </span><span class="s0">[</span><span class="s2">&quot;%c&quot;</span><span class="s0">.concat(inputArgs[</span><span class="s4">0</span><span class="s0">]), style].concat(hook_toConsumableArray(inputArgs.slice(</span><span class="s4">1</span><span class="s0">)));</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">firstArg = inputArgs.reduce(</span><span class="s1">function </span><span class="s0">(formatStr, elem, i) {</span>
        <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s4">0</span><span class="s0">) {</span>
          <span class="s0">formatStr += </span><span class="s2">' '</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">switch </span><span class="s0">(hook_typeof(elem)) {</span>
          <span class="s1">case </span><span class="s2">'string'</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">'boolean'</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">'symbol'</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">formatStr += </span><span class="s2">'%s'</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'number'</span><span class="s0">:</span>
            <span class="s1">var </span><span class="s0">formatting = Number.isInteger(elem) ? </span><span class="s2">'%i' </span><span class="s0">: </span><span class="s2">'%f'</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">formatStr += formatting;</span>

          <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">formatStr += </span><span class="s2">'%o'</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}, </span><span class="s2">'%c'</span><span class="s0">);</span>
      <span class="s1">return </span><span class="s0">[firstArg, style].concat(hook_toConsumableArray(inputArgs));</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">unpatchFn = </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// NOTE: KEEP IN SYNC with src/backend/console.js:patchForStrictMode</span>
  <span class="s3">// This function hides or dims console logs during the initial double renderer</span>
  <span class="s3">// in Strict Mode. We need this function because during initial render,</span>
  <span class="s3">// React and DevTools are connecting and the renderer interface isn't avaiable</span>
  <span class="s3">// and we want to be able to have consistent logging behavior for double logs</span>
  <span class="s3">// during the initial renderer.</span>

  <span class="s1">function </span><span class="s0">patchConsoleForInitialRenderInStrictMode(_ref) {</span>
    <span class="s1">var </span><span class="s0">hideConsoleLogsInStrictMode = _ref.hideConsoleLogsInStrictMode,</span>
        <span class="s0">browserTheme = _ref.browserTheme;</span>
    <span class="s1">var </span><span class="s0">overrideConsoleMethods = [</span><span class="s2">'error'</span><span class="s0">, </span><span class="s2">'group'</span><span class="s0">, </span><span class="s2">'groupCollapsed'</span><span class="s0">, </span><span class="s2">'info'</span><span class="s0">, </span><span class="s2">'log'</span><span class="s0">, </span><span class="s2">'trace'</span><span class="s0">, </span><span class="s2">'warn'</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(unpatchFn !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Don't patch twice.</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">originalConsoleMethods = {};</span>

    <span class="s0">unpatchFn = </span><span class="s1">function </span><span class="s0">unpatchFn() {</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_method2 </span><span class="s1">in </span><span class="s0">originalConsoleMethods) {</span>
        <span class="s1">try </span><span class="s0">{</span>
          <span class="s0">targetConsole[_method2] = originalConsoleMethods[_method2];</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
      <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s0">overrideConsoleMethods.forEach(</span><span class="s1">function </span><span class="s0">(method) {</span>
      <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method];</span>

        <span class="s1">var </span><span class="s0">overrideMethod = </span><span class="s1">function </span><span class="s0">overrideMethod() {</span>
          <span class="s1">if </span><span class="s0">(!hideConsoleLogsInStrictMode) {</span>
            <span class="s3">// Dim the text color of the double logs if we're not</span>
            <span class="s3">// hiding them.</span>
            <span class="s1">var </span><span class="s0">color;</span>

            <span class="s1">switch </span><span class="s0">(method) {</span>
              <span class="s1">case </span><span class="s2">'warn'</span><span class="s0">:</span>
                <span class="s0">color = browserTheme === </span><span class="s2">'light' </span><span class="s0">? </span><span class="s2">&quot;rgba(250, 180, 50, 0.75)&quot; </span><span class="s0">: </span><span class="s2">&quot;rgba(250, 180, 50, 0.5)&quot;</span><span class="s0">;</span>
                <span class="s1">break</span><span class="s0">;</span>

              <span class="s1">case </span><span class="s2">'error'</span><span class="s0">:</span>
                <span class="s0">color = browserTheme === </span><span class="s2">'light' </span><span class="s0">? </span><span class="s2">&quot;rgba(250, 123, 130, 0.75)&quot; </span><span class="s0">: </span><span class="s2">&quot;rgba(250, 123, 130, 0.5)&quot;</span><span class="s0">;</span>
                <span class="s1">break</span><span class="s0">;</span>

              <span class="s1">case </span><span class="s2">'log'</span><span class="s0">:</span>
              <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">color = browserTheme === </span><span class="s2">'light' </span><span class="s0">? </span><span class="s2">&quot;rgba(125, 125, 125, 0.75)&quot; </span><span class="s0">: </span><span class="s2">&quot;rgba(125, 125, 125, 0.5)&quot;</span><span class="s0">;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(color) {</span>
              <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, args = </span><span class="s1">new </span><span class="s0">Array(_len), _key = </span><span class="s4">0</span><span class="s0">; _key &lt; _len; _key++) {</span>
                <span class="s0">args[_key] = arguments[_key];</span>
              <span class="s0">}</span>

              <span class="s0">originalMethod.apply(</span><span class="s1">void </span><span class="s4">0</span><span class="s0">, hook_toConsumableArray(formatWithStyles(args, </span><span class="s2">&quot;color: &quot;</span><span class="s0">.concat(color))));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
              <span class="s1">throw </span><span class="s0">Error(</span><span class="s2">'Console color is not defined'</span><span class="s0">);</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">};</span>

        <span class="s0">overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;</span>
        <span class="s0">originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;</span>
        <span class="s0">targetConsole[method] = overrideMethod;</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {}</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s3">// NOTE: KEEP IN SYNC with src/backend/console.js:unpatchForStrictMode</span>


  <span class="s1">function </span><span class="s0">unpatchConsoleForInitialRenderInStrictMode() {</span>
    <span class="s1">if </span><span class="s0">(unpatchFn !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">unpatchFn();</span>
      <span class="s0">unpatchFn = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">uidCounter = </span><span class="s4">0</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">inject(renderer) {</span>
    <span class="s1">var </span><span class="s0">id = ++uidCounter;</span>
    <span class="s0">renderers.set(id, renderer);</span>
    <span class="s1">var </span><span class="s0">reactBuildType = hasDetectedBadDCE ? </span><span class="s2">'deadcode' </span><span class="s0">: detectReactBuildType(renderer); </span><span class="s3">// Patching the console enables DevTools to do a few useful things:</span>
    <span class="s3">// * Append component stacks to warnings and error messages</span>
    <span class="s3">// * Disabling or marking logs during a double render in Strict Mode</span>
    <span class="s3">// * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)</span>
    <span class="s3">//</span>
    <span class="s3">// Allow patching console early (during injection) to</span>
    <span class="s3">// provide developers with components stacks even if they don't run DevTools.</span>

    <span class="s1">if </span><span class="s0">(target.hasOwnProperty(</span><span class="s2">'__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__'</span><span class="s0">)) {</span>
      <span class="s1">var </span><span class="s0">_target$__REACT_DEVTO = target.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__,</span>
          <span class="s0">registerRendererWithConsole = _target$__REACT_DEVTO.registerRendererWithConsole,</span>
          <span class="s0">patchConsoleUsingWindowValues = _target$__REACT_DEVTO.patchConsoleUsingWindowValues;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">registerRendererWithConsole === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">patchConsoleUsingWindowValues === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s0">registerRendererWithConsole(renderer);</span>
        <span class="s0">patchConsoleUsingWindowValues();</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">// If we have just reloaded to profile, we need to inject the renderer interface before the app loads.</span>
    <span class="s3">// Otherwise the renderer won't yet exist and we can skip this step.</span>


    <span class="s1">var </span><span class="s0">attach = target.__REACT_DEVTOOLS_ATTACH__;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">attach === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">rendererInterface = attach(hook, id, renderer, target);</span>
      <span class="s0">hook.rendererInterfaces.set(id, rendererInterface);</span>
    <span class="s0">}</span>

    <span class="s0">hook.emit(</span><span class="s2">'renderer'</span><span class="s0">, {</span>
      <span class="s0">id: id,</span>
      <span class="s0">renderer: renderer,</span>
      <span class="s0">reactBuildType: reactBuildType</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">id;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">hasDetectedBadDCE = </span><span class="s1">false</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">sub(event, fn) {</span>
    <span class="s0">hook.on(event, fn);</span>
    <span class="s1">return function </span><span class="s0">() {</span>
      <span class="s1">return </span><span class="s0">hook.off(event, fn);</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">on(event, fn) {</span>
    <span class="s1">if </span><span class="s0">(!listeners[event]) {</span>
      <span class="s0">listeners[event] = [];</span>
    <span class="s0">}</span>

    <span class="s0">listeners[event].push(fn);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">off(event, fn) {</span>
    <span class="s1">if </span><span class="s0">(!listeners[event]) {</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">index = listeners[event].indexOf(fn);</span>

    <span class="s1">if </span><span class="s0">(index !== -</span><span class="s4">1</span><span class="s0">) {</span>
      <span class="s0">listeners[event].splice(index, </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!listeners[event].length) {</span>
      <span class="s1">delete </span><span class="s0">listeners[event];</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">emit(event, data) {</span>
    <span class="s1">if </span><span class="s0">(listeners[event]) {</span>
      <span class="s0">listeners[event].map(</span><span class="s1">function </span><span class="s0">(fn) {</span>
        <span class="s1">return </span><span class="s0">fn(data);</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getFiberRoots(rendererID) {</span>
    <span class="s1">var </span><span class="s0">roots = fiberRoots;</span>

    <span class="s1">if </span><span class="s0">(!roots[rendererID]) {</span>
      <span class="s0">roots[rendererID] = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">roots[rendererID];</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">onCommitFiberUnmount(rendererID, fiber) {</span>
    <span class="s1">var </span><span class="s0">rendererInterface = rendererInterfaces.get(rendererID);</span>

    <span class="s1">if </span><span class="s0">(rendererInterface != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">rendererInterface.handleCommitFiberUnmount(fiber);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">onCommitFiberRoot(rendererID, root, priorityLevel) {</span>
    <span class="s1">var </span><span class="s0">mountedRoots = hook.getFiberRoots(rendererID);</span>
    <span class="s1">var </span><span class="s0">current = root.current;</span>
    <span class="s1">var </span><span class="s0">isKnownRoot = mountedRoots.has(root);</span>
    <span class="s1">var </span><span class="s0">isUnmounting = current.memoizedState == </span><span class="s1">null </span><span class="s0">|| current.memoizedState.element == </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// Keep track of mounted roots so we can hydrate when DevTools connect.</span>

    <span class="s1">if </span><span class="s0">(!isKnownRoot &amp;&amp; !isUnmounting) {</span>
      <span class="s0">mountedRoots.add(root);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(isKnownRoot &amp;&amp; isUnmounting) {</span>
      <span class="s0">mountedRoots.</span><span class="s1">delete</span><span class="s0">(root);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">rendererInterface = rendererInterfaces.get(rendererID);</span>

    <span class="s1">if </span><span class="s0">(rendererInterface != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">rendererInterface.handleCommitFiberRoot(root, priorityLevel);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">onPostCommitFiberRoot(rendererID, root) {</span>
    <span class="s1">var </span><span class="s0">rendererInterface = rendererInterfaces.get(rendererID);</span>

    <span class="s1">if </span><span class="s0">(rendererInterface != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">rendererInterface.handlePostCommitFiberRoot(root);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">setStrictMode(rendererID, isStrictMode) {</span>
    <span class="s1">var </span><span class="s0">rendererInterface = rendererInterfaces.get(rendererID);</span>

    <span class="s1">if </span><span class="s0">(rendererInterface != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(isStrictMode) {</span>
        <span class="s0">rendererInterface.patchConsoleForStrictMode();</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">rendererInterface.unpatchConsoleForStrictMode();</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s3">// This should only happen during initial render in the extension before DevTools</span>
      <span class="s3">// finishes its handshake with the injected renderer</span>
      <span class="s1">if </span><span class="s0">(isStrictMode) {</span>
        <span class="s1">var </span><span class="s0">hideConsoleLogsInStrictMode = window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ === </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">browserTheme = window.__REACT_DEVTOOLS_BROWSER_THEME__;</span>
        <span class="s0">patchConsoleForInitialRenderInStrictMode({</span>
          <span class="s0">hideConsoleLogsInStrictMode: hideConsoleLogsInStrictMode,</span>
          <span class="s0">browserTheme: browserTheme</span>
        <span class="s0">});</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">unpatchConsoleForInitialRenderInStrictMode();</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">openModuleRangesStack = [];</span>
  <span class="s1">var </span><span class="s0">moduleRanges = [];</span>

  <span class="s1">function </span><span class="s0">getTopStackFrameString(error) {</span>
    <span class="s1">var </span><span class="s0">frames = error.stack.split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">frame = frames.length &gt; </span><span class="s4">1 </span><span class="s0">? frames[</span><span class="s4">1</span><span class="s0">] : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">frame;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getInternalModuleRanges() {</span>
    <span class="s1">return </span><span class="s0">moduleRanges;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">registerInternalModuleStart(error) {</span>
    <span class="s1">var </span><span class="s0">startStackFrame = getTopStackFrameString(error);</span>

    <span class="s1">if </span><span class="s0">(startStackFrame !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">openModuleRangesStack.push(startStackFrame);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">registerInternalModuleStop(error) {</span>
    <span class="s1">if </span><span class="s0">(openModuleRangesStack.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">startStackFrame = openModuleRangesStack.pop();</span>
      <span class="s1">var </span><span class="s0">stopStackFrame = getTopStackFrameString(error);</span>

      <span class="s1">if </span><span class="s0">(stopStackFrame !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">moduleRanges.push([startStackFrame, stopStackFrame]);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// TODO: More meaningful names for &quot;rendererInterfaces&quot; and &quot;renderers&quot;.</span>


  <span class="s1">var </span><span class="s0">fiberRoots = {};</span>
  <span class="s1">var </span><span class="s0">rendererInterfaces = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">listeners = {};</span>
  <span class="s1">var </span><span class="s0">renderers = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">backends = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">hook = {</span>
    <span class="s0">rendererInterfaces: rendererInterfaces,</span>
    <span class="s0">listeners: listeners,</span>
    <span class="s0">backends: backends,</span>
    <span class="s3">// Fast Refresh for web relies on this.</span>
    <span class="s0">renderers: renderers,</span>
    <span class="s0">emit: emit,</span>
    <span class="s0">getFiberRoots: getFiberRoots,</span>
    <span class="s0">inject: inject,</span>
    <span class="s0">on: on,</span>
    <span class="s0">off: off,</span>
    <span class="s0">sub: sub,</span>
    <span class="s3">// This is a legacy flag.</span>
    <span class="s3">// React v16 checks the hook for this to ensure DevTools is new enough.</span>
    <span class="s0">supportsFiber: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s3">// React calls these methods.</span>
    <span class="s0">checkDCE: checkDCE,</span>
    <span class="s0">onCommitFiberUnmount: onCommitFiberUnmount,</span>
    <span class="s0">onCommitFiberRoot: onCommitFiberRoot,</span>
    <span class="s0">onPostCommitFiberRoot: onPostCommitFiberRoot,</span>
    <span class="s0">setStrictMode: setStrictMode,</span>
    <span class="s3">// Schedule Profiler runtime helpers.</span>
    <span class="s3">// These internal React modules to report their own boundaries</span>
    <span class="s3">// which in turn enables the profiler to dim or filter internal frames.</span>
    <span class="s0">getInternalModuleRanges: getInternalModuleRanges,</span>
    <span class="s0">registerInternalModuleStart: registerInternalModuleStart,</span>
    <span class="s0">registerInternalModuleStop: registerInternalModuleStop</span>
  <span class="s0">};</span>

  <span class="s1">if </span><span class="s0">(</span><span class="s1">false</span><span class="s0">) {}</span>

  <span class="s0">Object.defineProperty(target, </span><span class="s2">'__REACT_DEVTOOLS_GLOBAL_HOOK__'</span><span class="s0">, {</span>
    <span class="s3">// This property needs to be configurable for the test environment,</span>
    <span class="s3">// else we won't be able to delete and recreate it between tests.</span>
    <span class="s0">configurable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
      <span class="s1">return </span><span class="s0">hook;</span>
    <span class="s0">}</span>
  <span class="s0">});</span>
  <span class="s1">return </span><span class="s0">hook;</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/utils.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>
<span class="s1">function </span><span class="s0">decorate(object, attr, fn) {</span>
  <span class="s1">var </span><span class="s0">old = object[attr]; </span><span class="s3">// $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations</span>

  <span class="s0">object[attr] = </span><span class="s1">function </span><span class="s0">(instance) {</span>
    <span class="s1">return </span><span class="s0">fn.call(</span><span class="s1">this</span><span class="s0">, old, arguments);</span>
  <span class="s0">};</span>

  <span class="s1">return </span><span class="s0">old;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">decorateMany(source, fns) {</span>
  <span class="s1">var </span><span class="s0">olds = {};</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">fns) {</span>
    <span class="s0">olds[name] = decorate(source, name, fns[name]);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">olds;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">restoreMany(source, olds) {</span>
  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">olds) {</span>
    <span class="s0">source[name] = olds[name];</span>
  <span class="s0">}</span>
<span class="s0">} </span><span class="s3">// $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations</span>

<span class="s1">function </span><span class="s0">forceUpdate(instance) {</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">instance.forceUpdate === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s0">instance.forceUpdate();</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(instance.updater != </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">instance.updater.enqueueForceUpdate === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s0">instance.updater.enqueueForceUpdate(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {}, </span><span class="s2">'forceUpdate'</span><span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/renderer.js</span>
<span class="s1">function </span><span class="s0">legacy_renderer_ownKeys(object, enumerableOnly) { </span><span class="s1">var </span><span class="s0">keys = Object.keys(object); </span><span class="s1">if </span><span class="s0">(Object.getOwnPropertySymbols) { </span><span class="s1">var </span><span class="s0">symbols = Object.getOwnPropertySymbols(object); </span><span class="s1">if </span><span class="s0">(enumerableOnly) symbols = symbols.filter(</span><span class="s1">function </span><span class="s0">(sym) { </span><span class="s1">return </span><span class="s0">Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } </span><span class="s1">return </span><span class="s0">keys; }</span>

<span class="s1">function </span><span class="s0">legacy_renderer_objectSpread(target) { </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; arguments.length; i++) { </span><span class="s1">var </span><span class="s0">source = arguments[i] != </span><span class="s1">null </span><span class="s0">? arguments[i] : {}; </span><span class="s1">if </span><span class="s0">(i % </span><span class="s4">2</span><span class="s0">) { legacy_renderer_ownKeys(Object(source), </span><span class="s1">true</span><span class="s0">).forEach(</span><span class="s1">function </span><span class="s0">(key) { legacy_renderer_defineProperty(target, key, source[key]); }); } </span><span class="s1">else if </span><span class="s0">(Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } </span><span class="s1">else </span><span class="s0">{ legacy_renderer_ownKeys(Object(source)).forEach(</span><span class="s1">function </span><span class="s0">(key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } </span><span class="s1">return </span><span class="s0">target; }</span>

<span class="s1">function </span><span class="s0">legacy_renderer_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s1">function </span><span class="s0">legacy_renderer_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { legacy_renderer_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ legacy_renderer_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">legacy_renderer_typeof(obj); }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>







<span class="s1">function </span><span class="s0">getData(internalInstance) {</span>
  <span class="s1">var </span><span class="s0">displayName = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">key = </span><span class="s1">null</span><span class="s0">; </span><span class="s3">// != used deliberately here to catch undefined and null</span>

  <span class="s1">if </span><span class="s0">(internalInstance._currentElement != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(internalInstance._currentElement.key) {</span>
      <span class="s0">key = String(internalInstance._currentElement.key);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">elementType = internalInstance._currentElement.type;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">elementType === </span><span class="s2">'string'</span><span class="s0">) {</span>
      <span class="s0">displayName = elementType;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">elementType === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s0">displayName = getDisplayName(elementType);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">displayName: displayName,</span>
    <span class="s0">key: key</span>
  <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">getElementType(internalInstance) {</span>
  <span class="s3">// != used deliberately here to catch undefined and null</span>
  <span class="s1">if </span><span class="s0">(internalInstance._currentElement != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">elementType = internalInstance._currentElement.type;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">elementType === </span><span class="s2">'function'</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">publicInstance = internalInstance.getPublicInstance();</span>

      <span class="s1">if </span><span class="s0">(publicInstance !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">types_ElementTypeClass;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">types_ElementTypeFunction;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">elementType === </span><span class="s2">'string'</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">ElementTypeHostComponent;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">ElementTypeOtherOrUnknown;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">getChildren(internalInstance) {</span>
  <span class="s1">var </span><span class="s0">children = []; </span><span class="s3">// If the parent is a native node without rendered children, but with</span>
  <span class="s3">// multiple string children, then the `element` that gets passed in here is</span>
  <span class="s3">// a plain value -- a string or number.</span>

  <span class="s1">if </span><span class="s0">(legacy_renderer_typeof(internalInstance) !== </span><span class="s2">'object'</span><span class="s0">) {</span><span class="s3">// No children</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(internalInstance._currentElement === </span><span class="s1">null </span><span class="s0">|| internalInstance._currentElement === </span><span class="s1">false</span><span class="s0">) {</span><span class="s3">// No children</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(internalInstance._renderedComponent) {</span>
    <span class="s1">var </span><span class="s0">child = internalInstance._renderedComponent;</span>

    <span class="s1">if </span><span class="s0">(getElementType(child) !== ElementTypeOtherOrUnknown) {</span>
      <span class="s0">children.push(child);</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(internalInstance._renderedChildren) {</span>
    <span class="s1">var </span><span class="s0">renderedChildren = internalInstance._renderedChildren;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">renderedChildren) {</span>
      <span class="s1">var </span><span class="s0">_child = renderedChildren[name];</span>

      <span class="s1">if </span><span class="s0">(getElementType(_child) !== ElementTypeOtherOrUnknown) {</span>
        <span class="s0">children.push(_child);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// Note: we skip the case where children are just strings or numbers</span>
  <span class="s3">// because the new DevTools skips over host text nodes anyway.</span>


  <span class="s1">return </span><span class="s0">children;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">renderer_attach(hook, rendererID, renderer, global) {</span>
  <span class="s1">var </span><span class="s0">idToInternalInstanceMap = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">internalInstanceToIDMap = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
  <span class="s1">var </span><span class="s0">internalInstanceToRootIDMap = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
  <span class="s1">var </span><span class="s0">getInternalIDForNative = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">findNativeNodeForInternalID;</span>

  <span class="s1">var </span><span class="s0">getFiberForNative = </span><span class="s1">function </span><span class="s0">getFiberForNative(node) {</span>
    <span class="s3">// Not implemented.</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">};</span>

  <span class="s1">if </span><span class="s0">(renderer.ComponentTree) {</span>
    <span class="s0">getInternalIDForNative = </span><span class="s1">function </span><span class="s0">getInternalIDForNative(node, findNearestUnfilteredAncestor) {</span>
      <span class="s1">var </span><span class="s0">internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);</span>
      <span class="s1">return </span><span class="s0">internalInstanceToIDMap.get(internalInstance) || </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s0">findNativeNodeForInternalID = </span><span class="s1">function </span><span class="s0">findNativeNodeForInternalID(id) {</span>
      <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>
      <span class="s1">return </span><span class="s0">renderer.ComponentTree.getNodeFromInstance(internalInstance);</span>
    <span class="s0">};</span>

    <span class="s0">getFiberForNative = </span><span class="s1">function </span><span class="s0">getFiberForNative(node) {</span>
      <span class="s1">return </span><span class="s0">renderer.ComponentTree.getClosestInstanceFromNode(node);</span>
    <span class="s0">};</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(renderer.Mount.getID &amp;&amp; renderer.Mount.getNode) {</span>
    <span class="s0">getInternalIDForNative = </span><span class="s1">function </span><span class="s0">getInternalIDForNative(node, findNearestUnfilteredAncestor) {</span>
      <span class="s3">// Not implemented.</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s0">findNativeNodeForInternalID = </span><span class="s1">function </span><span class="s0">findNativeNodeForInternalID(id) {</span>
      <span class="s3">// Not implemented.</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getDisplayNameForFiberID(id) {</span>
    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>
    <span class="s1">return </span><span class="s0">internalInstance ? getData(internalInstance).displayName : </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getID(internalInstance) {</span>
    <span class="s1">if </span><span class="s0">(legacy_renderer_typeof(internalInstance) !== </span><span class="s2">'object' </span><span class="s0">|| internalInstance === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Invalid internal instance: ' </span><span class="s0">+ internalInstance);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!internalInstanceToIDMap.has(internalInstance)) {</span>
      <span class="s1">var </span><span class="s0">_id = getUID();</span>

      <span class="s0">internalInstanceToIDMap.set(internalInstance, _id);</span>
      <span class="s0">idToInternalInstanceMap.set(_id, internalInstance);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">internalInstanceToIDMap.get(internalInstance);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">areEqualArrays(a, b) {</span>
    <span class="s1">if </span><span class="s0">(a.length !== b.length) {</span>
      <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; a.length; i++) {</span>
      <span class="s1">if </span><span class="s0">(a[i] !== b[i]) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return true</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s3">// This is shared mutable state that lets us keep track of where we are.</span>


  <span class="s1">var </span><span class="s0">parentIDStack = [];</span>
  <span class="s1">var </span><span class="s0">oldReconcilerMethods = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">if </span><span class="s0">(renderer.Reconciler) {</span>
    <span class="s3">// React 15</span>
    <span class="s0">oldReconcilerMethods = decorateMany(renderer.Reconciler, {</span>
      <span class="s0">mountComponent: </span><span class="s1">function </span><span class="s0">mountComponent(fn, args) {</span>
        <span class="s1">var </span><span class="s0">internalInstance = args[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">var </span><span class="s0">hostContainerInfo = args[</span><span class="s4">3</span><span class="s0">];</span>

        <span class="s1">if </span><span class="s0">(getElementType(internalInstance) === ElementTypeOtherOrUnknown) {</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">return </span><span class="s0">fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(hostContainerInfo._topLevelWrapper === undefined) {</span>
          <span class="s3">// SSR</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">return </span><span class="s0">fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">id = getID(internalInstance); </span><span class="s3">// Push the operation.</span>

        <span class="s1">var </span><span class="s0">parentID = parentIDStack.length &gt; </span><span class="s4">0 </span><span class="s0">? parentIDStack[parentIDStack.length - </span><span class="s4">1</span><span class="s0">] : </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">recordMount(internalInstance, id, parentID);</span>
        <span class="s0">parentIDStack.push(id); </span><span class="s3">// Remember the root.</span>

        <span class="s0">internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));</span>

        <span class="s1">try </span><span class="s0">{</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">var </span><span class="s0">result = fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
          <span class="s0">parentIDStack.pop();</span>
          <span class="s1">return </span><span class="s0">result;</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
          <span class="s0">parentIDStack = [];</span>
          <span class="s1">throw </span><span class="s0">err;</span>
        <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
          <span class="s1">if </span><span class="s0">(parentIDStack.length === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">rootID = internalInstanceToRootIDMap.get(internalInstance);</span>

            <span class="s1">if </span><span class="s0">(rootID === undefined) {</span>
              <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected to find root ID.'</span><span class="s0">);</span>
            <span class="s0">}</span>

            <span class="s0">flushPendingEvents(rootID);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">},</span>
      <span class="s0">performUpdateIfNecessary: </span><span class="s1">function </span><span class="s0">performUpdateIfNecessary(fn, args) {</span>
        <span class="s1">var </span><span class="s0">internalInstance = args[</span><span class="s4">0</span><span class="s0">];</span>

        <span class="s1">if </span><span class="s0">(getElementType(internalInstance) === ElementTypeOtherOrUnknown) {</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">return </span><span class="s0">fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">id = getID(internalInstance);</span>
        <span class="s0">parentIDStack.push(id);</span>
        <span class="s1">var </span><span class="s0">prevChildren = getChildren(internalInstance);</span>

        <span class="s1">try </span><span class="s0">{</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">var </span><span class="s0">result = fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
          <span class="s1">var </span><span class="s0">nextChildren = getChildren(internalInstance);</span>

          <span class="s1">if </span><span class="s0">(!areEqualArrays(prevChildren, nextChildren)) {</span>
            <span class="s3">// Push the operation</span>
            <span class="s0">recordReorder(internalInstance, id, nextChildren);</span>
          <span class="s0">}</span>

          <span class="s0">parentIDStack.pop();</span>
          <span class="s1">return </span><span class="s0">result;</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
          <span class="s0">parentIDStack = [];</span>
          <span class="s1">throw </span><span class="s0">err;</span>
        <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
          <span class="s1">if </span><span class="s0">(parentIDStack.length === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">rootID = internalInstanceToRootIDMap.get(internalInstance);</span>

            <span class="s1">if </span><span class="s0">(rootID === undefined) {</span>
              <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected to find root ID.'</span><span class="s0">);</span>
            <span class="s0">}</span>

            <span class="s0">flushPendingEvents(rootID);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">},</span>
      <span class="s0">receiveComponent: </span><span class="s1">function </span><span class="s0">receiveComponent(fn, args) {</span>
        <span class="s1">var </span><span class="s0">internalInstance = args[</span><span class="s4">0</span><span class="s0">];</span>

        <span class="s1">if </span><span class="s0">(getElementType(internalInstance) === ElementTypeOtherOrUnknown) {</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">return </span><span class="s0">fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">id = getID(internalInstance);</span>
        <span class="s0">parentIDStack.push(id);</span>
        <span class="s1">var </span><span class="s0">prevChildren = getChildren(internalInstance);</span>

        <span class="s1">try </span><span class="s0">{</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">var </span><span class="s0">result = fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
          <span class="s1">var </span><span class="s0">nextChildren = getChildren(internalInstance);</span>

          <span class="s1">if </span><span class="s0">(!areEqualArrays(prevChildren, nextChildren)) {</span>
            <span class="s3">// Push the operation</span>
            <span class="s0">recordReorder(internalInstance, id, nextChildren);</span>
          <span class="s0">}</span>

          <span class="s0">parentIDStack.pop();</span>
          <span class="s1">return </span><span class="s0">result;</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
          <span class="s0">parentIDStack = [];</span>
          <span class="s1">throw </span><span class="s0">err;</span>
        <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
          <span class="s1">if </span><span class="s0">(parentIDStack.length === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">rootID = internalInstanceToRootIDMap.get(internalInstance);</span>

            <span class="s1">if </span><span class="s0">(rootID === undefined) {</span>
              <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected to find root ID.'</span><span class="s0">);</span>
            <span class="s0">}</span>

            <span class="s0">flushPendingEvents(rootID);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">},</span>
      <span class="s0">unmountComponent: </span><span class="s1">function </span><span class="s0">unmountComponent(fn, args) {</span>
        <span class="s1">var </span><span class="s0">internalInstance = args[</span><span class="s4">0</span><span class="s0">];</span>

        <span class="s1">if </span><span class="s0">(getElementType(internalInstance) === ElementTypeOtherOrUnknown) {</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">return </span><span class="s0">fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">id = getID(internalInstance);</span>
        <span class="s0">parentIDStack.push(id);</span>

        <span class="s1">try </span><span class="s0">{</span>
          <span class="s3">// $FlowFixMe[object-this-reference] found when upgrading Flow</span>
          <span class="s1">var </span><span class="s0">result = fn.apply(</span><span class="s1">this</span><span class="s0">, args);</span>
          <span class="s0">parentIDStack.pop(); </span><span class="s3">// Push the operation.</span>

          <span class="s0">recordUnmount(internalInstance, id);</span>
          <span class="s1">return </span><span class="s0">result;</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
          <span class="s0">parentIDStack = [];</span>
          <span class="s1">throw </span><span class="s0">err;</span>
        <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
          <span class="s1">if </span><span class="s0">(parentIDStack.length === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">rootID = internalInstanceToRootIDMap.get(internalInstance);</span>

            <span class="s1">if </span><span class="s0">(rootID === undefined) {</span>
              <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Expected to find root ID.'</span><span class="s0">);</span>
            <span class="s0">}</span>

            <span class="s0">flushPendingEvents(rootID);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">cleanup() {</span>
    <span class="s1">if </span><span class="s0">(oldReconcilerMethods !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(renderer.Component) {</span>
        <span class="s0">restoreMany(renderer.Component.Mixin, oldReconcilerMethods);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">restoreMany(renderer.Reconciler, oldReconcilerMethods);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">oldReconcilerMethods = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordMount(internalInstance, id, parentID) {</span>
    <span class="s1">var </span><span class="s0">isRoot = parentID === </span><span class="s4">0</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">console.log(</span><span class="s2">'%crecordMount()'</span><span class="s0">, </span><span class="s2">'color: green; font-weight: bold;'</span><span class="s0">, id, getData(internalInstance).displayName);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(isRoot) {</span>
      <span class="s3">// TODO Is this right? For all versions?</span>
      <span class="s1">var </span><span class="s0">hasOwnerMetadata = internalInstance._currentElement != </span><span class="s1">null </span><span class="s0">&amp;&amp; internalInstance._currentElement._owner != </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">pushOperation(TREE_OPERATION_ADD);</span>
      <span class="s0">pushOperation(id);</span>
      <span class="s0">pushOperation(ElementTypeRoot);</span>
      <span class="s0">pushOperation(</span><span class="s4">0</span><span class="s0">); </span><span class="s3">// StrictMode compliant?</span>

      <span class="s0">pushOperation(</span><span class="s4">0</span><span class="s0">); </span><span class="s3">// Profiling flag</span>

      <span class="s0">pushOperation(</span><span class="s4">0</span><span class="s0">); </span><span class="s3">// StrictMode supported?</span>

      <span class="s0">pushOperation(hasOwnerMetadata ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">var </span><span class="s0">type = getElementType(internalInstance);</span>

      <span class="s1">var </span><span class="s0">_getData = getData(internalInstance),</span>
          <span class="s0">displayName = _getData.displayName,</span>
          <span class="s0">key = _getData.key;</span>

      <span class="s1">var </span><span class="s0">ownerID = internalInstance._currentElement != </span><span class="s1">null </span><span class="s0">&amp;&amp; internalInstance._currentElement._owner != </span><span class="s1">null </span><span class="s0">? getID(internalInstance._currentElement._owner) : </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">displayNameStringID = getStringID(displayName);</span>
      <span class="s1">var </span><span class="s0">keyStringID = getStringID(key);</span>
      <span class="s0">pushOperation(TREE_OPERATION_ADD);</span>
      <span class="s0">pushOperation(id);</span>
      <span class="s0">pushOperation(type);</span>
      <span class="s0">pushOperation(parentID);</span>
      <span class="s0">pushOperation(ownerID);</span>
      <span class="s0">pushOperation(displayNameStringID);</span>
      <span class="s0">pushOperation(keyStringID);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordReorder(internalInstance, id, nextChildren) {</span>
    <span class="s0">pushOperation(TREE_OPERATION_REORDER_CHILDREN);</span>
    <span class="s0">pushOperation(id);</span>
    <span class="s1">var </span><span class="s0">nextChildIDs = nextChildren.map(getID);</span>
    <span class="s0">pushOperation(nextChildIDs.length);</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; nextChildIDs.length; i++) {</span>
      <span class="s0">pushOperation(nextChildIDs[i]);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">recordUnmount(internalInstance, id) {</span>
    <span class="s0">pendingUnmountedIDs.push(id);</span>
    <span class="s0">idToInternalInstanceMap.</span><span class="s1">delete</span><span class="s0">(id);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">crawlAndRecordInitialMounts(id, parentID, rootID) {</span>
    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">console.group(</span><span class="s2">'crawlAndRecordInitialMounts() id:'</span><span class="s0">, id);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(internalInstance != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">internalInstanceToRootIDMap.set(internalInstance, rootID);</span>
      <span class="s0">recordMount(internalInstance, id, parentID);</span>
      <span class="s0">getChildren(internalInstance).forEach(</span><span class="s1">function </span><span class="s0">(child) {</span>
        <span class="s1">return </span><span class="s0">crawlAndRecordInitialMounts(getID(child), id, rootID);</span>
      <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">console.groupEnd();</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">flushInitialOperations() {</span>
    <span class="s3">// Crawl roots though and register any nodes that mounted before we were injected.</span>
    <span class="s1">var </span><span class="s0">roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">key </span><span class="s1">in </span><span class="s0">roots) {</span>
      <span class="s1">var </span><span class="s0">internalInstance = roots[key];</span>

      <span class="s1">var </span><span class="s0">_id2 = getID(internalInstance);</span>

      <span class="s0">crawlAndRecordInitialMounts(_id2, </span><span class="s4">0</span><span class="s0">, _id2);</span>
      <span class="s0">flushPendingEvents(_id2);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">pendingOperations = [];</span>
  <span class="s1">var </span><span class="s0">pendingStringTable = </span><span class="s1">new </span><span class="s0">Map();</span>
  <span class="s1">var </span><span class="s0">pendingUnmountedIDs = [];</span>
  <span class="s1">var </span><span class="s0">pendingStringTableLength = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">pendingUnmountedRootID = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">flushPendingEvents(rootID) {</span>
    <span class="s1">if </span><span class="s0">(pendingOperations.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; pendingUnmountedIDs.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; pendingUnmountedRootID === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === </span><span class="s1">null </span><span class="s0">? </span><span class="s4">0 </span><span class="s0">: </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">operations = </span><span class="s1">new </span><span class="s0">Array( </span><span class="s3">// Identify which renderer this update is coming from.</span>
    <span class="s4">2 </span><span class="s0">+ </span><span class="s3">// [rendererID, rootFiberID]</span>
    <span class="s3">// How big is the string table?</span>
    <span class="s4">1 </span><span class="s0">+ </span><span class="s3">// [stringTableLength]</span>
    <span class="s3">// Then goes the actual string table.</span>
    <span class="s0">pendingStringTableLength + ( </span><span class="s3">// All unmounts are batched in a single message.</span>
    <span class="s3">// [TREE_OPERATION_REMOVE, removedIDLength, ...ids]</span>
    <span class="s0">numUnmountIDs &gt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s4">2 </span><span class="s0">+ numUnmountIDs : </span><span class="s4">0</span><span class="s0">) + </span><span class="s3">// Mount operations</span>
    <span class="s0">pendingOperations.length); </span><span class="s3">// Identify which renderer this update is coming from.</span>
    <span class="s3">// This enables roots to be mapped to renderers,</span>
    <span class="s3">// Which in turn enables fiber properations, states, and hooks to be inspected.</span>

    <span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">operations[i++] = rendererID;</span>
    <span class="s0">operations[i++] = rootID; </span><span class="s3">// Now fill in the string table.</span>
    <span class="s3">// [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]</span>

    <span class="s0">operations[i++] = pendingStringTableLength;</span>
    <span class="s0">pendingStringTable.forEach(</span><span class="s1">function </span><span class="s0">(value, key) {</span>
      <span class="s0">operations[i++] = key.length;</span>
      <span class="s1">var </span><span class="s0">encodedKey = utfEncodeString(key);</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; encodedKey.length; j++) {</span>
        <span class="s0">operations[i + j] = encodedKey[j];</span>
      <span class="s0">}</span>

      <span class="s0">i += key.length;</span>
    <span class="s0">});</span>

    <span class="s1">if </span><span class="s0">(numUnmountIDs &gt; </span><span class="s4">0</span><span class="s0">) {</span>
      <span class="s3">// All unmounts except roots are batched in a single message.</span>
      <span class="s0">operations[i++] = TREE_OPERATION_REMOVE; </span><span class="s3">// The first number is how many unmounted IDs we're gonna send.</span>

      <span class="s0">operations[i++] = numUnmountIDs; </span><span class="s3">// Fill in the unmounts</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; pendingUnmountedIDs.length; j++) {</span>
        <span class="s0">operations[i++] = pendingUnmountedIDs[j];</span>
      <span class="s0">} </span><span class="s3">// The root ID should always be unmounted last.</span>


      <span class="s1">if </span><span class="s0">(pendingUnmountedRootID !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">operations[i] = pendingUnmountedRootID;</span>
        <span class="s0">i++;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">// Fill in the rest of the operations.</span>


    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_j = </span><span class="s4">0</span><span class="s0">; _j &lt; pendingOperations.length; _j++) {</span>
      <span class="s0">operations[i + _j] = pendingOperations[_j];</span>
    <span class="s0">}</span>

    <span class="s0">i += pendingOperations.length;</span>

    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">printOperationsArray(operations);</span>
    <span class="s0">} </span><span class="s3">// If we've already connected to the frontend, just pass the operations through.</span>


    <span class="s0">hook.emit(</span><span class="s2">'operations'</span><span class="s0">, operations);</span>
    <span class="s0">pendingOperations.length = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">pendingUnmountedIDs = [];</span>
    <span class="s0">pendingUnmountedRootID = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">pendingStringTable.clear();</span>
    <span class="s0">pendingStringTableLength = </span><span class="s4">0</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">pushOperation(op) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">false</span><span class="s0">) {}</span>

    <span class="s0">pendingOperations.push(op);</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getStringID(str) {</span>
    <span class="s1">if </span><span class="s0">(str === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">existingID = pendingStringTable.get(str);</span>

    <span class="s1">if </span><span class="s0">(existingID !== undefined) {</span>
      <span class="s1">return </span><span class="s0">existingID;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">stringID = pendingStringTable.size + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">pendingStringTable.set(str, stringID); </span><span class="s3">// The string table total length needs to account</span>
    <span class="s3">// both for the string length, and for the array item</span>
    <span class="s3">// that contains the length itself. Hence + 1.</span>

    <span class="s0">pendingStringTableLength += str.length + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">stringID;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">currentlyInspectedElementID = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">currentlyInspectedPaths = {}; </span><span class="s3">// Track the intersection of currently inspected paths,</span>
  <span class="s3">// so that we can send their data along if the element is re-rendered.</span>

  <span class="s1">function </span><span class="s0">mergeInspectedPaths(path) {</span>
    <span class="s1">var </span><span class="s0">current = currentlyInspectedPaths;</span>
    <span class="s0">path.forEach(</span><span class="s1">function </span><span class="s0">(key) {</span>
      <span class="s1">if </span><span class="s0">(!current[key]) {</span>
        <span class="s0">current[key] = {};</span>
      <span class="s0">}</span>

      <span class="s0">current = current[key];</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">createIsPathAllowed(key) {</span>
    <span class="s3">// This function helps prevent previously-inspected paths from being dehydrated in updates.</span>
    <span class="s3">// This is important to avoid a bad user experience where expanded toggles collapse on update.</span>
    <span class="s1">return function </span><span class="s0">isPathAllowed(path) {</span>
      <span class="s1">var </span><span class="s0">current = currentlyInspectedPaths[key];</span>

      <span class="s1">if </span><span class="s0">(!current) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; path.length; i++) {</span>
        <span class="s0">current = current[path[i]];</span>

        <span class="s1">if </span><span class="s0">(!current) {</span>
          <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">};</span>
  <span class="s0">} </span><span class="s3">// Fast path props lookup for React Native style editor.</span>


  <span class="s1">function </span><span class="s0">getInstanceAndStyle(id) {</span>
    <span class="s1">var </span><span class="s0">instance = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">style = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(internalInstance != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">instance = internalInstance._instance || </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">element = internalInstance._currentElement;</span>

      <span class="s1">if </span><span class="s0">(element != </span><span class="s1">null </span><span class="s0">&amp;&amp; element.props != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">style = element.props.style || </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">instance: instance,</span>
      <span class="s0">style: style</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">updateSelectedElement(id) {</span>
    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(internalInstance == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Could not find instance with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">switch </span><span class="s0">(getElementType(internalInstance)) {</span>
      <span class="s1">case </span><span class="s0">types_ElementTypeClass:</span>
        <span class="s0">global.$r = internalInstance._instance;</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">case </span><span class="s0">types_ElementTypeFunction:</span>
        <span class="s1">var </span><span class="s0">element = internalInstance._currentElement;</span>

        <span class="s1">if </span><span class="s0">(element == </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">console.warn(</span><span class="s2">&quot;Could not find element with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
          <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s0">global.$r = {</span>
          <span class="s0">props: element.props,</span>
          <span class="s0">type: element.type</span>
        <span class="s0">};</span>
        <span class="s1">break</span><span class="s0">;</span>

      <span class="s1">default</span><span class="s0">:</span>
        <span class="s0">global.$r = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">storeAsGlobal(id, path, count) {</span>
    <span class="s1">var </span><span class="s0">inspectedElement = inspectElementRaw(id);</span>

    <span class="s1">if </span><span class="s0">(inspectedElement !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">value = utils_getInObject(inspectedElement, path);</span>
      <span class="s1">var </span><span class="s0">key = </span><span class="s2">&quot;$reactTemp&quot;</span><span class="s0">.concat(count);</span>
      <span class="s0">window[key] = value;</span>
      <span class="s0">console.log(key);</span>
      <span class="s0">console.log(value);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getSerializedElementValueByPath(id, path) {</span>
    <span class="s1">var </span><span class="s0">inspectedElement = inspectElementRaw(id);</span>

    <span class="s1">if </span><span class="s0">(inspectedElement !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">valueToCopy = utils_getInObject(inspectedElement, path);</span>
      <span class="s1">return </span><span class="s0">serializeToString(valueToCopy);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">inspectElement(requestID, id, path, forceFullData) {</span>
    <span class="s1">if </span><span class="s0">(forceFullData || currentlyInspectedElementID !== id) {</span>
      <span class="s0">currentlyInspectedElementID = id;</span>
      <span class="s0">currentlyInspectedPaths = {};</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">inspectedElement = inspectElementRaw(id);</span>

    <span class="s1">if </span><span class="s0">(inspectedElement === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">id: id,</span>
        <span class="s0">responseID: requestID,</span>
        <span class="s0">type: </span><span class="s2">'not-found'</span>
      <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(path !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">mergeInspectedPaths(path);</span>
    <span class="s0">} </span><span class="s3">// Any time an inspected element has an update,</span>
    <span class="s3">// we should update the selected $r value as wel.</span>
    <span class="s3">// Do this before dehydration (cleanForBridge).</span>


    <span class="s0">updateSelectedElement(id);</span>
    <span class="s0">inspectedElement.context = cleanForBridge(inspectedElement.context, createIsPathAllowed(</span><span class="s2">'context'</span><span class="s0">));</span>
    <span class="s0">inspectedElement.props = cleanForBridge(inspectedElement.props, createIsPathAllowed(</span><span class="s2">'props'</span><span class="s0">));</span>
    <span class="s0">inspectedElement.state = cleanForBridge(inspectedElement.state, createIsPathAllowed(</span><span class="s2">'state'</span><span class="s0">));</span>
    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">id: id,</span>
      <span class="s0">responseID: requestID,</span>
      <span class="s0">type: </span><span class="s2">'full-data'</span><span class="s0">,</span>
      <span class="s0">value: inspectedElement</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">inspectElementRaw(id) {</span>
    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(internalInstance == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">_getData2 = getData(internalInstance),</span>
        <span class="s0">displayName = _getData2.displayName,</span>
        <span class="s0">key = _getData2.key;</span>

    <span class="s1">var </span><span class="s0">type = getElementType(internalInstance);</span>
    <span class="s1">var </span><span class="s0">context = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">owners = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">props = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">state = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">source = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">element = internalInstance._currentElement;</span>

    <span class="s1">if </span><span class="s0">(element !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">props = element.props;</span>
      <span class="s0">source = element._source != </span><span class="s1">null </span><span class="s0">? element._source : </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">var </span><span class="s0">owner = element._owner;</span>

      <span class="s1">if </span><span class="s0">(owner) {</span>
        <span class="s0">owners = [];</span>

        <span class="s1">while </span><span class="s0">(owner != </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">owners.push({</span>
            <span class="s0">displayName: getData(owner).displayName || </span><span class="s2">'Unknown'</span><span class="s0">,</span>
            <span class="s0">id: getID(owner),</span>
            <span class="s0">key: element.key,</span>
            <span class="s0">type: getElementType(owner)</span>
          <span class="s0">});</span>

          <span class="s1">if </span><span class="s0">(owner._currentElement) {</span>
            <span class="s0">owner = owner._currentElement._owner;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">publicInstance = internalInstance._instance;</span>

    <span class="s1">if </span><span class="s0">(publicInstance != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">context = publicInstance.context || </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s0">state = publicInstance.state || </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s3">// Not implemented</span>


    <span class="s1">var </span><span class="s0">errors = [];</span>
    <span class="s1">var </span><span class="s0">warnings = [];</span>
    <span class="s1">return </span><span class="s0">{</span>
      <span class="s0">id: id,</span>
      <span class="s3">// Does the current renderer support editable hooks and function props?</span>
      <span class="s0">canEditHooks: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">canEditFunctionProps: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s3">// Does the current renderer support advanced editing interface?</span>
      <span class="s0">canEditHooksAndDeletePaths: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">canEditHooksAndRenamePaths: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">canEditFunctionPropsDeletePaths: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">canEditFunctionPropsRenamePaths: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s3">// Toggle error boundary did not exist in legacy versions</span>
      <span class="s0">canToggleError: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">isErrored: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s0">targetErrorBoundaryID: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s3">// Suspense did not exist in legacy versions</span>
      <span class="s0">canToggleSuspense: </span><span class="s1">false</span><span class="s0">,</span>
      <span class="s3">// Can view component source location.</span>
      <span class="s0">canViewSource: type === types_ElementTypeClass || type === types_ElementTypeFunction,</span>
      <span class="s3">// Only legacy context exists in legacy versions.</span>
      <span class="s0">hasLegacyContext: </span><span class="s1">true</span><span class="s0">,</span>
      <span class="s0">displayName: displayName,</span>
      <span class="s0">type: type,</span>
      <span class="s0">key: key != </span><span class="s1">null </span><span class="s0">? key : </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s3">// Inspectable properties.</span>
      <span class="s0">context: context,</span>
      <span class="s0">hooks: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">props: props,</span>
      <span class="s0">state: state,</span>
      <span class="s0">errors: errors,</span>
      <span class="s0">warnings: warnings,</span>
      <span class="s3">// List of owners</span>
      <span class="s0">owners: owners,</span>
      <span class="s3">// Location of component in source code.</span>
      <span class="s0">source: source,</span>
      <span class="s0">rootType: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">rendererPackageName: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">rendererVersion: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">plugins: {</span>
        <span class="s0">stylex: </span><span class="s1">null</span>
      <span class="s0">}</span>
    <span class="s0">};</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">logElementToConsole(id) {</span>
    <span class="s1">var </span><span class="s0">result = inspectElementRaw(id);</span>

    <span class="s1">if </span><span class="s0">(result === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Could not find element with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">supportsGroup = </span><span class="s1">typeof </span><span class="s0">console.groupCollapsed === </span><span class="s2">'function'</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(supportsGroup) {</span>
      <span class="s0">console.groupCollapsed(</span><span class="s2">&quot;[Click to expand] %c&lt;&quot;</span><span class="s0">.concat(result.displayName || </span><span class="s2">'Component'</span><span class="s0">, </span><span class="s2">&quot; /&gt;&quot;</span><span class="s0">), </span><span class="s3">// --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.</span>
      <span class="s2">'color: var(--dom-tag-name-color); font-weight: normal;'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(result.props !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'Props:'</span><span class="s0">, result.props);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(result.state !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'State:'</span><span class="s0">, result.state);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(result.context !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'Context:'</span><span class="s0">, result.context);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">nativeNode = findNativeNodeForInternalID(id);</span>

    <span class="s1">if </span><span class="s0">(nativeNode !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.log(</span><span class="s2">'Node:'</span><span class="s0">, nativeNode);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(window.chrome || /firefox/i.test(navigator.userAgent)) {</span>
      <span class="s0">console.log(</span><span class="s2">'Right-click any value to save it as a global variable for further inspection.'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(supportsGroup) {</span>
      <span class="s0">console.groupEnd();</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">prepareViewAttributeSource(id, path) {</span>
    <span class="s1">var </span><span class="s0">inspectedElement = inspectElementRaw(id);</span>

    <span class="s1">if </span><span class="s0">(inspectedElement !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">window.$attribute = utils_getInObject(inspectedElement, path);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">prepareViewElementSource(id) {</span>
    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(internalInstance == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Could not find instance with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">element = internalInstance._currentElement;</span>

    <span class="s1">if </span><span class="s0">(element == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">console.warn(</span><span class="s2">&quot;Could not find element with id </span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">.concat(id, </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">));</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">global.$type = element.type;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">deletePath(type, id, hookID, path) {</span>
    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(internalInstance != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">publicInstance = internalInstance._instance;</span>

      <span class="s1">if </span><span class="s0">(publicInstance != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">switch </span><span class="s0">(type) {</span>
          <span class="s1">case </span><span class="s2">'context'</span><span class="s0">:</span>
            <span class="s0">deletePathInObject(publicInstance.context, path);</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'hooks'</span><span class="s0">:</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Hooks not supported by this renderer'</span><span class="s0">);</span>

          <span class="s1">case </span><span class="s2">'props'</span><span class="s0">:</span>
            <span class="s1">var </span><span class="s0">element = internalInstance._currentElement;</span>
            <span class="s0">internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {</span>
              <span class="s0">props: copyWithDelete(element.props, path)</span>
            <span class="s0">});</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'state'</span><span class="s0">:</span>
            <span class="s0">deletePathInObject(publicInstance.state, path);</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">renamePath(type, id, hookID, oldPath, newPath) {</span>
    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(internalInstance != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">publicInstance = internalInstance._instance;</span>

      <span class="s1">if </span><span class="s0">(publicInstance != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">switch </span><span class="s0">(type) {</span>
          <span class="s1">case </span><span class="s2">'context'</span><span class="s0">:</span>
            <span class="s0">renamePathInObject(publicInstance.context, oldPath, newPath);</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'hooks'</span><span class="s0">:</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Hooks not supported by this renderer'</span><span class="s0">);</span>

          <span class="s1">case </span><span class="s2">'props'</span><span class="s0">:</span>
            <span class="s1">var </span><span class="s0">element = internalInstance._currentElement;</span>
            <span class="s0">internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {</span>
              <span class="s0">props: copyWithRename(element.props, oldPath, newPath)</span>
            <span class="s0">});</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'state'</span><span class="s0">:</span>
            <span class="s0">renamePathInObject(publicInstance.state, oldPath, newPath);</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">overrideValueAtPath(type, id, hookID, path, value) {</span>
    <span class="s1">var </span><span class="s0">internalInstance = idToInternalInstanceMap.get(id);</span>

    <span class="s1">if </span><span class="s0">(internalInstance != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s0">publicInstance = internalInstance._instance;</span>

      <span class="s1">if </span><span class="s0">(publicInstance != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">switch </span><span class="s0">(type) {</span>
          <span class="s1">case </span><span class="s2">'context'</span><span class="s0">:</span>
            <span class="s0">utils_setInObject(publicInstance.context, path, value);</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'hooks'</span><span class="s0">:</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Hooks not supported by this renderer'</span><span class="s0">);</span>

          <span class="s1">case </span><span class="s2">'props'</span><span class="s0">:</span>
            <span class="s1">var </span><span class="s0">element = internalInstance._currentElement;</span>
            <span class="s0">internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {</span>
              <span class="s0">props: copyWithSet(element.props, path, value)</span>
            <span class="s0">});</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>

          <span class="s1">case </span><span class="s2">'state'</span><span class="s0">:</span>
            <span class="s0">utils_setInObject(publicInstance.state, path, value);</span>
            <span class="s0">forceUpdate(publicInstance);</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s3">// v16+ only features</span>


  <span class="s1">var </span><span class="s0">getProfilingData = </span><span class="s1">function </span><span class="s0">getProfilingData() {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'getProfilingData not supported by this renderer'</span><span class="s0">);</span>
  <span class="s0">};</span>

  <span class="s1">var </span><span class="s0">handleCommitFiberRoot = </span><span class="s1">function </span><span class="s0">handleCommitFiberRoot() {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'handleCommitFiberRoot not supported by this renderer'</span><span class="s0">);</span>
  <span class="s0">};</span>

  <span class="s1">var </span><span class="s0">handleCommitFiberUnmount = </span><span class="s1">function </span><span class="s0">handleCommitFiberUnmount() {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'handleCommitFiberUnmount not supported by this renderer'</span><span class="s0">);</span>
  <span class="s0">};</span>

  <span class="s1">var </span><span class="s0">handlePostCommitFiberRoot = </span><span class="s1">function </span><span class="s0">handlePostCommitFiberRoot() {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'handlePostCommitFiberRoot not supported by this renderer'</span><span class="s0">);</span>
  <span class="s0">};</span>

  <span class="s1">var </span><span class="s0">overrideError = </span><span class="s1">function </span><span class="s0">overrideError() {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'overrideError not supported by this renderer'</span><span class="s0">);</span>
  <span class="s0">};</span>

  <span class="s1">var </span><span class="s0">overrideSuspense = </span><span class="s1">function </span><span class="s0">overrideSuspense() {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'overrideSuspense not supported by this renderer'</span><span class="s0">);</span>
  <span class="s0">};</span>

  <span class="s1">var </span><span class="s0">startProfiling = </span><span class="s1">function </span><span class="s0">startProfiling() {</span><span class="s3">// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.</span>
  <span class="s0">};</span>

  <span class="s1">var </span><span class="s0">stopProfiling = </span><span class="s1">function </span><span class="s0">stopProfiling() {</span><span class="s3">// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.</span>
  <span class="s0">};</span>

  <span class="s1">function </span><span class="s0">getBestMatchForTrackedPath() {</span>
    <span class="s3">// Not implemented.</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getPathForElement(id) {</span>
    <span class="s3">// Not implemented.</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">updateComponentFilters(componentFilters) {</span><span class="s3">// Not implemented.</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">setTraceUpdatesEnabled(enabled) {</span><span class="s3">// Not implemented.</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">setTrackedPath(path) {</span><span class="s3">// Not implemented.</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">getOwnersList(id) {</span>
    <span class="s3">// Not implemented.</span>
    <span class="s1">return null</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">clearErrorsAndWarnings() {</span><span class="s3">// Not implemented</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">clearErrorsForFiberID(id) {</span><span class="s3">// Not implemented</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">clearWarningsForFiberID(id) {</span><span class="s3">// Not implemented</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">patchConsoleForStrictMode() {}</span>

  <span class="s1">function </span><span class="s0">unpatchConsoleForStrictMode() {}</span>

  <span class="s1">function </span><span class="s0">hasFiberWithId(id) {</span>
    <span class="s1">return </span><span class="s0">idToInternalInstanceMap.has(id);</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">clearErrorsAndWarnings: clearErrorsAndWarnings,</span>
    <span class="s0">clearErrorsForFiberID: clearErrorsForFiberID,</span>
    <span class="s0">clearWarningsForFiberID: clearWarningsForFiberID,</span>
    <span class="s0">cleanup: cleanup,</span>
    <span class="s0">getSerializedElementValueByPath: getSerializedElementValueByPath,</span>
    <span class="s0">deletePath: deletePath,</span>
    <span class="s0">flushInitialOperations: flushInitialOperations,</span>
    <span class="s0">getBestMatchForTrackedPath: getBestMatchForTrackedPath,</span>
    <span class="s0">getDisplayNameForFiberID: getDisplayNameForFiberID,</span>
    <span class="s0">getFiberForNative: getFiberForNative,</span>
    <span class="s0">getFiberIDForNative: getInternalIDForNative,</span>
    <span class="s0">getInstanceAndStyle: getInstanceAndStyle,</span>
    <span class="s0">findNativeNodesForFiberID: </span><span class="s1">function </span><span class="s0">findNativeNodesForFiberID(id) {</span>
      <span class="s1">var </span><span class="s0">nativeNode = findNativeNodeForInternalID(id);</span>
      <span class="s1">return </span><span class="s0">nativeNode == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: [nativeNode];</span>
    <span class="s0">},</span>
    <span class="s0">getOwnersList: getOwnersList,</span>
    <span class="s0">getPathForElement: getPathForElement,</span>
    <span class="s0">getProfilingData: getProfilingData,</span>
    <span class="s0">handleCommitFiberRoot: handleCommitFiberRoot,</span>
    <span class="s0">handleCommitFiberUnmount: handleCommitFiberUnmount,</span>
    <span class="s0">handlePostCommitFiberRoot: handlePostCommitFiberRoot,</span>
    <span class="s0">hasFiberWithId: hasFiberWithId,</span>
    <span class="s0">inspectElement: inspectElement,</span>
    <span class="s0">logElementToConsole: logElementToConsole,</span>
    <span class="s0">overrideError: overrideError,</span>
    <span class="s0">overrideSuspense: overrideSuspense,</span>
    <span class="s0">overrideValueAtPath: overrideValueAtPath,</span>
    <span class="s0">renamePath: renamePath,</span>
    <span class="s0">patchConsoleForStrictMode: patchConsoleForStrictMode,</span>
    <span class="s0">prepareViewAttributeSource: prepareViewAttributeSource,</span>
    <span class="s0">prepareViewElementSource: prepareViewElementSource,</span>
    <span class="s0">renderer: renderer,</span>
    <span class="s0">setTraceUpdatesEnabled: setTraceUpdatesEnabled,</span>
    <span class="s0">setTrackedPath: setTrackedPath,</span>
    <span class="s0">startProfiling: startProfiling,</span>
    <span class="s0">stopProfiling: stopProfiling,</span>
    <span class="s0">storeAsGlobal: storeAsGlobal,</span>
    <span class="s0">unpatchConsoleForStrictMode: unpatchConsoleForStrictMode,</span>
    <span class="s0">updateComponentFilters: updateComponentFilters</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/index.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>





<span class="s3">// this is the backend that is compatible with all older React versions</span>
<span class="s1">function </span><span class="s0">isMatchingRender(version) {</span>
  <span class="s1">return </span><span class="s0">!hasAssignedBackend(version);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">initBackend(hook, agent, global) {</span>
  <span class="s1">if </span><span class="s0">(hook == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s3">// DevTools didn't get injected into this page (maybe b'c of the contentType).</span>
    <span class="s1">return function </span><span class="s0">() {};</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">subs = [hook.sub(</span><span class="s2">'renderer-attached'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref) {</span>
    <span class="s1">var </span><span class="s0">id = _ref.id,</span>
        <span class="s0">renderer = _ref.renderer,</span>
        <span class="s0">rendererInterface = _ref.rendererInterface;</span>
    <span class="s0">agent.setRendererInterface(id, rendererInterface); </span><span class="s3">// Now that the Store and the renderer interface are connected,</span>
    <span class="s3">// it's time to flush the pending operation codes to the frontend.</span>

    <span class="s0">rendererInterface.flushInitialOperations();</span>
  <span class="s0">}), hook.sub(</span><span class="s2">'unsupported-renderer-version'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(id) {</span>
    <span class="s0">agent.onUnsupportedRenderer(id);</span>
  <span class="s0">}), hook.sub(</span><span class="s2">'fastRefreshScheduled'</span><span class="s0">, agent.onFastRefreshScheduled), hook.sub(</span><span class="s2">'operations'</span><span class="s0">, agent.onHookOperations), hook.sub(</span><span class="s2">'traceUpdates'</span><span class="s0">, agent.onTraceUpdates) </span><span class="s3">// TODO Add additional subscriptions required for profiling mode</span>
  <span class="s0">];</span>

  <span class="s1">var </span><span class="s0">attachRenderer = </span><span class="s1">function </span><span class="s0">attachRenderer(id, renderer) {</span>
    <span class="s3">// only attach if the renderer is compatible with the current version of the backend</span>
    <span class="s1">if </span><span class="s0">(!isMatchingRender(renderer.reconcilerVersion || renderer.version)) {</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">rendererInterface = hook.rendererInterfaces.get(id); </span><span class="s3">// Inject any not-yet-injected renderers (if we didn't reload-and-profile)</span>

    <span class="s1">if </span><span class="s0">(rendererInterface == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">renderer.findFiberByHostInstance === </span><span class="s2">'function'</span><span class="s0">) {</span>
        <span class="s3">// react-reconciler v16+</span>
        <span class="s0">rendererInterface = attach(hook, id, renderer, global);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(renderer.ComponentTree) {</span>
        <span class="s3">// react-dom v15</span>
        <span class="s0">rendererInterface = renderer_attach(hook, id, renderer, global);</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span><span class="s3">// Older react-dom or other unsupported renderer version</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(rendererInterface != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">hook.rendererInterfaces.set(id, rendererInterface);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">// Notify the DevTools frontend about new renderers.</span>
    <span class="s3">// This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).</span>


    <span class="s1">if </span><span class="s0">(rendererInterface != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">hook.emit(</span><span class="s2">'renderer-attached'</span><span class="s0">, {</span>
        <span class="s0">id: id,</span>
        <span class="s0">renderer: renderer,</span>
        <span class="s0">rendererInterface: rendererInterface</span>
      <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">hook.emit(</span><span class="s2">'unsupported-renderer-version'</span><span class="s0">, id);</span>
    <span class="s0">}</span>
  <span class="s0">}; </span><span class="s3">// Connect renderers that have already injected themselves.</span>


  <span class="s0">hook.renderers.forEach(</span><span class="s1">function </span><span class="s0">(renderer, id) {</span>
    <span class="s0">attachRenderer(id, renderer);</span>
  <span class="s0">}); </span><span class="s3">// Connect any new renderers that injected themselves.</span>

  <span class="s0">subs.push(hook.sub(</span><span class="s2">'renderer'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref2) {</span>
    <span class="s1">var </span><span class="s0">id = _ref2.id,</span>
        <span class="s0">renderer = _ref2.renderer;</span>
    <span class="s0">attachRenderer(id, renderer);</span>
  <span class="s0">}));</span>
  <span class="s0">hook.emit(</span><span class="s2">'react-devtools'</span><span class="s0">, agent);</span>
  <span class="s0">hook.reactDevtoolsAgent = agent;</span>

  <span class="s1">var </span><span class="s0">onAgentShutdown = </span><span class="s1">function </span><span class="s0">onAgentShutdown() {</span>
    <span class="s0">subs.forEach(</span><span class="s1">function </span><span class="s0">(fn) {</span>
      <span class="s1">return </span><span class="s0">fn();</span>
    <span class="s0">});</span>
    <span class="s0">hook.rendererInterfaces.forEach(</span><span class="s1">function </span><span class="s0">(rendererInterface) {</span>
      <span class="s0">rendererInterface.cleanup();</span>
    <span class="s0">});</span>
    <span class="s0">hook.reactDevtoolsAgent = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s0">};</span>

  <span class="s0">agent.addListener(</span><span class="s2">'shutdown'</span><span class="s0">, onAgentShutdown);</span>
  <span class="s0">subs.push(</span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s0">agent.removeListener(</span><span class="s2">'shutdown'</span><span class="s0">, onAgentShutdown);</span>
  <span class="s0">});</span>
  <span class="s1">return function </span><span class="s0">() {</span>
    <span class="s0">subs.forEach(</span><span class="s1">function </span><span class="s0">(fn) {</span>
      <span class="s1">return </span><span class="s0">fn();</span>
    <span class="s0">});</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

<span class="s3">/** 
 * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support). 
 * 
 * Resolve a style property into it's component parts, e.g. 
 * 
 * resolveBoxStyle('margin', {margin: 5, marginBottom: 10}) 
 * -&gt; {top: 5, left: 5, right: 5, bottom: 10} 
 */</span>
<span class="s1">function </span><span class="s0">resolveBoxStyle(prefix, style) {</span>
  <span class="s1">var </span><span class="s0">hasParts = </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">result = {</span>
    <span class="s0">bottom: </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">left: </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">right: </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">top: </span><span class="s4">0</span>
  <span class="s0">};</span>
  <span class="s1">var </span><span class="s0">styleForAll = style[prefix];</span>

  <span class="s1">if </span><span class="s0">(styleForAll != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s3">// eslint-disable-next-line no-for-of-loops/no-for-of-loops</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_i = </span><span class="s4">0</span><span class="s0">, _Object$keys = Object.keys(result); _i &lt; _Object$keys.length; _i++) {</span>
      <span class="s1">var </span><span class="s0">key = _Object$keys[_i];</span>
      <span class="s0">result[key] = styleForAll;</span>
    <span class="s0">}</span>

    <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">styleForHorizontal = style[prefix + </span><span class="s2">'Horizontal'</span><span class="s0">];</span>

  <span class="s1">if </span><span class="s0">(styleForHorizontal != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">result.left = styleForHorizontal;</span>
    <span class="s0">result.right = styleForHorizontal;</span>
    <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">styleForLeft = style[prefix + </span><span class="s2">'Left'</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(styleForLeft != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">result.left = styleForLeft;</span>
      <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">styleForRight = style[prefix + </span><span class="s2">'Right'</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(styleForRight != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">result.right = styleForRight;</span>
      <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">styleForEnd = style[prefix + </span><span class="s2">'End'</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(styleForEnd != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// TODO RTL support</span>
      <span class="s0">result.right = styleForEnd;</span>
      <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">styleForStart = style[prefix + </span><span class="s2">'Start'</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(styleForStart != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// TODO RTL support</span>
      <span class="s0">result.left = styleForStart;</span>
      <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">styleForVertical = style[prefix + </span><span class="s2">'Vertical'</span><span class="s0">];</span>

  <span class="s1">if </span><span class="s0">(styleForVertical != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">result.bottom = styleForVertical;</span>
    <span class="s0">result.top = styleForVertical;</span>
    <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">var </span><span class="s0">styleForBottom = style[prefix + </span><span class="s2">'Bottom'</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(styleForBottom != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">result.bottom = styleForBottom;</span>
      <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">styleForTop = style[prefix + </span><span class="s2">'Top'</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(styleForTop != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">result.top = styleForTop;</span>
      <span class="s0">hasParts = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">hasParts ? result : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js</span>
<span class="s1">function </span><span class="s0">setupNativeStyleEditor_typeof(obj) { </span><span class="s2">&quot;@babel/helpers - typeof&quot;</span><span class="s0">; </span><span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol.iterator === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">) { setupNativeStyleEditor_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return typeof </span><span class="s0">obj; }; } </span><span class="s1">else </span><span class="s0">{ setupNativeStyleEditor_typeof = </span><span class="s1">function </span><span class="s0">_typeof(obj) { </span><span class="s1">return </span><span class="s0">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s0">Symbol === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s2">&quot;symbol&quot; </span><span class="s0">: </span><span class="s1">typeof </span><span class="s0">obj; }; } </span><span class="s1">return </span><span class="s0">setupNativeStyleEditor_typeof(obj); }</span>

<span class="s1">function </span><span class="s0">setupNativeStyleEditor_defineProperty(obj, key, value) { </span><span class="s1">if </span><span class="s0">(key </span><span class="s1">in </span><span class="s0">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s1">true</span><span class="s0">, configurable: </span><span class="s1">true</span><span class="s0">, writable: </span><span class="s1">true </span><span class="s0">}); } </span><span class="s1">else </span><span class="s0">{ obj[key] = value; } </span><span class="s1">return </span><span class="s0">obj; }</span>

<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>



<span class="s1">function </span><span class="s0">setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {</span>
  <span class="s0">bridge.addListener(</span><span class="s2">'NativeStyleEditor_measure'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref) {</span>
    <span class="s1">var </span><span class="s0">id = _ref.id,</span>
        <span class="s0">rendererID = _ref.rendererID;</span>
    <span class="s0">measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);</span>
  <span class="s0">});</span>
  <span class="s0">bridge.addListener(</span><span class="s2">'NativeStyleEditor_renameAttribute'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref2) {</span>
    <span class="s1">var </span><span class="s0">id = _ref2.id,</span>
        <span class="s0">rendererID = _ref2.rendererID,</span>
        <span class="s0">oldName = _ref2.oldName,</span>
        <span class="s0">newName = _ref2.newName,</span>
        <span class="s0">value = _ref2.value;</span>
    <span class="s0">renameStyle(agent, id, rendererID, oldName, newName, value);</span>
    <span class="s0">setTimeout(</span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s1">return </span><span class="s0">measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);</span>
    <span class="s0">});</span>
  <span class="s0">});</span>
  <span class="s0">bridge.addListener(</span><span class="s2">'NativeStyleEditor_setValue'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(_ref3) {</span>
    <span class="s1">var </span><span class="s0">id = _ref3.id,</span>
        <span class="s0">rendererID = _ref3.rendererID,</span>
        <span class="s0">name = _ref3.name,</span>
        <span class="s0">value = _ref3.value;</span>
    <span class="s0">setStyle(agent, id, rendererID, name, value);</span>
    <span class="s0">setTimeout(</span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s1">return </span><span class="s0">measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);</span>
    <span class="s0">});</span>
  <span class="s0">});</span>
  <span class="s0">bridge.send(</span><span class="s2">'isNativeStyleEditorSupported'</span><span class="s0">, {</span>
    <span class="s0">isSupported: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">validAttributes: validAttributes</span>
  <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">var </span><span class="s0">EMPTY_BOX_STYLE = {</span>
  <span class="s0">top: </span><span class="s4">0</span><span class="s0">,</span>
  <span class="s0">left: </span><span class="s4">0</span><span class="s0">,</span>
  <span class="s0">right: </span><span class="s4">0</span><span class="s0">,</span>
  <span class="s0">bottom: </span><span class="s4">0</span>
<span class="s0">};</span>
<span class="s1">var </span><span class="s0">componentIDToStyleOverrides = </span><span class="s1">new </span><span class="s0">Map();</span>

<span class="s1">function </span><span class="s0">measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {</span>
  <span class="s1">var </span><span class="s0">data = agent.getInstanceAndStyle({</span>
    <span class="s0">id: id,</span>
    <span class="s0">rendererID: rendererID</span>
  <span class="s0">});</span>

  <span class="s1">if </span><span class="s0">(!data || !data.style) {</span>
    <span class="s0">bridge.send(</span><span class="s2">'NativeStyleEditor_styleAndLayout'</span><span class="s0">, {</span>
      <span class="s0">id: id,</span>
      <span class="s0">layout: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">style: </span><span class="s1">null</span>
    <span class="s0">});</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">instance = data.instance,</span>
      <span class="s0">style = data.style;</span>
  <span class="s1">var </span><span class="s0">resolvedStyle = resolveNativeStyle(style); </span><span class="s3">// If it's a host component we edited before, amend styles.</span>

  <span class="s1">var </span><span class="s0">styleOverrides = componentIDToStyleOverrides.get(id);</span>

  <span class="s1">if </span><span class="s0">(styleOverrides != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s0">resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(!instance || </span><span class="s1">typeof </span><span class="s0">instance.measure !== </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s0">bridge.send(</span><span class="s2">'NativeStyleEditor_styleAndLayout'</span><span class="s0">, {</span>
      <span class="s0">id: id,</span>
      <span class="s0">layout: </span><span class="s1">null</span><span class="s0">,</span>
      <span class="s0">style: resolvedStyle || </span><span class="s1">null</span>
    <span class="s0">});</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">instance.measure(</span><span class="s1">function </span><span class="s0">(x, y, width, height, left, top) {</span>
    <span class="s3">// RN Android sometimes returns undefined here. Don't send measurements in this case.</span>
    <span class="s3">// https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">x !== </span><span class="s2">'number'</span><span class="s0">) {</span>
      <span class="s0">bridge.send(</span><span class="s2">'NativeStyleEditor_styleAndLayout'</span><span class="s0">, {</span>
        <span class="s0">id: id,</span>
        <span class="s0">layout: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">style: resolvedStyle || </span><span class="s1">null</span>
      <span class="s0">});</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">margin = resolvedStyle != </span><span class="s1">null </span><span class="s0">&amp;&amp; resolveBoxStyle(</span><span class="s2">'margin'</span><span class="s0">, resolvedStyle) || EMPTY_BOX_STYLE;</span>
    <span class="s1">var </span><span class="s0">padding = resolvedStyle != </span><span class="s1">null </span><span class="s0">&amp;&amp; resolveBoxStyle(</span><span class="s2">'padding'</span><span class="s0">, resolvedStyle) || EMPTY_BOX_STYLE;</span>
    <span class="s0">bridge.send(</span><span class="s2">'NativeStyleEditor_styleAndLayout'</span><span class="s0">, {</span>
      <span class="s0">id: id,</span>
      <span class="s0">layout: {</span>
        <span class="s0">x: x,</span>
        <span class="s0">y: y,</span>
        <span class="s0">width: width,</span>
        <span class="s0">height: height,</span>
        <span class="s0">left: left,</span>
        <span class="s0">top: top,</span>
        <span class="s0">margin: margin,</span>
        <span class="s0">padding: padding</span>
      <span class="s0">},</span>
      <span class="s0">style: resolvedStyle || </span><span class="s1">null</span>
    <span class="s0">});</span>
  <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">shallowClone(object) {</span>
  <span class="s1">var </span><span class="s0">cloned = {};</span>

  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">n </span><span class="s1">in </span><span class="s0">object) {</span>
    <span class="s0">cloned[n] = object[n];</span>
  <span class="s0">}</span>

  <span class="s1">return </span><span class="s0">cloned;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">renameStyle(agent, id, rendererID, oldName, newName, value) {</span>
  <span class="s1">var </span><span class="s0">_ref4;</span>

  <span class="s1">var </span><span class="s0">data = agent.getInstanceAndStyle({</span>
    <span class="s0">id: id,</span>
    <span class="s0">rendererID: rendererID</span>
  <span class="s0">});</span>

  <span class="s1">if </span><span class="s0">(!data || !data.style) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">instance = data.instance,</span>
      <span class="s0">style = data.style;</span>
  <span class="s1">var </span><span class="s0">newStyle = newName ? (_ref4 = {}, setupNativeStyleEditor_defineProperty(_ref4, oldName, undefined), setupNativeStyleEditor_defineProperty(_ref4, newName, value), _ref4) : setupNativeStyleEditor_defineProperty({}, oldName, undefined);</span>
  <span class="s1">var </span><span class="s0">customStyle; </span><span class="s3">// TODO It would be nice if the renderer interface abstracted this away somehow.</span>

  <span class="s1">if </span><span class="s0">(instance !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">instance.setNativeProps === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s3">// In the case of a host component, we need to use setNativeProps().</span>
    <span class="s3">// Remember to &quot;correct&quot; resolved styles when we read them next time.</span>
    <span class="s1">var </span><span class="s0">styleOverrides = componentIDToStyleOverrides.get(id);</span>

    <span class="s1">if </span><span class="s0">(!styleOverrides) {</span>
      <span class="s0">componentIDToStyleOverrides.set(id, newStyle);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">Object.assign(styleOverrides, newStyle);</span>
    <span class="s0">} </span><span class="s3">// TODO Fabric does not support setNativeProps; chat with Sebastian or Eli</span>


    <span class="s0">instance.setNativeProps({</span>
      <span class="s0">style: newStyle</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(src_isArray(style)) {</span>
    <span class="s1">var </span><span class="s0">lastIndex = style.length - </span><span class="s4">1</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(setupNativeStyleEditor_typeof(style[lastIndex]) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; !src_isArray(style[lastIndex])) {</span>
      <span class="s0">customStyle = shallowClone(style[lastIndex]);</span>
      <span class="s1">delete </span><span class="s0">customStyle[oldName];</span>

      <span class="s1">if </span><span class="s0">(newName) {</span>
        <span class="s0">customStyle[newName] = value;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">customStyle[oldName] = undefined;</span>
      <span class="s0">}</span>

      <span class="s0">agent.overrideValueAtPath({</span>
        <span class="s0">type: </span><span class="s2">'props'</span><span class="s0">,</span>
        <span class="s0">id: id,</span>
        <span class="s0">rendererID: rendererID,</span>
        <span class="s0">path: [</span><span class="s2">'style'</span><span class="s0">, lastIndex],</span>
        <span class="s0">value: customStyle</span>
      <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">agent.overrideValueAtPath({</span>
        <span class="s0">type: </span><span class="s2">'props'</span><span class="s0">,</span>
        <span class="s0">id: id,</span>
        <span class="s0">rendererID: rendererID,</span>
        <span class="s0">path: [</span><span class="s2">'style'</span><span class="s0">],</span>
        <span class="s0">value: style.concat([newStyle])</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(setupNativeStyleEditor_typeof(style) === </span><span class="s2">'object'</span><span class="s0">) {</span>
    <span class="s0">customStyle = shallowClone(style);</span>
    <span class="s1">delete </span><span class="s0">customStyle[oldName];</span>

    <span class="s1">if </span><span class="s0">(newName) {</span>
      <span class="s0">customStyle[newName] = value;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">customStyle[oldName] = undefined;</span>
    <span class="s0">}</span>

    <span class="s0">agent.overrideValueAtPath({</span>
      <span class="s0">type: </span><span class="s2">'props'</span><span class="s0">,</span>
      <span class="s0">id: id,</span>
      <span class="s0">rendererID: rendererID,</span>
      <span class="s0">path: [</span><span class="s2">'style'</span><span class="s0">],</span>
      <span class="s0">value: customStyle</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">agent.overrideValueAtPath({</span>
      <span class="s0">type: </span><span class="s2">'props'</span><span class="s0">,</span>
      <span class="s0">id: id,</span>
      <span class="s0">rendererID: rendererID,</span>
      <span class="s0">path: [</span><span class="s2">'style'</span><span class="s0">],</span>
      <span class="s0">value: [style, newStyle]</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s0">agent.emit(</span><span class="s2">'hideNativeHighlight'</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">setStyle(agent, id, rendererID, name, value) {</span>
  <span class="s1">var </span><span class="s0">data = agent.getInstanceAndStyle({</span>
    <span class="s0">id: id,</span>
    <span class="s0">rendererID: rendererID</span>
  <span class="s0">});</span>

  <span class="s1">if </span><span class="s0">(!data || !data.style) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">instance = data.instance,</span>
      <span class="s0">style = data.style;</span>

  <span class="s1">var </span><span class="s0">newStyle = setupNativeStyleEditor_defineProperty({}, name, value); </span><span class="s3">// TODO It would be nice if the renderer interface abstracted this away somehow.</span>


  <span class="s1">if </span><span class="s0">(instance !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">instance.setNativeProps === </span><span class="s2">'function'</span><span class="s0">) {</span>
    <span class="s3">// In the case of a host component, we need to use setNativeProps().</span>
    <span class="s3">// Remember to &quot;correct&quot; resolved styles when we read them next time.</span>
    <span class="s1">var </span><span class="s0">styleOverrides = componentIDToStyleOverrides.get(id);</span>

    <span class="s1">if </span><span class="s0">(!styleOverrides) {</span>
      <span class="s0">componentIDToStyleOverrides.set(id, newStyle);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">Object.assign(styleOverrides, newStyle);</span>
    <span class="s0">} </span><span class="s3">// TODO Fabric does not support setNativeProps; chat with Sebastian or Eli</span>


    <span class="s0">instance.setNativeProps({</span>
      <span class="s0">style: newStyle</span>
    <span class="s0">});</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(src_isArray(style)) {</span>
    <span class="s1">var </span><span class="s0">lastLength = style.length - </span><span class="s4">1</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(setupNativeStyleEditor_typeof(style[lastLength]) === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; !src_isArray(style[lastLength])) {</span>
      <span class="s0">agent.overrideValueAtPath({</span>
        <span class="s0">type: </span><span class="s2">'props'</span><span class="s0">,</span>
        <span class="s0">id: id,</span>
        <span class="s0">rendererID: rendererID,</span>
        <span class="s0">path: [</span><span class="s2">'style'</span><span class="s0">, lastLength, name],</span>
        <span class="s0">value: value</span>
      <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s0">agent.overrideValueAtPath({</span>
        <span class="s0">type: </span><span class="s2">'props'</span><span class="s0">,</span>
        <span class="s0">id: id,</span>
        <span class="s0">rendererID: rendererID,</span>
        <span class="s0">path: [</span><span class="s2">'style'</span><span class="s0">],</span>
        <span class="s0">value: style.concat([newStyle])</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s0">agent.overrideValueAtPath({</span>
      <span class="s0">type: </span><span class="s2">'props'</span><span class="s0">,</span>
      <span class="s0">id: id,</span>
      <span class="s0">rendererID: rendererID,</span>
      <span class="s0">path: [</span><span class="s2">'style'</span><span class="s0">],</span>
      <span class="s0">value: [style, newStyle]</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s0">agent.emit(</span><span class="s2">'hideNativeHighlight'</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ./src/cachedSettings.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>

 <span class="s3">// Note: all keys should be optional in this type, because users can use newer</span>
<span class="s3">// versions of React DevTools with older versions of React Native, and the object</span>
<span class="s3">// provided by React Native may not include all of this type's fields.</span>

<span class="s1">function </span><span class="s0">initializeUsingCachedSettings(devToolsSettingsManager) {</span>
  <span class="s0">initializeConsolePatchSettings(devToolsSettingsManager);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">initializeConsolePatchSettings(devToolsSettingsManager) {</span>
  <span class="s1">if </span><span class="s0">(devToolsSettingsManager.getConsolePatchSettings == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">consolePatchSettingsString = devToolsSettingsManager.getConsolePatchSettings();</span>

  <span class="s1">if </span><span class="s0">(consolePatchSettingsString == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">parsedConsolePatchSettings = parseConsolePatchSettings(consolePatchSettingsString);</span>

  <span class="s1">if </span><span class="s0">(parsedConsolePatchSettings == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">writeConsolePatchSettingsToWindow(parsedConsolePatchSettings);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">parseConsolePatchSettings(consolePatchSettingsString) {</span>
  <span class="s1">var </span><span class="s0">_castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;</span>

  <span class="s1">var </span><span class="s0">parsedValue = JSON.parse(consolePatchSettingsString !== </span><span class="s1">null </span><span class="s0">&amp;&amp; consolePatchSettingsString !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? consolePatchSettingsString : </span><span class="s2">'{}'</span><span class="s0">);</span>
  <span class="s1">var </span><span class="s0">appendComponentStack = parsedValue.appendComponentStack,</span>
      <span class="s0">breakOnConsoleErrors = parsedValue.breakOnConsoleErrors,</span>
      <span class="s0">showInlineWarningsAndErrors = parsedValue.showInlineWarningsAndErrors,</span>
      <span class="s0">hideConsoleLogsInStrictMode = parsedValue.hideConsoleLogsInStrictMode,</span>
      <span class="s0">browserTheme = parsedValue.browserTheme;</span>
  <span class="s1">return </span><span class="s0">{</span>
    <span class="s0">appendComponentStack: (_castBool = castBool(appendComponentStack)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBool !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBool : </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">breakOnConsoleErrors: (_castBool2 = castBool(breakOnConsoleErrors)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBool2 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBool2 : </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">showInlineWarningsAndErrors: (_castBool3 = castBool(showInlineWarningsAndErrors)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBool3 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBool3 : </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">hideConsoleLogsInStrictMode: (_castBool4 = castBool(hideConsoleLogsInStrictMode)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBool4 !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBool4 : </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">browserTheme: (_castBrowserTheme = castBrowserTheme(browserTheme)) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _castBrowserTheme !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _castBrowserTheme : </span><span class="s2">'dark'</span>
  <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">cacheConsolePatchSettings(devToolsSettingsManager, value) {</span>
  <span class="s1">if </span><span class="s0">(devToolsSettingsManager.setConsolePatchSettings == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s0">devToolsSettingsManager.setConsolePatchSettings(JSON.stringify(value));</span>
<span class="s0">}</span>
<span class="s0">;</span><span class="s3">// CONCATENATED MODULE: ./src/backend.js</span>
<span class="s3">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 *  
 */</span>









<span class="s3">// Install a global variable to allow patching console early (during injection).</span>
<span class="s3">// This provides React Native developers with components stacks even if they don't run DevTools.</span>
<span class="s0">installConsoleFunctionsToWindow();</span>
<span class="s0">installHook(window);</span>
<span class="s1">var </span><span class="s0">hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;</span>
<span class="s1">var </span><span class="s0">savedComponentFilters = getDefaultComponentFilters();</span>

<span class="s1">function </span><span class="s0">backend_debug(methodName) {</span>
  <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
    <span class="s1">var </span><span class="s0">_console;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">_len = arguments.length, args = </span><span class="s1">new </span><span class="s0">Array(_len &gt; </span><span class="s4">1 </span><span class="s0">? _len - </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">), _key = </span><span class="s4">1</span><span class="s0">; _key &lt; _len; _key++) {</span>
      <span class="s0">args[_key - </span><span class="s4">1</span><span class="s0">] = arguments[_key];</span>
    <span class="s0">}</span>

    <span class="s0">(_console = console).log.apply(_console, [</span><span class="s2">&quot;%c[core/backend] %c&quot;</span><span class="s0">.concat(methodName), </span><span class="s2">'color: teal; font-weight: bold;'</span><span class="s0">, </span><span class="s2">'font-weight: bold;'</span><span class="s0">].concat(args));</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">connectToDevTools(options) {</span>
  <span class="s1">if </span><span class="s0">(hook == </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s3">// DevTools didn't get injected into this page (maybe b'c of the contentType).</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">_ref = options || {},</span>
      <span class="s0">_ref$host = _ref.host,</span>
      <span class="s0">host = _ref$host === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s2">'localhost' </span><span class="s0">: _ref$host,</span>
      <span class="s0">nativeStyleEditorValidAttributes = _ref.nativeStyleEditorValidAttributes,</span>
      <span class="s0">_ref$useHttps = _ref.useHttps,</span>
      <span class="s0">useHttps = _ref$useHttps === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s1">false </span><span class="s0">: _ref$useHttps,</span>
      <span class="s0">_ref$port = _ref.port,</span>
      <span class="s0">port = _ref$port === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s4">8097 </span><span class="s0">: _ref$port,</span>
      <span class="s0">websocket = _ref.websocket,</span>
      <span class="s0">_ref$resolveRNStyle = _ref.resolveRNStyle,</span>
      <span class="s0">resolveRNStyle = _ref$resolveRNStyle === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: _ref$resolveRNStyle,</span>
      <span class="s0">_ref$retryConnectionD = _ref.retryConnectionDelay,</span>
      <span class="s0">retryConnectionDelay = _ref$retryConnectionD === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s4">2000 </span><span class="s0">: _ref$retryConnectionD,</span>
      <span class="s0">_ref$isAppActive = _ref.isAppActive,</span>
      <span class="s0">isAppActive = _ref$isAppActive === </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return true</span><span class="s0">;</span>
  <span class="s0">} : _ref$isAppActive,</span>
      <span class="s0">devToolsSettingsManager = _ref.devToolsSettingsManager;</span>

  <span class="s1">var </span><span class="s0">protocol = useHttps ? </span><span class="s2">'wss' </span><span class="s0">: </span><span class="s2">'ws'</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">retryTimeoutID = </span><span class="s1">null</span><span class="s0">;</span>

  <span class="s1">function </span><span class="s0">scheduleRetry() {</span>
    <span class="s1">if </span><span class="s0">(retryTimeoutID === </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// Two seconds because RN had issues with quick retries.</span>
      <span class="s0">retryTimeoutID = setTimeout(</span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">connectToDevTools(options);</span>
      <span class="s0">}, retryConnectionDelay);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(devToolsSettingsManager != </span><span class="s1">null</span><span class="s0">) {</span>
    <span class="s1">try </span><span class="s0">{</span>
      <span class="s0">initializeUsingCachedSettings(devToolsSettingsManager);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
      <span class="s3">// If we call a method on devToolsSettingsManager that throws, or if</span>
      <span class="s3">// is invalid data read out, don't throw and don't interrupt initialization</span>
      <span class="s0">console.error(e);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s1">if </span><span class="s0">(!isAppActive()) {</span>
    <span class="s3">// If the app is in background, maybe retry later.</span>
    <span class="s3">// Don't actually attempt to connect until we're in foreground.</span>
    <span class="s0">scheduleRetry();</span>
    <span class="s1">return</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s1">var </span><span class="s0">bridge = </span><span class="s1">null</span><span class="s0">;</span>
  <span class="s1">var </span><span class="s0">messageListeners = [];</span>
  <span class="s1">var </span><span class="s0">uri = protocol + </span><span class="s2">'://' </span><span class="s0">+ host + </span><span class="s2">':' </span><span class="s0">+ port; </span><span class="s3">// If existing websocket is passed, use it.</span>
  <span class="s3">// This is necessary to support our custom integrations.</span>
  <span class="s3">// See D6251744.</span>

  <span class="s1">var </span><span class="s0">ws = websocket ? websocket : </span><span class="s1">new </span><span class="s0">window.WebSocket(uri);</span>
  <span class="s0">ws.onclose = handleClose;</span>
  <span class="s0">ws.onerror = handleFailed;</span>
  <span class="s0">ws.onmessage = handleMessage;</span>

  <span class="s0">ws.onopen = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s0">bridge = </span><span class="s1">new </span><span class="s0">src_bridge({</span>
      <span class="s0">listen: </span><span class="s1">function </span><span class="s0">listen(fn) {</span>
        <span class="s0">messageListeners.push(fn);</span>
        <span class="s1">return function </span><span class="s0">() {</span>
          <span class="s1">var </span><span class="s0">index = messageListeners.indexOf(fn);</span>

          <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">messageListeners.splice(index, </span><span class="s4">1</span><span class="s0">);</span>
          <span class="s0">}</span>
        <span class="s0">};</span>
      <span class="s0">},</span>
      <span class="s0">send: </span><span class="s1">function </span><span class="s0">send(event, payload, transferable) {</span>
        <span class="s1">if </span><span class="s0">(ws.readyState === ws.OPEN) {</span>
          <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
            <span class="s0">backend_debug(</span><span class="s2">'wall.send()'</span><span class="s0">, event, payload);</span>
          <span class="s0">}</span>

          <span class="s0">ws.send(JSON.stringify({</span>
            <span class="s0">event: event,</span>
            <span class="s0">payload: payload</span>
          <span class="s0">}));</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
            <span class="s0">backend_debug(</span><span class="s2">'wall.send()'</span><span class="s0">, </span><span class="s2">'Shutting down bridge because of closed WebSocket connection'</span><span class="s0">);</span>
          <span class="s0">}</span>

          <span class="s1">if </span><span class="s0">(bridge !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">bridge.shutdown();</span>
          <span class="s0">}</span>

          <span class="s0">scheduleRetry();</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">bridge.addListener(</span><span class="s2">'updateComponentFilters'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(componentFilters) {</span>
      <span class="s3">// Save filter changes in memory, in case DevTools is reloaded.</span>
      <span class="s3">// In that case, the renderer will already be using the updated values.</span>
      <span class="s3">// We'll lose these in between backend reloads but that can't be helped.</span>
      <span class="s0">savedComponentFilters = componentFilters;</span>
    <span class="s0">});</span>

    <span class="s1">if </span><span class="s0">(devToolsSettingsManager != </span><span class="s1">null </span><span class="s0">&amp;&amp; bridge != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">bridge.addListener(</span><span class="s2">'updateConsolePatchSettings'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(consolePatchSettings) {</span>
        <span class="s1">return </span><span class="s0">cacheConsolePatchSettings(devToolsSettingsManager, consolePatchSettings);</span>
      <span class="s0">});</span>
    <span class="s0">} </span><span class="s3">// The renderer interface doesn't read saved component filters directly,</span>
    <span class="s3">// because they are generally stored in localStorage within the context of the extension.</span>
    <span class="s3">// Because of this it relies on the extension to pass filters.</span>
    <span class="s3">// In the case of the standalone DevTools being used with a website,</span>
    <span class="s3">// saved filters are injected along with the backend script tag so we shouldn't override them here.</span>
    <span class="s3">// This injection strategy doesn't work for React Native though.</span>
    <span class="s3">// Ideally the backend would save the filters itself, but RN doesn't provide a sync storage solution.</span>
    <span class="s3">// So for now we just fall back to using the default filters...</span>


    <span class="s1">if </span><span class="s0">(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s3">// $FlowFixMe[incompatible-use] found when upgrading Flow</span>
      <span class="s0">bridge.send(</span><span class="s2">'overrideComponentFilters'</span><span class="s0">, savedComponentFilters);</span>
    <span class="s0">} </span><span class="s3">// TODO (npm-packages) Warn if &quot;isBackendStorageAPISupported&quot;</span>
    <span class="s3">// $FlowFixMe[incompatible-call] found when upgrading Flow</span>


    <span class="s1">var </span><span class="s0">agent = </span><span class="s1">new </span><span class="s0">Agent(bridge);</span>
    <span class="s0">agent.addListener(</span><span class="s2">'shutdown'</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s3">// If we received 'shutdown' from `agent`, we assume the `bridge` is already shutting down,</span>
      <span class="s3">// and that caused the 'shutdown' event on the `agent`, so we don't need to call `bridge.shutdown()` here.</span>
      <span class="s0">hook.emit(</span><span class="s2">'shutdown'</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">initBackend(hook, agent, window); </span><span class="s3">// Setup React Native style editor if the environment supports it.</span>

    <span class="s1">if </span><span class="s0">(resolveRNStyle != </span><span class="s1">null </span><span class="s0">|| hook.resolveRNStyle != </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">setupNativeStyleEditor( </span><span class="s3">// $FlowFixMe[incompatible-call] found when upgrading Flow</span>
      <span class="s0">bridge, agent, resolveRNStyle || hook.resolveRNStyle, nativeStyleEditorValidAttributes || hook.nativeStyleEditorValidAttributes || </span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s3">// Otherwise listen to detect if the environment later supports it.</span>
      <span class="s3">// For example, Flipper does not eagerly inject these values.</span>
      <span class="s3">// Instead it relies on the React Native Inspector to lazily inject them.</span>
      <span class="s1">var </span><span class="s0">lazyResolveRNStyle;</span>
      <span class="s1">var </span><span class="s0">lazyNativeStyleEditorValidAttributes;</span>

      <span class="s1">var </span><span class="s0">initAfterTick = </span><span class="s1">function </span><span class="s0">initAfterTick() {</span>
        <span class="s1">if </span><span class="s0">(bridge !== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s0">setupNativeStyleEditor(bridge, agent, lazyResolveRNStyle, lazyNativeStyleEditorValidAttributes);</span>
        <span class="s0">}</span>
      <span class="s0">};</span>

      <span class="s1">if </span><span class="s0">(!hook.hasOwnProperty(</span><span class="s2">'resolveRNStyle'</span><span class="s0">)) {</span>
        <span class="s0">Object.defineProperty(hook, </span><span class="s2">'resolveRNStyle'</span><span class="s0">, {</span>
          <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
          <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
            <span class="s1">return </span><span class="s0">lazyResolveRNStyle;</span>
          <span class="s0">},</span>
          <span class="s0">set: </span><span class="s1">function </span><span class="s0">set(value) {</span>
            <span class="s0">lazyResolveRNStyle = value;</span>
            <span class="s0">initAfterTick();</span>
          <span class="s0">}</span>
        <span class="s0">});</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(!hook.hasOwnProperty(</span><span class="s2">'nativeStyleEditorValidAttributes'</span><span class="s0">)) {</span>
        <span class="s0">Object.defineProperty(hook, </span><span class="s2">'nativeStyleEditorValidAttributes'</span><span class="s0">, {</span>
          <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
          <span class="s0">get: </span><span class="s1">function </span><span class="s0">get() {</span>
            <span class="s1">return </span><span class="s0">lazyNativeStyleEditorValidAttributes;</span>
          <span class="s0">},</span>
          <span class="s0">set: </span><span class="s1">function </span><span class="s0">set(value) {</span>
            <span class="s0">lazyNativeStyleEditorValidAttributes = value;</span>
            <span class="s0">initAfterTick();</span>
          <span class="s0">}</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
  <span class="s0">};</span>

  <span class="s1">function </span><span class="s0">handleClose() {</span>
    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">backend_debug(</span><span class="s2">'WebSocket.onclose'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(bridge !== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s0">bridge.emit(</span><span class="s2">'shutdown'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">scheduleRetry();</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">handleFailed() {</span>
    <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
      <span class="s0">backend_debug(</span><span class="s2">'WebSocket.onerror'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">scheduleRetry();</span>
  <span class="s0">}</span>

  <span class="s1">function </span><span class="s0">handleMessage(event) {</span>
    <span class="s1">var </span><span class="s0">data;</span>

    <span class="s1">try </span><span class="s0">{</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">event.data === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s0">data = JSON.parse(event.data);</span>

        <span class="s1">if </span><span class="s0">(__DEBUG__) {</span>
          <span class="s0">backend_debug(</span><span class="s2">'WebSocket.onmessage'</span><span class="s0">, data);</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">throw </span><span class="s0">Error();</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
      <span class="s0">console.error(</span><span class="s2">'[React DevTools] Failed to parse JSON: ' </span><span class="s0">+ event.data);</span>
      <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">messageListeners.forEach(</span><span class="s1">function </span><span class="s0">(fn) {</span>
      <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">fn(data);</span>
      <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
        <span class="s3">// jsc doesn't play so well with tracebacks that go into eval'd code,</span>
        <span class="s3">// so the stack trace here will stop at the `eval()` call. Getting the</span>
        <span class="s3">// message that caused the error is the best we can do for now.</span>
        <span class="s0">console.log(</span><span class="s2">'[React DevTools] Error calling listener'</span><span class="s0">, data);</span>
        <span class="s0">console.log(</span><span class="s2">'error:'</span><span class="s0">, error);</span>
        <span class="s1">throw </span><span class="s0">error;</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">})();</span>

<span class="s3">/******/ 	</span><span class="s1">return </span><span class="s0">__webpack_exports__;</span>
<span class="s3">/******/ </span><span class="s0">})()</span>
<span class="s0">;</span>
<span class="s0">});</span>
<span class="s3">//# sourceMappingURL=backend.js.map</span></pre>
</body>
</html>
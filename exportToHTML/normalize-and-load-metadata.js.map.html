<html>
<head>
<title>normalize-and-load-metadata.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
normalize-and-load-metadata.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_path&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperValidatorIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSplitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;hasExports&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;isSideEffectImport&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;imports&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;importsNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;reexports&quot;</span><span class="s0">,</span><span class="s1">&quot;reexportNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;reexportAll&quot;</span><span class="s0">,</span><span class="s1">&quot;validateImportInteropOption&quot;</span><span class="s0">,</span><span class="s1">&quot;importInterop&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveImportInterop&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeModuleAndLoadMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;programPath&quot;</span><span class="s0">,</span><span class="s1">&quot;exportName&quot;</span><span class="s0">,</span><span class="s1">&quot;initializeReexports&quot;</span><span class="s0">,</span><span class="s1">&quot;lazy&quot;</span><span class="s0">,</span><span class="s1">&quot;esNamespaceOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;stringSpecifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;nameAnonymousExports&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">,</span><span class="s1">&quot;getModuleMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;removeImportExportDeclarations&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedInterop&quot;</span><span class="s0">,</span><span class="s1">&quot;interop&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNameListName&quot;</span><span class="s0">,</span><span class="s1">&quot;getExportSpecifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;stringValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;assertExportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;localData&quot;</span><span class="s0">,</span><span class="s1">&quot;getLocalExportMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceData&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;getData&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceNode&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;basename&quot;</span><span class="s0">,</span><span class="s1">&quot;extname&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;referenced&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;spec&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;localName&quot;</span><span class="s0">,</span><span class="s1">&quot;reexport&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;importName&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportAllDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;needsDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;needsNamed&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingKindLookup&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;localMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;getLocalMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;idPath&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;ids&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifierPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;splitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;_blockHoist&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/normalize-and-load-metadata.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { basename, extname } from </span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { isIdentifierName } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-validator-identifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import splitExportDeclaration from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-split-export-declaration</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export interface ModuleMetadata {</span><span class="s3">\n  </span><span class="s1">exportName: string;</span><span class="s3">\n  </span><span class="s1">// The name of the variable that will reference an object containing export names.</span><span class="s3">\n  </span><span class="s1">exportNameListName: null | string;</span><span class="s3">\n  </span><span class="s1">hasExports: boolean;</span><span class="s3">\n  </span><span class="s1">// Lookup from local binding to export information.</span><span class="s3">\n  </span><span class="s1">local: Map&lt;string, LocalExportMetadata&gt;;</span><span class="s3">\n  </span><span class="s1">// Lookup of source file to source file metadata.</span><span class="s3">\n  </span><span class="s1">source: Map&lt;string, SourceModuleMetadata&gt;;</span><span class="s3">\n  </span><span class="s1">// List of names that should only be printed as string literals.</span><span class="s3">\n  </span><span class="s1">// i.e. `import { </span><span class="s3">\&quot;</span><span class="s1">any unicode</span><span class="s3">\&quot; </span><span class="s1">as foo } from </span><span class="s3">\&quot;</span><span class="s1">some-module</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n  </span><span class="s1">// `stringSpecifiers` is Set(1) [</span><span class="s3">\&quot;</span><span class="s1">any unicode</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">// In most cases `stringSpecifiers` is an empty Set</span><span class="s3">\n  </span><span class="s1">stringSpecifiers: Set&lt;string&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type InteropType =</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">// Babel interop for default-only imports</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot; </span><span class="s1">// Babel interop for namespace or default+named imports</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">node-default</span><span class="s3">\&quot; </span><span class="s1">// Node.js interop for default-only imports</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">node-namespace</span><span class="s3">\&quot; </span><span class="s1">// Node.js interop for namespace or default+named imports</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">; // No interop, or named-only imports</span><span class="s3">\n\n</span><span class="s1">export type ImportInterop =</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">babel</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;\n  </span><span class="s1">| ((source: string, filename?: string) =&gt; </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">babel</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export type Lazy = boolean | string[] | ((source: string) =&gt; boolean);</span><span class="s3">\n\n</span><span class="s1">export interface SourceModuleMetadata {</span><span class="s3">\n  </span><span class="s1">// A unique variable name to use for this namespace object. Centralized for simplicity.</span><span class="s3">\n  </span><span class="s1">name: string;</span><span class="s3">\n  </span><span class="s1">loc: t.SourceLocation | undefined | null;</span><span class="s3">\n  </span><span class="s1">interop: InteropType;</span><span class="s3">\n  </span><span class="s1">// Local binding to reference from this source namespace. Key: Local name, value: Import name</span><span class="s3">\n  </span><span class="s1">imports: Map&lt;string, string&gt;;</span><span class="s3">\n  </span><span class="s1">// Local names that reference namespace object.</span><span class="s3">\n  </span><span class="s1">importsNamespace: Set&lt;string&gt;;</span><span class="s3">\n  </span><span class="s1">// Reexports to create for namespace. Key: Export name, value: Import name</span><span class="s3">\n  </span><span class="s1">reexports: Map&lt;string, string&gt;;</span><span class="s3">\n  </span><span class="s1">// List of names to re-export namespace as.</span><span class="s3">\n  </span><span class="s1">reexportNamespace: Set&lt;string&gt;;</span><span class="s3">\n  </span><span class="s1">// Tracks if the source should be re-exported.</span><span class="s3">\n  </span><span class="s1">reexportAll: null | {</span><span class="s3">\n    </span><span class="s1">loc: t.SourceLocation | undefined | null;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">lazy?: Lazy;</span><span class="s3">\n  </span><span class="s1">referenced: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface LocalExportMetadata {</span><span class="s3">\n  </span><span class="s1">names: Array&lt;string&gt;; // names of exports,</span><span class="s3">\n  </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">hoisted</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if the module has any exports that need handling.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasExports(metadata: ModuleMetadata) {</span><span class="s3">\n  </span><span class="s1">return metadata.hasExports;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a given source is an anonymous import, e.g. </span><span class="s3">\&quot;</span><span class="s1">import 'foo';</span><span class="s3">\&quot;\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isSideEffectImport(source: SourceModuleMetadata) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">source.imports.size === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">source.importsNamespace.size === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">source.reexports.size === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">source.reexportNamespace.size === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!source.reexportAll</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function validateImportInteropOption(</span><span class="s3">\n  </span><span class="s1">importInterop: any,</span><span class="s3">\n</span><span class="s1">): importInterop is ImportInterop {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof importInterop !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">importInterop !== </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">importInterop !== </span><span class="s3">\&quot;</span><span class="s1">babel</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">importInterop !== </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`.importInterop must be one of </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">babel</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">, or a function returning one of those values (received ${importInterop}).`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return importInterop;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveImportInterop(</span><span class="s3">\n  </span><span class="s1">importInterop: ImportInterop,</span><span class="s3">\n  </span><span class="s1">source: string,</span><span class="s3">\n  </span><span class="s1">filename: string | undefined,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (typeof importInterop === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return validateImportInteropOption(importInterop(source, filename));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return importInterop;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Remove all imports and exports from the file, and return all metadata</span><span class="s3">\n </span><span class="s1">* needed to reconstruct the module's behavior.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function normalizeModuleAndLoadMetadata(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">exportName: string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">importInterop,</span><span class="s3">\n    </span><span class="s1">initializeReexports = false,</span><span class="s3">\n    </span><span class="s1">lazy = false,</span><span class="s3">\n    </span><span class="s1">esNamespaceOnly = false,</span><span class="s3">\n    </span><span class="s1">filename,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">importInterop: ImportInterop;</span><span class="s3">\n    </span><span class="s1">initializeReexports: boolean | void;</span><span class="s3">\n    </span><span class="s1">lazy: Lazy;</span><span class="s3">\n    </span><span class="s1">esNamespaceOnly: boolean;</span><span class="s3">\n    </span><span class="s1">filename: string;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">): ModuleMetadata {</span><span class="s3">\n  </span><span class="s1">if (!exportName) {</span><span class="s3">\n    </span><span class="s1">exportName = programPath.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">exports</span><span class="s3">\&quot;</span><span class="s1">).name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const stringSpecifiers = new Set&lt;string&gt;();</span><span class="s3">\n\n  </span><span class="s1">nameAnonymousExports(programPath);</span><span class="s3">\n\n  </span><span class="s1">const { local, sources, hasExports } = getModuleMetadata(</span><span class="s3">\n    </span><span class="s1">programPath,</span><span class="s3">\n    </span><span class="s1">{ initializeReexports, lazy },</span><span class="s3">\n    </span><span class="s1">stringSpecifiers,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">removeImportExportDeclarations(programPath);</span><span class="s3">\n\n  </span><span class="s1">// Reuse the imported namespace name if there is one.</span><span class="s3">\n  </span><span class="s1">for (const [source, metadata] of sources) {</span><span class="s3">\n    </span><span class="s1">if (metadata.importsNamespace.size &gt; 0) {</span><span class="s3">\n      </span><span class="s1">// This is kind of gross. If we stop using `loose: true` we should</span><span class="s3">\n      </span><span class="s1">// just make this destructuring assignment.</span><span class="s3">\n      </span><span class="s1">metadata.name = metadata.importsNamespace.values().next().value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const resolvedInterop = resolveImportInterop(</span><span class="s3">\n      </span><span class="s1">importInterop,</span><span class="s3">\n      </span><span class="s1">source,</span><span class="s3">\n      </span><span class="s1">filename,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (resolvedInterop === </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (resolvedInterop === </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; metadata.interop === </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">node-namespace</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (resolvedInterop === </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; metadata.interop === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">node-default</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (esNamespaceOnly &amp;&amp; metadata.interop === </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Both the default and namespace interops pass through __esModule</span><span class="s3">\n      </span><span class="s1">// objects, but the namespace interop is used to enable Babel's</span><span class="s3">\n      </span><span class="s1">// destructuring-like interop behavior for normal CommonJS.</span><span class="s3">\n      </span><span class="s1">// Since some tooling has started to remove that behavior, we expose</span><span class="s3">\n      </span><span class="s1">// it as the `esNamespace` option.</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">exportName,</span><span class="s3">\n    </span><span class="s1">exportNameListName: null,</span><span class="s3">\n    </span><span class="s1">hasExports,</span><span class="s3">\n    </span><span class="s1">local,</span><span class="s3">\n    </span><span class="s1">source: sources,</span><span class="s3">\n    </span><span class="s1">stringSpecifiers,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getExportSpecifierName(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">stringSpecifiers: Set&lt;string&gt;,</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">if (path.isIdentifier()) {</span><span class="s3">\n    </span><span class="s1">return path.node.name;</span><span class="s3">\n  </span><span class="s1">} else if (path.isStringLiteral()) {</span><span class="s3">\n    </span><span class="s1">const stringValue = path.node.value;</span><span class="s3">\n    </span><span class="s1">// add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name</span><span class="s3">\n    </span><span class="s1">// i.e In `import { </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot; </span><span class="s1">as bar }`</span><span class="s3">\n    </span><span class="s1">// we do not consider `</span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">` to be a `stringSpecifier` because we can treat it as</span><span class="s3">\n    </span><span class="s1">// `import { foo as bar }`</span><span class="s3">\n    </span><span class="s1">// This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names</span><span class="s3">\n    </span><span class="s1">// when building transpiled code from metadata</span><span class="s3">\n    </span><span class="s1">if (!isIdentifierName(stringValue)) {</span><span class="s3">\n      </span><span class="s1">stringSpecifiers.add(stringValue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return stringValue;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assertExportSpecifier(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n</span><span class="s1">): asserts path is NodePath&lt;t.ExportSpecifier&gt; {</span><span class="s3">\n  </span><span class="s1">if (path.isExportSpecifier()) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} else if (path.isExportNamespaceSpecifier()) {</span><span class="s3">\n    </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n      \&quot;</span><span class="s1">Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\&quot;</span><span class="s1">Unexpected export specifier type</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get metadata about the imports and exports present in this module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getModuleMetadata(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">lazy,</span><span class="s3">\n    </span><span class="s1">initializeReexports,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">// todo(flow-ts) changed from boolean, to match expected usage inside the function</span><span class="s3">\n    </span><span class="s1">lazy: boolean | string[] | ((source: string) =&gt; boolean);</span><span class="s3">\n    </span><span class="s1">initializeReexports: boolean | void;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">stringSpecifiers: Set&lt;string&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const localData = getLocalExportMetadata(</span><span class="s3">\n    </span><span class="s1">programPath,</span><span class="s3">\n    </span><span class="s1">initializeReexports,</span><span class="s3">\n    </span><span class="s1">stringSpecifiers,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const sourceData = new Map&lt;string, SourceModuleMetadata&gt;();</span><span class="s3">\n  </span><span class="s1">const getData = (sourceNode: t.StringLiteral) =&gt; {</span><span class="s3">\n    </span><span class="s1">const source = sourceNode.value;</span><span class="s3">\n\n    </span><span class="s1">let data = sourceData.get(source);</span><span class="s3">\n    </span><span class="s1">if (!data) {</span><span class="s3">\n      </span><span class="s1">data = {</span><span class="s3">\n        </span><span class="s1">name: programPath.scope.generateUidIdentifier(</span><span class="s3">\n          </span><span class="s1">basename(source, extname(source)),</span><span class="s3">\n        </span><span class="s1">).name,</span><span class="s3">\n\n        </span><span class="s1">interop: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n        </span><span class="s1">loc: null,</span><span class="s3">\n\n        </span><span class="s1">// Data about the requested sources and names.</span><span class="s3">\n        </span><span class="s1">imports: new Map(),</span><span class="s3">\n        </span><span class="s1">importsNamespace: new Set(),</span><span class="s3">\n\n        </span><span class="s1">// Metadata about data that is passed directly from source to export.</span><span class="s3">\n        </span><span class="s1">reexports: new Map(),</span><span class="s3">\n        </span><span class="s1">reexportNamespace: new Set(),</span><span class="s3">\n        </span><span class="s1">reexportAll: null,</span><span class="s3">\n\n        </span><span class="s1">lazy: false,</span><span class="s3">\n\n        </span><span class="s1">referenced: false,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">sourceData.set(source, data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return data;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">let hasExports = false;</span><span class="s3">\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(child =&gt; {</span><span class="s3">\n    </span><span class="s1">if (child.isImportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">const data = getData(child.node.source);</span><span class="s3">\n      </span><span class="s1">if (!data.loc) data.loc = child.node.loc;</span><span class="s3">\n\n      </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).forEach(spec =&gt; {</span><span class="s3">\n        </span><span class="s1">if (spec.isImportDefaultSpecifier()) {</span><span class="s3">\n          </span><span class="s1">const localName = spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">).node.name;</span><span class="s3">\n\n          </span><span class="s1">data.imports.set(localName, </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">const reexport = localData.get(localName);</span><span class="s3">\n          </span><span class="s1">if (reexport) {</span><span class="s3">\n            </span><span class="s1">localData.delete(localName);</span><span class="s3">\n\n            </span><span class="s1">reexport.names.forEach(name =&gt; {</span><span class="s3">\n              </span><span class="s1">data.reexports.set(name, </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">data.referenced = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (spec.isImportNamespaceSpecifier()) {</span><span class="s3">\n          </span><span class="s1">const localName = spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">).node.name;</span><span class="s3">\n\n          </span><span class="s1">data.importsNamespace.add(localName);</span><span class="s3">\n          </span><span class="s1">const reexport = localData.get(localName);</span><span class="s3">\n          </span><span class="s1">if (reexport) {</span><span class="s3">\n            </span><span class="s1">localData.delete(localName);</span><span class="s3">\n\n            </span><span class="s1">reexport.names.forEach(name =&gt; {</span><span class="s3">\n              </span><span class="s1">data.reexportNamespace.add(name);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">data.referenced = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (spec.isImportSpecifier()) {</span><span class="s3">\n          </span><span class="s1">const importName = getExportSpecifierName(</span><span class="s3">\n            </span><span class="s1">spec.get(</span><span class="s3">\&quot;</span><span class="s1">imported</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">stringSpecifiers,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">const localName = spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">).node.name;</span><span class="s3">\n\n          </span><span class="s1">data.imports.set(localName, importName);</span><span class="s3">\n\n          </span><span class="s1">const reexport = localData.get(localName);</span><span class="s3">\n          </span><span class="s1">if (reexport) {</span><span class="s3">\n            </span><span class="s1">localData.delete(localName);</span><span class="s3">\n\n            </span><span class="s1">reexport.names.forEach(name =&gt; {</span><span class="s3">\n              </span><span class="s1">data.reexports.set(name, importName);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">data.referenced = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportAllDeclaration()) {</span><span class="s3">\n      </span><span class="s1">hasExports = true;</span><span class="s3">\n      </span><span class="s1">const data = getData(child.node.source);</span><span class="s3">\n      </span><span class="s1">if (!data.loc) data.loc = child.node.loc;</span><span class="s3">\n\n      </span><span class="s1">data.reexportAll = {</span><span class="s3">\n        </span><span class="s1">loc: child.node.loc,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">data.referenced = true;</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportNamedDeclaration() &amp;&amp; child.node.source) {</span><span class="s3">\n      </span><span class="s1">hasExports = true;</span><span class="s3">\n      </span><span class="s1">const data = getData(child.node.source);</span><span class="s3">\n      </span><span class="s1">if (!data.loc) data.loc = child.node.loc;</span><span class="s3">\n\n      </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).forEach(spec =&gt; {</span><span class="s3">\n        </span><span class="s1">assertExportSpecifier(spec);</span><span class="s3">\n        </span><span class="s1">const importName = getExportSpecifierName(</span><span class="s3">\n          </span><span class="s1">spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">stringSpecifiers,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const exportName = getExportSpecifierName(</span><span class="s3">\n          </span><span class="s1">spec.get(</span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">stringSpecifiers,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">data.reexports.set(exportName, importName);</span><span class="s3">\n        </span><span class="s1">data.referenced = true;</span><span class="s3">\n\n        </span><span class="s1">if (exportName === </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">throw spec</span><span class="s3">\n            </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">.buildCodeFrameError('Illegal export </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">child.isExportNamedDeclaration() ||</span><span class="s3">\n      </span><span class="s1">child.isExportDefaultDeclaration()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">hasExports = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">for (const metadata of sourceData.values()) {</span><span class="s3">\n    </span><span class="s1">let needsDefault = false;</span><span class="s3">\n    </span><span class="s1">let needsNamed = false;</span><span class="s3">\n\n    </span><span class="s1">if (metadata.importsNamespace.size &gt; 0) {</span><span class="s3">\n      </span><span class="s1">needsDefault = true;</span><span class="s3">\n      </span><span class="s1">needsNamed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (metadata.reexportAll) {</span><span class="s3">\n      </span><span class="s1">needsNamed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const importName of metadata.imports.values()) {</span><span class="s3">\n      </span><span class="s1">if (importName === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) needsDefault = true;</span><span class="s3">\n      </span><span class="s1">else needsNamed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const importName of metadata.reexports.values()) {</span><span class="s3">\n      </span><span class="s1">if (importName === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) needsDefault = true;</span><span class="s3">\n      </span><span class="s1">else needsNamed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (needsDefault &amp;&amp; needsNamed) {</span><span class="s3">\n      </span><span class="s1">// TODO(logan): Using the namespace interop here is unfortunate. Revisit.</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (needsDefault) {</span><span class="s3">\n      </span><span class="s1">metadata.interop = </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [source, metadata] of sourceData) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">lazy !== false &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!(isSideEffectImport(metadata) || metadata.reexportAll)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (lazy === true) {</span><span class="s3">\n        </span><span class="s1">// 'true' means that local relative files are eagerly loaded and</span><span class="s3">\n        </span><span class="s1">// dependency modules are loaded lazily.</span><span class="s3">\n        </span><span class="s1">metadata.lazy = !/</span><span class="s3">\\</span><span class="s1">./.test(source);</span><span class="s3">\n      </span><span class="s1">} else if (Array.isArray(lazy)) {</span><span class="s3">\n        </span><span class="s1">metadata.lazy = lazy.indexOf(source) !== -1;</span><span class="s3">\n      </span><span class="s1">} else if (typeof lazy === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">metadata.lazy = lazy(source);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error(`.lazy must be a boolean, string array, or function`);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">hasExports,</span><span class="s3">\n    </span><span class="s1">local: localData,</span><span class="s3">\n    </span><span class="s1">sources: sourceData,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ModuleBindingKind = </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">hoisted</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get metadata about local variables that are exported.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getLocalExportMetadata(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">initializeReexports: boolean | void,</span><span class="s3">\n  </span><span class="s1">stringSpecifiers: Set&lt;string&gt;,</span><span class="s3">\n</span><span class="s1">): Map&lt;string, LocalExportMetadata&gt; {</span><span class="s3">\n  </span><span class="s1">const bindingKindLookup = new Map();</span><span class="s3">\n\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach((child: NodePath) =&gt; {</span><span class="s3">\n    </span><span class="s1">let kind: ModuleBindingKind;</span><span class="s3">\n    </span><span class="s1">if (child.isImportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (child.isExportDefaultDeclaration()) {</span><span class="s3">\n        </span><span class="s1">child = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (child.isExportNamedDeclaration()) {</span><span class="s3">\n        </span><span class="s1">if (child.node.declaration) {</span><span class="s3">\n          </span><span class="s1">child = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">initializeReexports &amp;&amp;</span><span class="s3">\n          </span><span class="s1">child.node.source &amp;&amp;</span><span class="s3">\n          </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">).isStringLiteral()</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).forEach(spec =&gt; {</span><span class="s3">\n            </span><span class="s1">assertExportSpecifier(spec);</span><span class="s3">\n            </span><span class="s1">bindingKindLookup.set(spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">).node.name, </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (child.isFunctionDeclaration()) {</span><span class="s3">\n        </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">hoisted</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else if (child.isClassDeclaration()) {</span><span class="s3">\n        </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else if (child.isVariableDeclaration({ kind: </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n        </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else if (child.isVariableDeclaration()) {</span><span class="s3">\n        </span><span class="s1">kind = </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">Object.keys(child.getOuterBindingIdentifiers()).forEach(name =&gt; {</span><span class="s3">\n      </span><span class="s1">bindingKindLookup.set(name, kind);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">const localMetadata = new Map();</span><span class="s3">\n  </span><span class="s1">const getLocalMetadata = (idPath: NodePath&lt;t.Identifier&gt;) =&gt; {</span><span class="s3">\n    </span><span class="s1">const localName = idPath.node.name;</span><span class="s3">\n    </span><span class="s1">let metadata = localMetadata.get(localName);</span><span class="s3">\n\n    </span><span class="s1">if (!metadata) {</span><span class="s3">\n      </span><span class="s1">const kind = bindingKindLookup.get(localName);</span><span class="s3">\n\n      </span><span class="s1">if (kind === undefined) {</span><span class="s3">\n        </span><span class="s1">throw idPath.buildCodeFrameError(</span><span class="s3">\n          </span><span class="s1">`Exporting local </span><span class="s3">\&quot;</span><span class="s1">${localName}</span><span class="s3">\&quot;</span><span class="s1">, which is not declared.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">metadata = {</span><span class="s3">\n        </span><span class="s1">names: [],</span><span class="s3">\n        </span><span class="s1">kind,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">localMetadata.set(localName, metadata);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return metadata;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(child =&gt; {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">child.isExportNamedDeclaration() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(initializeReexports || !child.node.source)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (child.node.declaration) {</span><span class="s3">\n        </span><span class="s1">const declaration = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const ids = declaration.getOuterBindingIdentifierPaths();</span><span class="s3">\n        </span><span class="s1">Object.keys(ids).forEach(name =&gt; {</span><span class="s3">\n          </span><span class="s1">if (name === </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">throw declaration.buildCodeFrameError(</span><span class="s3">\n              </span><span class="s1">'Illegal export </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">.',</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">getLocalMetadata(ids[name]).names.push(name);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">child.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).forEach(spec =&gt; {</span><span class="s3">\n          </span><span class="s1">const local = spec.get(</span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">const exported = spec.get(</span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">const localMetadata = getLocalMetadata(local);</span><span class="s3">\n          </span><span class="s1">const exportName = getExportSpecifierName(exported, stringSpecifiers);</span><span class="s3">\n\n          </span><span class="s1">if (exportName === </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">throw exported.buildCodeFrameError('Illegal export </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">.');</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">localMetadata.names.push(exportName);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportDefaultDeclaration()) {</span><span class="s3">\n      </span><span class="s1">const declaration = child.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">declaration.isFunctionDeclaration() ||</span><span class="s3">\n        </span><span class="s1">declaration.isClassDeclaration()</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): improve babel-types</span><span class="s3">\n        </span><span class="s1">getLocalMetadata(declaration.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)).names.push(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// These should have been removed by the nameAnonymousExports() call.</span><span class="s3">\n        </span><span class="s1">throw declaration.buildCodeFrameError(</span><span class="s3">\n          \&quot;</span><span class="s1">Unexpected default expression export.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return localMetadata;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensure that all exported values have local binding names.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function nameAnonymousExports(programPath: NodePath&lt;t.Program&gt;) {</span><span class="s3">\n  </span><span class="s1">// Name anonymous exported locals.</span><span class="s3">\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(child =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!child.isExportDefaultDeclaration()) return;</span><span class="s3">\n    </span><span class="s1">splitExportDeclaration(child);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function removeImportExportDeclarations(programPath: NodePath&lt;t.Program&gt;) {</span><span class="s3">\n  </span><span class="s1">programPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(child =&gt; {</span><span class="s3">\n    </span><span class="s1">if (child.isImportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">child.remove();</span><span class="s3">\n    </span><span class="s1">} else if (child.isExportNamedDeclaration()) {</span><span class="s3">\n      </span><span class="s1">if (child.node.declaration) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n        </span><span class="s1">child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      // export default foo;\n      const declaration = child.get(\&quot;declaration\&quot;);\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow-&gt;ts): avoid mutations\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(\n          declaration as NodePath&lt;t.FunctionDeclaration | t.ClassDeclaration&gt;,\n        );\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \&quot;Unexpected default expression export.\&quot;,\n        );\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}\n&quot;],&quot;mappings&quot;:&quot;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&quot;}</span></pre>
</body>
</html>
<html>
<head>
<title>argument_parser.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
argument_parser.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * class ArgumentParser 
 * 
 * Object for parsing command line strings into js objects. 
 * 
 * Inherited from [[ActionContainer]] 
 **/</span>
<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">util    = require(</span><span class="s2">'util'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">format  = require(</span><span class="s2">'util'</span><span class="s1">).format;</span>
<span class="s3">var </span><span class="s1">Path    = require(</span><span class="s2">'path'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">sprintf = require(</span><span class="s2">'sprintf-js'</span><span class="s1">).sprintf;</span>

<span class="s0">// Constants</span>
<span class="s3">var </span><span class="s1">c = require(</span><span class="s2">'./const'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">$$ = require(</span><span class="s2">'./utils'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">ActionContainer = require(</span><span class="s2">'./action_container'</span><span class="s1">);</span>

<span class="s0">// Errors</span>
<span class="s3">var </span><span class="s1">argumentErrorHelper = require(</span><span class="s2">'./argument/error'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">HelpFormatter = require(</span><span class="s2">'./help/formatter'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">Namespace = require(</span><span class="s2">'./namespace'</span><span class="s1">);</span>


<span class="s0">/** 
 * new ArgumentParser(options) 
 * 
 * Create a new ArgumentParser object. 
 * 
 * ##### Options: 
 * - `prog`  The name of the program (default: Path.basename(process.argv[1])) 
 * - `usage`  A usage message (default: auto-generated from arguments) 
 * - `description`  A description of what the program does 
 * - `epilog`  Text following the argument descriptions 
 * - `parents`  Parsers whose arguments should be copied into this one 
 * - `formatterClass`  HelpFormatter class for printing help messages 
 * - `prefixChars`  Characters that prefix optional arguments 
 * - `fromfilePrefixChars` Characters that prefix files containing additional arguments 
 * - `argumentDefault`  The default value for all arguments 
 * - `addHelp`  Add a -h/-help option 
 * - `conflictHandler`  Specifies how to handle conflicting argument names 
 * - `debug`  Enable debug mode. Argument errors throw exception in 
 *   debug mode and process.exit in normal. Used for development and 
 *   testing (default: false) 
 * 
 * See also [original guide][1] 
 * 
 * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects 
 **/</span>
<span class="s3">function </span><span class="s1">ArgumentParser(options) {</span>
  <span class="s3">if </span><span class="s1">(!(</span><span class="s3">this instanceof </span><span class="s1">ArgumentParser)) {</span>
    <span class="s3">return new </span><span class="s1">ArgumentParser(options);</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s1">options = options || {};</span>

  <span class="s1">options.description = (options.description || </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">options.argumentDefault = (options.argumentDefault || </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">options.prefixChars = (options.prefixChars || </span><span class="s2">'-'</span><span class="s1">);</span>
  <span class="s1">options.conflictHandler = (options.conflictHandler || </span><span class="s2">'error'</span><span class="s1">);</span>
  <span class="s1">ActionContainer.call(</span><span class="s3">this</span><span class="s1">, options);</span>

  <span class="s1">options.addHelp = </span><span class="s3">typeof </span><span class="s1">options.addHelp === </span><span class="s2">'undefined' </span><span class="s1">|| !!options.addHelp;</span>
  <span class="s1">options.parents = options.parents || [];</span>
  <span class="s0">// default program name</span>
  <span class="s1">options.prog = (options.prog || Path.basename(process.argv[</span><span class="s4">1</span><span class="s1">]));</span>
  <span class="s3">this</span><span class="s1">.prog = options.prog;</span>
  <span class="s3">this</span><span class="s1">.usage = options.usage;</span>
  <span class="s3">this</span><span class="s1">.epilog = options.epilog;</span>
  <span class="s3">this</span><span class="s1">.version = options.version;</span>

  <span class="s3">this</span><span class="s1">.debug = (options.debug === </span><span class="s3">true</span><span class="s1">);</span>

  <span class="s3">this</span><span class="s1">.formatterClass = (options.formatterClass || HelpFormatter);</span>
  <span class="s3">this</span><span class="s1">.fromfilePrefixChars = options.fromfilePrefixChars || </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">._positionals = </span><span class="s3">this</span><span class="s1">.addArgumentGroup({ title: </span><span class="s2">'Positional arguments' </span><span class="s1">});</span>
  <span class="s3">this</span><span class="s1">._optionals = </span><span class="s3">this</span><span class="s1">.addArgumentGroup({ title: </span><span class="s2">'Optional arguments' </span><span class="s1">});</span>
  <span class="s3">this</span><span class="s1">._subparsers = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s0">// register types</span>
  <span class="s3">function </span><span class="s1">FUNCTION_IDENTITY(o) {</span>
    <span class="s3">return </span><span class="s1">o;</span>
  <span class="s1">}</span>
  <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'auto'</span><span class="s1">, FUNCTION_IDENTITY);</span>
  <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, FUNCTION_IDENTITY);</span>
  <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'int'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">(x) {</span>
    <span class="s3">var </span><span class="s1">result = parseInt(x, </span><span class="s4">10</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(isNaN(result)) {</span>
      <span class="s3">throw new </span><span class="s1">Error(x + </span><span class="s2">' is not a valid integer.'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">result;</span>
  <span class="s1">});</span>
  <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'float'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">(x) {</span>
    <span class="s3">var </span><span class="s1">result = parseFloat(x);</span>
    <span class="s3">if </span><span class="s1">(isNaN(result)) {</span>
      <span class="s3">throw new </span><span class="s1">Error(x + </span><span class="s2">' is not a valid float.'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">result;</span>
  <span class="s1">});</span>
  <span class="s3">this</span><span class="s1">.register(</span><span class="s2">'type'</span><span class="s1">, </span><span class="s2">'string'</span><span class="s1">, </span><span class="s3">function </span><span class="s1">(x) {</span>
    <span class="s3">return </span><span class="s2">'' </span><span class="s1">+ x;</span>
  <span class="s1">});</span>

  <span class="s0">// add help and version arguments if necessary</span>
  <span class="s3">var </span><span class="s1">defaultPrefix = (</span><span class="s3">this</span><span class="s1">.prefixChars.indexOf(</span><span class="s2">'-'</span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">) ? </span><span class="s2">'-' </span><span class="s1">: </span><span class="s3">this</span><span class="s1">.prefixChars[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s3">if </span><span class="s1">(options.addHelp) {</span>
    <span class="s3">this</span><span class="s1">.addArgument(</span>
      <span class="s1">[ defaultPrefix + </span><span class="s2">'h'</span><span class="s1">, defaultPrefix + defaultPrefix + </span><span class="s2">'help' </span><span class="s1">],</span>
      <span class="s1">{</span>
        <span class="s1">action: </span><span class="s2">'help'</span><span class="s1">,</span>
        <span class="s1">defaultValue: c.SUPPRESS,</span>
        <span class="s1">help: </span><span class="s2">'Show this help message and exit.'</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof this</span><span class="s1">.version !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
    <span class="s3">this</span><span class="s1">.addArgument(</span>
      <span class="s1">[ defaultPrefix + </span><span class="s2">'v'</span><span class="s1">, defaultPrefix + defaultPrefix + </span><span class="s2">'version' </span><span class="s1">],</span>
      <span class="s1">{</span>
        <span class="s1">action: </span><span class="s2">'version'</span><span class="s1">,</span>
        <span class="s1">version: </span><span class="s3">this</span><span class="s1">.version,</span>
        <span class="s1">defaultValue: c.SUPPRESS,</span>
        <span class="s1">help: </span><span class="s2">&quot;Show program's version number and exit.&quot;</span>
      <span class="s1">}</span>
    <span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">// add parent arguments and defaults</span>
  <span class="s1">options.parents.forEach(</span><span class="s3">function </span><span class="s1">(parent) {</span>
    <span class="s1">self._addContainerActions(parent);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">parent._defaults !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">defaultKey </span><span class="s3">in </span><span class="s1">parent._defaults) {</span>
        <span class="s3">if </span><span class="s1">(parent._defaults.hasOwnProperty(defaultKey)) {</span>
          <span class="s1">self._defaults[defaultKey] = parent._defaults[defaultKey];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s1">util.inherits(ArgumentParser, ActionContainer);</span>

<span class="s0">/** 
 * ArgumentParser#addSubparsers(options) -&gt; [[ActionSubparsers]] 
 * - options (object): hash of options see [[ActionSubparsers.new]] 
 * 
 * See also [subcommands][1] 
 * 
 * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands 
 **/</span>
<span class="s1">ArgumentParser.prototype.addSubparsers = </span><span class="s3">function </span><span class="s1">(options) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._subparsers) {</span>
    <span class="s3">this</span><span class="s1">.error(</span><span class="s2">'Cannot have multiple subparser arguments.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">options = options || {};</span>
  <span class="s1">options.debug = (</span><span class="s3">this</span><span class="s1">.debug === </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">options.optionStrings = [];</span>
  <span class="s1">options.parserClass = (options.parserClass || ArgumentParser);</span>


  <span class="s3">if </span><span class="s1">(!!options.title || !!options.description) {</span>

    <span class="s3">this</span><span class="s1">._subparsers = </span><span class="s3">this</span><span class="s1">.addArgumentGroup({</span>
      <span class="s1">title: (options.title || </span><span class="s2">'subcommands'</span><span class="s1">),</span>
      <span class="s1">description: options.description</span>
    <span class="s1">});</span>
    <span class="s3">delete </span><span class="s1">options.title;</span>
    <span class="s3">delete </span><span class="s1">options.description;</span>

  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">._subparsers = </span><span class="s3">this</span><span class="s1">._positionals;</span>
  <span class="s1">}</span>

  <span class="s0">// prog defaults to the usage message of this parser, skipping</span>
  <span class="s0">// optional arguments and with no &quot;usage:&quot; prefix</span>
  <span class="s3">if </span><span class="s1">(!options.prog) {</span>
    <span class="s3">var </span><span class="s1">formatter = </span><span class="s3">this</span><span class="s1">._getFormatter();</span>
    <span class="s3">var </span><span class="s1">positionals = </span><span class="s3">this</span><span class="s1">._getPositionalActions();</span>
    <span class="s3">var </span><span class="s1">groups = </span><span class="s3">this</span><span class="s1">._mutuallyExclusiveGroups;</span>
    <span class="s1">formatter.addUsage(</span><span class="s3">this</span><span class="s1">.usage, positionals, groups, </span><span class="s2">''</span><span class="s1">);</span>
    <span class="s1">options.prog = formatter.formatHelp().trim();</span>
  <span class="s1">}</span>

  <span class="s0">// create the parsers action and add it to the positionals list</span>
  <span class="s3">var </span><span class="s1">ParsersClass = </span><span class="s3">this</span><span class="s1">._popActionClass(options, </span><span class="s2">'parsers'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">action = </span><span class="s3">new </span><span class="s1">ParsersClass(options);</span>
  <span class="s3">this</span><span class="s1">._subparsers._addAction(action);</span>

  <span class="s0">// return the created parsers action</span>
  <span class="s3">return </span><span class="s1">action;</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._addAction = </span><span class="s3">function </span><span class="s1">(action) {</span>
  <span class="s3">if </span><span class="s1">(action.isOptional()) {</span>
    <span class="s3">this</span><span class="s1">._optionals._addAction(action);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">this</span><span class="s1">._positionals._addAction(action);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">action;</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._getOptionalActions = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">return this</span><span class="s1">._actions.filter(</span><span class="s3">function </span><span class="s1">(action) {</span>
    <span class="s3">return </span><span class="s1">action.isOptional();</span>
  <span class="s1">});</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._getPositionalActions = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">return this</span><span class="s1">._actions.filter(</span><span class="s3">function </span><span class="s1">(action) {</span>
    <span class="s3">return </span><span class="s1">action.isPositional();</span>
  <span class="s1">});</span>
<span class="s1">};</span>


<span class="s0">/** 
 * ArgumentParser#parseArgs(args, namespace) -&gt; Namespace|Object 
 * - args (array): input elements 
 * - namespace (Namespace|Object): result object 
 * 
 * Parsed args and throws error if some arguments are not recognized 
 * 
 * See also [original guide][1] 
 * 
 * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method 
 **/</span>
<span class="s1">ArgumentParser.prototype.parseArgs = </span><span class="s3">function </span><span class="s1">(args, namespace) {</span>
  <span class="s3">var </span><span class="s1">argv;</span>
  <span class="s3">var </span><span class="s1">result = </span><span class="s3">this</span><span class="s1">.parseKnownArgs(args, namespace);</span>

  <span class="s1">args = result[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">argv = result[</span><span class="s4">1</span><span class="s1">];</span>
  <span class="s3">if </span><span class="s1">(argv &amp;&amp; argv.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">this</span><span class="s1">.error(</span>
      <span class="s1">format(</span><span class="s2">'Unrecognized arguments: %s.'</span><span class="s1">, argv.join(</span><span class="s2">' '</span><span class="s1">))</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">args;</span>
<span class="s1">};</span>

<span class="s0">/** 
 * ArgumentParser#parseKnownArgs(args, namespace) -&gt; array 
 * - args (array): input options 
 * - namespace (Namespace|Object): result object 
 * 
 * Parse known arguments and return tuple of result object 
 * and unknown args 
 * 
 * See also [original guide][1] 
 * 
 * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing 
 **/</span>
<span class="s1">ArgumentParser.prototype.parseKnownArgs = </span><span class="s3">function </span><span class="s1">(args, namespace) {</span>
  <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>

  <span class="s0">// args default to the system args</span>
  <span class="s1">args = args || process.argv.slice(</span><span class="s4">2</span><span class="s1">);</span>

  <span class="s0">// default Namespace built from parser defaults</span>
  <span class="s1">namespace = namespace || </span><span class="s3">new </span><span class="s1">Namespace();</span>

  <span class="s1">self._actions.forEach(</span><span class="s3">function </span><span class="s1">(action) {</span>
    <span class="s3">if </span><span class="s1">(action.dest !== c.SUPPRESS) {</span>
      <span class="s3">if </span><span class="s1">(!$$.has(namespace, action.dest)) {</span>
        <span class="s3">if </span><span class="s1">(action.defaultValue !== c.SUPPRESS) {</span>
          <span class="s3">var </span><span class="s1">defaultValue = action.defaultValue;</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">action.defaultValue === </span><span class="s2">'string'</span><span class="s1">) {</span>
            <span class="s1">defaultValue = self._getValue(action, defaultValue);</span>
          <span class="s1">}</span>
          <span class="s1">namespace[action.dest] = defaultValue;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s1">Object.keys(self._defaults).forEach(</span><span class="s3">function </span><span class="s1">(dest) {</span>
    <span class="s1">namespace[dest] = self._defaults[dest];</span>
  <span class="s1">});</span>

  <span class="s0">// parse the arguments and exit if there are any errors</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s3">var </span><span class="s1">res = </span><span class="s3">this</span><span class="s1">._parseKnownArgs(args, namespace);</span>

    <span class="s1">namespace = res[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">args = res[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s3">if </span><span class="s1">($$.has(namespace, c._UNRECOGNIZED_ARGS_ATTR)) {</span>
      <span class="s1">args = $$.arrayUnion(args, namespace[c._UNRECOGNIZED_ARGS_ATTR]);</span>
      <span class="s3">delete </span><span class="s1">namespace[c._UNRECOGNIZED_ARGS_ATTR];</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">[ namespace, args ];</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
    <span class="s3">this</span><span class="s1">.error(e);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._parseKnownArgs = </span><span class="s3">function </span><span class="s1">(argStrings, namespace) {</span>
  <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">extras = [];</span>

  <span class="s0">// replace arg strings that are file references</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.fromfilePrefixChars !== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s1">argStrings = </span><span class="s3">this</span><span class="s1">._readArgsFromFiles(argStrings);</span>
  <span class="s1">}</span>
  <span class="s0">// map all mutually exclusive arguments to the other arguments</span>
  <span class="s0">// they can't occur with</span>
  <span class="s0">// Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'</span>
  <span class="s0">// though I can't conceive of a way in which an action could be a member</span>
  <span class="s0">// of two different mutually exclusive groups.</span>

  <span class="s3">function </span><span class="s1">actionHash(action) {</span>
    <span class="s0">// some sort of hashable key for this action</span>
    <span class="s0">// action itself cannot be a key in actionConflicts</span>
    <span class="s0">// I think getName() (join of optionStrings) is unique enough</span>
    <span class="s3">return </span><span class="s1">action.getName();</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">conflicts, key;</span>
  <span class="s3">var </span><span class="s1">actionConflicts = {};</span>

  <span class="s3">this</span><span class="s1">._mutuallyExclusiveGroups.forEach(</span><span class="s3">function </span><span class="s1">(mutexGroup) {</span>
    <span class="s1">mutexGroup._groupActions.forEach(</span><span class="s3">function </span><span class="s1">(mutexAction, i, groupActions) {</span>
      <span class="s1">key = actionHash(mutexAction);</span>
      <span class="s3">if </span><span class="s1">(!$$.has(actionConflicts, key)) {</span>
        <span class="s1">actionConflicts[key] = [];</span>
      <span class="s1">}</span>
      <span class="s1">conflicts = actionConflicts[key];</span>
      <span class="s1">conflicts.push.apply(conflicts, groupActions.slice(</span><span class="s4">0</span><span class="s1">, i));</span>
      <span class="s1">conflicts.push.apply(conflicts, groupActions.slice(i + </span><span class="s4">1</span><span class="s1">));</span>
    <span class="s1">});</span>
  <span class="s1">});</span>

  <span class="s0">// find all option indices, and determine the arg_string_pattern</span>
  <span class="s0">// which has an 'O' if there is an option at an index,</span>
  <span class="s0">// an 'A' if there is an argument, or a '-' if there is a '--'</span>
  <span class="s3">var </span><span class="s1">optionStringIndices = {};</span>

  <span class="s3">var </span><span class="s1">argStringPatternParts = [];</span>

  <span class="s1">argStrings.forEach(</span><span class="s3">function </span><span class="s1">(argString, argStringIndex) {</span>
    <span class="s3">if </span><span class="s1">(argString === </span><span class="s2">'--'</span><span class="s1">) {</span>
      <span class="s1">argStringPatternParts.push(</span><span class="s2">'-'</span><span class="s1">);</span>
      <span class="s3">while </span><span class="s1">(argStringIndex &lt; argStrings.length) {</span>
        <span class="s1">argStringPatternParts.push(</span><span class="s2">'A'</span><span class="s1">);</span>
        <span class="s1">argStringIndex++;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// otherwise, add the arg to the arg strings</span>
      <span class="s0">// and note the index if it was an option</span>
      <span class="s3">var </span><span class="s1">pattern;</span>
      <span class="s3">var </span><span class="s1">optionTuple = self._parseOptional(argString);</span>
      <span class="s3">if </span><span class="s1">(!optionTuple) {</span>
        <span class="s1">pattern = </span><span class="s2">'A'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">optionStringIndices[argStringIndex] = optionTuple;</span>
        <span class="s1">pattern = </span><span class="s2">'O'</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">argStringPatternParts.push(pattern);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s3">var </span><span class="s1">argStringsPattern = argStringPatternParts.join(</span><span class="s2">''</span><span class="s1">);</span>

  <span class="s3">var </span><span class="s1">seenActions = [];</span>
  <span class="s3">var </span><span class="s1">seenNonDefaultActions = [];</span>


  <span class="s3">function </span><span class="s1">takeAction(action, argumentStrings, optionString) {</span>
    <span class="s1">seenActions.push(action);</span>
    <span class="s3">var </span><span class="s1">argumentValues = self._getValues(action, argumentStrings);</span>

    <span class="s0">// error if this argument is not allowed with other previously</span>
    <span class="s0">// seen arguments, assuming that actions that use the default</span>
    <span class="s0">// value don't really count as &quot;present&quot;</span>
    <span class="s3">if </span><span class="s1">(argumentValues !== action.defaultValue) {</span>
      <span class="s1">seenNonDefaultActions.push(action);</span>
      <span class="s3">if </span><span class="s1">(actionConflicts[actionHash(action)]) {</span>
        <span class="s1">actionConflicts[actionHash(action)].forEach(</span><span class="s3">function </span><span class="s1">(actionConflict) {</span>
          <span class="s3">if </span><span class="s1">(seenNonDefaultActions.indexOf(actionConflict) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">throw </span><span class="s1">argumentErrorHelper(</span>
              <span class="s1">action,</span>
              <span class="s1">format(</span><span class="s2">'Not allowed with argument &quot;%s&quot;.'</span><span class="s1">, actionConflict.getName())</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(argumentValues !== c.SUPPRESS) {</span>
      <span class="s1">action.call(self, namespace, argumentValues, optionString);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">consumeOptional(startIndex) {</span>
    <span class="s0">// get the optional identified at this index</span>
    <span class="s3">var </span><span class="s1">optionTuple = optionStringIndices[startIndex];</span>
    <span class="s3">var </span><span class="s1">action = optionTuple[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s3">var </span><span class="s1">optionString = optionTuple[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s3">var </span><span class="s1">explicitArg = optionTuple[</span><span class="s4">2</span><span class="s1">];</span>

    <span class="s0">// identify additional optionals in the same arg string</span>
    <span class="s0">// (e.g. -xyz is the same as -x -y -z if no args are required)</span>
    <span class="s3">var </span><span class="s1">actionTuples = [];</span>

    <span class="s3">var </span><span class="s1">args, argCount, start, stop;</span>

    <span class="s3">for </span><span class="s1">(;;) {</span>
      <span class="s3">if </span><span class="s1">(!action) {</span>
        <span class="s1">extras.push(argStrings[startIndex]);</span>
        <span class="s3">return </span><span class="s1">startIndex + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(explicitArg) {</span>
        <span class="s1">argCount = self._matchArgument(action, </span><span class="s2">'A'</span><span class="s1">);</span>

        <span class="s0">// if the action is a single-dash option and takes no</span>
        <span class="s0">// arguments, try to parse more single-dash options out</span>
        <span class="s0">// of the tail of the option string</span>
        <span class="s3">var </span><span class="s1">chars = self.prefixChars;</span>
        <span class="s3">if </span><span class="s1">(argCount === </span><span class="s4">0 </span><span class="s1">&amp;&amp; chars.indexOf(optionString[</span><span class="s4">1</span><span class="s1">]) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">actionTuples.push([ action, [], optionString ]);</span>
          <span class="s1">optionString = optionString[</span><span class="s4">0</span><span class="s1">] + explicitArg[</span><span class="s4">0</span><span class="s1">];</span>
          <span class="s3">var </span><span class="s1">newExplicitArg = explicitArg.slice(</span><span class="s4">1</span><span class="s1">) || </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">optionalsMap = self._optionStringActions;</span>

          <span class="s3">if </span><span class="s1">(Object.keys(optionalsMap).indexOf(optionString) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">action = optionalsMap[optionString];</span>
            <span class="s1">explicitArg = newExplicitArg;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">argumentErrorHelper(action, sprintf(</span><span class="s2">'ignored explicit argument %r'</span><span class="s1">, explicitArg));</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(argCount === </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s0">// if the action expect exactly one argument, we've</span>
          <span class="s0">// successfully matched the option; exit the loop</span>
          <span class="s1">stop = startIndex + </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s1">args = [ explicitArg ];</span>
          <span class="s1">actionTuples.push([ action, args, optionString ]);</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// error if a double-dash option did not use the</span>
          <span class="s0">// explicit argument</span>
          <span class="s3">throw </span><span class="s1">argumentErrorHelper(action, sprintf(</span><span class="s2">'ignored explicit argument %r'</span><span class="s1">, explicitArg));</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// if there is no explicit argument, try to match the</span>
        <span class="s0">// optional's string arguments with the following strings</span>
        <span class="s0">// if successful, exit the loop</span>

        <span class="s1">start = startIndex + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">selectedPatterns = argStringsPattern.substr(start);</span>

        <span class="s1">argCount = self._matchArgument(action, selectedPatterns);</span>
        <span class="s1">stop = start + argCount;</span>


        <span class="s1">args = argStrings.slice(start, stop);</span>

        <span class="s1">actionTuples.push([ action, args, optionString ]);</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

    <span class="s1">}</span>

    <span class="s0">// add the Optional to the list and return the index at which</span>
    <span class="s0">// the Optional's string args stopped</span>
    <span class="s3">if </span><span class="s1">(actionTuples.length &lt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'length should be &gt; 0'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; actionTuples.length; i++) {</span>
      <span class="s1">takeAction.apply(self, actionTuples[i]);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">stop;</span>
  <span class="s1">}</span>

  <span class="s0">// the list of Positionals left to be parsed; this is modified</span>
  <span class="s0">// by consume_positionals()</span>
  <span class="s3">var </span><span class="s1">positionals = self._getPositionalActions();</span>

  <span class="s3">function </span><span class="s1">consumePositionals(startIndex) {</span>
    <span class="s0">// match as many Positionals as possible</span>
    <span class="s3">var </span><span class="s1">selectedPattern = argStringsPattern.substr(startIndex);</span>
    <span class="s3">var </span><span class="s1">argCounts = self._matchArgumentsPartial(positionals, selectedPattern);</span>

    <span class="s0">// slice off the appropriate arg strings for each Positional</span>
    <span class="s0">// and add the Positional and its args to the list</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; positionals.length; i++) {</span>
      <span class="s3">var </span><span class="s1">action = positionals[i];</span>
      <span class="s3">var </span><span class="s1">argCount = argCounts[i];</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">argCount === </span><span class="s2">'undefined'</span><span class="s1">) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">var </span><span class="s1">args = argStrings.slice(startIndex, startIndex + argCount);</span>

      <span class="s1">startIndex += argCount;</span>
      <span class="s1">takeAction(action, args);</span>
    <span class="s1">}</span>

    <span class="s0">// slice off the Positionals that we just parsed and return the</span>
    <span class="s0">// index at which the Positionals' string args stopped</span>
    <span class="s1">positionals = positionals.slice(argCounts.length);</span>
    <span class="s3">return </span><span class="s1">startIndex;</span>
  <span class="s1">}</span>

  <span class="s0">// consume Positionals and Optionals alternately, until we have</span>
  <span class="s0">// passed the last option string</span>
  <span class="s3">var </span><span class="s1">startIndex = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">position;</span>

  <span class="s3">var </span><span class="s1">maxOptionStringIndex = -</span><span class="s4">1</span><span class="s1">;</span>

  <span class="s1">Object.keys(optionStringIndices).forEach(</span><span class="s3">function </span><span class="s1">(position) {</span>
    <span class="s1">maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, </span><span class="s4">10</span><span class="s1">));</span>
  <span class="s1">});</span>

  <span class="s3">var </span><span class="s1">positionalsEndIndex, nextOptionStringIndex;</span>

  <span class="s3">while </span><span class="s1">(startIndex &lt;= maxOptionStringIndex) {</span>
    <span class="s0">// consume any Positionals preceding the next option</span>
    <span class="s1">nextOptionStringIndex = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(position </span><span class="s3">in </span><span class="s1">optionStringIndices) {</span>
      <span class="s3">if </span><span class="s1">(!optionStringIndices.hasOwnProperty(position)) { </span><span class="s3">continue</span><span class="s1">; }</span>

      <span class="s1">position = parseInt(position, </span><span class="s4">10</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(position &gt;= startIndex) {</span>
        <span class="s3">if </span><span class="s1">(nextOptionStringIndex !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">nextOptionStringIndex = Math.min(nextOptionStringIndex, position);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">nextOptionStringIndex = position;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(startIndex !== nextOptionStringIndex) {</span>
      <span class="s1">positionalsEndIndex = consumePositionals(startIndex);</span>
      <span class="s0">// only try to parse the next optional if we didn't consume</span>
      <span class="s0">// the option string during the positionals parsing</span>
      <span class="s3">if </span><span class="s1">(positionalsEndIndex &gt; startIndex) {</span>
        <span class="s1">startIndex = positionalsEndIndex;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">startIndex = positionalsEndIndex;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// if we consumed all the positionals we could and we're not</span>
    <span class="s0">// at the index of an option string, there were extra arguments</span>
    <span class="s3">if </span><span class="s1">(!optionStringIndices[startIndex]) {</span>
      <span class="s3">var </span><span class="s1">strings = argStrings.slice(startIndex, nextOptionStringIndex);</span>
      <span class="s1">extras = extras.concat(strings);</span>
      <span class="s1">startIndex = nextOptionStringIndex;</span>
    <span class="s1">}</span>
    <span class="s0">// consume the next optional and any arguments for it</span>
    <span class="s1">startIndex = consumeOptional(startIndex);</span>
  <span class="s1">}</span>

  <span class="s0">// consume any positionals following the last Optional</span>
  <span class="s3">var </span><span class="s1">stopIndex = consumePositionals(startIndex);</span>

  <span class="s0">// if we didn't consume all the argument strings, there were extras</span>
  <span class="s1">extras = extras.concat(argStrings.slice(stopIndex));</span>

  <span class="s0">// if we didn't use all the Positional objects, there were too few</span>
  <span class="s0">// arg strings supplied.</span>
  <span class="s3">if </span><span class="s1">(positionals.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">self.error(</span><span class="s2">'too few arguments'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">// make sure all required actions were present</span>
  <span class="s1">self._actions.forEach(</span><span class="s3">function </span><span class="s1">(action) {</span>
    <span class="s3">if </span><span class="s1">(action.required) {</span>
      <span class="s3">if </span><span class="s1">(seenActions.indexOf(action) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">self.error(format(</span><span class="s2">'Argument &quot;%s&quot; is required'</span><span class="s1">, action.getName()));</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">// make sure all required groups have one option present</span>
  <span class="s3">var </span><span class="s1">actionUsed = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">self._mutuallyExclusiveGroups.forEach(</span><span class="s3">function </span><span class="s1">(group) {</span>
    <span class="s3">if </span><span class="s1">(group.required) {</span>
      <span class="s1">actionUsed = group._groupActions.some(</span><span class="s3">function </span><span class="s1">(action) {</span>
        <span class="s3">return </span><span class="s1">seenNonDefaultActions.indexOf(action) !== -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">});</span>

      <span class="s0">// if no actions were used, report the error</span>
      <span class="s3">if </span><span class="s1">(!actionUsed) {</span>
        <span class="s3">var </span><span class="s1">names = [];</span>
        <span class="s1">group._groupActions.forEach(</span><span class="s3">function </span><span class="s1">(action) {</span>
          <span class="s3">if </span><span class="s1">(action.help !== c.SUPPRESS) {</span>
            <span class="s1">names.push(action.getName());</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">names = names.join(</span><span class="s2">' '</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">msg = </span><span class="s2">'one of the arguments ' </span><span class="s1">+ names + </span><span class="s2">' is required'</span><span class="s1">;</span>
        <span class="s1">self.error(msg);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">// return the updated namespace and the extra arguments</span>
  <span class="s3">return </span><span class="s1">[ namespace, extras ];</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._readArgsFromFiles = </span><span class="s3">function </span><span class="s1">(argStrings) {</span>
  <span class="s0">// expand arguments referencing files</span>
  <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">fs = require(</span><span class="s2">'fs'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">newArgStrings = [];</span>
  <span class="s1">argStrings.forEach(</span><span class="s3">function </span><span class="s1">(argString) {</span>
    <span class="s3">if </span><span class="s1">(self.fromfilePrefixChars.indexOf(argString[</span><span class="s4">0</span><span class="s1">]) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">// for regular arguments, just add them back into the list</span>
      <span class="s1">newArgStrings.push(argString);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// replace arguments referencing files with the file content</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">argstrs = [];</span>
        <span class="s3">var </span><span class="s1">filename = argString.slice(</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">content = fs.readFileSync(filename, </span><span class="s2">'utf8'</span><span class="s1">);</span>
        <span class="s1">content = content.trim().split(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">);</span>
        <span class="s1">content.forEach(</span><span class="s3">function </span><span class="s1">(argLine) {</span>
          <span class="s1">self.convertArgLineToArgs(argLine).forEach(</span><span class="s3">function </span><span class="s1">(arg) {</span>
            <span class="s1">argstrs.push(arg);</span>
          <span class="s1">});</span>
          <span class="s1">argstrs = self._readArgsFromFiles(argstrs);</span>
        <span class="s1">});</span>
        <span class="s1">newArgStrings.push.apply(newArgStrings, argstrs);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s3">return </span><span class="s1">self.error(error.message);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">});</span>
  <span class="s3">return </span><span class="s1">newArgStrings;</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype.convertArgLineToArgs = </span><span class="s3">function </span><span class="s1">(argLine) {</span>
  <span class="s3">return </span><span class="s1">[ argLine ];</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._matchArgument = </span><span class="s3">function </span><span class="s1">(action, regexpArgStrings) {</span>

  <span class="s0">// match the pattern for this action to the arg strings</span>
  <span class="s3">var </span><span class="s1">regexpNargs = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^' </span><span class="s1">+ </span><span class="s3">this</span><span class="s1">._getNargsPattern(action));</span>
  <span class="s3">var </span><span class="s1">matches = regexpArgStrings.match(regexpNargs);</span>
  <span class="s3">var </span><span class="s1">message;</span>

  <span class="s0">// throw an exception if we weren't able to find a match</span>
  <span class="s3">if </span><span class="s1">(!matches) {</span>
    <span class="s3">switch </span><span class="s1">(action.nargs) {</span>
      <span class="s0">/*eslint-disable no-undefined*/</span>
      <span class="s3">case </span><span class="s1">undefined:</span>
      <span class="s3">case null</span><span class="s1">:</span>
        <span class="s1">message = </span><span class="s2">'Expected one argument.'</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s1">c.OPTIONAL:</span>
        <span class="s1">message = </span><span class="s2">'Expected at most one argument.'</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s3">case </span><span class="s1">c.ONE_OR_MORE:</span>
        <span class="s1">message = </span><span class="s2">'Expected at least one argument.'</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">message = </span><span class="s2">'Expected %s argument(s)'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">throw </span><span class="s1">argumentErrorHelper(</span>
      <span class="s1">action,</span>
      <span class="s1">format(message, action.nargs)</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">// return the number of arguments matched</span>
  <span class="s3">return </span><span class="s1">matches[</span><span class="s4">1</span><span class="s1">].length;</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._matchArgumentsPartial = </span><span class="s3">function </span><span class="s1">(actions, regexpArgStrings) {</span>
  <span class="s0">// progressively shorten the actions list by slicing off the</span>
  <span class="s0">// final actions until we find a match</span>
  <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">result = [];</span>
  <span class="s3">var </span><span class="s1">actionSlice, pattern, matches;</span>
  <span class="s3">var </span><span class="s1">i, j;</span>

  <span class="s3">function </span><span class="s1">getLength(string) {</span>
    <span class="s3">return </span><span class="s1">string.length;</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(i = actions.length; i &gt; </span><span class="s4">0</span><span class="s1">; i--) {</span>
    <span class="s1">pattern = </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s1">actionSlice = actions.slice(</span><span class="s4">0</span><span class="s1">, i);</span>
    <span class="s3">for </span><span class="s1">(j = </span><span class="s4">0</span><span class="s1">; j &lt; actionSlice.length; j++) {</span>
      <span class="s1">pattern += self._getNargsPattern(actionSlice[j]);</span>
    <span class="s1">}</span>

    <span class="s1">pattern = </span><span class="s3">new </span><span class="s1">RegExp(</span><span class="s2">'^' </span><span class="s1">+ pattern);</span>
    <span class="s1">matches = regexpArgStrings.match(pattern);</span>

    <span class="s3">if </span><span class="s1">(matches &amp;&amp; matches.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">// need only groups</span>
      <span class="s1">matches = matches.splice(</span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">result = result.concat(matches.map(getLength));</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// return the list of arg string counts</span>
  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._parseOptional = </span><span class="s3">function </span><span class="s1">(argString) {</span>
  <span class="s3">var </span><span class="s1">action, optionString, argExplicit, optionTuples;</span>

  <span class="s0">// if it's an empty string, it was meant to be a positional</span>
  <span class="s3">if </span><span class="s1">(!argString) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// if it doesn't start with a prefix, it was meant to be positional</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.prefixChars.indexOf(argString[</span><span class="s4">0</span><span class="s1">]) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// if the option string is present in the parser, return the action</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._optionStringActions[argString]) {</span>
    <span class="s3">return </span><span class="s1">[ </span><span class="s3">this</span><span class="s1">._optionStringActions[argString], argString, </span><span class="s3">null </span><span class="s1">];</span>
  <span class="s1">}</span>

  <span class="s0">// if it's just a single character, it was meant to be positional</span>
  <span class="s3">if </span><span class="s1">(argString.length === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// if the option string before the &quot;=&quot; is present, return the action</span>
  <span class="s3">if </span><span class="s1">(argString.indexOf(</span><span class="s2">'='</span><span class="s1">) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">optionString = argString.split(</span><span class="s2">'='</span><span class="s1">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">argExplicit = argString.slice(optionString.length + </span><span class="s4">1</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._optionStringActions[optionString]) {</span>
      <span class="s1">action = </span><span class="s3">this</span><span class="s1">._optionStringActions[optionString];</span>
      <span class="s3">return </span><span class="s1">[ action, optionString, argExplicit ];</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// search through all possible prefixes of the option string</span>
  <span class="s0">// and all actions in the parser for possible interpretations</span>
  <span class="s1">optionTuples = </span><span class="s3">this</span><span class="s1">._getOptionTuples(argString);</span>

  <span class="s0">// if multiple actions match, the option string was ambiguous</span>
  <span class="s3">if </span><span class="s1">(optionTuples.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">optionStrings = optionTuples.map(</span><span class="s3">function </span><span class="s1">(optionTuple) {</span>
      <span class="s3">return </span><span class="s1">optionTuple[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">});</span>
    <span class="s3">this</span><span class="s1">.error(format(</span>
          <span class="s2">'Ambiguous option: &quot;%s&quot; could match %s.'</span><span class="s1">,</span>
          <span class="s1">argString, optionStrings.join(</span><span class="s2">', '</span><span class="s1">)</span>
    <span class="s1">));</span>
  <span class="s0">// if exactly one action matched, this segmentation is good,</span>
  <span class="s0">// so return the parsed action</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(optionTuples.length === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">optionTuples[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">}</span>

  <span class="s0">// if it was not found as an option, but it looks like a negative</span>
  <span class="s0">// number, it was meant to be positional</span>
  <span class="s0">// unless there are negative-number-like options</span>
  <span class="s3">if </span><span class="s1">(argString.match(</span><span class="s3">this</span><span class="s1">._regexpNegativeNumber)) {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">._hasNegativeNumberOptionals.some(Boolean)) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">// if it contains a space, it was meant to be a positional</span>
  <span class="s3">if </span><span class="s1">(argString.search(</span><span class="s2">' '</span><span class="s1">) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// it was meant to be an optional but there is no such option</span>
  <span class="s0">// in this parser (though it might be a valid option in a subparser)</span>
  <span class="s3">return </span><span class="s1">[ </span><span class="s3">null</span><span class="s1">, argString, </span><span class="s3">null </span><span class="s1">];</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._getOptionTuples = </span><span class="s3">function </span><span class="s1">(optionString) {</span>
  <span class="s3">var </span><span class="s1">result = [];</span>
  <span class="s3">var </span><span class="s1">chars = </span><span class="s3">this</span><span class="s1">.prefixChars;</span>
  <span class="s3">var </span><span class="s1">optionPrefix;</span>
  <span class="s3">var </span><span class="s1">argExplicit;</span>
  <span class="s3">var </span><span class="s1">action;</span>
  <span class="s3">var </span><span class="s1">actionOptionString;</span>

  <span class="s0">// option strings starting with two prefix characters are only split at</span>
  <span class="s0">// the '='</span>
  <span class="s3">if </span><span class="s1">(chars.indexOf(optionString[</span><span class="s4">0</span><span class="s1">]) &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; chars.indexOf(optionString[</span><span class="s4">1</span><span class="s1">]) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(optionString.indexOf(</span><span class="s2">'='</span><span class="s1">) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">optionStringSplit = optionString.split(</span><span class="s2">'='</span><span class="s1">, </span><span class="s4">1</span><span class="s1">);</span>

      <span class="s1">optionPrefix = optionStringSplit[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s1">argExplicit = optionStringSplit[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">optionPrefix = optionString;</span>
      <span class="s1">argExplicit = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(actionOptionString </span><span class="s3">in this</span><span class="s1">._optionStringActions) {</span>
      <span class="s3">if </span><span class="s1">(actionOptionString.substr(</span><span class="s4">0</span><span class="s1">, optionPrefix.length) === optionPrefix) {</span>
        <span class="s1">action = </span><span class="s3">this</span><span class="s1">._optionStringActions[actionOptionString];</span>
        <span class="s1">result.push([ action, actionOptionString, argExplicit ]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

  <span class="s0">// single character options can be concatenated with their arguments</span>
  <span class="s0">// but multiple character options always have to have their argument</span>
  <span class="s0">// separate</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(chars.indexOf(optionString[</span><span class="s4">0</span><span class="s1">]) &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; chars.indexOf(optionString[</span><span class="s4">1</span><span class="s1">]) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">optionPrefix = optionString;</span>
    <span class="s1">argExplicit = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">optionPrefixShort = optionString.substr(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">argExplicitShort = optionString.substr(</span><span class="s4">2</span><span class="s1">);</span>

    <span class="s3">for </span><span class="s1">(actionOptionString </span><span class="s3">in this</span><span class="s1">._optionStringActions) {</span>
      <span class="s3">if </span><span class="s1">(!$$.has(</span><span class="s3">this</span><span class="s1">._optionStringActions, actionOptionString)) </span><span class="s3">continue</span><span class="s1">;</span>

      <span class="s1">action = </span><span class="s3">this</span><span class="s1">._optionStringActions[actionOptionString];</span>
      <span class="s3">if </span><span class="s1">(actionOptionString === optionPrefixShort) {</span>
        <span class="s1">result.push([ action, actionOptionString, argExplicitShort ]);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(actionOptionString.substr(</span><span class="s4">0</span><span class="s1">, optionPrefix.length) === optionPrefix) {</span>
        <span class="s1">result.push([ action, actionOptionString, argExplicit ]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

  <span class="s0">// shouldn't ever get here</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">throw new </span><span class="s1">Error(format(</span><span class="s2">'Unexpected option string: %s.'</span><span class="s1">, optionString));</span>
  <span class="s1">}</span>
  <span class="s0">// return the collected option tuples</span>
  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._getNargsPattern = </span><span class="s3">function </span><span class="s1">(action) {</span>
  <span class="s0">// in all examples below, we have to allow for '--' args</span>
  <span class="s0">// which are represented as '-' in the pattern</span>
  <span class="s3">var </span><span class="s1">regexpNargs;</span>

  <span class="s3">switch </span><span class="s1">(action.nargs) {</span>
    <span class="s0">// the default (null) is assumed to be a single argument</span>
    <span class="s3">case </span><span class="s1">undefined:</span>
    <span class="s3">case null</span><span class="s1">:</span>
      <span class="s1">regexpNargs = </span><span class="s2">'(-*A-*)'</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s0">// allow zero or more arguments</span>
    <span class="s3">case </span><span class="s1">c.OPTIONAL:</span>
      <span class="s1">regexpNargs = </span><span class="s2">'(-*A?-*)'</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s0">// allow zero or more arguments</span>
    <span class="s3">case </span><span class="s1">c.ZERO_OR_MORE:</span>
      <span class="s1">regexpNargs = </span><span class="s2">'(-*[A-]*)'</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s0">// allow one or more arguments</span>
    <span class="s3">case </span><span class="s1">c.ONE_OR_MORE:</span>
      <span class="s1">regexpNargs = </span><span class="s2">'(-*A[A-]*)'</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s0">// allow any number of options or arguments</span>
    <span class="s3">case </span><span class="s1">c.REMAINDER:</span>
      <span class="s1">regexpNargs = </span><span class="s2">'([-AO]*)'</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s0">// allow one argument followed by any number of options or arguments</span>
    <span class="s3">case </span><span class="s1">c.PARSER:</span>
      <span class="s1">regexpNargs = </span><span class="s2">'(-*A[-AO]*)'</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s0">// all others should be integers</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s1">regexpNargs = </span><span class="s2">'(-*' </span><span class="s1">+ $$.repeat(</span><span class="s2">'-*A'</span><span class="s1">, action.nargs) + </span><span class="s2">'-*)'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// if this is an optional action, -- is not allowed</span>
  <span class="s3">if </span><span class="s1">(action.isOptional()) {</span>
    <span class="s1">regexpNargs = regexpNargs.replace(/-\*/g, </span><span class="s2">''</span><span class="s1">);</span>
    <span class="s1">regexpNargs = regexpNargs.replace(/-/g, </span><span class="s2">''</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">// return the pattern</span>
  <span class="s3">return </span><span class="s1">regexpNargs;</span>
<span class="s1">};</span>

<span class="s0">//</span>
<span class="s0">// Value conversion methods</span>
<span class="s0">//</span>

<span class="s1">ArgumentParser.prototype._getValues = </span><span class="s3">function </span><span class="s1">(action, argStrings) {</span>
  <span class="s3">var </span><span class="s1">self = </span><span class="s3">this</span><span class="s1">;</span>

  <span class="s0">// for everything but PARSER args, strip out '--'</span>
  <span class="s3">if </span><span class="s1">(action.nargs !== c.PARSER &amp;&amp; action.nargs !== c.REMAINDER) {</span>
    <span class="s1">argStrings = argStrings.filter(</span><span class="s3">function </span><span class="s1">(arrayElement) {</span>
      <span class="s3">return </span><span class="s1">arrayElement !== </span><span class="s2">'--'</span><span class="s1">;</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">value, argString;</span>

  <span class="s0">// optional argument produces a default when not present</span>
  <span class="s3">if </span><span class="s1">(argStrings.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; action.nargs === c.OPTIONAL) {</span>

    <span class="s1">value = (action.isOptional()) ? action.constant : action.defaultValue;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">(value) === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s1">value = </span><span class="s3">this</span><span class="s1">._getValue(action, value);</span>
      <span class="s3">this</span><span class="s1">._checkValue(action, value);</span>
    <span class="s1">}</span>

  <span class="s0">// when nargs='*' on a positional, if there were no command-line</span>
  <span class="s0">// args, use the default if it is anything other than None</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(argStrings.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; action.nargs === c.ZERO_OR_MORE &amp;&amp;</span>
    <span class="s1">action.optionStrings.length === </span><span class="s4">0</span><span class="s1">) {</span>

    <span class="s1">value = (action.defaultValue || argStrings);</span>
    <span class="s3">this</span><span class="s1">._checkValue(action, value);</span>

  <span class="s0">// single argument or optional argument produces a single value</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(argStrings.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(!action.nargs || action.nargs === c.OPTIONAL)) {</span>

    <span class="s1">argString = argStrings[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">value = </span><span class="s3">this</span><span class="s1">._getValue(action, argString);</span>
    <span class="s3">this</span><span class="s1">._checkValue(action, value);</span>

  <span class="s0">// REMAINDER arguments convert all values, checking none</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === c.REMAINDER) {</span>
    <span class="s1">value = argStrings.map(</span><span class="s3">function </span><span class="s1">(v) {</span>
      <span class="s3">return </span><span class="s1">self._getValue(action, v);</span>
    <span class="s1">});</span>

  <span class="s0">// PARSER arguments convert all values, but check only the first</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(action.nargs === c.PARSER) {</span>
    <span class="s1">value = argStrings.map(</span><span class="s3">function </span><span class="s1">(v) {</span>
      <span class="s3">return </span><span class="s1">self._getValue(action, v);</span>
    <span class="s1">});</span>
    <span class="s3">this</span><span class="s1">._checkValue(action, value[</span><span class="s4">0</span><span class="s1">]);</span>

  <span class="s0">// all other types of nargs produce a list</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">value = argStrings.map(</span><span class="s3">function </span><span class="s1">(v) {</span>
      <span class="s3">return </span><span class="s1">self._getValue(action, v);</span>
    <span class="s1">});</span>
    <span class="s1">value.forEach(</span><span class="s3">function </span><span class="s1">(v) {</span>
      <span class="s1">self._checkValue(action, v);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">// return the converted value</span>
  <span class="s3">return </span><span class="s1">value;</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._getValue = </span><span class="s3">function </span><span class="s1">(action, argString) {</span>
  <span class="s3">var </span><span class="s1">result;</span>

  <span class="s3">var </span><span class="s1">typeFunction = </span><span class="s3">this</span><span class="s1">._registryGet(</span><span class="s2">'type'</span><span class="s1">, action.type, action.type);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">typeFunction !== </span><span class="s2">'function'</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">message = format(</span><span class="s2">'%s is not callable'</span><span class="s1">, typeFunction);</span>
    <span class="s3">throw </span><span class="s1">argumentErrorHelper(action, message);</span>
  <span class="s1">}</span>

  <span class="s0">// convert the value to the appropriate type</span>
  <span class="s3">try </span><span class="s1">{</span>
    <span class="s1">result = typeFunction(argString);</span>

    <span class="s0">// ArgumentTypeErrors indicate errors</span>
    <span class="s0">// If action.type is not a registered string, it is a function</span>
    <span class="s0">// Try to deduce its name for inclusion in the error message</span>
    <span class="s0">// Failing that, include the error message it raised.</span>
  <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
    <span class="s3">var </span><span class="s1">name = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">action.type === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s1">name = action.type;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">name = action.type.name || action.type.displayName || </span><span class="s2">'&lt;function&gt;'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">msg = format(</span><span class="s2">'Invalid %s value: %s'</span><span class="s1">, name, argString);</span>
    <span class="s3">if </span><span class="s1">(name === </span><span class="s2">'&lt;function&gt;'</span><span class="s1">) { msg += </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ e.message; }</span>
    <span class="s3">throw </span><span class="s1">argumentErrorHelper(action, msg);</span>
  <span class="s1">}</span>
  <span class="s0">// return the converted value</span>
  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._checkValue = </span><span class="s3">function </span><span class="s1">(action, value) {</span>
  <span class="s0">// converted value must be one of the choices (if specified)</span>
  <span class="s3">var </span><span class="s1">choices = action.choices;</span>
  <span class="s3">if </span><span class="s1">(choices) {</span>
    <span class="s0">// choise for argument can by array or string</span>
    <span class="s3">if </span><span class="s1">((</span><span class="s3">typeof </span><span class="s1">choices === </span><span class="s2">'string' </span><span class="s1">|| Array.isArray(choices)) &amp;&amp;</span>
        <span class="s1">choices.indexOf(value) !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// choise for subparsers can by only hash</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">choices === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; !Array.isArray(choices) &amp;&amp; choices[value]) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">choices === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s1">choices = choices.split(</span><span class="s2">''</span><span class="s1">).join(</span><span class="s2">', '</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(Array.isArray(choices)) {</span>
      <span class="s1">choices =  choices.join(</span><span class="s2">', '</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">choices =  Object.keys(choices).join(</span><span class="s2">', '</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">message = format(</span><span class="s2">'Invalid choice: %s (choose from [%s])'</span><span class="s1">, value, choices);</span>
    <span class="s3">throw </span><span class="s1">argumentErrorHelper(action, message);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s0">//</span>
<span class="s0">// Help formatting methods</span>
<span class="s0">//</span>

<span class="s0">/** 
 * ArgumentParser#formatUsage -&gt; string 
 * 
 * Return usage string 
 * 
 * See also [original guide][1] 
 * 
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help 
 **/</span>
<span class="s1">ArgumentParser.prototype.formatUsage = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">var </span><span class="s1">formatter = </span><span class="s3">this</span><span class="s1">._getFormatter();</span>
  <span class="s1">formatter.addUsage(</span><span class="s3">this</span><span class="s1">.usage, </span><span class="s3">this</span><span class="s1">._actions, </span><span class="s3">this</span><span class="s1">._mutuallyExclusiveGroups);</span>
  <span class="s3">return </span><span class="s1">formatter.formatHelp();</span>
<span class="s1">};</span>

<span class="s0">/** 
 * ArgumentParser#formatHelp -&gt; string 
 * 
 * Return help 
 * 
 * See also [original guide][1] 
 * 
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help 
 **/</span>
<span class="s1">ArgumentParser.prototype.formatHelp = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">var </span><span class="s1">formatter = </span><span class="s3">this</span><span class="s1">._getFormatter();</span>

  <span class="s0">// usage</span>
  <span class="s1">formatter.addUsage(</span><span class="s3">this</span><span class="s1">.usage, </span><span class="s3">this</span><span class="s1">._actions, </span><span class="s3">this</span><span class="s1">._mutuallyExclusiveGroups);</span>

  <span class="s0">// description</span>
  <span class="s1">formatter.addText(</span><span class="s3">this</span><span class="s1">.description);</span>

  <span class="s0">// positionals, optionals and user-defined groups</span>
  <span class="s3">this</span><span class="s1">._actionGroups.forEach(</span><span class="s3">function </span><span class="s1">(actionGroup) {</span>
    <span class="s1">formatter.startSection(actionGroup.title);</span>
    <span class="s1">formatter.addText(actionGroup.description);</span>
    <span class="s1">formatter.addArguments(actionGroup._groupActions);</span>
    <span class="s1">formatter.endSection();</span>
  <span class="s1">});</span>

  <span class="s0">// epilog</span>
  <span class="s1">formatter.addText(</span><span class="s3">this</span><span class="s1">.epilog);</span>

  <span class="s0">// determine help from format above</span>
  <span class="s3">return </span><span class="s1">formatter.formatHelp();</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._getFormatter = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">var </span><span class="s1">FormatterClass = </span><span class="s3">this</span><span class="s1">.formatterClass;</span>
  <span class="s3">var </span><span class="s1">formatter = </span><span class="s3">new </span><span class="s1">FormatterClass({ prog: </span><span class="s3">this</span><span class="s1">.prog });</span>
  <span class="s3">return </span><span class="s1">formatter;</span>
<span class="s1">};</span>

<span class="s0">//</span>
<span class="s0">//  Print functions</span>
<span class="s0">//</span>

<span class="s0">/** 
 * ArgumentParser#printUsage() -&gt; Void 
 * 
 * Print usage 
 * 
 * See also [original guide][1] 
 * 
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help 
 **/</span>
<span class="s1">ArgumentParser.prototype.printUsage = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">this</span><span class="s1">._printMessage(</span><span class="s3">this</span><span class="s1">.formatUsage());</span>
<span class="s1">};</span>

<span class="s0">/** 
 * ArgumentParser#printHelp() -&gt; Void 
 * 
 * Print help 
 * 
 * See also [original guide][1] 
 * 
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help 
 **/</span>
<span class="s1">ArgumentParser.prototype.printHelp = </span><span class="s3">function </span><span class="s1">() {</span>
  <span class="s3">this</span><span class="s1">._printMessage(</span><span class="s3">this</span><span class="s1">.formatHelp());</span>
<span class="s1">};</span>

<span class="s1">ArgumentParser.prototype._printMessage = </span><span class="s3">function </span><span class="s1">(message, stream) {</span>
  <span class="s3">if </span><span class="s1">(!stream) {</span>
    <span class="s1">stream = process.stdout;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(message) {</span>
    <span class="s1">stream.write(</span><span class="s2">'' </span><span class="s1">+ message);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s0">//</span>
<span class="s0">//  Exit functions</span>
<span class="s0">//</span>

<span class="s0">/** 
 * ArgumentParser#exit(status=0, message) -&gt; Void 
 * - status (int): exit status 
 * - message (string): message 
 * 
 * Print message in stderr/stdout and exit program 
 **/</span>
<span class="s1">ArgumentParser.prototype.exit = </span><span class="s3">function </span><span class="s1">(status, message) {</span>
  <span class="s3">if </span><span class="s1">(message) {</span>
    <span class="s3">if </span><span class="s1">(status === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._printMessage(message);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">this</span><span class="s1">._printMessage(message, process.stderr);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">process.exit(status);</span>
<span class="s1">};</span>

<span class="s0">/** 
 * ArgumentParser#error(message) -&gt; Void 
 * - err (Error|string): message 
 * 
 * Error method Prints a usage message incorporating the message to stderr and 
 * exits. If you override this in a subclass, 
 * it should not return -- it should 
 * either exit or throw an exception. 
 * 
 **/</span>
<span class="s1">ArgumentParser.prototype.error = </span><span class="s3">function </span><span class="s1">(err) {</span>
  <span class="s3">var </span><span class="s1">message;</span>
  <span class="s3">if </span><span class="s1">(err </span><span class="s3">instanceof </span><span class="s1">Error) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.debug === </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">throw </span><span class="s1">err;</span>
    <span class="s1">}</span>
    <span class="s1">message = err.message;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">message = err;</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">msg = format(</span><span class="s2">'%s: error: %s'</span><span class="s1">, </span><span class="s3">this</span><span class="s1">.prog, message) + c.EOL;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.debug === </span><span class="s3">true</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s1">Error(msg);</span>
  <span class="s1">}</span>

  <span class="s3">this</span><span class="s1">.printUsage(process.stderr);</span>

  <span class="s3">return this</span><span class="s1">.exit(</span><span class="s4">2</span><span class="s1">, msg);</span>
<span class="s1">};</span>

<span class="s1">module.exports = ArgumentParser;</span>
</pre>
</body>
</html>
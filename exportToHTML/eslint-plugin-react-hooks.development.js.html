<html>
<head>
<title>eslint-plugin-react-hooks.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
eslint-plugin-react-hooks.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @license React 
 * eslint-plugin-react-hooks.development.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">&quot;production&quot;</span><span class="s1">) {</span>
  <span class="s1">(</span><span class="s3">function</span><span class="s1">() {</span>
<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">_unsupportedIterableToArray(o, minLen) {</span>
  <span class="s3">if </span><span class="s1">(!o) </span><span class="s3">return</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">o === </span><span class="s2">&quot;string&quot;</span><span class="s1">) </span><span class="s3">return </span><span class="s1">_arrayLikeToArray(o, minLen);</span>
  <span class="s3">var </span><span class="s1">n = Object.prototype.toString.call(o).slice(</span><span class="s4">8</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s1">&amp;&amp; o.constructor) n = o.constructor.name;</span>
  <span class="s3">if </span><span class="s1">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s1">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s1">) </span><span class="s3">return </span><span class="s1">Array.from(o);</span>
  <span class="s3">if </span><span class="s1">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s1">|| /^(?:Ui|I)nt(?:</span><span class="s4">8</span><span class="s1">|</span><span class="s4">16</span><span class="s1">|</span><span class="s4">32</span><span class="s1">)(?:Clamped)?Array$/.test(n)) </span><span class="s3">return </span><span class="s1">_arrayLikeToArray(o, minLen);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_arrayLikeToArray(arr, len) {</span>
  <span class="s3">if </span><span class="s1">(len == </span><span class="s3">null </span><span class="s1">|| len &gt; arr.length) len = arr.length;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, arr2 = </span><span class="s3">new </span><span class="s1">Array(len); i &lt; len; i++) arr2[i] = arr[i];</span>

  <span class="s3">return </span><span class="s1">arr2;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">_createForOfIteratorHelper(o, allowArrayLike) {</span>
  <span class="s3">var </span><span class="s1">it;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">&quot;undefined&quot; </span><span class="s1">|| o[Symbol.iterator] == </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; </span><span class="s3">typeof </span><span class="s1">o.length === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(it) o = it;</span>
      <span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s3">var </span><span class="s1">F = </span><span class="s3">function </span><span class="s1">() {};</span>

      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">s: F,</span>
        <span class="s1">n: </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s3">if </span><span class="s1">(i &gt;= o.length) </span><span class="s3">return </span><span class="s1">{</span>
            <span class="s1">done: </span><span class="s3">true</span>
          <span class="s1">};</span>
          <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">done: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">value: o[i++]</span>
          <span class="s1">};</span>
        <span class="s1">},</span>
        <span class="s1">e: </span><span class="s3">function </span><span class="s1">(e) {</span>
          <span class="s3">throw </span><span class="s1">e;</span>
        <span class="s1">},</span>
        <span class="s1">f: F</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Invalid attempt to iterate non-iterable instance.</span><span class="s5">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">normalCompletion = </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">didErr = </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">err;</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">s: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">it = o[Symbol.iterator]();</span>
    <span class="s1">},</span>
    <span class="s1">n: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">step = it.next();</span>
      <span class="s1">normalCompletion = step.done;</span>
      <span class="s3">return </span><span class="s1">step;</span>
    <span class="s1">},</span>
    <span class="s1">e: </span><span class="s3">function </span><span class="s1">(e) {</span>
      <span class="s1">didErr = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">err = e;</span>
    <span class="s1">},</span>
    <span class="s1">f: </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!normalCompletion &amp;&amp; it.</span><span class="s3">return </span><span class="s1">!= </span><span class="s3">null</span><span class="s1">) it.</span><span class="s3">return</span><span class="s1">();</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(didErr) </span><span class="s3">throw </span><span class="s1">err;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s0">/* global BigInt */</span>

<span class="s3">function </span><span class="s1">isHookName(s) {</span>
  <span class="s3">return </span><span class="s1">/^use[A-Z0-9].*$/.test(s);</span>
<span class="s1">}</span>
<span class="s0">/** 
 * We consider hooks to be a hook name identifier or a member expression 
 * containing a hook name. 
 */</span>


<span class="s3">function </span><span class="s1">isHook(node) {</span>
  <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">'Identifier'</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">isHookName(node.name);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.type === </span><span class="s2">'MemberExpression' </span><span class="s1">&amp;&amp; !node.computed &amp;&amp; isHook(node.property)) {</span>
    <span class="s3">var </span><span class="s1">obj = node.object;</span>
    <span class="s3">var </span><span class="s1">isPascalCaseNameSpace = /^[A-Z].*/;</span>
    <span class="s3">return </span><span class="s1">obj.type === </span><span class="s2">'Identifier' </span><span class="s1">&amp;&amp; isPascalCaseNameSpace.test(obj.name);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Checks if the node is a React component name. React component names must 
 * always start with a non-lowercase letter. So `MyComponent` or `_MyComponent` 
 * are valid component names for instance. 
 */</span>


<span class="s3">function </span><span class="s1">isComponentName(node) {</span>
  <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">'Identifier'</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">!/^[a-z]/.test(node.name);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isReactFunction(node, functionName) {</span>
  <span class="s3">return </span><span class="s1">node.name === functionName || node.type === </span><span class="s2">'MemberExpression' </span><span class="s1">&amp;&amp; node.object.name === </span><span class="s2">'React' </span><span class="s1">&amp;&amp; node.property.name === functionName;</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Checks if the node is a callback argument of forwardRef. This render function 
 * should follow the rules of hooks. 
 */</span>


<span class="s3">function </span><span class="s1">isForwardRefCallback(node) {</span>
  <span class="s3">return </span><span class="s1">!!(node.parent &amp;&amp; node.parent.callee &amp;&amp; isReactFunction(node.parent.callee, </span><span class="s2">'forwardRef'</span><span class="s1">));</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Checks if the node is a callback argument of React.memo. This anonymous 
 * functional component should follow the rules of hooks. 
 */</span>


<span class="s3">function </span><span class="s1">isMemoCallback(node) {</span>
  <span class="s3">return </span><span class="s1">!!(node.parent &amp;&amp; node.parent.callee &amp;&amp; isReactFunction(node.parent.callee, </span><span class="s2">'memo'</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isInsideComponentOrHook(node) {</span>
  <span class="s3">while </span><span class="s1">(node) {</span>
    <span class="s3">var </span><span class="s1">functionName = getFunctionName(node);</span>

    <span class="s3">if </span><span class="s1">(functionName) {</span>
      <span class="s3">if </span><span class="s1">(isComponentName(functionName) || isHook(functionName)) {</span>
        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(isForwardRefCallback(node) || isMemoCallback(node)) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">node = node.parent;</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">RulesOfHooks = {</span>
  <span class="s1">meta: {</span>
    <span class="s1">type: </span><span class="s2">'problem'</span><span class="s1">,</span>
    <span class="s1">docs: {</span>
      <span class="s1">description: </span><span class="s2">'enforces the Rules of Hooks'</span><span class="s1">,</span>
      <span class="s1">recommended: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">url: </span><span class="s2">'https://reactjs.org/docs/hooks-rules.html'</span>
    <span class="s1">}</span>
  <span class="s1">},</span>
  <span class="s1">create: </span><span class="s3">function </span><span class="s1">(context) {</span>
    <span class="s3">var </span><span class="s1">codePathReactHooksMapStack = [];</span>
    <span class="s3">var </span><span class="s1">codePathSegmentStack = [];</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s0">// Maintain code segment path stack as we traverse.</span>
      <span class="s1">onCodePathSegmentStart: </span><span class="s3">function </span><span class="s1">(segment) {</span>
        <span class="s3">return </span><span class="s1">codePathSegmentStack.push(segment);</span>
      <span class="s1">},</span>
      <span class="s1">onCodePathSegmentEnd: </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">codePathSegmentStack.pop();</span>
      <span class="s1">},</span>
      <span class="s0">// Maintain code path stack as we traverse.</span>
      <span class="s1">onCodePathStart: </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">codePathReactHooksMapStack.push(</span><span class="s3">new </span><span class="s1">Map());</span>
      <span class="s1">},</span>
      <span class="s0">// Process our code path.</span>
      <span class="s0">//</span>
      <span class="s0">// Everything is ok if all React Hooks are both reachable from the initial</span>
      <span class="s0">// segment and reachable from every final segment.</span>
      <span class="s1">onCodePathEnd: </span><span class="s3">function </span><span class="s1">(codePath, codePathNode) {</span>
        <span class="s3">var </span><span class="s1">reactHooksMap = codePathReactHooksMapStack.pop();</span>

        <span class="s3">if </span><span class="s1">(reactHooksMap.size === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// All of the segments which are cyclic are recorded in this set.</span>


        <span class="s3">var </span><span class="s1">cyclic = </span><span class="s3">new </span><span class="s1">Set();</span>
        <span class="s0">/** 
         * Count the number of code paths from the start of the function to this 
         * segment. For example: 
         * 
         * ```js 
         * function MyComponent() { 
         *   if (condition) { 
         *     // Segment 1 
         *   } else { 
         *     // Segment 2 
         *   } 
         *   // Segment 3 
         * } 
         * ``` 
         * 
         * Segments 1 and 2 have one path to the beginning of `MyComponent` and 
         * segment 3 has two paths to the beginning of `MyComponent` since we 
         * could have either taken the path of segment 1 or segment 2. 
         * 
         * Populates `cyclic` with cyclic segments. 
         */</span>

        <span class="s3">function </span><span class="s1">countPathsFromStart(segment, pathHistory) {</span>
          <span class="s3">var </span><span class="s1">cache = countPathsFromStart.cache;</span>
          <span class="s3">var </span><span class="s1">paths = cache.get(segment.id);</span>
          <span class="s3">var </span><span class="s1">pathList = </span><span class="s3">new </span><span class="s1">Set(pathHistory); </span><span class="s0">// If `pathList` includes the current segment then we've found a cycle!</span>
          <span class="s0">// We need to fill `cyclic` with all segments inside cycle</span>

          <span class="s3">if </span><span class="s1">(pathList.has(segment.id)) {</span>
            <span class="s3">var </span><span class="s1">pathArray = [].concat(pathList);</span>
            <span class="s3">var </span><span class="s1">cyclicSegments = pathArray.slice(pathArray.indexOf(segment.id) + </span><span class="s4">1</span><span class="s1">);</span>

            <span class="s3">var </span><span class="s1">_iterator = _createForOfIteratorHelper(cyclicSegments),</span>
                <span class="s1">_step;</span>

            <span class="s3">try </span><span class="s1">{</span>
              <span class="s3">for </span><span class="s1">(_iterator.s(); !(_step = _iterator.n()).done;) {</span>
                <span class="s3">var </span><span class="s1">cyclicSegment = _step.value;</span>
                <span class="s1">cyclic.add(cyclicSegment);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
              <span class="s1">_iterator.e(err);</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
              <span class="s1">_iterator.f();</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">BigInt(</span><span class="s2">'0'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s0">// add the current segment to pathList</span>


          <span class="s1">pathList.add(segment.id); </span><span class="s0">// We have a cached `paths`. Return it.</span>

          <span class="s3">if </span><span class="s1">(paths !== undefined) {</span>
            <span class="s3">return </span><span class="s1">paths;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(codePath.thrownSegments.includes(segment)) {</span>
            <span class="s1">paths = BigInt(</span><span class="s2">'0'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(segment.prevSegments.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">paths = BigInt(</span><span class="s2">'1'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">paths = BigInt(</span><span class="s2">'0'</span><span class="s1">);</span>

            <span class="s3">var </span><span class="s1">_iterator2 = _createForOfIteratorHelper(segment.prevSegments),</span>
                <span class="s1">_step2;</span>

            <span class="s3">try </span><span class="s1">{</span>
              <span class="s3">for </span><span class="s1">(_iterator2.s(); !(_step2 = _iterator2.n()).done;) {</span>
                <span class="s3">var </span><span class="s1">prevSegment = _step2.value;</span>
                <span class="s1">paths += countPathsFromStart(prevSegment, pathList);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
              <span class="s1">_iterator2.e(err);</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
              <span class="s1">_iterator2.f();</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// If our segment is reachable then there should be at least one path</span>
          <span class="s0">// to it from the start of our code path.</span>


          <span class="s3">if </span><span class="s1">(segment.reachable &amp;&amp; paths === BigInt(</span><span class="s2">'0'</span><span class="s1">)) {</span>
            <span class="s1">cache.</span><span class="s3">delete</span><span class="s1">(segment.id);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">cache.set(segment.id, paths);</span>
          <span class="s1">}</span>

          <span class="s3">return </span><span class="s1">paths;</span>
        <span class="s1">}</span>
        <span class="s0">/** 
         * Count the number of code paths from this segment to the end of the 
         * function. For example: 
         * 
         * ```js 
         * function MyComponent() { 
         *   // Segment 1 
         *   if (condition) { 
         *     // Segment 2 
         *   } else { 
         *     // Segment 3 
         *   } 
         * } 
         * ``` 
         * 
         * Segments 2 and 3 have one path to the end of `MyComponent` and 
         * segment 1 has two paths to the end of `MyComponent` since we could 
         * either take the path of segment 1 or segment 2. 
         * 
         * Populates `cyclic` with cyclic segments. 
         */</span>


        <span class="s3">function </span><span class="s1">countPathsToEnd(segment, pathHistory) {</span>
          <span class="s3">var </span><span class="s1">cache = countPathsToEnd.cache;</span>
          <span class="s3">var </span><span class="s1">paths = cache.get(segment.id);</span>
          <span class="s3">var </span><span class="s1">pathList = </span><span class="s3">new </span><span class="s1">Set(pathHistory); </span><span class="s0">// If `pathList` includes the current segment then we've found a cycle!</span>
          <span class="s0">// We need to fill `cyclic` with all segments inside cycle</span>

          <span class="s3">if </span><span class="s1">(pathList.has(segment.id)) {</span>
            <span class="s3">var </span><span class="s1">pathArray = Array.from(pathList);</span>
            <span class="s3">var </span><span class="s1">cyclicSegments = pathArray.slice(pathArray.indexOf(segment.id) + </span><span class="s4">1</span><span class="s1">);</span>

            <span class="s3">var </span><span class="s1">_iterator3 = _createForOfIteratorHelper(cyclicSegments),</span>
                <span class="s1">_step3;</span>

            <span class="s3">try </span><span class="s1">{</span>
              <span class="s3">for </span><span class="s1">(_iterator3.s(); !(_step3 = _iterator3.n()).done;) {</span>
                <span class="s3">var </span><span class="s1">cyclicSegment = _step3.value;</span>
                <span class="s1">cyclic.add(cyclicSegment);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
              <span class="s1">_iterator3.e(err);</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
              <span class="s1">_iterator3.f();</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">BigInt(</span><span class="s2">'0'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s0">// add the current segment to pathList</span>


          <span class="s1">pathList.add(segment.id); </span><span class="s0">// We have a cached `paths`. Return it.</span>

          <span class="s3">if </span><span class="s1">(paths !== undefined) {</span>
            <span class="s3">return </span><span class="s1">paths;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(codePath.thrownSegments.includes(segment)) {</span>
            <span class="s1">paths = BigInt(</span><span class="s2">'0'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">else if </span><span class="s1">(segment.nextSegments.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">paths = BigInt(</span><span class="s2">'1'</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">paths = BigInt(</span><span class="s2">'0'</span><span class="s1">);</span>

            <span class="s3">var </span><span class="s1">_iterator4 = _createForOfIteratorHelper(segment.nextSegments),</span>
                <span class="s1">_step4;</span>

            <span class="s3">try </span><span class="s1">{</span>
              <span class="s3">for </span><span class="s1">(_iterator4.s(); !(_step4 = _iterator4.n()).done;) {</span>
                <span class="s3">var </span><span class="s1">nextSegment = _step4.value;</span>
                <span class="s1">paths += countPathsToEnd(nextSegment, pathList);</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
              <span class="s1">_iterator4.e(err);</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
              <span class="s1">_iterator4.f();</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s1">cache.set(segment.id, paths);</span>
          <span class="s3">return </span><span class="s1">paths;</span>
        <span class="s1">}</span>
        <span class="s0">/** 
         * Gets the shortest path length to the start of a code path. 
         * For example: 
         * 
         * ```js 
         * function MyComponent() { 
         *   if (condition) { 
         *     // Segment 1 
         *   } 
         *   // Segment 2 
         * } 
         * ``` 
         * 
         * There is only one path from segment 1 to the code path start. Its 
         * length is one so that is the shortest path. 
         * 
         * There are two paths from segment 2 to the code path start. One 
         * through segment 1 with a length of two and another directly to the 
         * start with a length of one. The shortest path has a length of one 
         * so we would return that. 
         */</span>


        <span class="s3">function </span><span class="s1">shortestPathLengthToStart(segment) {</span>
          <span class="s3">var </span><span class="s1">cache = shortestPathLengthToStart.cache;</span>
          <span class="s3">var </span><span class="s1">length = cache.get(segment.id); </span><span class="s0">// If `length` is null then we found a cycle! Return infinity since</span>
          <span class="s0">// the shortest path is definitely not the one where we looped.</span>

          <span class="s3">if </span><span class="s1">(length === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">Infinity;</span>
          <span class="s1">} </span><span class="s0">// We have a cached `length`. Return it.</span>


          <span class="s3">if </span><span class="s1">(length !== undefined) {</span>
            <span class="s3">return </span><span class="s1">length;</span>
          <span class="s1">} </span><span class="s0">// Compute `length` and cache it. Guarding against cycles.</span>


          <span class="s1">cache.set(segment.id, </span><span class="s3">null</span><span class="s1">);</span>

          <span class="s3">if </span><span class="s1">(segment.prevSegments.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">length = </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">length = Infinity;</span>

            <span class="s3">var </span><span class="s1">_iterator5 = _createForOfIteratorHelper(segment.prevSegments),</span>
                <span class="s1">_step5;</span>

            <span class="s3">try </span><span class="s1">{</span>
              <span class="s3">for </span><span class="s1">(_iterator5.s(); !(_step5 = _iterator5.n()).done;) {</span>
                <span class="s3">var </span><span class="s1">prevSegment = _step5.value;</span>
                <span class="s3">var </span><span class="s1">prevLength = shortestPathLengthToStart(prevSegment);</span>

                <span class="s3">if </span><span class="s1">(prevLength &lt; length) {</span>
                  <span class="s1">length = prevLength;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
              <span class="s1">_iterator5.e(err);</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
              <span class="s1">_iterator5.f();</span>
            <span class="s1">}</span>

            <span class="s1">length += </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">cache.set(segment.id, length);</span>
          <span class="s3">return </span><span class="s1">length;</span>
        <span class="s1">}</span>

        <span class="s1">countPathsFromStart.cache = </span><span class="s3">new </span><span class="s1">Map();</span>
        <span class="s1">countPathsToEnd.cache = </span><span class="s3">new </span><span class="s1">Map();</span>
        <span class="s1">shortestPathLengthToStart.cache = </span><span class="s3">new </span><span class="s1">Map(); </span><span class="s0">// Count all code paths to the end of our component/hook. Also primes</span>
        <span class="s0">// the `countPathsToEnd` cache.</span>

        <span class="s3">var </span><span class="s1">allPathsFromStartToEnd = countPathsToEnd(codePath.initialSegment); </span><span class="s0">// Gets the function name for our code path. If the function name is</span>
        <span class="s0">// `undefined` then we know either that we have an anonymous function</span>
        <span class="s0">// expression or our code path is not in a function. In both cases we</span>
        <span class="s0">// will want to error since neither are React function components or</span>
        <span class="s0">// hook functions - unless it is an anonymous function argument to</span>
        <span class="s0">// forwardRef or memo.</span>

        <span class="s3">var </span><span class="s1">codePathFunctionName = getFunctionName(codePathNode); </span><span class="s0">// This is a valid code path for React hooks if we are directly in a React</span>
        <span class="s0">// function component or we are in a hook function.</span>

        <span class="s3">var </span><span class="s1">isSomewhereInsideComponentOrHook = isInsideComponentOrHook(codePathNode);</span>
        <span class="s3">var </span><span class="s1">isDirectlyInsideComponentOrHook = codePathFunctionName ? isComponentName(codePathFunctionName) || isHook(codePathFunctionName) : isForwardRefCallback(codePathNode) || isMemoCallback(codePathNode); </span><span class="s0">// Compute the earliest finalizer level using information from the</span>
        <span class="s0">// cache. We expect all reachable final segments to have a cache entry</span>
        <span class="s0">// after calling `visitSegment()`.</span>

        <span class="s3">var </span><span class="s1">shortestFinalPathLength = Infinity;</span>

        <span class="s3">var </span><span class="s1">_iterator6 = _createForOfIteratorHelper(codePath.finalSegments),</span>
            <span class="s1">_step6;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">for </span><span class="s1">(_iterator6.s(); !(_step6 = _iterator6.n()).done;) {</span>
            <span class="s3">var </span><span class="s1">finalSegment = _step6.value;</span>

            <span class="s3">if </span><span class="s1">(!finalSegment.reachable) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">length = shortestPathLengthToStart(finalSegment);</span>

            <span class="s3">if </span><span class="s1">(length &lt; shortestFinalPathLength) {</span>
              <span class="s1">shortestFinalPathLength = length;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">// Make sure all React Hooks pass our lint invariants. Log warnings</span>
          <span class="s0">// if not.</span>

        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
          <span class="s1">_iterator6.e(err);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">_iterator6.f();</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">_iterator7 = _createForOfIteratorHelper(reactHooksMap),</span>
            <span class="s1">_step7;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">for </span><span class="s1">(_iterator7.s(); !(_step7 = _iterator7.n()).done;) {</span>
            <span class="s3">var </span><span class="s1">_step7$value = _step7.value,</span>
                <span class="s1">segment = _step7$value[</span><span class="s4">0</span><span class="s1">],</span>
                <span class="s1">reactHooks = _step7$value[</span><span class="s4">1</span><span class="s1">];</span>

            <span class="s0">// NOTE: We could report here that the hook is not reachable, but</span>
            <span class="s0">// that would be redundant with more general &quot;no unreachable&quot;</span>
            <span class="s0">// lint rules.</span>
            <span class="s3">if </span><span class="s1">(!segment.reachable) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s0">// If there are any final segments with a shorter path to start then</span>
            <span class="s0">// we possibly have an early return.</span>
            <span class="s0">//</span>
            <span class="s0">// If our segment is a final segment itself then siblings could</span>
            <span class="s0">// possibly be early returns.</span>


            <span class="s3">var </span><span class="s1">possiblyHasEarlyReturn = segment.nextSegments.length === </span><span class="s4">0 </span><span class="s1">? shortestFinalPathLength &lt;= shortestPathLengthToStart(segment) : shortestFinalPathLength &lt; shortestPathLengthToStart(segment); </span><span class="s0">// Count all the paths from the start of our code path to the end of</span>
            <span class="s0">// our code path that go _through_ this segment. The critical piece</span>
            <span class="s0">// of this is _through_. If we just call `countPathsToEnd(segment)`</span>
            <span class="s0">// then we neglect that we may have gone through multiple paths to get</span>
            <span class="s0">// to this point! Consider:</span>
            <span class="s0">//</span>
            <span class="s0">// ```js</span>
            <span class="s0">// function MyComponent() {</span>
            <span class="s0">//   if (a) {</span>
            <span class="s0">//     // Segment 1</span>
            <span class="s0">//   } else {</span>
            <span class="s0">//     // Segment 2</span>
            <span class="s0">//   }</span>
            <span class="s0">//   // Segment 3</span>
            <span class="s0">//   if (b) {</span>
            <span class="s0">//     // Segment 4</span>
            <span class="s0">//   } else {</span>
            <span class="s0">//     // Segment 5</span>
            <span class="s0">//   }</span>
            <span class="s0">// }</span>
            <span class="s0">// ```</span>
            <span class="s0">//</span>
            <span class="s0">// In this component we have four code paths:</span>
            <span class="s0">//</span>
            <span class="s0">// 1. `a = true; b = true`</span>
            <span class="s0">// 2. `a = true; b = false`</span>
            <span class="s0">// 3. `a = false; b = true`</span>
            <span class="s0">// 4. `a = false; b = false`</span>
            <span class="s0">//</span>
            <span class="s0">// From segment 3 there are two code paths to the end through segment</span>
            <span class="s0">// 4 and segment 5. However, we took two paths to get here through</span>
            <span class="s0">// segment 1 and segment 2.</span>
            <span class="s0">//</span>
            <span class="s0">// If we multiply the paths from start (two) by the paths to end (two)</span>
            <span class="s0">// for segment 3 we get four. Which is our desired count.</span>

            <span class="s3">var </span><span class="s1">pathsFromStartToEnd = countPathsFromStart(segment) * countPathsToEnd(segment); </span><span class="s0">// Is this hook a part of a cyclic segment?</span>

            <span class="s3">var </span><span class="s1">cycled = cyclic.has(segment.id);</span>

            <span class="s3">var </span><span class="s1">_iterator8 = _createForOfIteratorHelper(reactHooks),</span>
                <span class="s1">_step8;</span>

            <span class="s3">try </span><span class="s1">{</span>
              <span class="s3">for </span><span class="s1">(_iterator8.s(); !(_step8 = _iterator8.n()).done;) {</span>
                <span class="s3">var </span><span class="s1">hook = _step8.value;</span>

                <span class="s0">// Report an error if a hook may be called more then once.</span>
                <span class="s3">if </span><span class="s1">(cycled) {</span>
                  <span class="s1">context.report({</span>
                    <span class="s1">node: hook,</span>
                    <span class="s1">message: </span><span class="s2">&quot;React Hook </span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ context.getSource(hook) + </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">may be executed &quot; </span><span class="s1">+ </span><span class="s2">'more than once. Possibly because it is called in a loop. ' </span><span class="s1">+ </span><span class="s2">'React Hooks must be called in the exact same order in ' </span><span class="s1">+ </span><span class="s2">'every component render.'</span>
                  <span class="s1">});</span>
                <span class="s1">} </span><span class="s0">// If this is not a valid code path for React hooks then we need to</span>
                <span class="s0">// log a warning for every hook in this code path.</span>
                <span class="s0">//</span>
                <span class="s0">// Pick a special message depending on the scope this hook was</span>
                <span class="s0">// called in.</span>


                <span class="s3">if </span><span class="s1">(isDirectlyInsideComponentOrHook) {</span>
                  <span class="s0">// Report an error if a hook does not reach all finalizing code</span>
                  <span class="s0">// path segments.</span>
                  <span class="s0">//</span>
                  <span class="s0">// Special case when we think there might be an early return.</span>
                  <span class="s3">if </span><span class="s1">(!cycled &amp;&amp; pathsFromStartToEnd !== allPathsFromStartToEnd) {</span>
                    <span class="s3">var </span><span class="s1">message = </span><span class="s2">&quot;React Hook </span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ context.getSource(hook) + </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">is called &quot; </span><span class="s1">+ </span><span class="s2">'conditionally. React Hooks must be called in the exact ' </span><span class="s1">+ </span><span class="s2">'same order in every component render.' </span><span class="s1">+ (possiblyHasEarlyReturn ? </span><span class="s2">' Did you accidentally call a React Hook after an' </span><span class="s1">+ </span><span class="s2">' early return?' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">);</span>
                    <span class="s1">context.report({</span>
                      <span class="s1">node: hook,</span>
                      <span class="s1">message: message</span>
                    <span class="s1">});</span>
                  <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(codePathNode.parent &amp;&amp; (codePathNode.parent.type === </span><span class="s2">'MethodDefinition' </span><span class="s1">|| codePathNode.parent.type === </span><span class="s2">'ClassProperty'</span><span class="s1">) &amp;&amp; codePathNode.parent.value === codePathNode) {</span>
                  <span class="s0">// Custom message for hooks inside a class</span>
                  <span class="s3">var </span><span class="s1">_message = </span><span class="s2">&quot;React Hook </span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ context.getSource(hook) + </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">cannot be called &quot; </span><span class="s1">+ </span><span class="s2">'in a class component. React Hooks must be called in a ' </span><span class="s1">+ </span><span class="s2">'React function component or a custom React Hook function.'</span><span class="s1">;</span>

                  <span class="s1">context.report({</span>
                    <span class="s1">node: hook,</span>
                    <span class="s1">message: _message</span>
                  <span class="s1">});</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(codePathFunctionName) {</span>
                  <span class="s0">// Custom message if we found an invalid function name.</span>
                  <span class="s3">var </span><span class="s1">_message2 = </span><span class="s2">&quot;React Hook </span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ context.getSource(hook) + </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">is called in &quot; </span><span class="s1">+ (</span><span class="s2">&quot;function </span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ context.getSource(codePathFunctionName) + </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">&quot;</span><span class="s1">) + </span><span class="s2">'that is neither a React function component nor a custom ' </span><span class="s1">+ </span><span class="s2">'React Hook function.' </span><span class="s1">+ </span><span class="s2">' React component names must start with an uppercase letter.' </span><span class="s1">+ </span><span class="s2">' React Hook names must start with the word &quot;use&quot;.'</span><span class="s1">;</span>

                  <span class="s1">context.report({</span>
                    <span class="s1">node: hook,</span>
                    <span class="s1">message: _message2</span>
                  <span class="s1">});</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(codePathNode.type === </span><span class="s2">'Program'</span><span class="s1">) {</span>
                  <span class="s0">// These are dangerous if you have inline requires enabled.</span>
                  <span class="s3">var </span><span class="s1">_message3 = </span><span class="s2">&quot;React Hook </span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ context.getSource(hook) + </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">cannot be called &quot; </span><span class="s1">+ </span><span class="s2">'at the top level. React Hooks must be called in a ' </span><span class="s1">+ </span><span class="s2">'React function component or a custom React Hook function.'</span><span class="s1">;</span>

                  <span class="s1">context.report({</span>
                    <span class="s1">node: hook,</span>
                    <span class="s1">message: _message3</span>
                  <span class="s1">});</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                  <span class="s0">// Assume in all other cases the user called a hook in some</span>
                  <span class="s0">// random function callback. This should usually be true for</span>
                  <span class="s0">// anonymous function expressions. Hopefully this is clarifying</span>
                  <span class="s0">// enough in the common case that the incorrect message in</span>
                  <span class="s0">// uncommon cases doesn't matter.</span>
                  <span class="s3">if </span><span class="s1">(isSomewhereInsideComponentOrHook) {</span>
                    <span class="s3">var </span><span class="s1">_message4 = </span><span class="s2">&quot;React Hook </span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ context.getSource(hook) + </span><span class="s2">&quot;</span><span class="s5">\&quot; </span><span class="s2">cannot be called &quot; </span><span class="s1">+ </span><span class="s2">'inside a callback. React Hooks must be called in a ' </span><span class="s1">+ </span><span class="s2">'React function component or a custom React Hook function.'</span><span class="s1">;</span>

                    <span class="s1">context.report({</span>
                      <span class="s1">node: hook,</span>
                      <span class="s1">message: _message4</span>
                    <span class="s1">});</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
              <span class="s1">_iterator8.e(err);</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
              <span class="s1">_iterator8.f();</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
          <span class="s1">_iterator7.e(err);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">_iterator7.f();</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s0">// Missed opportunity...We could visit all `Identifier`s instead of all</span>
      <span class="s0">// `CallExpression`s and check that _every use_ of a hook name is valid.</span>
      <span class="s0">// But that gets complicated and enters type-system territory, so we're</span>
      <span class="s0">// only being strict about hook calls for now.</span>
      <span class="s1">CallExpression: </span><span class="s3">function </span><span class="s1">(node) {</span>
        <span class="s3">if </span><span class="s1">(isHook(node.callee)) {</span>
          <span class="s0">// Add the hook node to a map keyed by the code path segment. We will</span>
          <span class="s0">// do full code path analysis at the end of our code path.</span>
          <span class="s3">var </span><span class="s1">reactHooksMap = last(codePathReactHooksMapStack);</span>
          <span class="s3">var </span><span class="s1">codePathSegment = last(codePathSegmentStack);</span>
          <span class="s3">var </span><span class="s1">reactHooks = reactHooksMap.get(codePathSegment);</span>

          <span class="s3">if </span><span class="s1">(!reactHooks) {</span>
            <span class="s1">reactHooks = [];</span>
            <span class="s1">reactHooksMap.set(codePathSegment, reactHooks);</span>
          <span class="s1">}</span>

          <span class="s1">reactHooks.push(node.callee);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s0">/** 
 * Gets the static name of a function AST node. For function declarations it is 
 * easy. For anonymous function expressions it is much harder. If you search for 
 * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places 
 * where JS gives anonymous function expressions names. We roughly detect the 
 * same AST nodes with some exceptions to better fit our use case. 
 */</span>

<span class="s3">function </span><span class="s1">getFunctionName(node) {</span>
  <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">'FunctionDeclaration' </span><span class="s1">|| node.type === </span><span class="s2">'FunctionExpression' </span><span class="s1">&amp;&amp; node.id) {</span>
    <span class="s0">// function useHook() {}</span>
    <span class="s0">// const whatever = function useHook() {};</span>
    <span class="s0">//</span>
    <span class="s0">// Function declaration or function expression names win over any</span>
    <span class="s0">// assignment statements or other renames.</span>
    <span class="s3">return </span><span class="s1">node.id;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.type === </span><span class="s2">'FunctionExpression' </span><span class="s1">|| node.type === </span><span class="s2">'ArrowFunctionExpression'</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(node.parent.type === </span><span class="s2">'VariableDeclarator' </span><span class="s1">&amp;&amp; node.parent.init === node) {</span>
      <span class="s0">// const useHook = () =&gt; {};</span>
      <span class="s3">return </span><span class="s1">node.parent.id;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.parent.type === </span><span class="s2">'AssignmentExpression' </span><span class="s1">&amp;&amp; node.parent.right === node &amp;&amp; node.parent.operator === </span><span class="s2">'='</span><span class="s1">) {</span>
      <span class="s0">// useHook = () =&gt; {};</span>
      <span class="s3">return </span><span class="s1">node.parent.left;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.parent.type === </span><span class="s2">'Property' </span><span class="s1">&amp;&amp; node.parent.value === node &amp;&amp; !node.parent.computed) {</span>
      <span class="s0">// {useHook: () =&gt; {}}</span>
      <span class="s0">// {useHook() {}}</span>
      <span class="s3">return </span><span class="s1">node.parent.key; </span><span class="s0">// NOTE: We could also support `ClassProperty` and `MethodDefinition`</span>
      <span class="s0">// here to be pedantic. However, hooks in a class are an anti-pattern. So</span>
      <span class="s0">// we don't allow it to error early.</span>
      <span class="s0">//</span>
      <span class="s0">// class {useHook = () =&gt; {}}</span>
      <span class="s0">// class {useHook() {}}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.parent.type === </span><span class="s2">'AssignmentPattern' </span><span class="s1">&amp;&amp; node.parent.right === node &amp;&amp; !node.parent.computed) {</span>
      <span class="s0">// const {useHook = () =&gt; {}} = {};</span>
      <span class="s0">// ({useHook = () =&gt; {}} = {});</span>
      <span class="s0">//</span>
      <span class="s0">// Kinda clowny, but we'd said we'd follow spec convention for</span>
      <span class="s0">// `IsAnonymousFunctionDefinition()` usage.</span>
      <span class="s3">return </span><span class="s1">node.parent.left;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Convenience function for peeking the last item in a stack. 
 */</span>


<span class="s3">function </span><span class="s1">last(array) {</span>
  <span class="s3">return </span><span class="s1">array[array.length - </span><span class="s4">1</span><span class="s1">];</span>
<span class="s1">}</span>

<span class="s0">/* eslint-disable no-for-of-loops/no-for-of-loops */</span>
<span class="s3">var </span><span class="s1">ExhaustiveDeps = {</span>
  <span class="s1">meta: {</span>
    <span class="s1">type: </span><span class="s2">'suggestion'</span><span class="s1">,</span>
    <span class="s1">docs: {</span>
      <span class="s1">description: </span><span class="s2">'verifies the list of dependencies for Hooks like useEffect and similar'</span><span class="s1">,</span>
      <span class="s1">recommended: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s1">url: </span><span class="s2">'https://github.com/facebook/react/issues/14920'</span>
    <span class="s1">},</span>
    <span class="s1">fixable: </span><span class="s2">'code'</span><span class="s1">,</span>
    <span class="s1">hasSuggestions: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">schema: [{</span>
      <span class="s1">type: </span><span class="s2">'object'</span><span class="s1">,</span>
      <span class="s1">additionalProperties: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">enableDangerousAutofixThisMayCauseInfiniteLoops: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s1">properties: {</span>
        <span class="s1">additionalHooks: {</span>
          <span class="s1">type: </span><span class="s2">'string'</span>
        <span class="s1">},</span>
        <span class="s1">enableDangerousAutofixThisMayCauseInfiniteLoops: {</span>
          <span class="s1">type: </span><span class="s2">'boolean'</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}]</span>
  <span class="s1">},</span>
  <span class="s1">create: </span><span class="s3">function </span><span class="s1">(context) {</span>
    <span class="s0">// Parse the `additionalHooks` regex.</span>
    <span class="s3">var </span><span class="s1">additionalHooks = context.options &amp;&amp; context.options[</span><span class="s4">0</span><span class="s1">] &amp;&amp; context.options[</span><span class="s4">0</span><span class="s1">].additionalHooks ? </span><span class="s3">new </span><span class="s1">RegExp(context.options[</span><span class="s4">0</span><span class="s1">].additionalHooks) : undefined;</span>
    <span class="s3">var </span><span class="s1">enableDangerousAutofixThisMayCauseInfiniteLoops = context.options &amp;&amp; context.options[</span><span class="s4">0</span><span class="s1">] &amp;&amp; context.options[</span><span class="s4">0</span><span class="s1">].enableDangerousAutofixThisMayCauseInfiniteLoops || </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">options = {</span>
      <span class="s1">additionalHooks: additionalHooks,</span>
      <span class="s1">enableDangerousAutofixThisMayCauseInfiniteLoops: enableDangerousAutofixThisMayCauseInfiniteLoops</span>
    <span class="s1">};</span>

    <span class="s3">function </span><span class="s1">reportProblem(problem) {</span>
      <span class="s3">if </span><span class="s1">(enableDangerousAutofixThisMayCauseInfiniteLoops) {</span>
        <span class="s0">// Used to enable legacy behavior. Dangerous.</span>
        <span class="s0">// Keep this as an option until major IDEs upgrade (including VSCode FB ESLint extension).</span>
        <span class="s3">if </span><span class="s1">(Array.isArray(problem.suggest) &amp;&amp; problem.suggest.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">problem.fix = problem.suggest[</span><span class="s4">0</span><span class="s1">].fix;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">context.report(problem);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">scopeManager = context.getSourceCode().scopeManager; </span><span class="s0">// Should be shared between visitors.</span>

    <span class="s3">var </span><span class="s1">setStateCallSites = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
    <span class="s3">var </span><span class="s1">stateVariables = </span><span class="s3">new </span><span class="s1">WeakSet();</span>
    <span class="s3">var </span><span class="s1">stableKnownValueCache = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
    <span class="s3">var </span><span class="s1">functionWithoutCapturedValueCache = </span><span class="s3">new </span><span class="s1">WeakMap();</span>

    <span class="s3">function </span><span class="s1">memoizeWithWeakMap(fn, map) {</span>
      <span class="s3">return function </span><span class="s1">(arg) {</span>
        <span class="s3">if </span><span class="s1">(map.has(arg)) {</span>
          <span class="s0">// to verify cache hits:</span>
          <span class="s0">// console.log(arg.name)</span>
          <span class="s3">return </span><span class="s1">map.get(arg);</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">result = fn(arg);</span>
        <span class="s1">map.set(arg, result);</span>
        <span class="s3">return </span><span class="s1">result;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * Visitor for both function expressions and arrow function expressions. 
     */</span>


    <span class="s3">function </span><span class="s1">visitFunctionWithDependencies(node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect) {</span>
      <span class="s3">if </span><span class="s1">(isEffect &amp;&amp; node.async) {</span>
        <span class="s1">reportProblem({</span>
          <span class="s1">node: node,</span>
          <span class="s1">message: </span><span class="s2">&quot;Effect callbacks are synchronous to prevent race conditions. &quot; </span><span class="s1">+ </span><span class="s2">&quot;Put the async function inside:</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">'useEffect(() =&gt; {</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'  async function fetchData() {</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'    // You can await here</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'    const response = await MyAPI.getData(someId);</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'    // ...</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'  }</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">'  fetchData();</span><span class="s5">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">&quot;}, [someId]); // Or [] if effect doesn't need props or state</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+ </span><span class="s2">'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching'</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s0">// Get the current scope.</span>


      <span class="s3">var </span><span class="s1">scope = scopeManager.acquire(node); </span><span class="s0">// Find all our &quot;pure scopes&quot;. On every re-render of a component these</span>
      <span class="s0">// pure scopes may have changes to the variables declared within. So all</span>
      <span class="s0">// variables used in our reactive hook callback but declared in a pure</span>
      <span class="s0">// scope need to be listed as dependencies of our reactive hook callback.</span>
      <span class="s0">//</span>
      <span class="s0">// According to the rules of React you can't read a mutable value in pure</span>
      <span class="s0">// scope. We can't enforce this in a lint so we trust that all variables</span>
      <span class="s0">// declared outside of pure scope are indeed frozen.</span>

      <span class="s3">var </span><span class="s1">pureScopes = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s3">var </span><span class="s1">componentScope = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">currentScope = scope.upper;</span>

        <span class="s3">while </span><span class="s1">(currentScope) {</span>
          <span class="s1">pureScopes.add(currentScope);</span>

          <span class="s3">if </span><span class="s1">(currentScope.type === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">currentScope = currentScope.upper;</span>
        <span class="s1">} </span><span class="s0">// If there is no parent function scope then there are no pure scopes.</span>
        <span class="s0">// The ones we've collected so far are incorrect. So don't continue with</span>
        <span class="s0">// the lint.</span>


        <span class="s3">if </span><span class="s1">(!currentScope) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">componentScope = currentScope;</span>
      <span class="s1">}</span>
      <span class="s3">var </span><span class="s1">isArray = Array.isArray; </span><span class="s0">// Next we'll define a few helpers that helps us</span>
      <span class="s0">// tell if some values don't have to be declared as deps.</span>
      <span class="s0">// Some are known to be stable based on Hook calls.</span>
      <span class="s0">// const [state, setState] = useState() / React.useState()</span>
      <span class="s0">//               ^^^ true for this reference</span>
      <span class="s0">// const [state, dispatch] = useReducer() / React.useReducer()</span>
      <span class="s0">//               ^^^ true for this reference</span>
      <span class="s0">// const ref = useRef()</span>
      <span class="s0">//       ^^^ true for this reference</span>
      <span class="s0">// False for everything else.</span>

      <span class="s3">function </span><span class="s1">isStableKnownHookValue(resolved) {</span>
        <span class="s3">if </span><span class="s1">(!isArray(resolved.defs)) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">def = resolved.defs[</span><span class="s4">0</span><span class="s1">];</span>

        <span class="s3">if </span><span class="s1">(def == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Look for `let stuff = ...`</span>


        <span class="s3">if </span><span class="s1">(def.node.type !== </span><span class="s2">'VariableDeclarator'</span><span class="s1">) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">init = def.node.init;</span>

        <span class="s3">if </span><span class="s1">(init == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">while </span><span class="s1">(init.type === </span><span class="s2">'TSAsExpression'</span><span class="s1">) {</span>
          <span class="s1">init = init.expression;</span>
        <span class="s1">} </span><span class="s0">// Detect primitive constants</span>
        <span class="s0">// const foo = 42</span>


        <span class="s3">var </span><span class="s1">declaration = def.node.parent;</span>

        <span class="s3">if </span><span class="s1">(declaration == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s0">// This might happen if variable is declared after the callback.</span>
          <span class="s0">// In that case ESLint won't set up .parent refs.</span>
          <span class="s0">// So we'll set them up manually.</span>
          <span class="s1">fastFindReferenceWithParent(componentScope.block, def.node.id);</span>
          <span class="s1">declaration = def.node.parent;</span>

          <span class="s3">if </span><span class="s1">(declaration == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(declaration.kind === </span><span class="s2">'const' </span><span class="s1">&amp;&amp; init.type === </span><span class="s2">'Literal' </span><span class="s1">&amp;&amp; (</span><span class="s3">typeof </span><span class="s1">init.value === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">init.value === </span><span class="s2">'number' </span><span class="s1">|| init.value === </span><span class="s3">null</span><span class="s1">)) {</span>
          <span class="s0">// Definitely stable</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Detect known Hook calls</span>
        <span class="s0">// const [_, setState] = useState()</span>


        <span class="s3">if </span><span class="s1">(init.type !== </span><span class="s2">'CallExpression'</span><span class="s1">) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">callee = init.callee; </span><span class="s0">// Step into `= React.something` initializer.</span>

        <span class="s3">if </span><span class="s1">(callee.type === </span><span class="s2">'MemberExpression' </span><span class="s1">&amp;&amp; callee.object.name === </span><span class="s2">'React' </span><span class="s1">&amp;&amp; callee.property != </span><span class="s3">null </span><span class="s1">&amp;&amp; !callee.computed) {</span>
          <span class="s1">callee = callee.property;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(callee.type !== </span><span class="s2">'Identifier'</span><span class="s1">) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">id = def.node.id;</span>
        <span class="s3">var </span><span class="s1">_callee = callee,</span>
            <span class="s1">name = _callee.name;</span>

        <span class="s3">if </span><span class="s1">(name === </span><span class="s2">'useRef' </span><span class="s1">&amp;&amp; id.type === </span><span class="s2">'Identifier'</span><span class="s1">) {</span>
          <span class="s0">// useRef() return value is stable.</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(name === </span><span class="s2">'useState' </span><span class="s1">|| name === </span><span class="s2">'useReducer'</span><span class="s1">) {</span>
          <span class="s0">// Only consider second value in initializing tuple stable.</span>
          <span class="s3">if </span><span class="s1">(id.type === </span><span class="s2">'ArrayPattern' </span><span class="s1">&amp;&amp; id.elements.length === </span><span class="s4">2 </span><span class="s1">&amp;&amp; isArray(resolved.identifiers)) {</span>
            <span class="s0">// Is second tuple value the same reference we're checking?</span>
            <span class="s3">if </span><span class="s1">(id.elements[</span><span class="s4">1</span><span class="s1">] === resolved.identifiers[</span><span class="s4">0</span><span class="s1">]) {</span>
              <span class="s3">if </span><span class="s1">(name === </span><span class="s2">'useState'</span><span class="s1">) {</span>
                <span class="s3">var </span><span class="s1">references = resolved.references;</span>
                <span class="s3">var </span><span class="s1">writeCount = </span><span class="s4">0</span><span class="s1">;</span>

                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; references.length; i++) {</span>
                  <span class="s3">if </span><span class="s1">(references[i].isWrite()) {</span>
                    <span class="s1">writeCount++;</span>
                  <span class="s1">}</span>

                  <span class="s3">if </span><span class="s1">(writeCount &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                  <span class="s1">}</span>

                  <span class="s1">setStateCallSites.set(references[i].identifier, id.elements[</span><span class="s4">0</span><span class="s1">]);</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s0">// Setter is stable.</span>


              <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(id.elements[</span><span class="s4">0</span><span class="s1">] === resolved.identifiers[</span><span class="s4">0</span><span class="s1">]) {</span>
              <span class="s3">if </span><span class="s1">(name === </span><span class="s2">'useState'</span><span class="s1">) {</span>
                <span class="s3">var </span><span class="s1">_references = resolved.references;</span>

                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s1">; _i &lt; _references.length; _i++) {</span>
                  <span class="s1">stateVariables.add(_references[_i].identifier);</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s0">// State variable itself is dynamic.</span>


              <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(name === </span><span class="s2">'useTransition'</span><span class="s1">) {</span>
          <span class="s0">// Only consider second value in initializing tuple stable.</span>
          <span class="s3">if </span><span class="s1">(id.type === </span><span class="s2">'ArrayPattern' </span><span class="s1">&amp;&amp; id.elements.length === </span><span class="s4">2 </span><span class="s1">&amp;&amp; Array.isArray(resolved.identifiers)) {</span>
            <span class="s0">// Is second tuple value the same reference we're checking?</span>
            <span class="s3">if </span><span class="s1">(id.elements[</span><span class="s4">1</span><span class="s1">] === resolved.identifiers[</span><span class="s4">0</span><span class="s1">]) {</span>
              <span class="s0">// Setter is stable.</span>
              <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// By default assume it's dynamic.</span>


        <span class="s3">return false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Some are just functions that don't reference anything dynamic.</span>


      <span class="s3">function </span><span class="s1">isFunctionWithoutCapturedValues(resolved) {</span>
        <span class="s3">if </span><span class="s1">(!isArray(resolved.defs)) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">def = resolved.defs[</span><span class="s4">0</span><span class="s1">];</span>

        <span class="s3">if </span><span class="s1">(def == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(def.node == </span><span class="s3">null </span><span class="s1">|| def.node.id == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Search the direct component subscopes for</span>
        <span class="s0">// top-level function definitions matching this reference.</span>


        <span class="s3">var </span><span class="s1">fnNode = def.node;</span>
        <span class="s3">var </span><span class="s1">childScopes = componentScope.childScopes;</span>
        <span class="s3">var </span><span class="s1">fnScope = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">i;</span>

        <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; childScopes.length; i++) {</span>
          <span class="s3">var </span><span class="s1">childScope = childScopes[i];</span>
          <span class="s3">var </span><span class="s1">childScopeBlock = childScope.block;</span>

          <span class="s3">if </span><span class="s1">( </span><span class="s0">// function handleChange() {}</span>
          <span class="s1">fnNode.type === </span><span class="s2">'FunctionDeclaration' </span><span class="s1">&amp;&amp; childScopeBlock === fnNode || </span><span class="s0">// const handleChange = () =&gt; {}</span>
          <span class="s0">// const handleChange = function() {}</span>
          <span class="s1">fnNode.type === </span><span class="s2">'VariableDeclarator' </span><span class="s1">&amp;&amp; childScopeBlock.parent === fnNode) {</span>
            <span class="s0">// Found it!</span>
            <span class="s1">fnScope = childScope;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(fnScope == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Does this function capture any values</span>
        <span class="s0">// that are in pure scopes (aka render)?</span>


        <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; fnScope.through.length; i++) {</span>
          <span class="s3">var </span><span class="s1">ref = fnScope.through[i];</span>

          <span class="s3">if </span><span class="s1">(ref.resolved == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(pureScopes.has(ref.resolved.scope) &amp;&amp; </span><span class="s0">// Stable values are fine though,</span>
          <span class="s0">// although we won't check functions deeper.</span>
          <span class="s1">!memoizedIsStableKnownHookValue(ref.resolved)) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// If we got here, this function doesn't capture anything</span>
        <span class="s0">// from render--or everything it captures is known stable.</span>


        <span class="s3">return true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Remember such values. Avoid re-running extra checks on them.</span>


      <span class="s3">var </span><span class="s1">memoizedIsStableKnownHookValue = memoizeWithWeakMap(isStableKnownHookValue, stableKnownValueCache);</span>
      <span class="s3">var </span><span class="s1">memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache); </span><span class="s0">// These are usually mistaken. Collect them.</span>

      <span class="s3">var </span><span class="s1">currentRefsInEffectCleanup = </span><span class="s3">new </span><span class="s1">Map(); </span><span class="s0">// Is this reference inside a cleanup function for this effect node?</span>
      <span class="s0">// We can check by traversing scopes upwards  from the reference, and checking</span>
      <span class="s0">// if the last &quot;return () =&gt; &quot; we encounter is located directly inside the effect.</span>

      <span class="s3">function </span><span class="s1">isInsideEffectCleanup(reference) {</span>
        <span class="s3">var </span><span class="s1">curScope = reference.from;</span>
        <span class="s3">var </span><span class="s1">isInReturnedFunction = </span><span class="s3">false</span><span class="s1">;</span>

        <span class="s3">while </span><span class="s1">(curScope.block !== node) {</span>
          <span class="s3">if </span><span class="s1">(curScope.type === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">isInReturnedFunction = curScope.block.parent != </span><span class="s3">null </span><span class="s1">&amp;&amp; curScope.block.parent.type === </span><span class="s2">'ReturnStatement'</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">curScope = curScope.upper;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">isInReturnedFunction;</span>
      <span class="s1">} </span><span class="s0">// Get dependencies from all our resolved references in pure scopes.</span>
      <span class="s0">// Key is dependency string, value is whether it's stable.</span>


      <span class="s3">var </span><span class="s1">dependencies = </span><span class="s3">new </span><span class="s1">Map();</span>
      <span class="s3">var </span><span class="s1">optionalChains = </span><span class="s3">new </span><span class="s1">Map();</span>
      <span class="s1">gatherDependenciesRecursively(scope);</span>

      <span class="s3">function </span><span class="s1">gatherDependenciesRecursively(currentScope) {</span>
        <span class="s3">var </span><span class="s1">_iterator = _createForOfIteratorHelper(currentScope.references),</span>
            <span class="s1">_step;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">for </span><span class="s1">(_iterator.s(); !(_step = _iterator.n()).done;) {</span>
            <span class="s3">var </span><span class="s1">reference = _step.value;</span>

            <span class="s0">// If this reference is not resolved or it is not declared in a pure</span>
            <span class="s0">// scope then we don't care about this reference.</span>
            <span class="s3">if </span><span class="s1">(!reference.resolved) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(!pureScopes.has(reference.resolved.scope)) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s0">// Narrow the scope of a dependency if it is, say, a member expression.</span>
            <span class="s0">// Then normalize the narrowed dependency.</span>


            <span class="s3">var </span><span class="s1">referenceNode = fastFindReferenceWithParent(node, reference.identifier);</span>
            <span class="s3">var </span><span class="s1">dependencyNode = getDependency(referenceNode);</span>
            <span class="s3">var </span><span class="s1">dependency = analyzePropertyChain(dependencyNode, optionalChains); </span><span class="s0">// Accessing ref.current inside effect cleanup is bad.</span>

            <span class="s3">if </span><span class="s1">( </span><span class="s0">// We're in an effect...</span>
            <span class="s1">isEffect &amp;&amp; </span><span class="s0">// ... and this look like accessing .current...</span>
            <span class="s1">dependencyNode.type === </span><span class="s2">'Identifier' </span><span class="s1">&amp;&amp; (dependencyNode.parent.type === </span><span class="s2">'MemberExpression' </span><span class="s1">|| dependencyNode.parent.type === </span><span class="s2">'OptionalMemberExpression'</span><span class="s1">) &amp;&amp; !dependencyNode.parent.computed &amp;&amp; dependencyNode.parent.property.type === </span><span class="s2">'Identifier' </span><span class="s1">&amp;&amp; dependencyNode.parent.property.name === </span><span class="s2">'current' </span><span class="s1">&amp;&amp; </span><span class="s0">// ...in a cleanup function or below...</span>
            <span class="s1">isInsideEffectCleanup(reference)) {</span>
              <span class="s1">currentRefsInEffectCleanup.set(dependency, {</span>
                <span class="s1">reference: reference,</span>
                <span class="s1">dependencyNode: dependencyNode</span>
              <span class="s1">});</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(dependencyNode.parent.type === </span><span class="s2">'TSTypeQuery' </span><span class="s1">|| dependencyNode.parent.type === </span><span class="s2">'TSTypeReference'</span><span class="s1">) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">def = reference.resolved.defs[</span><span class="s4">0</span><span class="s1">];</span>

            <span class="s3">if </span><span class="s1">(def == </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s0">// Ignore references to the function itself as it's not defined yet.</span>


            <span class="s3">if </span><span class="s1">(def.node != </span><span class="s3">null </span><span class="s1">&amp;&amp; def.node.init === node.parent) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s0">// Ignore Flow type parameters</span>


            <span class="s3">if </span><span class="s1">(def.type === </span><span class="s2">'TypeParameter'</span><span class="s1">) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s0">// Add the dependency to a map so we can make sure it is referenced</span>
            <span class="s0">// again in our dependencies array. Remember whether it's stable.</span>


            <span class="s3">if </span><span class="s1">(!dependencies.has(dependency)) {</span>
              <span class="s3">var </span><span class="s1">resolved = reference.resolved;</span>
              <span class="s3">var </span><span class="s1">isStable = memoizedIsStableKnownHookValue(resolved) || memoizedIsFunctionWithoutCapturedValues(resolved);</span>
              <span class="s1">dependencies.set(dependency, {</span>
                <span class="s1">isStable: isStable,</span>
                <span class="s1">references: [reference]</span>
              <span class="s1">});</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s1">dependencies.get(dependency).references.push(reference);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
          <span class="s1">_iterator.e(err);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">_iterator.f();</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">_iterator2 = _createForOfIteratorHelper(currentScope.childScopes),</span>
            <span class="s1">_step2;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">for </span><span class="s1">(_iterator2.s(); !(_step2 = _iterator2.n()).done;) {</span>
            <span class="s3">var </span><span class="s1">childScope = _step2.value;</span>
            <span class="s1">gatherDependenciesRecursively(childScope);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
          <span class="s1">_iterator2.e(err);</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">_iterator2.f();</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// Warn about accessing .current in cleanup effects.</span>


      <span class="s1">currentRefsInEffectCleanup.forEach(</span><span class="s3">function </span><span class="s1">(_ref, dependency) {</span>
        <span class="s3">var </span><span class="s1">reference = _ref.reference,</span>
            <span class="s1">dependencyNode = _ref.dependencyNode;</span>
        <span class="s3">var </span><span class="s1">references = reference.resolved.references; </span><span class="s0">// Is React managing this ref or us?</span>
        <span class="s0">// Let's see if we can find a .current assignment.</span>

        <span class="s3">var </span><span class="s1">foundCurrentAssignment = </span><span class="s3">false</span><span class="s1">;</span>

        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; references.length; i++) {</span>
          <span class="s3">var </span><span class="s1">identifier = references[i].identifier;</span>
          <span class="s3">var </span><span class="s1">parent = identifier.parent;</span>

          <span class="s3">if </span><span class="s1">(parent != </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s0">// ref.current</span>
          <span class="s0">// Note: no need to handle OptionalMemberExpression because it can't be LHS.</span>
          <span class="s1">parent.type === </span><span class="s2">'MemberExpression' </span><span class="s1">&amp;&amp; !parent.computed &amp;&amp; parent.property.type === </span><span class="s2">'Identifier' </span><span class="s1">&amp;&amp; parent.property.name === </span><span class="s2">'current' </span><span class="s1">&amp;&amp; </span><span class="s0">// ref.current = &lt;something&gt;</span>
          <span class="s1">parent.parent.type === </span><span class="s2">'AssignmentExpression' </span><span class="s1">&amp;&amp; parent.parent.left === parent) {</span>
            <span class="s1">foundCurrentAssignment = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">// We only want to warn about React-managed refs.</span>


        <span class="s3">if </span><span class="s1">(foundCurrentAssignment) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">reportProblem({</span>
          <span class="s1">node: dependencyNode.parent.property,</span>
          <span class="s1">message: </span><span class="s2">&quot;The ref value '&quot; </span><span class="s1">+ dependency + </span><span class="s2">&quot;.current' will likely have &quot; </span><span class="s1">+ </span><span class="s2">&quot;changed by the time this effect cleanup function runs. If &quot; </span><span class="s1">+ </span><span class="s2">&quot;this ref points to a node rendered by React, copy &quot; </span><span class="s1">+ (</span><span class="s2">&quot;'&quot; </span><span class="s1">+ dependency + </span><span class="s2">&quot;.current' to a variable inside the effect, and &quot;</span><span class="s1">) + </span><span class="s2">&quot;use that variable in the cleanup function.&quot;</span>
        <span class="s1">});</span>
      <span class="s1">}); </span><span class="s0">// Warn about assigning to variables in the outer scope.</span>
      <span class="s0">// Those are usually bugs.</span>

      <span class="s3">var </span><span class="s1">staleAssignments = </span><span class="s3">new </span><span class="s1">Set();</span>

      <span class="s3">function </span><span class="s1">reportStaleAssignment(writeExpr, key) {</span>
        <span class="s3">if </span><span class="s1">(staleAssignments.has(key)) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">staleAssignments.add(key);</span>
        <span class="s1">reportProblem({</span>
          <span class="s1">node: writeExpr,</span>
          <span class="s1">message: </span><span class="s2">&quot;Assignments to the '&quot; </span><span class="s1">+ key + </span><span class="s2">&quot;' variable from inside React Hook &quot; </span><span class="s1">+ (context.getSource(reactiveHook) + </span><span class="s2">&quot; will be lost after each &quot;</span><span class="s1">) + </span><span class="s2">&quot;render. To preserve the value over time, store it in a useRef &quot; </span><span class="s1">+ </span><span class="s2">&quot;Hook and keep the mutable value in the '.current' property. &quot; </span><span class="s1">+ </span><span class="s2">&quot;Otherwise, you can move this variable directly inside &quot; </span><span class="s1">+ (context.getSource(reactiveHook) + </span><span class="s2">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s0">// Remember which deps are stable and report bad usage first.</span>


      <span class="s3">var </span><span class="s1">stableDependencies = </span><span class="s3">new </span><span class="s1">Set();</span>
      <span class="s1">dependencies.forEach(</span><span class="s3">function </span><span class="s1">(_ref2, key) {</span>
        <span class="s3">var </span><span class="s1">isStable = _ref2.isStable,</span>
            <span class="s1">references = _ref2.references;</span>

        <span class="s3">if </span><span class="s1">(isStable) {</span>
          <span class="s1">stableDependencies.add(key);</span>
        <span class="s1">}</span>

        <span class="s1">references.forEach(</span><span class="s3">function </span><span class="s1">(reference) {</span>
          <span class="s3">if </span><span class="s1">(reference.writeExpr) {</span>
            <span class="s1">reportStaleAssignment(reference.writeExpr, key);</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">});</span>

      <span class="s3">if </span><span class="s1">(staleAssignments.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">// The intent isn't clear so we'll wait until you fix those first.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!declaredDependenciesNode) {</span>
        <span class="s0">// Check if there are any top-level setState() calls.</span>
        <span class="s0">// Those tend to lead to infinite loops.</span>
        <span class="s3">var </span><span class="s1">setStateInsideEffectWithoutDeps = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">dependencies.forEach(</span><span class="s3">function </span><span class="s1">(_ref3, key) {</span>
          <span class="s3">var </span><span class="s1">isStable = _ref3.isStable,</span>
              <span class="s1">references = _ref3.references;</span>

          <span class="s3">if </span><span class="s1">(setStateInsideEffectWithoutDeps) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">references.forEach(</span><span class="s3">function </span><span class="s1">(reference) {</span>
            <span class="s3">if </span><span class="s1">(setStateInsideEffectWithoutDeps) {</span>
              <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">id = reference.identifier;</span>
            <span class="s3">var </span><span class="s1">isSetState = setStateCallSites.has(id);</span>

            <span class="s3">if </span><span class="s1">(!isSetState) {</span>
              <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">fnScope = reference.from;</span>

            <span class="s3">while </span><span class="s1">(fnScope.type !== </span><span class="s2">'function'</span><span class="s1">) {</span>
              <span class="s1">fnScope = fnScope.upper;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">isDirectlyInsideEffect = fnScope.block === node;</span>

            <span class="s3">if </span><span class="s1">(isDirectlyInsideEffect) {</span>
              <span class="s0">// TODO: we could potentially ignore early returns.</span>
              <span class="s1">setStateInsideEffectWithoutDeps = key;</span>
            <span class="s1">}</span>
          <span class="s1">});</span>
        <span class="s1">});</span>

        <span class="s3">if </span><span class="s1">(setStateInsideEffectWithoutDeps) {</span>
          <span class="s3">var </span><span class="s1">_collectRecommendatio = collectRecommendations({</span>
            <span class="s1">dependencies: dependencies,</span>
            <span class="s1">declaredDependencies: [],</span>
            <span class="s1">stableDependencies: stableDependencies,</span>
            <span class="s1">externalDependencies: </span><span class="s3">new </span><span class="s1">Set(),</span>
            <span class="s1">isEffect: </span><span class="s3">true</span>
          <span class="s1">}),</span>
              <span class="s1">_suggestedDependencies = _collectRecommendatio.suggestedDependencies;</span>

          <span class="s1">reportProblem({</span>
            <span class="s1">node: reactiveHook,</span>
            <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ reactiveHookName + </span><span class="s2">&quot; contains a call to '&quot; </span><span class="s1">+ setStateInsideEffectWithoutDeps + </span><span class="s2">&quot;'. &quot; </span><span class="s1">+ </span><span class="s2">&quot;Without a list of dependencies, this can lead to an infinite chain of updates. &quot; </span><span class="s1">+ </span><span class="s2">&quot;To fix this, pass [&quot; </span><span class="s1">+ _suggestedDependencies.join(</span><span class="s2">', '</span><span class="s1">) + (</span><span class="s2">&quot;] as a second argument to the &quot; </span><span class="s1">+ reactiveHookName + </span><span class="s2">&quot; Hook.&quot;</span><span class="s1">),</span>
            <span class="s1">suggest: [{</span>
              <span class="s1">desc: </span><span class="s2">&quot;Add dependencies array: [&quot; </span><span class="s1">+ _suggestedDependencies.join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span><span class="s1">,</span>
              <span class="s1">fix: </span><span class="s3">function </span><span class="s1">(fixer) {</span>
                <span class="s3">return </span><span class="s1">fixer.insertTextAfter(node, </span><span class="s2">&quot;, [&quot; </span><span class="s1">+ _suggestedDependencies.join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span><span class="s1">);</span>
              <span class="s1">}</span>
            <span class="s1">}]</span>
          <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">declaredDependencies = [];</span>
      <span class="s3">var </span><span class="s1">externalDependencies = </span><span class="s3">new </span><span class="s1">Set();</span>

      <span class="s3">if </span><span class="s1">(declaredDependenciesNode.type !== </span><span class="s2">'ArrayExpression'</span><span class="s1">) {</span>
        <span class="s0">// If the declared dependencies are not an array expression then we</span>
        <span class="s0">// can't verify that the user provided the correct dependencies. Tell</span>
        <span class="s0">// the user this in an error.</span>
        <span class="s1">reportProblem({</span>
          <span class="s1">node: declaredDependenciesNode,</span>
          <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ context.getSource(reactiveHook) + </span><span class="s2">&quot; was passed a &quot; </span><span class="s1">+ </span><span class="s2">'dependency list that is not an array literal. This means we ' </span><span class="s1">+ </span><span class="s2">&quot;can't statically verify whether you've passed the correct &quot; </span><span class="s1">+ </span><span class="s2">'dependencies.'</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">declaredDependenciesNode.elements.forEach(</span><span class="s3">function </span><span class="s1">(declaredDependencyNode) {</span>
          <span class="s0">// Skip elided elements.</span>
          <span class="s3">if </span><span class="s1">(declaredDependencyNode === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// If we see a spread element then add a special warning.</span>


          <span class="s3">if </span><span class="s1">(declaredDependencyNode.type === </span><span class="s2">'SpreadElement'</span><span class="s1">) {</span>
            <span class="s1">reportProblem({</span>
              <span class="s1">node: declaredDependencyNode,</span>
              <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ context.getSource(reactiveHook) + </span><span class="s2">&quot; has a spread &quot; </span><span class="s1">+ </span><span class="s2">&quot;element in its dependency array. This means we can't &quot; </span><span class="s1">+ </span><span class="s2">&quot;statically verify whether you've passed the &quot; </span><span class="s1">+ </span><span class="s2">'correct dependencies.'</span>
            <span class="s1">});</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Try to normalize the declared dependency. If we can't then an error</span>
          <span class="s0">// will be thrown. We will catch that error and report an error.</span>


          <span class="s3">var </span><span class="s1">declaredDependency;</span>

          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">declaredDependency = analyzePropertyChain(declaredDependencyNode, </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
            <span class="s3">if </span><span class="s1">(/Unsupported node type/.test(error.message)) {</span>
              <span class="s3">if </span><span class="s1">(declaredDependencyNode.type === </span><span class="s2">'Literal'</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(dependencies.has(declaredDependencyNode.value)) {</span>
                  <span class="s1">reportProblem({</span>
                    <span class="s1">node: declaredDependencyNode,</span>
                    <span class="s1">message: </span><span class="s2">&quot;The &quot; </span><span class="s1">+ declaredDependencyNode.raw + </span><span class="s2">&quot; literal is not a valid dependency &quot; </span><span class="s1">+ </span><span class="s2">&quot;because it never changes. &quot; </span><span class="s1">+ (</span><span class="s2">&quot;Did you mean to include &quot; </span><span class="s1">+ declaredDependencyNode.value + </span><span class="s2">&quot; in the array instead?&quot;</span><span class="s1">)</span>
                  <span class="s1">});</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                  <span class="s1">reportProblem({</span>
                    <span class="s1">node: declaredDependencyNode,</span>
                    <span class="s1">message: </span><span class="s2">&quot;The &quot; </span><span class="s1">+ declaredDependencyNode.raw + </span><span class="s2">&quot; literal is not a valid dependency &quot; </span><span class="s1">+ </span><span class="s2">'because it never changes. You can safely remove it.'</span>
                  <span class="s1">});</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">reportProblem({</span>
                  <span class="s1">node: declaredDependencyNode,</span>
                  <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ context.getSource(reactiveHook) + </span><span class="s2">&quot; has a &quot; </span><span class="s1">+ </span><span class="s2">&quot;complex expression in the dependency array. &quot; </span><span class="s1">+ </span><span class="s2">'Extract it to a separate variable so it can be statically checked.'</span>
                <span class="s1">});</span>
              <span class="s1">}</span>

              <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
              <span class="s3">throw </span><span class="s1">error;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">maybeID = declaredDependencyNode;</span>

          <span class="s3">while </span><span class="s1">(maybeID.type === </span><span class="s2">'MemberExpression' </span><span class="s1">|| maybeID.type === </span><span class="s2">'OptionalMemberExpression' </span><span class="s1">|| maybeID.type === </span><span class="s2">'ChainExpression'</span><span class="s1">) {</span>
            <span class="s1">maybeID = maybeID.object || maybeID.expression.object;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">isDeclaredInComponent = !componentScope.through.some(</span><span class="s3">function </span><span class="s1">(ref) {</span>
            <span class="s3">return </span><span class="s1">ref.identifier === maybeID;</span>
          <span class="s1">}); </span><span class="s0">// Add the dependency to our declared dependency map.</span>

          <span class="s1">declaredDependencies.push({</span>
            <span class="s1">key: declaredDependency,</span>
            <span class="s1">node: declaredDependencyNode</span>
          <span class="s1">});</span>

          <span class="s3">if </span><span class="s1">(!isDeclaredInComponent) {</span>
            <span class="s1">externalDependencies.add(declaredDependency);</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">_collectRecommendatio2 = collectRecommendations({</span>
        <span class="s1">dependencies: dependencies,</span>
        <span class="s1">declaredDependencies: declaredDependencies,</span>
        <span class="s1">stableDependencies: stableDependencies,</span>
        <span class="s1">externalDependencies: externalDependencies,</span>
        <span class="s1">isEffect: isEffect</span>
      <span class="s1">}),</span>
          <span class="s1">suggestedDependencies = _collectRecommendatio2.suggestedDependencies,</span>
          <span class="s1">unnecessaryDependencies = _collectRecommendatio2.unnecessaryDependencies,</span>
          <span class="s1">missingDependencies = _collectRecommendatio2.missingDependencies,</span>
          <span class="s1">duplicateDependencies = _collectRecommendatio2.duplicateDependencies;</span>

      <span class="s3">var </span><span class="s1">suggestedDeps = suggestedDependencies;</span>
      <span class="s3">var </span><span class="s1">problemCount = duplicateDependencies.size + missingDependencies.size + unnecessaryDependencies.size;</span>

      <span class="s3">if </span><span class="s1">(problemCount === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">// If nothing else to report, check if some dependencies would</span>
        <span class="s0">// invalidate on every render.</span>
        <span class="s3">var </span><span class="s1">constructions = scanForConstructions({</span>
          <span class="s1">declaredDependencies: declaredDependencies,</span>
          <span class="s1">declaredDependenciesNode: declaredDependenciesNode,</span>
          <span class="s1">componentScope: componentScope,</span>
          <span class="s1">scope: scope</span>
        <span class="s1">});</span>
        <span class="s1">constructions.forEach(</span><span class="s3">function </span><span class="s1">(_ref4) {</span>
          <span class="s3">var </span><span class="s1">construction = _ref4.construction,</span>
              <span class="s1">isUsedOutsideOfHook = _ref4.isUsedOutsideOfHook,</span>
              <span class="s1">depType = _ref4.depType;</span>
          <span class="s3">var </span><span class="s1">wrapperHook = depType === </span><span class="s2">'function' </span><span class="s1">? </span><span class="s2">'useCallback' </span><span class="s1">: </span><span class="s2">'useMemo'</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">constructionType = depType === </span><span class="s2">'function' </span><span class="s1">? </span><span class="s2">'definition' </span><span class="s1">: </span><span class="s2">'initialization'</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">defaultAdvice = </span><span class="s2">&quot;wrap the &quot; </span><span class="s1">+ constructionType + </span><span class="s2">&quot; of '&quot; </span><span class="s1">+ construction.name.name + </span><span class="s2">&quot;' in its own &quot; </span><span class="s1">+ wrapperHook + </span><span class="s2">&quot;() Hook.&quot;</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">advice = isUsedOutsideOfHook ? </span><span class="s2">&quot;To fix this, &quot; </span><span class="s1">+ defaultAdvice : </span><span class="s2">&quot;Move it inside the &quot; </span><span class="s1">+ reactiveHookName + </span><span class="s2">&quot; callback. Alternatively, &quot; </span><span class="s1">+ defaultAdvice;</span>
          <span class="s3">var </span><span class="s1">causation = depType === </span><span class="s2">'conditional' </span><span class="s1">|| depType === </span><span class="s2">'logical expression' </span><span class="s1">? </span><span class="s2">'could make' </span><span class="s1">: </span><span class="s2">'makes'</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">message = </span><span class="s2">&quot;The '&quot; </span><span class="s1">+ construction.name.name + </span><span class="s2">&quot;' &quot; </span><span class="s1">+ depType + </span><span class="s2">&quot; &quot; </span><span class="s1">+ causation + </span><span class="s2">&quot; the dependencies of &quot; </span><span class="s1">+ (reactiveHookName + </span><span class="s2">&quot; Hook (at line &quot; </span><span class="s1">+ declaredDependenciesNode.loc.start.line + </span><span class="s2">&quot;) &quot;</span><span class="s1">) + (</span><span class="s2">&quot;change on every render. &quot; </span><span class="s1">+ advice);</span>
          <span class="s3">var </span><span class="s1">suggest; </span><span class="s0">// Only handle the simple case of variable assignments.</span>
          <span class="s0">// Wrapping function declarations can mess up hoisting.</span>

          <span class="s3">if </span><span class="s1">(isUsedOutsideOfHook &amp;&amp; construction.type === </span><span class="s2">'Variable' </span><span class="s1">&amp;&amp; </span><span class="s0">// Objects may be mutated after construction, which would make this</span>
          <span class="s0">// fix unsafe. Functions _probably_ won't be mutated, so we'll</span>
          <span class="s0">// allow this fix for them.</span>
          <span class="s1">depType === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">suggest = [{</span>
              <span class="s1">desc: </span><span class="s2">&quot;Wrap the &quot; </span><span class="s1">+ constructionType + </span><span class="s2">&quot; of '&quot; </span><span class="s1">+ construction.name.name + </span><span class="s2">&quot;' in its own &quot; </span><span class="s1">+ wrapperHook + </span><span class="s2">&quot;() Hook.&quot;</span><span class="s1">,</span>
              <span class="s1">fix: </span><span class="s3">function </span><span class="s1">(fixer) {</span>
                <span class="s3">var </span><span class="s1">_ref5 = wrapperHook === </span><span class="s2">'useMemo' </span><span class="s1">? [</span><span class="s2">&quot;useMemo(() =&gt; { return &quot;</span><span class="s1">, </span><span class="s2">'; })'</span><span class="s1">] : [</span><span class="s2">'useCallback('</span><span class="s1">, </span><span class="s2">')'</span><span class="s1">],</span>
                    <span class="s1">before = _ref5[</span><span class="s4">0</span><span class="s1">],</span>
                    <span class="s1">after = _ref5[</span><span class="s4">1</span><span class="s1">];</span>

                <span class="s3">return </span><span class="s1">[</span><span class="s0">// TODO: also add an import?</span>
                <span class="s1">fixer.insertTextBefore(construction.node.init, before), </span><span class="s0">// TODO: ideally we'd gather deps here but it would require</span>
                <span class="s0">// restructuring the rule code. This will cause a new lint</span>
                <span class="s0">// error to appear immediately for useCallback. Note we're</span>
                <span class="s0">// not adding [] because would that changes semantics.</span>
                <span class="s1">fixer.insertTextAfter(construction.node.init, after)];</span>
              <span class="s1">}</span>
            <span class="s1">}];</span>
          <span class="s1">} </span><span class="s0">// TODO: What if the function needs to change on every render anyway?</span>
          <span class="s0">// Should we suggest removing effect deps as an appropriate fix too?</span>


          <span class="s1">reportProblem({</span>
            <span class="s0">// TODO: Why not report this at the dependency site?</span>
            <span class="s1">node: construction.node,</span>
            <span class="s1">message: message,</span>
            <span class="s1">suggest: suggest</span>
          <span class="s1">});</span>
        <span class="s1">});</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// If we're going to report a missing dependency,</span>
      <span class="s0">// we might as well recalculate the list ignoring</span>
      <span class="s0">// the currently specified deps. This can result</span>
      <span class="s0">// in some extra deduplication. We can't do this</span>
      <span class="s0">// for effects though because those have legit</span>
      <span class="s0">// use cases for over-specifying deps.</span>


      <span class="s3">if </span><span class="s1">(!isEffect &amp;&amp; missingDependencies.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">suggestedDeps = collectRecommendations({</span>
          <span class="s1">dependencies: dependencies,</span>
          <span class="s1">declaredDependencies: [],</span>
          <span class="s0">// Pretend we don't know</span>
          <span class="s1">stableDependencies: stableDependencies,</span>
          <span class="s1">externalDependencies: externalDependencies,</span>
          <span class="s1">isEffect: isEffect</span>
        <span class="s1">}).suggestedDependencies;</span>
      <span class="s1">} </span><span class="s0">// Alphabetize the suggestions, but only if deps were already alphabetized.</span>


      <span class="s3">function </span><span class="s1">areDeclaredDepsAlphabetized() {</span>
        <span class="s3">if </span><span class="s1">(declaredDependencies.length === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">declaredDepKeys = declaredDependencies.map(</span><span class="s3">function </span><span class="s1">(dep) {</span>
          <span class="s3">return </span><span class="s1">dep.key;</span>
        <span class="s1">});</span>
        <span class="s3">var </span><span class="s1">sortedDeclaredDepKeys = declaredDepKeys.slice().sort();</span>
        <span class="s3">return </span><span class="s1">declaredDepKeys.join(</span><span class="s2">','</span><span class="s1">) === sortedDeclaredDepKeys.join(</span><span class="s2">','</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(areDeclaredDepsAlphabetized()) {</span>
        <span class="s1">suggestedDeps.sort();</span>
      <span class="s1">} </span><span class="s0">// Most of our algorithm deals with dependency paths with optional chaining stripped.</span>
      <span class="s0">// This function is the last step before printing a dependency, so now is a good time to</span>
      <span class="s0">// check whether any members in our path are always used as optional-only. In that case,</span>
      <span class="s0">// we will use ?. instead of . to concatenate those parts of the path.</span>


      <span class="s3">function </span><span class="s1">formatDependency(path) {</span>
        <span class="s3">var </span><span class="s1">members = path.split(</span><span class="s2">'.'</span><span class="s1">);</span>
        <span class="s3">var </span><span class="s1">finalPath = </span><span class="s2">''</span><span class="s1">;</span>

        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; members.length; i++) {</span>
          <span class="s3">if </span><span class="s1">(i !== </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">pathSoFar = members.slice(</span><span class="s4">0</span><span class="s1">, i + </span><span class="s4">1</span><span class="s1">).join(</span><span class="s2">'.'</span><span class="s1">);</span>
            <span class="s3">var </span><span class="s1">isOptional = optionalChains.get(pathSoFar) === </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">finalPath += isOptional ? </span><span class="s2">'?.' </span><span class="s1">: </span><span class="s2">'.'</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">finalPath += members[i];</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">finalPath;</span>
      <span class="s1">}</span>

      <span class="s3">function </span><span class="s1">getWarningMessage(deps, singlePrefix, label, fixVerb) {</span>
        <span class="s3">if </span><span class="s1">(deps.size === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">(deps.size &gt; </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: singlePrefix + </span><span class="s2">' '</span><span class="s1">) + label + </span><span class="s2">' ' </span><span class="s1">+ (deps.size &gt; </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">'dependencies' </span><span class="s1">: </span><span class="s2">'dependency'</span><span class="s1">) + </span><span class="s2">': ' </span><span class="s1">+ joinEnglish(Array.from(deps).sort().map(</span><span class="s3">function </span><span class="s1">(name) {</span>
          <span class="s3">return </span><span class="s2">&quot;'&quot; </span><span class="s1">+ formatDependency(name) + </span><span class="s2">&quot;'&quot;</span><span class="s1">;</span>
        <span class="s1">})) + (</span><span class="s2">&quot;. Either &quot; </span><span class="s1">+ fixVerb + </span><span class="s2">&quot; &quot; </span><span class="s1">+ (deps.size &gt; </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">'them' </span><span class="s1">: </span><span class="s2">'it'</span><span class="s1">) + </span><span class="s2">&quot; or remove the dependency array.&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">extraWarning = </span><span class="s2">''</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(unnecessaryDependencies.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">badRef = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">Array.from(unnecessaryDependencies.keys()).forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
          <span class="s3">if </span><span class="s1">(badRef !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(key.endsWith(</span><span class="s2">'.current'</span><span class="s1">)) {</span>
            <span class="s1">badRef = key;</span>
          <span class="s1">}</span>
        <span class="s1">});</span>

        <span class="s3">if </span><span class="s1">(badRef !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">extraWarning = </span><span class="s2">&quot; Mutable values like '&quot; </span><span class="s1">+ badRef + </span><span class="s2">&quot;' aren't valid dependencies &quot; </span><span class="s1">+ </span><span class="s2">&quot;because mutating them doesn't re-render the component.&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(externalDependencies.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s3">var </span><span class="s1">dep = Array.from(externalDependencies)[</span><span class="s4">0</span><span class="s1">]; </span><span class="s0">// Don't show this warning for things that likely just got moved *inside* the callback</span>
          <span class="s0">// because in that case they're clearly not referring to globals.</span>

          <span class="s3">if </span><span class="s1">(!scope.set.has(dep)) {</span>
            <span class="s1">extraWarning = </span><span class="s2">&quot; Outer scope values like '&quot; </span><span class="s1">+ dep + </span><span class="s2">&quot;' aren't valid dependencies &quot; </span><span class="s1">+ </span><span class="s2">&quot;because mutating them doesn't re-render the component.&quot;</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">// `props.foo()` marks `props` as a dependency because it has</span>
      <span class="s0">// a `this` value. This warning can be confusing.</span>
      <span class="s0">// So if we're going to show it, append a clarification.</span>


      <span class="s3">if </span><span class="s1">(!extraWarning &amp;&amp; missingDependencies.has(</span><span class="s2">'props'</span><span class="s1">)) {</span>
        <span class="s3">var </span><span class="s1">propDep = dependencies.get(</span><span class="s2">'props'</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(propDep == </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">refs = propDep.references;</span>

        <span class="s3">if </span><span class="s1">(!Array.isArray(refs)) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">isPropsOnlyUsedInMembers = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; refs.length; i++) {</span>
          <span class="s3">var </span><span class="s1">ref = refs[i];</span>
          <span class="s3">var </span><span class="s1">id = fastFindReferenceWithParent(componentScope.block, ref.identifier);</span>

          <span class="s3">if </span><span class="s1">(!id) {</span>
            <span class="s1">isPropsOnlyUsedInMembers = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">parent = id.parent;</span>

          <span class="s3">if </span><span class="s1">(parent == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">isPropsOnlyUsedInMembers = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(parent.type !== </span><span class="s2">'MemberExpression' </span><span class="s1">&amp;&amp; parent.type !== </span><span class="s2">'OptionalMemberExpression'</span><span class="s1">) {</span>
            <span class="s1">isPropsOnlyUsedInMembers = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(isPropsOnlyUsedInMembers) {</span>
          <span class="s1">extraWarning = </span><span class="s2">&quot; However, 'props' will change when *any* prop changes, so the &quot; </span><span class="s1">+ </span><span class="s2">&quot;preferred fix is to destructure the 'props' object outside of &quot; </span><span class="s1">+ (</span><span class="s2">&quot;the &quot; </span><span class="s1">+ reactiveHookName + </span><span class="s2">&quot; call and refer to those specific props &quot;</span><span class="s1">) + (</span><span class="s2">&quot;inside &quot; </span><span class="s1">+ context.getSource(reactiveHook) + </span><span class="s2">&quot;.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!extraWarning &amp;&amp; missingDependencies.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">// See if the user is trying to avoid specifying a callable prop.</span>
        <span class="s0">// This usually means they're unaware of useCallback.</span>
        <span class="s3">var </span><span class="s1">missingCallbackDep = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">missingDependencies.forEach(</span><span class="s3">function </span><span class="s1">(missingDep) {</span>
          <span class="s3">if </span><span class="s1">(missingCallbackDep) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Is this a variable from top scope?</span>


          <span class="s3">var </span><span class="s1">topScopeRef = componentScope.set.get(missingDep);</span>
          <span class="s3">var </span><span class="s1">usedDep = dependencies.get(missingDep);</span>

          <span class="s3">if </span><span class="s1">(usedDep.references[</span><span class="s4">0</span><span class="s1">].resolved !== topScopeRef) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Is this a destructured prop?</span>


          <span class="s3">var </span><span class="s1">def = topScopeRef.defs[</span><span class="s4">0</span><span class="s1">];</span>

          <span class="s3">if </span><span class="s1">(def == </span><span class="s3">null </span><span class="s1">|| def.name == </span><span class="s3">null </span><span class="s1">|| def.type !== </span><span class="s2">'Parameter'</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Was it called in at least one case? Then it's a function.</span>


          <span class="s3">var </span><span class="s1">isFunctionCall = </span><span class="s3">false</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">id;</span>

          <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i2 = </span><span class="s4">0</span><span class="s1">; _i2 &lt; usedDep.references.length; _i2++) {</span>
            <span class="s1">id = usedDep.references[_i2].identifier;</span>

            <span class="s3">if </span><span class="s1">(id != </span><span class="s3">null </span><span class="s1">&amp;&amp; id.parent != </span><span class="s3">null </span><span class="s1">&amp;&amp; (id.parent.type === </span><span class="s2">'CallExpression' </span><span class="s1">|| id.parent.type === </span><span class="s2">'OptionalCallExpression'</span><span class="s1">) &amp;&amp; id.parent.callee === id) {</span>
              <span class="s1">isFunctionCall = </span><span class="s3">true</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(!isFunctionCall) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// If it's missing (i.e. in component scope) *and* it's a parameter</span>
          <span class="s0">// then it is definitely coming from props destructuring.</span>
          <span class="s0">// (It could also be props itself but we wouldn't be calling it then.)</span>


          <span class="s1">missingCallbackDep = missingDep;</span>
        <span class="s1">});</span>

        <span class="s3">if </span><span class="s1">(missingCallbackDep !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">extraWarning = </span><span class="s2">&quot; If '&quot; </span><span class="s1">+ missingCallbackDep + </span><span class="s2">&quot;' changes too often, &quot; </span><span class="s1">+ </span><span class="s2">&quot;find the parent component that defines it &quot; </span><span class="s1">+ </span><span class="s2">&quot;and wrap that definition in useCallback.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(!extraWarning &amp;&amp; missingDependencies.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">setStateRecommendation = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">missingDependencies.forEach(</span><span class="s3">function </span><span class="s1">(missingDep) {</span>
          <span class="s3">if </span><span class="s1">(setStateRecommendation !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">usedDep = dependencies.get(missingDep);</span>
          <span class="s3">var </span><span class="s1">references = usedDep.references;</span>
          <span class="s3">var </span><span class="s1">id;</span>
          <span class="s3">var </span><span class="s1">maybeCall;</span>

          <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i3 = </span><span class="s4">0</span><span class="s1">; _i3 &lt; references.length; _i3++) {</span>
            <span class="s1">id = references[_i3].identifier;</span>
            <span class="s1">maybeCall = id.parent; </span><span class="s0">// Try to see if we have setState(someExpr(missingDep)).</span>

            <span class="s3">while </span><span class="s1">(maybeCall != </span><span class="s3">null </span><span class="s1">&amp;&amp; maybeCall !== componentScope.block) {</span>
              <span class="s3">if </span><span class="s1">(maybeCall.type === </span><span class="s2">'CallExpression'</span><span class="s1">) {</span>
                <span class="s3">var </span><span class="s1">correspondingStateVariable = setStateCallSites.get(maybeCall.callee);</span>

                <span class="s3">if </span><span class="s1">(correspondingStateVariable != </span><span class="s3">null</span><span class="s1">) {</span>
                  <span class="s3">if </span><span class="s1">(correspondingStateVariable.name === missingDep) {</span>
                    <span class="s0">// setCount(count + 1)</span>
                    <span class="s1">setStateRecommendation = {</span>
                      <span class="s1">missingDep: missingDep,</span>
                      <span class="s1">setter: maybeCall.callee.name,</span>
                      <span class="s1">form: </span><span class="s2">'updater'</span>
                    <span class="s1">};</span>
                  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stateVariables.has(id)) {</span>
                    <span class="s0">// setCount(count + increment)</span>
                    <span class="s1">setStateRecommendation = {</span>
                      <span class="s1">missingDep: missingDep,</span>
                      <span class="s1">setter: maybeCall.callee.name,</span>
                      <span class="s1">form: </span><span class="s2">'reducer'</span>
                    <span class="s1">};</span>
                  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">resolved = references[_i3].resolved;</span>

                    <span class="s3">if </span><span class="s1">(resolved != </span><span class="s3">null</span><span class="s1">) {</span>
                      <span class="s0">// If it's a parameter *and* a missing dep,</span>
                      <span class="s0">// it must be a prop or something inside a prop.</span>
                      <span class="s0">// Therefore, recommend an inline reducer.</span>
                      <span class="s3">var </span><span class="s1">def = resolved.defs[</span><span class="s4">0</span><span class="s1">];</span>

                      <span class="s3">if </span><span class="s1">(def != </span><span class="s3">null </span><span class="s1">&amp;&amp; def.type === </span><span class="s2">'Parameter'</span><span class="s1">) {</span>
                        <span class="s1">setStateRecommendation = {</span>
                          <span class="s1">missingDep: missingDep,</span>
                          <span class="s1">setter: maybeCall.callee.name,</span>
                          <span class="s1">form: </span><span class="s2">'inlineReducer'</span>
                        <span class="s1">};</span>
                      <span class="s1">}</span>
                    <span class="s1">}</span>
                  <span class="s1">}</span>

                  <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s1">maybeCall = maybeCall.parent;</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(setStateRecommendation !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">});</span>

        <span class="s3">if </span><span class="s1">(setStateRecommendation !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">switch </span><span class="s1">(setStateRecommendation.form) {</span>
            <span class="s3">case </span><span class="s2">'reducer'</span><span class="s1">:</span>
              <span class="s1">extraWarning = </span><span class="s2">&quot; You can also replace multiple useState variables with useReducer &quot; </span><span class="s1">+ (</span><span class="s2">&quot;if '&quot; </span><span class="s1">+ setStateRecommendation.setter + </span><span class="s2">&quot;' needs the &quot;</span><span class="s1">) + (</span><span class="s2">&quot;current value of '&quot; </span><span class="s1">+ setStateRecommendation.missingDep + </span><span class="s2">&quot;'.&quot;</span><span class="s1">);</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s2">'inlineReducer'</span><span class="s1">:</span>
              <span class="s1">extraWarning = </span><span class="s2">&quot; If '&quot; </span><span class="s1">+ setStateRecommendation.setter + </span><span class="s2">&quot;' needs the &quot; </span><span class="s1">+ (</span><span class="s2">&quot;current value of '&quot; </span><span class="s1">+ setStateRecommendation.missingDep + </span><span class="s2">&quot;', &quot;</span><span class="s1">) + </span><span class="s2">&quot;you can also switch to useReducer instead of useState and &quot; </span><span class="s1">+ (</span><span class="s2">&quot;read '&quot; </span><span class="s1">+ setStateRecommendation.missingDep + </span><span class="s2">&quot;' in the reducer.&quot;</span><span class="s1">);</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s2">'updater'</span><span class="s1">:</span>
              <span class="s1">extraWarning = </span><span class="s2">&quot; You can also do a functional update '&quot; </span><span class="s1">+ setStateRecommendation.setter + </span><span class="s2">&quot;(&quot; </span><span class="s1">+ setStateRecommendation.missingDep.substring(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">) + </span><span class="s2">&quot; =&gt; ...)' if you only need '&quot; </span><span class="s1">+ setStateRecommendation.missingDep + </span><span class="s2">&quot;'&quot; </span><span class="s1">+ (</span><span class="s2">&quot; in the '&quot; </span><span class="s1">+ setStateRecommendation.setter + </span><span class="s2">&quot;' call.&quot;</span><span class="s1">);</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">default</span><span class="s1">:</span>
              <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'Unknown case.'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">reportProblem({</span>
        <span class="s1">node: declaredDependenciesNode,</span>
        <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ context.getSource(reactiveHook) + </span><span class="s2">&quot; has &quot; </span><span class="s1">+ ( </span><span class="s0">// To avoid a long message, show the next actionable item.</span>
        <span class="s1">getWarningMessage(missingDependencies, </span><span class="s2">'a'</span><span class="s1">, </span><span class="s2">'missing'</span><span class="s1">, </span><span class="s2">'include'</span><span class="s1">) || getWarningMessage(unnecessaryDependencies, </span><span class="s2">'an'</span><span class="s1">, </span><span class="s2">'unnecessary'</span><span class="s1">, </span><span class="s2">'exclude'</span><span class="s1">) || getWarningMessage(duplicateDependencies, </span><span class="s2">'a'</span><span class="s1">, </span><span class="s2">'duplicate'</span><span class="s1">, </span><span class="s2">'omit'</span><span class="s1">)) + extraWarning,</span>
        <span class="s1">suggest: [{</span>
          <span class="s1">desc: </span><span class="s2">&quot;Update the dependencies array to be: [&quot; </span><span class="s1">+ suggestedDeps.map(formatDependency).join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span><span class="s1">,</span>
          <span class="s1">fix: </span><span class="s3">function </span><span class="s1">(fixer) {</span>
            <span class="s0">// TODO: consider preserving the comments or formatting?</span>
            <span class="s3">return </span><span class="s1">fixer.replaceText(declaredDependenciesNode, </span><span class="s2">&quot;[&quot; </span><span class="s1">+ suggestedDeps.map(formatDependency).join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">&quot;]&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}]</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">visitCallExpression(node) {</span>
      <span class="s3">var </span><span class="s1">callbackIndex = getReactiveHookCallbackIndex(node.callee, options);</span>

      <span class="s3">if </span><span class="s1">(callbackIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s0">// Not a React Hook call that needs deps.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">callback = node.arguments[callbackIndex];</span>
      <span class="s3">var </span><span class="s1">reactiveHook = node.callee;</span>
      <span class="s3">var </span><span class="s1">reactiveHookName = getNodeWithoutReactNamespace(reactiveHook).name;</span>
      <span class="s3">var </span><span class="s1">declaredDependenciesNode = node.arguments[callbackIndex + </span><span class="s4">1</span><span class="s1">];</span>
      <span class="s3">var </span><span class="s1">isEffect = /Effect($|[^a-z])/g.test(reactiveHookName); </span><span class="s0">// Check whether a callback is supplied. If there is no callback supplied</span>
      <span class="s0">// then the hook will not work and React will throw a TypeError.</span>
      <span class="s0">// So no need to check for dependency inclusion.</span>

      <span class="s3">if </span><span class="s1">(!callback) {</span>
        <span class="s1">reportProblem({</span>
          <span class="s1">node: reactiveHook,</span>
          <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ reactiveHookName + </span><span class="s2">&quot; requires an effect callback. &quot; </span><span class="s1">+ </span><span class="s2">&quot;Did you forget to pass a callback to the hook?&quot;</span>
        <span class="s1">});</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Check the declared dependencies for this reactive hook. If there is no</span>
      <span class="s0">// second argument then the reactive callback will re-run on every render.</span>
      <span class="s0">// So no need to check for dependency inclusion.</span>


      <span class="s3">if </span><span class="s1">(!declaredDependenciesNode &amp;&amp; !isEffect) {</span>
        <span class="s0">// These are only used for optimization.</span>
        <span class="s3">if </span><span class="s1">(reactiveHookName === </span><span class="s2">'useMemo' </span><span class="s1">|| reactiveHookName === </span><span class="s2">'useCallback'</span><span class="s1">) {</span>
          <span class="s0">// TODO: Can this have a suggestion?</span>
          <span class="s1">reportProblem({</span>
            <span class="s1">node: reactiveHook,</span>
            <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ reactiveHookName + </span><span class="s2">&quot; does nothing when called with &quot; </span><span class="s1">+ </span><span class="s2">&quot;only one argument. Did you forget to pass an array of &quot; </span><span class="s1">+ </span><span class="s2">&quot;dependencies?&quot;</span>
          <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">switch </span><span class="s1">(callback.type) {</span>
        <span class="s3">case </span><span class="s2">'FunctionExpression'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'ArrowFunctionExpression'</span><span class="s1">:</span>
          <span class="s1">visitFunctionWithDependencies(callback, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s0">// Handled</span>

        <span class="s3">case </span><span class="s2">'Identifier'</span><span class="s1">:</span>
          <span class="s3">if </span><span class="s1">(!declaredDependenciesNode) {</span>
            <span class="s0">// No deps, no problems.</span>
            <span class="s3">return</span><span class="s1">; </span><span class="s0">// Handled</span>
          <span class="s1">} </span><span class="s0">// The function passed as a callback is not written inline.</span>
          <span class="s0">// But perhaps it's in the dependencies array?</span>


          <span class="s3">if </span><span class="s1">(declaredDependenciesNode.elements &amp;&amp; declaredDependenciesNode.elements.some(</span><span class="s3">function </span><span class="s1">(el) {</span>
            <span class="s3">return </span><span class="s1">el &amp;&amp; el.type === </span><span class="s2">'Identifier' </span><span class="s1">&amp;&amp; el.name === callback.name;</span>
          <span class="s1">})) {</span>
            <span class="s0">// If it's already in the list of deps, we don't care because</span>
            <span class="s0">// this is valid regardless.</span>
            <span class="s3">return</span><span class="s1">; </span><span class="s0">// Handled</span>
          <span class="s1">} </span><span class="s0">// We'll do our best effort to find it, complain otherwise.</span>


          <span class="s3">var </span><span class="s1">variable = context.getScope().set.get(callback.name);</span>

          <span class="s3">if </span><span class="s1">(variable == </span><span class="s3">null </span><span class="s1">|| variable.defs == </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// If it's not in scope, we don't care.</span>
            <span class="s3">return</span><span class="s1">; </span><span class="s0">// Handled</span>
          <span class="s1">} </span><span class="s0">// The function passed as a callback is not written inline.</span>
          <span class="s0">// But it's defined somewhere in the render scope.</span>
          <span class="s0">// We'll do our best effort to find and check it, complain otherwise.</span>


          <span class="s3">var </span><span class="s1">def = variable.defs[</span><span class="s4">0</span><span class="s1">];</span>

          <span class="s3">if </span><span class="s1">(!def || !def.node) {</span>
            <span class="s3">break</span><span class="s1">; </span><span class="s0">// Unhandled</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(def.type !== </span><span class="s2">'Variable' </span><span class="s1">&amp;&amp; def.type !== </span><span class="s2">'FunctionName'</span><span class="s1">) {</span>
            <span class="s0">// Parameter or an unusual pattern. Bail out.</span>
            <span class="s3">break</span><span class="s1">; </span><span class="s0">// Unhandled</span>
          <span class="s1">}</span>

          <span class="s3">switch </span><span class="s1">(def.node.type) {</span>
            <span class="s3">case </span><span class="s2">'FunctionDeclaration'</span><span class="s1">:</span>
              <span class="s0">// useEffect(() =&gt; { ... }, []);</span>
              <span class="s1">visitFunctionWithDependencies(def.node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);</span>
              <span class="s3">return</span><span class="s1">;</span>
            <span class="s0">// Handled</span>

            <span class="s3">case </span><span class="s2">'VariableDeclarator'</span><span class="s1">:</span>
              <span class="s3">var </span><span class="s1">init = def.node.init;</span>

              <span class="s3">if </span><span class="s1">(!init) {</span>
                <span class="s3">break</span><span class="s1">; </span><span class="s0">// Unhandled</span>
              <span class="s1">}</span>

              <span class="s3">switch </span><span class="s1">(init.type) {</span>
                <span class="s0">// const effectBody = () =&gt; {...};</span>
                <span class="s0">// useEffect(effectBody, []);</span>
                <span class="s3">case </span><span class="s2">'ArrowFunctionExpression'</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s2">'FunctionExpression'</span><span class="s1">:</span>
                  <span class="s0">// We can inspect this function as if it were inline.</span>
                  <span class="s1">visitFunctionWithDependencies(init, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect);</span>
                  <span class="s3">return</span><span class="s1">;</span>
                <span class="s0">// Handled</span>
              <span class="s1">}</span>

              <span class="s3">break</span><span class="s1">;</span>
            <span class="s0">// Unhandled</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s0">// Unhandled</span>

        <span class="s3">default</span><span class="s1">:</span>
          <span class="s0">// useEffect(generateEffectBody(), []);</span>
          <span class="s1">reportProblem({</span>
            <span class="s1">node: reactiveHook,</span>
            <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ reactiveHookName + </span><span class="s2">&quot; received a function whose dependencies &quot; </span><span class="s1">+ </span><span class="s2">&quot;are unknown. Pass an inline function instead.&quot;</span>
          <span class="s1">});</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s0">// Handled</span>
      <span class="s1">} </span><span class="s0">// Something unusual. Fall back to suggesting to add the body itself as a dep.</span>


      <span class="s1">reportProblem({</span>
        <span class="s1">node: reactiveHook,</span>
        <span class="s1">message: </span><span class="s2">&quot;React Hook &quot; </span><span class="s1">+ reactiveHookName + </span><span class="s2">&quot; has a missing dependency: '&quot; </span><span class="s1">+ callback.name + </span><span class="s2">&quot;'. &quot; </span><span class="s1">+ </span><span class="s2">&quot;Either include it or remove the dependency array.&quot;</span><span class="s1">,</span>
        <span class="s1">suggest: [{</span>
          <span class="s1">desc: </span><span class="s2">&quot;Update the dependencies array to be: [&quot; </span><span class="s1">+ callback.name + </span><span class="s2">&quot;]&quot;</span><span class="s1">,</span>
          <span class="s1">fix: </span><span class="s3">function </span><span class="s1">(fixer) {</span>
            <span class="s3">return </span><span class="s1">fixer.replaceText(declaredDependenciesNode, </span><span class="s2">&quot;[&quot; </span><span class="s1">+ callback.name + </span><span class="s2">&quot;]&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}]</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">CallExpression: visitCallExpression</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
<span class="s1">}; </span><span class="s0">// The meat of the logic.</span>

<span class="s3">function </span><span class="s1">collectRecommendations(_ref6) {</span>
  <span class="s3">var </span><span class="s1">dependencies = _ref6.dependencies,</span>
      <span class="s1">declaredDependencies = _ref6.declaredDependencies,</span>
      <span class="s1">stableDependencies = _ref6.stableDependencies,</span>
      <span class="s1">externalDependencies = _ref6.externalDependencies,</span>
      <span class="s1">isEffect = _ref6.isEffect;</span>
  <span class="s0">// Our primary data structure.</span>
  <span class="s0">// It is a logical representation of property chains:</span>
  <span class="s0">// `props` -&gt; `props.foo` -&gt; `props.foo.bar` -&gt; `props.foo.bar.baz`</span>
  <span class="s0">//         -&gt; `props.lol`</span>
  <span class="s0">//         -&gt; `props.huh` -&gt; `props.huh.okay`</span>
  <span class="s0">//         -&gt; `props.wow`</span>
  <span class="s0">// We'll use it to mark nodes that are *used* by the programmer,</span>
  <span class="s0">// and the nodes that were *declared* as deps. Then we will</span>
  <span class="s0">// traverse it to learn which deps are missing or unnecessary.</span>
  <span class="s3">var </span><span class="s1">depTree = createDepTree();</span>

  <span class="s3">function </span><span class="s1">createDepTree() {</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">isUsed: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s0">// True if used in code</span>
      <span class="s1">isSatisfiedRecursively: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s0">// True if specified in deps</span>
      <span class="s1">isSubtreeUsed: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s0">// True if something deeper is used by code</span>
      <span class="s1">children: </span><span class="s3">new </span><span class="s1">Map() </span><span class="s0">// Nodes for properties</span>

    <span class="s1">};</span>
  <span class="s1">} </span><span class="s0">// Mark all required nodes first.</span>
  <span class="s0">// Imagine exclamation marks next to each used deep property.</span>


  <span class="s1">dependencies.forEach(</span><span class="s3">function </span><span class="s1">(_, key) {</span>
    <span class="s3">var </span><span class="s1">node = getOrCreateNodeByPath(depTree, key);</span>
    <span class="s1">node.isUsed = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">markAllParentsByPath(depTree, key, </span><span class="s3">function </span><span class="s1">(parent) {</span>
      <span class="s1">parent.isSubtreeUsed = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">});</span>
  <span class="s1">}); </span><span class="s0">// Mark all satisfied nodes.</span>
  <span class="s0">// Imagine checkmarks next to each declared dependency.</span>

  <span class="s1">declaredDependencies.forEach(</span><span class="s3">function </span><span class="s1">(_ref7) {</span>
    <span class="s3">var </span><span class="s1">key = _ref7.key;</span>
    <span class="s3">var </span><span class="s1">node = getOrCreateNodeByPath(depTree, key);</span>
    <span class="s1">node.isSatisfiedRecursively = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">});</span>
  <span class="s1">stableDependencies.forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
    <span class="s3">var </span><span class="s1">node = getOrCreateNodeByPath(depTree, key);</span>
    <span class="s1">node.isSatisfiedRecursively = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">}); </span><span class="s0">// Tree manipulation helpers.</span>

  <span class="s3">function </span><span class="s1">getOrCreateNodeByPath(rootNode, path) {</span>
    <span class="s3">var </span><span class="s1">keys = path.split(</span><span class="s2">'.'</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">node = rootNode;</span>

    <span class="s3">var </span><span class="s1">_iterator3 = _createForOfIteratorHelper(keys),</span>
        <span class="s1">_step3;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(_iterator3.s(); !(_step3 = _iterator3.n()).done;) {</span>
        <span class="s3">var </span><span class="s1">key = _step3.value;</span>
        <span class="s3">var </span><span class="s1">child = node.children.get(key);</span>

        <span class="s3">if </span><span class="s1">(!child) {</span>
          <span class="s1">child = createDepTree();</span>
          <span class="s1">node.children.set(key, child);</span>
        <span class="s1">}</span>

        <span class="s1">node = child;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
      <span class="s1">_iterator3.e(err);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">_iterator3.f();</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">node;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">markAllParentsByPath(rootNode, path, fn) {</span>
    <span class="s3">var </span><span class="s1">keys = path.split(</span><span class="s2">'.'</span><span class="s1">);</span>
    <span class="s3">var </span><span class="s1">node = rootNode;</span>

    <span class="s3">var </span><span class="s1">_iterator4 = _createForOfIteratorHelper(keys),</span>
        <span class="s1">_step4;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(_iterator4.s(); !(_step4 = _iterator4.n()).done;) {</span>
        <span class="s3">var </span><span class="s1">key = _step4.value;</span>
        <span class="s3">var </span><span class="s1">child = node.children.get(key);</span>

        <span class="s3">if </span><span class="s1">(!child) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">fn(child);</span>
        <span class="s1">node = child;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
      <span class="s1">_iterator4.e(err);</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">_iterator4.f();</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">// Now we can learn which dependencies are missing or necessary.</span>


  <span class="s3">var </span><span class="s1">missingDependencies = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s3">var </span><span class="s1">satisfyingDependencies = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, </span><span class="s3">function </span><span class="s1">(key) {</span>
    <span class="s3">return </span><span class="s1">key;</span>
  <span class="s1">});</span>

  <span class="s3">function </span><span class="s1">scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {</span>
    <span class="s1">node.children.forEach(</span><span class="s3">function </span><span class="s1">(child, key) {</span>
      <span class="s3">var </span><span class="s1">path = keyToPath(key);</span>

      <span class="s3">if </span><span class="s1">(child.isSatisfiedRecursively) {</span>
        <span class="s3">if </span><span class="s1">(child.isSubtreeUsed) {</span>
          <span class="s0">// Remember this dep actually satisfied something.</span>
          <span class="s1">satisfyingPaths.add(path);</span>
        <span class="s1">} </span><span class="s0">// It doesn't matter if there's something deeper.</span>
        <span class="s0">// It would be transitively satisfied since we assume immutability.</span>
        <span class="s0">// `props.foo` is enough if you read `props.foo.id`.</span>


        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(child.isUsed) {</span>
        <span class="s0">// Remember that no declared deps satisfied this node.</span>
        <span class="s1">missingPaths.add(path); </span><span class="s0">// If we got here, nothing in its subtree was satisfied.</span>
        <span class="s0">// No need to search further.</span>

        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">scanTreeRecursively(child, missingPaths, satisfyingPaths, </span><span class="s3">function </span><span class="s1">(childKey) {</span>
        <span class="s3">return </span><span class="s1">path + </span><span class="s2">'.' </span><span class="s1">+ childKey;</span>
      <span class="s1">});</span>
    <span class="s1">});</span>
  <span class="s1">} </span><span class="s0">// Collect suggestions in the order they were originally specified.</span>


  <span class="s3">var </span><span class="s1">suggestedDependencies = [];</span>
  <span class="s3">var </span><span class="s1">unnecessaryDependencies = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s3">var </span><span class="s1">duplicateDependencies = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">declaredDependencies.forEach(</span><span class="s3">function </span><span class="s1">(_ref8) {</span>
    <span class="s3">var </span><span class="s1">key = _ref8.key;</span>

    <span class="s0">// Does this declared dep satisfy a real need?</span>
    <span class="s3">if </span><span class="s1">(satisfyingDependencies.has(key)) {</span>
      <span class="s3">if </span><span class="s1">(suggestedDependencies.indexOf(key) === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s0">// Good one.</span>
        <span class="s1">suggestedDependencies.push(key);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Duplicate.</span>
        <span class="s1">duplicateDependencies.add(key);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(isEffect &amp;&amp; !key.endsWith(</span><span class="s2">'.current'</span><span class="s1">) &amp;&amp; !externalDependencies.has(key)) {</span>
        <span class="s0">// Effects are allowed extra &quot;unnecessary&quot; deps.</span>
        <span class="s0">// Such as resetting scroll when ID changes.</span>
        <span class="s0">// Consider them legit.</span>
        <span class="s0">// The exception is ref.current which is always wrong.</span>
        <span class="s3">if </span><span class="s1">(suggestedDependencies.indexOf(key) === -</span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">suggestedDependencies.push(key);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// It's definitely not needed.</span>
        <span class="s1">unnecessaryDependencies.add(key);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}); </span><span class="s0">// Then add the missing ones at the end.</span>

  <span class="s1">missingDependencies.forEach(</span><span class="s3">function </span><span class="s1">(key) {</span>
    <span class="s1">suggestedDependencies.push(key);</span>
  <span class="s1">});</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">suggestedDependencies: suggestedDependencies,</span>
    <span class="s1">unnecessaryDependencies: unnecessaryDependencies,</span>
    <span class="s1">duplicateDependencies: duplicateDependencies,</span>
    <span class="s1">missingDependencies: missingDependencies</span>
  <span class="s1">};</span>
<span class="s1">} </span><span class="s0">// If the node will result in constructing a referentially unique value, return</span>
<span class="s0">// its human readable type name, else return null.</span>


<span class="s3">function </span><span class="s1">getConstructionExpressionType(node) {</span>
  <span class="s3">switch </span><span class="s1">(node.type) {</span>
    <span class="s3">case </span><span class="s2">'ObjectExpression'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">'object'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'ArrayExpression'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">'array'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'ArrowFunctionExpression'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'FunctionExpression'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">'function'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'ClassExpression'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">'class'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'ConditionalExpression'</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(getConstructionExpressionType(node.consequent) != </span><span class="s3">null </span><span class="s1">|| getConstructionExpressionType(node.alternate) != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s2">'conditional'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'LogicalExpression'</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(getConstructionExpressionType(node.left) != </span><span class="s3">null </span><span class="s1">|| getConstructionExpressionType(node.right) != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s2">'logical expression'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'JSXFragment'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">'JSX fragment'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'JSXElement'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">'JSX element'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'AssignmentExpression'</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(getConstructionExpressionType(node.right) != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s2">'assignment expression'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'NewExpression'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s2">'object construction'</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'Literal'</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(node.value </span><span class="s3">instanceof </span><span class="s1">RegExp) {</span>
        <span class="s3">return </span><span class="s2">'regular expression'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return null</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'TypeCastExpression'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">getConstructionExpressionType(node.expression);</span>

    <span class="s3">case </span><span class="s2">'TSAsExpression'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">getConstructionExpressionType(node.expression);</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">} </span><span class="s0">// Finds variables declared as dependencies</span>
<span class="s0">// that would invalidate on every render.</span>


<span class="s3">function </span><span class="s1">scanForConstructions(_ref9) {</span>
  <span class="s3">var </span><span class="s1">declaredDependencies = _ref9.declaredDependencies,</span>
      <span class="s1">declaredDependenciesNode = _ref9.declaredDependenciesNode,</span>
      <span class="s1">componentScope = _ref9.componentScope,</span>
      <span class="s1">scope = _ref9.scope;</span>
  <span class="s3">var </span><span class="s1">constructions = declaredDependencies.map(</span><span class="s3">function </span><span class="s1">(_ref10) {</span>
    <span class="s3">var </span><span class="s1">key = _ref10.key;</span>
    <span class="s3">var </span><span class="s1">ref = componentScope.variables.find(</span><span class="s3">function </span><span class="s1">(v) {</span>
      <span class="s3">return </span><span class="s1">v.name === key;</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(ref == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">node = ref.defs[</span><span class="s4">0</span><span class="s1">];</span>

    <span class="s3">if </span><span class="s1">(node == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">// const handleChange = function () {}</span>
    <span class="s0">// const handleChange = () =&gt; {}</span>
    <span class="s0">// const foo = {}</span>
    <span class="s0">// const foo = []</span>
    <span class="s0">// etc.</span>


    <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">'Variable' </span><span class="s1">&amp;&amp; node.node.type === </span><span class="s2">'VariableDeclarator' </span><span class="s1">&amp;&amp; node.node.id.type === </span><span class="s2">'Identifier' </span><span class="s1">&amp;&amp; </span><span class="s0">// Ensure this is not destructed assignment</span>
    <span class="s1">node.node.init != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">constantExpressionType = getConstructionExpressionType(node.node.init);</span>

      <span class="s3">if </span><span class="s1">(constantExpressionType != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">[ref, constantExpressionType];</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// function handleChange() {}</span>


    <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">'FunctionName' </span><span class="s1">&amp;&amp; node.node.type === </span><span class="s2">'FunctionDeclaration'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">[ref, </span><span class="s2">'function'</span><span class="s1">];</span>
    <span class="s1">} </span><span class="s0">// class Foo {}</span>


    <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">'ClassName' </span><span class="s1">&amp;&amp; node.node.type === </span><span class="s2">'ClassDeclaration'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">[ref, </span><span class="s2">'class'</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}).filter(Boolean);</span>

  <span class="s3">function </span><span class="s1">isUsedOutsideOfHook(ref) {</span>
    <span class="s3">var </span><span class="s1">foundWriteExpr = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; ref.references.length; i++) {</span>
      <span class="s3">var </span><span class="s1">reference = ref.references[i];</span>

      <span class="s3">if </span><span class="s1">(reference.writeExpr) {</span>
        <span class="s3">if </span><span class="s1">(foundWriteExpr) {</span>
          <span class="s0">// Two writes to the same function.</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s0">// Ignore first write as it's not usage.</span>
          <span class="s1">foundWriteExpr = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">currentScope = reference.from;</span>

      <span class="s3">while </span><span class="s1">(currentScope !== scope &amp;&amp; currentScope != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">currentScope = currentScope.upper;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(currentScope !== scope) {</span>
        <span class="s0">// This reference is outside the Hook callback.</span>
        <span class="s0">// It can only be legit if it's the deps array.</span>
        <span class="s3">if </span><span class="s1">(!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">constructions.map(</span><span class="s3">function </span><span class="s1">(_ref11) {</span>
    <span class="s3">var </span><span class="s1">ref = _ref11[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">depType = _ref11[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">construction: ref.defs[</span><span class="s4">0</span><span class="s1">],</span>
      <span class="s1">depType: depType,</span>
      <span class="s1">isUsedOutsideOfHook: isUsedOutsideOfHook(ref)</span>
    <span class="s1">};</span>
  <span class="s1">});</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Assuming () means the passed/returned node: 
 * (props) =&gt; (props) 
 * props.(foo) =&gt; (props.foo) 
 * props.foo.(bar) =&gt; (props).foo.bar 
 * props.foo.bar.(baz) =&gt; (props).foo.bar.baz 
 */</span>


<span class="s3">function </span><span class="s1">getDependency(node) {</span>
  <span class="s3">if </span><span class="s1">((node.parent.type === </span><span class="s2">'MemberExpression' </span><span class="s1">|| node.parent.type === </span><span class="s2">'OptionalMemberExpression'</span><span class="s1">) &amp;&amp; node.parent.object === node &amp;&amp; node.parent.property.name !== </span><span class="s2">'current' </span><span class="s1">&amp;&amp; !node.parent.computed &amp;&amp; !(node.parent.parent != </span><span class="s3">null </span><span class="s1">&amp;&amp; (node.parent.parent.type === </span><span class="s2">'CallExpression' </span><span class="s1">|| node.parent.parent.type === </span><span class="s2">'OptionalCallExpression'</span><span class="s1">) &amp;&amp; node.parent.parent.callee === node.parent)) {</span>
    <span class="s3">return </span><span class="s1">getDependency(node.parent);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">( </span><span class="s0">// Note: we don't check OptionalMemberExpression because it can't be LHS.</span>
  <span class="s1">node.type === </span><span class="s2">'MemberExpression' </span><span class="s1">&amp;&amp; node.parent &amp;&amp; node.parent.type === </span><span class="s2">'AssignmentExpression' </span><span class="s1">&amp;&amp; node.parent.left === node) {</span>
    <span class="s3">return </span><span class="s1">node.object;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s1">node;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Mark a node as either optional or required. 
 * Note: If the node argument is an OptionalMemberExpression, it doesn't necessarily mean it is optional. 
 * It just means there is an optional member somewhere inside. 
 * This particular node might still represent a required member, so check .optional field. 
 */</span>


<span class="s3">function </span><span class="s1">markNode(node, optionalChains, result) {</span>
  <span class="s3">if </span><span class="s1">(optionalChains) {</span>
    <span class="s3">if </span><span class="s1">(node.optional) {</span>
      <span class="s0">// We only want to consider it optional if *all* usages were optional.</span>
      <span class="s3">if </span><span class="s1">(!optionalChains.has(result)) {</span>
        <span class="s0">// Mark as (maybe) optional. If there's a required usage, this will be overridden.</span>
        <span class="s1">optionalChains.set(result, </span><span class="s3">true</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s0">// Mark as required.</span>
      <span class="s1">optionalChains.set(result, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * Assuming () means the passed node. 
 * (foo) -&gt; 'foo' 
 * foo(.)bar -&gt; 'foo.bar' 
 * foo.bar(.)baz -&gt; 'foo.bar.baz' 
 * Otherwise throw. 
 */</span>


<span class="s3">function </span><span class="s1">analyzePropertyChain(node, optionalChains) {</span>
  <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">'Identifier' </span><span class="s1">|| node.type === </span><span class="s2">'JSXIdentifier'</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s1">result = node.name;</span>

    <span class="s3">if </span><span class="s1">(optionalChains) {</span>
      <span class="s0">// Mark as required.</span>
      <span class="s1">optionalChains.set(result, </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">result;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.type === </span><span class="s2">'MemberExpression' </span><span class="s1">&amp;&amp; !node.computed) {</span>
    <span class="s3">var </span><span class="s1">object = analyzePropertyChain(node.object, optionalChains);</span>
    <span class="s3">var </span><span class="s1">property = analyzePropertyChain(node.property, </span><span class="s3">null</span><span class="s1">);</span>

    <span class="s3">var </span><span class="s1">_result = object + </span><span class="s2">&quot;.&quot; </span><span class="s1">+ property;</span>

    <span class="s1">markNode(node, optionalChains, _result);</span>
    <span class="s3">return </span><span class="s1">_result;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.type === </span><span class="s2">'OptionalMemberExpression' </span><span class="s1">&amp;&amp; !node.computed) {</span>
    <span class="s3">var </span><span class="s1">_object = analyzePropertyChain(node.object, optionalChains);</span>

    <span class="s3">var </span><span class="s1">_property = analyzePropertyChain(node.property, </span><span class="s3">null</span><span class="s1">);</span>

    <span class="s3">var </span><span class="s1">_result2 = _object + </span><span class="s2">&quot;.&quot; </span><span class="s1">+ _property;</span>

    <span class="s1">markNode(node, optionalChains, _result2);</span>
    <span class="s3">return </span><span class="s1">_result2;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node.type === </span><span class="s2">'ChainExpression' </span><span class="s1">&amp;&amp; !node.computed) {</span>
    <span class="s3">var </span><span class="s1">expression = node.expression;</span>

    <span class="s3">if </span><span class="s1">(expression.type === </span><span class="s2">'CallExpression'</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unsupported node type: &quot; </span><span class="s1">+ expression.type);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">_object2 = analyzePropertyChain(expression.object, optionalChains);</span>

    <span class="s3">var </span><span class="s1">_property2 = analyzePropertyChain(expression.property, </span><span class="s3">null</span><span class="s1">);</span>

    <span class="s3">var </span><span class="s1">_result3 = _object2 + </span><span class="s2">&quot;.&quot; </span><span class="s1">+ _property2;</span>

    <span class="s1">markNode(expression, optionalChains, _result3);</span>
    <span class="s3">return </span><span class="s1">_result3;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unsupported node type: &quot; </span><span class="s1">+ node.type);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getNodeWithoutReactNamespace(node, options) {</span>
  <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">'MemberExpression' </span><span class="s1">&amp;&amp; node.object.type === </span><span class="s2">'Identifier' </span><span class="s1">&amp;&amp; node.object.name === </span><span class="s2">'React' </span><span class="s1">&amp;&amp; node.property.type === </span><span class="s2">'Identifier' </span><span class="s1">&amp;&amp; !node.computed) {</span>
    <span class="s3">return </span><span class="s1">node.property;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">node;</span>
<span class="s1">} </span><span class="s0">// What's the index of callback that needs to be analyzed for a given Hook?</span>
<span class="s0">// -1 if it's not a Hook we care about (e.g. useState).</span>
<span class="s0">// 0 for useEffect/useMemo/useCallback(fn).</span>
<span class="s0">// 1 for useImperativeHandle(ref, fn).</span>
<span class="s0">// For additionally configured Hooks, assume that they're like useEffect (0).</span>


<span class="s3">function </span><span class="s1">getReactiveHookCallbackIndex(calleeNode, options) {</span>
  <span class="s3">var </span><span class="s1">node = getNodeWithoutReactNamespace(calleeNode);</span>

  <span class="s3">if </span><span class="s1">(node.type !== </span><span class="s2">'Identifier'</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">switch </span><span class="s1">(node.name) {</span>
    <span class="s3">case </span><span class="s2">'useEffect'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'useLayoutEffect'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'useCallback'</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">'useMemo'</span><span class="s1">:</span>
      <span class="s0">// useEffect(fn)</span>
      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">'useImperativeHandle'</span><span class="s1">:</span>
      <span class="s0">// useImperativeHandle(ref, fn)</span>
      <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s3">default</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(node === calleeNode &amp;&amp; options &amp;&amp; options.additionalHooks) {</span>
        <span class="s0">// Allow the user to provide a regular expression which enables the lint to</span>
        <span class="s0">// target custom reactive hooks.</span>
        <span class="s3">var </span><span class="s1">name;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">name = analyzePropertyChain(node, </span><span class="s3">null</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s3">if </span><span class="s1">(/Unsupported node type/.test(error.message)) {</span>
            <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">error;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">options.additionalHooks.test(name) ? </span><span class="s4">0 </span><span class="s1">: -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>

  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/** 
 * ESLint won't assign node.parent to references from context.getScope() 
 * 
 * So instead we search for the node from an ancestor assigning node.parent 
 * as we go. This mutates the AST. 
 * 
 * This traversal is: 
 * - optimized by only searching nodes with a range surrounding our target node 
 * - agnostic to AST node types, it looks for `{ type: string, ... }` 
 */</span>


<span class="s3">function </span><span class="s1">fastFindReferenceWithParent(start, target) {</span>
  <span class="s3">var </span><span class="s1">queue = [start];</span>
  <span class="s3">var </span><span class="s1">item = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">while </span><span class="s1">(queue.length) {</span>
    <span class="s1">item = queue.shift();</span>

    <span class="s3">if </span><span class="s1">(isSameIdentifier(item, target)) {</span>
      <span class="s3">return </span><span class="s1">item;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!isAncestorNodeOf(item, target)) {</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_i4 = </span><span class="s4">0</span><span class="s1">, _Object$entries = Object.entries(item); _i4 &lt; _Object$entries.length; _i4++) {</span>
      <span class="s3">var </span><span class="s1">_Object$entries$_i = _Object$entries[_i4],</span>
          <span class="s1">key = _Object$entries$_i[</span><span class="s4">0</span><span class="s1">],</span>
          <span class="s1">value = _Object$entries$_i[</span><span class="s4">1</span><span class="s1">];</span>

      <span class="s3">if </span><span class="s1">(key === </span><span class="s2">'parent'</span><span class="s1">) {</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(isNodeLike(value)) {</span>
        <span class="s1">value.parent = item;</span>
        <span class="s1">queue.push(value);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(Array.isArray(value)) {</span>
        <span class="s1">value.forEach(</span><span class="s3">function </span><span class="s1">(val) {</span>
          <span class="s3">if </span><span class="s1">(isNodeLike(val)) {</span>
            <span class="s1">val.parent = item;</span>
            <span class="s1">queue.push(val);</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">joinEnglish(arr) {</span>
  <span class="s3">var </span><span class="s1">s = </span><span class="s2">''</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; arr.length; i++) {</span>
    <span class="s1">s += arr[i];</span>

    <span class="s3">if </span><span class="s1">(i === </span><span class="s4">0 </span><span class="s1">&amp;&amp; arr.length === </span><span class="s4">2</span><span class="s1">) {</span>
      <span class="s1">s += </span><span class="s2">' and '</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i === arr.length - </span><span class="s4">2 </span><span class="s1">&amp;&amp; arr.length &gt; </span><span class="s4">2</span><span class="s1">) {</span>
      <span class="s1">s += </span><span class="s2">', and '</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(i &lt; arr.length - </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">s += </span><span class="s2">', '</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">s;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isNodeLike(val) {</span>
  <span class="s3">return typeof </span><span class="s1">val === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; val !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !Array.isArray(val) &amp;&amp; </span><span class="s3">typeof </span><span class="s1">val.type === </span><span class="s2">'string'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isSameIdentifier(a, b) {</span>
  <span class="s3">return </span><span class="s1">(a.type === </span><span class="s2">'Identifier' </span><span class="s1">|| a.type === </span><span class="s2">'JSXIdentifier'</span><span class="s1">) &amp;&amp; a.type === b.type &amp;&amp; a.name === b.name &amp;&amp; a.range[</span><span class="s4">0</span><span class="s1">] === b.range[</span><span class="s4">0</span><span class="s1">] &amp;&amp; a.range[</span><span class="s4">1</span><span class="s1">] === b.range[</span><span class="s4">1</span><span class="s1">];</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">isAncestorNodeOf(a, b) {</span>
  <span class="s3">return </span><span class="s1">a.range[</span><span class="s4">0</span><span class="s1">] &lt;= b.range[</span><span class="s4">0</span><span class="s1">] &amp;&amp; a.range[</span><span class="s4">1</span><span class="s1">] &gt;= b.range[</span><span class="s4">1</span><span class="s1">];</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">configs = {</span>
  <span class="s1">recommended: {</span>
    <span class="s1">plugins: [</span><span class="s2">'react-hooks'</span><span class="s1">],</span>
    <span class="s1">rules: {</span>
      <span class="s2">'react-hooks/rules-of-hooks'</span><span class="s1">: </span><span class="s2">'error'</span><span class="s1">,</span>
      <span class="s2">'react-hooks/exhaustive-deps'</span><span class="s1">: </span><span class="s2">'warn'</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s3">var </span><span class="s1">rules = {</span>
  <span class="s2">'rules-of-hooks'</span><span class="s1">: RulesOfHooks,</span>
  <span class="s2">'exhaustive-deps'</span><span class="s1">: ExhaustiveDeps</span>
<span class="s1">};</span>

<span class="s1">exports.configs = configs;</span>
<span class="s1">exports.rules = rules;</span>
  <span class="s1">})();</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>gestureHandlerCommon.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gestureHandlerCommon.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;gestureHandlerCommon.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;commonProps&quot;</span><span class="s0">,</span><span class="s1">&quot;componentInteractionProps&quot;</span><span class="s0">,</span><span class="s1">&quot;baseGestureHandlerProps&quot;</span><span class="s0">,</span><span class="s1">&quot;baseGestureHandlerWithMonitorProps&quot;</span><span class="s0">,</span><span class="s1">&quot;isConfigParam&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;filterConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;validProps&quot;</span><span class="s0">,</span><span class="s1">&quot;defaults&quot;</span><span class="s0">,</span><span class="s1">&quot;filteredConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;transformIntoHandlerTags&quot;</span><span class="s0">,</span><span class="s1">&quot;top&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;bottom&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerIDs&quot;</span><span class="s0">,</span><span class="s1">&quot;Platform&quot;</span><span class="s0">,</span><span class="s1">&quot;OS&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;handle&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerID&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerIDToTag&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerTag&quot;</span><span class="s0">,</span><span class="s1">&quot;findNodeHandle&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;flushOperationsScheduled&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleFlushOperations&quot;</span><span class="s0">,</span><span class="s1">&quot;queueMicrotask&quot;</span><span class="s0">,</span><span class="s1">&quot;RNGestureHandlerModule&quot;</span><span class="s0">,</span><span class="s1">&quot;flushOperations&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAKA;;AAKA;;AACA;;AACA;;;;AAZA;AACA;AACA;AACA;AAWA,MAAMA,WAAW,GAAG,CAClB,IADkB,EAElB,SAFkB,EAGlB,yBAHkB,EAIlB,SAJkB,EAKlB,sBALkB,EAMlB,YANkB,CAApB;AASA,MAAMC,yBAAyB,GAAG,CAAC,SAAD,EAAY,sBAAZ,CAAlC;AAEO,MAAMC,uBAAuB,GAAG,CACrC,GAAGF,WADkC,EAErC,GAAGC,yBAFkC,EAGrC,SAHqC,EAIrC,UAJqC,EAKrC,aALqC,EAMrC,aANqC,EAOrC,SAPqC,EAQrC,gBARqC,EASrC,sBATqC,CAAhC;;AAYA,MAAME,kCAAkC,GAAG,CAChD,GAAGH,WAD6C,EAEhD,kBAFgD,EAGhD,kBAHgD,CAA3C;;;AAkGP,SAASI,aAAT,CAAuBC,KAAvB,EAAuCC,IAAvC,EAAqD;AACnD;AACA;AACA,SACED,KAAK,KAAKE,SAAV,KACCF,KAAK,KAAKG,MAAM,CAACH,KAAD,CAAhB,IACC,EAAE,gBAAiBA,KAAnB,CAFF,KAGAC,IAAI,KAAK,sBAHT,IAIAA,IAAI,KAAK,gBALX;AAOD;;AAEM,SAASG,YAAT,CACLC,KADK,EAELC,UAFK,EAGLC,QAAiC,GAAG,EAH/B,EAIL;AACA,QAAMC,cAAc,GAAG,EAAE,GAAGD;AAAL,GAAvB;;AACA,OAAK,MAAME,GAAX,IAAkBH,UAAlB,EAA8B;AAC5B,QAAII,KAAK,GAAGL,KAAK,CAACI,GAAD,CAAjB;;AACA,QAAIV,aAAa,CAACW,KAAD,EAAQD,GAAR,CAAjB,EAA+B;AAC7B,UAAIA,GAAG,KAAK,sBAAR,IAAkCA,GAAG,KAAK,SAA9C,EAAyD;AACvDC,QAAAA,KAAK,GAAGC,wBAAwB,CAACN,KAAK,CAACI,GAAD,CAAN,CAAhC;AACD,OAFD,MAEO,IAAIA,GAAG,KAAK,SAAR,IAAqB,OAAOC,KAAP,KAAiB,QAA1C,EAAoD;AACzDA,QAAAA,KAAK,GAAG;AAAEE,UAAAA,GAAG,EAAEF,KAAP;AAAcG,UAAAA,IAAI,EAAEH,KAApB;AAA2BI,UAAAA,MAAM,EAAEJ,KAAnC;AAA0CK,UAAAA,KAAK,EAAEL;AAAjD,SAAR;AACD;;AACDF,MAAAA,cAAc,CAACC,GAAD,CAAd,GAAsBC,KAAtB;AACD;AACF;;AACD,SAAOF,cAAP;AACD;;AAED,SAASG,wBAAT,CAAkCK,UAAlC,EAAmD;AACjDA,EAAAA,UAAU,GAAG,oBAAQA,UAAR,CAAb;;AAEA,MAAIC,sBAASC,EAAT,KAAgB,KAApB,EAA2B;AACzB,WAAOF,UAAU,CACdG,GADI,CACA,CAAC;AAAEC,MAAAA;AAAF,KAAD,KAAmCA,OADnC,EAEJC,MAFI,CAEIC,MAAD,IAAiBA,MAFpB,CAAP;AAGD,GAPgD,CAQjD;;;AACA,SAAON,UAAU,CACdG,GADI,CAEFI,SAAD;AAAA;;AAAA,WACEC,iCAAeD,SAAf,4BAA6BA,SAAS,CAACH,OAAvC,uDAA6B,mBAAmBK,UAAhD,KAA8D,CAAC,CADjE;AAAA,GAFG,EAKJJ,MALI,CAKII,UAAD,IAAwBA,UAAU,GAAG,CALxC,CAAP;AAMD;;AAEM,SAASC,cAAT,CACLC,IADK,EAEkE;AACvE,MAAIV,sBAASC,EAAT,KAAgB,KAApB,EAA2B;AACzB,WAAOS,IAAP;AACD;;AACD,SAAO,iCAAiBA,IAAjB,CAAP;AACD;;AAED,IAAIC,wBAAwB,GAAG,KAA/B;;AAEO,SAASC,uBAAT,GAAmC;AACxC,MAAI,CAACD,wBAAL,EAA+B;AAC7BA,IAAAA,wBAAwB,GAAG,IAA3B;AACAE,IAAAA,cAAc,CAAC,MAAM;AACnBC,sCAAuBC,eAAvB;;AAEAJ,MAAAA,wBAAwB,GAAG,KAA3B;AACD,KAJa,CAAd;AAKD;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.</span><span class="s3">\n</span><span class="s1">// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof</span><span class="s3">\n</span><span class="s1">// e.g. React.createRef&lt;TapGestureHandler&gt; -&gt; React.createRef&lt;typeof TapGestureHandler&gt;.</span><span class="s3">\n</span><span class="s1">// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.</span><span class="s3">\n</span><span class="s1">import * as React from 'react';</span><span class="s3">\n</span><span class="s1">import { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';</span><span class="s3">\n\n</span><span class="s1">import { State } from '../State';</span><span class="s3">\n</span><span class="s1">import { TouchEventType } from '../TouchEventType';</span><span class="s3">\n</span><span class="s1">import { ValueOf } from '../typeUtils';</span><span class="s3">\n</span><span class="s1">import { handlerIDToTag } from './handlersRegistry';</span><span class="s3">\n</span><span class="s1">import { toArray } from '../utils';</span><span class="s3">\n</span><span class="s1">import RNGestureHandlerModule from '../RNGestureHandlerModule';</span><span class="s3">\n\n</span><span class="s1">const commonProps = [</span><span class="s3">\n  </span><span class="s1">'id',</span><span class="s3">\n  </span><span class="s1">'enabled',</span><span class="s3">\n  </span><span class="s1">'shouldCancelWhenOutside',</span><span class="s3">\n  </span><span class="s1">'hitSlop',</span><span class="s3">\n  </span><span class="s1">'cancelsTouchesInView',</span><span class="s3">\n  </span><span class="s1">'userSelect',</span><span class="s3">\n</span><span class="s1">] as const;</span><span class="s3">\n\n</span><span class="s1">const componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;</span><span class="s3">\n\n</span><span class="s1">export const baseGestureHandlerProps = [</span><span class="s3">\n  </span><span class="s1">...commonProps,</span><span class="s3">\n  </span><span class="s1">...componentInteractionProps,</span><span class="s3">\n  </span><span class="s1">'onBegan',</span><span class="s3">\n  </span><span class="s1">'onFailed',</span><span class="s3">\n  </span><span class="s1">'onCancelled',</span><span class="s3">\n  </span><span class="s1">'onActivated',</span><span class="s3">\n  </span><span class="s1">'onEnded',</span><span class="s3">\n  </span><span class="s1">'onGestureEvent',</span><span class="s3">\n  </span><span class="s1">'onHandlerStateChange',</span><span class="s3">\n</span><span class="s1">] as const;</span><span class="s3">\n\n</span><span class="s1">export const baseGestureHandlerWithMonitorProps = [</span><span class="s3">\n  </span><span class="s1">...commonProps,</span><span class="s3">\n  </span><span class="s1">'needsPointerData',</span><span class="s3">\n  </span><span class="s1">'manualActivation',</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">export interface GestureEventPayload {</span><span class="s3">\n  </span><span class="s1">handlerTag: number;</span><span class="s3">\n  </span><span class="s1">numberOfPointers: number;</span><span class="s3">\n  </span><span class="s1">state: ValueOf&lt;typeof State&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export interface HandlerStateChangeEventPayload extends GestureEventPayload {</span><span class="s3">\n  </span><span class="s1">oldState: ValueOf&lt;typeof State&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type HitSlop =</span><span class="s3">\n  </span><span class="s1">| number</span><span class="s3">\n  </span><span class="s1">| Partial&lt;</span><span class="s3">\n      </span><span class="s1">Record&lt;</span><span class="s3">\n        </span><span class="s1">'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',</span><span class="s3">\n        </span><span class="s1">number</span><span class="s3">\n      </span><span class="s1">&gt;</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n  </span><span class="s1">| Record&lt;'width' | 'left', number&gt;</span><span class="s3">\n  </span><span class="s1">| Record&lt;'width' | 'right', number&gt;</span><span class="s3">\n  </span><span class="s1">| Record&lt;'height' | 'top', number&gt;</span><span class="s3">\n  </span><span class="s1">| Record&lt;'height' | 'bottom', number&gt;;</span><span class="s3">\n\n</span><span class="s1">export type UserSelect = 'none' | 'auto' | 'text';</span><span class="s3">\n\n</span><span class="s1">//TODO(TS) events in handlers</span><span class="s3">\n\n</span><span class="s1">export interface GestureEvent&lt;ExtraEventPayloadT = Record&lt;string, unknown&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">nativeEvent: Readonly&lt;GestureEventPayload &amp; ExtraEventPayloadT&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export interface HandlerStateChangeEvent&lt;</span><span class="s3">\n  </span><span class="s1">ExtraEventPayloadT = Record&lt;string, unknown&gt;</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">nativeEvent: Readonly&lt;HandlerStateChangeEventPayload &amp; ExtraEventPayloadT&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type TouchData = {</span><span class="s3">\n  </span><span class="s1">id: number;</span><span class="s3">\n  </span><span class="s1">x: number;</span><span class="s3">\n  </span><span class="s1">y: number;</span><span class="s3">\n  </span><span class="s1">absoluteX: number;</span><span class="s3">\n  </span><span class="s1">absoluteY: number;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export type GestureTouchEvent = {</span><span class="s3">\n  </span><span class="s1">handlerTag: number;</span><span class="s3">\n  </span><span class="s1">numberOfTouches: number;</span><span class="s3">\n  </span><span class="s1">state: ValueOf&lt;typeof State&gt;;</span><span class="s3">\n  </span><span class="s1">eventType: TouchEventType;</span><span class="s3">\n  </span><span class="s1">allTouches: TouchData[];</span><span class="s3">\n  </span><span class="s1">changedTouches: TouchData[];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export type GestureUpdateEvent&lt;GestureEventPayloadT = Record&lt;string, unknown&gt;&gt; =</span><span class="s3">\n  </span><span class="s1">GestureEventPayload &amp; GestureEventPayloadT;</span><span class="s3">\n\n</span><span class="s1">export type GestureStateChangeEvent&lt;</span><span class="s3">\n  </span><span class="s1">GestureStateChangeEventPayloadT = Record&lt;string, unknown&gt;</span><span class="s3">\n</span><span class="s1">&gt; = HandlerStateChangeEventPayload &amp; GestureStateChangeEventPayloadT;</span><span class="s3">\n\n</span><span class="s1">export type CommonGestureConfig = {</span><span class="s3">\n  </span><span class="s1">enabled?: boolean;</span><span class="s3">\n  </span><span class="s1">shouldCancelWhenOutside?: boolean;</span><span class="s3">\n  </span><span class="s1">hitSlop?: HitSlop;</span><span class="s3">\n  </span><span class="s1">userSelect?: UserSelect;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Events payloads are types instead of interfaces due to TS limitation.</span><span class="s3">\n</span><span class="s1">// See https://github.com/microsoft/TypeScript/issues/15300 for more info.</span><span class="s3">\n</span><span class="s1">export type BaseGestureHandlerProps&lt;</span><span class="s3">\n  </span><span class="s1">ExtraEventPayloadT extends Record&lt;string, unknown&gt; = Record&lt;string, unknown&gt;</span><span class="s3">\n</span><span class="s1">&gt; = CommonGestureConfig &amp; {</span><span class="s3">\n  </span><span class="s1">id?: string;</span><span class="s3">\n  </span><span class="s1">waitFor?: React.Ref&lt;unknown&gt; | React.Ref&lt;unknown&gt;[];</span><span class="s3">\n  </span><span class="s1">simultaneousHandlers?: React.Ref&lt;unknown&gt; | React.Ref&lt;unknown&gt;[];</span><span class="s3">\n  </span><span class="s1">testID?: string;</span><span class="s3">\n  </span><span class="s1">cancelsTouchesInView?: boolean;</span><span class="s3">\n  </span><span class="s1">// TODO(TS) - fix event types</span><span class="s3">\n  </span><span class="s1">onBegan?: (event: HandlerStateChangeEvent) =&gt; void;</span><span class="s3">\n  </span><span class="s1">onFailed?: (event: HandlerStateChangeEvent) =&gt; void;</span><span class="s3">\n  </span><span class="s1">onCancelled?: (event: HandlerStateChangeEvent) =&gt; void;</span><span class="s3">\n  </span><span class="s1">onActivated?: (event: HandlerStateChangeEvent) =&gt; void;</span><span class="s3">\n  </span><span class="s1">onEnded?: (event: HandlerStateChangeEvent) =&gt; void;</span><span class="s3">\n\n  </span><span class="s1">//TODO(TS) consider using NativeSyntheticEvent</span><span class="s3">\n  </span><span class="s1">onGestureEvent?: (event: GestureEvent&lt;ExtraEventPayloadT&gt;) =&gt; void;</span><span class="s3">\n  </span><span class="s1">onHandlerStateChange?: (</span><span class="s3">\n    </span><span class="s1">event: HandlerStateChangeEvent&lt;ExtraEventPayloadT&gt;</span><span class="s3">\n  </span><span class="s1">) =&gt; void;</span><span class="s3">\n  </span><span class="s1">// implicit `children` prop has been removed in @types/react^18.0.0</span><span class="s3">\n  </span><span class="s1">children?: React.ReactNode;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function isConfigParam(param: unknown, name: string) {</span><span class="s3">\n  </span><span class="s1">// param !== Object(param) returns false if `param` is a function</span><span class="s3">\n  </span><span class="s1">// or an object and returns true if `param` is null</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">param !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(param !== Object(param) ||</span><span class="s3">\n      </span><span class="s1">!('__isNative' in (param as Record&lt;string, unknown&gt;))) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">name !== 'onHandlerStateChange' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">name !== 'onGestureEvent'</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function filterConfig(</span><span class="s3">\n  </span><span class="s1">props: Record&lt;string, unknown&gt;,</span><span class="s3">\n  </span><span class="s1">validProps: string[],</span><span class="s3">\n  </span><span class="s1">defaults: Record&lt;string, unknown&gt; = {}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const filteredConfig = { ...defaults };</span><span class="s3">\n  </span><span class="s1">for (const key of validProps) {</span><span class="s3">\n    </span><span class="s1">let value = props[key];</span><span class="s3">\n    </span><span class="s1">if (isConfigParam(value, key)) {</span><span class="s3">\n      </span><span class="s1">if (key === 'simultaneousHandlers' || key === 'waitFor') {</span><span class="s3">\n        </span><span class="s1">value = transformIntoHandlerTags(props[key]);</span><span class="s3">\n      </span><span class="s1">} else if (key === 'hitSlop' &amp;&amp; typeof value !== 'object') {</span><span class="s3">\n        </span><span class="s1">value = { top: value, left: value, bottom: value, right: value };</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">filteredConfig[key] = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return filteredConfig;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function transformIntoHandlerTags(handlerIDs: any) {</span><span class="s3">\n  </span><span class="s1">handlerIDs = toArray(handlerIDs);</span><span class="s3">\n\n  </span><span class="s1">if (Platform.OS === 'web') {</span><span class="s3">\n    </span><span class="s1">return handlerIDs</span><span class="s3">\n      </span><span class="s1">.map(({ current }: { current: any }) =&gt; current)</span><span class="s3">\n      </span><span class="s1">.filter((handle: any) =&gt; handle);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// converts handler string IDs into their numeric tags</span><span class="s3">\n  </span><span class="s1">return handlerIDs</span><span class="s3">\n    </span><span class="s1">.map(</span><span class="s3">\n      </span><span class="s1">(handlerID: any) =&gt;</span><span class="s3">\n        </span><span class="s1">handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">.filter((handlerTag: number) =&gt; handlerTag &gt; 0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function findNodeHandle(</span><span class="s3">\n  </span><span class="s1">node: null | number | React.Component&lt;any, any&gt; | React.ComponentClass&lt;any&gt;</span><span class="s3">\n</span><span class="s1">): null | number | React.Component&lt;any, any&gt; | React.ComponentClass&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">if (Platform.OS === 'web') {</span><span class="s3">\n    </span><span class="s1">return node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return findNodeHandleRN(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let flushOperationsScheduled = false;</span><span class="s3">\n\n</span><span class="s1">export function scheduleFlushOperations() {</span><span class="s3">\n  </span><span class="s1">if (!flushOperationsScheduled) {</span><span class="s3">\n    </span><span class="s1">flushOperationsScheduled = true;</span><span class="s3">\n    </span><span class="s1">queueMicrotask(() =&gt; {</span><span class="s3">\n      </span><span class="s1">RNGestureHandlerModule.flushOperations();</span><span class="s3">\n\n      </span><span class="s1">flushOperationsScheduled = false;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>
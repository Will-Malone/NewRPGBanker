<html>
<head>
<title>v8.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb; font-style: italic;}
.s6 { color: #9876aa; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
v8.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The `node:v8` module exposes APIs that are specific to the version of [V8](https://developers.google.com/v8/) built into the Node.js binary. It can be accessed using: 
 * 
 * ```js 
 * const v8 = require('node:v8'); 
 * ``` 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/v8.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'v8' </span><span class="s3">{</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">Readable </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'node:stream'</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">HeapSpaceInfo </span><span class="s3">{</span>
        <span class="s3">space_name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s3">space_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">space_used_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">space_available_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">physical_space_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">// ** Signifies if the --zap_code_space option is enabled or not.  1 == enabled, 0 == disabled. */</span>
    <span class="s1">type </span><span class="s2">DoesZapCodeSpaceFlag </span><span class="s1">= </span><span class="s5">0 </span><span class="s1">| </span><span class="s5">1</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">HeapInfo </span><span class="s3">{</span>
        <span class="s3">total_heap_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">total_heap_size_executable</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">total_physical_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">total_available_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">used_heap_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">heap_size_limit</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">malloced_memory</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">peak_malloced_memory</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">does_zap_garbage</span><span class="s1">: </span><span class="s2">DoesZapCodeSpaceFlag</span><span class="s3">;</span>
        <span class="s3">number_of_native_contexts</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">number_of_detached_contexts</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">total_global_handles_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">used_global_handles_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">external_memory</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">HeapCodeStatistics </span><span class="s3">{</span>
        <span class="s3">code_and_metadata_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">bytecode_and_metadata_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">external_script_source_size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns an integer representing a version tag derived from the V8 version, 
     * command-line flags, and detected CPU features. This is useful for determining 
     * whether a `vm.Script` `cachedData` buffer is compatible with this instance 
     * of V8. 
     * 
     * ```js 
     * console.log(v8.cachedDataVersionTag()); // 3947234607 
     * // The value returned by v8.cachedDataVersionTag() is derived from the V8 
     * // version, command-line flags, and detected CPU features. Test that the value 
     * // does indeed update when flags are toggled. 
     * v8.setFlagsFromString('--allow_natives_syntax'); 
     * console.log(v8.cachedDataVersionTag()); // 183726201 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v8.0.0 
     */</span>
    <span class="s1">function </span><span class="s3">cachedDataVersionTag()</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns an object with the following properties: 
     * 
     * `does_zap_garbage` is a 0/1 boolean, which signifies whether the`--zap_code_space` option is enabled or not. This makes V8 overwrite heap 
     * garbage with a bit pattern. The RSS footprint (resident set size) gets bigger 
     * because it continuously touches all heap pages and that makes them less likely 
     * to get swapped out by the operating system. 
     * 
     * `number_of_native_contexts` The value of native\_context is the number of the 
     * top-level contexts currently active. Increase of this number over time indicates 
     * a memory leak. 
     * 
     * `number_of_detached_contexts` The value of detached\_context is the number 
     * of contexts that were detached and not yet garbage collected. This number 
     * being non-zero indicates a potential memory leak. 
     * 
     * `total_global_handles_size` The value of total\_global\_handles\_size is the 
     * total memory size of V8 global handles. 
     * 
     * `used_global_handles_size` The value of used\_global\_handles\_size is the 
     * used memory size of V8 global handles. 
     * 
     * `external_memory` The value of external\_memory is the memory size of array 
     * buffers and external strings. 
     * 
     * ```js 
     * { 
     *   total_heap_size: 7326976, 
     *   total_heap_size_executable: 4194304, 
     *   total_physical_size: 7326976, 
     *   total_available_size: 1152656, 
     *   used_heap_size: 3476208, 
     *   heap_size_limit: 1535115264, 
     *   malloced_memory: 16384, 
     *   peak_malloced_memory: 1127496, 
     *   does_zap_garbage: 0, 
     *   number_of_native_contexts: 1, 
     *   number_of_detached_contexts: 0, 
     *   total_global_handles_size: 8192, 
     *   used_global_handles_size: 3296, 
     *   external_memory: 318824 
     * } 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v1.0.0 
     */</span>
    <span class="s1">function </span><span class="s3">getHeapStatistics()</span><span class="s1">: </span><span class="s2">HeapInfo</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns statistics about the V8 heap spaces, i.e. the segments which make up 
     * the V8 heap. Neither the ordering of heap spaces, nor the availability of a 
     * heap space can be guaranteed as the statistics are provided via the 
     * V8[`GetHeapSpaceStatistics`](https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate.html#ac673576f24fdc7a33378f8f57e1d13a4) function and may change from one V8 version to the 
     * next. 
     * 
     * The value returned is an array of objects containing the following properties: 
     * 
     * ```json 
     * [ 
     *   { 
     *     &quot;space_name&quot;: &quot;new_space&quot;, 
     *     &quot;space_size&quot;: 2063872, 
     *     &quot;space_used_size&quot;: 951112, 
     *     &quot;space_available_size&quot;: 80824, 
     *     &quot;physical_space_size&quot;: 2063872 
     *   }, 
     *   { 
     *     &quot;space_name&quot;: &quot;old_space&quot;, 
     *     &quot;space_size&quot;: 3090560, 
     *     &quot;space_used_size&quot;: 2493792, 
     *     &quot;space_available_size&quot;: 0, 
     *     &quot;physical_space_size&quot;: 3090560 
     *   }, 
     *   { 
     *     &quot;space_name&quot;: &quot;code_space&quot;, 
     *     &quot;space_size&quot;: 1260160, 
     *     &quot;space_used_size&quot;: 644256, 
     *     &quot;space_available_size&quot;: 960, 
     *     &quot;physical_space_size&quot;: 1260160 
     *   }, 
     *   { 
     *     &quot;space_name&quot;: &quot;map_space&quot;, 
     *     &quot;space_size&quot;: 1094160, 
     *     &quot;space_used_size&quot;: 201608, 
     *     &quot;space_available_size&quot;: 0, 
     *     &quot;physical_space_size&quot;: 1094160 
     *   }, 
     *   { 
     *     &quot;space_name&quot;: &quot;large_object_space&quot;, 
     *     &quot;space_size&quot;: 0, 
     *     &quot;space_used_size&quot;: 0, 
     *     &quot;space_available_size&quot;: 1490980608, 
     *     &quot;physical_space_size&quot;: 0 
     *   } 
     * ] 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v6.0.0 
     */</span>
    <span class="s1">function </span><span class="s3">getHeapSpaceStatistics()</span><span class="s1">: </span><span class="s2">HeapSpaceInfo</span><span class="s3">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The `v8.setFlagsFromString()` method can be used to programmatically set 
     * V8 command-line flags. This method should be used with care. Changing settings 
     * after the VM has started may result in unpredictable behavior, including 
     * crashes and data loss; or it may simply do nothing. 
     * 
     * The V8 options available for a version of Node.js may be determined by running`node --v8-options`. 
     * 
     * Usage: 
     * 
     * ```js 
     * // Print GC events to stdout for one minute. 
     * const v8 = require('node:v8'); 
     * v8.setFlagsFromString('--trace_gc'); 
     * setTimeout(() =&gt; { v8.setFlagsFromString('--notrace_gc'); }, 60e3); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v1.0.0 
     */</span>
    <span class="s1">function </span><span class="s3">setFlagsFromString(</span><span class="s2">flags</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Generates a snapshot of the current V8 heap and returns a Readable 
     * Stream that may be used to read the JSON serialized representation. 
     * This JSON stream format is intended to be used with tools such as 
     * Chrome DevTools. The JSON schema is undocumented and specific to the 
     * V8 engine. Therefore, the schema may change from one version of V8 to the next. 
     * 
     * Creating a heap snapshot requires memory about twice the size of the heap at 
     * the time the snapshot is created. This results in the risk of OOM killers 
     * terminating the process. 
     * 
     * Generating a snapshot is a synchronous operation which blocks the event loop 
     * for a duration depending on the heap size. 
     * 
     * ```js 
     * // Print heap snapshot to the console 
     * const v8 = require('node:v8'); 
     * const stream = v8.getHeapSnapshot(); 
     * stream.pipe(process.stdout); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v11.13.0 
     * </span><span class="s1">@return </span><span class="s0">A Readable containing the V8 heap snapshot. 
     */</span>
    <span class="s1">function </span><span class="s3">getHeapSnapshot()</span><span class="s1">: </span><span class="s2">Readable</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Generates a snapshot of the current V8 heap and writes it to a JSON 
     * file. This file is intended to be used with tools such as Chrome 
     * DevTools. The JSON schema is undocumented and specific to the V8 
     * engine, and may change from one version of V8 to the next. 
     * 
     * A heap snapshot is specific to a single V8 isolate. When using `worker threads`, a heap snapshot generated from the main thread will 
     * not contain any information about the workers, and vice versa. 
     * 
     * Creating a heap snapshot requires memory about twice the size of the heap at 
     * the time the snapshot is created. This results in the risk of OOM killers 
     * terminating the process. 
     * 
     * Generating a snapshot is a synchronous operation which blocks the event loop 
     * for a duration depending on the heap size. 
     * 
     * ```js 
     * const { writeHeapSnapshot } = require('node:v8'); 
     * const { 
     *   Worker, 
     *   isMainThread, 
     *   parentPort, 
     * } = require('node:worker_threads'); 
     * 
     * if (isMainThread) { 
     *   const worker = new Worker(__filename); 
     * 
     *   worker.once('message', (filename) =&gt; { 
     *     console.log(`worker heapdump: ${filename}`); 
     *     // Now get a heapdump for the main thread. 
     *     console.log(`main thread heapdump: ${writeHeapSnapshot()}`); 
     *   }); 
     * 
     *   // Tell the worker to create a heapdump. 
     *   worker.postMessage('heapdump'); 
     * } else { 
     *   parentPort.once('message', (message) =&gt; { 
     *     if (message === 'heapdump') { 
     *       // Generate a heapdump for the worker 
     *       // and return the filename to the parent. 
     *       parentPort.postMessage(writeHeapSnapshot()); 
     *     } 
     *   }); 
     * } 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v11.13.0 
     * </span><span class="s1">@param </span><span class="s2">filename </span><span class="s0">The file path where the V8 heap snapshot is to be saved. If not specified, a file name with the pattern `'Heap-${yyyymmdd}-${hhmmss}-${pid}-${thread_id}.heapsnapshot'` will be 
     * generated, where `{pid}` will be the PID of the Node.js process, `{thread_id}` will be `0` when `writeHeapSnapshot()` is called from the main Node.js thread or the id of a 
     * worker thread. 
     * </span><span class="s1">@return </span><span class="s0">The filename where the snapshot was saved. 
     */</span>
    <span class="s1">function </span><span class="s3">writeHeapSnapshot(</span><span class="s2">filename</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Get statistics about code and its metadata in the heap, see 
     * V8[`GetHeapCodeAndMetadataStatistics`](https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate.html#a6079122af17612ef54ef3348ce170866) API. Returns an object with the 
     * following properties: 
     * 
     * ```js 
     * { 
     *   code_and_metadata_size: 212208, 
     *   bytecode_and_metadata_size: 161368, 
     *   external_script_source_size: 1410794, 
     *   cpu_profiler_metadata_size: 0, 
     * } 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v12.8.0 
     */</span>
    <span class="s1">function </span><span class="s3">getHeapCodeStatistics()</span><span class="s1">: </span><span class="s2">HeapCodeStatistics</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.0.0 
     */</span>
    <span class="s1">class </span><span class="s2">Serializer </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Writes out a header, which includes the serialization format version. 
         */</span>
        <span class="s3">writeHeader()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Serializes a JavaScript value and adds the serialized representation to the 
         * internal buffer. 
         * 
         * This throws an error if `value` cannot be serialized. 
         */</span>
        <span class="s3">writeValue(</span><span class="s2">val</span><span class="s1">: </span><span class="s2">any</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the stored internal buffer. This serializer should not be used once 
         * the buffer is released. Calling this method results in undefined behavior 
         * if a previous write has failed. 
         */</span>
        <span class="s3">releaseBuffer()</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Marks an `ArrayBuffer` as having its contents transferred out of band. 
         * Pass the corresponding `ArrayBuffer` in the deserializing context to `deserializer.transferArrayBuffer()`. 
         * </span><span class="s1">@param </span><span class="s2">id </span><span class="s0">A 32-bit unsigned integer. 
         * </span><span class="s1">@param </span><span class="s2">arrayBuffer </span><span class="s0">An `ArrayBuffer` instance. 
         */</span>
        <span class="s3">transferArrayBuffer(</span><span class="s2">id</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">arrayBuffer</span><span class="s1">: </span><span class="s2">ArrayBuffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Write a raw 32-bit unsigned integer. 
         * For use inside of a custom `serializer._writeHostObject()`. 
         */</span>
        <span class="s3">writeUint32(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Write a raw 64-bit unsigned integer, split into high and low 32-bit parts. 
         * For use inside of a custom `serializer._writeHostObject()`. 
         */</span>
        <span class="s3">writeUint64(</span><span class="s2">hi</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">lo</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Write a JS `number` value. 
         * For use inside of a custom `serializer._writeHostObject()`. 
         */</span>
        <span class="s3">writeDouble(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Write raw bytes into the serializer's internal buffer. The deserializer 
         * will require a way to compute the length of the buffer. 
         * For use inside of a custom `serializer._writeHostObject()`. 
         */</span>
        <span class="s3">writeRawBytes(</span><span class="s2">buffer</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">TypedArray</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A subclass of `Serializer` that serializes `TypedArray`(in particular `Buffer`) and `DataView` objects as host objects, and only 
     * stores the part of their underlying `ArrayBuffer`s that they are referring to. 
     * </span><span class="s1">@since </span><span class="s0">v8.0.0 
     */</span>
    <span class="s1">class </span><span class="s2">DefaultSerializer </span><span class="s1">extends </span><span class="s2">Serializer </span><span class="s3">{}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v8.0.0 
     */</span>
    <span class="s1">class </span><span class="s2">Deserializer </span><span class="s3">{</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">TypedArray</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Reads and validates a header (including the format version). 
         * May, for example, reject an invalid or unsupported wire format. In that case, 
         * an `Error` is thrown. 
         */</span>
        <span class="s3">readHeader()</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Deserializes a JavaScript value from the buffer and returns it. 
         */</span>
        <span class="s3">readValue()</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Marks an `ArrayBuffer` as having its contents transferred out of band. 
         * Pass the corresponding `ArrayBuffer` in the serializing context to `serializer.transferArrayBuffer()` (or return the `id` from `serializer._getSharedArrayBufferId()` in the case of 
         * `SharedArrayBuffer`s). 
         * </span><span class="s1">@param </span><span class="s2">id </span><span class="s0">A 32-bit unsigned integer. 
         * </span><span class="s1">@param </span><span class="s2">arrayBuffer </span><span class="s0">An `ArrayBuffer` instance. 
         */</span>
        <span class="s3">transferArrayBuffer(</span><span class="s2">id</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">arrayBuffer</span><span class="s1">: </span><span class="s2">ArrayBuffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Reads the underlying wire format version. Likely mostly to be useful to 
         * legacy code reading old wire format versions. May not be called before`.readHeader()`. 
         */</span>
        <span class="s3">getWireFormatVersion()</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Read a raw 32-bit unsigned integer and return it. 
         * For use inside of a custom `deserializer._readHostObject()`. 
         */</span>
        <span class="s3">readUint32()</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Read a raw 64-bit unsigned integer and return it as an array `[hi, lo]`with two 32-bit unsigned integer entries. 
         * For use inside of a custom `deserializer._readHostObject()`. 
         */</span>
        <span class="s3">readUint64()</span><span class="s1">: </span><span class="s3">[</span><span class="s2">number</span><span class="s3">, </span><span class="s2">number</span><span class="s3">];</span>
        <span class="s0">/**</span>
         <span class="s0">* Read a JS `number` value. 
         * For use inside of a custom `deserializer._readHostObject()`. 
         */</span>
        <span class="s3">readDouble()</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Read raw bytes from the deserializer's internal buffer. The `length` parameter 
         * must correspond to the length of the buffer that was passed to `serializer.writeRawBytes()`. 
         * For use inside of a custom `deserializer._readHostObject()`. 
         */</span>
        <span class="s3">readRawBytes(</span><span class="s2">length</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A subclass of `Deserializer` corresponding to the format written by `DefaultSerializer`. 
     * </span><span class="s1">@since </span><span class="s0">v8.0.0 
     */</span>
    <span class="s1">class </span><span class="s2">DefaultDeserializer </span><span class="s1">extends </span><span class="s2">Deserializer </span><span class="s3">{}</span>
    <span class="s0">/**</span>
     <span class="s0">* Uses a `DefaultSerializer` to serialize `value` into a buffer. 
     * 
     * `ERR_BUFFER_TOO_LARGE` will be thrown when trying to 
     * serialize a huge object which requires buffer 
     * larger than `buffer.constants.MAX_LENGTH`. 
     * </span><span class="s1">@since </span><span class="s0">v8.0.0 
     */</span>
    <span class="s1">function </span><span class="s3">serialize(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">any</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Uses a `DefaultDeserializer` with default options to read a JS value 
     * from a buffer. 
     * </span><span class="s1">@since </span><span class="s0">v8.0.0 
     * </span><span class="s1">@param </span><span class="s2">buffer </span><span class="s0">A buffer returned by </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">serialize}</span><span class="s0">. 
     */</span>
    <span class="s1">function </span><span class="s3">deserialize(</span><span class="s2">buffer</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">TypedArray</span><span class="s3">)</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `v8.takeCoverage()` method allows the user to write the coverage started by `NODE_V8_COVERAGE` to disk on demand. This method can be invoked multiple 
     * times during the lifetime of the process. Each time the execution counter will 
     * be reset and a new coverage report will be written to the directory specified 
     * by `NODE_V8_COVERAGE`. 
     * 
     * When the process is about to exit, one last coverage will still be written to 
     * disk unless </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">stopCoverage} </span><span class="s0">is invoked before the process exits. 
     * </span><span class="s1">@since </span><span class="s0">v15.1.0, v14.18.0, v12.22.0 
     */</span>
    <span class="s1">function </span><span class="s3">takeCoverage()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `v8.stopCoverage()` method allows the user to stop the coverage collection 
     * started by `NODE_V8_COVERAGE`, so that V8 can release the execution count 
     * records and optimize code. This can be used in conjunction with </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">takeCoverage} </span><span class="s0">if the user wants to collect the coverage on demand. 
     * </span><span class="s1">@since </span><span class="s0">v15.1.0, v14.18.0, v12.22.0 
     */</span>
    <span class="s1">function </span><span class="s3">stopCoverage()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This API collects GC data in current thread. 
     * </span><span class="s1">@since </span><span class="s0">v19.6.0, v18.15.0 
     */</span>
    <span class="s1">class </span><span class="s2">GCProfiler </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Start collecting GC data. 
         * </span><span class="s1">@since </span><span class="s0">v19.6.0, v18.15.0 
         */</span>
        <span class="s3">start()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Stop collecting GC data and return an object.The content of object 
         * is as follows. 
         * 
         * ```json 
         * { 
         *   &quot;version&quot;: 1, 
         *   &quot;startTime&quot;: 1674059033862, 
         *   &quot;statistics&quot;: [ 
         *     { 
         *       &quot;gcType&quot;: &quot;Scavenge&quot;, 
         *       &quot;beforeGC&quot;: { 
         *         &quot;heapStatistics&quot;: { 
         *           &quot;totalHeapSize&quot;: 5005312, 
         *           &quot;totalHeapSizeExecutable&quot;: 524288, 
         *           &quot;totalPhysicalSize&quot;: 5226496, 
         *           &quot;totalAvailableSize&quot;: 4341325216, 
         *           &quot;totalGlobalHandlesSize&quot;: 8192, 
         *           &quot;usedGlobalHandlesSize&quot;: 2112, 
         *           &quot;usedHeapSize&quot;: 4883840, 
         *           &quot;heapSizeLimit&quot;: 4345298944, 
         *           &quot;mallocedMemory&quot;: 254128, 
         *           &quot;externalMemory&quot;: 225138, 
         *           &quot;peakMallocedMemory&quot;: 181760 
         *         }, 
         *         &quot;heapSpaceStatistics&quot;: [ 
         *           { 
         *             &quot;spaceName&quot;: &quot;read_only_space&quot;, 
         *             &quot;spaceSize&quot;: 0, 
         *             &quot;spaceUsedSize&quot;: 0, 
         *             &quot;spaceAvailableSize&quot;: 0, 
         *             &quot;physicalSpaceSize&quot;: 0 
         *           } 
         *         ] 
         *       }, 
         *       &quot;cost&quot;: 1574.14, 
         *       &quot;afterGC&quot;: { 
         *         &quot;heapStatistics&quot;: { 
         *           &quot;totalHeapSize&quot;: 6053888, 
         *           &quot;totalHeapSizeExecutable&quot;: 524288, 
         *           &quot;totalPhysicalSize&quot;: 5500928, 
         *           &quot;totalAvailableSize&quot;: 4341101384, 
         *           &quot;totalGlobalHandlesSize&quot;: 8192, 
         *           &quot;usedGlobalHandlesSize&quot;: 2112, 
         *           &quot;usedHeapSize&quot;: 4059096, 
         *           &quot;heapSizeLimit&quot;: 4345298944, 
         *           &quot;mallocedMemory&quot;: 254128, 
         *           &quot;externalMemory&quot;: 225138, 
         *           &quot;peakMallocedMemory&quot;: 181760 
         *         }, 
         *         &quot;heapSpaceStatistics&quot;: [ 
         *           { 
         *             &quot;spaceName&quot;: &quot;read_only_space&quot;, 
         *             &quot;spaceSize&quot;: 0, 
         *             &quot;spaceUsedSize&quot;: 0, 
         *             &quot;spaceAvailableSize&quot;: 0, 
         *             &quot;physicalSpaceSize&quot;: 0 
         *           } 
         *         ] 
         *       } 
         *     } 
         *   ], 
         *   &quot;endTime&quot;: 1674059036865 
         * } 
         * ``` 
         * 
         * Here's an example. 
         * 
         * ```js 
         * const { GCProfiler } = require('v8'); 
         * const profiler = new GCProfiler(); 
         * profiler.start(); 
         * setTimeout(() =&gt; { 
         *   console.log(profiler.stop()); 
         * }, 1000); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v19.6.0, v18.15.0 
         */</span>
        <span class="s3">stop()</span><span class="s1">: </span><span class="s2">GCProfilerResult</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">GCProfilerResult </span><span class="s3">{</span>
        <span class="s3">version</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">startTime</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">endTime</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">statistics</span><span class="s1">: </span><span class="s2">Array</span><span class="s3">&lt;{</span>
            <span class="s3">gcType</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
            <span class="s3">cost</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s3">beforeGC</span><span class="s1">: </span><span class="s3">{</span>
                <span class="s3">heapStatistics</span><span class="s1">: </span><span class="s2">HeapStatistics</span><span class="s3">;</span>
                <span class="s3">heapSpaceStatistics</span><span class="s1">: </span><span class="s2">HeapSpaceStatistics</span><span class="s3">[];</span>
            <span class="s3">};</span>
            <span class="s3">afterGC</span><span class="s1">: </span><span class="s3">{</span>
                <span class="s3">heapStatistics</span><span class="s1">: </span><span class="s2">HeapStatistics</span><span class="s3">;</span>
                <span class="s3">heapSpaceStatistics</span><span class="s1">: </span><span class="s2">HeapSpaceStatistics</span><span class="s3">[];</span>
            <span class="s3">};</span>
        <span class="s3">}&gt;;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">HeapStatistics </span><span class="s3">{</span>
        <span class="s3">totalHeapSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">totalHeapSizeExecutable</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">totalPhysicalSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">totalAvailableSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">totalGlobalHandlesSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">usedGlobalHandlesSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">usedHeapSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">heapSizeLimit</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">mallocedMemory</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">externalMemory</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">peakMallocedMemory</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">HeapSpaceStatistics </span><span class="s3">{</span>
        <span class="s3">spaceName</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s3">spaceSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">spaceUsedSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">spaceAvailableSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">physicalSpaceSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Called when a promise is constructed. This does not mean that corresponding before/after events will occur, only that the possibility exists. This will 
     * happen if a promise is created without ever getting a continuation. 
     * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
     * </span><span class="s1">@param </span><span class="s2">promise </span><span class="s0">The promise being created. 
     * </span><span class="s1">@param </span><span class="s2">parent </span><span class="s0">The promise continued from, if applicable. 
     */</span>
    <span class="s1">interface </span><span class="s2">Init </span><span class="s3">{</span>
        <span class="s3">(</span><span class="s2">promise</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">unknown</span><span class="s3">&gt;, </span><span class="s2">parent</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">unknown</span><span class="s3">&gt;)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Called before a promise continuation executes. This can be in the form of `then()`, `catch()`, or `finally()` handlers or an await resuming. 
     * 
     * The before callback will be called 0 to N times. The before callback will typically be called 0 times if no continuation was ever made for the promise. 
     * The before callback may be called many times in the case where many continuations have been made from the same promise. 
     * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
     */</span>
    <span class="s1">interface </span><span class="s2">Before </span><span class="s3">{</span>
        <span class="s3">(</span><span class="s2">promise</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">unknown</span><span class="s3">&gt;)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Called immediately after a promise continuation executes. This may be after a `then()`, `catch()`, or `finally()` handler or before an await after another await. 
     * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
     */</span>
    <span class="s1">interface </span><span class="s2">After </span><span class="s3">{</span>
        <span class="s3">(</span><span class="s2">promise</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">unknown</span><span class="s3">&gt;)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Called when the promise receives a resolution or rejection value. This may occur synchronously in the case of </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Promise.resolve()} </span><span class="s0">or 
     * </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Promise.reject()}</span><span class="s0">. 
     * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
     */</span>
    <span class="s1">interface </span><span class="s2">Settled </span><span class="s3">{</span>
        <span class="s3">(</span><span class="s2">promise</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">unknown</span><span class="s3">&gt;)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Key events in the lifetime of a promise have been categorized into four areas: creation of a promise, before/after a continuation handler is called or 
     * around an await, and when the promise resolves or rejects. 
     * 
     * Because promises are asynchronous resources whose lifecycle is tracked via the promise hooks mechanism, the `init()`, `before()`, `after()`, and 
     * `settled()` callbacks must not be async functions as they create more promises which would produce an infinite loop. 
     * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
     */</span>
    <span class="s1">interface </span><span class="s2">HookCallbacks </span><span class="s3">{</span>
        <span class="s3">init</span><span class="s1">?: </span><span class="s2">Init</span><span class="s3">;</span>
        <span class="s3">before</span><span class="s1">?: </span><span class="s2">Before</span><span class="s3">;</span>
        <span class="s3">after</span><span class="s1">?: </span><span class="s2">After</span><span class="s3">;</span>
        <span class="s3">settled</span><span class="s1">?: </span><span class="s2">Settled</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">PromiseHooks </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The `init` hook must be a plain function. Providing an async function will throw as it would produce an infinite microtask loop. 
         * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
         * </span><span class="s1">@param </span><span class="s2">init </span><span class="s0">The </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Init | `init` callback} </span><span class="s0">to call when a promise is created. 
         * </span><span class="s1">@return </span><span class="s0">Call to stop the hook. 
         */</span>
        <span class="s3">onInit</span><span class="s1">: </span><span class="s3">(</span><span class="s2">init</span><span class="s1">: </span><span class="s2">Init</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">Function</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `settled` hook must be a plain function. Providing an async function will throw as it would produce an infinite microtask loop. 
         * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
         * </span><span class="s1">@param </span><span class="s2">settled </span><span class="s0">The </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Settled | `settled` callback} </span><span class="s0">to call when a promise is created. 
         * </span><span class="s1">@return </span><span class="s0">Call to stop the hook. 
         */</span>
        <span class="s3">onSettled</span><span class="s1">: </span><span class="s3">(</span><span class="s2">settled</span><span class="s1">: </span><span class="s2">Settled</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">Function</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `before` hook must be a plain function. Providing an async function will throw as it would produce an infinite microtask loop. 
         * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
         * </span><span class="s1">@param </span><span class="s2">before </span><span class="s0">The </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Before | `before` callback} </span><span class="s0">to call before a promise continuation executes. 
         * </span><span class="s1">@return </span><span class="s0">Call to stop the hook. 
         */</span>
        <span class="s3">onBefore</span><span class="s1">: </span><span class="s3">(</span><span class="s2">before</span><span class="s1">: </span><span class="s2">Before</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">Function</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `after` hook must be a plain function. Providing an async function will throw as it would produce an infinite microtask loop. 
         * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
         * </span><span class="s1">@param </span><span class="s2">after </span><span class="s0">The </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">After | `after` callback} </span><span class="s0">to call after a promise continuation executes. 
         * </span><span class="s1">@return </span><span class="s0">Call to stop the hook. 
         */</span>
        <span class="s3">onAfter</span><span class="s1">: </span><span class="s3">(</span><span class="s2">after</span><span class="s1">: </span><span class="s2">After</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">Function</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Registers functions to be called for different lifetime events of each promise. 
         * The callbacks `init()`/`before()`/`after()`/`settled()` are called for the respective events during a promise's lifetime. 
         * All callbacks are optional. For example, if only promise creation needs to be tracked, then only the init callback needs to be passed. 
         * The hook callbacks must be plain functions. Providing async functions will throw as it would produce an infinite microtask loop. 
         * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
         * </span><span class="s1">@param </span><span class="s2">callbacks </span><span class="s0">The </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">HookCallbacks | Hook Callbacks} </span><span class="s0">to register 
         * </span><span class="s1">@return </span><span class="s0">Used for disabling hooks 
         */</span>
        <span class="s3">createHook</span><span class="s1">: </span><span class="s3">(</span><span class="s2">callbacks</span><span class="s1">: </span><span class="s2">HookCallbacks</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">Function</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `promiseHooks` interface can be used to track promise lifecycle events. 
     * </span><span class="s1">@since </span><span class="s0">v17.1.0, v16.14.0 
     */</span>
    <span class="s1">const </span><span class="s3">promiseHooks</span><span class="s1">: </span><span class="s2">PromiseHooks</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s1">declare module </span><span class="s4">'node:v8' </span><span class="s3">{</span>
    <span class="s1">export </span><span class="s6">* </span><span class="s1">from </span><span class="s4">'v8'</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>jsi.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
jsi.h</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#pragma </span><span class="s1">once</span>

<span class="s2">#include </span><span class="s3">&lt;cassert&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;cstring&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;exception&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;functional&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;memory&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;string&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;vector&gt;</span>

<span class="s2">#ifndef </span><span class="s1">JSI_EXPORT</span>
<span class="s2">#ifdef </span><span class="s1">_MSC_VER</span>
<span class="s2">#ifdef </span><span class="s1">CREATE_SHARED_LIBRARY</span>
<span class="s2">#define </span><span class="s1">JSI_EXPORT </span><span class="s4">__declspec</span><span class="s1">(dllexport)</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">JSI_EXPORT</span>
<span class="s2">#endif </span><span class="s0">// CREATE_SHARED_LIBRARY</span>
<span class="s2">#else </span><span class="s0">// _MSC_VER</span>
<span class="s2">#define </span><span class="s1">JSI_EXPORT </span><span class="s4">__attribute__</span><span class="s1">((visibility(</span><span class="s3">&quot;default&quot;</span><span class="s1">)))</span>
<span class="s2">#endif </span><span class="s0">// _MSC_VER</span>
<span class="s2">#endif </span><span class="s0">// !defined(JSI_EXPORT)</span>

<span class="s4">class </span><span class="s1">FBJSRuntime</span><span class="s4">;</span>
<span class="s4">namespace </span><span class="s1">facebook {</span>
<span class="s4">namespace </span><span class="s1">jsi {</span>

<span class="s0">/// Base class for buffers of data or bytecode that need to be passed to the</span>
<span class="s0">/// runtime. The buffer is expected to be fully immutable, so the result of</span>
<span class="s0">/// size(), data(), and the contents of the pointer returned by data() must not</span>
<span class="s0">/// change after construction.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Buffer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">virtual </span><span class="s1">~Buffer()</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">size_t size() </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual const </span><span class="s1">uint8_t* data() </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">class </span><span class="s1">JSI_EXPORT StringBuffer : </span><span class="s4">public </span><span class="s1">Buffer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">StringBuffer(std::string s) : s_(std::move(s)) {}</span>
  <span class="s1">size_t size() </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">s_.size()</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">const </span><span class="s1">uint8_t* data() </span><span class="s4">const </span><span class="s1">override {</span>
    <span class="s4">return reinterpret_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">uint8_t*&gt;(s_.data())</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s1">std::string s_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Base class for buffers of data that need to be passed to the runtime. The</span>
<span class="s0">/// result of size() and data() must not change after construction. However, the</span>
<span class="s0">/// region pointed to by data() may be modified by the user or the runtime. The</span>
<span class="s0">/// user must ensure that access to the contents of the buffer is properly</span>
<span class="s0">/// synchronised.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT MutableBuffer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">virtual </span><span class="s1">~MutableBuffer()</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">size_t size() </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">uint8_t* data() = </span><span class="s5">0</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// PreparedJavaScript is a base class representing JavaScript which is in a</span>
<span class="s0">/// form optimized for execution, in a runtime-specific way. Construct one via</span>
<span class="s0">/// jsi::Runtime::prepareJavaScript().</span>
<span class="s0">/// ** This is an experimental API that is subject to change. **</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT PreparedJavaScript {</span>
 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s1">PreparedJavaScript() = </span><span class="s4">default;</span>

 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">virtual </span><span class="s1">~PreparedJavaScript() = </span><span class="s5">0</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">class </span><span class="s1">Runtime</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Pointer</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">PropNameID</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Symbol</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">BigInt</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">String</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Object</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">WeakObject</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Array</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">ArrayBuffer</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Function</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Value</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Instrumentation</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Scope</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">JSIException</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">JSError</span><span class="s4">;</span>

<span class="s0">/// A function which has this type can be registered as a function</span>
<span class="s0">/// callable from JavaScript using Function::createFromHostFunction().</span>
<span class="s0">/// When the function is called, args will point to the arguments, and</span>
<span class="s0">/// count will indicate how many arguments are passed.  The function</span>
<span class="s0">/// can return a Value to the caller, or throw an exception.  If a C++</span>
<span class="s0">/// exception is thrown, a JS Error will be created and thrown into</span>
<span class="s0">/// JS; if the C++ exception extends std::exception, the Error's</span>
<span class="s0">/// message will be whatever what() returns. Note that it is undefined whether</span>
<span class="s0">/// HostFunctions may or may not be called in strict mode; that is `thisVal`</span>
<span class="s0">/// can be any value - it will not necessarily be coerced to an object or</span>
<span class="s0">/// or set to the global object.</span>
<span class="s4">using </span><span class="s1">HostFunctionType = std::function&lt;</span>
    <span class="s1">Value(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Value&amp; thisVal</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count)&gt;</span><span class="s4">;</span>

<span class="s0">/// An object which implements this interface can be registered as an</span>
<span class="s0">/// Object with the JS runtime.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT HostObject {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s0">// The C++ object's dtor will be called when the GC finalizes this</span>
  <span class="s0">// object.  (This may be as late as when the Runtime is shut down.)</span>
  <span class="s0">// You have no control over which thread it is called on.  This will</span>
  <span class="s0">// be called from inside the GC, so it is unsafe to do any VM</span>
  <span class="s0">// operations which require a Runtime&amp;.  Derived classes' dtors</span>
  <span class="s0">// should also avoid doing anything expensive.  Calling the dtor on</span>
  <span class="s0">// a jsi object is explicitly ok.  If you want to do JS operations,</span>
  <span class="s0">// or any nontrivial work, you should add it to a work queue, and</span>
  <span class="s0">// manage it externally.</span>
  <span class="s4">virtual </span><span class="s1">~HostObject()</span><span class="s4">;</span>

  <span class="s0">// When JS wants a property with a given name from the HostObject,</span>
  <span class="s0">// it will call this method.  If it throws an exception, the call</span>
  <span class="s0">// will throw a JS \c Error object. By default this returns undefined.</span>
  <span class="s0">// \return the value for the property.</span>
  <span class="s4">virtual </span><span class="s1">Value get(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name)</span><span class="s4">;</span>

  <span class="s0">// When JS wants to set a property with a given name on the HostObject,</span>
  <span class="s0">// it will call this method. If it throws an exception, the call will</span>
  <span class="s0">// throw a JS \c Error object. By default this throws a type error exception</span>
  <span class="s0">// mimicking the behavior of a frozen object in strict mode.</span>
  <span class="s4">virtual void </span><span class="s1">set(Runtime&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name</span><span class="s4">, const </span><span class="s1">Value&amp; value)</span><span class="s4">;</span>

  <span class="s0">// When JS wants a list of property names for the HostObject, it will</span>
  <span class="s0">// call this method. If it throws an exception, the call will throw a</span>
  <span class="s0">// JS \c Error object. The default implementation returns empty vector.</span>
  <span class="s4">virtual </span><span class="s1">std::vector&lt;PropNameID&gt; getPropertyNames(Runtime&amp; rt)</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Native state (and destructor) that can be attached to any JS object</span>
<span class="s0">/// using setNativeState.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT NativeState {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">virtual </span><span class="s1">~NativeState()</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents a JS runtime.  Movable, but not copyable.  Note that</span>
<span class="s0">/// this object may not be thread-aware, but cannot be used safely from</span>
<span class="s0">/// multiple threads at once.  The application is responsible for</span>
<span class="s0">/// ensuring that it is used safely.  This could mean using the</span>
<span class="s0">/// Runtime from a single thread, using a mutex, doing all work on a</span>
<span class="s0">/// serial queue, etc.  This restriction applies to the methods of</span>
<span class="s0">/// this class, and any method in the API which take a Runtime&amp; as an</span>
<span class="s0">/// argument.  Destructors (all but ~Scope), operators, or other methods</span>
<span class="s0">/// which do not take Runtime&amp; as an argument are safe to call from any</span>
<span class="s0">/// thread, but it is still forbidden to make write operations on a single</span>
<span class="s0">/// instance of any class from more than one thread.  In addition, to</span>
<span class="s0">/// make shutdown safe, destruction of objects associated with the Runtime</span>
<span class="s0">/// must be destroyed before the Runtime is destroyed, or from the</span>
<span class="s0">/// destructor of a managed HostObject or HostFunction.  Informally, this</span>
<span class="s0">/// means that the main source of unsafe behavior is to hold a jsi object</span>
<span class="s0">/// in a non-Runtime-managed object, and not clean it up before the Runtime</span>
<span class="s0">/// is shut down.  If your lifecycle is such that avoiding this is hard,</span>
<span class="s0">/// you will probably need to do use your own locks.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Runtime {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">virtual </span><span class="s1">~Runtime()</span><span class="s4">;</span>

  <span class="s0">/// Evaluates the given JavaScript \c buffer.  \c sourceURL is used</span>
  <span class="s0">/// to annotate the stack trace if there is an exception.  The</span>
  <span class="s0">/// contents may be utf8-encoded JS source code, or binary bytecode</span>
  <span class="s0">/// whose format is specific to the implementation.  If the input</span>
  <span class="s0">/// format is unknown, or evaluation causes an error, a JSIException</span>
  <span class="s0">/// will be thrown.</span>
  <span class="s0">/// Note this function should ONLY be used when there isn't another means</span>
  <span class="s0">/// through the JSI API. For example, it will be much slower to use this to</span>
  <span class="s0">/// call a global function than using the JSI APIs to read the function</span>
  <span class="s0">/// property from the global object and then calling it explicitly.</span>
  <span class="s4">virtual </span><span class="s1">Value evaluateJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">Buffer&gt;&amp; buffer</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">std::string&amp; sourceURL) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">/// Prepares to evaluate the given JavaScript \c buffer by processing it into</span>
  <span class="s0">/// a form optimized for execution. This may include pre-parsing, compiling,</span>
  <span class="s0">/// etc. If the input is invalid (for example, cannot be parsed), a</span>
  <span class="s0">/// JSIException will be thrown. The resulting object is tied to the</span>
  <span class="s0">/// particular concrete type of Runtime from which it was created. It may be</span>
  <span class="s0">/// used (via evaluatePreparedJavaScript) in any Runtime of the same concrete</span>
  <span class="s0">/// type.</span>
  <span class="s0">/// The PreparedJavaScript object may be passed to multiple VM instances, so</span>
  <span class="s0">/// they can all share and benefit from the prepared script.</span>
  <span class="s0">/// As with evaluateJavaScript(), using JavaScript code should be avoided</span>
  <span class="s0">/// when the JSI API is sufficient.</span>
  <span class="s4">virtual </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">PreparedJavaScript&gt; prepareJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">Buffer&gt;&amp; buffer</span><span class="s4">,</span>
      <span class="s1">std::string sourceURL) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">/// Evaluates a PreparedJavaScript. If evaluation causes an error, a</span>
  <span class="s0">/// JSIException will be thrown.</span>
  <span class="s0">/// As with evaluateJavaScript(), using JavaScript code should be avoided</span>
  <span class="s0">/// when the JSI API is sufficient.</span>
  <span class="s4">virtual </span><span class="s1">Value evaluatePreparedJavaScript(</span>
      <span class="s4">const </span><span class="s1">std::shared_ptr&lt;</span><span class="s4">const </span><span class="s1">PreparedJavaScript&gt;&amp; js) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">/// Drain the JavaScript VM internal Microtask (a.k.a. Job in ECMA262) queue.</span>
  <span class="s0">///</span>
  <span class="s0">/// \param maxMicrotasksHint a hint to tell an implementation that it should</span>
  <span class="s0">/// make a best effort not execute more than the given number. It's default</span>
  <span class="s0">/// to -1 for infinity (unbounded execution).</span>
  <span class="s0">/// \return true if the queue is drained or false if there is more work to do.</span>
  <span class="s0">///</span>
  <span class="s0">/// When there were exceptions thrown from the execution of microtasks,</span>
  <span class="s0">/// implementations shall discard the exceptional jobs. An implementation may</span>
  <span class="s0">/// \throw a \c JSError object to signal the hosts to handle. In that case, an</span>
  <span class="s0">/// implementation may or may not suspend the draining.</span>
  <span class="s0">///</span>
  <span class="s0">/// Hosts may call this function again to resume the draining if it was</span>
  <span class="s0">/// suspended due to either exceptions or the \p maxMicrotasksHint bound.</span>
  <span class="s0">/// E.g. a host may repetitively invoke this function until the queue is</span>
  <span class="s0">/// drained to implement the &quot;microtask checkpoint&quot; defined in WHATWG HTML</span>
  <span class="s0">/// event loop: https://html.spec.whatwg.org/C#perform-a-microtask-checkpoint.</span>
  <span class="s0">///</span>
  <span class="s0">/// Note that error propagation is only a concern if a host needs to implement</span>
  <span class="s0">/// `queueMicrotask`, a recent API that allows enqueueing arbitrary functions</span>
  <span class="s0">/// (hence may throw) as microtasks. Exceptions from ECMA-262 Promise Jobs are</span>
  <span class="s0">/// handled internally to VMs and are never propagated to hosts.</span>
  <span class="s0">///</span>
  <span class="s0">/// This API offers some queue management to hosts at its best effort due to</span>
  <span class="s0">/// different behaviors and limitations imposed by different VMs and APIs. By</span>
  <span class="s0">/// the time this is written, An implementation may swallow exceptions (JSC),</span>
  <span class="s0">/// may not pause (V8), and may not support bounded executions.</span>
  <span class="s4">virtual bool </span><span class="s1">drainMicrotasks(</span><span class="s4">int </span><span class="s1">maxMicrotasksHint = -</span><span class="s5">1</span><span class="s1">) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">/// \return the global object</span>
  <span class="s4">virtual </span><span class="s1">Object global() = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">/// \return a short printable description of the instance.  It should</span>
  <span class="s0">/// at least include some human-readable indication of the runtime</span>
  <span class="s0">/// implementation.  This should only be used by logging, debugging,</span>
  <span class="s0">/// and other developer-facing callers.</span>
  <span class="s4">virtual </span><span class="s1">std::string description() = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">/// \return whether or not the underlying runtime supports debugging via the</span>
  <span class="s0">/// Chrome remote debugging protocol.</span>
  <span class="s0">///</span>
  <span class="s0">/// NOTE: the API for determining whether a runtime is debuggable and</span>
  <span class="s0">/// registering a runtime with the debugger is still in flux, so please don't</span>
  <span class="s0">/// use this API unless you know what you're doing.</span>
  <span class="s4">virtual bool </span><span class="s1">isInspectable() = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">/// \return an interface to extract metrics from this \c Runtime.  The default</span>
  <span class="s0">/// implementation of this function returns an \c Instrumentation instance</span>
  <span class="s0">/// which returns no metrics.</span>
  <span class="s4">virtual </span><span class="s1">Instrumentation&amp; instrumentation()</span><span class="s4">;</span>

 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s4">friend class </span><span class="s1">Pointer</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">PropNameID</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Symbol</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">BigInt</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">String</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Object</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">WeakObject</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Array</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">ArrayBuffer</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Function</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Scope</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">JSError</span><span class="s4">;</span>

  <span class="s0">// Potential optimization: avoid the cloneFoo() virtual dispatch,</span>
  <span class="s0">// and instead just fix the number of fields, and copy them, since</span>
  <span class="s0">// in practice they are trivially copyable.  Sufficient use of</span>
  <span class="s0">// rvalue arguments/methods would also reduce the number of clones.</span>

  <span class="s4">struct </span><span class="s1">PointerValue {</span>
    <span class="s4">virtual void </span><span class="s1">invalidate() = </span><span class="s5">0</span><span class="s4">;</span>

   <span class="s4">protected</span><span class="s1">:</span>
    <span class="s4">virtual </span><span class="s1">~PointerValue() = </span><span class="s4">default;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">PointerValue* cloneSymbol(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">PointerValue* cloneBigInt(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">PointerValue* cloneString(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">PointerValue* cloneObject(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">PointerValue* clonePropNameID(</span><span class="s4">const </span><span class="s1">Runtime::PointerValue* pv) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">PropNameID createPropNameIDFromAscii(</span>
      <span class="s4">const char</span><span class="s1">* str</span><span class="s4">,</span>
      <span class="s1">size_t length) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">PropNameID createPropNameIDFromUtf8(</span>
      <span class="s4">const </span><span class="s1">uint8_t* utf8</span><span class="s4">,</span>
      <span class="s1">size_t length) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">PropNameID createPropNameIDFromString(</span><span class="s4">const </span><span class="s1">String&amp; str) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">PropNameID createPropNameIDFromSymbol(</span><span class="s4">const </span><span class="s1">Symbol&amp; sym) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">std::string utf8(</span><span class="s4">const </span><span class="s1">PropNameID&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">compare(</span><span class="s4">const </span><span class="s1">PropNameID&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp;) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">std::string symbolToString(</span><span class="s4">const </span><span class="s1">Symbol&amp;) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">BigInt createBigIntFromInt64(int64_t) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">BigInt createBigIntFromUint64(uint64_t) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">bigintIsInt64(</span><span class="s4">const </span><span class="s1">BigInt&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">bigintIsUint64(</span><span class="s4">const </span><span class="s1">BigInt&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">uint64_t truncate(</span><span class="s4">const </span><span class="s1">BigInt&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">String bigintToString(</span><span class="s4">const </span><span class="s1">BigInt&amp;</span><span class="s4">, int</span><span class="s1">) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">String createStringFromAscii(</span><span class="s4">const char</span><span class="s1">* str</span><span class="s4">, </span><span class="s1">size_t length) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">String createStringFromUtf8(</span><span class="s4">const </span><span class="s1">uint8_t* utf8</span><span class="s4">, </span><span class="s1">size_t length) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">std::string utf8(</span><span class="s4">const </span><span class="s1">String&amp;) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">// \return a \c Value created from a utf8-encoded JSON string. The default</span>
  <span class="s0">// implementation creates a \c String and invokes JSON.parse.</span>
  <span class="s4">virtual </span><span class="s1">Value createValueFromJsonUtf8(</span><span class="s4">const </span><span class="s1">uint8_t* json</span><span class="s4">, </span><span class="s1">size_t length)</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">Object createObject() = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">Object createObject(std::shared_ptr&lt;HostObject&gt; ho) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">std::shared_ptr&lt;HostObject&gt; getHostObject(</span><span class="s4">const </span><span class="s1">jsi::Object&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">HostFunctionType&amp; getHostFunction(</span><span class="s4">const </span><span class="s1">jsi::Function&amp;) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual bool </span><span class="s1">hasNativeState(</span><span class="s4">const </span><span class="s1">jsi::Object&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">std::shared_ptr&lt;NativeState&gt; getNativeState(</span><span class="s4">const </span><span class="s1">jsi::Object&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual void </span><span class="s1">setNativeState(</span>
      <span class="s4">const </span><span class="s1">jsi::Object&amp;</span><span class="s4">,</span>
      <span class="s1">std::shared_ptr&lt;NativeState&gt; state) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">Value getProperty(</span><span class="s4">const </span><span class="s1">Object&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">Value getProperty(</span><span class="s4">const </span><span class="s1">Object&amp;</span><span class="s4">, const </span><span class="s1">String&amp; name) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">hasProperty(</span><span class="s4">const </span><span class="s1">Object&amp;</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">hasProperty(</span><span class="s4">const </span><span class="s1">Object&amp;</span><span class="s4">, const </span><span class="s1">String&amp; name) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual void </span><span class="s1">setPropertyValue(</span>
      <span class="s4">const </span><span class="s1">Object&amp;</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">PropNameID&amp; name</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value&amp; value) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual void</span>
  <span class="s1">setPropertyValue(</span><span class="s4">const </span><span class="s1">Object&amp;</span><span class="s4">, const </span><span class="s1">String&amp; name</span><span class="s4">, const </span><span class="s1">Value&amp; value) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual bool </span><span class="s1">isArray(</span><span class="s4">const </span><span class="s1">Object&amp;) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">isArrayBuffer(</span><span class="s4">const </span><span class="s1">Object&amp;) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">isFunction(</span><span class="s4">const </span><span class="s1">Object&amp;) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">isHostObject(</span><span class="s4">const </span><span class="s1">jsi::Object&amp;) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">isHostFunction(</span><span class="s4">const </span><span class="s1">jsi::Function&amp;) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">Array getPropertyNames(</span><span class="s4">const </span><span class="s1">Object&amp;) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">WeakObject createWeakObject(</span><span class="s4">const </span><span class="s1">Object&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">Value lockWeakObject(</span><span class="s4">const </span><span class="s1">WeakObject&amp;) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">Array createArray(size_t length) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">ArrayBuffer createArrayBuffer(</span>
      <span class="s1">std::shared_ptr&lt;MutableBuffer&gt; buffer) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">size_t size(</span><span class="s4">const </span><span class="s1">Array&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">size_t size(</span><span class="s4">const </span><span class="s1">ArrayBuffer&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">uint8_t* data(</span><span class="s4">const </span><span class="s1">ArrayBuffer&amp;) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">Value getValueAtIndex(</span><span class="s4">const </span><span class="s1">Array&amp;</span><span class="s4">, </span><span class="s1">size_t i) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual void</span>
  <span class="s1">setValueAtIndexImpl(</span><span class="s4">const </span><span class="s1">Array&amp;</span><span class="s4">, </span><span class="s1">size_t i</span><span class="s4">, const </span><span class="s1">Value&amp; value) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual </span><span class="s1">Function createFunctionFromHostFunction(</span>
      <span class="s4">const </span><span class="s1">PropNameID&amp; name</span><span class="s4">,</span>
      <span class="s4">unsigned int </span><span class="s1">paramCount</span><span class="s4">,</span>
      <span class="s1">HostFunctionType func) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">Value call(</span>
      <span class="s4">const </span><span class="s1">Function&amp;</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value&amp; jsThis</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value* args</span><span class="s4">,</span>
      <span class="s1">size_t count) = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">Value</span>
  <span class="s1">callAsConstructor(</span><span class="s4">const </span><span class="s1">Function&amp;</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">// Private data for managing scopes.</span>
  <span class="s4">struct </span><span class="s1">ScopeState</span><span class="s4">;</span>
  <span class="s4">virtual </span><span class="s1">ScopeState* pushScope()</span><span class="s4">;</span>
  <span class="s4">virtual void </span><span class="s1">popScope(ScopeState*)</span><span class="s4">;</span>

  <span class="s4">virtual bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">Symbol&amp; a</span><span class="s4">, const </span><span class="s1">Symbol&amp; b) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">BigInt&amp; a</span><span class="s4">, const </span><span class="s1">BigInt&amp; b) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">String&amp; a</span><span class="s4">, const </span><span class="s1">String&amp; b) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">virtual bool </span><span class="s1">strictEquals(</span><span class="s4">const </span><span class="s1">Object&amp; a</span><span class="s4">, const </span><span class="s1">Object&amp; b) </span><span class="s4">const </span><span class="s1">= </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s4">virtual bool </span><span class="s1">instanceOf(</span><span class="s4">const </span><span class="s1">Object&amp; o</span><span class="s4">, const </span><span class="s1">Function&amp; f) = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s0">// These exist so derived classes can access the private parts of</span>
  <span class="s0">// Value, Symbol, String, and Object, which are all friends of Runtime.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt;</span>
  <span class="s4">static </span><span class="s1">T make(PointerValue* pv)</span><span class="s4">;</span>
  <span class="s4">static </span><span class="s1">PointerValue* getPointerValue(Pointer&amp; pointer)</span><span class="s4">;</span>
  <span class="s4">static const </span><span class="s1">PointerValue* getPointerValue(</span><span class="s4">const </span><span class="s1">Pointer&amp; pointer)</span><span class="s4">;</span>
  <span class="s4">static const </span><span class="s1">PointerValue* getPointerValue(</span><span class="s4">const </span><span class="s1">Value&amp; value)</span><span class="s4">;</span>

  <span class="s4">friend class </span><span class="s1">::FBJSRuntime</span><span class="s4">;</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">Plain</span><span class="s4">, typename </span><span class="s1">Base&gt;</span>
  <span class="s4">friend class </span><span class="s1">RuntimeDecorator</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">// Base class for pointer-storing types.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Pointer {</span>
 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s4">explicit </span><span class="s1">Pointer(Pointer&amp;&amp; other) : ptr_(other.ptr_) {</span>
    <span class="s1">other.ptr_ = </span><span class="s4">nullptr;</span>
  <span class="s1">}</span>

  <span class="s1">~Pointer() {</span>
    <span class="s4">if </span><span class="s1">(ptr_) {</span>
      <span class="s1">ptr_-&gt;invalidate()</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">Pointer&amp; </span><span class="s4">operator</span><span class="s1">=(Pointer&amp;&amp; other)</span><span class="s4">;</span>

  <span class="s4">friend class </span><span class="s1">Runtime</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>

  <span class="s4">explicit </span><span class="s1">Pointer(Runtime::PointerValue* ptr) : ptr_(ptr) {}</span>

  <span class="s4">typename </span><span class="s1">Runtime::PointerValue* ptr_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents something that can be a JS property key.  Movable, not copyable.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT PropNameID : </span><span class="s4">public </span><span class="s1">Pointer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">using </span><span class="s1">Pointer::Pointer</span><span class="s4">;</span>

  <span class="s1">PropNameID(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">PropNameID&amp; other)</span>
      <span class="s1">: Pointer(runtime.clonePropNameID(other.ptr_)) {}</span>

  <span class="s1">PropNameID(PropNameID&amp;&amp; other) = </span><span class="s4">default;</span>
  <span class="s1">PropNameID&amp; </span><span class="s4">operator</span><span class="s1">=(PropNameID&amp;&amp; other) = </span><span class="s4">default;</span>

  <span class="s0">/// Create a JS property name id from ascii values.  The data is</span>
  <span class="s0">/// copied.</span>
  <span class="s4">static </span><span class="s1">PropNameID forAscii(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* str</span><span class="s4">, </span><span class="s1">size_t length) {</span>
    <span class="s4">return </span><span class="s1">runtime.createPropNameIDFromAscii(str</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a property name id from a nul-terminated C ascii name.  The data is</span>
  <span class="s0">/// copied.</span>
  <span class="s4">static </span><span class="s1">PropNameID forAscii(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* str) {</span>
    <span class="s4">return </span><span class="s1">forAscii(runtime</span><span class="s4">, </span><span class="s1">str</span><span class="s4">, </span><span class="s1">strlen(str))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a PropNameID from a C++ string. The string is copied.</span>
  <span class="s4">static </span><span class="s1">PropNameID forAscii(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">std::string&amp; str) {</span>
    <span class="s4">return </span><span class="s1">forAscii(runtime</span><span class="s4">, </span><span class="s1">str.c_str()</span><span class="s4">, </span><span class="s1">str.size())</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a PropNameID from utf8 values.  The data is copied.</span>
  <span class="s0">/// Results are undefined if \p utf8 contains invalid code points.</span>
  <span class="s4">static </span><span class="s1">PropNameID</span>
  <span class="s1">forUtf8(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">uint8_t* utf8</span><span class="s4">, </span><span class="s1">size_t length) {</span>
    <span class="s4">return </span><span class="s1">runtime.createPropNameIDFromUtf8(utf8</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a PropNameID from utf8-encoded octets stored in a</span>
  <span class="s0">/// std::string.  The string data is transformed and copied.</span>
  <span class="s0">/// Results are undefined if \p utf8 contains invalid code points.</span>
  <span class="s4">static </span><span class="s1">PropNameID forUtf8(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">std::string&amp; utf8) {</span>
    <span class="s4">return </span><span class="s1">runtime.createPropNameIDFromUtf8(</span>
        <span class="s4">reinterpret_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">uint8_t*&gt;(utf8.data())</span><span class="s4">, </span><span class="s1">utf8.size())</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a PropNameID from a JS string.</span>
  <span class="s4">static </span><span class="s1">PropNameID forString(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">jsi::String&amp; str) {</span>
    <span class="s4">return </span><span class="s1">runtime.createPropNameIDFromString(str)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a PropNameID from a JS symbol.</span>
  <span class="s4">static </span><span class="s1">PropNameID forSymbol(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">jsi::Symbol&amp; sym) {</span>
    <span class="s4">return </span><span class="s1">runtime.createPropNameIDFromSymbol(sym)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// Creates a vector of PropNameIDs constructed from given arguments.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename</span><span class="s1">... Args&gt;</span>
  <span class="s4">static </span><span class="s1">std::vector&lt;PropNameID&gt; names(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">Args&amp;&amp;... args)</span><span class="s4">;</span>

  <span class="s0">// Creates a vector of given PropNameIDs.</span>
  <span class="s4">template </span><span class="s1">&lt;size_t N&gt;</span>
  <span class="s4">static </span><span class="s1">std::vector&lt;PropNameID&gt; names(PropNameID(&amp;&amp;propertyNames)[N])</span><span class="s4">;</span>

  <span class="s0">/// Copies the data in a PropNameID as utf8 into a C++ string.</span>
  <span class="s1">std::string utf8(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.utf8(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">static bool </span><span class="s1">compare(</span>
      <span class="s1">Runtime&amp; runtime</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">jsi::PropNameID&amp; a</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">jsi::PropNameID&amp; b) {</span>
    <span class="s4">return </span><span class="s1">runtime.compare(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">friend class </span><span class="s1">Runtime</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents a JS Symbol (es6).  Movable, not copyable.</span>
<span class="s0">/// TODO T40778724: this is a limited implementation sufficient for</span>
<span class="s0">/// the debugger not to crash when a Symbol is a property in an Object</span>
<span class="s0">/// or element in an array.  Complete support for creating will come</span>
<span class="s0">/// later.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Symbol : </span><span class="s4">public </span><span class="s1">Pointer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">using </span><span class="s1">Pointer::Pointer</span><span class="s4">;</span>

  <span class="s1">Symbol(Symbol&amp;&amp; other) = </span><span class="s4">default;</span>
  <span class="s1">Symbol&amp; </span><span class="s4">operator</span><span class="s1">=(Symbol&amp;&amp; other) = </span><span class="s4">default;</span>

  <span class="s0">/// \return whether a and b refer to the same symbol.</span>
  <span class="s4">static bool </span><span class="s1">strictEquals(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Symbol&amp; a</span><span class="s4">, const </span><span class="s1">Symbol&amp; b) {</span>
    <span class="s4">return </span><span class="s1">runtime.strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Converts a Symbol into a C++ string as JS .toString would.  The output</span>
  <span class="s0">/// will look like \c Symbol(description) .</span>
  <span class="s1">std::string toString(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.symbolToString(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">friend class </span><span class="s1">Runtime</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents a JS BigInt.  Movable, not copyable.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT BigInt : </span><span class="s4">public </span><span class="s1">Pointer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">using </span><span class="s1">Pointer::Pointer</span><span class="s4">;</span>

  <span class="s1">BigInt(BigInt&amp;&amp; other) = </span><span class="s4">default;</span>
  <span class="s1">BigInt&amp; </span><span class="s4">operator</span><span class="s1">=(BigInt&amp;&amp; other) = </span><span class="s4">default;</span>

  <span class="s0">/// Create a BigInt representing the signed 64-bit \p value.</span>
  <span class="s4">static </span><span class="s1">BigInt fromInt64(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">int64_t value) {</span>
    <span class="s4">return </span><span class="s1">runtime.createBigIntFromInt64(value)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a BigInt representing the unsigned 64-bit \p value.</span>
  <span class="s4">static </span><span class="s1">BigInt fromUint64(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">uint64_t value) {</span>
    <span class="s4">return </span><span class="s1">runtime.createBigIntFromUint64(value)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return whether a === b.</span>
  <span class="s4">static bool </span><span class="s1">strictEquals(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">BigInt&amp; a</span><span class="s4">, const </span><span class="s1">BigInt&amp; b) {</span>
    <span class="s4">return </span><span class="s1">runtime.strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \returns This bigint truncated to a signed 64-bit integer.</span>
  <span class="s1">int64_t getInt64(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.truncate(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \returns Whether this bigint can be losslessly converted to int64_t.</span>
  <span class="s4">bool </span><span class="s1">isInt64(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.bigintIsInt64(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \returns This bigint truncated to a signed 64-bit integer. Throws a</span>
  <span class="s0">/// JSIException if the truncation is lossy.</span>
  <span class="s1">int64_t asInt64(Runtime&amp; runtime) </span><span class="s4">const;</span>

  <span class="s0">/// \returns This bigint truncated to an unsigned 64-bit integer.</span>
  <span class="s1">uint64_t getUint64(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.truncate(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \returns Whether this bigint can be losslessly converted to uint64_t.</span>
  <span class="s4">bool </span><span class="s1">isUint64(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.bigintIsUint64(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \returns This bigint truncated to an unsigned 64-bit integer. Throws a</span>
  <span class="s0">/// JSIException if the truncation is lossy.</span>
  <span class="s1">uint64_t asUint64(Runtime&amp; runtime) </span><span class="s4">const;</span>

  <span class="s0">/// \returns this BigInt converted to a String in base \p radix. Throws a</span>
  <span class="s0">/// JSIException if radix is not in the [2, 36] range.</span>
  <span class="s4">inline </span><span class="s1">String toString(Runtime&amp; runtime</span><span class="s4">, int </span><span class="s1">radix = </span><span class="s5">10</span><span class="s1">) </span><span class="s4">const;</span>

  <span class="s4">friend class </span><span class="s1">Runtime</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents a JS String.  Movable, not copyable.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT String : </span><span class="s4">public </span><span class="s1">Pointer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">using </span><span class="s1">Pointer::Pointer</span><span class="s4">;</span>

  <span class="s1">String(String&amp;&amp; other) = </span><span class="s4">default;</span>
  <span class="s1">String&amp; </span><span class="s4">operator</span><span class="s1">=(String&amp;&amp; other) = </span><span class="s4">default;</span>

  <span class="s0">/// Create a JS string from ascii values.  The string data is</span>
  <span class="s0">/// copied.</span>
  <span class="s4">static </span><span class="s1">String</span>
  <span class="s1">createFromAscii(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* str</span><span class="s4">, </span><span class="s1">size_t length) {</span>
    <span class="s4">return </span><span class="s1">runtime.createStringFromAscii(str</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a JS string from a nul-terminated C ascii string.  The</span>
  <span class="s0">/// string data is copied.</span>
  <span class="s4">static </span><span class="s1">String createFromAscii(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* str) {</span>
    <span class="s4">return </span><span class="s1">createFromAscii(runtime</span><span class="s4">, </span><span class="s1">str</span><span class="s4">, </span><span class="s1">strlen(str))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a JS string from a C++ string.  The string data is</span>
  <span class="s0">/// copied.</span>
  <span class="s4">static </span><span class="s1">String createFromAscii(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">std::string&amp; str) {</span>
    <span class="s4">return </span><span class="s1">createFromAscii(runtime</span><span class="s4">, </span><span class="s1">str.c_str()</span><span class="s4">, </span><span class="s1">str.size())</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a JS string from utf8-encoded octets.  The string data is</span>
  <span class="s0">/// transformed and copied.  Results are undefined if \p utf8 contains invalid</span>
  <span class="s0">/// code points.</span>
  <span class="s4">static </span><span class="s1">String</span>
  <span class="s1">createFromUtf8(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">uint8_t* utf8</span><span class="s4">, </span><span class="s1">size_t length) {</span>
    <span class="s4">return </span><span class="s1">runtime.createStringFromUtf8(utf8</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Create a JS string from utf8-encoded octets stored in a</span>
  <span class="s0">/// std::string.  The string data is transformed and copied.  Results are</span>
  <span class="s0">/// undefined if \p utf8 contains invalid code points.</span>
  <span class="s4">static </span><span class="s1">String createFromUtf8(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">std::string&amp; utf8) {</span>
    <span class="s4">return </span><span class="s1">runtime.createStringFromUtf8(</span>
        <span class="s4">reinterpret_cast</span><span class="s1">&lt;</span><span class="s4">const </span><span class="s1">uint8_t*&gt;(utf8.data())</span><span class="s4">, </span><span class="s1">utf8.length())</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return whether a and b contain the same characters.</span>
  <span class="s4">static bool </span><span class="s1">strictEquals(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">String&amp; a</span><span class="s4">, const </span><span class="s1">String&amp; b) {</span>
    <span class="s4">return </span><span class="s1">runtime.strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Copies the data in a JS string as utf8 into a C++ string.</span>
  <span class="s1">std::string utf8(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.utf8(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">friend class </span><span class="s1">Runtime</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">class </span><span class="s1">Array</span><span class="s4">;</span>
<span class="s4">class </span><span class="s1">Function</span><span class="s4">;</span>

<span class="s0">/// Represents a JS Object.  Movable, not copyable.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Object : </span><span class="s4">public </span><span class="s1">Pointer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">using </span><span class="s1">Pointer::Pointer</span><span class="s4">;</span>

  <span class="s1">Object(Object&amp;&amp; other) = </span><span class="s4">default;</span>
  <span class="s1">Object&amp; </span><span class="s4">operator</span><span class="s1">=(Object&amp;&amp; other) = </span><span class="s4">default;</span>

  <span class="s0">/// Creates a new Object instance, like '{}' in JS.</span>
  <span class="s1">Object(Runtime&amp; runtime) : Object(runtime.createObject()) {}</span>

  <span class="s4">static </span><span class="s1">Object createFromHostObject(</span>
      <span class="s1">Runtime&amp; runtime</span><span class="s4">,</span>
      <span class="s1">std::shared_ptr&lt;HostObject&gt; ho) {</span>
    <span class="s4">return </span><span class="s1">runtime.createObject(ho)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return whether this and \c obj are the same JSObject or not.</span>
  <span class="s4">static bool </span><span class="s1">strictEquals(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Object&amp; a</span><span class="s4">, const </span><span class="s1">Object&amp; b) {</span>
    <span class="s4">return </span><span class="s1">runtime.strictEquals(a</span><span class="s4">, </span><span class="s1">b)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the result of `this instanceOf ctor` in JS.</span>
  <span class="s4">bool </span><span class="s1">instanceOf(Runtime&amp; rt</span><span class="s4">, const </span><span class="s1">Function&amp; ctor) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">rt.instanceOf(*</span><span class="s4">this, </span><span class="s1">ctor)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the property of the object with the given ascii name.</span>
  <span class="s0">/// If the name isn't a property on the object, returns the</span>
  <span class="s0">/// undefined value.</span>
  <span class="s1">Value getProperty(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* name) </span><span class="s4">const;</span>

  <span class="s0">/// \return the property of the object with the String name.</span>
  <span class="s0">/// If the name isn't a property on the object, returns the</span>
  <span class="s0">/// undefined value.</span>
  <span class="s1">Value getProperty(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">String&amp; name) </span><span class="s4">const;</span>

  <span class="s0">/// \return the property of the object with the given JS PropNameID</span>
  <span class="s0">/// name.  If the name isn't a property on the object, returns the</span>
  <span class="s0">/// undefined value.</span>
  <span class="s1">Value getProperty(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) </span><span class="s4">const;</span>

  <span class="s0">/// \return true if and only if the object has a property with the</span>
  <span class="s0">/// given ascii name.</span>
  <span class="s4">bool </span><span class="s1">hasProperty(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* name) </span><span class="s4">const;</span>

  <span class="s0">/// \return true if and only if the object has a property with the</span>
  <span class="s0">/// given String name.</span>
  <span class="s4">bool </span><span class="s1">hasProperty(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">String&amp; name) </span><span class="s4">const;</span>

  <span class="s0">/// \return true if and only if the object has a property with the</span>
  <span class="s0">/// given PropNameID name.</span>
  <span class="s4">bool </span><span class="s1">hasProperty(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name) </span><span class="s4">const;</span>

  <span class="s0">/// Sets the property value from a Value or anything which can be</span>
  <span class="s0">/// used to make one: nullptr_t, bool, double, int, const char*,</span>
  <span class="s0">/// String, or Object.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt;</span>
  <span class="s4">void </span><span class="s1">setProperty(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* name</span><span class="s4">, </span><span class="s1">T&amp;&amp; value) </span><span class="s4">const;</span>

  <span class="s0">/// Sets the property value from a Value or anything which can be</span>
  <span class="s0">/// used to make one: nullptr_t, bool, double, int, const char*,</span>
  <span class="s0">/// String, or Object.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt;</span>
  <span class="s4">void </span><span class="s1">setProperty(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">String&amp; name</span><span class="s4">, </span><span class="s1">T&amp;&amp; value) </span><span class="s4">const;</span>

  <span class="s0">/// Sets the property value from a Value or anything which can be</span>
  <span class="s0">/// used to make one: nullptr_t, bool, double, int, const char*,</span>
  <span class="s0">/// String, or Object.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt;</span>
  <span class="s4">void </span><span class="s1">setProperty(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">PropNameID&amp; name</span><span class="s4">, </span><span class="s1">T&amp;&amp; value) </span><span class="s4">const;</span>

  <span class="s0">/// \return true iff JS \c Array.isArray() would return \c true.  If</span>
  <span class="s0">/// so, then \c getArray() will succeed.</span>
  <span class="s4">bool </span><span class="s1">isArray(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.isArray(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return true iff the Object is an ArrayBuffer. If so, then \c</span>
  <span class="s0">/// getArrayBuffer() will succeed.</span>
  <span class="s4">bool </span><span class="s1">isArrayBuffer(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.isArrayBuffer(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return true iff the Object is callable.  If so, then \c</span>
  <span class="s0">/// getFunction will succeed.</span>
  <span class="s4">bool </span><span class="s1">isFunction(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.isFunction(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return true iff the Object was initialized with \c createFromHostObject</span>
  <span class="s0">/// and the HostObject passed is of type \c T. If returns \c true then</span>
  <span class="s0">/// \c getHostObject&lt;T&gt; will succeed.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T = HostObject&gt;</span>
  <span class="s4">bool </span><span class="s1">isHostObject(Runtime&amp; runtime) </span><span class="s4">const;</span>

  <span class="s0">/// \return an Array instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isArray() would return false, this will assert.</span>
  <span class="s1">Array getArray(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return an Array instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isArray() would return false, this will assert.</span>
  <span class="s1">Array getArray(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return an Array instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isArray() would return false, this will throw</span>
  <span class="s0">/// JSIException.</span>
  <span class="s1">Array asArray(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return an Array instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isArray() would return false, this will throw</span>
  <span class="s0">/// JSIException.</span>
  <span class="s1">Array asArray(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return an ArrayBuffer instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isArrayBuffer() would return false, this will assert.</span>
  <span class="s1">ArrayBuffer getArrayBuffer(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return an ArrayBuffer instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isArrayBuffer() would return false, this will assert.</span>
  <span class="s1">ArrayBuffer getArrayBuffer(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return a Function instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isFunction() would return false, this will assert.</span>
  <span class="s1">Function getFunction(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return a Function instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isFunction() would return false, this will assert.</span>
  <span class="s1">Function getFunction(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return a Function instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isFunction() would return false, this will throw</span>
  <span class="s0">/// JSIException.</span>
  <span class="s1">Function asFunction(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return a Function instance which refers to the same underlying</span>
  <span class="s0">/// object.  If \c isFunction() would return false, this will throw</span>
  <span class="s0">/// JSIException.</span>
  <span class="s1">Function asFunction(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return a shared_ptr&lt;T&gt; which refers to the same underlying</span>
  <span class="s0">/// \c HostObject that was used to create this object. If \c isHostObject&lt;T&gt;</span>
  <span class="s0">/// is false, this will assert. Note that this does a type check and will</span>
  <span class="s0">/// assert if the underlying HostObject isn't of type \c T</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T = HostObject&gt;</span>
  <span class="s1">std::shared_ptr&lt;T&gt; getHostObject(Runtime&amp; runtime) </span><span class="s4">const;</span>

  <span class="s0">/// \return a shared_ptr&lt;T&gt; which refers to the same underlying</span>
  <span class="s0">/// \c HostObject that was used to create this object. If \c isHostObject&lt;T&gt;</span>
  <span class="s0">/// is false, this will throw.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T = HostObject&gt;</span>
  <span class="s1">std::shared_ptr&lt;T&gt; asHostObject(Runtime&amp; runtime) </span><span class="s4">const;</span>

  <span class="s0">/// \return whether this object has native state of type T previously set by</span>
  <span class="s0">/// \c setNativeState.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T = NativeState&gt;</span>
  <span class="s4">bool </span><span class="s1">hasNativeState(Runtime&amp; runtime) </span><span class="s4">const;</span>

  <span class="s0">/// \return a shared_ptr to the state previously set by \c setNativeState.</span>
  <span class="s0">/// If \c hasNativeState&lt;T&gt; is false, this will assert. Note that this does a</span>
  <span class="s0">/// type check and will assert if the native state isn't of type \c T</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T = NativeState&gt;</span>
  <span class="s1">std::shared_ptr&lt;T&gt; getNativeState(Runtime&amp; runtime) </span><span class="s4">const;</span>

  <span class="s0">/// Set the internal native state property of this object, overwriting any old</span>
  <span class="s0">/// value. Creates a new shared_ptr to the object managed by \p state, which</span>
  <span class="s0">/// will live until the value at this property becomes unreachable.</span>
  <span class="s0">///</span>
  <span class="s0">/// Throws a type error if this object is a proxy or host object.</span>
  <span class="s4">void </span><span class="s1">setNativeState(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;NativeState&gt; state)</span>
      <span class="s4">const;</span>

  <span class="s0">/// \return same as \c getProperty(name).asObject(), except with</span>
  <span class="s0">/// a better exception message.</span>
  <span class="s1">Object getPropertyAsObject(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* name) </span><span class="s4">const;</span>

  <span class="s0">/// \return similar to \c</span>
  <span class="s0">/// getProperty(name).getObject().getFunction(), except it will</span>
  <span class="s0">/// throw JSIException instead of asserting if the property is</span>
  <span class="s0">/// not an object, or the object is not callable.</span>
  <span class="s1">Function getPropertyAsFunction(Runtime&amp; runtime</span><span class="s4">, const char</span><span class="s1">* name) </span><span class="s4">const;</span>

  <span class="s0">/// \return an Array consisting of all enumerable property names in</span>
  <span class="s0">/// the object and its prototype chain.  All values in the return</span>
  <span class="s0">/// will be isString().  (This is probably not optimal, but it</span>
  <span class="s0">/// works.  I only need it in one place.)</span>
  <span class="s1">Array getPropertyNames(Runtime&amp; runtime) </span><span class="s4">const;</span>

 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s4">void </span><span class="s1">setPropertyValue(</span>
      <span class="s1">Runtime&amp; runtime</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">String&amp; name</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value&amp; value) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.setPropertyValue(*</span><span class="s4">this, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">void </span><span class="s1">setPropertyValue(</span>
      <span class="s1">Runtime&amp; runtime</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">PropNameID&amp; name</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value&amp; value) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.setPropertyValue(*</span><span class="s4">this, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">friend class </span><span class="s1">Runtime</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents a weak reference to a JS Object.  If the only reference</span>
<span class="s0">/// to an Object are these, the object is eligible for GC.  Method</span>
<span class="s0">/// names are inspired by C++ weak_ptr.  Movable, not copyable.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT WeakObject : </span><span class="s4">public </span><span class="s1">Pointer {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">using </span><span class="s1">Pointer::Pointer</span><span class="s4">;</span>

  <span class="s1">WeakObject(WeakObject&amp;&amp; other) = </span><span class="s4">default;</span>
  <span class="s1">WeakObject&amp; </span><span class="s4">operator</span><span class="s1">=(WeakObject&amp;&amp; other) = </span><span class="s4">default;</span>

  <span class="s0">/// Create a WeakObject from an Object.</span>
  <span class="s1">WeakObject(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Object&amp; o)</span>
      <span class="s1">: WeakObject(runtime.createWeakObject(o)) {}</span>

  <span class="s0">/// \return a Value representing the underlying Object if it is still valid;</span>
  <span class="s0">/// otherwise returns \c undefined.  Note that this method has nothing to do</span>
  <span class="s0">/// with threads or concurrency.  The name is based on std::weak_ptr::lock()</span>
  <span class="s0">/// which serves a similar purpose.</span>
  <span class="s1">Value lock(Runtime&amp; runtime) </span><span class="s4">const;</span>

  <span class="s4">friend class </span><span class="s1">Runtime</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents a JS Object which can be efficiently used as an array</span>
<span class="s0">/// with integral indices.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Array : </span><span class="s4">public </span><span class="s1">Object {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">Array(Array&amp;&amp;) = </span><span class="s4">default;</span>
  <span class="s0">/// Creates a new Array instance, with \c length undefined elements.</span>
  <span class="s1">Array(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">size_t length) : Array(runtime.createArray(length)) {}</span>

  <span class="s1">Array&amp; </span><span class="s4">operator</span><span class="s1">=(Array&amp;&amp;) = </span><span class="s4">default;</span>

  <span class="s0">/// \return the size of the Array, according to its length property.</span>
  <span class="s0">/// (C++ naming convention)</span>
  <span class="s1">size_t size(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.size(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the size of the Array, according to its length property.</span>
  <span class="s0">/// (JS naming convention)</span>
  <span class="s1">size_t length(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">size(runtime)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the property of the array at index \c i.  If there is no</span>
  <span class="s0">/// such property, returns the undefined value.  If \c i is out of</span>
  <span class="s0">/// range [ 0..\c length ] throws a JSIException.</span>
  <span class="s1">Value getValueAtIndex(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">size_t i) </span><span class="s4">const;</span>

  <span class="s0">/// Sets the property of the array at index \c i.  The argument</span>
  <span class="s0">/// value behaves as with Object::setProperty().  If \c i is out of</span>
  <span class="s0">/// range [ 0..\c length ] throws a JSIException.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt;</span>
  <span class="s4">void </span><span class="s1">setValueAtIndex(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">size_t i</span><span class="s4">, </span><span class="s1">T&amp;&amp; value) </span><span class="s4">const;</span>

  <span class="s0">/// There is no current API for changing the size of an array once</span>
  <span class="s0">/// created.  We'll probably need that eventually.</span>

  <span class="s0">/// Creates a new Array instance from provided values</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename</span><span class="s1">... Args&gt;</span>
  <span class="s4">static </span><span class="s1">Array createWithElements(Runtime&amp;</span><span class="s4">, </span><span class="s1">Args&amp;&amp;... args)</span><span class="s4">;</span>

  <span class="s0">/// Creates a new Array instance from initializer list.</span>
  <span class="s4">static </span><span class="s1">Array createWithElements(</span>
      <span class="s1">Runtime&amp; runtime</span><span class="s4">,</span>
      <span class="s1">std::initializer_list&lt;Value&gt; elements)</span><span class="s4">;</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">friend class </span><span class="s1">Object</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>

  <span class="s4">void </span><span class="s1">setValueAtIndexImpl(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">size_t i</span><span class="s4">, const </span><span class="s1">Value&amp; value)</span>
      <span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.setValueAtIndexImpl(*</span><span class="s4">this, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">value)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Array(Runtime::PointerValue* value) : Object(value) {}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents a JSArrayBuffer</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT ArrayBuffer : </span><span class="s4">public </span><span class="s1">Object {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">ArrayBuffer(ArrayBuffer&amp;&amp;) = </span><span class="s4">default;</span>
  <span class="s1">ArrayBuffer&amp; </span><span class="s4">operator</span><span class="s1">=(ArrayBuffer&amp;&amp;) = </span><span class="s4">default;</span>

  <span class="s1">ArrayBuffer(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">std::shared_ptr&lt;MutableBuffer&gt; buffer)</span>
      <span class="s1">: ArrayBuffer(runtime.createArrayBuffer(std::move(buffer))) {}</span>

  <span class="s0">/// \return the size of the ArrayBuffer, according to its byteLength property.</span>
  <span class="s0">/// (C++ naming convention)</span>
  <span class="s1">size_t size(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.size(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">size_t length(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.size(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">uint8_t* data(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.data(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">friend class </span><span class="s1">Object</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>

  <span class="s1">ArrayBuffer(Runtime::PointerValue* value) : Object(value) {}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents a JS Object which is guaranteed to be Callable.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Function : </span><span class="s4">public </span><span class="s1">Object {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">Function(Function&amp;&amp;) = </span><span class="s4">default;</span>
  <span class="s1">Function&amp; </span><span class="s4">operator</span><span class="s1">=(Function&amp;&amp;) = </span><span class="s4">default;</span>

  <span class="s0">/// Create a function which, when invoked, calls C++ code. If the</span>
  <span class="s0">/// function throws an exception, a JS Error will be created and</span>
  <span class="s0">/// thrown.</span>
  <span class="s0">/// \param name the name property for the function.</span>
  <span class="s0">/// \param paramCount the length property for the function, which</span>
  <span class="s0">/// may not be the number of arguments the function is passed.</span>
  <span class="s4">static </span><span class="s1">Function createFromHostFunction(</span>
      <span class="s1">Runtime&amp; runtime</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">jsi::PropNameID&amp; name</span><span class="s4">,</span>
      <span class="s4">unsigned int </span><span class="s1">paramCount</span><span class="s4">,</span>
      <span class="s1">jsi::HostFunctionType func)</span><span class="s4">;</span>

  <span class="s0">/// Calls the function with \c count \c args.  The \c this value of the JS</span>
  <span class="s0">/// function will not be set by the C++ caller, similar to calling</span>
  <span class="s0">/// Function.prototype.apply(undefined, args) in JS.</span>
  <span class="s0">/// \b Note: as with Function.prototype.apply, \c this may not always be</span>
  <span class="s0">/// \c undefined in the function itself.  If the function is non-strict,</span>
  <span class="s0">/// \c this will be set to the global object.</span>
  <span class="s1">Value call(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count) </span><span class="s4">const;</span>

  <span class="s0">/// Calls the function with a \c std::initializer_list of Value</span>
  <span class="s0">/// arguments.  The \c this value of the JS function will not be set by the</span>
  <span class="s0">/// C++ caller, similar to calling Function.prototype.apply(undefined, args)</span>
  <span class="s0">/// in JS.</span>
  <span class="s0">/// \b Note: as with Function.prototype.apply, \c this may not always be</span>
  <span class="s0">/// \c undefined in the function itself.  If the function is non-strict,</span>
  <span class="s0">/// \c this will be set to the global object.</span>
  <span class="s1">Value call(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">std::initializer_list&lt;Value&gt; args) </span><span class="s4">const;</span>

  <span class="s0">/// Calls the function with any number of arguments similarly to</span>
  <span class="s0">/// Object::setProperty().  The \c this value of the JS function will not be</span>
  <span class="s0">/// set by the C++ caller, similar to calling</span>
  <span class="s0">/// Function.prototype.call(undefined, ...args) in JS.</span>
  <span class="s0">/// \b Note: as with Function.prototype.call, \c this may not always be</span>
  <span class="s0">/// \c undefined in the function itself.  If the function is non-strict,</span>
  <span class="s0">/// \c this will be set to the global object.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename</span><span class="s1">... Args&gt;</span>
  <span class="s1">Value call(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">Args&amp;&amp;... args) </span><span class="s4">const;</span>

  <span class="s0">/// Calls the function with \c count \c args and \c jsThis value passed</span>
  <span class="s0">/// as the \c this value.</span>
  <span class="s1">Value callWithThis(</span>
      <span class="s1">Runtime&amp; Runtime</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Object&amp; jsThis</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Value* args</span><span class="s4">,</span>
      <span class="s1">size_t count) </span><span class="s4">const;</span>

  <span class="s0">/// Calls the function with a \c std::initializer_list of Value</span>
  <span class="s0">/// arguments and \c jsThis passed as the \c this value.</span>
  <span class="s1">Value callWithThis(</span>
      <span class="s1">Runtime&amp; runtime</span><span class="s4">,</span>
      <span class="s4">const </span><span class="s1">Object&amp; jsThis</span><span class="s4">,</span>
      <span class="s1">std::initializer_list&lt;Value&gt; args) </span><span class="s4">const;</span>

  <span class="s0">/// Calls the function with any number of arguments similarly to</span>
  <span class="s0">/// Object::setProperty(), and with \c jsThis passed as the \c this value.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename</span><span class="s1">... Args&gt;</span>
  <span class="s1">Value callWithThis(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Object&amp; jsThis</span><span class="s4">, </span><span class="s1">Args&amp;&amp;... args)</span>
      <span class="s4">const;</span>

  <span class="s0">/// Calls the function as a constructor with \c count \c args. Equivalent</span>
  <span class="s0">/// to calling `new Func` where `Func` is the js function reqresented by</span>
  <span class="s0">/// this.</span>
  <span class="s1">Value callAsConstructor(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Value* args</span><span class="s4">, </span><span class="s1">size_t count)</span>
      <span class="s4">const;</span>

  <span class="s0">/// Same as above `callAsConstructor`, except use an initializer_list to</span>
  <span class="s0">/// supply the arguments.</span>
  <span class="s1">Value callAsConstructor(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">std::initializer_list&lt;Value&gt; args)</span>
      <span class="s4">const;</span>

  <span class="s0">/// Same as above `callAsConstructor`, but automatically converts/wraps</span>
  <span class="s0">/// any argument with a jsi Value.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename</span><span class="s1">... Args&gt;</span>
  <span class="s1">Value callAsConstructor(Runtime&amp; runtime</span><span class="s4">, </span><span class="s1">Args&amp;&amp;... args) </span><span class="s4">const;</span>

  <span class="s0">/// Returns whether this was created with Function::createFromHostFunction.</span>
  <span class="s0">/// If true then you can use getHostFunction to get the underlying</span>
  <span class="s0">/// HostFunctionType.</span>
  <span class="s4">bool </span><span class="s1">isHostFunction(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">runtime.isHostFunction(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Returns the underlying HostFunctionType iff isHostFunction returns true</span>
  <span class="s0">/// and asserts otherwise. You can use this to use std::function&lt;&gt;::target</span>
  <span class="s0">/// to get the object that was passed to create the HostFunctionType.</span>
  <span class="s0">///</span>
  <span class="s0">/// Note: The reference returned is borrowed from the JS object underlying</span>
  <span class="s0">///       \c this, and thus only lasts as long as the object underlying</span>
  <span class="s0">///       \c this does.</span>
  <span class="s1">HostFunctionType&amp; getHostFunction(Runtime&amp; runtime) </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s1">assert(isHostFunction(runtime))</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">runtime.getHostFunction(*</span><span class="s4">this</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">friend class </span><span class="s1">Object</span><span class="s4">;</span>
  <span class="s4">friend class </span><span class="s1">Value</span><span class="s4">;</span>

  <span class="s1">Function(Runtime::PointerValue* value) : Object(value) {}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Represents any JS Value (undefined, null, boolean, number, symbol,</span>
<span class="s0">/// string, or object).  Movable, or explicitly copyable (has no copy</span>
<span class="s0">/// ctor).</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Value {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s0">/// Default ctor creates an \c undefined JS value.</span>
  <span class="s1">Value() : Value(UndefinedKind) {}</span>

  <span class="s0">/// Creates a \c null JS value.</span>
  <span class="s0">/* implicit */ </span><span class="s1">Value(std::nullptr_t) : kind_(NullKind) {}</span>

  <span class="s0">/// Creates a boolean JS value.</span>
  <span class="s0">/* implicit */ </span><span class="s1">Value(</span><span class="s4">bool </span><span class="s1">b) : Value(BooleanKind) {</span>
    <span class="s1">data_.boolean = b</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Creates a number JS value.</span>
  <span class="s0">/* implicit */ </span><span class="s1">Value(</span><span class="s4">double </span><span class="s1">d) : Value(NumberKind) {</span>
    <span class="s1">data_.number = d</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Creates a number JS value.</span>
  <span class="s0">/* implicit */ </span><span class="s1">Value(</span><span class="s4">int </span><span class="s1">i) : Value(NumberKind) {</span>
    <span class="s1">data_.number = i</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Moves a Symbol, String, or Object rvalue into a new JS value.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt;</span>
  <span class="s0">/* implicit */ </span><span class="s1">Value(T&amp;&amp; other) : Value(kindOf(other)) {</span>
    <span class="s4">static_assert</span><span class="s1">(</span>
        <span class="s1">std::is_base_of&lt;Symbol</span><span class="s4">, </span><span class="s1">T&gt;::value ||</span>
            <span class="s1">std::is_base_of&lt;BigInt</span><span class="s4">, </span><span class="s1">T&gt;::value ||</span>
            <span class="s1">std::is_base_of&lt;String</span><span class="s4">, </span><span class="s1">T&gt;::value ||</span>
            <span class="s1">std::is_base_of&lt;Object</span><span class="s4">, </span><span class="s1">T&gt;::value</span><span class="s4">,</span>
        <span class="s3">&quot;Value cannot be implicitly move-constructed from this type&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) T(std::move(other))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Value(&quot;foo&quot;) will treat foo as a bool.  This makes doing that a</span>
  <span class="s0">/// compile error.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T = </span><span class="s4">void</span><span class="s1">&gt;</span>
  <span class="s1">Value(</span><span class="s4">const char</span><span class="s1">*) {</span>
    <span class="s4">static_assert</span><span class="s1">(</span>
        <span class="s1">!std::is_same&lt;</span><span class="s4">void, </span><span class="s1">T&gt;::value</span><span class="s4">,</span>
        <span class="s3">&quot;Value cannot be constructed directly from const char*&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">Value(Value&amp;&amp; value)</span><span class="s4">;</span>

  <span class="s0">/// Copies a Symbol lvalue into a new JS value.</span>
  <span class="s1">Value(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Symbol&amp; sym) : Value(SymbolKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) Symbol(runtime.cloneSymbol(sym.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Copies a BigInt lvalue into a new JS value.</span>
  <span class="s1">Value(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">BigInt&amp; bigint) : Value(BigIntKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) BigInt(runtime.cloneBigInt(bigint.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Copies a String lvalue into a new JS value.</span>
  <span class="s1">Value(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">String&amp; str) : Value(StringKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) String(runtime.cloneString(str.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Copies a Object lvalue into a new JS value.</span>
  <span class="s1">Value(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Object&amp; obj) : Value(ObjectKind) {</span>
    <span class="s4">new </span><span class="s1">(&amp;data_.pointer) Object(runtime.cloneObject(obj.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// Creates a JS value from another Value lvalue.</span>
  <span class="s1">Value(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Value&amp; value)</span><span class="s4">;</span>

  <span class="s0">/// Value(rt, &quot;foo&quot;) will treat foo as a bool.  This makes doing</span>
  <span class="s0">/// that a compile error.</span>
  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T = </span><span class="s4">void</span><span class="s1">&gt;</span>
  <span class="s1">Value(Runtime&amp;</span><span class="s4">, const char</span><span class="s1">*) {</span>
    <span class="s4">static_assert</span><span class="s1">(</span>
        <span class="s1">!std::is_same&lt;T</span><span class="s4">, void</span><span class="s1">&gt;::value</span><span class="s4">,</span>
        <span class="s3">&quot;Value cannot be constructed directly from const char*&quot;</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">~Value()</span><span class="s4">;</span>
  <span class="s0">// \return the undefined \c Value.</span>
  <span class="s4">static </span><span class="s1">Value undefined() {</span>
    <span class="s4">return </span><span class="s1">Value()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// \return the null \c Value.</span>
  <span class="s4">static </span><span class="s1">Value null() {</span>
    <span class="s4">return </span><span class="s1">Value(</span><span class="s4">nullptr</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">// \return a \c Value created from a utf8-encoded JSON string.</span>
  <span class="s4">static </span><span class="s1">Value</span>
  <span class="s1">createFromJsonUtf8(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">uint8_t* json</span><span class="s4">, </span><span class="s1">size_t length) {</span>
    <span class="s4">return </span><span class="s1">runtime.createValueFromJsonUtf8(json</span><span class="s4">, </span><span class="s1">length)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return according to the Strict Equality Comparison algorithm, see:</span>
  <span class="s0">/// https://262.ecma-international.org/11.0/#sec-strict-equality-comparison</span>
  <span class="s4">static bool </span><span class="s1">strictEquals(Runtime&amp; runtime</span><span class="s4">, const </span><span class="s1">Value&amp; a</span><span class="s4">, const </span><span class="s1">Value&amp; b)</span><span class="s4">;</span>

  <span class="s1">Value&amp; </span><span class="s4">operator</span><span class="s1">=(Value&amp;&amp; other) {</span>
    <span class="s4">this</span><span class="s1">-&gt;~Value()</span><span class="s4">;</span>
    <span class="s4">new </span><span class="s1">(</span><span class="s4">this</span><span class="s1">) Value(std::move(other))</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">*</span><span class="s4">this;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">isUndefined() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">kind_ == UndefinedKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">isNull() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">kind_ == NullKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">isBool() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">kind_ == BooleanKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">isNumber() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">kind_ == NumberKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">isString() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">kind_ == StringKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">isBigInt() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">kind_ == BigIntKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">isSymbol() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">kind_ == SymbolKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">bool </span><span class="s1">isObject() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">kind_ == ObjectKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the boolean value, or asserts if not a boolean.</span>
  <span class="s4">bool </span><span class="s1">getBool() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s1">assert(isBool())</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">data_.boolean</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the boolean value, or throws JSIException if not a</span>
  <span class="s0">/// boolean.</span>
  <span class="s4">bool </span><span class="s1">asBool() </span><span class="s4">const;</span>

  <span class="s0">/// \return the number value, or asserts if not a number.</span>
  <span class="s4">double </span><span class="s1">getNumber() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s1">assert(isNumber())</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">data_.number</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the number value, or throws JSIException if not a</span>
  <span class="s0">/// number.</span>
  <span class="s4">double </span><span class="s1">asNumber() </span><span class="s4">const;</span>

  <span class="s0">/// \return the Symbol value, or asserts if not a symbol.</span>
  <span class="s1">Symbol getSymbol(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp; {</span>
    <span class="s1">assert(isSymbol())</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">Symbol(runtime.cloneSymbol(data_.pointer.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the Symbol value, or asserts if not a symbol.</span>
  <span class="s0">/// Can be used on rvalue references to avoid cloning more symbols.</span>
  <span class="s1">Symbol getSymbol(Runtime&amp;) &amp;&amp; {</span>
    <span class="s1">assert(isSymbol())</span><span class="s4">;</span>
    <span class="s4">auto </span><span class="s1">ptr = data_.pointer.ptr_</span><span class="s4">;</span>
    <span class="s1">data_.pointer.ptr_ = </span><span class="s4">nullptr;</span>
    <span class="s4">return static_cast</span><span class="s1">&lt;Symbol&gt;(ptr)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the Symbol value, or throws JSIException if not a</span>
  <span class="s0">/// symbol</span>
  <span class="s1">Symbol asSymbol(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>
  <span class="s1">Symbol asSymbol(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return the BigInt value, or asserts if not a bigint.</span>
  <span class="s1">BigInt getBigInt(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp; {</span>
    <span class="s1">assert(isBigInt())</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">BigInt(runtime.cloneBigInt(data_.pointer.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the BigInt value, or asserts if not a bigint.</span>
  <span class="s0">/// Can be used on rvalue references to avoid cloning more bigints.</span>
  <span class="s1">BigInt getBigInt(Runtime&amp;) &amp;&amp; {</span>
    <span class="s1">assert(isBigInt())</span><span class="s4">;</span>
    <span class="s4">auto </span><span class="s1">ptr = data_.pointer.ptr_</span><span class="s4">;</span>
    <span class="s1">data_.pointer.ptr_ = </span><span class="s4">nullptr;</span>
    <span class="s4">return static_cast</span><span class="s1">&lt;BigInt&gt;(ptr)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the BigInt value, or throws JSIException if not a</span>
  <span class="s0">/// bigint</span>
  <span class="s1">BigInt asBigInt(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>
  <span class="s1">BigInt asBigInt(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return the String value, or asserts if not a string.</span>
  <span class="s1">String getString(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp; {</span>
    <span class="s1">assert(isString())</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">String(runtime.cloneString(data_.pointer.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the String value, or asserts if not a string.</span>
  <span class="s0">/// Can be used on rvalue references to avoid cloning more strings.</span>
  <span class="s1">String getString(Runtime&amp;) &amp;&amp; {</span>
    <span class="s1">assert(isString())</span><span class="s4">;</span>
    <span class="s4">auto </span><span class="s1">ptr = data_.pointer.ptr_</span><span class="s4">;</span>
    <span class="s1">data_.pointer.ptr_ = </span><span class="s4">nullptr;</span>
    <span class="s4">return static_cast</span><span class="s1">&lt;String&gt;(ptr)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the String value, or throws JSIException if not a</span>
  <span class="s0">/// string.</span>
  <span class="s1">String asString(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>
  <span class="s1">String asString(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">/// \return the Object value, or asserts if not an object.</span>
  <span class="s1">Object getObject(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp; {</span>
    <span class="s1">assert(isObject())</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">Object(runtime.cloneObject(data_.pointer.ptr_))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the Object value, or asserts if not an object.</span>
  <span class="s0">/// Can be used on rvalue references to avoid cloning more objects.</span>
  <span class="s1">Object getObject(Runtime&amp;) &amp;&amp; {</span>
    <span class="s1">assert(isObject())</span><span class="s4">;</span>
    <span class="s4">auto </span><span class="s1">ptr = data_.pointer.ptr_</span><span class="s4">;</span>
    <span class="s1">data_.pointer.ptr_ = </span><span class="s4">nullptr;</span>
    <span class="s4">return static_cast</span><span class="s1">&lt;Object&gt;(ptr)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s0">/// \return the Object value, or throws JSIException if not an</span>
  <span class="s0">/// object.</span>
  <span class="s1">Object asObject(Runtime&amp; runtime) </span><span class="s4">const</span><span class="s1">&amp;</span><span class="s4">;</span>
  <span class="s1">Object asObject(Runtime&amp; runtime) &amp;&amp;</span><span class="s4">;</span>

  <span class="s0">// \return a String like JS .toString() would do.</span>
  <span class="s1">String toString(Runtime&amp; runtime) </span><span class="s4">const;</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s4">friend class </span><span class="s1">Runtime</span><span class="s4">;</span>

  <span class="s4">enum </span><span class="s1">ValueKind {</span>
    <span class="s1">UndefinedKind</span><span class="s4">,</span>
    <span class="s1">NullKind</span><span class="s4">,</span>
    <span class="s1">BooleanKind</span><span class="s4">,</span>
    <span class="s1">NumberKind</span><span class="s4">,</span>
    <span class="s1">SymbolKind</span><span class="s4">,</span>
    <span class="s1">BigIntKind</span><span class="s4">,</span>
    <span class="s1">StringKind</span><span class="s4">,</span>
    <span class="s1">ObjectKind</span><span class="s4">,</span>
    <span class="s1">PointerKind = SymbolKind</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">union </span><span class="s1">Data {</span>
    <span class="s0">// Value's ctor and dtor will manage the lifecycle of the contained Data.</span>
    <span class="s1">Data() {</span>
      <span class="s4">static_assert</span><span class="s1">(</span>
          <span class="s4">sizeof</span><span class="s1">(Data) == </span><span class="s4">sizeof</span><span class="s1">(uint64_t)</span><span class="s4">,</span>
          <span class="s3">&quot;Value data should fit in a 64-bit register&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">~Data() {}</span>

    <span class="s0">// scalars</span>
    <span class="s4">bool </span><span class="s1">boolean</span><span class="s4">;</span>
    <span class="s4">double </span><span class="s1">number</span><span class="s4">;</span>
    <span class="s0">// pointers</span>
    <span class="s1">Pointer pointer</span><span class="s4">; </span><span class="s0">// Symbol, String, Object, Array, Function</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Value(ValueKind kind) : kind_(kind) {}</span>

  <span class="s4">constexpr static </span><span class="s1">ValueKind kindOf(</span><span class="s4">const </span><span class="s1">Symbol&amp;) {</span>
    <span class="s4">return </span><span class="s1">SymbolKind</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">constexpr static </span><span class="s1">ValueKind kindOf(</span><span class="s4">const </span><span class="s1">BigInt&amp;) {</span>
    <span class="s4">return </span><span class="s1">BigIntKind</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">constexpr static </span><span class="s1">ValueKind kindOf(</span><span class="s4">const </span><span class="s1">String&amp;) {</span>
    <span class="s4">return </span><span class="s1">StringKind</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">constexpr static </span><span class="s1">ValueKind kindOf(</span><span class="s4">const </span><span class="s1">Object&amp;) {</span>
    <span class="s4">return </span><span class="s1">ObjectKind</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">ValueKind kind_</span><span class="s4">;</span>
  <span class="s1">Data data_</span><span class="s4">;</span>

  <span class="s0">// In the future: Value becomes NaN-boxed. See T40538354.</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Not movable and not copyable RAII marker advising the underlying</span>
<span class="s0">/// JavaScript VM to track resources allocated since creation until</span>
<span class="s0">/// destruction so that they can be recycled eagerly when the Scope</span>
<span class="s0">/// goes out of scope instead of floating in the air until the next</span>
<span class="s0">/// garbage collection or any other delayed release occurs.</span>
<span class="s0">///</span>
<span class="s0">/// This API should be treated only as advice, implementations can</span>
<span class="s0">/// choose to ignore the fact that Scopes are created or destroyed.</span>
<span class="s0">///</span>
<span class="s0">/// This class is an exception to the rule allowing destructors to be</span>
<span class="s0">/// called without proper synchronization (see Runtime documentation).</span>
<span class="s0">/// The whole point of this class is to enable all sorts of clean ups</span>
<span class="s0">/// when the destructor is called and this proper synchronization is</span>
<span class="s0">/// required at that time.</span>
<span class="s0">///</span>
<span class="s0">/// Instances of this class are intended to be created as automatic stack</span>
<span class="s0">/// variables in which case destructor calls don't require any additional</span>
<span class="s0">/// locking, provided that the lock (if any) is managed with RAII helpers.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT Scope {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s4">explicit </span><span class="s1">Scope(Runtime&amp; rt) : rt_(rt)</span><span class="s4">, </span><span class="s1">prv_(rt.pushScope()) {}</span>
  <span class="s1">~Scope() {</span>
    <span class="s1">rt_.popScope(prv_)</span><span class="s4">;</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">Scope(</span><span class="s4">const </span><span class="s1">Scope&amp;) = </span><span class="s4">delete;</span>
  <span class="s1">Scope(Scope&amp;&amp;) = </span><span class="s4">delete;</span>

  <span class="s1">Scope&amp; </span><span class="s4">operator</span><span class="s1">=(</span><span class="s4">const </span><span class="s1">Scope&amp;) = </span><span class="s4">delete;</span>
  <span class="s1">Scope&amp; </span><span class="s4">operator</span><span class="s1">=(Scope&amp;&amp;) = </span><span class="s4">delete;</span>

  <span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">F&gt;</span>
  <span class="s4">static auto </span><span class="s1">callInNewScope(Runtime&amp; rt</span><span class="s4">, </span><span class="s1">F f) -&gt; </span><span class="s4">decltype</span><span class="s1">(f()) {</span>
    <span class="s1">Scope s(rt)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">f()</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s1">Runtime&amp; rt_</span><span class="s4">;</span>
  <span class="s1">Runtime::ScopeState* prv_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// Base class for jsi exceptions</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT JSIException : </span><span class="s4">public </span><span class="s1">std::exception {</span>
 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s1">JSIException(){}</span><span class="s4">;</span>
  <span class="s1">JSIException(std::string what) : what_(std::move(what)){}</span><span class="s4">;</span>

 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">JSIException(</span><span class="s4">const </span><span class="s1">JSIException&amp;) = </span><span class="s4">default;</span>

  <span class="s4">virtual const char</span><span class="s1">* what() </span><span class="s4">const noexcept </span><span class="s1">override {</span>
    <span class="s4">return </span><span class="s1">what_.c_str()</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">virtual </span><span class="s1">~JSIException() override</span><span class="s4">;</span>

 <span class="s4">protected</span><span class="s1">:</span>
  <span class="s1">std::string what_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// This exception will be thrown by API functions on errors not related to</span>
<span class="s0">/// JavaScript execution.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT JSINativeException : </span><span class="s4">public </span><span class="s1">JSIException {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s1">JSINativeException(std::string what) : JSIException(std::move(what)) {}</span>

  <span class="s1">JSINativeException(</span><span class="s4">const </span><span class="s1">JSINativeException&amp;) = </span><span class="s4">default;</span>

  <span class="s4">virtual </span><span class="s1">~JSINativeException()</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">/// This exception will be thrown by API functions whenever a JS</span>
<span class="s0">/// operation causes an exception as described by the spec, or as</span>
<span class="s0">/// otherwise described.</span>
<span class="s4">class </span><span class="s1">JSI_EXPORT JSError : </span><span class="s4">public </span><span class="s1">JSIException {</span>
 <span class="s4">public</span><span class="s1">:</span>
  <span class="s0">/// Creates a JSError referring to provided \c value</span>
  <span class="s1">JSError(Runtime&amp; r</span><span class="s4">, </span><span class="s1">Value&amp;&amp; value)</span><span class="s4">;</span>

  <span class="s0">/// Creates a JSError referring to new \c Error instance capturing current</span>
  <span class="s0">/// JavaScript stack. The error message property is set to given \c message.</span>
  <span class="s1">JSError(Runtime&amp; rt</span><span class="s4">, </span><span class="s1">std::string message)</span><span class="s4">;</span>

  <span class="s0">/// Creates a JSError referring to new \c Error instance capturing current</span>
  <span class="s0">/// JavaScript stack. The error message property is set to given \c message.</span>
  <span class="s1">JSError(Runtime&amp; rt</span><span class="s4">, const char</span><span class="s1">* message)</span>
      <span class="s1">: JSError(rt</span><span class="s4">, </span><span class="s1">std::string(message)){}</span><span class="s4">;</span>

  <span class="s0">/// Creates a JSError referring to a JavaScript Object having message and</span>
  <span class="s0">/// stack properties set to provided values.</span>
  <span class="s1">JSError(Runtime&amp; rt</span><span class="s4">, </span><span class="s1">std::string message</span><span class="s4">, </span><span class="s1">std::string stack)</span><span class="s4">;</span>

  <span class="s0">/// Creates a JSError referring to provided value and what string</span>
  <span class="s0">/// set to provided message.  This argument order is a bit weird,</span>
  <span class="s0">/// but necessary to avoid ambiguity with the above.</span>
  <span class="s1">JSError(std::string what</span><span class="s4">, </span><span class="s1">Runtime&amp; rt</span><span class="s4">, </span><span class="s1">Value&amp;&amp; value)</span><span class="s4">;</span>

  <span class="s1">JSError(</span><span class="s4">const </span><span class="s1">JSError&amp;) = </span><span class="s4">default;</span>

  <span class="s4">virtual </span><span class="s1">~JSError()</span><span class="s4">;</span>

  <span class="s4">const </span><span class="s1">std::string&amp; getStack() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">stack_</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">const </span><span class="s1">std::string&amp; getMessage() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">message_</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">const </span><span class="s1">jsi::Value&amp; value() </span><span class="s4">const </span><span class="s1">{</span>
    <span class="s1">assert(value_)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">*value_</span><span class="s4">;</span>
  <span class="s1">}</span>

 <span class="s4">private</span><span class="s1">:</span>
  <span class="s0">// This initializes the value_ member and does some other</span>
  <span class="s0">// validation, so it must be called by every branch through the</span>
  <span class="s0">// constructors.</span>
  <span class="s4">void </span><span class="s1">setValue(Runtime&amp; rt</span><span class="s4">, </span><span class="s1">Value&amp;&amp; value)</span><span class="s4">;</span>

  <span class="s0">// This needs to be on the heap, because throw requires the object</span>
  <span class="s0">// be copyable, and Value is not.</span>
  <span class="s1">std::shared_ptr&lt;jsi::Value&gt; value_</span><span class="s4">;</span>
  <span class="s1">std::string message_</span><span class="s4">;</span>
  <span class="s1">std::string stack_</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s1">} </span><span class="s0">// namespace jsi</span>
<span class="s1">} </span><span class="s0">// namespace facebook</span>

<span class="s2">#include </span><span class="s3">&lt;jsi/jsi-inl.h&gt;</span>
</pre>
</body>
</html>
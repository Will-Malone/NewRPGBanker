<html>
<head>
<title>ReactImageView.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ReactImageView.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.views.image</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Bitmap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.BitmapShader</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Canvas</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Color</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Matrix</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Paint</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Rect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Shader</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.Animatable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.drawable.Drawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.net.Uri</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.internal.Objects</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.references.CloseableReference</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.util.UriUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.controller.AbstractDraweeControllerBuilder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.controller.ControllerListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.controller.ForwardingControllerListener</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.drawable.AutoRotateDrawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.drawable.RoundedColorDrawable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.drawable.ScalingUtils</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.generic.GenericDraweeHierarchy</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.generic.GenericDraweeHierarchyBuilder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.generic.RoundingParams</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.drawee.view.GenericDraweeView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.imagepipeline.common.ResizeOptions</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.imagepipeline.image.ImageInfo</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.imagepipeline.postprocessors.IterativeBoxBlurPostProcessor</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.imagepipeline.request.BasePostprocessor</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.imagepipeline.request.ImageRequest</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.imagepipeline.request.ImageRequestBuilder</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.imagepipeline.request.Postprocessor</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReactContext</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableArray</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.ReadableMap</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.build.ReactBuildConfig</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.modules.fresco.ReactNetworkImageRequest</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.FloatUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.PixelUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.UIManagerHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.events.EventDispatcher</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.util.RNLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.imagehelper.ImageSource</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.imagehelper.MultiSourceHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.imagehelper.MultiSourceHelper.MultiSourceResult</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.views.imagehelper.ResourceDrawableIdHelper</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.yoga.YogaConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Arrays</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.LinkedList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.List</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Wrapper class around Fresco's GenericDraweeView, enabling persisting props across multiple view</span>
 <span class="s3">* update and consistent processing of both static and network images.</span>
 <span class="s3">*/</span>
<span class="s2">public class </span><span class="s1">ReactImageView </span><span class="s2">extends </span><span class="s1">GenericDraweeView {</span>

  <span class="s2">public static final int </span><span class="s1">REMOTE_IMAGE_FADE_DURATION_MS = </span><span class="s4">300</span><span class="s2">;</span>

  <span class="s2">private static float</span><span class="s1">[] sComputedCornerRadii = </span><span class="s2">new float</span><span class="s1">[</span><span class="s4">4</span><span class="s1">]</span><span class="s2">;</span>

  <span class="s2">private </span><span class="s1">ImageResizeMethod mResizeMethod = ImageResizeMethod.AUTO</span><span class="s2">;</span>

  <span class="s2">public void </span><span class="s1">updateCallerContext(@Nullable Object callerContext) {</span>
    <span class="s2">if </span><span class="s1">(!Objects.equal(mCallerContext</span><span class="s2">, </span><span class="s1">callerContext)) {</span>
      <span class="s1">mCallerContext = callerContext</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Fresco lacks support for repeating images, see https://github.com/facebook/fresco/issues/1575</span>
  <span class="s0">// We implement it here as a postprocessing step.</span>
  <span class="s2">private static final </span><span class="s1">Matrix sTileMatrix = </span><span class="s2">new </span><span class="s1">Matrix()</span><span class="s2">;</span>

  <span class="s2">private class </span><span class="s1">TilePostprocessor </span><span class="s2">extends </span><span class="s1">BasePostprocessor {</span>
    <span class="s1">@Override</span>
    <span class="s2">public </span><span class="s1">CloseableReference&lt;Bitmap&gt; process(Bitmap source</span><span class="s2">, </span><span class="s1">PlatformBitmapFactory bitmapFactory) {</span>
      <span class="s2">final </span><span class="s1">Rect destRect = </span><span class="s2">new </span><span class="s1">Rect(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">getWidth()</span><span class="s2">, </span><span class="s1">getHeight())</span><span class="s2">;</span>
      <span class="s1">mScaleType.getTransform(</span>
          <span class="s1">sTileMatrix</span><span class="s2">, </span><span class="s1">destRect</span><span class="s2">, </span><span class="s1">source.getWidth()</span><span class="s2">, </span><span class="s1">source.getHeight()</span><span class="s2">, </span><span class="s4">0.0f</span><span class="s2">, </span><span class="s4">0.0f</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s1">Paint paint = </span><span class="s2">new </span><span class="s1">Paint()</span><span class="s2">;</span>
      <span class="s1">paint.setAntiAlias(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">Shader shader = </span><span class="s2">new </span><span class="s1">BitmapShader(source</span><span class="s2">, </span><span class="s1">mTileMode</span><span class="s2">, </span><span class="s1">mTileMode)</span><span class="s2">;</span>
      <span class="s1">shader.setLocalMatrix(sTileMatrix)</span><span class="s2">;</span>
      <span class="s1">paint.setShader(shader)</span><span class="s2">;</span>

      <span class="s1">CloseableReference&lt;Bitmap&gt; output = bitmapFactory.createBitmap(getWidth()</span><span class="s2">, </span><span class="s1">getHeight())</span><span class="s2">;</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">Canvas canvas = </span><span class="s2">new </span><span class="s1">Canvas(output.get())</span><span class="s2">;</span>
        <span class="s1">canvas.drawRect(destRect</span><span class="s2">, </span><span class="s1">paint)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">output.clone()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">CloseableReference.closeSafely(output)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private final </span><span class="s1">List&lt;ImageSource&gt; mSources = </span><span class="s2">new </span><span class="s1">LinkedList&lt;&gt;()</span><span class="s2">;</span>

  <span class="s2">private </span><span class="s1">@Nullable ImageSource mImageSource</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ImageSource mCachedImageSource</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Drawable mDefaultImageDrawable</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Drawable mLoadingImageDrawable</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable RoundedColorDrawable mBackgroundImageDrawable</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mBackgroundColor = </span><span class="s4">0x00000000</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mBorderColor</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mOverlayColor</span><span class="s2">;</span>
  <span class="s2">private float </span><span class="s1">mBorderWidth</span><span class="s2">;</span>
  <span class="s2">private float </span><span class="s1">mBorderRadius = YogaConstants.UNDEFINED</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable </span><span class="s2">float</span><span class="s1">[] mBorderCornerRadii</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">ScalingUtils.ScaleType mScaleType = ImageResizeMode.defaultValue()</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">Shader.TileMode mTileMode = ImageResizeMode.defaultTileMode()</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mIsDirty</span><span class="s2">;</span>
  <span class="s2">private final </span><span class="s1">AbstractDraweeControllerBuilder mDraweeControllerBuilder</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable TilePostprocessor mTilePostprocessor</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable IterativeBoxBlurPostProcessor mIterativeBoxBlurPostProcessor</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ReactImageDownloadListener mDownloadListener</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable ControllerListener mControllerForTesting</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable GlobalImageLoadListener mGlobalImageLoadListener</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">@Nullable Object mCallerContext</span><span class="s2">;</span>
  <span class="s2">private int </span><span class="s1">mFadeDurationMs = -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">private boolean </span><span class="s1">mProgressiveRenderingEnabled</span><span class="s2">;</span>
  <span class="s2">private </span><span class="s1">ReadableMap mHeaders</span><span class="s2">;</span>

  <span class="s0">// We can't specify rounding in XML, so have to do so here</span>
  <span class="s2">private static </span><span class="s1">GenericDraweeHierarchy buildHierarchy(Context context) {</span>
    <span class="s1">RoundingParams roundingParams = RoundingParams.fromCornersRadius(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">roundingParams.setPaintFilterBitmap(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return new </span><span class="s1">GenericDraweeHierarchyBuilder(context.getResources())</span>
        <span class="s1">.setRoundingParams(roundingParams)</span>
        <span class="s1">.build()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public </span><span class="s1">ReactImageView(</span>
      <span class="s1">Context context</span><span class="s2">,</span>
      <span class="s1">AbstractDraweeControllerBuilder draweeControllerBuilder</span><span class="s2">,</span>
      <span class="s1">@Nullable GlobalImageLoadListener globalImageLoadListener</span><span class="s2">,</span>
      <span class="s1">@Nullable Object callerContext) {</span>
    <span class="s2">super</span><span class="s1">(context</span><span class="s2">, </span><span class="s1">buildHierarchy(context))</span><span class="s2">;</span>
    <span class="s1">mDraweeControllerBuilder = draweeControllerBuilder</span><span class="s2">;</span>
    <span class="s1">mGlobalImageLoadListener = globalImageLoadListener</span><span class="s2">;</span>
    <span class="s1">mCallerContext = callerContext</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setShouldNotifyLoadEvents(</span><span class="s2">boolean </span><span class="s1">shouldNotify) {</span>
    <span class="s0">// Skip update if shouldNotify is already in sync with the download listener</span>
    <span class="s2">if </span><span class="s1">(shouldNotify == (mDownloadListener != </span><span class="s2">null</span><span class="s1">)) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!shouldNotify) {</span>
      <span class="s1">mDownloadListener = </span><span class="s2">null;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">final </span><span class="s1">EventDispatcher mEventDispatcher =</span>
          <span class="s1">UIManagerHelper.getEventDispatcherForReactTag((ReactContext) getContext()</span><span class="s2">, </span><span class="s1">getId())</span><span class="s2">;</span>

      <span class="s1">mDownloadListener =</span>
          <span class="s2">new </span><span class="s1">ReactImageDownloadListener&lt;ImageInfo&gt;() {</span>
            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">onProgressChange(</span><span class="s2">int </span><span class="s1">loaded</span><span class="s2">, int </span><span class="s1">total) {</span>
              <span class="s0">// TODO: Somehow get image size and convert `loaded` and `total` to image bytes.</span>
              <span class="s1">mEventDispatcher.dispatchEvent(</span>
                  <span class="s1">ImageLoadEvent.createProgressEvent(</span>
                      <span class="s1">UIManagerHelper.getSurfaceId(ReactImageView.</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
                      <span class="s1">getId()</span><span class="s2">,</span>
                      <span class="s1">mImageSource.getSource()</span><span class="s2">,</span>
                      <span class="s1">loaded</span><span class="s2">,</span>
                      <span class="s1">total))</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">onSubmit(String id</span><span class="s2">, </span><span class="s1">Object callerContext) {</span>
              <span class="s1">mEventDispatcher.dispatchEvent(</span>
                  <span class="s1">ImageLoadEvent.createLoadStartEvent(</span>
                      <span class="s1">UIManagerHelper.getSurfaceId(ReactImageView.</span><span class="s2">this</span><span class="s1">)</span><span class="s2">, </span><span class="s1">getId()))</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">onFinalImageSet(</span>
                <span class="s1">String id</span><span class="s2">, </span><span class="s1">@Nullable </span><span class="s2">final </span><span class="s1">ImageInfo imageInfo</span><span class="s2">, </span><span class="s1">@Nullable Animatable animatable) {</span>
              <span class="s2">if </span><span class="s1">(imageInfo != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">mEventDispatcher.dispatchEvent(</span>
                    <span class="s1">ImageLoadEvent.createLoadEvent(</span>
                        <span class="s1">UIManagerHelper.getSurfaceId(ReactImageView.</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">getId()</span><span class="s2">,</span>
                        <span class="s1">mImageSource.getSource()</span><span class="s2">,</span>
                        <span class="s1">imageInfo.getWidth()</span><span class="s2">,</span>
                        <span class="s1">imageInfo.getHeight()))</span><span class="s2">;</span>
                <span class="s1">mEventDispatcher.dispatchEvent(</span>
                    <span class="s1">ImageLoadEvent.createLoadEndEvent(</span>
                        <span class="s1">UIManagerHelper.getSurfaceId(ReactImageView.</span><span class="s2">this</span><span class="s1">)</span><span class="s2">, </span><span class="s1">getId()))</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">@Override</span>
            <span class="s2">public void </span><span class="s1">onFailure(String id</span><span class="s2">, </span><span class="s1">Throwable throwable) {</span>
              <span class="s1">mEventDispatcher.dispatchEvent(</span>
                  <span class="s1">ImageLoadEvent.createErrorEvent(</span>
                      <span class="s1">UIManagerHelper.getSurfaceId(ReactImageView.</span><span class="s2">this</span><span class="s1">)</span><span class="s2">, </span><span class="s1">getId()</span><span class="s2">, </span><span class="s1">throwable))</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">mIsDirty = </span><span class="s2">true;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBlurRadius(</span><span class="s2">float </span><span class="s1">blurRadius) {</span>
    <span class="s0">// Divide `blurRadius` by 2 to more closely match other platforms.</span>
    <span class="s2">int </span><span class="s1">pixelBlurRadius = (</span><span class="s2">int</span><span class="s1">) PixelUtil.toPixelFromDIP(blurRadius) / </span><span class="s4">2</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(pixelBlurRadius == </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">mIterativeBoxBlurPostProcessor = </span><span class="s2">null;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mIterativeBoxBlurPostProcessor = </span><span class="s2">new </span><span class="s1">IterativeBoxBlurPostProcessor(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">pixelBlurRadius)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mIsDirty = </span><span class="s2">true;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">public void </span><span class="s1">setBackgroundColor(</span><span class="s2">int </span><span class="s1">backgroundColor) {</span>
    <span class="s2">if </span><span class="s1">(mBackgroundColor != backgroundColor) {</span>
      <span class="s1">mBackgroundColor = backgroundColor</span><span class="s2">;</span>
      <span class="s1">mBackgroundImageDrawable = </span><span class="s2">new </span><span class="s1">RoundedColorDrawable(backgroundColor)</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderColor(</span><span class="s2">int </span><span class="s1">borderColor) {</span>
    <span class="s2">if </span><span class="s1">(mBorderColor != borderColor) {</span>
      <span class="s1">mBorderColor = borderColor</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setOverlayColor(</span><span class="s2">int </span><span class="s1">overlayColor) {</span>
    <span class="s2">if </span><span class="s1">(mOverlayColor != overlayColor) {</span>
      <span class="s1">mOverlayColor = overlayColor</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderWidth(</span><span class="s2">float </span><span class="s1">borderWidth) {</span>
    <span class="s2">float </span><span class="s1">newBorderWidth = PixelUtil.toPixelFromDIP(borderWidth)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!FloatUtil.floatsEqual(mBorderWidth</span><span class="s2">, </span><span class="s1">newBorderWidth)) {</span>
      <span class="s1">mBorderWidth = newBorderWidth</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius) {</span>
    <span class="s2">if </span><span class="s1">(!FloatUtil.floatsEqual(mBorderRadius</span><span class="s2">, </span><span class="s1">borderRadius)) {</span>
      <span class="s1">mBorderRadius = borderRadius</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setBorderRadius(</span><span class="s2">float </span><span class="s1">borderRadius</span><span class="s2">, int </span><span class="s1">position) {</span>
    <span class="s2">if </span><span class="s1">(mBorderCornerRadii == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mBorderCornerRadii = </span><span class="s2">new float</span><span class="s1">[</span><span class="s4">4</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s1">Arrays.fill(mBorderCornerRadii</span><span class="s2">, </span><span class="s1">YogaConstants.UNDEFINED)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!FloatUtil.floatsEqual(mBorderCornerRadii[position]</span><span class="s2">, </span><span class="s1">borderRadius)) {</span>
      <span class="s1">mBorderCornerRadii[position] = borderRadius</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setScaleType(ScalingUtils.ScaleType scaleType) {</span>
    <span class="s2">if </span><span class="s1">(mScaleType != scaleType) {</span>
      <span class="s1">mScaleType = scaleType</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setTileMode(Shader.TileMode tileMode) {</span>
    <span class="s2">if </span><span class="s1">(mTileMode != tileMode) {</span>
      <span class="s1">mTileMode = tileMode</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isTiled()) {</span>
        <span class="s1">mTilePostprocessor = </span><span class="s2">new </span><span class="s1">TilePostprocessor()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">mTilePostprocessor = </span><span class="s2">null;</span>
      <span class="s1">}</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setResizeMethod(ImageResizeMethod resizeMethod) {</span>
    <span class="s2">if </span><span class="s1">(mResizeMethod != resizeMethod) {</span>
      <span class="s1">mResizeMethod = resizeMethod</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setSource(@Nullable ReadableArray sources) {</span>
    <span class="s1">List&lt;ImageSource&gt; tmpSources = </span><span class="s2">new </span><span class="s1">LinkedList&lt;&gt;()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(sources == </span><span class="s2">null </span><span class="s1">|| sources.size() == </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">tmpSources.add(ImageSource.getTransparentBitmapImageSource(getContext()))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(sources.size() == </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s0">// Optimize for the case where we have just one uri, case in which we don't need the sizes</span>
      <span class="s1">ReadableMap source = sources.getMap(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">ImageSource imageSource = </span><span class="s2">new </span><span class="s1">ImageSource(getContext()</span><span class="s2">, </span><span class="s1">source.getString(</span><span class="s5">&quot;uri&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(Uri.EMPTY.equals(imageSource.getUri())) {</span>
        <span class="s1">warnImageSource(source.getString(</span><span class="s5">&quot;uri&quot;</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">imageSource = ImageSource.getTransparentBitmapImageSource(getContext())</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">tmpSources.add(imageSource)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">idx = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">idx &lt; sources.size()</span><span class="s2">; </span><span class="s1">idx++) {</span>
        <span class="s1">ReadableMap source = sources.getMap(idx)</span><span class="s2">;</span>
        <span class="s1">ImageSource imageSource =</span>
            <span class="s2">new </span><span class="s1">ImageSource(</span>
                <span class="s1">getContext()</span><span class="s2">,</span>
                <span class="s1">source.getString(</span><span class="s5">&quot;uri&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">source.getDouble(</span><span class="s5">&quot;width&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">source.getDouble(</span><span class="s5">&quot;height&quot;</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(Uri.EMPTY.equals(imageSource.getUri())) {</span>
          <span class="s1">warnImageSource(source.getString(</span><span class="s5">&quot;uri&quot;</span><span class="s1">))</span><span class="s2">;</span>
          <span class="s1">imageSource = ImageSource.getTransparentBitmapImageSource(getContext())</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">tmpSources.add(imageSource)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Don't reset sources and dirty node if sources haven't changed</span>
    <span class="s2">if </span><span class="s1">(mSources.equals(tmpSources)) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mSources.clear()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(ImageSource src : tmpSources) {</span>
      <span class="s1">mSources.add(src)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mIsDirty = </span><span class="s2">true;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setDefaultSource(@Nullable String name) {</span>
    <span class="s1">Drawable newDefaultDrawable =</span>
        <span class="s1">ResourceDrawableIdHelper.getInstance().getResourceDrawable(getContext()</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!Objects.equal(mDefaultImageDrawable</span><span class="s2">, </span><span class="s1">newDefaultDrawable)) {</span>
      <span class="s1">mDefaultImageDrawable = newDefaultDrawable</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setLoadingIndicatorSource(@Nullable String name) {</span>
    <span class="s1">Drawable drawable =</span>
        <span class="s1">ResourceDrawableIdHelper.getInstance().getResourceDrawable(getContext()</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
    <span class="s1">Drawable newLoadingIndicatorSource =</span>
        <span class="s1">drawable != </span><span class="s2">null </span><span class="s1">? (Drawable) </span><span class="s2">new </span><span class="s1">AutoRotateDrawable(drawable</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">) : </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(!Objects.equal(mLoadingImageDrawable</span><span class="s2">, </span><span class="s1">newLoadingIndicatorSource)) {</span>
      <span class="s1">mLoadingImageDrawable = newLoadingIndicatorSource</span><span class="s2">;</span>
      <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setProgressiveRenderingEnabled(</span><span class="s2">boolean </span><span class="s1">enabled) {</span>
    <span class="s1">mProgressiveRenderingEnabled = enabled</span><span class="s2">;</span>
    <span class="s0">// no worth marking as dirty if it already rendered..</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setFadeDuration(</span><span class="s2">int </span><span class="s1">durationMs) {</span>
    <span class="s1">mFadeDurationMs = durationMs</span><span class="s2">;</span>
    <span class="s0">// no worth marking as dirty if it already rendered..</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">getCornerRadii(</span><span class="s2">float</span><span class="s1">[] computedCorners) {</span>
    <span class="s2">float </span><span class="s1">defaultBorderRadius = !YogaConstants.isUndefined(mBorderRadius) ? mBorderRadius : </span><span class="s4">0</span><span class="s2">;</span>

    <span class="s1">computedCorners[</span><span class="s4">0</span><span class="s1">] =</span>
        <span class="s1">mBorderCornerRadii != </span><span class="s2">null </span><span class="s1">&amp;&amp; !YogaConstants.isUndefined(mBorderCornerRadii[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">? mBorderCornerRadii[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">: defaultBorderRadius</span><span class="s2">;</span>
    <span class="s1">computedCorners[</span><span class="s4">1</span><span class="s1">] =</span>
        <span class="s1">mBorderCornerRadii != </span><span class="s2">null </span><span class="s1">&amp;&amp; !YogaConstants.isUndefined(mBorderCornerRadii[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">? mBorderCornerRadii[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">: defaultBorderRadius</span><span class="s2">;</span>
    <span class="s1">computedCorners[</span><span class="s4">2</span><span class="s1">] =</span>
        <span class="s1">mBorderCornerRadii != </span><span class="s2">null </span><span class="s1">&amp;&amp; !YogaConstants.isUndefined(mBorderCornerRadii[</span><span class="s4">2</span><span class="s1">])</span>
            <span class="s1">? mBorderCornerRadii[</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">: defaultBorderRadius</span><span class="s2">;</span>
    <span class="s1">computedCorners[</span><span class="s4">3</span><span class="s1">] =</span>
        <span class="s1">mBorderCornerRadii != </span><span class="s2">null </span><span class="s1">&amp;&amp; !YogaConstants.isUndefined(mBorderCornerRadii[</span><span class="s4">3</span><span class="s1">])</span>
            <span class="s1">? mBorderCornerRadii[</span><span class="s4">3</span><span class="s1">]</span>
            <span class="s1">: defaultBorderRadius</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">setHeaders(ReadableMap headers) {</span>
    <span class="s1">mHeaders = headers</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public void </span><span class="s1">maybeUpdateView() {</span>
    <span class="s2">if </span><span class="s1">(!mIsDirty) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(hasMultipleSources() &amp;&amp; (getWidth() &lt;= </span><span class="s4">0 </span><span class="s1">|| getHeight() &lt;= </span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s0">// If we need to choose from multiple uris but the size is not yet set, wait for layout pass</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">setSourceImage()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mImageSource == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">boolean </span><span class="s1">doResize = shouldResize(mImageSource)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(doResize &amp;&amp; (getWidth() &lt;= </span><span class="s4">0 </span><span class="s1">|| getHeight() &lt;= </span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s0">// If need a resize and the size is not yet set, wait until the layout pass provides one</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isTiled() &amp;&amp; (getWidth() &lt;= </span><span class="s4">0 </span><span class="s1">|| getHeight() &lt;= </span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s0">// If need to tile and the size is not yet set, wait until the layout pass provides one</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">GenericDraweeHierarchy hierarchy = getHierarchy()</span><span class="s2">;</span>
    <span class="s1">hierarchy.setActualImageScaleType(mScaleType)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mDefaultImageDrawable != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">hierarchy.setPlaceholderImage(mDefaultImageDrawable</span><span class="s2">, </span><span class="s1">mScaleType)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mLoadingImageDrawable != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">hierarchy.setPlaceholderImage(mLoadingImageDrawable</span><span class="s2">, </span><span class="s1">ScalingUtils.ScaleType.CENTER)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">getCornerRadii(sComputedCornerRadii)</span><span class="s2">;</span>

    <span class="s1">RoundingParams roundingParams = hierarchy.getRoundingParams()</span><span class="s2">;</span>
    <span class="s1">roundingParams.setCornersRadii(</span>
        <span class="s1">sComputedCornerRadii[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">sComputedCornerRadii[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">sComputedCornerRadii[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">sComputedCornerRadii[</span><span class="s4">3</span><span class="s1">])</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mBackgroundImageDrawable != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mBackgroundImageDrawable.setBorder(mBorderColor</span><span class="s2">, </span><span class="s1">mBorderWidth)</span><span class="s2">;</span>
      <span class="s1">mBackgroundImageDrawable.setRadii(roundingParams.getCornersRadii())</span><span class="s2">;</span>
      <span class="s1">hierarchy.setBackgroundImage(mBackgroundImageDrawable)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">roundingParams.setBorder(mBorderColor</span><span class="s2">, </span><span class="s1">mBorderWidth)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mOverlayColor != Color.TRANSPARENT) {</span>
      <span class="s1">roundingParams.setOverlayColor(mOverlayColor)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// make sure the default rounding method is used.</span>
      <span class="s1">roundingParams.setRoundingMethod(RoundingParams.RoundingMethod.BITMAP_ONLY)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hierarchy.setRoundingParams(roundingParams)</span><span class="s2">;</span>
    <span class="s1">hierarchy.setFadeDuration(</span>
        <span class="s1">mFadeDurationMs &gt;= </span><span class="s4">0</span>
            <span class="s1">? mFadeDurationMs</span>
            <span class="s1">: mImageSource.isResource() ? </span><span class="s4">0 </span><span class="s1">: REMOTE_IMAGE_FADE_DURATION_MS)</span><span class="s2">;</span>

    <span class="s1">List&lt;Postprocessor&gt; postprocessors = </span><span class="s2">new </span><span class="s1">LinkedList&lt;&gt;()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mIterativeBoxBlurPostProcessor != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">postprocessors.add(mIterativeBoxBlurPostProcessor)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mTilePostprocessor != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">postprocessors.add(mTilePostprocessor)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">Postprocessor postprocessor = MultiPostprocessor.from(postprocessors)</span><span class="s2">;</span>

    <span class="s1">ResizeOptions resizeOptions = doResize ? </span><span class="s2">new </span><span class="s1">ResizeOptions(getWidth()</span><span class="s2">, </span><span class="s1">getHeight()) : </span><span class="s2">null;</span>

    <span class="s1">ImageRequestBuilder imageRequestBuilder =</span>
        <span class="s1">ImageRequestBuilder.newBuilderWithSource(mImageSource.getUri())</span>
            <span class="s1">.setPostprocessor(postprocessor)</span>
            <span class="s1">.setResizeOptions(resizeOptions)</span>
            <span class="s1">.setAutoRotateEnabled(</span><span class="s2">true</span><span class="s1">)</span>
            <span class="s1">.setProgressiveRenderingEnabled(mProgressiveRenderingEnabled)</span><span class="s2">;</span>

    <span class="s1">ImageRequest imageRequest =</span>
        <span class="s1">ReactNetworkImageRequest.fromBuilderWithHeaders(imageRequestBuilder</span><span class="s2">, </span><span class="s1">mHeaders)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mGlobalImageLoadListener != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mGlobalImageLoadListener.onLoadAttempt(mImageSource.getUri())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// This builder is reused</span>
    <span class="s1">mDraweeControllerBuilder.reset()</span><span class="s2">;</span>

    <span class="s1">mDraweeControllerBuilder</span>
        <span class="s1">.setAutoPlayAnimations(</span><span class="s2">true</span><span class="s1">)</span>
        <span class="s1">.setCallerContext(mCallerContext)</span>
        <span class="s1">.setOldController(getController())</span>
        <span class="s1">.setImageRequest(imageRequest)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(mCachedImageSource != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ImageRequest cachedImageRequest =</span>
          <span class="s1">ImageRequestBuilder.newBuilderWithSource(mCachedImageSource.getUri())</span>
              <span class="s1">.setPostprocessor(postprocessor)</span>
              <span class="s1">.setResizeOptions(resizeOptions)</span>
              <span class="s1">.setAutoRotateEnabled(</span><span class="s2">true</span><span class="s1">)</span>
              <span class="s1">.setProgressiveRenderingEnabled(mProgressiveRenderingEnabled)</span>
              <span class="s1">.build()</span><span class="s2">;</span>
      <span class="s1">mDraweeControllerBuilder.setLowResImageRequest(cachedImageRequest)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mDownloadListener != </span><span class="s2">null </span><span class="s1">&amp;&amp; mControllerForTesting != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">ForwardingControllerListener combinedListener = </span><span class="s2">new </span><span class="s1">ForwardingControllerListener()</span><span class="s2">;</span>
      <span class="s1">combinedListener.addListener(mDownloadListener)</span><span class="s2">;</span>
      <span class="s1">combinedListener.addListener(mControllerForTesting)</span><span class="s2">;</span>
      <span class="s1">mDraweeControllerBuilder.setControllerListener(combinedListener)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mControllerForTesting != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mDraweeControllerBuilder.setControllerListener(mControllerForTesting)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mDownloadListener != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mDraweeControllerBuilder.setControllerListener(mDownloadListener)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(mDownloadListener != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">hierarchy.setProgressBarImage(mDownloadListener)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">setController(mDraweeControllerBuilder.build())</span><span class="s2">;</span>
    <span class="s1">mIsDirty = </span><span class="s2">false;</span>

    <span class="s0">// Reset again so the DraweeControllerBuilder clears all it's references. Otherwise, this causes</span>
    <span class="s0">// a memory leak.</span>
    <span class="s1">mDraweeControllerBuilder.reset()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// VisibleForTesting</span>
  <span class="s2">public void </span><span class="s1">setControllerListener(ControllerListener controllerListener) {</span>
    <span class="s1">mControllerForTesting = controllerListener</span><span class="s2">;</span>
    <span class="s1">mIsDirty = </span><span class="s2">true;</span>
    <span class="s1">maybeUpdateView()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// VisibleForTesting</span>
  <span class="s2">public </span><span class="s1">@Nullable ImageSource getImageSource() {</span>
    <span class="s2">return </span><span class="s1">mImageSource</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@Override</span>
  <span class="s2">protected void </span><span class="s1">onSizeChanged(</span><span class="s2">int </span><span class="s1">w</span><span class="s2">, int </span><span class="s1">h</span><span class="s2">, int </span><span class="s1">oldw</span><span class="s2">, int </span><span class="s1">oldh) {</span>
    <span class="s2">super</span><span class="s1">.onSizeChanged(w</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">oldw</span><span class="s2">, </span><span class="s1">oldh)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(w &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; h &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">mIsDirty = mIsDirty || hasMultipleSources() || isTiled()</span><span class="s2">;</span>
      <span class="s1">maybeUpdateView()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">/** ReactImageViews only render a single image. */</span>
  <span class="s1">@Override</span>
  <span class="s2">public boolean </span><span class="s1">hasOverlappingRendering() {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">hasMultipleSources() {</span>
    <span class="s2">return </span><span class="s1">mSources.size() &gt; </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">isTiled() {</span>
    <span class="s2">return </span><span class="s1">mTileMode != Shader.TileMode.CLAMP</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">setSourceImage() {</span>
    <span class="s1">mImageSource = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(mSources.isEmpty()) {</span>
      <span class="s1">mSources.add(ImageSource.getTransparentBitmapImageSource(getContext()))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasMultipleSources()) {</span>
      <span class="s1">MultiSourceResult multiSource =</span>
          <span class="s1">MultiSourceHelper.getBestSourceForSize(getWidth()</span><span class="s2">, </span><span class="s1">getHeight()</span><span class="s2">, </span><span class="s1">mSources)</span><span class="s2">;</span>
      <span class="s1">mImageSource = multiSource.getBestResult()</span><span class="s2">;</span>
      <span class="s1">mCachedImageSource = multiSource.getBestResultInCache()</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">mImageSource = mSources.get(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">private boolean </span><span class="s1">shouldResize(ImageSource imageSource) {</span>
    <span class="s0">// Resizing is inferior to scaling. See http://frescolib.org/docs/resizing-rotating.html#_</span>
    <span class="s0">// We resize here only for images likely to be from the device's camera, where the app developer</span>
    <span class="s0">// has no control over the original size</span>
    <span class="s2">if </span><span class="s1">(mResizeMethod == ImageResizeMethod.AUTO) {</span>
      <span class="s2">return </span><span class="s1">UriUtil.isLocalContentUri(imageSource.getUri())</span>
          <span class="s1">|| UriUtil.isLocalFileUri(imageSource.getUri())</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mResizeMethod == ImageResizeMethod.RESIZE) {</span>
      <span class="s2">return true;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private void </span><span class="s1">warnImageSource(String uri) {</span>
    <span class="s2">if </span><span class="s1">(ReactBuildConfig.DEBUG) {</span>
      <span class="s1">RNLog.w(</span>
          <span class="s1">(ReactContext) getContext()</span><span class="s2">,</span>
          <span class="s5">&quot;ReactImageView: Image source </span><span class="s2">\&quot;</span><span class="s5">&quot; </span><span class="s1">+ uri + </span><span class="s5">&quot;</span><span class="s2">\&quot; </span><span class="s5">doesn't exist&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
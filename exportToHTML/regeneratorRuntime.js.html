<html>
<head>
<title>regeneratorRuntime.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
regeneratorRuntime.js</font>
</center></td></tr></table>
<pre><span class="s0">import _typeof from </span><span class="s1">&quot;./typeof.js&quot;</span><span class="s0">;</span>
<span class="s0">export </span><span class="s2">default function </span><span class="s0">_regeneratorRuntime() {</span>
  <span class="s1">&quot;use strict&quot;</span><span class="s0">; </span><span class="s3">/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */</span>
  <span class="s0">_regeneratorRuntime = </span><span class="s2">function </span><span class="s0">_regeneratorRuntime() {</span>
    <span class="s2">return </span><span class="s0">exports;</span>
  <span class="s0">};</span>
  <span class="s2">var </span><span class="s0">exports = {},</span>
    <span class="s0">Op = Object.prototype,</span>
    <span class="s0">hasOwn = Op.hasOwnProperty,</span>
    <span class="s0">defineProperty = Object.defineProperty || </span><span class="s2">function </span><span class="s0">(obj, key, desc) {</span>
      <span class="s0">obj[key] = desc.value;</span>
    <span class="s0">},</span>
    <span class="s0">$Symbol = </span><span class="s1">&quot;function&quot; </span><span class="s0">== </span><span class="s2">typeof </span><span class="s0">Symbol ? Symbol : {},</span>
    <span class="s0">iteratorSymbol = $Symbol.iterator || </span><span class="s1">&quot;@@iterator&quot;</span><span class="s0">,</span>
    <span class="s0">asyncIteratorSymbol = $Symbol.asyncIterator || </span><span class="s1">&quot;@@asyncIterator&quot;</span><span class="s0">,</span>
    <span class="s0">toStringTagSymbol = $Symbol.toStringTag || </span><span class="s1">&quot;@@toStringTag&quot;</span><span class="s0">;</span>
  <span class="s2">function </span><span class="s0">define(obj, key, value) {</span>
    <span class="s2">return </span><span class="s0">Object.defineProperty(obj, key, {</span>
      <span class="s0">value: value,</span>
      <span class="s0">enumerable: !</span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">configurable: !</span><span class="s4">0</span><span class="s0">,</span>
      <span class="s0">writable: !</span><span class="s4">0</span>
    <span class="s0">}), obj[key];</span>
  <span class="s0">}</span>
  <span class="s2">try </span><span class="s0">{</span>
    <span class="s0">define({}, </span><span class="s1">&quot;&quot;</span><span class="s0">);</span>
  <span class="s0">} </span><span class="s2">catch </span><span class="s0">(err) {</span>
    <span class="s0">define = </span><span class="s2">function </span><span class="s0">define(obj, key, value) {</span>
      <span class="s2">return </span><span class="s0">obj[key] = value;</span>
    <span class="s0">};</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">wrap(innerFn, outerFn, self, tryLocsList) {</span>
    <span class="s2">var </span><span class="s0">protoGenerator = outerFn &amp;&amp; outerFn.prototype </span><span class="s2">instanceof </span><span class="s0">Generator ? outerFn : Generator,</span>
      <span class="s0">generator = Object.create(protoGenerator.prototype),</span>
      <span class="s0">context = </span><span class="s2">new </span><span class="s0">Context(tryLocsList || []);</span>
    <span class="s2">return </span><span class="s0">defineProperty(generator, </span><span class="s1">&quot;_invoke&quot;</span><span class="s0">, {</span>
      <span class="s0">value: makeInvokeMethod(innerFn, self, context)</span>
    <span class="s0">}), generator;</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">tryCatch(fn, obj, arg) {</span>
    <span class="s2">try </span><span class="s0">{</span>
      <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">type: </span><span class="s1">&quot;normal&quot;</span><span class="s0">,</span>
        <span class="s0">arg: fn.call(obj, arg)</span>
      <span class="s0">};</span>
    <span class="s0">} </span><span class="s2">catch </span><span class="s0">(err) {</span>
      <span class="s2">return </span><span class="s0">{</span>
        <span class="s0">type: </span><span class="s1">&quot;throw&quot;</span><span class="s0">,</span>
        <span class="s0">arg: err</span>
      <span class="s0">};</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s0">exports.wrap = wrap;</span>
  <span class="s2">var </span><span class="s0">ContinueSentinel = {};</span>
  <span class="s2">function </span><span class="s0">Generator() {}</span>
  <span class="s2">function </span><span class="s0">GeneratorFunction() {}</span>
  <span class="s2">function </span><span class="s0">GeneratorFunctionPrototype() {}</span>
  <span class="s2">var </span><span class="s0">IteratorPrototype = {};</span>
  <span class="s0">define(IteratorPrototype, iteratorSymbol, </span><span class="s2">function </span><span class="s0">() {</span>
    <span class="s2">return this</span><span class="s0">;</span>
  <span class="s0">});</span>
  <span class="s2">var </span><span class="s0">getProto = Object.getPrototypeOf,</span>
    <span class="s0">NativeIteratorPrototype = getProto &amp;&amp; getProto(getProto(values([])));</span>
  <span class="s0">NativeIteratorPrototype &amp;&amp; NativeIteratorPrototype !== Op &amp;&amp; hasOwn.call(NativeIteratorPrototype, iteratorSymbol) &amp;&amp; (IteratorPrototype = NativeIteratorPrototype);</span>
  <span class="s2">var </span><span class="s0">Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);</span>
  <span class="s2">function </span><span class="s0">defineIteratorMethods(prototype) {</span>
    <span class="s0">[</span><span class="s1">&quot;next&quot;</span><span class="s0">, </span><span class="s1">&quot;throw&quot;</span><span class="s0">, </span><span class="s1">&quot;return&quot;</span><span class="s0">].forEach(</span><span class="s2">function </span><span class="s0">(method) {</span>
      <span class="s0">define(prototype, method, </span><span class="s2">function </span><span class="s0">(arg) {</span>
        <span class="s2">return this</span><span class="s0">._invoke(method, arg);</span>
      <span class="s0">});</span>
    <span class="s0">});</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">AsyncIterator(generator, PromiseImpl) {</span>
    <span class="s2">function </span><span class="s0">invoke(method, arg, resolve, reject) {</span>
      <span class="s2">var </span><span class="s0">record = tryCatch(generator[method], generator, arg);</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;throw&quot; </span><span class="s0">!== record.type) {</span>
        <span class="s2">var </span><span class="s0">result = record.arg,</span>
          <span class="s0">value = result.value;</span>
        <span class="s2">return </span><span class="s0">value &amp;&amp; </span><span class="s1">&quot;object&quot; </span><span class="s0">== _typeof(value) &amp;&amp; hasOwn.call(value, </span><span class="s1">&quot;__await&quot;</span><span class="s0">) ? PromiseImpl.resolve(value.__await).then(</span><span class="s2">function </span><span class="s0">(value) {</span>
          <span class="s0">invoke(</span><span class="s1">&quot;next&quot;</span><span class="s0">, value, resolve, reject);</span>
        <span class="s0">}, </span><span class="s2">function </span><span class="s0">(err) {</span>
          <span class="s0">invoke(</span><span class="s1">&quot;throw&quot;</span><span class="s0">, err, resolve, reject);</span>
        <span class="s0">}) : PromiseImpl.resolve(value).then(</span><span class="s2">function </span><span class="s0">(unwrapped) {</span>
          <span class="s0">result.value = unwrapped, resolve(result);</span>
        <span class="s0">}, </span><span class="s2">function </span><span class="s0">(error) {</span>
          <span class="s2">return </span><span class="s0">invoke(</span><span class="s1">&quot;throw&quot;</span><span class="s0">, error, resolve, reject);</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
      <span class="s0">reject(record.arg);</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">previousPromise;</span>
    <span class="s0">defineProperty(</span><span class="s2">this</span><span class="s0">, </span><span class="s1">&quot;_invoke&quot;</span><span class="s0">, {</span>
      <span class="s0">value: </span><span class="s2">function </span><span class="s0">value(method, arg) {</span>
        <span class="s2">function </span><span class="s0">callInvokeWithMethodAndArg() {</span>
          <span class="s2">return new </span><span class="s0">PromiseImpl(</span><span class="s2">function </span><span class="s0">(resolve, reject) {</span>
            <span class="s0">invoke(method, arg, resolve, reject);</span>
          <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s2">return </span><span class="s0">previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">makeInvokeMethod(innerFn, self, context) {</span>
    <span class="s2">var </span><span class="s0">state = </span><span class="s1">&quot;suspendedStart&quot;</span><span class="s0">;</span>
    <span class="s2">return function </span><span class="s0">(method, arg) {</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;executing&quot; </span><span class="s0">=== state) </span><span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;Generator is already running&quot;</span><span class="s0">);</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;completed&quot; </span><span class="s0">=== state) {</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;throw&quot; </span><span class="s0">=== method) </span><span class="s2">throw </span><span class="s0">arg;</span>
        <span class="s2">return </span><span class="s0">doneResult();</span>
      <span class="s0">}</span>
      <span class="s2">for </span><span class="s0">(context.method = method, context.arg = arg;;) {</span>
        <span class="s2">var </span><span class="s0">delegate = context.delegate;</span>
        <span class="s2">if </span><span class="s0">(delegate) {</span>
          <span class="s2">var </span><span class="s0">delegateResult = maybeInvokeDelegate(delegate, context);</span>
          <span class="s2">if </span><span class="s0">(delegateResult) {</span>
            <span class="s2">if </span><span class="s0">(delegateResult === ContinueSentinel) </span><span class="s2">continue</span><span class="s0">;</span>
            <span class="s2">return </span><span class="s0">delegateResult;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;next&quot; </span><span class="s0">=== context.method) context.sent = context._sent = context.arg;</span><span class="s2">else if </span><span class="s0">(</span><span class="s1">&quot;throw&quot; </span><span class="s0">=== context.method) {</span>
          <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;suspendedStart&quot; </span><span class="s0">=== state) </span><span class="s2">throw </span><span class="s0">state = </span><span class="s1">&quot;completed&quot;</span><span class="s0">, context.arg;</span>
          <span class="s0">context.dispatchException(context.arg);</span>
        <span class="s0">} </span><span class="s2">else </span><span class="s1">&quot;return&quot; </span><span class="s0">=== context.method &amp;&amp; context.abrupt(</span><span class="s1">&quot;return&quot;</span><span class="s0">, context.arg);</span>
        <span class="s0">state = </span><span class="s1">&quot;executing&quot;</span><span class="s0">;</span>
        <span class="s2">var </span><span class="s0">record = tryCatch(innerFn, self, context);</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;normal&quot; </span><span class="s0">=== record.type) {</span>
          <span class="s2">if </span><span class="s0">(state = context.done ? </span><span class="s1">&quot;completed&quot; </span><span class="s0">: </span><span class="s1">&quot;suspendedYield&quot;</span><span class="s0">, record.arg === ContinueSentinel) </span><span class="s2">continue</span><span class="s0">;</span>
          <span class="s2">return </span><span class="s0">{</span>
            <span class="s0">value: record.arg,</span>
            <span class="s0">done: context.done</span>
          <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">&quot;throw&quot; </span><span class="s0">=== record.type &amp;&amp; (state = </span><span class="s1">&quot;completed&quot;</span><span class="s0">, context.method = </span><span class="s1">&quot;throw&quot;</span><span class="s0">, context.arg = record.arg);</span>
      <span class="s0">}</span>
    <span class="s0">};</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">maybeInvokeDelegate(delegate, context) {</span>
    <span class="s2">var </span><span class="s0">methodName = context.method,</span>
      <span class="s0">method = delegate.iterator[methodName];</span>
    <span class="s2">if </span><span class="s0">(undefined === method) </span><span class="s2">return </span><span class="s0">context.delegate = </span><span class="s2">null</span><span class="s0">, </span><span class="s1">&quot;throw&quot; </span><span class="s0">=== methodName &amp;&amp; delegate.iterator[</span><span class="s1">&quot;return&quot;</span><span class="s0">] &amp;&amp; (context.method = </span><span class="s1">&quot;return&quot;</span><span class="s0">, context.arg = undefined, maybeInvokeDelegate(delegate, context), </span><span class="s1">&quot;throw&quot; </span><span class="s0">=== context.method) || </span><span class="s1">&quot;return&quot; </span><span class="s0">!== methodName &amp;&amp; (context.method = </span><span class="s1">&quot;throw&quot;</span><span class="s0">, context.arg = </span><span class="s2">new </span><span class="s0">TypeError(</span><span class="s1">&quot;The iterator does not provide a '&quot; </span><span class="s0">+ methodName + </span><span class="s1">&quot;' method&quot;</span><span class="s0">)), ContinueSentinel;</span>
    <span class="s2">var </span><span class="s0">record = tryCatch(method, delegate.iterator, context.arg);</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;throw&quot; </span><span class="s0">=== record.type) </span><span class="s2">return </span><span class="s0">context.method = </span><span class="s1">&quot;throw&quot;</span><span class="s0">, context.arg = record.arg, context.delegate = </span><span class="s2">null</span><span class="s0">, ContinueSentinel;</span>
    <span class="s2">var </span><span class="s0">info = record.arg;</span>
    <span class="s2">return </span><span class="s0">info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, </span><span class="s1">&quot;return&quot; </span><span class="s0">!== context.method &amp;&amp; (context.method = </span><span class="s1">&quot;next&quot;</span><span class="s0">, context.arg = undefined), context.delegate = </span><span class="s2">null</span><span class="s0">, ContinueSentinel) : info : (context.method = </span><span class="s1">&quot;throw&quot;</span><span class="s0">, context.arg = </span><span class="s2">new </span><span class="s0">TypeError(</span><span class="s1">&quot;iterator result is not an object&quot;</span><span class="s0">), context.delegate = </span><span class="s2">null</span><span class="s0">, ContinueSentinel);</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">pushTryEntry(locs) {</span>
    <span class="s2">var </span><span class="s0">entry = {</span>
      <span class="s0">tryLoc: locs[</span><span class="s4">0</span><span class="s0">]</span>
    <span class="s0">};</span>
    <span class="s4">1 </span><span class="s2">in </span><span class="s0">locs &amp;&amp; (entry.catchLoc = locs[</span><span class="s4">1</span><span class="s0">]), </span><span class="s4">2 </span><span class="s2">in </span><span class="s0">locs &amp;&amp; (entry.finallyLoc = locs[</span><span class="s4">2</span><span class="s0">], entry.afterLoc = locs[</span><span class="s4">3</span><span class="s0">]), </span><span class="s2">this</span><span class="s0">.tryEntries.push(entry);</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">resetTryEntry(entry) {</span>
    <span class="s2">var </span><span class="s0">record = entry.completion || {};</span>
    <span class="s0">record.type = </span><span class="s1">&quot;normal&quot;</span><span class="s0">, </span><span class="s2">delete </span><span class="s0">record.arg, entry.completion = record;</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">Context(tryLocsList) {</span>
    <span class="s2">this</span><span class="s0">.tryEntries = [{</span>
      <span class="s0">tryLoc: </span><span class="s1">&quot;root&quot;</span>
    <span class="s0">}], tryLocsList.forEach(pushTryEntry, </span><span class="s2">this</span><span class="s0">), </span><span class="s2">this</span><span class="s0">.reset(!</span><span class="s4">0</span><span class="s0">);</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">values(iterable) {</span>
    <span class="s2">if </span><span class="s0">(iterable) {</span>
      <span class="s2">var </span><span class="s0">iteratorMethod = iterable[iteratorSymbol];</span>
      <span class="s2">if </span><span class="s0">(iteratorMethod) </span><span class="s2">return </span><span class="s0">iteratorMethod.call(iterable);</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;function&quot; </span><span class="s0">== </span><span class="s2">typeof </span><span class="s0">iterable.next) </span><span class="s2">return </span><span class="s0">iterable;</span>
      <span class="s2">if </span><span class="s0">(!isNaN(iterable.length)) {</span>
        <span class="s2">var </span><span class="s0">i = -</span><span class="s4">1</span><span class="s0">,</span>
          <span class="s0">next = </span><span class="s2">function </span><span class="s0">next() {</span>
            <span class="s2">for </span><span class="s0">(; ++i &lt; iterable.length;) </span><span class="s2">if </span><span class="s0">(hasOwn.call(iterable, i)) </span><span class="s2">return </span><span class="s0">next.value = iterable[i], next.done = !</span><span class="s4">1</span><span class="s0">, next;</span>
            <span class="s2">return </span><span class="s0">next.value = undefined, next.done = !</span><span class="s4">0</span><span class="s0">, next;</span>
          <span class="s0">};</span>
        <span class="s2">return </span><span class="s0">next.next = next;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">{</span>
      <span class="s0">next: doneResult</span>
    <span class="s0">};</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">doneResult() {</span>
    <span class="s2">return </span><span class="s0">{</span>
      <span class="s0">value: undefined,</span>
      <span class="s0">done: !</span><span class="s4">0</span>
    <span class="s0">};</span>
  <span class="s0">}</span>
  <span class="s2">return </span><span class="s0">GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, </span><span class="s1">&quot;constructor&quot;</span><span class="s0">, {</span>
    <span class="s0">value: GeneratorFunctionPrototype,</span>
    <span class="s0">configurable: !</span><span class="s4">0</span>
  <span class="s0">}), defineProperty(GeneratorFunctionPrototype, </span><span class="s1">&quot;constructor&quot;</span><span class="s0">, {</span>
    <span class="s0">value: GeneratorFunction,</span>
    <span class="s0">configurable: !</span><span class="s4">0</span>
  <span class="s0">}), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, </span><span class="s1">&quot;GeneratorFunction&quot;</span><span class="s0">), exports.isGeneratorFunction = </span><span class="s2">function </span><span class="s0">(genFun) {</span>
    <span class="s2">var </span><span class="s0">ctor = </span><span class="s1">&quot;function&quot; </span><span class="s0">== </span><span class="s2">typeof </span><span class="s0">genFun &amp;&amp; genFun.constructor;</span>
    <span class="s2">return </span><span class="s0">!!ctor &amp;&amp; (ctor === GeneratorFunction || </span><span class="s1">&quot;GeneratorFunction&quot; </span><span class="s0">=== (ctor.displayName || ctor.name));</span>
  <span class="s0">}, exports.mark = </span><span class="s2">function </span><span class="s0">(genFun) {</span>
    <span class="s2">return </span><span class="s0">Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, </span><span class="s1">&quot;GeneratorFunction&quot;</span><span class="s0">)), genFun.prototype = Object.create(Gp), genFun;</span>
  <span class="s0">}, exports.awrap = </span><span class="s2">function </span><span class="s0">(arg) {</span>
    <span class="s2">return </span><span class="s0">{</span>
      <span class="s0">__await: arg</span>
    <span class="s0">};</span>
  <span class="s0">}, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, </span><span class="s2">function </span><span class="s0">() {</span>
    <span class="s2">return this</span><span class="s0">;</span>
  <span class="s0">}), exports.AsyncIterator = AsyncIterator, exports.async = </span><span class="s2">function </span><span class="s0">(innerFn, outerFn, self, tryLocsList, PromiseImpl) {</span>
    <span class="s2">void </span><span class="s4">0 </span><span class="s0">=== PromiseImpl &amp;&amp; (PromiseImpl = Promise);</span>
    <span class="s2">var </span><span class="s0">iter = </span><span class="s2">new </span><span class="s0">AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);</span>
    <span class="s2">return </span><span class="s0">exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(</span><span class="s2">function </span><span class="s0">(result) {</span>
      <span class="s2">return </span><span class="s0">result.done ? result.value : iter.next();</span>
    <span class="s0">});</span>
  <span class="s0">}, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, </span><span class="s1">&quot;Generator&quot;</span><span class="s0">), define(Gp, iteratorSymbol, </span><span class="s2">function </span><span class="s0">() {</span>
    <span class="s2">return this</span><span class="s0">;</span>
  <span class="s0">}), define(Gp, </span><span class="s1">&quot;toString&quot;</span><span class="s0">, </span><span class="s2">function </span><span class="s0">() {</span>
    <span class="s2">return </span><span class="s1">&quot;[object Generator]&quot;</span><span class="s0">;</span>
  <span class="s0">}), exports.keys = </span><span class="s2">function </span><span class="s0">(val) {</span>
    <span class="s2">var </span><span class="s0">object = Object(val),</span>
      <span class="s0">keys = [];</span>
    <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">key </span><span class="s2">in </span><span class="s0">object) keys.push(key);</span>
    <span class="s2">return </span><span class="s0">keys.reverse(), </span><span class="s2">function </span><span class="s0">next() {</span>
      <span class="s2">for </span><span class="s0">(; keys.length;) {</span>
        <span class="s2">var </span><span class="s0">key = keys.pop();</span>
        <span class="s2">if </span><span class="s0">(key </span><span class="s2">in </span><span class="s0">object) </span><span class="s2">return </span><span class="s0">next.value = key, next.done = !</span><span class="s4">1</span><span class="s0">, next;</span>
      <span class="s0">}</span>
      <span class="s2">return </span><span class="s0">next.done = !</span><span class="s4">0</span><span class="s0">, next;</span>
    <span class="s0">};</span>
  <span class="s0">}, exports.values = values, Context.prototype = {</span>
    <span class="s0">constructor: Context,</span>
    <span class="s0">reset: </span><span class="s2">function </span><span class="s0">reset(skipTempReset) {</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.prev = </span><span class="s4">0</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.next = </span><span class="s4">0</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.sent = </span><span class="s2">this</span><span class="s0">._sent = undefined, </span><span class="s2">this</span><span class="s0">.done = !</span><span class="s4">1</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.delegate = </span><span class="s2">null</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.method = </span><span class="s1">&quot;next&quot;</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.arg = undefined, </span><span class="s2">this</span><span class="s0">.tryEntries.forEach(resetTryEntry), !skipTempReset) </span><span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">name </span><span class="s2">in this</span><span class="s0">) </span><span class="s1">&quot;t&quot; </span><span class="s0">=== name.charAt(</span><span class="s4">0</span><span class="s0">) &amp;&amp; hasOwn.call(</span><span class="s2">this</span><span class="s0">, name) &amp;&amp; !isNaN(+name.slice(</span><span class="s4">1</span><span class="s0">)) &amp;&amp; (</span><span class="s2">this</span><span class="s0">[name] = undefined);</span>
    <span class="s0">},</span>
    <span class="s0">stop: </span><span class="s2">function </span><span class="s0">stop() {</span>
      <span class="s2">this</span><span class="s0">.done = !</span><span class="s4">0</span><span class="s0">;</span>
      <span class="s2">var </span><span class="s0">rootRecord = </span><span class="s2">this</span><span class="s0">.tryEntries[</span><span class="s4">0</span><span class="s0">].completion;</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;throw&quot; </span><span class="s0">=== rootRecord.type) </span><span class="s2">throw </span><span class="s0">rootRecord.arg;</span>
      <span class="s2">return this</span><span class="s0">.rval;</span>
    <span class="s0">},</span>
    <span class="s0">dispatchException: </span><span class="s2">function </span><span class="s0">dispatchException(exception) {</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.done) </span><span class="s2">throw </span><span class="s0">exception;</span>
      <span class="s2">var </span><span class="s0">context = </span><span class="s2">this</span><span class="s0">;</span>
      <span class="s2">function </span><span class="s0">handle(loc, caught) {</span>
        <span class="s2">return </span><span class="s0">record.type = </span><span class="s1">&quot;throw&quot;</span><span class="s0">, record.arg = exception, context.next = loc, caught &amp;&amp; (context.method = </span><span class="s1">&quot;next&quot;</span><span class="s0">, context.arg = undefined), !!caught;</span>
      <span class="s0">}</span>
      <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s2">this</span><span class="s0">.tryEntries.length - </span><span class="s4">1</span><span class="s0">; i &gt;= </span><span class="s4">0</span><span class="s0">; --i) {</span>
        <span class="s2">var </span><span class="s0">entry = </span><span class="s2">this</span><span class="s0">.tryEntries[i],</span>
          <span class="s0">record = entry.completion;</span>
        <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;root&quot; </span><span class="s0">=== entry.tryLoc) </span><span class="s2">return </span><span class="s0">handle(</span><span class="s1">&quot;end&quot;</span><span class="s0">);</span>
        <span class="s2">if </span><span class="s0">(entry.tryLoc &lt;= </span><span class="s2">this</span><span class="s0">.prev) {</span>
          <span class="s2">var </span><span class="s0">hasCatch = hasOwn.call(entry, </span><span class="s1">&quot;catchLoc&quot;</span><span class="s0">),</span>
            <span class="s0">hasFinally = hasOwn.call(entry, </span><span class="s1">&quot;finallyLoc&quot;</span><span class="s0">);</span>
          <span class="s2">if </span><span class="s0">(hasCatch &amp;&amp; hasFinally) {</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.prev &lt; entry.catchLoc) </span><span class="s2">return </span><span class="s0">handle(entry.catchLoc, !</span><span class="s4">0</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.prev &lt; entry.finallyLoc) </span><span class="s2">return </span><span class="s0">handle(entry.finallyLoc);</span>
          <span class="s0">} </span><span class="s2">else if </span><span class="s0">(hasCatch) {</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.prev &lt; entry.catchLoc) </span><span class="s2">return </span><span class="s0">handle(entry.catchLoc, !</span><span class="s4">0</span><span class="s0">);</span>
          <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
            <span class="s2">if </span><span class="s0">(!hasFinally) </span><span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;try statement without catch or finally&quot;</span><span class="s0">);</span>
            <span class="s2">if </span><span class="s0">(</span><span class="s2">this</span><span class="s0">.prev &lt; entry.finallyLoc) </span><span class="s2">return </span><span class="s0">handle(entry.finallyLoc);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">abrupt: </span><span class="s2">function </span><span class="s0">abrupt(type, arg) {</span>
      <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s2">this</span><span class="s0">.tryEntries.length - </span><span class="s4">1</span><span class="s0">; i &gt;= </span><span class="s4">0</span><span class="s0">; --i) {</span>
        <span class="s2">var </span><span class="s0">entry = </span><span class="s2">this</span><span class="s0">.tryEntries[i];</span>
        <span class="s2">if </span><span class="s0">(entry.tryLoc &lt;= </span><span class="s2">this</span><span class="s0">.prev &amp;&amp; hasOwn.call(entry, </span><span class="s1">&quot;finallyLoc&quot;</span><span class="s0">) &amp;&amp; </span><span class="s2">this</span><span class="s0">.prev &lt; entry.finallyLoc) {</span>
          <span class="s2">var </span><span class="s0">finallyEntry = entry;</span>
          <span class="s2">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
      <span class="s0">finallyEntry &amp;&amp; (</span><span class="s1">&quot;break&quot; </span><span class="s0">=== type || </span><span class="s1">&quot;continue&quot; </span><span class="s0">=== type) &amp;&amp; finallyEntry.tryLoc &lt;= arg &amp;&amp; arg &lt;= finallyEntry.finallyLoc &amp;&amp; (finallyEntry = </span><span class="s2">null</span><span class="s0">);</span>
      <span class="s2">var </span><span class="s0">record = finallyEntry ? finallyEntry.completion : {};</span>
      <span class="s2">return </span><span class="s0">record.type = type, record.arg = arg, finallyEntry ? (</span><span class="s2">this</span><span class="s0">.method = </span><span class="s1">&quot;next&quot;</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.next = finallyEntry.finallyLoc, ContinueSentinel) : </span><span class="s2">this</span><span class="s0">.complete(record);</span>
    <span class="s0">},</span>
    <span class="s0">complete: </span><span class="s2">function </span><span class="s0">complete(record, afterLoc) {</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;throw&quot; </span><span class="s0">=== record.type) </span><span class="s2">throw </span><span class="s0">record.arg;</span>
      <span class="s2">return </span><span class="s1">&quot;break&quot; </span><span class="s0">=== record.type || </span><span class="s1">&quot;continue&quot; </span><span class="s0">=== record.type ? </span><span class="s2">this</span><span class="s0">.next = record.arg : </span><span class="s1">&quot;return&quot; </span><span class="s0">=== record.type ? (</span><span class="s2">this</span><span class="s0">.rval = </span><span class="s2">this</span><span class="s0">.arg = record.arg, </span><span class="s2">this</span><span class="s0">.method = </span><span class="s1">&quot;return&quot;</span><span class="s0">, </span><span class="s2">this</span><span class="s0">.next = </span><span class="s1">&quot;end&quot;</span><span class="s0">) : </span><span class="s1">&quot;normal&quot; </span><span class="s0">=== record.type &amp;&amp; afterLoc &amp;&amp; (</span><span class="s2">this</span><span class="s0">.next = afterLoc), ContinueSentinel;</span>
    <span class="s0">},</span>
    <span class="s0">finish: </span><span class="s2">function </span><span class="s0">finish(finallyLoc) {</span>
      <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s2">this</span><span class="s0">.tryEntries.length - </span><span class="s4">1</span><span class="s0">; i &gt;= </span><span class="s4">0</span><span class="s0">; --i) {</span>
        <span class="s2">var </span><span class="s0">entry = </span><span class="s2">this</span><span class="s0">.tryEntries[i];</span>
        <span class="s2">if </span><span class="s0">(entry.finallyLoc === finallyLoc) </span><span class="s2">return this</span><span class="s0">.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;</span>
      <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s1">&quot;catch&quot;</span><span class="s0">: </span><span class="s2">function </span><span class="s0">_catch(tryLoc) {</span>
      <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s2">this</span><span class="s0">.tryEntries.length - </span><span class="s4">1</span><span class="s0">; i &gt;= </span><span class="s4">0</span><span class="s0">; --i) {</span>
        <span class="s2">var </span><span class="s0">entry = </span><span class="s2">this</span><span class="s0">.tryEntries[i];</span>
        <span class="s2">if </span><span class="s0">(entry.tryLoc === tryLoc) {</span>
          <span class="s2">var </span><span class="s0">record = entry.completion;</span>
          <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;throw&quot; </span><span class="s0">=== record.type) {</span>
            <span class="s2">var </span><span class="s0">thrown = record.arg;</span>
            <span class="s0">resetTryEntry(entry);</span>
          <span class="s0">}</span>
          <span class="s2">return </span><span class="s0">thrown;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
      <span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;illegal catch attempt&quot;</span><span class="s0">);</span>
    <span class="s0">},</span>
    <span class="s0">delegateYield: </span><span class="s2">function </span><span class="s0">delegateYield(iterable, resultName, nextLoc) {</span>
      <span class="s2">return this</span><span class="s0">.delegate = {</span>
        <span class="s0">iterator: values(iterable),</span>
        <span class="s0">resultName: resultName,</span>
        <span class="s0">nextLoc: nextLoc</span>
      <span class="s0">}, </span><span class="s1">&quot;next&quot; </span><span class="s0">=== </span><span class="s2">this</span><span class="s0">.method &amp;&amp; (</span><span class="s2">this</span><span class="s0">.arg = undefined), ContinueSentinel;</span>
    <span class="s0">}</span>
  <span class="s0">}, exports;</span>
<span class="s0">}</span></pre>
</body>
</html>
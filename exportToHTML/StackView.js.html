<html>
<head>
<title>StackView.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
StackView.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">_elements = require(</span><span class="s0">&quot;@react-navigation/elements&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_native = require(</span><span class="s0">&quot;@react-navigation/native&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">React = _interopRequireWildcard(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_reactNative = require(</span><span class="s0">&quot;react-native&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_reactNativeSafeAreaContext = require(</span><span class="s0">&quot;react-native-safe-area-context&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_ModalPresentationContext = _interopRequireDefault(require(</span><span class="s0">&quot;../../utils/ModalPresentationContext&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_GestureHandler = require(</span><span class="s0">&quot;../GestureHandler&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">_HeaderContainer = _interopRequireDefault(require(</span><span class="s0">&quot;../Header/HeaderContainer&quot;</span><span class="s1">));</span>
<span class="s2">var </span><span class="s1">_CardStack = _interopRequireDefault(require(</span><span class="s0">&quot;./CardStack&quot;</span><span class="s1">));</span>
<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj }; }</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) { </span><span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">; </span><span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap(); </span><span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap(); </span><span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">(nodeInterop) { </span><span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }</span>
<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj, nodeInterop) { </span><span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) { </span><span class="s2">return </span><span class="s1">obj; } </span><span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj }; } </span><span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop); </span><span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s2">return </span><span class="s1">cache.get(obj); } </span><span class="s2">var </span><span class="s1">newObj = {}; </span><span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) { </span><span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) { </span><span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } </span><span class="s2">else </span><span class="s1">{ newObj[key] = obj[key]; } } } newObj.</span><span class="s2">default </span><span class="s1">= obj; </span><span class="s2">if </span><span class="s1">(cache) { cache.set(obj, newObj); } </span><span class="s2">return </span><span class="s1">newObj; }</span>
<span class="s2">function </span><span class="s1">_extends() { _extends = Object.assign ? Object.assign.bind() : </span><span class="s2">function </span><span class="s1">(target) { </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s3">1</span><span class="s1">; i &lt; arguments.length; i++) { </span><span class="s2">var </span><span class="s1">source = arguments[i]; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">source) { </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } </span><span class="s2">return </span><span class="s1">target; }; </span><span class="s2">return </span><span class="s1">_extends.apply(</span><span class="s2">this</span><span class="s1">, arguments); }</span>
<span class="s1">const GestureHandlerWrapper = _GestureHandler.GestureHandlerRootView ?? _reactNative.View;</span>

<span class="s4">/** 
 * Compare two arrays with primitive values as the content. 
 * We need to make sure that both values and order match. 
 */</span>
<span class="s1">const isArrayEqual = (a, b) =&gt; a.length === b.length &amp;&amp; a.every((it, index) =&gt; it === b[index]);</span>
<span class="s1">class StackView extends React.Component {</span>
  <span class="s1">static getDerivedStateFromProps(props, state) {</span>
    <span class="s4">// If there was no change in routes, we don't need to compute anything</span>
    <span class="s2">if </span><span class="s1">((props.state.routes === state.previousRoutes || isArrayEqual(props.state.routes.map(r =&gt; r.key), state.previousRoutes.map(r =&gt; r.key))) &amp;&amp; state.routes.length) {</span>
      <span class="s1">let routes = state.routes;</span>
      <span class="s1">let previousRoutes = state.previousRoutes;</span>
      <span class="s1">let descriptors = props.descriptors;</span>
      <span class="s1">let previousDescriptors = state.previousDescriptors;</span>
      <span class="s2">if </span><span class="s1">(props.descriptors !== state.previousDescriptors) {</span>
        <span class="s1">descriptors = state.routes.reduce((acc, route) =&gt; {</span>
          <span class="s1">acc[route.key] = props.descriptors[route.key] || state.descriptors[route.key];</span>
          <span class="s2">return </span><span class="s1">acc;</span>
        <span class="s1">}, {});</span>
        <span class="s1">previousDescriptors = props.descriptors;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(props.state.routes !== state.previousRoutes) {</span>
        <span class="s4">// if any route objects have changed, we should update them</span>
        <span class="s1">const map = props.state.routes.reduce((acc, route) =&gt; {</span>
          <span class="s1">acc[route.key] = route;</span>
          <span class="s2">return </span><span class="s1">acc;</span>
        <span class="s1">}, {});</span>
        <span class="s1">routes = state.routes.map(route =&gt; map[route.key] || route);</span>
        <span class="s1">previousRoutes = props.state.routes;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">routes,</span>
        <span class="s1">previousRoutes,</span>
        <span class="s1">descriptors,</span>
        <span class="s1">previousDescriptors</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s4">// Here we determine which routes were added or removed to animate them</span>
    <span class="s4">// We keep a copy of the route being removed in local state to be able to animate it</span>

    <span class="s1">let routes = props.state.index &lt; props.state.routes.length - </span><span class="s3">1 </span><span class="s1">?</span>
    <span class="s4">// Remove any extra routes from the state</span>
    <span class="s4">// The last visible route should be the focused route, i.e. at current index</span>
    <span class="s1">props.state.routes.slice(</span><span class="s3">0</span><span class="s1">, props.state.index + </span><span class="s3">1</span><span class="s1">) : props.state.routes;</span>

    <span class="s4">// Now we need to determine which routes were added and removed</span>
    <span class="s1">let {</span>
      <span class="s1">openingRouteKeys,</span>
      <span class="s1">closingRouteKeys,</span>
      <span class="s1">replacingRouteKeys,</span>
      <span class="s1">previousRoutes</span>
    <span class="s1">} = state;</span>
    <span class="s1">const previousFocusedRoute = previousRoutes[previousRoutes.length - </span><span class="s3">1</span><span class="s1">];</span>
    <span class="s1">const nextFocusedRoute = routes[routes.length - </span><span class="s3">1</span><span class="s1">];</span>
    <span class="s1">const isAnimationEnabled = key =&gt; {</span>
      <span class="s1">const descriptor = props.descriptors[key] || state.descriptors[key];</span>
      <span class="s2">return </span><span class="s1">descriptor ? descriptor.options.animationEnabled !== </span><span class="s2">false </span><span class="s1">: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s1">const getAnimationTypeForReplace = key =&gt; {</span>
      <span class="s1">const descriptor = props.descriptors[key] || state.descriptors[key];</span>
      <span class="s2">return </span><span class="s1">descriptor.options.animationTypeForReplace ?? </span><span class="s0">'push'</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">if </span><span class="s1">(previousFocusedRoute &amp;&amp; previousFocusedRoute.key !== nextFocusedRoute.key) {</span>
      <span class="s4">// We only need to animate routes if the focused route changed</span>
      <span class="s4">// Animating previous routes won't be visible coz the focused route is on top of everything</span>

      <span class="s2">if </span><span class="s1">(!previousRoutes.some(r =&gt; r.key === nextFocusedRoute.key)) {</span>
        <span class="s4">// A new route has come to the focus, we treat this as a push</span>
        <span class="s4">// A replace can also trigger this, the animation should look like push</span>

        <span class="s2">if </span><span class="s1">(isAnimationEnabled(nextFocusedRoute.key) &amp;&amp; !openingRouteKeys.includes(nextFocusedRoute.key)) {</span>
          <span class="s4">// In this case, we need to animate pushing the focused route</span>
          <span class="s4">// We don't care about animating any other added routes because they won't be visible</span>
          <span class="s1">openingRouteKeys = [...openingRouteKeys, nextFocusedRoute.key];</span>
          <span class="s1">closingRouteKeys = closingRouteKeys.filter(key =&gt; key !== nextFocusedRoute.key);</span>
          <span class="s1">replacingRouteKeys = replacingRouteKeys.filter(key =&gt; key !== nextFocusedRoute.key);</span>
          <span class="s2">if </span><span class="s1">(!routes.some(r =&gt; r.key === previousFocusedRoute.key)) {</span>
            <span class="s4">// The previous focused route isn't present in state, we treat this as a replace</span>

            <span class="s1">openingRouteKeys = openingRouteKeys.filter(key =&gt; key !== previousFocusedRoute.key);</span>
            <span class="s2">if </span><span class="s1">(getAnimationTypeForReplace(nextFocusedRoute.key) === </span><span class="s0">'pop'</span><span class="s1">) {</span>
              <span class="s1">closingRouteKeys = [...closingRouteKeys, previousFocusedRoute.key];</span>

              <span class="s4">// By default, new routes have a push animation, so we add it to `openingRouteKeys` before</span>
              <span class="s4">// But since user configured it to animate the old screen like a pop, we need to add this without animation</span>
              <span class="s4">// So remove it from `openingRouteKeys` which will remove the animation</span>
              <span class="s1">openingRouteKeys = openingRouteKeys.filter(key =&gt; key !== nextFocusedRoute.key);</span>

              <span class="s4">// Keep the route being removed at the end to animate it out</span>
              <span class="s1">routes = [...routes, previousFocusedRoute];</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">replacingRouteKeys = [...replacingRouteKeys, previousFocusedRoute.key];</span>
              <span class="s1">closingRouteKeys = closingRouteKeys.filter(key =&gt; key !== previousFocusedRoute.key);</span>

              <span class="s4">// Keep the old route in the state because it's visible under the new route, and removing it will feel abrupt</span>
              <span class="s4">// We need to insert it just before the focused one (the route being pushed)</span>
              <span class="s4">// After the push animation is completed, routes being replaced will be removed completely</span>
              <span class="s1">routes = routes.slice();</span>
              <span class="s1">routes.splice(routes.length - </span><span class="s3">1</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, previousFocusedRoute);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!routes.some(r =&gt; r.key === previousFocusedRoute.key)) {</span>
        <span class="s4">// The previously focused route was removed, we treat this as a pop</span>

        <span class="s2">if </span><span class="s1">(isAnimationEnabled(previousFocusedRoute.key) &amp;&amp; !closingRouteKeys.includes(previousFocusedRoute.key)) {</span>
          <span class="s1">closingRouteKeys = [...closingRouteKeys, previousFocusedRoute.key];</span>

          <span class="s4">// Sometimes a route can be closed before the opening animation finishes</span>
          <span class="s4">// So we also need to remove it from the opening list</span>
          <span class="s1">openingRouteKeys = openingRouteKeys.filter(key =&gt; key !== previousFocusedRoute.key);</span>
          <span class="s1">replacingRouteKeys = replacingRouteKeys.filter(key =&gt; key !== previousFocusedRoute.key);</span>

          <span class="s4">// Keep a copy of route being removed in the state to be able to animate it</span>
          <span class="s1">routes = [...routes, previousFocusedRoute];</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s4">// Looks like some routes were re-arranged and no focused routes were added/removed</span>
        <span class="s4">// i.e. the currently focused route already existed and the previously focused route still exists</span>
        <span class="s4">// We don't know how to animate this</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(replacingRouteKeys.length || closingRouteKeys.length) {</span>
      <span class="s4">// Keep the routes we are closing or replacing if animation is enabled for them</span>
      <span class="s1">routes = routes.slice();</span>
      <span class="s1">routes.splice(routes.length - </span><span class="s3">1</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, ...state.routes.filter(_ref =&gt; {</span>
        <span class="s1">let {</span>
          <span class="s1">key</span>
        <span class="s1">} = _ref;</span>
        <span class="s2">return </span><span class="s1">isAnimationEnabled(key) ? replacingRouteKeys.includes(key) || closingRouteKeys.includes(key) : </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}));</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!routes.length) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'There should always be at least one route in the navigation state.'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">const descriptors = routes.reduce((acc, route) =&gt; {</span>
      <span class="s1">acc[route.key] = props.descriptors[route.key] || state.descriptors[route.key];</span>
      <span class="s2">return </span><span class="s1">acc;</span>
    <span class="s1">}, {});</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">routes,</span>
      <span class="s1">previousRoutes: props.state.routes,</span>
      <span class="s1">previousDescriptors: props.descriptors,</span>
      <span class="s1">openingRouteKeys,</span>
      <span class="s1">closingRouteKeys,</span>
      <span class="s1">replacingRouteKeys,</span>
      <span class="s1">descriptors</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s1">state = {</span>
    <span class="s1">routes: [],</span>
    <span class="s1">previousRoutes: [],</span>
    <span class="s1">previousDescriptors: {},</span>
    <span class="s1">openingRouteKeys: [],</span>
    <span class="s1">closingRouteKeys: [],</span>
    <span class="s1">replacingRouteKeys: [],</span>
    <span class="s1">descriptors: {}</span>
  <span class="s1">};</span>
  <span class="s1">getPreviousRoute = _ref2 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref2;</span>
    <span class="s1">const {</span>
      <span class="s1">closingRouteKeys,</span>
      <span class="s1">replacingRouteKeys</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s1">const routes = </span><span class="s2">this</span><span class="s1">.state.routes.filter(r =&gt; r.key === route.key || !closingRouteKeys.includes(r.key) &amp;&amp; !replacingRouteKeys.includes(r.key));</span>
    <span class="s1">const index = routes.findIndex(r =&gt; r.key === route.key);</span>
    <span class="s2">return </span><span class="s1">routes[index - </span><span class="s3">1</span><span class="s1">];</span>
  <span class="s1">};</span>
  <span class="s1">renderScene = _ref3 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref3;</span>
    <span class="s1">const descriptor = </span><span class="s2">this</span><span class="s1">.state.descriptors[route.key] || </span><span class="s2">this</span><span class="s1">.props.descriptors[route.key];</span>
    <span class="s2">if </span><span class="s1">(!descriptor) {</span>
      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">descriptor.render();</span>
  <span class="s1">};</span>
  <span class="s1">renderHeader = props =&gt; {</span>
    <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_HeaderContainer.</span><span class="s2">default</span><span class="s1">, props);</span>
  <span class="s1">};</span>
  <span class="s1">handleOpenRoute = _ref4 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref4;</span>
    <span class="s1">const {</span>
      <span class="s1">state,</span>
      <span class="s1">navigation</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s1">const {</span>
      <span class="s1">closingRouteKeys,</span>
      <span class="s1">replacingRouteKeys</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">if </span><span class="s1">(closingRouteKeys.some(key =&gt; key === route.key) &amp;&amp; replacingRouteKeys.every(key =&gt; key !== route.key) &amp;&amp; state.routeNames.includes(route.name) &amp;&amp; !state.routes.some(r =&gt; r.key === route.key)) {</span>
      <span class="s4">// If route isn't present in current state, but was closing, assume that a close animation was cancelled</span>
      <span class="s4">// So we need to add this route back to the state</span>
      <span class="s1">navigation.navigate(route);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.setState(state =&gt; ({</span>
        <span class="s1">routes: state.replacingRouteKeys.length ? state.routes.filter(r =&gt; !state.replacingRouteKeys.includes(r.key)) : state.routes,</span>
        <span class="s1">openingRouteKeys: state.openingRouteKeys.filter(key =&gt; key !== route.key),</span>
        <span class="s1">closingRouteKeys: state.closingRouteKeys.filter(key =&gt; key !== route.key),</span>
        <span class="s1">replacingRouteKeys: []</span>
      <span class="s1">}));</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">handleCloseRoute = _ref5 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref5;</span>
    <span class="s1">const {</span>
      <span class="s1">state,</span>
      <span class="s1">navigation</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s2">if </span><span class="s1">(state.routes.some(r =&gt; r.key === route.key)) {</span>
      <span class="s4">// If a route exists in state, trigger a pop</span>
      <span class="s4">// This will happen in when the route was closed from the card component</span>
      <span class="s4">// e.g. When the close animation triggered from a gesture ends</span>
      <span class="s1">navigation.dispatch({</span>
        <span class="s1">..._native.StackActions.pop(),</span>
        <span class="s1">source: route.key,</span>
        <span class="s1">target: state.key</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s4">// We need to clean up any state tracking the route and pop it immediately</span>
      <span class="s2">this</span><span class="s1">.setState(state =&gt; ({</span>
        <span class="s1">routes: state.routes.filter(r =&gt; r.key !== route.key),</span>
        <span class="s1">openingRouteKeys: state.openingRouteKeys.filter(key =&gt; key !== route.key),</span>
        <span class="s1">closingRouteKeys: state.closingRouteKeys.filter(key =&gt; key !== route.key)</span>
      <span class="s1">}));</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s1">handleTransitionStart = (_ref6, closing) =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref6;</span>
    <span class="s2">return this</span><span class="s1">.props.navigation.emit({</span>
      <span class="s1">type: </span><span class="s0">'transitionStart'</span><span class="s1">,</span>
      <span class="s1">data: {</span>
        <span class="s1">closing</span>
      <span class="s1">},</span>
      <span class="s1">target: route.key</span>
    <span class="s1">});</span>
  <span class="s1">};</span>
  <span class="s1">handleTransitionEnd = (_ref7, closing) =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref7;</span>
    <span class="s2">return this</span><span class="s1">.props.navigation.emit({</span>
      <span class="s1">type: </span><span class="s0">'transitionEnd'</span><span class="s1">,</span>
      <span class="s1">data: {</span>
        <span class="s1">closing</span>
      <span class="s1">},</span>
      <span class="s1">target: route.key</span>
    <span class="s1">});</span>
  <span class="s1">};</span>
  <span class="s1">handleGestureStart = _ref8 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref8;</span>
    <span class="s2">this</span><span class="s1">.props.navigation.emit({</span>
      <span class="s1">type: </span><span class="s0">'gestureStart'</span><span class="s1">,</span>
      <span class="s1">target: route.key</span>
    <span class="s1">});</span>
  <span class="s1">};</span>
  <span class="s1">handleGestureEnd = _ref9 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref9;</span>
    <span class="s2">this</span><span class="s1">.props.navigation.emit({</span>
      <span class="s1">type: </span><span class="s0">'gestureEnd'</span><span class="s1">,</span>
      <span class="s1">target: route.key</span>
    <span class="s1">});</span>
  <span class="s1">};</span>
  <span class="s1">handleGestureCancel = _ref10 =&gt; {</span>
    <span class="s1">let {</span>
      <span class="s1">route</span>
    <span class="s1">} = _ref10;</span>
    <span class="s2">this</span><span class="s1">.props.navigation.emit({</span>
      <span class="s1">type: </span><span class="s0">'gestureCancel'</span><span class="s1">,</span>
      <span class="s1">target: route.key</span>
    <span class="s1">});</span>
  <span class="s1">};</span>
  <span class="s1">render() {</span>
    <span class="s1">const {</span>
      <span class="s1">state,</span>
      <span class="s4">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span>
      <span class="s1">descriptors: _,</span>
      <span class="s1">...rest</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>
    <span class="s1">const {</span>
      <span class="s1">routes,</span>
      <span class="s1">descriptors,</span>
      <span class="s1">openingRouteKeys,</span>
      <span class="s1">closingRouteKeys</span>
    <span class="s1">} = </span><span class="s2">this</span><span class="s1">.state;</span>
    <span class="s2">return </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(GestureHandlerWrapper, {</span>
      <span class="s1">style: styles.container</span>
    <span class="s1">}, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_elements.SafeAreaProviderCompat, </span><span class="s2">null</span><span class="s1">, </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_reactNativeSafeAreaContext.SafeAreaInsetsContext.Consumer, </span><span class="s2">null</span><span class="s1">, insets =&gt; </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_ModalPresentationContext.</span><span class="s2">default</span><span class="s1">.Consumer, </span><span class="s2">null</span><span class="s1">, isParentModal =&gt; </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_elements.HeaderShownContext.Consumer, </span><span class="s2">null</span><span class="s1">, isParentHeaderShown =&gt; </span><span class="s4">/*#__PURE__*/</span><span class="s1">React.createElement(_CardStack.</span><span class="s2">default</span><span class="s1">, _extends({</span>
      <span class="s1">insets: insets,</span>
      <span class="s1">isParentHeaderShown: isParentHeaderShown,</span>
      <span class="s1">isParentModal: isParentModal,</span>
      <span class="s1">getPreviousRoute: </span><span class="s2">this</span><span class="s1">.getPreviousRoute,</span>
      <span class="s1">routes: routes,</span>
      <span class="s1">openingRouteKeys: openingRouteKeys,</span>
      <span class="s1">closingRouteKeys: closingRouteKeys,</span>
      <span class="s1">onOpenRoute: </span><span class="s2">this</span><span class="s1">.handleOpenRoute,</span>
      <span class="s1">onCloseRoute: </span><span class="s2">this</span><span class="s1">.handleCloseRoute,</span>
      <span class="s1">onTransitionStart: </span><span class="s2">this</span><span class="s1">.handleTransitionStart,</span>
      <span class="s1">onTransitionEnd: </span><span class="s2">this</span><span class="s1">.handleTransitionEnd,</span>
      <span class="s1">renderHeader: </span><span class="s2">this</span><span class="s1">.renderHeader,</span>
      <span class="s1">renderScene: </span><span class="s2">this</span><span class="s1">.renderScene,</span>
      <span class="s1">state: state,</span>
      <span class="s1">descriptors: descriptors,</span>
      <span class="s1">onGestureStart: </span><span class="s2">this</span><span class="s1">.handleGestureStart,</span>
      <span class="s1">onGestureEnd: </span><span class="s2">this</span><span class="s1">.handleGestureEnd,</span>
      <span class="s1">onGestureCancel: </span><span class="s2">this</span><span class="s1">.handleGestureCancel</span>
    <span class="s1">}, rest)))))));</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= StackView;</span>
<span class="s1">const styles = _reactNative.StyleSheet.create({</span>
  <span class="s1">container: {</span>
    <span class="s1">flex: </span><span class="s3">1</span>
  <span class="s1">}</span>
<span class="s1">});</span>
<span class="s4">//# sourceMappingURL=StackView.js.map</span></pre>
</body>
</html>
<html>
<head>
<title>joi-browser.min.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #4646f1;}
.s5 { color: #6a8759;}
.s6 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
joi-browser.min.js</font>
</center></td></tr></table>
<pre><span class="s0">!</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">exports&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">module?module.exports=t():</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">define&amp;&amp;define.amd?define([],t):</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">exports?exports.joi=t():e.joi=t()}(self,(()=&gt;{</span><span class="s1">return </span><span class="s0">e={</span><span class="s3">7629</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">9474</span><span class="s0">),i=r(</span><span class="s3">1687</span><span class="s0">),o=r(</span><span class="s3">8652</span><span class="s0">),l=r(</span><span class="s3">8160</span><span class="s0">),c=r(</span><span class="s3">3292</span><span class="s0">),u=r(</span><span class="s3">6354</span><span class="s0">),f=r(</span><span class="s3">8901</span><span class="s0">),h=r(</span><span class="s3">9708</span><span class="s0">),m=r(</span><span class="s3">6914</span><span class="s0">),d=r(</span><span class="s3">2294</span><span class="s0">),p=r(</span><span class="s3">6133</span><span class="s0">),g=r(</span><span class="s3">1152</span><span class="s0">),y=r(</span><span class="s3">8863</span><span class="s0">),b=r(</span><span class="s3">2036</span><span class="s0">),v={Base:class{constructor(e){</span><span class="s1">this</span><span class="s0">.type=e,</span><span class="s1">this</span><span class="s0">.$_root=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._definition={},</span><span class="s1">this</span><span class="s0">._reset()}_reset(){</span><span class="s1">this</span><span class="s0">._ids=</span><span class="s1">new </span><span class="s0">d.Ids,</span><span class="s1">this</span><span class="s0">._preferences=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._refs=</span><span class="s1">new </span><span class="s0">p.Manager,</span><span class="s1">this</span><span class="s0">._cache=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._valids=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._invalids=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._flags={},</span><span class="s1">this</span><span class="s0">._rules=[],</span><span class="s1">this</span><span class="s0">._singleRules=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.$_terms={},</span><span class="s1">this</span><span class="s0">.$_temp={ruleset:</span><span class="s1">null</span><span class="s0">,whens:{}}}describe(){</span><span class="s1">return </span><span class="s0">s(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">h.describe,</span><span class="s2">&quot;Manifest functionality disabled&quot;</span><span class="s0">),h.describe(</span><span class="s1">this</span><span class="s0">)}allow(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return </span><span class="s0">l.verifyFlat(t,</span><span class="s2">&quot;allow&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">._values(t,</span><span class="s2">&quot;_valids&quot;</span><span class="s0">)}alter(e){s(e&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;!Array.isArray(e),</span><span class="s2">&quot;Invalid targets argument&quot;</span><span class="s0">),s(!</span><span class="s1">this</span><span class="s0">._inRuleset(),</span><span class="s2">&quot;Cannot set alterations inside a ruleset&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.clone();t.$_terms.alterations=t.$_terms.alterations||[];</span><span class="s1">for</span><span class="s0">(const r </span><span class="s1">in </span><span class="s0">e){const n=e[r];s(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n,</span><span class="s2">&quot;Alteration adjuster for&quot;</span><span class="s0">,r,</span><span class="s2">&quot;must be a function&quot;</span><span class="s0">),t.$_terms.alterations.push({target:r,adjuster:n})}</span><span class="s1">return </span><span class="s0">t.$_temp.ruleset=!</span><span class="s3">1</span><span class="s0">,t}artifact(e){</span><span class="s1">return </span><span class="s0">s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e,</span><span class="s2">&quot;Artifact cannot be undefined&quot;</span><span class="s0">),s(!</span><span class="s1">this</span><span class="s0">._cache,</span><span class="s2">&quot;Cannot set an artifact with a rule cache&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;artifact&quot;</span><span class="s0">,e)}cast(e){</span><span class="s1">return </span><span class="s0">s(!</span><span class="s3">1</span><span class="s0">===e||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid to value&quot;</span><span class="s0">),s(!</span><span class="s3">1</span><span class="s0">===e||</span><span class="s1">this</span><span class="s0">._definition.cast[e],</span><span class="s2">&quot;Type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type,</span><span class="s2">&quot;does not support casting to&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;cast&quot;</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">===e?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e)}</span><span class="s1">default</span><span class="s0">(e,t){</span><span class="s1">return this</span><span class="s0">._default(</span><span class="s2">&quot;default&quot;</span><span class="s0">,e,t)}description(e){</span><span class="s1">return </span><span class="s0">s(e&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Description must be a non-empty string&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;description&quot;</span><span class="s0">,e)}empty(e){const t=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;(e=t.$_compile(e,{override:!</span><span class="s3">1</span><span class="s0">})),t.$_setFlag(</span><span class="s2">&quot;empty&quot;</span><span class="s0">,e,{clone:!</span><span class="s3">1</span><span class="s0">})}error(e){</span><span class="s1">return </span><span class="s0">s(e,</span><span class="s2">&quot;Missing error&quot;</span><span class="s0">),s(e </span><span class="s1">instanceof </span><span class="s0">Error||</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Must provide a valid Error object or a function&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;error&quot;</span><span class="s0">,e)}example(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e,</span><span class="s2">&quot;Missing example&quot;</span><span class="s0">),l.assertOptions(t,[</span><span class="s2">&quot;override&quot;</span><span class="s0">]),</span><span class="s1">this</span><span class="s0">._inner(</span><span class="s2">&quot;examples&quot;</span><span class="s0">,e,{single:!</span><span class="s3">0</span><span class="s0">,override:t.override})}external(e,t){</span><span class="s1">return</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(s(!t,</span><span class="s2">&quot;Cannot combine options with description&quot;</span><span class="s0">),t=e.description,e=e.method),s(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Method must be a function&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t||t&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,</span><span class="s2">&quot;Description must be a non-empty string&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">._inner(</span><span class="s2">&quot;externals&quot;</span><span class="s0">,{method:e,description:t},{single:!</span><span class="s3">0</span><span class="s0">})}failover(e,t){</span><span class="s1">return this</span><span class="s0">._default(</span><span class="s2">&quot;failover&quot;</span><span class="s0">,e,t)}forbidden(){</span><span class="s1">return this</span><span class="s0">.presence(</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">)}id(e){</span><span class="s1">return </span><span class="s0">e?(s(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;id must be a non-empty string&quot;</span><span class="s0">),s(/^[^\.]+$/.test(e),</span><span class="s2">&quot;id cannot contain period character&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;id&quot;</span><span class="s0">,e)):</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;id&quot;</span><span class="s0">,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}invalid(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return this</span><span class="s0">._values(t,</span><span class="s2">&quot;_invalids&quot;</span><span class="s0">)}label(e){</span><span class="s1">return </span><span class="s0">s(e&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Label name must be a non-empty string&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;label&quot;</span><span class="s0">,e)}meta(e){</span><span class="s1">return </span><span class="s0">s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e,</span><span class="s2">&quot;Meta cannot be undefined&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">._inner(</span><span class="s2">&quot;metas&quot;</span><span class="s0">,e,{single:!</span><span class="s3">0</span><span class="s0">})}note(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];s(t.length,</span><span class="s2">&quot;Missing notes&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of t)s(e&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Notes must be non-empty strings&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">._inner(</span><span class="s2">&quot;notes&quot;</span><span class="s0">,t)}only(){let e=!(arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">])||arguments[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">s(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid mode:&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;only&quot;</span><span class="s0">,e)}optional(){</span><span class="s1">return this</span><span class="s0">.presence(</span><span class="s2">&quot;optional&quot;</span><span class="s0">)}prefs(e){s(e,</span><span class="s2">&quot;Missing preferences&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.context,</span><span class="s2">&quot;Cannot override context&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.externals,</span><span class="s2">&quot;Cannot override externals&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.warnings,</span><span class="s2">&quot;Cannot override warnings&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.debug,</span><span class="s2">&quot;Cannot override debug&quot;</span><span class="s0">),l.checkPreferences(e);const t=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return </span><span class="s0">t._preferences=l.preferences(t._preferences,e),t}presence(e){</span><span class="s1">return </span><span class="s0">s([</span><span class="s2">&quot;optional&quot;</span><span class="s0">,</span><span class="s2">&quot;required&quot;</span><span class="s0">,</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">].includes(e),</span><span class="s2">&quot;Unknown presence mode&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;presence&quot;</span><span class="s0">,e)}raw(){let e=!(arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">])||arguments[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;result&quot;</span><span class="s0">,e?</span><span class="s2">&quot;raw&quot;</span><span class="s0">:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}result(e){</span><span class="s1">return </span><span class="s0">s([</span><span class="s2">&quot;raw&quot;</span><span class="s0">,</span><span class="s2">&quot;strip&quot;</span><span class="s0">].includes(e),</span><span class="s2">&quot;Unknown result mode&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;result&quot;</span><span class="s0">,e)}required(){</span><span class="s1">return this</span><span class="s0">.presence(</span><span class="s2">&quot;required&quot;</span><span class="s0">)}strict(e){const t=</span><span class="s1">this</span><span class="s0">.clone(),r=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;!e;</span><span class="s1">return </span><span class="s0">t._preferences=l.preferences(t._preferences,{convert:r}),t}strip(){let e=!(arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">])||arguments[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;result&quot;</span><span class="s0">,e?</span><span class="s2">&quot;strip&quot;</span><span class="s0">:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}tag(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];s(t.length,</span><span class="s2">&quot;Missing tags&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of t)s(e&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Tags must be non-empty strings&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">._inner(</span><span class="s2">&quot;tags&quot;</span><span class="s0">,t)}unit(e){</span><span class="s1">return </span><span class="s0">s(e&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Unit name must be a non-empty string&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;unit&quot;</span><span class="s0">,e)}valid(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];l.verifyFlat(t,</span><span class="s2">&quot;valid&quot;</span><span class="s0">);const s=</span><span class="s1">this</span><span class="s0">.allow(...t);</span><span class="s1">return </span><span class="s0">s.$_setFlag(</span><span class="s2">&quot;only&quot;</span><span class="s0">,!!s._valids,{clone:!</span><span class="s3">1</span><span class="s0">}),s}when(e,t){const r=</span><span class="s1">this</span><span class="s0">.clone();r.$_terms.whens||(r.$_terms.whens=[]);const n=c.when(r,e,t);</span><span class="s1">if</span><span class="s0">(![</span><span class="s2">&quot;any&quot;</span><span class="s0">,</span><span class="s2">&quot;link&quot;</span><span class="s0">].includes(r.type)){const e=n.is?[n]:n.</span><span class="s1">switch</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const t of e)s(!t.then||</span><span class="s2">&quot;any&quot;</span><span class="s0">===t.then.type||t.then.type===r.type,</span><span class="s2">&quot;Cannot combine&quot;</span><span class="s0">,r.type,</span><span class="s2">&quot;with&quot;</span><span class="s0">,t.then&amp;&amp;t.then.type),s(!t.otherwise||</span><span class="s2">&quot;any&quot;</span><span class="s0">===t.otherwise.type||t.otherwise.type===r.type,</span><span class="s2">&quot;Cannot combine&quot;</span><span class="s0">,r.type,</span><span class="s2">&quot;with&quot;</span><span class="s0">,t.otherwise&amp;&amp;t.otherwise.type)}</span><span class="s1">return </span><span class="s0">r.$_terms.whens.push(n),r.$_mutateRebuild()}cache(e){s(!</span><span class="s1">this</span><span class="s0">._inRuleset(),</span><span class="s2">&quot;Cannot set caching inside a ruleset&quot;</span><span class="s0">),s(!</span><span class="s1">this</span><span class="s0">._cache,</span><span class="s2">&quot;Cannot override schema cache&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">._flags.artifact,</span><span class="s2">&quot;Cannot cache a rule with an artifact&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return </span><span class="s0">t._cache=e||o.provider.provision(),t.$_temp.ruleset=!</span><span class="s3">1</span><span class="s0">,t}clone(){const e=Object.create(Object.getPrototypeOf(</span><span class="s1">this</span><span class="s0">));</span><span class="s1">return this</span><span class="s0">._assign(e)}concat(e){s(l.isSchema(e),</span><span class="s2">&quot;Invalid schema object&quot;</span><span class="s0">),s(</span><span class="s2">&quot;any&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type||</span><span class="s2">&quot;any&quot;</span><span class="s0">===e.type||e.type===</span><span class="s1">this</span><span class="s0">.type,</span><span class="s2">&quot;Cannot merge type&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type,</span><span class="s2">&quot;with another type:&quot;</span><span class="s0">,e.type),s(!</span><span class="s1">this</span><span class="s0">._inRuleset(),</span><span class="s2">&quot;Cannot concatenate onto a schema with open ruleset&quot;</span><span class="s0">),s(!e._inRuleset(),</span><span class="s2">&quot;Cannot concatenate a schema with open ruleset&quot;</span><span class="s0">);let t=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;any&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type&amp;&amp;</span><span class="s2">&quot;any&quot;</span><span class="s0">!==e.type){const r=e.clone();</span><span class="s1">for</span><span class="s0">(const e of Object.keys(t))</span><span class="s2">&quot;type&quot;</span><span class="s0">!==e&amp;&amp;(r[e]=t[e]);t=r}t._ids.concat(e._ids),t._refs.register(e,p.toSibling),t._preferences=t._preferences?l.preferences(t._preferences,e._preferences):e._preferences,t._valids=b.merge(t._valids,e._valids,e._invalids),t._invalids=b.merge(t._invalids,e._invalids,e._valids);</span><span class="s1">for</span><span class="s0">(const r of e._singleRules.keys())t._singleRules.has(r)&amp;&amp;(t._rules=t._rules.filter((e=&gt;e.keep||e.name!==r)),t._singleRules.</span><span class="s1">delete</span><span class="s0">(r));</span><span class="s1">for</span><span class="s0">(const r of e._rules)e._definition.rules[r.method].multi||t._singleRules.set(r.name,r),t._rules.push(r);</span><span class="s1">if</span><span class="s0">(t._flags.empty&amp;&amp;e._flags.empty){t._flags.empty=t._flags.empty.concat(e._flags.empty);const r=Object.assign({},e._flags);</span><span class="s1">delete </span><span class="s0">r.empty,i(t._flags,r)}</span><span class="s1">else if</span><span class="s0">(e._flags.empty){t._flags.empty=e._flags.empty;const r=Object.assign({},e._flags);</span><span class="s1">delete </span><span class="s0">r.empty,i(t._flags,r)}</span><span class="s1">else </span><span class="s0">i(t._flags,e._flags);</span><span class="s1">for</span><span class="s0">(const r </span><span class="s1">in </span><span class="s0">e.$_terms){const s=e.$_terms[r];s?t.$_terms[r]?t.$_terms[r]=t.$_terms[r].concat(s):t.$_terms[r]=s.slice():t.$_terms[r]||(t.$_terms[r]=s)}</span><span class="s1">return this</span><span class="s0">.$_root._tracer&amp;&amp;</span><span class="s1">this</span><span class="s0">.$_root._tracer._combine(t,[</span><span class="s1">this</span><span class="s0">,e]),t.$_mutateRebuild()}extend(e){</span><span class="s1">return </span><span class="s0">s(!e.base,</span><span class="s2">&quot;Cannot extend type with another base&quot;</span><span class="s0">),f.type(</span><span class="s1">this</span><span class="s0">,e)}extract(e){</span><span class="s1">return </span><span class="s0">e=Array.isArray(e)?e:e.split(</span><span class="s2">&quot;.&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">._ids.reach(e)}fork(e,t){s(!</span><span class="s1">this</span><span class="s0">._inRuleset(),</span><span class="s2">&quot;Cannot fork inside a ruleset&quot;</span><span class="s0">);let r=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let s of[].concat(e))s=Array.isArray(s)?s:s.split(</span><span class="s2">&quot;.&quot;</span><span class="s0">),r=r._ids.fork(s,t,r);</span><span class="s1">return </span><span class="s0">r.$_temp.ruleset=!</span><span class="s3">1</span><span class="s0">,r}rule(e){const t=</span><span class="s1">this</span><span class="s0">._definition;l.assertOptions(e,Object.keys(t.modifiers)),s(!</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.$_temp.ruleset,</span><span class="s2">&quot;Cannot apply rules to empty ruleset or the last rule added does not support rule properties&quot;</span><span class="s0">);const r=</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.$_temp.ruleset?</span><span class="s1">this</span><span class="s0">._rules.length-1:</span><span class="s1">this</span><span class="s0">.$_temp.ruleset;s(r&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;r&lt;</span><span class="s1">this</span><span class="s0">._rules.length,</span><span class="s2">&quot;Cannot apply rules to empty ruleset&quot;</span><span class="s0">);const a=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">for</span><span class="s0">(let i=r;i&lt;a._rules.length;++i){const r=a._rules[i],o=n(r);</span><span class="s1">for</span><span class="s0">(const n </span><span class="s1">in </span><span class="s0">e)t.modifiers[n](o,e[n]),s(o.name===r.name,</span><span class="s2">&quot;Cannot change rule name&quot;</span><span class="s0">);a._rules[i]=o,a._singleRules.get(o.name)===r&amp;&amp;a._singleRules.set(o.name,o)}</span><span class="s1">return </span><span class="s0">a.$_temp.ruleset=!</span><span class="s3">1</span><span class="s0">,a.$_mutateRebuild()}get ruleset(){s(!</span><span class="s1">this</span><span class="s0">._inRuleset(),</span><span class="s2">&quot;Cannot start a new ruleset without closing the previous one&quot;</span><span class="s0">);const e=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return </span><span class="s0">e.$_temp.ruleset=e._rules.length,e}get $(){</span><span class="s1">return this</span><span class="s0">.ruleset}tailor(e){e=[].concat(e),s(!</span><span class="s1">this</span><span class="s0">._inRuleset(),</span><span class="s2">&quot;Cannot tailor inside a ruleset&quot;</span><span class="s0">);let t=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.$_terms.alterations)</span><span class="s1">for</span><span class="s0">(const{target:r,adjuster:n}of </span><span class="s1">this</span><span class="s0">.$_terms.alterations)e.includes(r)&amp;&amp;(t=n(t),s(l.isSchema(t),</span><span class="s2">&quot;Alteration adjuster for&quot;</span><span class="s0">,r,</span><span class="s2">&quot;failed to return a schema object&quot;</span><span class="s0">));</span><span class="s1">return </span><span class="s0">t=t.$_modify({each:t=&gt;t.tailor(e),ref:!</span><span class="s3">1</span><span class="s0">}),t.$_temp.ruleset=!</span><span class="s3">1</span><span class="s0">,t.$_mutateRebuild()}tracer(){</span><span class="s1">return </span><span class="s0">g.location?g.location(</span><span class="s1">this</span><span class="s0">):</span><span class="s1">this</span><span class="s0">}validate(e,t){</span><span class="s1">return </span><span class="s0">y.entry(e,</span><span class="s1">this</span><span class="s0">,t)}validateAsync(e,t){</span><span class="s1">return </span><span class="s0">y.entryAsync(e,</span><span class="s1">this</span><span class="s0">,t)}$_addRule(e){</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(e={name:e}),s(e&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid options&quot;</span><span class="s0">),s(e.name&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.name,</span><span class="s2">&quot;Invalid rule name&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const t </span><span class="s1">in </span><span class="s0">e)s(</span><span class="s2">&quot;_&quot;</span><span class="s0">!==t[</span><span class="s3">0</span><span class="s0">],</span><span class="s2">&quot;Cannot set private rule properties&quot;</span><span class="s0">);const t=Object.assign({},e);t._resolve=[],t.method=t.method||t.name;const r=</span><span class="s1">this</span><span class="s0">._definition.rules[t.method],n=t.args;s(r,</span><span class="s2">&quot;Unknown rule&quot;</span><span class="s0">,t.method);const a=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">if</span><span class="s0">(n){s(</span><span class="s3">1</span><span class="s0">===Object.keys(n).length||Object.keys(n).length===</span><span class="s1">this</span><span class="s0">._definition.rules[t.name].args.length,</span><span class="s2">&quot;Invalid rule definition for&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.type,t.name);</span><span class="s1">for</span><span class="s0">(const e </span><span class="s1">in </span><span class="s0">n){let i=n[e];</span><span class="s1">if</span><span class="s0">(r.argsByName){const o=r.argsByName.get(e);</span><span class="s1">if</span><span class="s0">(o.ref&amp;&amp;l.isResolvable(i))t._resolve.push(e),a.$_mutateRegister(i);</span><span class="s1">else if</span><span class="s0">(o.normalize&amp;&amp;(i=o.normalize(i),n[e]=i),o.assert){const t=l.validateArg(i,e,o);s(!t,t,</span><span class="s2">&quot;or reference&quot;</span><span class="s0">)}}</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==i?n[e]=i:</span><span class="s1">delete </span><span class="s0">n[e]}}</span><span class="s1">return </span><span class="s0">r.multi||(a._ruleRemove(t.name,{clone:!</span><span class="s3">1</span><span class="s0">}),a._singleRules.set(t.name,t)),!</span><span class="s3">1</span><span class="s0">===a.$_temp.ruleset&amp;&amp;(a.$_temp.ruleset=</span><span class="s1">null</span><span class="s0">),r.priority?a._rules.unshift(t):a._rules.push(t),a}$_compile(e,t){</span><span class="s1">return </span><span class="s0">c.schema(</span><span class="s1">this</span><span class="s0">.$_root,e,t)}$_createError(e,t,r,s,n){let a=arguments.length&gt;</span><span class="s3">5</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">5</span><span class="s0">]?arguments[</span><span class="s3">5</span><span class="s0">]:{};const i=!</span><span class="s3">1</span><span class="s0">!==a.flags?</span><span class="s1">this</span><span class="s0">._flags:{},o=a.messages?m.merge(</span><span class="s1">this</span><span class="s0">._definition.messages,a.messages):</span><span class="s1">this</span><span class="s0">._definition.messages;</span><span class="s1">return new </span><span class="s0">u.Report(e,t,r,i,o,s,n)}$_getFlag(e){</span><span class="s1">return this</span><span class="s0">._flags[e]}$_getRule(e){</span><span class="s1">return this</span><span class="s0">._singleRules.get(e)}$_mapLabels(e){</span><span class="s1">return </span><span class="s0">e=Array.isArray(e)?e:e.split(</span><span class="s2">&quot;.&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">._ids.labels(e)}$_match(e,t,r,s){(r=Object.assign({},r)).abortEarly=!</span><span class="s3">0</span><span class="s0">,r._externals=!</span><span class="s3">1</span><span class="s0">,t.snapshot();const n=!y.validate(e,</span><span class="s1">this</span><span class="s0">,t,r,s).errors;</span><span class="s1">return </span><span class="s0">t.restore(),n}$_modify(e){</span><span class="s1">return </span><span class="s0">l.assertOptions(e,[</span><span class="s2">&quot;each&quot;</span><span class="s0">,</span><span class="s2">&quot;once&quot;</span><span class="s0">,</span><span class="s2">&quot;ref&quot;</span><span class="s0">,</span><span class="s2">&quot;schema&quot;</span><span class="s0">]),d.schema(</span><span class="s1">this</span><span class="s0">,e)||</span><span class="s1">this</span><span class="s0">}$_mutateRebuild(){</span><span class="s1">return </span><span class="s0">s(!</span><span class="s1">this</span><span class="s0">._inRuleset(),</span><span class="s2">&quot;Cannot add this rule inside a ruleset&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">._refs.reset(),</span><span class="s1">this</span><span class="s0">._ids.reset(),</span><span class="s1">this</span><span class="s0">.$_modify({each:(e,t)=&gt;{let{source:r,name:s,path:n,key:a}=t;const i=</span><span class="s1">this</span><span class="s0">._definition[r][s]&amp;&amp;</span><span class="s1">this</span><span class="s0">._definition[r][s].register;!</span><span class="s3">1</span><span class="s0">!==i&amp;&amp;</span><span class="s1">this</span><span class="s0">.$_mutateRegister(e,{family:i,key:a})}}),</span><span class="s1">this</span><span class="s0">._definition.rebuild&amp;&amp;</span><span class="s1">this</span><span class="s0">._definition.rebuild(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_temp.ruleset=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">}$_mutateRegister(e){let{family:t,key:r}=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">this</span><span class="s0">._refs.register(e,t),</span><span class="s1">this</span><span class="s0">._ids.register(e,{key:r})}$_property(e){</span><span class="s1">return this</span><span class="s0">._definition.properties[e]}$_reach(e){</span><span class="s1">return this</span><span class="s0">._ids.reach(e)}$_rootReferences(){</span><span class="s1">return this</span><span class="s0">._refs.roots()}$_setFlag(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};s(</span><span class="s2">&quot;_&quot;</span><span class="s0">===e[</span><span class="s3">0</span><span class="s0">]||!</span><span class="s1">this</span><span class="s0">._inRuleset(),</span><span class="s2">&quot;Cannot set flag inside a ruleset&quot;</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">._definition.flags[e]||{};</span><span class="s1">if</span><span class="s0">(a(t,n.</span><span class="s1">default</span><span class="s0">)&amp;&amp;(t=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),a(t,</span><span class="s1">this</span><span class="s0">._flags[e]))</span><span class="s1">return this</span><span class="s0">;const i=!</span><span class="s3">1</span><span class="s0">!==r.clone?</span><span class="s1">this</span><span class="s0">.clone():</span><span class="s1">this</span><span class="s0">;</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">!==t?(i._flags[e]=t,i.$_mutateRegister(t)):</span><span class="s1">delete </span><span class="s0">i._flags[e],</span><span class="s2">&quot;_&quot;</span><span class="s0">!==e[</span><span class="s3">0</span><span class="s0">]&amp;&amp;(i.$_temp.ruleset=!</span><span class="s3">1</span><span class="s0">),i}$_parent(e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">t=arguments.length,r=</span><span class="s1">new </span><span class="s0">Array(t&gt;</span><span class="s3">1</span><span class="s0">?t-1:</span><span class="s3">0</span><span class="s0">),s=</span><span class="s3">1</span><span class="s0">;s&lt;t;s++)r[s-1]=arguments[s];</span><span class="s1">return this</span><span class="s0">[e][l.symbols.parent].call(</span><span class="s1">this</span><span class="s0">,...r)}$_validate(e,t,r){</span><span class="s1">return </span><span class="s0">y.validate(e,</span><span class="s1">this</span><span class="s0">,t,r)}_assign(e){e.type=</span><span class="s1">this</span><span class="s0">.type,e.$_root=</span><span class="s1">this</span><span class="s0">.$_root,e.$_temp=Object.assign({},</span><span class="s1">this</span><span class="s0">.$_temp),e.$_temp.whens={},e._ids=</span><span class="s1">this</span><span class="s0">._ids.clone(),e._preferences=</span><span class="s1">this</span><span class="s0">._preferences,e._valids=</span><span class="s1">this</span><span class="s0">._valids&amp;&amp;</span><span class="s1">this</span><span class="s0">._valids.clone(),e._invalids=</span><span class="s1">this</span><span class="s0">._invalids&amp;&amp;</span><span class="s1">this</span><span class="s0">._invalids.clone(),e._rules=</span><span class="s1">this</span><span class="s0">._rules.slice(),e._singleRules=n(</span><span class="s1">this</span><span class="s0">._singleRules,{shallow:!</span><span class="s3">0</span><span class="s0">}),e._refs=</span><span class="s1">this</span><span class="s0">._refs.clone(),e._flags=Object.assign({},</span><span class="s1">this</span><span class="s0">._flags),e._cache=</span><span class="s1">null</span><span class="s0">,e.$_terms={};</span><span class="s1">for</span><span class="s0">(const t </span><span class="s1">in this</span><span class="s0">.$_terms)e.$_terms[t]=</span><span class="s1">this</span><span class="s0">.$_terms[t]?</span><span class="s1">this</span><span class="s0">.$_terms[t].slice():</span><span class="s1">null</span><span class="s0">;e.$_super={};</span><span class="s1">for</span><span class="s0">(const t </span><span class="s1">in this</span><span class="s0">.$_super)e.$_super[t]=</span><span class="s1">this</span><span class="s0">._super[t].bind(e);</span><span class="s1">return </span><span class="s0">e}_bare(){const e=</span><span class="s1">this</span><span class="s0">.clone();e._reset();const t=e._definition.terms;</span><span class="s1">for</span><span class="s0">(const r </span><span class="s1">in </span><span class="s0">t){const s=t[r];e.$_terms[r]=s.init}</span><span class="s1">return </span><span class="s0">e.$_mutateRebuild()}_default(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">l.assertOptions(r,</span><span class="s2">&quot;literal&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t,</span><span class="s2">&quot;Missing&quot;</span><span class="s0">,e,</span><span class="s2">&quot;value&quot;</span><span class="s0">),s(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t||!r.literal,</span><span class="s2">&quot;Only function value supports literal option&quot;</span><span class="s0">),</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;r.literal&amp;&amp;(t={[l.symbols.literal]:!</span><span class="s3">0</span><span class="s0">,literal:t}),</span><span class="s1">this</span><span class="s0">.$_setFlag(e,t)}_generate(e,t,r){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.$_terms.whens)</span><span class="s1">return</span><span class="s0">{schema:</span><span class="s1">this</span><span class="s0">};const s=[],n=[];</span><span class="s1">for</span><span class="s0">(let a=</span><span class="s3">0</span><span class="s0">;a&lt;</span><span class="s1">this</span><span class="s0">.$_terms.whens.length;++a){const i=</span><span class="s1">this</span><span class="s0">.$_terms.whens[a];</span><span class="s1">if</span><span class="s0">(i.concat){s.push(i.concat),n.push(`${a}.concat`);</span><span class="s1">continue</span><span class="s0">}const o=i.ref?i.ref.resolve(e,t,r):e,l=i.is?[i]:i.</span><span class="s1">switch</span><span class="s0">,c=n.length;</span><span class="s1">for</span><span class="s0">(let c=</span><span class="s3">0</span><span class="s0">;c&lt;l.length;++c){const{is:u,then:f,otherwise:h}=l[c],m=`${a}${i.</span><span class="s1">switch</span><span class="s0">?</span><span class="s2">&quot;.&quot;</span><span class="s0">+c:</span><span class="s2">&quot;&quot;</span><span class="s0">}`;</span><span class="s1">if</span><span class="s0">(u.$_match(o,t.nest(u,`${m}.is`),r)){</span><span class="s1">if</span><span class="s0">(f){const a=t.localize([...t.path,`${m}.then`],t.ancestors,t.schemas),{schema:i,id:o}=f._generate(e,a,r);s.push(i),n.push(`${m}.then${o?`(${o})`:</span><span class="s2">&quot;&quot;</span><span class="s0">}`);</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(h){const a=t.localize([...t.path,`${m}.otherwise`],t.ancestors,t.schemas),{schema:i,id:o}=h._generate(e,a,r);s.push(i),n.push(`${m}.otherwise${o?`(${o})`:</span><span class="s2">&quot;&quot;</span><span class="s0">}`);</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(i.</span><span class="s1">break</span><span class="s0">&amp;&amp;n.length&gt;c)</span><span class="s1">break</span><span class="s0">}const a=n.join(</span><span class="s2">&quot;, &quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t.mainstay.tracer.debug(t,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,</span><span class="s2">&quot;when&quot;</span><span class="s0">,a),!a)</span><span class="s1">return</span><span class="s0">{schema:</span><span class="s1">this</span><span class="s0">};</span><span class="s1">if</span><span class="s0">(!t.mainstay.tracer.active&amp;&amp;</span><span class="s1">this</span><span class="s0">.$_temp.whens[a])</span><span class="s1">return</span><span class="s0">{schema:</span><span class="s1">this</span><span class="s0">.$_temp.whens[a],id:a};let i=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">this</span><span class="s0">._definition.generate&amp;&amp;(i=</span><span class="s1">this</span><span class="s0">._definition.generate(</span><span class="s1">this</span><span class="s0">,e,t,r));</span><span class="s1">for</span><span class="s0">(const e of s)i=i.concat(e);</span><span class="s1">return this</span><span class="s0">.$_root._tracer&amp;&amp;</span><span class="s1">this</span><span class="s0">.$_root._tracer._combine(i,[</span><span class="s1">this</span><span class="s0">,...s]),</span><span class="s1">this</span><span class="s0">.$_temp.whens[a]=i,{schema:i,id:a}}_inner(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};s(!</span><span class="s1">this</span><span class="s0">._inRuleset(),`Cannot set ${e} inside a ruleset`);const n=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return </span><span class="s0">n.$_terms[e]&amp;&amp;!r.override||(n.$_terms[e]=[]),r.single?n.$_terms[e].push(t):n.$_terms[e].push(...t),n.$_temp.ruleset=!</span><span class="s3">1</span><span class="s0">,n}_inRuleset(){</span><span class="s1">return null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.$_temp.ruleset&amp;&amp;!</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.$_temp.ruleset}_ruleRemove(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._singleRules.has(e))</span><span class="s1">return this</span><span class="s0">;const r=!</span><span class="s3">1</span><span class="s0">!==t.clone?</span><span class="s1">this</span><span class="s0">.clone():</span><span class="s1">this</span><span class="s0">;r._singleRules.</span><span class="s1">delete</span><span class="s0">(e);const s=[];</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;r._rules.length;++t){const n=r._rules[t];n.name!==e||n.keep?s.push(n):r._inRuleset()&amp;&amp;t&lt;r.$_temp.ruleset&amp;&amp;--r.$_temp.ruleset}</span><span class="s1">return </span><span class="s0">r._rules=s,r}_values(e,t){l.verifyFlat(e,t.slice(</span><span class="s3">1</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">));const r=</span><span class="s1">this</span><span class="s0">.clone(),n=e[</span><span class="s3">0</span><span class="s0">]===l.symbols.override;</span><span class="s1">if</span><span class="s0">(n&amp;&amp;(e=e.slice(</span><span class="s3">1</span><span class="s0">)),!r[t]&amp;&amp;e.length?r[t]=</span><span class="s1">new </span><span class="s0">b:n&amp;&amp;(r[t]=e.length?</span><span class="s1">new </span><span class="s0">b:</span><span class="s1">null</span><span class="s0">,r.$_mutateRebuild()),!r[t])</span><span class="s1">return </span><span class="s0">r;n&amp;&amp;r[t].override();</span><span class="s1">for</span><span class="s0">(const n of e){s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n,</span><span class="s2">&quot;Cannot call allow/valid/invalid with undefined&quot;</span><span class="s0">),s(n!==l.symbols.override,</span><span class="s2">&quot;Override must be the first value&quot;</span><span class="s0">);const e=</span><span class="s2">&quot;_invalids&quot;</span><span class="s0">===t?</span><span class="s2">&quot;_valids&quot;</span><span class="s0">:</span><span class="s2">&quot;_invalids&quot;</span><span class="s0">;r[e]&amp;&amp;(r[e].remove(n),r[e].length||(s(</span><span class="s2">&quot;_valids&quot;</span><span class="s0">===t||!r._flags.only,</span><span class="s2">&quot;Setting invalid value&quot;</span><span class="s0">,n,</span><span class="s2">&quot;leaves schema rejecting all values due to previous valid rule&quot;</span><span class="s0">),r[e]=</span><span class="s1">null</span><span class="s0">)),r[t].add(n,r._refs)}</span><span class="s1">return </span><span class="s0">r}}};v.Base.prototype[l.symbols.any]={version:l.version,compile:c.compile,root:</span><span class="s2">&quot;$_root&quot;</span><span class="s0">},v.Base.prototype.isImmutable=!</span><span class="s3">0</span><span class="s0">,v.Base.prototype.deny=v.Base.prototype.invalid,v.Base.prototype.disallow=v.Base.prototype.invalid,v.Base.prototype.equal=v.Base.prototype.valid,v.Base.prototype.exist=v.Base.prototype.required,v.Base.prototype.not=v.Base.prototype.invalid,v.Base.prototype.options=v.Base.prototype.prefs,v.Base.prototype.preferences=v.Base.prototype.prefs,e.exports=</span><span class="s1">new </span><span class="s0">v.Base},</span><span class="s3">8652</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i={max:</span><span class="s3">1</span><span class="s0">e3,supported:</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;undefined&quot;</span><span class="s0">,</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s2">&quot;string&quot;</span><span class="s0">])};t.provider={provision:e=&gt;</span><span class="s1">new </span><span class="s0">i.Cache(e)},i.Cache=class{constructor(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};a.assertOptions(e,[</span><span class="s2">&quot;max&quot;</span><span class="s0">]),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.max||e.max&amp;&amp;e.max&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;isFinite(e.max),</span><span class="s2">&quot;Invalid max cache size&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">._max=e.max||i.max,</span><span class="s1">this</span><span class="s0">._map=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">._list=</span><span class="s1">new </span><span class="s0">i.List}get length(){</span><span class="s1">return this</span><span class="s0">._map.size}set(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!==e&amp;&amp;!i.supported.has(</span><span class="s1">typeof </span><span class="s0">e))</span><span class="s1">return</span><span class="s0">;let r=</span><span class="s1">this</span><span class="s0">._map.get(e);</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">return </span><span class="s0">r.value=t,</span><span class="s1">void this</span><span class="s0">._list.first(r);r=</span><span class="s1">this</span><span class="s0">._list.unshift({key:e,value:t}),</span><span class="s1">this</span><span class="s0">._map.set(e,r),</span><span class="s1">this</span><span class="s0">._compact()}get(e){const t=</span><span class="s1">this</span><span class="s0">._map.get(e);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return this</span><span class="s0">._list.first(t),n(t.value)}_compact(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">._map.size&gt;</span><span class="s1">this</span><span class="s0">._max){const e=</span><span class="s1">this</span><span class="s0">._list.pop();</span><span class="s1">this</span><span class="s0">._map.</span><span class="s1">delete</span><span class="s0">(e.key)}}},i.List=class{constructor(){</span><span class="s1">this</span><span class="s0">.tail=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.head=</span><span class="s1">null</span><span class="s0">}unshift(e){</span><span class="s1">return </span><span class="s0">e.next=</span><span class="s1">null</span><span class="s0">,e.prev=</span><span class="s1">this</span><span class="s0">.head,</span><span class="s1">this</span><span class="s0">.head&amp;&amp;(</span><span class="s1">this</span><span class="s0">.head.next=e),</span><span class="s1">this</span><span class="s0">.head=e,</span><span class="s1">this</span><span class="s0">.tail||(</span><span class="s1">this</span><span class="s0">.tail=e),e}first(e){e!==</span><span class="s1">this</span><span class="s0">.head&amp;&amp;(</span><span class="s1">this</span><span class="s0">._remove(e),</span><span class="s1">this</span><span class="s0">.unshift(e))}pop(){</span><span class="s1">return this</span><span class="s0">._remove(</span><span class="s1">this</span><span class="s0">.tail)}_remove(e){const{next:t,prev:r}=e;</span><span class="s1">return </span><span class="s0">t.prev=r,r&amp;&amp;(r.next=t),e===</span><span class="s1">this</span><span class="s0">.tail&amp;&amp;(</span><span class="s1">this</span><span class="s0">.tail=t),e.prev=</span><span class="s1">null</span><span class="s0">,e.next=</span><span class="s1">null</span><span class="s0">,e}}},</span><span class="s3">8160</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">7916</span><span class="s0">),a=r(</span><span class="s3">5934</span><span class="s0">);let i,o;const l={isoDate:/^(?:[-+]\d{</span><span class="s3">2</span><span class="s0">})?(?:\d{</span><span class="s3">4</span><span class="s0">}(?!\d{</span><span class="s3">2</span><span class="s0">}\b))(?:(-?)(?:(?:</span><span class="s3">0</span><span class="s0">[</span><span class="s3">1</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]|</span><span class="s3">1</span><span class="s0">[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">2</span><span class="s0">])(?:\</span><span class="s3">1</span><span class="s0">(?:[</span><span class="s3">12</span><span class="s0">]\d|</span><span class="s3">0</span><span class="s0">[</span><span class="s3">1</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]|</span><span class="s3">3</span><span class="s0">[</span><span class="s3">01</span><span class="s0">]))?|W(?:[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">4</span><span class="s0">]\d|</span><span class="s3">5</span><span class="s0">[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">2</span><span class="s0">])(?:-?[</span><span class="s3">1</span><span class="s0">-</span><span class="s3">7</span><span class="s0">])?|(?:</span><span class="s3">00</span><span class="s0">[</span><span class="s3">1</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]|</span><span class="s3">0</span><span class="s0">[</span><span class="s3">1</span><span class="s0">-</span><span class="s3">9</span><span class="s0">]\d|[</span><span class="s3">12</span><span class="s0">]\d{</span><span class="s3">2</span><span class="s0">}|</span><span class="s3">3</span><span class="s0">(?:[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">5</span><span class="s0">]\d|</span><span class="s3">6</span><span class="s0">[</span><span class="s3">1</span><span class="s0">-</span><span class="s3">6</span><span class="s0">])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[</span><span class="s3">01</span><span class="s0">]\d|</span><span class="s3">2</span><span class="s0">[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">3</span><span class="s0">])(?:(:?)[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">5</span><span class="s0">]\d)?|</span><span class="s3">24</span><span class="s0">\:?</span><span class="s3">00</span><span class="s0">)(?:[.,]\d+(?!:))?)(?:\</span><span class="s3">2</span><span class="s0">[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">5</span><span class="s0">]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[</span><span class="s3">01</span><span class="s0">]\d|</span><span class="s3">2</span><span class="s0">[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">3</span><span class="s0">])(?::?[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">5</span><span class="s0">]\d)?)?)?)?$/};t.version=a.version,t.defaults={abortEarly:!</span><span class="s3">0</span><span class="s0">,allowUnknown:!</span><span class="s3">1</span><span class="s0">,artifacts:!</span><span class="s3">1</span><span class="s0">,cache:!</span><span class="s3">0</span><span class="s0">,context:</span><span class="s1">null</span><span class="s0">,convert:!</span><span class="s3">0</span><span class="s0">,dateFormat:</span><span class="s2">&quot;iso&quot;</span><span class="s0">,errors:{escapeHtml:!</span><span class="s3">1</span><span class="s0">,label:</span><span class="s2">&quot;path&quot;</span><span class="s0">,language:</span><span class="s1">null</span><span class="s0">,render:!</span><span class="s3">0</span><span class="s0">,stack:!</span><span class="s3">1</span><span class="s0">,wrap:{label:</span><span class="s2">'&quot;'</span><span class="s0">,array:</span><span class="s2">&quot;[]&quot;</span><span class="s0">}},externals:!</span><span class="s3">0</span><span class="s0">,messages:{},nonEnumerables:!</span><span class="s3">1</span><span class="s0">,noDefaults:!</span><span class="s3">1</span><span class="s0">,presence:</span><span class="s2">&quot;optional&quot;</span><span class="s0">,skipFunctions:!</span><span class="s3">1</span><span class="s0">,stripUnknown:!</span><span class="s3">1</span><span class="s0">,warnings:!</span><span class="s3">1</span><span class="s0">},t.symbols={any:Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;@hapi/joi/schema&quot;</span><span class="s0">),arraySingle:Symbol(</span><span class="s2">&quot;arraySingle&quot;</span><span class="s0">),deepDefault:Symbol(</span><span class="s2">&quot;deepDefault&quot;</span><span class="s0">),errors:Symbol(</span><span class="s2">&quot;errors&quot;</span><span class="s0">),literal:Symbol(</span><span class="s2">&quot;literal&quot;</span><span class="s0">),override:Symbol(</span><span class="s2">&quot;override&quot;</span><span class="s0">),parent:Symbol(</span><span class="s2">&quot;parent&quot;</span><span class="s0">),prefs:Symbol(</span><span class="s2">&quot;prefs&quot;</span><span class="s0">),ref:Symbol(</span><span class="s2">&quot;ref&quot;</span><span class="s0">),template:Symbol(</span><span class="s2">&quot;template&quot;</span><span class="s0">),values:Symbol(</span><span class="s2">&quot;values&quot;</span><span class="s0">)},t.assertOptions=</span><span class="s1">function</span><span class="s0">(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:</span><span class="s2">&quot;Options&quot;</span><span class="s0">;s(e&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;!Array.isArray(e),</span><span class="s2">&quot;Options must be of type object&quot;</span><span class="s0">);const n=Object.keys(e).filter((e=&gt;!t.includes(e)));s(</span><span class="s3">0</span><span class="s0">===n.length,`${r} contain unknown keys: ${n}`)},t.checkPreferences=</span><span class="s1">function</span><span class="s0">(e){o=o||r(</span><span class="s3">3378</span><span class="s0">);const t=o.preferences.validate(e);</span><span class="s1">if</span><span class="s0">(t.error)</span><span class="s1">throw new </span><span class="s0">n([t.error.details[</span><span class="s3">0</span><span class="s0">].message])},t.compare=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">switch</span><span class="s0">(r){</span><span class="s1">case</span><span class="s2">&quot;=&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e===t;</span><span class="s1">case</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e&gt;t;</span><span class="s1">case</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e&lt;t;</span><span class="s1">case</span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e&gt;=t;</span><span class="s1">case</span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">:</span><span class="s1">return </span><span class="s0">e&lt;=t}},t.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">===e?t:e},t.isIsoDate=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">l.isoDate.test(e)},t.isNumber=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;!isNaN(e)},t.isResolvable=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(e[t.symbols.ref]||e[t.symbols.template])},t.isSchema=</span><span class="s1">function</span><span class="s0">(e){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};const n=e&amp;&amp;e[t.symbols.any];</span><span class="s1">return</span><span class="s0">!!n&amp;&amp;(s(r.legacy||n.version===t.version,</span><span class="s2">&quot;Cannot mix different versions of joi schemas&quot;</span><span class="s0">),!</span><span class="s3">0</span><span class="s0">)},t.isValues=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e[t.symbols.values]},t.limit=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">Number.isSafeInteger(e)&amp;&amp;e&gt;=</span><span class="s3">0</span><span class="s0">},t.preferences=</span><span class="s1">function</span><span class="s0">(e,s){i=i||r(</span><span class="s3">6914</span><span class="s0">),e=e||{},s=s||{};const n=Object.assign({},e,s);</span><span class="s1">return </span><span class="s0">s.errors&amp;&amp;e.errors&amp;&amp;(n.errors=Object.assign({},e.errors,s.errors),n.errors.wrap=Object.assign({},e.errors.wrap,s.errors.wrap)),s.messages&amp;&amp;(n.messages=i.compile(s.messages,e.messages)),</span><span class="s1">delete </span><span class="s0">n[t.symbols.prefs],n},t.tryWithPath=</span><span class="s1">function</span><span class="s0">(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">e()}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">throw void </span><span class="s3">0</span><span class="s0">!==e.path?e.path=t+</span><span class="s2">&quot;.&quot;</span><span class="s0">+e.path:e.path=t,r.append&amp;&amp;(e.message=`${e.message} (${e.path})`),e}},t.validateArg=</span><span class="s1">function</span><span class="s0">(e,r,s){let{assert:n,message:a}=s;</span><span class="s1">if</span><span class="s0">(t.isSchema(n)){const t=n.validate(e);</span><span class="s1">if</span><span class="s0">(!t.error)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t.error.message}</span><span class="s1">if</span><span class="s0">(!n(e))</span><span class="s1">return </span><span class="s0">r?`${r} ${a}`:a},t.verifyFlat=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">for</span><span class="s0">(const r of e)s(!Array.isArray(r),</span><span class="s2">&quot;Method no longer accepts array arguments:&quot;</span><span class="s0">,t)}},</span><span class="s3">3292</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8160</span><span class="s0">),a=r(</span><span class="s3">6133</span><span class="s0">),i={};t.schema=</span><span class="s1">function</span><span class="s0">(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};n.assertOptions(r,[</span><span class="s2">&quot;appendPath&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">]);</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">i.schema(e,t,r)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">throw </span><span class="s0">r.appendPath&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e.path&amp;&amp;(e.message=`${e.message} (${e.path})`),e}},i.schema=</span><span class="s1">function</span><span class="s0">(e,t,r){s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t,</span><span class="s2">&quot;Invalid undefined schema&quot;</span><span class="s0">),Array.isArray(t)&amp;&amp;(s(t.length,</span><span class="s2">&quot;Invalid empty array schema&quot;</span><span class="s0">),</span><span class="s3">1</span><span class="s0">===t.length&amp;&amp;(t=t[</span><span class="s3">0</span><span class="s0">]));const a=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">s=arguments.length,n=</span><span class="s1">new </span><span class="s0">Array(s&gt;</span><span class="s3">1</span><span class="s0">?s-1:</span><span class="s3">0</span><span class="s0">),a=</span><span class="s3">1</span><span class="s0">;a&lt;s;a++)n[a-1]=arguments[a];</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">!==r.override?t.valid(e.override,...n):t.valid(...n)};</span><span class="s1">if</span><span class="s0">(i.simple(t))</span><span class="s1">return </span><span class="s0">a(e,t);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t)</span><span class="s1">return </span><span class="s0">e.custom(t);</span><span class="s1">if</span><span class="s0">(s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,</span><span class="s2">&quot;Invalid schema content:&quot;</span><span class="s0">,</span><span class="s1">typeof </span><span class="s0">t),n.isResolvable(t))</span><span class="s1">return </span><span class="s0">a(e,t);</span><span class="s1">if</span><span class="s0">(n.isSchema(t))</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">if</span><span class="s0">(Array.isArray(t)){</span><span class="s1">for</span><span class="s0">(const r of t)</span><span class="s1">if</span><span class="s0">(!i.simple(r))</span><span class="s1">return </span><span class="s0">e.alternatives().</span><span class="s1">try</span><span class="s0">(...t);</span><span class="s1">return </span><span class="s0">a(e,...t)}</span><span class="s1">return </span><span class="s0">t </span><span class="s1">instanceof </span><span class="s0">RegExp?e.string().regex(t):t </span><span class="s1">instanceof </span><span class="s0">Date?a(e.date(),t):(s(Object.getPrototypeOf(t)===Object.getPrototypeOf({}),</span><span class="s2">&quot;Schema can only contain plain objects&quot;</span><span class="s0">),e.object().keys(t))},t.ref=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">a.isRef(e)?e:a.create(e,t)},t.compile=</span><span class="s1">function</span><span class="s0">(e,r){let a=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};n.assertOptions(a,[</span><span class="s2">&quot;legacy&quot;</span><span class="s0">]);const o=r&amp;&amp;r[n.symbols.any];</span><span class="s1">if</span><span class="s0">(o)</span><span class="s1">return </span><span class="s0">s(a.legacy||o.version===n.version,</span><span class="s2">&quot;Cannot mix different versions of joi schemas:&quot;</span><span class="s0">,o.version,n.version),r;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r||!a.legacy)</span><span class="s1">return </span><span class="s0">t.schema(e,r,{appendPath:!</span><span class="s3">0</span><span class="s0">});const l=i.walk(r);</span><span class="s1">return </span><span class="s0">l?l.compile(l.root,r):t.schema(e,r,{appendPath:!</span><span class="s3">0</span><span class="s0">})},i.walk=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(Array.isArray(e)){</span><span class="s1">for</span><span class="s0">(const t of e){const e=i.walk(t);</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">return null</span><span class="s0">}const t=e[n.symbols.any];</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return</span><span class="s0">{root:e[t.root],compile:t.compile};s(Object.getPrototypeOf(e)===Object.getPrototypeOf({}),</span><span class="s2">&quot;Schema can only contain plain objects&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const t </span><span class="s1">in </span><span class="s0">e){const r=i.walk(e[t]);</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">return </span><span class="s0">r}</span><span class="s1">return null</span><span class="s0">},i.simple=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return null</span><span class="s0">===e||[</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,</span><span class="s2">&quot;string&quot;</span><span class="s0">,</span><span class="s2">&quot;number&quot;</span><span class="s0">].includes(</span><span class="s1">typeof </span><span class="s0">e)},t.when=</span><span class="s1">function</span><span class="s0">(e,r,o){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o&amp;&amp;(s(r&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r,</span><span class="s2">&quot;Missing options&quot;</span><span class="s0">),o=r,r=a.create(</span><span class="s2">&quot;.&quot;</span><span class="s0">)),Array.isArray(o)&amp;&amp;(o={</span><span class="s1">switch</span><span class="s0">:o}),n.assertOptions(o,[</span><span class="s2">&quot;is&quot;</span><span class="s0">,</span><span class="s2">&quot;not&quot;</span><span class="s0">,</span><span class="s2">&quot;then&quot;</span><span class="s0">,</span><span class="s2">&quot;otherwise&quot;</span><span class="s0">,</span><span class="s2">&quot;switch&quot;</span><span class="s0">,</span><span class="s2">&quot;break&quot;</span><span class="s0">]),n.isSchema(r))</span><span class="s1">return </span><span class="s0">s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.is,</span><span class="s2">'&quot;is&quot; can not be used with a schema condition'</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.not,</span><span class="s2">'&quot;not&quot; can not be used with a schema condition'</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.</span><span class="s1">switch</span><span class="s0">,</span><span class="s2">'&quot;switch&quot; can not be used with a schema condition'</span><span class="s0">),i.condition(e,{is:r,then:o.then,otherwise:o.otherwise,</span><span class="s1">break</span><span class="s0">:o.</span><span class="s1">break</span><span class="s0">});</span><span class="s1">if</span><span class="s0">(s(a.isRef(r)||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r,</span><span class="s2">&quot;Invalid condition:&quot;</span><span class="s0">,r),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.not||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.is,</span><span class="s2">'Cannot combine &quot;is&quot; with &quot;not&quot;'</span><span class="s0">),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.</span><span class="s1">switch</span><span class="s0">){let l=o;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==o.not&amp;&amp;(l={is:o.not,then:o.otherwise,otherwise:o.then,</span><span class="s1">break</span><span class="s0">:o.</span><span class="s1">break</span><span class="s0">});let c=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==l.is?e.$_compile(l.is):e.$_root.invalid(</span><span class="s1">null</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;&quot;</span><span class="s0">).required();</span><span class="s1">return </span><span class="s0">s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==l.then||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==l.otherwise,</span><span class="s2">'options must have at least one of &quot;then&quot;, &quot;otherwise&quot;, or &quot;switch&quot;'</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===l.</span><span class="s1">break</span><span class="s0">||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===l.then||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===l.otherwise,</span><span class="s2">&quot;Cannot specify then, otherwise, and break all together&quot;</span><span class="s0">),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.is||a.isRef(o.is)||n.isSchema(o.is)||(c=c.required()),i.condition(e,{ref:t.ref(r),is:c,then:l.then,otherwise:l.otherwise,</span><span class="s1">break</span><span class="s0">:l.</span><span class="s1">break</span><span class="s0">})}s(Array.isArray(o.</span><span class="s1">switch</span><span class="s0">),</span><span class="s2">'&quot;switch&quot; must be an array'</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.is,</span><span class="s2">'Cannot combine &quot;switch&quot; with &quot;is&quot;'</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.not,</span><span class="s2">'Cannot combine &quot;switch&quot; with &quot;not&quot;'</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.then,</span><span class="s2">'Cannot combine &quot;switch&quot; with &quot;then&quot;'</span><span class="s0">);const l={ref:t.ref(r),</span><span class="s1">switch</span><span class="s0">:[],</span><span class="s1">break</span><span class="s0">:o.</span><span class="s1">break</span><span class="s0">};</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;o.</span><span class="s1">switch</span><span class="s0">.length;++t){const r=o.</span><span class="s1">switch</span><span class="s0">[t],i=t===o.</span><span class="s1">switch</span><span class="s0">.length-1;n.assertOptions(r,i?[</span><span class="s2">&quot;is&quot;</span><span class="s0">,</span><span class="s2">&quot;then&quot;</span><span class="s0">,</span><span class="s2">&quot;otherwise&quot;</span><span class="s0">]:[</span><span class="s2">&quot;is&quot;</span><span class="s0">,</span><span class="s2">&quot;then&quot;</span><span class="s0">]),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r.is,</span><span class="s2">'Switch statement missing &quot;is&quot;'</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r.then,</span><span class="s2">'Switch statement missing &quot;then&quot;'</span><span class="s0">);const c={is:e.$_compile(r.is),then:e.$_compile(r.then)};</span><span class="s1">if</span><span class="s0">(a.isRef(r.is)||n.isSchema(r.is)||(c.is=c.is.required()),i){s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o.otherwise||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r.otherwise,</span><span class="s2">'Cannot specify &quot;otherwise&quot; inside and outside a &quot;switch&quot;'</span><span class="s0">);const t=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==o.otherwise?o.otherwise:r.otherwise;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t&amp;&amp;(s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===l.</span><span class="s1">break</span><span class="s0">,</span><span class="s2">&quot;Cannot specify both otherwise and break&quot;</span><span class="s0">),c.otherwise=e.$_compile(t))}l.</span><span class="s1">switch</span><span class="s0">.push(c)}</span><span class="s1">return </span><span class="s0">l},i.condition=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">for</span><span class="s0">(const r of[</span><span class="s2">&quot;then&quot;</span><span class="s0">,</span><span class="s2">&quot;otherwise&quot;</span><span class="s0">])</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t[r]?</span><span class="s1">delete </span><span class="s0">t[r]:t[r]=e.$_compile(t[r]);</span><span class="s1">return </span><span class="s0">t}},</span><span class="s3">6354</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">5688</span><span class="s0">),n=r(</span><span class="s3">8160</span><span class="s0">),a=r(</span><span class="s3">3328</span><span class="s0">);t.Report=class{constructor(e,r,s,n,a,i,o){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.code=e,</span><span class="s1">this</span><span class="s0">.flags=n,</span><span class="s1">this</span><span class="s0">.messages=a,</span><span class="s1">this</span><span class="s0">.path=i.path,</span><span class="s1">this</span><span class="s0">.prefs=o,</span><span class="s1">this</span><span class="s0">.state=i,</span><span class="s1">this</span><span class="s0">.value=r,</span><span class="s1">this</span><span class="s0">.message=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.template=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.local=s||{},</span><span class="s1">this</span><span class="s0">.local.label=t.label(</span><span class="s1">this</span><span class="s0">.flags,</span><span class="s1">this</span><span class="s0">.state,</span><span class="s1">this</span><span class="s0">.prefs,</span><span class="s1">this</span><span class="s0">.messages),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.value||</span><span class="s1">this</span><span class="s0">.local.hasOwnProperty(</span><span class="s2">&quot;value&quot;</span><span class="s0">)||(</span><span class="s1">this</span><span class="s0">.local.value=</span><span class="s1">this</span><span class="s0">.value),</span><span class="s1">this</span><span class="s0">.path.length){const e=</span><span class="s1">this</span><span class="s0">.path[</span><span class="s1">this</span><span class="s0">.path.length-1];</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.local.key=e)}}_setTemplate(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.template=e,!</span><span class="s1">this</span><span class="s0">.flags.label&amp;&amp;</span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.path.length){const e=</span><span class="s1">this</span><span class="s0">._template(</span><span class="s1">this</span><span class="s0">.template,</span><span class="s2">&quot;root&quot;</span><span class="s0">);e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.local.label=e)}}toString(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.message)</span><span class="s1">return this</span><span class="s0">.message;const e=</span><span class="s1">this</span><span class="s0">.code;</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.prefs.errors.render)</span><span class="s1">return this</span><span class="s0">.code;const t=</span><span class="s1">this</span><span class="s0">._template(</span><span class="s1">this</span><span class="s0">.template)||</span><span class="s1">this</span><span class="s0">._template(</span><span class="s1">this</span><span class="s0">.prefs.messages)||</span><span class="s1">this</span><span class="s0">._template(</span><span class="s1">this</span><span class="s0">.messages);</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">===t?`Error code </span><span class="s2">&quot;${e}&quot; </span><span class="s0">is not defined, your custom type is missing the correct messages definition`:(</span><span class="s1">this</span><span class="s0">.message=t.render(</span><span class="s1">this</span><span class="s0">.value,</span><span class="s1">this</span><span class="s0">.state,</span><span class="s1">this</span><span class="s0">.prefs,</span><span class="s1">this</span><span class="s0">.local,{errors:</span><span class="s1">this</span><span class="s0">.prefs.errors,messages:[</span><span class="s1">this</span><span class="s0">.prefs.messages,</span><span class="s1">this</span><span class="s0">.messages]}),</span><span class="s1">this</span><span class="s0">.prefs.errors.label||(</span><span class="s1">this</span><span class="s0">.message=</span><span class="s1">this</span><span class="s0">.message.replace(/^</span><span class="s2">&quot;&quot; </span><span class="s0">/,</span><span class="s2">&quot;&quot;</span><span class="s0">).trim()),</span><span class="s1">this</span><span class="s0">.message)}_template(e,r){</span><span class="s1">return </span><span class="s0">t.template(</span><span class="s1">this</span><span class="s0">.value,e,r||</span><span class="s1">this</span><span class="s0">.code,</span><span class="s1">this</span><span class="s0">.state,</span><span class="s1">this</span><span class="s0">.prefs)}},t.path=</span><span class="s1">function</span><span class="s0">(e){let t=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const r of e)</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r?(t&amp;&amp;(t+=</span><span class="s2">&quot;.&quot;</span><span class="s0">),t+=r):t+=`[${r}]`);</span><span class="s1">return </span><span class="s0">t},t.template=</span><span class="s1">function</span><span class="s0">(e,t,r,s,i){</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(a.isTemplate(t))</span><span class="s1">return</span><span class="s2">&quot;root&quot;</span><span class="s0">!==r?t:</span><span class="s1">null</span><span class="s0">;let o=i.errors.language;</span><span class="s1">if</span><span class="s0">(n.isResolvable(o)&amp;&amp;(o=o.resolve(e,s,i)),o&amp;&amp;t[o]){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t[o][r])</span><span class="s1">return </span><span class="s0">t[o][r];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t[o][</span><span class="s2">&quot;*&quot;</span><span class="s0">])</span><span class="s1">return </span><span class="s0">t[o][</span><span class="s2">&quot;*&quot;</span><span class="s0">]}</span><span class="s1">return </span><span class="s0">t[r]?t[r]:t[</span><span class="s2">&quot;*&quot;</span><span class="s0">]},t.label=</span><span class="s1">function</span><span class="s0">(e,r,s,n){</span><span class="s1">if</span><span class="s0">(e.label)</span><span class="s1">return </span><span class="s0">e.label;</span><span class="s1">if</span><span class="s0">(!s.errors.label)</span><span class="s1">return</span><span class="s2">&quot;&quot;</span><span class="s0">;let a=r.path;</span><span class="s2">&quot;key&quot;</span><span class="s0">===s.errors.label&amp;&amp;r.path.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;(a=r.path.slice(-</span><span class="s3">1</span><span class="s0">));</span><span class="s1">return </span><span class="s0">t.path(a)||t.template(</span><span class="s1">null</span><span class="s0">,s.messages,</span><span class="s2">&quot;root&quot;</span><span class="s0">,r,s)||n&amp;&amp;t.template(</span><span class="s1">null</span><span class="s0">,n,</span><span class="s2">&quot;root&quot;</span><span class="s0">,r,s)||</span><span class="s2">&quot;value&quot;</span><span class="s0">},t.process=</span><span class="s1">function</span><span class="s0">(e,r,s){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return null</span><span class="s0">;const{override:n,message:a,details:i}=t.details(e);</span><span class="s1">if</span><span class="s0">(n)</span><span class="s1">return </span><span class="s0">n;</span><span class="s1">if</span><span class="s0">(s.errors.stack)</span><span class="s1">return new </span><span class="s0">t.ValidationError(a,i,r);const o=Error.stackTraceLimit;Error.stackTraceLimit=</span><span class="s3">0</span><span class="s0">;const l=</span><span class="s1">new </span><span class="s0">t.ValidationError(a,i,r);</span><span class="s1">return </span><span class="s0">Error.stackTraceLimit=o,l},t.details=</span><span class="s1">function</span><span class="s0">(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{},r=[];const s=[];</span><span class="s1">for</span><span class="s0">(const n of e){</span><span class="s1">if</span><span class="s0">(n </span><span class="s1">instanceof </span><span class="s0">Error){</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">1</span><span class="s0">!==t.override)</span><span class="s1">return</span><span class="s0">{override:n};const e=n.toString();r.push(e),s.push({message:e,type:</span><span class="s2">&quot;override&quot;</span><span class="s0">,context:{error:n}});</span><span class="s1">continue</span><span class="s0">}const e=n.toString();r.push(e),s.push({message:e,path:n.path.filter((e=&gt;</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)),type:n.code,context:n.local})}</span><span class="s1">return </span><span class="s0">r.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;(r=[...</span><span class="s1">new </span><span class="s0">Set(r)]),{message:r.join(</span><span class="s2">&quot;. &quot;</span><span class="s0">),details:s}},t.ValidationError=class extends Error{constructor(e,t,r){super(e),</span><span class="s1">this</span><span class="s0">._original=r,</span><span class="s1">this</span><span class="s0">.details=t}static isError(e){</span><span class="s1">return </span><span class="s0">e </span><span class="s1">instanceof </span><span class="s0">t.ValidationError}},t.ValidationError.prototype.isJoi=!</span><span class="s3">0</span><span class="s0">,t.ValidationError.prototype.name=</span><span class="s2">&quot;ValidationError&quot;</span><span class="s0">,t.ValidationError.prototype.annotate=s.error},</span><span class="s3">8901</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i=r(</span><span class="s3">6914</span><span class="s0">),o={};t.type=</span><span class="s1">function</span><span class="s0">(e,t){const r=Object.getPrototypeOf(e),l=n(r),c=e._assign(Object.create(l)),u=Object.assign({},t);</span><span class="s1">delete </span><span class="s0">u.base,l._definition=u;const f=r._definition||{};u.messages=i.merge(f.messages,u.messages),u.properties=Object.assign({},f.properties,u.properties),c.type=u.type,u.flags=Object.assign({},f.flags,u.flags);const h=Object.assign({},f.terms);</span><span class="s1">if</span><span class="s0">(u.terms)</span><span class="s1">for</span><span class="s0">(const e </span><span class="s1">in </span><span class="s0">u.terms){const t=u.terms[e];s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===c.$_terms[e],</span><span class="s2">&quot;Invalid term override for&quot;</span><span class="s0">,u.type,e),c.$_terms[e]=t.init,h[e]=t}u.terms=h,u.args||(u.args=f.args),u.prepare=o.prepare(u.prepare,f.prepare),u.coerce&amp;&amp;(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">u.coerce&amp;&amp;(u.coerce={method:u.coerce}),u.coerce.from&amp;&amp;!Array.isArray(u.coerce.from)&amp;&amp;(u.coerce={method:u.coerce.method,from:[].concat(u.coerce.from)})),u.coerce=o.coerce(u.coerce,f.coerce),u.validate=o.validate(u.validate,f.validate);const m=Object.assign({},f.rules);</span><span class="s1">if</span><span class="s0">(u.rules)</span><span class="s1">for</span><span class="s0">(const e </span><span class="s1">in </span><span class="s0">u.rules){const t=u.rules[e];s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,</span><span class="s2">&quot;Invalid rule definition for&quot;</span><span class="s0">,u.type,e);let r=t.method;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r&amp;&amp;(r=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.$_addRule(e)}),r&amp;&amp;(s(!l[e],</span><span class="s2">&quot;Rule conflict in&quot;</span><span class="s0">,u.type,e),l[e]=r),s(!m[e],</span><span class="s2">&quot;Rule conflict in&quot;</span><span class="s0">,u.type,e),m[e]=t,t.alias){const e=[].concat(t.alias);</span><span class="s1">for</span><span class="s0">(const r of e)l[r]=t.method}t.args&amp;&amp;(t.argsByName=</span><span class="s1">new </span><span class="s0">Map,t.args=t.args.map((e=&gt;(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(e={name:e}),s(!t.argsByName.has(e.name),</span><span class="s2">&quot;Duplicated argument name&quot;</span><span class="s0">,e.name),a.isSchema(e.assert)&amp;&amp;(e.assert=e.assert.strict().label(e.name)),t.argsByName.set(e.name,e),e))))}u.rules=m;const d=Object.assign({},f.modifiers);</span><span class="s1">if</span><span class="s0">(u.modifiers)</span><span class="s1">for</span><span class="s0">(const e </span><span class="s1">in </span><span class="s0">u.modifiers){s(!l[e],</span><span class="s2">&quot;Rule conflict in&quot;</span><span class="s0">,u.type,e);const t=u.modifiers[e];s(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,</span><span class="s2">&quot;Invalid modifier definition for&quot;</span><span class="s0">,u.type,e);const r=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return this</span><span class="s0">.rule({[e]:t})};l[e]=r,d[e]=t}</span><span class="s1">if</span><span class="s0">(u.modifiers=d,u.overrides){l._super=r,c.$_super={};</span><span class="s1">for</span><span class="s0">(const e </span><span class="s1">in </span><span class="s0">u.overrides)s(r[e],</span><span class="s2">&quot;Cannot override missing&quot;</span><span class="s0">,e),u.overrides[e][a.symbols.parent]=r[e],c.$_super[e]=r[e].bind(c);Object.assign(l,u.overrides)}u.cast=Object.assign({},f.cast,u.cast);const p=Object.assign({},f.manifest,u.manifest);</span><span class="s1">return </span><span class="s0">p.build=o.build(u.manifest&amp;&amp;u.manifest.build,f.manifest&amp;&amp;f.manifest.build),u.manifest=p,u.rebuild=o.rebuild(u.rebuild,f.rebuild),c},o.build=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">e&amp;&amp;t?</span><span class="s1">function</span><span class="s0">(r,s){</span><span class="s1">return </span><span class="s0">t(e(r,s),s)}:e||t},o.coerce=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">e&amp;&amp;t?{from:e.from&amp;&amp;t.from?[...</span><span class="s1">new </span><span class="s0">Set([...e.from,...t.from])]:</span><span class="s1">null</span><span class="s0">,method(r,s){let n;</span><span class="s1">if</span><span class="s0">((!t.from||t.from.includes(</span><span class="s1">typeof </span><span class="s0">r))&amp;&amp;(n=t.method(r,s),n)){</span><span class="s1">if</span><span class="s0">(n.errors||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===n.value)</span><span class="s1">return </span><span class="s0">n;r=n.value}</span><span class="s1">if</span><span class="s0">(!e.from||e.from.includes(</span><span class="s1">typeof </span><span class="s0">r)){const t=e.method(r,s);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">return </span><span class="s0">n}}:e||t},o.prepare=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">e&amp;&amp;t?</span><span class="s1">function</span><span class="s0">(r,s){const n=e(r,s);</span><span class="s1">if</span><span class="s0">(n){</span><span class="s1">if</span><span class="s0">(n.errors||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===n.value)</span><span class="s1">return </span><span class="s0">n;r=n.value}</span><span class="s1">return </span><span class="s0">t(r,s)||n}:e||t},o.rebuild=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">e&amp;&amp;t?</span><span class="s1">function</span><span class="s0">(r){t(r),e(r)}:e||t},o.validate=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">e&amp;&amp;t?</span><span class="s1">function</span><span class="s0">(r,s){const n=t(r,s);</span><span class="s1">if</span><span class="s0">(n){</span><span class="s1">if</span><span class="s0">(n.errors&amp;&amp;(!Array.isArray(n.errors)||n.errors.length))</span><span class="s1">return </span><span class="s0">n;r=n.value}</span><span class="s1">return </span><span class="s0">e(r,s)||n}:e||t}},</span><span class="s3">5107</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">8652</span><span class="s0">),i=r(</span><span class="s3">8160</span><span class="s0">),o=r(</span><span class="s3">3292</span><span class="s0">),l=r(</span><span class="s3">6354</span><span class="s0">),c=r(</span><span class="s3">8901</span><span class="s0">),u=r(</span><span class="s3">9708</span><span class="s0">),f=r(</span><span class="s3">6133</span><span class="s0">),h=r(</span><span class="s3">3328</span><span class="s0">),m=r(</span><span class="s3">1152</span><span class="s0">);let d;const p={types:{alternatives:r(</span><span class="s3">4946</span><span class="s0">),any:r(</span><span class="s3">8068</span><span class="s0">),array:r(</span><span class="s3">546</span><span class="s0">),boolean:r(</span><span class="s3">4937</span><span class="s0">),date:r(</span><span class="s3">7500</span><span class="s0">),</span><span class="s1">function</span><span class="s0">:r(</span><span class="s3">390</span><span class="s0">),link:r(</span><span class="s3">8785</span><span class="s0">),number:r(</span><span class="s3">3832</span><span class="s0">),object:r(</span><span class="s3">8966</span><span class="s0">),string:r(</span><span class="s3">7417</span><span class="s0">),symbol:r(</span><span class="s3">8826</span><span class="s0">)},aliases:{alt:</span><span class="s2">&quot;alternatives&quot;</span><span class="s0">,bool:</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,func:</span><span class="s2">&quot;function&quot;</span><span class="s0">},root:</span><span class="s1">function</span><span class="s0">(){const e={_types:</span><span class="s1">new </span><span class="s0">Set(Object.keys(p.types))};</span><span class="s1">for</span><span class="s0">(const t of e._types)e[t]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,r=</span><span class="s1">new </span><span class="s0">Array(e),n=</span><span class="s3">0</span><span class="s0">;n&lt;e;n++)r[n]=arguments[n];</span><span class="s1">return </span><span class="s0">s(!r.length||[</span><span class="s2">&quot;alternatives&quot;</span><span class="s0">,</span><span class="s2">&quot;link&quot;</span><span class="s0">,</span><span class="s2">&quot;object&quot;</span><span class="s0">].includes(t),</span><span class="s2">&quot;The&quot;</span><span class="s0">,t,</span><span class="s2">&quot;type does not allow arguments&quot;</span><span class="s0">),p.generate(</span><span class="s1">this</span><span class="s0">,p.types[t],r)};</span><span class="s1">for</span><span class="s0">(const t of[</span><span class="s2">&quot;allow&quot;</span><span class="s0">,</span><span class="s2">&quot;custom&quot;</span><span class="s0">,</span><span class="s2">&quot;disallow&quot;</span><span class="s0">,</span><span class="s2">&quot;equal&quot;</span><span class="s0">,</span><span class="s2">&quot;exist&quot;</span><span class="s0">,</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">,</span><span class="s2">&quot;invalid&quot;</span><span class="s0">,</span><span class="s2">&quot;not&quot;</span><span class="s0">,</span><span class="s2">&quot;only&quot;</span><span class="s0">,</span><span class="s2">&quot;optional&quot;</span><span class="s0">,</span><span class="s2">&quot;options&quot;</span><span class="s0">,</span><span class="s2">&quot;prefs&quot;</span><span class="s0">,</span><span class="s2">&quot;preferences&quot;</span><span class="s0">,</span><span class="s2">&quot;required&quot;</span><span class="s0">,</span><span class="s2">&quot;strip&quot;</span><span class="s0">,</span><span class="s2">&quot;valid&quot;</span><span class="s0">,</span><span class="s2">&quot;when&quot;</span><span class="s0">])e[t]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return this</span><span class="s0">.any()[t](...arguments)};Object.assign(e,p.methods);</span><span class="s1">for</span><span class="s0">(const t </span><span class="s1">in </span><span class="s0">p.aliases){const r=p.aliases[t];e[t]=e[r]}</span><span class="s1">return </span><span class="s0">e.x=e.expression,m.setup&amp;&amp;m.setup(e),e}};p.methods={ValidationError:l.ValidationError,version:i.version,cache:a.provider,assert(e,t){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r=arguments.length,s=</span><span class="s1">new </span><span class="s0">Array(r&gt;</span><span class="s3">2</span><span class="s0">?r-2:</span><span class="s3">0</span><span class="s0">),n=</span><span class="s3">2</span><span class="s0">;n&lt;r;n++)s[n-2]=arguments[n];p.assert(e,t,!</span><span class="s3">0</span><span class="s0">,s)},attempt(e,t){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">r=arguments.length,s=</span><span class="s1">new </span><span class="s0">Array(r&gt;</span><span class="s3">2</span><span class="s0">?r-2:</span><span class="s3">0</span><span class="s0">),n=</span><span class="s3">2</span><span class="s0">;n&lt;r;n++)s[n-2]=arguments[n];</span><span class="s1">return </span><span class="s0">p.assert(e,t,!</span><span class="s3">1</span><span class="s0">,s)},build(e){</span><span class="s1">return </span><span class="s0">s(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">u.build,</span><span class="s2">&quot;Manifest functionality disabled&quot;</span><span class="s0">),u.build(</span><span class="s1">this</span><span class="s0">,e)},checkPreferences(e){i.checkPreferences(e)},compile(e,t){</span><span class="s1">return </span><span class="s0">o.compile(</span><span class="s1">this</span><span class="s0">,e,t)},defaults(e){s(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;modifier must be a function&quot;</span><span class="s0">);const t=Object.assign({},</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const r of t._types){const n=e(t[r]());s(i.isSchema(n),</span><span class="s2">&quot;modifier must return a valid schema object&quot;</span><span class="s0">),t[r]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return </span><span class="s0">p.generate(</span><span class="s1">this</span><span class="s0">,n,t)}}</span><span class="s1">return </span><span class="s0">t},expression(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return new </span><span class="s0">h(...t)},extend(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),n=</span><span class="s3">0</span><span class="s0">;n&lt;e;n++)t[n]=arguments[n];i.verifyFlat(t,</span><span class="s2">&quot;extend&quot;</span><span class="s0">),d=d||r(</span><span class="s3">3378</span><span class="s0">),s(t.length,</span><span class="s2">&quot;You need to provide at least one extension&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.assert(t,d.extensions);const a=Object.assign({},</span><span class="s1">this</span><span class="s0">);a._types=</span><span class="s1">new </span><span class="s0">Set(a._types);</span><span class="s1">for</span><span class="s0">(let e of t){</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(e=e(a)),</span><span class="s1">this</span><span class="s0">.assert(e,d.extension);const t=p.expandExtension(e,a);</span><span class="s1">for</span><span class="s0">(const e of t){s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===a[e.type]||a._types.has(e.type),</span><span class="s2">&quot;Cannot override name&quot;</span><span class="s0">,e.type);const t=e.base||</span><span class="s1">this</span><span class="s0">.any(),r=c.type(t,e);a._types.add(e.type),a[e.type]=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),s=</span><span class="s3">0</span><span class="s0">;s&lt;e;s++)t[s]=arguments[s];</span><span class="s1">return </span><span class="s0">p.generate(</span><span class="s1">this</span><span class="s0">,r,t)}}}</span><span class="s1">return </span><span class="s0">a},isError:l.ValidationError.isError,isExpression:h.isTemplate,isRef:f.isRef,isSchema:i.isSchema,</span><span class="s1">in</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">f.</span><span class="s1">in</span><span class="s0">(...arguments)},override:i.symbols.override,ref(){</span><span class="s1">return </span><span class="s0">f.create(...arguments)},types(){const e={};</span><span class="s1">for</span><span class="s0">(const t of </span><span class="s1">this</span><span class="s0">._types)e[t]=</span><span class="s1">this</span><span class="s0">[t]();</span><span class="s1">for</span><span class="s0">(const t </span><span class="s1">in </span><span class="s0">p.aliases)e[t]=</span><span class="s1">this</span><span class="s0">[t]();</span><span class="s1">return </span><span class="s0">e}},p.assert=</span><span class="s1">function</span><span class="s0">(e,t,r,s){const a=s[</span><span class="s3">0</span><span class="s0">]</span><span class="s1">instanceof </span><span class="s0">Error||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s[</span><span class="s3">0</span><span class="s0">]?s[</span><span class="s3">0</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">,o=</span><span class="s1">null</span><span class="s0">!==a?s[</span><span class="s3">1</span><span class="s0">]:s[</span><span class="s3">0</span><span class="s0">],c=t.validate(e,i.preferences({errors:{stack:!</span><span class="s3">0</span><span class="s0">}},o||{}));let u=c.error;</span><span class="s1">if</span><span class="s0">(!u)</span><span class="s1">return </span><span class="s0">c.value;</span><span class="s1">if</span><span class="s0">(a </span><span class="s1">instanceof </span><span class="s0">Error)</span><span class="s1">throw </span><span class="s0">a;const f=r&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">u.annotate?u.annotate():u.message;</span><span class="s1">throw </span><span class="s0">u </span><span class="s1">instanceof </span><span class="s0">l.ValidationError==</span><span class="s3">0</span><span class="s0">&amp;&amp;(u=n(u)),u.message=a?`${a} ${f}`:f,u},p.generate=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return </span><span class="s0">s(e,</span><span class="s2">&quot;Must be invoked on a Joi instance.&quot;</span><span class="s0">),t.$_root=e,t._definition.args&amp;&amp;r.length?t._definition.args(t,...r):t},p.expandExtension=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.type)</span><span class="s1">return</span><span class="s0">[e];const r=[];</span><span class="s1">for</span><span class="s0">(const s of t._types)</span><span class="s1">if</span><span class="s0">(e.type.test(s)){const n=Object.assign({},e);n.type=s,n.base=t[s](),r.push(n)}</span><span class="s1">return </span><span class="s0">r},e.exports=p.root()},</span><span class="s3">6914</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">3328</span><span class="s0">);t.compile=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return </span><span class="s0">s(!t,</span><span class="s2">&quot;Cannot set single message string&quot;</span><span class="s0">),</span><span class="s1">new </span><span class="s0">a(e);</span><span class="s1">if</span><span class="s0">(a.isTemplate(e))</span><span class="s1">return </span><span class="s0">s(!t,</span><span class="s2">&quot;Cannot set single message template&quot;</span><span class="s0">),e;s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;!Array.isArray(e),</span><span class="s2">&quot;Invalid message options&quot;</span><span class="s0">),t=t?n(t):{};</span><span class="s1">for</span><span class="s0">(let r </span><span class="s1">in </span><span class="s0">e){const n=e[r];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;root&quot;</span><span class="s0">===r||a.isTemplate(n)){t[r]=n;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n){t[r]=</span><span class="s1">new </span><span class="s0">a(n);</span><span class="s1">continue</span><span class="s0">}s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n&amp;&amp;!Array.isArray(n),</span><span class="s2">&quot;Invalid message for&quot;</span><span class="s0">,r);const i=r;</span><span class="s1">for</span><span class="s0">(r </span><span class="s1">in </span><span class="s0">t[i]=t[i]||{},n){const e=n[r];</span><span class="s2">&quot;root&quot;</span><span class="s0">===r||a.isTemplate(e)?t[i][r]=e:(s(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid message for&quot;</span><span class="s0">,r,</span><span class="s2">&quot;in&quot;</span><span class="s0">,i),t[i][r]=</span><span class="s1">new </span><span class="s0">a(e))}}</span><span class="s1">return </span><span class="s0">t},t.decompile=</span><span class="s1">function</span><span class="s0">(e){const t={};</span><span class="s1">for</span><span class="s0">(let r </span><span class="s1">in </span><span class="s0">e){const s=e[r];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;root&quot;</span><span class="s0">===r){t.root=s;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(a.isTemplate(s)){t[r]=s.describe({compact:!</span><span class="s3">0</span><span class="s0">});</span><span class="s1">continue</span><span class="s0">}const n=r;</span><span class="s1">for</span><span class="s0">(r </span><span class="s1">in </span><span class="s0">t[n]={},s){const e=s[r];</span><span class="s2">&quot;root&quot;</span><span class="s0">!==r?t[n][r]=e.describe({compact:!</span><span class="s3">0</span><span class="s0">}):t[n].root=e}}</span><span class="s1">return </span><span class="s0">t},t.merge=</span><span class="s1">function</span><span class="s0">(e,r){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return </span><span class="s0">t.compile(r);</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r)</span><span class="s1">return new </span><span class="s0">a(r);</span><span class="s1">if</span><span class="s0">(a.isTemplate(r))</span><span class="s1">return </span><span class="s0">r;const i=n(e);</span><span class="s1">for</span><span class="s0">(let e </span><span class="s1">in </span><span class="s0">r){const t=r[e];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;root&quot;</span><span class="s0">===e||a.isTemplate(t)){i[e]=t;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t){i[e]=</span><span class="s1">new </span><span class="s0">a(t);</span><span class="s1">continue</span><span class="s0">}s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;!Array.isArray(t),</span><span class="s2">&quot;Invalid message for&quot;</span><span class="s0">,e);const n=e;</span><span class="s1">for</span><span class="s0">(e </span><span class="s1">in </span><span class="s0">i[n]=i[n]||{},t){const r=t[e];</span><span class="s2">&quot;root&quot;</span><span class="s0">===e||a.isTemplate(r)?i[n][e]=r:(s(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r,</span><span class="s2">&quot;Invalid message for&quot;</span><span class="s0">,e,</span><span class="s2">&quot;in&quot;</span><span class="s0">,n),i[n][e]=</span><span class="s1">new </span><span class="s0">a(r))}}</span><span class="s1">return </span><span class="s0">i}},</span><span class="s3">2294</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8160</span><span class="s0">),a=r(</span><span class="s3">6133</span><span class="s0">),i={};t.Ids=i.Ids=class{constructor(){</span><span class="s1">this</span><span class="s0">._byId=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">._byKey=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">._schemaChain=!</span><span class="s3">1</span><span class="s0">}clone(){const e=</span><span class="s1">new </span><span class="s0">i.Ids;</span><span class="s1">return </span><span class="s0">e._byId=</span><span class="s1">new </span><span class="s0">Map(</span><span class="s1">this</span><span class="s0">._byId),e._byKey=</span><span class="s1">new </span><span class="s0">Map(</span><span class="s1">this</span><span class="s0">._byKey),e._schemaChain=</span><span class="s1">this</span><span class="s0">._schemaChain,e}concat(e){e._schemaChain&amp;&amp;(</span><span class="s1">this</span><span class="s0">._schemaChain=!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const[t,r]of e._byId.entries())s(!</span><span class="s1">this</span><span class="s0">._byKey.has(t),</span><span class="s2">&quot;Schema id conflicts with existing key:&quot;</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">._byId.set(t,r);</span><span class="s1">for</span><span class="s0">(const[t,r]of e._byKey.entries())s(!</span><span class="s1">this</span><span class="s0">._byId.has(t),</span><span class="s2">&quot;Schema key conflicts with existing id:&quot;</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">._byKey.set(t,r)}fork(e,t,r){const a=</span><span class="s1">this</span><span class="s0">._collect(e);a.push({schema:r});const o=a.shift();let l={id:o.id,schema:t(o.schema)};s(n.isSchema(l.schema),</span><span class="s2">&quot;adjuster function failed to return a joi schema type&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const e of a)l={id:e.id,schema:i.fork(e.schema,l.id,l.schema)};</span><span class="s1">return </span><span class="s0">l.schema}labels(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:[];const r=e[</span><span class="s3">0</span><span class="s0">],s=</span><span class="s1">this</span><span class="s0">._get(r);</span><span class="s1">if</span><span class="s0">(!s)</span><span class="s1">return</span><span class="s0">[...t,...e].join(</span><span class="s2">&quot;.&quot;</span><span class="s0">);const n=e.slice(</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t=[...t,s.schema._flags.label||r],n.length?s.schema._ids.labels(n,t):t.join(</span><span class="s2">&quot;.&quot;</span><span class="s0">)}reach(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:[];const r=e[</span><span class="s3">0</span><span class="s0">],n=</span><span class="s1">this</span><span class="s0">._get(r);s(n,</span><span class="s2">&quot;Schema does not contain path&quot;</span><span class="s0">,[...t,...e].join(</span><span class="s2">&quot;.&quot;</span><span class="s0">));const a=e.slice(</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">a.length?n.schema._ids.reach(a,[...t,r]):n.schema}register(e){let{key:t}=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">(!e||!n.isSchema(e))</span><span class="s1">return</span><span class="s0">;(e.$_property(</span><span class="s2">&quot;schemaChain&quot;</span><span class="s0">)||e._ids._schemaChain)&amp;&amp;(</span><span class="s1">this</span><span class="s0">._schemaChain=!</span><span class="s3">0</span><span class="s0">);const r=e._flags.id;</span><span class="s1">if</span><span class="s0">(r){const t=</span><span class="s1">this</span><span class="s0">._byId.get(r);s(!t||t.schema===e,</span><span class="s2">&quot;Cannot add different schemas with the same id:&quot;</span><span class="s0">,r),s(!</span><span class="s1">this</span><span class="s0">._byKey.has(r),</span><span class="s2">&quot;Schema id conflicts with existing key:&quot;</span><span class="s0">,r),</span><span class="s1">this</span><span class="s0">._byId.set(r,{schema:e,id:r})}t&amp;&amp;(s(!</span><span class="s1">this</span><span class="s0">._byKey.has(t),</span><span class="s2">&quot;Schema already contains key:&quot;</span><span class="s0">,t),s(!</span><span class="s1">this</span><span class="s0">._byId.has(t),</span><span class="s2">&quot;Schema key conflicts with existing id:&quot;</span><span class="s0">,t),</span><span class="s1">this</span><span class="s0">._byKey.set(t,{schema:e,id:t}))}reset(){</span><span class="s1">this</span><span class="s0">._byId=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">._byKey=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">._schemaChain=!</span><span class="s3">1</span><span class="s0">}_collect(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:[],r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:[];const n=e[</span><span class="s3">0</span><span class="s0">],a=</span><span class="s1">this</span><span class="s0">._get(n);s(a,</span><span class="s2">&quot;Schema does not contain path&quot;</span><span class="s0">,[...t,...e].join(</span><span class="s2">&quot;.&quot;</span><span class="s0">)),r=[a,...r];const i=e.slice(</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">i.length?a.schema._ids._collect(i,[...t,n],r):r}_get(e){</span><span class="s1">return this</span><span class="s0">._byId.get(e)||</span><span class="s1">this</span><span class="s0">._byKey.get(e)}},i.fork=</span><span class="s1">function</span><span class="s0">(e,r,s){const n=t.schema(e,{each:(e,t)=&gt;{let{key:n}=t;</span><span class="s1">if</span><span class="s0">(r===(e._flags.id||n))</span><span class="s1">return </span><span class="s0">s},ref:!</span><span class="s3">1</span><span class="s0">});</span><span class="s1">return </span><span class="s0">n?n.$_mutateRebuild():e},t.schema=</span><span class="s1">function</span><span class="s0">(e,t){let r;</span><span class="s1">for</span><span class="s0">(const s </span><span class="s1">in </span><span class="s0">e._flags){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;_&quot;</span><span class="s0">===s[</span><span class="s3">0</span><span class="s0">])</span><span class="s1">continue</span><span class="s0">;const n=i.scan(e._flags[s],{source:</span><span class="s2">&quot;flags&quot;</span><span class="s0">,name:s},t);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n&amp;&amp;(r=r||e.clone(),r._flags[s]=n)}</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">;s&lt;e._rules.length;++s){const n=e._rules[s],a=i.scan(n.args,{source:</span><span class="s2">&quot;rules&quot;</span><span class="s0">,name:n.name},t);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==a){r=r||e.clone();const t=Object.assign({},n);t.args=a,r._rules[s]=t,r._singleRules.get(n.name)===n&amp;&amp;r._singleRules.set(n.name,t)}}</span><span class="s1">for</span><span class="s0">(const s </span><span class="s1">in </span><span class="s0">e.$_terms){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;_&quot;</span><span class="s0">===s[</span><span class="s3">0</span><span class="s0">])</span><span class="s1">continue</span><span class="s0">;const n=i.scan(e.$_terms[s],{source:</span><span class="s2">&quot;terms&quot;</span><span class="s0">,name:s},t);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n&amp;&amp;(r=r||e.clone(),r.$_terms[s]=n)}</span><span class="s1">return </span><span class="s0">r},i.scan=</span><span class="s1">function</span><span class="s0">(e,t,r,s,o){const l=s||[];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">;let c;</span><span class="s1">if</span><span class="s0">(Array.isArray(e)){</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">;s&lt;e.length;++s){const n=</span><span class="s2">&quot;terms&quot;</span><span class="s0">===t.source&amp;&amp;</span><span class="s2">&quot;keys&quot;</span><span class="s0">===t.name&amp;&amp;e[s].key,a=i.scan(e[s],t,r,[s,...l],n);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==a&amp;&amp;(c=c||e.slice(),c[s]=a)}</span><span class="s1">return </span><span class="s0">c}</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">1</span><span class="s0">!==r.schema&amp;&amp;n.isSchema(e)||!</span><span class="s3">1</span><span class="s0">!==r.ref&amp;&amp;a.isRef(e)){const s=r.each(e,{...t,path:l,key:o});</span><span class="s1">if</span><span class="s0">(s===e)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return </span><span class="s0">s}</span><span class="s1">for</span><span class="s0">(const s </span><span class="s1">in </span><span class="s0">e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;_&quot;</span><span class="s0">===s[</span><span class="s3">0</span><span class="s0">])</span><span class="s1">continue</span><span class="s0">;const n=i.scan(e[s],t,r,[s,...l],o);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n&amp;&amp;(c=c||Object.assign({},e),c[s]=n)}</span><span class="s1">return </span><span class="s0">c}},</span><span class="s3">6133</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">9621</span><span class="s0">),i=r(</span><span class="s3">8160</span><span class="s0">);let o;const l={symbol:Symbol(</span><span class="s2">&quot;ref&quot;</span><span class="s0">),defaults:{adjust:</span><span class="s1">null</span><span class="s0">,</span><span class="s1">in</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">,iterables:</span><span class="s1">null</span><span class="s0">,map:</span><span class="s1">null</span><span class="s0">,separator:</span><span class="s2">&quot;.&quot;</span><span class="s0">,type:</span><span class="s2">&quot;value&quot;</span><span class="s0">}};t.create=</span><span class="s1">function</span><span class="s0">(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};s(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid reference key:&quot;</span><span class="s0">,e),i.assertOptions(t,[</span><span class="s2">&quot;adjust&quot;</span><span class="s0">,</span><span class="s2">&quot;ancestor&quot;</span><span class="s0">,</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;iterables&quot;</span><span class="s0">,</span><span class="s2">&quot;map&quot;</span><span class="s0">,</span><span class="s2">&quot;prefix&quot;</span><span class="s0">,</span><span class="s2">&quot;render&quot;</span><span class="s0">,</span><span class="s2">&quot;separator&quot;</span><span class="s0">]),s(!t.prefix||</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t.prefix,</span><span class="s2">&quot;options.prefix must be of type object&quot;</span><span class="s0">);const r=Object.assign({},l.defaults,t);</span><span class="s1">delete </span><span class="s0">r.prefix;const n=r.separator,a=l.context(e,n,t.prefix);</span><span class="s1">if</span><span class="s0">(r.type=a.type,e=a.key,</span><span class="s2">&quot;value&quot;</span><span class="s0">===r.type)</span><span class="s1">if</span><span class="s0">(a.root&amp;&amp;(s(!n||e[</span><span class="s3">0</span><span class="s0">]!==n,</span><span class="s2">&quot;Cannot specify relative path with root prefix&quot;</span><span class="s0">),r.ancestor=</span><span class="s2">&quot;root&quot;</span><span class="s0">,e||(e=</span><span class="s1">null</span><span class="s0">)),n&amp;&amp;n===e)e=</span><span class="s1">null</span><span class="s0">,r.ancestor=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r.ancestor)s(!n||!e||e[</span><span class="s3">0</span><span class="s0">]!==n,</span><span class="s2">&quot;Cannot combine prefix with ancestor option&quot;</span><span class="s0">);</span><span class="s1">else</span><span class="s0">{const[t,s]=l.ancestor(e,n);s&amp;&amp;</span><span class="s2">&quot;&quot;</span><span class="s0">===(e=e.slice(s))&amp;&amp;(e=</span><span class="s1">null</span><span class="s0">),r.ancestor=t}</span><span class="s1">return </span><span class="s0">r.path=n?</span><span class="s1">null</span><span class="s0">===e?[]:e.split(n):[e],</span><span class="s1">new </span><span class="s0">l.Ref(r)},t.</span><span class="s1">in</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e){let r=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">t.create(e,{...r,</span><span class="s1">in</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">})},t.isRef=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;!!e[i.symbols.ref]},l.Ref=class{constructor(e){s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid reference construction&quot;</span><span class="s0">),i.assertOptions(e,[</span><span class="s2">&quot;adjust&quot;</span><span class="s0">,</span><span class="s2">&quot;ancestor&quot;</span><span class="s0">,</span><span class="s2">&quot;in&quot;</span><span class="s0">,</span><span class="s2">&quot;iterables&quot;</span><span class="s0">,</span><span class="s2">&quot;map&quot;</span><span class="s0">,</span><span class="s2">&quot;path&quot;</span><span class="s0">,</span><span class="s2">&quot;render&quot;</span><span class="s0">,</span><span class="s2">&quot;separator&quot;</span><span class="s0">,</span><span class="s2">&quot;type&quot;</span><span class="s0">,</span><span class="s2">&quot;depth&quot;</span><span class="s0">,</span><span class="s2">&quot;key&quot;</span><span class="s0">,</span><span class="s2">&quot;root&quot;</span><span class="s0">,</span><span class="s2">&quot;display&quot;</span><span class="s0">]),s([!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">].includes(e.separator)||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.separator&amp;&amp;</span><span class="s3">1</span><span class="s0">===e.separator.length,</span><span class="s2">&quot;Invalid separator&quot;</span><span class="s0">),s(!e.adjust||</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.adjust,</span><span class="s2">&quot;options.adjust must be a function&quot;</span><span class="s0">),s(!e.map||Array.isArray(e.map),</span><span class="s2">&quot;options.map must be an array&quot;</span><span class="s0">),s(!e.map||!e.adjust,</span><span class="s2">&quot;Cannot set both map and adjust options&quot;</span><span class="s0">),Object.assign(</span><span class="s1">this</span><span class="s0">,l.defaults,e),s(</span><span class="s2">&quot;value&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.ancestor,</span><span class="s2">&quot;Non-value references cannot reference ancestors&quot;</span><span class="s0">),Array.isArray(</span><span class="s1">this</span><span class="s0">.map)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.map=</span><span class="s1">new </span><span class="s0">Map(</span><span class="s1">this</span><span class="s0">.map)),</span><span class="s1">this</span><span class="s0">.depth=</span><span class="s1">this</span><span class="s0">.path.length,</span><span class="s1">this</span><span class="s0">.key=</span><span class="s1">this</span><span class="s0">.path.length?</span><span class="s1">this</span><span class="s0">.path.join(</span><span class="s1">this</span><span class="s0">.separator):</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.root=</span><span class="s1">this</span><span class="s0">.path[</span><span class="s3">0</span><span class="s0">],</span><span class="s1">this</span><span class="s0">.updateDisplay()}resolve(e,t,r,n){let a=arguments.length&gt;</span><span class="s3">4</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">4</span><span class="s0">]?arguments[</span><span class="s3">4</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">s(!</span><span class="s1">this</span><span class="s0">.</span><span class="s1">in</span><span class="s0">||a.</span><span class="s1">in</span><span class="s0">,</span><span class="s2">&quot;Invalid in() reference usage&quot;</span><span class="s0">),</span><span class="s2">&quot;global&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type?</span><span class="s1">this</span><span class="s0">._resolve(r.context,t,a):</span><span class="s2">&quot;local&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type?</span><span class="s1">this</span><span class="s0">._resolve(n,t,a):</span><span class="s1">this</span><span class="s0">.ancestor?</span><span class="s2">&quot;root&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.ancestor?</span><span class="s1">this</span><span class="s0">._resolve(t.ancestors[t.ancestors.length-1],t,a):(s(</span><span class="s1">this</span><span class="s0">.ancestor&lt;=t.ancestors.length,</span><span class="s2">&quot;Invalid reference exceeds the schema root:&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.display),</span><span class="s1">this</span><span class="s0">._resolve(t.ancestors[</span><span class="s1">this</span><span class="s0">.ancestor-1],t,a)):</span><span class="s1">this</span><span class="s0">._resolve(e,t,a)}_resolve(e,t,r){let s;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;value&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type&amp;&amp;t.mainstay.shadow&amp;&amp;!</span><span class="s3">1</span><span class="s0">!==r.shadow&amp;&amp;(s=t.mainstay.shadow.get(</span><span class="s1">this</span><span class="s0">.absolute(t))),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===s&amp;&amp;(s=a(e,</span><span class="s1">this</span><span class="s0">.path,{iterables:</span><span class="s1">this</span><span class="s0">.iterables,functions:!</span><span class="s3">0</span><span class="s0">})),</span><span class="s1">this</span><span class="s0">.adjust&amp;&amp;(s=</span><span class="s1">this</span><span class="s0">.adjust(s)),</span><span class="s1">this</span><span class="s0">.map){const e=</span><span class="s1">this</span><span class="s0">.map.get(s);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;(s=e)}</span><span class="s1">return </span><span class="s0">t.mainstay&amp;&amp;t.mainstay.tracer.resolve(t,</span><span class="s1">this</span><span class="s0">,s),s}toString(){</span><span class="s1">return this</span><span class="s0">.display}absolute(e){</span><span class="s1">return</span><span class="s0">[...e.path.slice(</span><span class="s3">0</span><span class="s0">,-</span><span class="s1">this</span><span class="s0">.ancestor),...</span><span class="s1">this</span><span class="s0">.path]}clone(){</span><span class="s1">return new </span><span class="s0">l.Ref(</span><span class="s1">this</span><span class="s0">)}describe(){const e={path:</span><span class="s1">this</span><span class="s0">.path};</span><span class="s2">&quot;value&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.type&amp;&amp;(e.type=</span><span class="s1">this</span><span class="s0">.type),</span><span class="s2">&quot;.&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.separator&amp;&amp;(e.separator=</span><span class="s1">this</span><span class="s0">.separator),</span><span class="s2">&quot;value&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.type&amp;&amp;</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.ancestor&amp;&amp;(e.ancestor=</span><span class="s1">this</span><span class="s0">.ancestor),</span><span class="s1">this</span><span class="s0">.map&amp;&amp;(e.map=[...</span><span class="s1">this</span><span class="s0">.map]);</span><span class="s1">for</span><span class="s0">(const t of[</span><span class="s2">&quot;adjust&quot;</span><span class="s0">,</span><span class="s2">&quot;iterables&quot;</span><span class="s0">,</span><span class="s2">&quot;render&quot;</span><span class="s0">])</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">[t]&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">[t]&amp;&amp;(e[t]=</span><span class="s1">this</span><span class="s0">[t]);</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.</span><span class="s1">in</span><span class="s0">&amp;&amp;(e.</span><span class="s1">in</span><span class="s0">=!</span><span class="s3">0</span><span class="s0">),{ref:e}}updateDisplay(){const e=</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.key?</span><span class="s1">this</span><span class="s0">.key:</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;value&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.type)</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.display=`ref:${</span><span class="s1">this</span><span class="s0">.type}:${e}`);</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.separator)</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.display=`ref:${e}`);</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.ancestor)</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.display=`ref:${</span><span class="s1">this</span><span class="s0">.separator}${e}`);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;root&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.ancestor)</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.display=`ref:root:${e}`);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.ancestor)</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.display=`ref:${e||</span><span class="s2">&quot;..&quot;</span><span class="s0">}`);const t=</span><span class="s1">new </span><span class="s0">Array(</span><span class="s1">this</span><span class="s0">.ancestor+</span><span class="s3">1</span><span class="s0">).fill(</span><span class="s1">this</span><span class="s0">.separator).join(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">this</span><span class="s0">.display=`ref:${t}${e||</span><span class="s2">&quot;&quot;</span><span class="s0">}`}},l.Ref.prototype[i.symbols.ref]=!</span><span class="s3">0</span><span class="s0">,t.build=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s2">&quot;value&quot;</span><span class="s0">===(e=Object.assign({},l.defaults,e)).type&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.ancestor&amp;&amp;(e.ancestor=</span><span class="s3">1</span><span class="s0">),</span><span class="s1">new </span><span class="s0">l.Ref(e)},l.context=</span><span class="s1">function</span><span class="s0">(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">(e=e.trim(),r){const s=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r.global?</span><span class="s2">&quot;$&quot;</span><span class="s0">:r.global;</span><span class="s1">if</span><span class="s0">(s!==t&amp;&amp;e.startsWith(s))</span><span class="s1">return</span><span class="s0">{key:e.slice(s.length),type:</span><span class="s2">&quot;global&quot;</span><span class="s0">};const n=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r.local?</span><span class="s2">&quot;#&quot;</span><span class="s0">:r.local;</span><span class="s1">if</span><span class="s0">(n!==t&amp;&amp;e.startsWith(n))</span><span class="s1">return</span><span class="s0">{key:e.slice(n.length),type:</span><span class="s2">&quot;local&quot;</span><span class="s0">};const a=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r.root?</span><span class="s2">&quot;/&quot;</span><span class="s0">:r.root;</span><span class="s1">if</span><span class="s0">(a!==t&amp;&amp;e.startsWith(a))</span><span class="s1">return</span><span class="s0">{key:e.slice(a.length),type:</span><span class="s2">&quot;value&quot;</span><span class="s0">,root:!</span><span class="s3">0</span><span class="s0">}}</span><span class="s1">return</span><span class="s0">{key:e,type:</span><span class="s2">&quot;value&quot;</span><span class="s0">}},l.ancestor=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(e[</span><span class="s3">0</span><span class="s0">]!==t)</span><span class="s1">return</span><span class="s0">[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(e[</span><span class="s3">1</span><span class="s0">]!==t)</span><span class="s1">return</span><span class="s0">[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">];let r=</span><span class="s3">2</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;e[r]===t;)++r;</span><span class="s1">return</span><span class="s0">[r-1,r]},t.toSibling=</span><span class="s3">0</span><span class="s0">,t.toParent=</span><span class="s3">1</span><span class="s0">,t.Manager=class{constructor(){</span><span class="s1">this</span><span class="s0">.refs=[]}register(e,s){</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">if</span><span class="s0">(s=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===s?t.toParent:s,Array.isArray(e))</span><span class="s1">for</span><span class="s0">(const t of e)</span><span class="s1">this</span><span class="s0">.register(t,s);</span><span class="s1">else if</span><span class="s0">(i.isSchema(e))</span><span class="s1">for</span><span class="s0">(const t of e._refs.refs)t.ancestor-s&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.refs.push({ancestor:t.ancestor-s,root:t.root});</span><span class="s1">else </span><span class="s0">t.isRef(e)&amp;&amp;</span><span class="s2">&quot;value&quot;</span><span class="s0">===e.type&amp;&amp;e.ancestor-s&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">this</span><span class="s0">.refs.push({ancestor:e.ancestor-s,root:e.root}),o=o||r(</span><span class="s3">3328</span><span class="s0">),o.isTemplate(e)&amp;&amp;</span><span class="s1">this</span><span class="s0">.register(e.refs(),s)}get length(){</span><span class="s1">return this</span><span class="s0">.refs.length}clone(){const e=</span><span class="s1">new </span><span class="s0">t.Manager;</span><span class="s1">return </span><span class="s0">e.refs=n(</span><span class="s1">this</span><span class="s0">.refs),e}reset(){</span><span class="s1">this</span><span class="s0">.refs=[]}roots(){</span><span class="s1">return this</span><span class="s0">.refs.filter((e=&gt;!e.ancestor)).map((e=&gt;e.root))}}},</span><span class="s3">3378</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">5107</span><span class="s0">),n={};n.wrap=s.string().min(</span><span class="s3">1</span><span class="s0">).max(</span><span class="s3">2</span><span class="s0">).allow(!</span><span class="s3">1</span><span class="s0">),t.preferences=s.object({allowUnknown:s.boolean(),abortEarly:s.boolean(),artifacts:s.boolean(),cache:s.boolean(),context:s.object(),convert:s.boolean(),dateFormat:s.valid(</span><span class="s2">&quot;date&quot;</span><span class="s0">,</span><span class="s2">&quot;iso&quot;</span><span class="s0">,</span><span class="s2">&quot;string&quot;</span><span class="s0">,</span><span class="s2">&quot;time&quot;</span><span class="s0">,</span><span class="s2">&quot;utc&quot;</span><span class="s0">),debug:s.boolean(),errors:{escapeHtml:s.boolean(),label:s.valid(</span><span class="s2">&quot;path&quot;</span><span class="s0">,</span><span class="s2">&quot;key&quot;</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),language:[s.string(),s.object().ref()],render:s.boolean(),stack:s.boolean(),wrap:{label:n.wrap,array:n.wrap,string:n.wrap}},externals:s.boolean(),messages:s.object(),noDefaults:s.boolean(),nonEnumerables:s.boolean(),presence:s.valid(</span><span class="s2">&quot;required&quot;</span><span class="s0">,</span><span class="s2">&quot;optional&quot;</span><span class="s0">,</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">),skipFunctions:s.boolean(),stripUnknown:s.object({arrays:s.boolean(),objects:s.boolean()}).or(</span><span class="s2">&quot;arrays&quot;</span><span class="s0">,</span><span class="s2">&quot;objects&quot;</span><span class="s0">).allow(!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),warnings:s.boolean()}).strict(),n.nameRx=/^[a-zA-Z0-9]\w*$/,n.rule=s.object({alias:s.array().items(s.string().pattern(n.nameRx)).single(),args:s.array().items(s.string(),s.object({name:s.string().pattern(n.nameRx).required(),ref:s.boolean(),assert:s.alternatives([s.</span><span class="s1">function</span><span class="s0">(),s.object().schema()]).conditional(</span><span class="s2">&quot;ref&quot;</span><span class="s0">,{is:!</span><span class="s3">0</span><span class="s0">,then:s.required()}),normalize:s.</span><span class="s1">function</span><span class="s0">(),message:s.string().when(</span><span class="s2">&quot;assert&quot;</span><span class="s0">,{is:s.</span><span class="s1">function</span><span class="s0">(),then:s.required()})})),convert:s.boolean(),manifest:s.boolean(),method:s.</span><span class="s1">function</span><span class="s0">().allow(!</span><span class="s3">1</span><span class="s0">),multi:s.boolean(),validate:s.</span><span class="s1">function</span><span class="s0">()}),t.extension=s.object({type:s.alternatives([s.string(),s.object().regex()]).required(),args:s.</span><span class="s1">function</span><span class="s0">(),cast:s.object().pattern(n.nameRx,s.object({from:s.</span><span class="s1">function</span><span class="s0">().maxArity(</span><span class="s3">1</span><span class="s0">).required(),to:s.</span><span class="s1">function</span><span class="s0">().minArity(</span><span class="s3">1</span><span class="s0">).maxArity(</span><span class="s3">2</span><span class="s0">).required()})),base:s.object().schema().when(</span><span class="s2">&quot;type&quot;</span><span class="s0">,{is:s.object().regex(),then:s.forbidden()}),coerce:[s.</span><span class="s1">function</span><span class="s0">().maxArity(</span><span class="s3">3</span><span class="s0">),s.object({method:s.</span><span class="s1">function</span><span class="s0">().maxArity(</span><span class="s3">3</span><span class="s0">).required(),from:s.array().items(s.string()).single()})],flags:s.object().pattern(n.nameRx,s.object({setter:s.string(),</span><span class="s1">default</span><span class="s0">:s.any()})),manifest:{build:s.</span><span class="s1">function</span><span class="s0">().arity(</span><span class="s3">2</span><span class="s0">)},messages:[s.object(),s.string()],modifiers:s.object().pattern(n.nameRx,s.</span><span class="s1">function</span><span class="s0">().minArity(</span><span class="s3">1</span><span class="s0">).maxArity(</span><span class="s3">2</span><span class="s0">)),overrides:s.object().pattern(n.nameRx,s.</span><span class="s1">function</span><span class="s0">()),prepare:s.</span><span class="s1">function</span><span class="s0">().maxArity(</span><span class="s3">3</span><span class="s0">),rebuild:s.</span><span class="s1">function</span><span class="s0">().arity(</span><span class="s3">1</span><span class="s0">),rules:s.object().pattern(n.nameRx,n.rule),terms:s.object().pattern(n.nameRx,s.object({init:s.array().allow(</span><span class="s1">null</span><span class="s0">).required(),manifest:s.object().pattern(/.+/,[s.valid(</span><span class="s2">&quot;schema&quot;</span><span class="s0">,</span><span class="s2">&quot;single&quot;</span><span class="s0">),s.object({mapped:s.object({from:s.string().required(),to:s.string().required()}).required()})])})),validate:s.</span><span class="s1">function</span><span class="s0">().maxArity(</span><span class="s3">3</span><span class="s0">)}).strict(),t.extensions=s.array().items(s.object(),s.</span><span class="s1">function</span><span class="s0">().arity(</span><span class="s3">1</span><span class="s0">)).strict(),n.desc={buffer:s.object({buffer:s.string()}),func:s.object({</span><span class="s1">function</span><span class="s0">:s.</span><span class="s1">function</span><span class="s0">().required(),options:{literal:!</span><span class="s3">0</span><span class="s0">}}),override:s.object({override:!</span><span class="s3">0</span><span class="s0">}),ref:s.object({ref:s.object({type:s.valid(</span><span class="s2">&quot;value&quot;</span><span class="s0">,</span><span class="s2">&quot;global&quot;</span><span class="s0">,</span><span class="s2">&quot;local&quot;</span><span class="s0">),path:s.array().required(),separator:s.string().length(</span><span class="s3">1</span><span class="s0">).allow(!</span><span class="s3">1</span><span class="s0">),ancestor:s.number().min(</span><span class="s3">0</span><span class="s0">).integer().allow(</span><span class="s2">&quot;root&quot;</span><span class="s0">),map:s.array().items(s.array().length(</span><span class="s3">2</span><span class="s0">)).min(</span><span class="s3">1</span><span class="s0">),adjust:s.</span><span class="s1">function</span><span class="s0">(),iterables:s.boolean(),</span><span class="s1">in</span><span class="s0">:s.boolean(),render:s.boolean()}).required()}),regex:s.object({regex:s.string().min(</span><span class="s3">3</span><span class="s0">)}),special:s.object({special:s.valid(</span><span class="s2">&quot;deep&quot;</span><span class="s0">).required()}),template:s.object({template:s.string().required(),options:s.object()}),value:s.object({value:s.alternatives([s.object(),s.array()]).required()})},n.desc.entity=s.alternatives([s.array().items(s.link(</span><span class="s2">&quot;...&quot;</span><span class="s0">)),s.boolean(),s.</span><span class="s1">function</span><span class="s0">(),s.number(),s.string(),n.desc.buffer,n.desc.func,n.desc.ref,n.desc.regex,n.desc.special,n.desc.template,n.desc.value,s.link(</span><span class="s2">&quot;/&quot;</span><span class="s0">)]),n.desc.values=s.array().items(</span><span class="s1">null</span><span class="s0">,s.boolean(),s.</span><span class="s1">function</span><span class="s0">(),s.number().allow(</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">),s.string().allow(</span><span class="s2">&quot;&quot;</span><span class="s0">),s.symbol(),n.desc.buffer,n.desc.func,n.desc.override,n.desc.ref,n.desc.regex,n.desc.template,n.desc.value),n.desc.messages=s.object().pattern(/.+/,[s.string(),n.desc.template,s.object().pattern(/.+/,[s.string(),n.desc.template])]),t.description=s.object({type:s.string().required(),flags:s.object({cast:s.string(),</span><span class="s1">default</span><span class="s0">:s.any(),description:s.string(),empty:s.link(</span><span class="s2">&quot;/&quot;</span><span class="s0">),failover:n.desc.entity,id:s.string(),label:s.string(),only:!</span><span class="s3">0</span><span class="s0">,presence:[</span><span class="s2">&quot;optional&quot;</span><span class="s0">,</span><span class="s2">&quot;required&quot;</span><span class="s0">,</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">],result:[</span><span class="s2">&quot;raw&quot;</span><span class="s0">,</span><span class="s2">&quot;strip&quot;</span><span class="s0">],strip:s.boolean(),unit:s.string()}).unknown(),preferences:{allowUnknown:s.boolean(),abortEarly:s.boolean(),artifacts:s.boolean(),cache:s.boolean(),convert:s.boolean(),dateFormat:[</span><span class="s2">&quot;date&quot;</span><span class="s0">,</span><span class="s2">&quot;iso&quot;</span><span class="s0">,</span><span class="s2">&quot;string&quot;</span><span class="s0">,</span><span class="s2">&quot;time&quot;</span><span class="s0">,</span><span class="s2">&quot;utc&quot;</span><span class="s0">],errors:{escapeHtml:s.boolean(),label:[</span><span class="s2">&quot;path&quot;</span><span class="s0">,</span><span class="s2">&quot;key&quot;</span><span class="s0">],language:[s.string(),n.desc.ref],wrap:{label:n.wrap,array:n.wrap}},externals:s.boolean(),messages:n.desc.messages,noDefaults:s.boolean(),nonEnumerables:s.boolean(),presence:[</span><span class="s2">&quot;required&quot;</span><span class="s0">,</span><span class="s2">&quot;optional&quot;</span><span class="s0">,</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">],skipFunctions:s.boolean(),stripUnknown:s.object({arrays:s.boolean(),objects:s.boolean()}).or(</span><span class="s2">&quot;arrays&quot;</span><span class="s0">,</span><span class="s2">&quot;objects&quot;</span><span class="s0">).allow(!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),warnings:s.boolean()},allow:n.desc.values,invalid:n.desc.values,rules:s.array().min(</span><span class="s3">1</span><span class="s0">).items({name:s.string().required(),args:s.object().min(</span><span class="s3">1</span><span class="s0">),keep:s.boolean(),message:[s.string(),n.desc.messages],warn:s.boolean()}),keys:s.object().pattern(/.*/,s.link(</span><span class="s2">&quot;/&quot;</span><span class="s0">)),link:n.desc.ref}).pattern(/^[a-z]\w*$/,s.any())},</span><span class="s3">493</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">8571</span><span class="s0">),n=r(</span><span class="s3">9621</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i={value:Symbol(</span><span class="s2">&quot;value&quot;</span><span class="s0">)};e.exports=i.State=class{constructor(e,t,r){</span><span class="s1">this</span><span class="s0">.path=e,</span><span class="s1">this</span><span class="s0">.ancestors=t,</span><span class="s1">this</span><span class="s0">.mainstay=r.mainstay,</span><span class="s1">this</span><span class="s0">.schemas=r.schemas,</span><span class="s1">this</span><span class="s0">.debug=</span><span class="s1">null</span><span class="s0">}localize(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">,r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;const s=</span><span class="s1">new </span><span class="s0">i.State(e,t,</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r&amp;&amp;s.schemas&amp;&amp;(s.schemas=[i.schemas(r),...s.schemas]),s}nest(e,t){const r=</span><span class="s1">new </span><span class="s0">i.State(</span><span class="s1">this</span><span class="s0">.path,</span><span class="s1">this</span><span class="s0">.ancestors,</span><span class="s1">this</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r.schemas=r.schemas&amp;&amp;[i.schemas(e),...r.schemas],r.debug=t,r}shadow(e,t){</span><span class="s1">this</span><span class="s0">.mainstay.shadow=</span><span class="s1">this</span><span class="s0">.mainstay.shadow||</span><span class="s1">new </span><span class="s0">i.Shadow,</span><span class="s1">this</span><span class="s0">.mainstay.shadow.set(</span><span class="s1">this</span><span class="s0">.path,e,t)}snapshot(){</span><span class="s1">this</span><span class="s0">.mainstay.shadow&amp;&amp;(</span><span class="s1">this</span><span class="s0">._snapshot=s(</span><span class="s1">this</span><span class="s0">.mainstay.shadow.node(</span><span class="s1">this</span><span class="s0">.path))),</span><span class="s1">this</span><span class="s0">.mainstay.snapshot()}restore(){</span><span class="s1">this</span><span class="s0">.mainstay.shadow&amp;&amp;(</span><span class="s1">this</span><span class="s0">.mainstay.shadow.override(</span><span class="s1">this</span><span class="s0">.path,</span><span class="s1">this</span><span class="s0">._snapshot),</span><span class="s1">this</span><span class="s0">._snapshot=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.mainstay.restore()}commit(){</span><span class="s1">this</span><span class="s0">.mainstay.shadow&amp;&amp;(</span><span class="s1">this</span><span class="s0">.mainstay.shadow.override(</span><span class="s1">this</span><span class="s0">.path,</span><span class="s1">this</span><span class="s0">._snapshot),</span><span class="s1">this</span><span class="s0">._snapshot=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.mainstay.commit()}},i.schemas=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">a.isSchema(e)?{schema:e}:e},i.Shadow=class{constructor(){</span><span class="s1">this</span><span class="s0">._values=</span><span class="s1">null</span><span class="s0">}set(e,t,r){</span><span class="s1">if</span><span class="s0">(!e.length)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;strip&quot;</span><span class="s0">===r&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e[e.length-1])</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">._values=</span><span class="s1">this</span><span class="s0">._values||</span><span class="s1">new </span><span class="s0">Map;let s=</span><span class="s1">this</span><span class="s0">._values;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;e.length;++t){const r=e[t];let n=s.get(r);n||(n=</span><span class="s1">new </span><span class="s0">Map,s.set(r,n)),s=n}s[i.value]=t}get(e){const t=</span><span class="s1">this</span><span class="s0">.node(e);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">t[i.value]}node(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">._values)</span><span class="s1">return </span><span class="s0">n(</span><span class="s1">this</span><span class="s0">._values,e,{iterables:!</span><span class="s3">0</span><span class="s0">})}override(e,t){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._values)</span><span class="s1">return</span><span class="s0">;const r=e.slice(</span><span class="s3">0</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">),s=e[e.length-1],a=n(</span><span class="s1">this</span><span class="s0">._values,r,{iterables:!</span><span class="s3">0</span><span class="s0">});t?a.set(s,t):a&amp;&amp;a.</span><span class="s1">delete</span><span class="s0">(s)}}},</span><span class="s3">3328</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">5277</span><span class="s0">),i=r(</span><span class="s3">1447</span><span class="s0">),o=r(</span><span class="s3">8160</span><span class="s0">),l=r(</span><span class="s3">6354</span><span class="s0">),c=r(</span><span class="s3">6133</span><span class="s0">),u={symbol:Symbol(</span><span class="s2">&quot;template&quot;</span><span class="s0">),opens:</span><span class="s1">new </span><span class="s0">Array(</span><span class="s3">1</span><span class="s0">e3).join(</span><span class="s2">&quot;</span><span class="s4">\0</span><span class="s2">&quot;</span><span class="s0">),closes:</span><span class="s1">new </span><span class="s0">Array(</span><span class="s3">1</span><span class="s0">e3).join(</span><span class="s2">&quot;&quot;</span><span class="s0">),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};e.exports=u.Template=class{constructor(e,t){s(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Template source must be a string&quot;</span><span class="s0">),s(!e.includes(</span><span class="s2">&quot;</span><span class="s4">\0</span><span class="s2">&quot;</span><span class="s0">)&amp;&amp;!e.includes(</span><span class="s2">&quot;&quot;</span><span class="s0">),</span><span class="s2">&quot;Template source cannot contain reserved control characters&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.source=e,</span><span class="s1">this</span><span class="s0">.rendered=e,</span><span class="s1">this</span><span class="s0">._template=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._settings=n(t),</span><span class="s1">this</span><span class="s0">._parse()}_parse(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.source.includes(</span><span class="s2">&quot;{&quot;</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;const e=u.encode(</span><span class="s1">this</span><span class="s0">.source),t=u.split(e);let r=!</span><span class="s3">1</span><span class="s0">;const s=[],n=t.shift();n&amp;&amp;s.push(n);</span><span class="s1">for</span><span class="s0">(const e of t){const t=</span><span class="s2">&quot;{&quot;</span><span class="s0">!==e[</span><span class="s3">0</span><span class="s0">],n=t?</span><span class="s2">&quot;}&quot;</span><span class="s0">:</span><span class="s2">&quot;}}&quot;</span><span class="s0">,a=e.indexOf(n);</span><span class="s1">if</span><span class="s0">(-</span><span class="s3">1</span><span class="s0">===a||</span><span class="s2">&quot;{&quot;</span><span class="s0">===e[</span><span class="s3">1</span><span class="s0">]){s.push(`{${u.decode(e)}`);</span><span class="s1">continue</span><span class="s0">}let i=e.slice(t?</span><span class="s3">0</span><span class="s0">:</span><span class="s3">1</span><span class="s0">,a);const o=</span><span class="s2">&quot;:&quot;</span><span class="s0">===i[</span><span class="s3">0</span><span class="s0">];o&amp;&amp;(i=i.slice(</span><span class="s3">1</span><span class="s0">));const l=</span><span class="s1">this</span><span class="s0">._ref(u.decode(i),{raw:t,wrapped:o});s.push(l),</span><span class="s2">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">l&amp;&amp;(r=!</span><span class="s3">0</span><span class="s0">);const c=e.slice(a+n.length);c&amp;&amp;s.push(u.decode(c))}r?</span><span class="s1">this</span><span class="s0">._template=s:</span><span class="s1">this</span><span class="s0">.rendered=s.join(</span><span class="s2">&quot;&quot;</span><span class="s0">)}static date(e,t){</span><span class="s1">return </span><span class="s0">u.dateFormat[t.dateFormat].call(e)}describe(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._settings&amp;&amp;e.compact)</span><span class="s1">return this</span><span class="s0">.source;const t={template:</span><span class="s1">this</span><span class="s0">.source};</span><span class="s1">return this</span><span class="s0">._settings&amp;&amp;(t.options=</span><span class="s1">this</span><span class="s0">._settings),t}static build(e){</span><span class="s1">return new </span><span class="s0">u.Template(e.template,e.options)}isDynamic(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">._template}static isTemplate(e){</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;!!e[o.symbols.template]}refs(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._template)</span><span class="s1">return</span><span class="s0">;const e=[];</span><span class="s1">for</span><span class="s0">(const t of </span><span class="s1">this</span><span class="s0">._template)</span><span class="s2">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;e.push(...t.refs);</span><span class="s1">return </span><span class="s0">e}resolve(e,t,r,s){</span><span class="s1">return this</span><span class="s0">._template&amp;&amp;</span><span class="s3">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">._template.length?</span><span class="s1">this</span><span class="s0">._part(</span><span class="s1">this</span><span class="s0">._template[</span><span class="s3">0</span><span class="s0">],e,t,r,s,{}):</span><span class="s1">this</span><span class="s0">.render(e,t,r,s)}_part(e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">t=arguments.length,r=</span><span class="s1">new </span><span class="s0">Array(t&gt;</span><span class="s3">1</span><span class="s0">?t-1:</span><span class="s3">0</span><span class="s0">),s=</span><span class="s3">1</span><span class="s0">;s&lt;t;s++)r[s-1]=arguments[s];</span><span class="s1">return </span><span class="s0">e.ref?e.ref.resolve(...r):e.formula.evaluate(r)}render(e,t,r,s){let n=arguments.length&gt;</span><span class="s3">4</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">4</span><span class="s0">]?arguments[</span><span class="s3">4</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isDynamic())</span><span class="s1">return this</span><span class="s0">.rendered;const i=[];</span><span class="s1">for</span><span class="s0">(const o of </span><span class="s1">this</span><span class="s0">._template)</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o)i.push(o);</span><span class="s1">else</span><span class="s0">{const l=</span><span class="s1">this</span><span class="s0">._part(o,e,t,r,s,n),c=u.stringify(l,e,t,r,s,n);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==c){const e=o.raw||!</span><span class="s3">1</span><span class="s0">===(n.errors&amp;&amp;n.errors.escapeHtml)?c:a(c);i.push(u.wrap(e,o.wrapped&amp;&amp;r.errors.wrap.label))}}</span><span class="s1">return </span><span class="s0">i.join(</span><span class="s2">&quot;&quot;</span><span class="s0">)}_ref(e,t){let{raw:r,wrapped:s}=t;const n=[],a=e=&gt;{const t=c.create(e,</span><span class="s1">this</span><span class="s0">._settings);</span><span class="s1">return </span><span class="s0">n.push(t),e=&gt;t.resolve(...e)};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">var </span><span class="s0">o=</span><span class="s1">new </span><span class="s0">i.Parser(e,{reference:a,functions:u.functions,constants:u.constants})}</span><span class="s1">catch</span><span class="s0">(t){</span><span class="s1">throw </span><span class="s0">t.message=`Invalid template variable </span><span class="s2">&quot;${e}&quot; </span><span class="s0">fails due to: ${t.message}`,t}</span><span class="s1">if</span><span class="s0">(o.single){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;reference&quot;</span><span class="s0">===o.single.type){const e=n[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return</span><span class="s0">{ref:e,raw:r,refs:n,wrapped:s||</span><span class="s2">&quot;local&quot;</span><span class="s0">===e.type&amp;&amp;</span><span class="s2">&quot;label&quot;</span><span class="s0">===e.key}}</span><span class="s1">return </span><span class="s0">u.stringify(o.single.value)}</span><span class="s1">return</span><span class="s0">{formula:o,raw:r,refs:n}}toString(){</span><span class="s1">return this</span><span class="s0">.source}},u.Template.prototype[o.symbols.template]=!</span><span class="s3">0</span><span class="s0">,u.Template.prototype.isImmutable=!</span><span class="s3">0</span><span class="s0">,u.encode=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e.replace(/\\(\{+)/g,((e,t)=&gt;u.opens.slice(</span><span class="s3">0</span><span class="s0">,t.length))).replace(/\\(\}+)/g,((e,t)=&gt;u.closes.slice(</span><span class="s3">0</span><span class="s0">,t.length)))},u.decode=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e.replace(/\u0000/g,</span><span class="s2">&quot;{&quot;</span><span class="s0">).replace(/\u0001/g,</span><span class="s2">&quot;}&quot;</span><span class="s0">)},u.split=</span><span class="s1">function</span><span class="s0">(e){const t=[];let r=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">;s&lt;e.length;++s){const n=e[s];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;{&quot;</span><span class="s0">===n){let n=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;s+</span><span class="s3">1</span><span class="s0">&lt;e.length&amp;&amp;</span><span class="s2">&quot;{&quot;</span><span class="s0">===e[s+</span><span class="s3">1</span><span class="s0">];)n+=</span><span class="s2">&quot;{&quot;</span><span class="s0">,++s;t.push(r),r=n}</span><span class="s1">else </span><span class="s0">r+=n}</span><span class="s1">return </span><span class="s0">t.push(r),t},u.wrap=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">t?</span><span class="s3">1</span><span class="s0">===t.length?`${t}${e}${t}`:`${t[</span><span class="s3">0</span><span class="s0">]}${e}${t[</span><span class="s3">1</span><span class="s0">]}`:e},u.stringify=</span><span class="s1">function</span><span class="s0">(e,t,r,s,n){let a=arguments.length&gt;</span><span class="s3">5</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">5</span><span class="s0">]?arguments[</span><span class="s3">5</span><span class="s0">]:{};const i=</span><span class="s1">typeof </span><span class="s0">e,o=s&amp;&amp;s.errors&amp;&amp;s.errors.wrap||{};let l=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(c.isRef(e)&amp;&amp;e.render&amp;&amp;(l=e.</span><span class="s1">in</span><span class="s0">,e=e.resolve(t,r,s,n,{</span><span class="s1">in</span><span class="s0">:e.</span><span class="s1">in</span><span class="s0">,...a})),</span><span class="s1">null</span><span class="s0">===e)</span><span class="s1">return</span><span class="s2">&quot;null&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">===i)</span><span class="s1">return </span><span class="s0">u.wrap(e,a.arrayItems&amp;&amp;o.string);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;number&quot;</span><span class="s0">===i||</span><span class="s2">&quot;function&quot;</span><span class="s0">===i||</span><span class="s2">&quot;symbol&quot;</span><span class="s0">===i)</span><span class="s1">return </span><span class="s0">e.toString();</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;object&quot;</span><span class="s0">!==i)</span><span class="s1">return </span><span class="s0">JSON.stringify(e);</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">Date)</span><span class="s1">return </span><span class="s0">u.Template.date(e,s);</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">Map){const t=[];</span><span class="s1">for</span><span class="s0">(const[r,s]of e.entries())t.push(`${r.toString()} -&gt; ${s.toString()}`);e=t}</span><span class="s1">if</span><span class="s0">(!Array.isArray(e))</span><span class="s1">return </span><span class="s0">e.toString();const f=[];</span><span class="s1">for</span><span class="s0">(const i of e)f.push(u.stringify(i,t,r,s,n,{arrayItems:!</span><span class="s3">0</span><span class="s0">,...a}));</span><span class="s1">return </span><span class="s0">u.wrap(f.join(</span><span class="s2">&quot;, &quot;</span><span class="s0">),!l&amp;&amp;o.array)},u.constants={</span><span class="s1">true</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">false</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">null</span><span class="s0">:</span><span class="s1">null</span><span class="s0">,second:</span><span class="s3">1</span><span class="s0">e3,minute:</span><span class="s3">6</span><span class="s0">e4,hour:</span><span class="s3">36</span><span class="s0">e5,day:</span><span class="s3">864</span><span class="s0">e5},u.functions={</span><span class="s1">if</span><span class="s0">:(e,t,r)=&gt;e?t:r,length:e=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?e.length:e&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?Array.isArray(e)?e.length:Object.keys(e).length:</span><span class="s1">null</span><span class="s0">,msg(e){const[t,r,s,n,a]=</span><span class="s1">this</span><span class="s0">,i=a.messages;</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return</span><span class="s2">&quot;&quot;</span><span class="s0">;const o=l.template(t,i[</span><span class="s3">0</span><span class="s0">],e,r,s)||l.template(t,i[</span><span class="s3">1</span><span class="s0">],e,r,s);</span><span class="s1">return </span><span class="s0">o?o.render(t,r,s,n,a):</span><span class="s2">&quot;&quot;</span><span class="s0">},number:e=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?e:</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?parseFloat(e):</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?e?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">:e </span><span class="s1">instanceof </span><span class="s0">Date?e.getTime():</span><span class="s1">null</span><span class="s0">}},</span><span class="s3">4946</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">1687</span><span class="s0">),a=r(</span><span class="s3">8068</span><span class="s0">),i=r(</span><span class="s3">8160</span><span class="s0">),o=r(</span><span class="s3">3292</span><span class="s0">),l=r(</span><span class="s3">6354</span><span class="s0">),c=r(</span><span class="s3">6133</span><span class="s0">),u={};e.exports=a.extend({type:</span><span class="s2">&quot;alternatives&quot;</span><span class="s0">,flags:{match:{</span><span class="s1">default</span><span class="s0">:</span><span class="s2">&quot;any&quot;</span><span class="s0">}},terms:{matches:{init:[],register:c.toSibling}},args(e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">t=arguments.length,r=</span><span class="s1">new </span><span class="s0">Array(t&gt;</span><span class="s3">1</span><span class="s0">?t-1:</span><span class="s3">0</span><span class="s0">),s=</span><span class="s3">1</span><span class="s0">;s&lt;t;s++)r[s-1]=arguments[s];</span><span class="s1">return </span><span class="s3">1</span><span class="s0">===r.length&amp;&amp;Array.isArray(r[</span><span class="s3">0</span><span class="s0">])?e.</span><span class="s1">try</span><span class="s0">(...r[</span><span class="s3">0</span><span class="s0">]):e.</span><span class="s1">try</span><span class="s0">(...r)},validate(e,t){const{schema:r,error:s,state:a,prefs:i}=t;</span><span class="s1">if</span><span class="s0">(r._flags.match){const t=[],o=[];</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">;s&lt;r.$_terms.matches.length;++s){const n=r.$_terms.matches[s],l=a.nest(n.schema,`match.${s}`);l.snapshot();const c=n.schema.$_validate(e,l,i);c.errors?(o.push(c.errors),l.restore()):(t.push(c.value),l.commit())}</span><span class="s1">if</span><span class="s0">(</span><span class="s3">0</span><span class="s0">===t.length)</span><span class="s1">return</span><span class="s0">{errors:s(</span><span class="s2">&quot;alternatives.any&quot;</span><span class="s0">,{details:o.map((e=&gt;l.details(e,{override:!</span><span class="s3">1</span><span class="s0">})))})};</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;one&quot;</span><span class="s0">===r._flags.match)</span><span class="s1">return </span><span class="s3">1</span><span class="s0">===t.length?{value:t[</span><span class="s3">0</span><span class="s0">]}:{errors:s(</span><span class="s2">&quot;alternatives.one&quot;</span><span class="s0">)};</span><span class="s1">if</span><span class="s0">(t.length!==r.$_terms.matches.length)</span><span class="s1">return</span><span class="s0">{errors:s(</span><span class="s2">&quot;alternatives.all&quot;</span><span class="s0">,{details:o.map((e=&gt;l.details(e,{override:!</span><span class="s3">1</span><span class="s0">})))})};const c=e=&gt;e.$_terms.matches.some((e=&gt;</span><span class="s2">&quot;object&quot;</span><span class="s0">===e.schema.type||</span><span class="s2">&quot;alternatives&quot;</span><span class="s0">===e.schema.type&amp;&amp;c(e.schema)));</span><span class="s1">return </span><span class="s0">c(r)?{value:t.reduce(((e,t)=&gt;n(e,t,{mergeArrays:!</span><span class="s3">1</span><span class="s0">})))}:{value:t[t.length-1]}}const o=[];</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;r.$_terms.matches.length;++t){const s=r.$_terms.matches[t];</span><span class="s1">if</span><span class="s0">(s.schema){const r=a.nest(s.schema,`match.${t}`);r.snapshot();const n=s.schema.$_validate(e,r,i);</span><span class="s1">if</span><span class="s0">(!n.errors)</span><span class="s1">return </span><span class="s0">r.commit(),n;r.restore(),o.push({schema:s.schema,reports:n.errors});</span><span class="s1">continue</span><span class="s0">}const n=s.ref?s.ref.resolve(e,a,i):e,l=s.is?[s]:s.</span><span class="s1">switch</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s3">0</span><span class="s0">;r&lt;l.length;++r){const o=l[r],{is:c,then:u,otherwise:f}=o,h=`match.${t}${s.</span><span class="s1">switch</span><span class="s0">?</span><span class="s2">&quot;.&quot;</span><span class="s0">+r:</span><span class="s2">&quot;&quot;</span><span class="s0">}`;</span><span class="s1">if</span><span class="s0">(c.$_match(n,a.nest(c,`${h}.is`),i)){</span><span class="s1">if</span><span class="s0">(u)</span><span class="s1">return </span><span class="s0">u.$_validate(e,a.nest(u,`${h}.then`),i)}</span><span class="s1">else if</span><span class="s0">(f)</span><span class="s1">return </span><span class="s0">f.$_validate(e,a.nest(f,`${h}.otherwise`),i)}}</span><span class="s1">return </span><span class="s0">u.errors(o,t)},rules:{conditional:{method(e,t){s(!</span><span class="s1">this</span><span class="s0">._flags._endedSwitch,</span><span class="s2">&quot;Unreachable condition&quot;</span><span class="s0">),s(!</span><span class="s1">this</span><span class="s0">._flags.match,</span><span class="s2">&quot;Cannot combine match mode&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._flags.match,</span><span class="s2">&quot;with conditional rule&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t.</span><span class="s1">break</span><span class="s0">,</span><span class="s2">&quot;Cannot use break option with alternatives conditional&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.clone(),n=o.when(r,e,t),a=n.is?[n]:n.</span><span class="s1">switch</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const e of a)</span><span class="s1">if</span><span class="s0">(e.then&amp;&amp;e.otherwise){r.$_setFlag(</span><span class="s2">&quot;_endedSwitch&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,{clone:!</span><span class="s3">1</span><span class="s0">});</span><span class="s1">break</span><span class="s0">}</span><span class="s1">return </span><span class="s0">r.$_terms.matches.push(n),r.$_mutateRebuild()}},match:{method(e){</span><span class="s1">if</span><span class="s0">(s([</span><span class="s2">&quot;any&quot;</span><span class="s0">,</span><span class="s2">&quot;one&quot;</span><span class="s0">,</span><span class="s2">&quot;all&quot;</span><span class="s0">].includes(e),</span><span class="s2">&quot;Invalid alternatives match mode&quot;</span><span class="s0">,e),</span><span class="s2">&quot;any&quot;</span><span class="s0">!==e)</span><span class="s1">for</span><span class="s0">(const t of </span><span class="s1">this</span><span class="s0">.$_terms.matches)s(t.schema,</span><span class="s2">&quot;Cannot combine match mode&quot;</span><span class="s0">,e,</span><span class="s2">&quot;with conditional rules&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;match&quot;</span><span class="s0">,e)}},</span><span class="s1">try</span><span class="s0">:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];s(t.length,</span><span class="s2">&quot;Missing alternative schemas&quot;</span><span class="s0">),i.verifyFlat(t,</span><span class="s2">&quot;try&quot;</span><span class="s0">),s(!</span><span class="s1">this</span><span class="s0">._flags._endedSwitch,</span><span class="s2">&quot;Unreachable condition&quot;</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">for</span><span class="s0">(const e of t)n.$_terms.matches.push({schema:n.$_compile(e)});</span><span class="s1">return </span><span class="s0">n.$_mutateRebuild()}}},overrides:{label(e){</span><span class="s1">return this</span><span class="s0">.$_parent(</span><span class="s2">&quot;label&quot;</span><span class="s0">,e).$_modify({each:(t,r)=&gt;</span><span class="s2">&quot;is&quot;</span><span class="s0">!==r.path[</span><span class="s3">0</span><span class="s0">]?t.label(e):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,ref:!</span><span class="s3">1</span><span class="s0">})}},rebuild(e){e.$_modify({each:t=&gt;{i.isSchema(t)&amp;&amp;</span><span class="s2">&quot;array&quot;</span><span class="s0">===t.type&amp;&amp;e.$_setFlag(</span><span class="s2">&quot;_arrayItems&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,{clone:!</span><span class="s3">1</span><span class="s0">})}})},manifest:{build(e,t){</span><span class="s1">if</span><span class="s0">(t.matches)</span><span class="s1">for</span><span class="s0">(const r of t.matches){const{schema:t,ref:s,is:n,not:a,then:i,otherwise:o}=r;e=t?e.</span><span class="s1">try</span><span class="s0">(t):s?e.conditional(s,{is:n,then:i,not:a,otherwise:o,</span><span class="s1">switch</span><span class="s0">:r.</span><span class="s1">switch</span><span class="s0">}):e.conditional(n,{then:i,otherwise:o})}</span><span class="s1">return </span><span class="s0">e}},messages:{</span><span class="s2">&quot;alternatives.all&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not match all of the required types&quot;</span><span class="s0">,</span><span class="s2">&quot;alternatives.any&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not match any of the allowed types&quot;</span><span class="s0">,</span><span class="s2">&quot;alternatives.match&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not match any of the allowed types&quot;</span><span class="s0">,</span><span class="s2">&quot;alternatives.one&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} matches more than one allowed type&quot;</span><span class="s0">,</span><span class="s2">&quot;alternatives.types&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be one of {{#types}}&quot;</span><span class="s0">}}),u.errors=</span><span class="s1">function</span><span class="s0">(e,t){let{error:r,state:s}=t;</span><span class="s1">if</span><span class="s0">(!e.length)</span><span class="s1">return</span><span class="s0">{errors:r(</span><span class="s2">&quot;alternatives.any&quot;</span><span class="s0">)};</span><span class="s1">if</span><span class="s0">(</span><span class="s3">1</span><span class="s0">===e.length)</span><span class="s1">return</span><span class="s0">{errors:e[</span><span class="s3">0</span><span class="s0">].reports};const n=</span><span class="s1">new </span><span class="s0">Set,a=[];</span><span class="s1">for</span><span class="s0">(const{reports:t,schema:i}of e){</span><span class="s1">if</span><span class="s0">(t.length&gt;</span><span class="s3">1</span><span class="s0">)</span><span class="s1">return </span><span class="s0">u.unmatched(e,r);const o=t[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(o </span><span class="s1">instanceof </span><span class="s0">l.Report==</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return </span><span class="s0">u.unmatched(e,r);</span><span class="s1">if</span><span class="s0">(o.state.path.length!==s.path.length){a.push({type:i.type,report:o});</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;any.only&quot;</span><span class="s0">===o.code){</span><span class="s1">for</span><span class="s0">(const e of o.local.valids)n.add(e);</span><span class="s1">continue</span><span class="s0">}const[c,f]=o.code.split(</span><span class="s2">&quot;.&quot;</span><span class="s0">);</span><span class="s2">&quot;base&quot;</span><span class="s0">===f?n.add(c):a.push({type:i.type,report:o})}</span><span class="s1">return </span><span class="s0">a.length?</span><span class="s3">1</span><span class="s0">===a.length?{errors:a[</span><span class="s3">0</span><span class="s0">].report}:u.unmatched(e,r):{errors:r(</span><span class="s2">&quot;alternatives.types&quot;</span><span class="s0">,{types:[...n]})}},u.unmatched=</span><span class="s1">function</span><span class="s0">(e,t){const r=[];</span><span class="s1">for</span><span class="s0">(const t of e)r.push(...t.reports);</span><span class="s1">return</span><span class="s0">{errors:t(</span><span class="s2">&quot;alternatives.match&quot;</span><span class="s0">,l.details(r,{override:!</span><span class="s3">1</span><span class="s0">}))}}},</span><span class="s3">8068</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">7629</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i=r(</span><span class="s3">6914</span><span class="s0">);e.exports=n.extend({type:</span><span class="s2">&quot;any&quot;</span><span class="s0">,flags:{only:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">}},terms:{alterations:{init:</span><span class="s1">null</span><span class="s0">},examples:{init:</span><span class="s1">null</span><span class="s0">},externals:{init:</span><span class="s1">null</span><span class="s0">},metas:{init:[]},notes:{init:[]},shared:{init:</span><span class="s1">null</span><span class="s0">},tags:{init:[]},whens:{init:</span><span class="s1">null</span><span class="s0">}},rules:{custom:{method(e,t){</span><span class="s1">return </span><span class="s0">s(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Method must be a function&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t||t&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,</span><span class="s2">&quot;Description must be a non-empty string&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;custom&quot;</span><span class="s0">,args:{method:e,description:t}})},validate(e,t,r){let{method:s}=r;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">s(e,t)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">t.error(</span><span class="s2">&quot;any.custom&quot;</span><span class="s0">,{error:e})}},args:[</span><span class="s2">&quot;method&quot;</span><span class="s0">,</span><span class="s2">&quot;description&quot;</span><span class="s0">],multi:!</span><span class="s3">0</span><span class="s0">},messages:{method(e){</span><span class="s1">return this</span><span class="s0">.prefs({messages:e})}},shared:{method(e){s(a.isSchema(e)&amp;&amp;e._flags.id,</span><span class="s2">&quot;Schema must be a schema with an id&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return </span><span class="s0">t.$_terms.shared=t.$_terms.shared||[],t.$_terms.shared.push(e),t.$_mutateRegister(e),t}},warning:{method(e,t){</span><span class="s1">return </span><span class="s0">s(e&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid warning code&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;warning&quot;</span><span class="s0">,args:{code:e,local:t},warn:!</span><span class="s3">0</span><span class="s0">})},validate(e,t,r){let{code:s,local:n}=r;</span><span class="s1">return </span><span class="s0">t.error(s,n)},args:[</span><span class="s2">&quot;code&quot;</span><span class="s0">,</span><span class="s2">&quot;local&quot;</span><span class="s0">],multi:!</span><span class="s3">0</span><span class="s0">}},modifiers:{keep(e){let t=!(arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">])||arguments[</span><span class="s3">1</span><span class="s0">];e.keep=t},message(e,t){e.message=i.compile(t)},warn(e){let t=!(arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">])||arguments[</span><span class="s3">1</span><span class="s0">];e.warn=t}},manifest:{build(e,t){</span><span class="s1">for</span><span class="s0">(const r </span><span class="s1">in </span><span class="s0">t){const s=t[r];</span><span class="s1">if</span><span class="s0">([</span><span class="s2">&quot;examples&quot;</span><span class="s0">,</span><span class="s2">&quot;externals&quot;</span><span class="s0">,</span><span class="s2">&quot;metas&quot;</span><span class="s0">,</span><span class="s2">&quot;notes&quot;</span><span class="s0">,</span><span class="s2">&quot;tags&quot;</span><span class="s0">].includes(r))</span><span class="s1">for</span><span class="s0">(const t of s)e=e[r.slice(</span><span class="s3">0</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">)](t);</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">&quot;alterations&quot;</span><span class="s0">!==r)</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;whens&quot;</span><span class="s0">!==r){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;shared&quot;</span><span class="s0">===r)</span><span class="s1">for</span><span class="s0">(const t of s)e=e.shared(t)}</span><span class="s1">else for</span><span class="s0">(const t of s){const{ref:r,is:s,not:n,then:a,otherwise:i,concat:o}=t;e=o?e.concat(o):r?e.when(r,{is:s,not:n,then:a,otherwise:i,</span><span class="s1">switch</span><span class="s0">:t.</span><span class="s1">switch</span><span class="s0">,</span><span class="s1">break</span><span class="s0">:t.</span><span class="s1">break</span><span class="s0">}):e.when(s,{then:a,otherwise:i,</span><span class="s1">break</span><span class="s0">:t.</span><span class="s1">break</span><span class="s0">})}</span><span class="s1">else</span><span class="s0">{const t={};</span><span class="s1">for</span><span class="s0">(const{target:e,adjuster:r}of s)t[e]=r;e=e.alter(t)}}</span><span class="s1">return </span><span class="s0">e}},messages:{</span><span class="s2">&quot;any.custom&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} failed custom validation because {{#error.message}}&quot;</span><span class="s0">,</span><span class="s2">&quot;any.default&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} threw an error when running default method&quot;</span><span class="s0">,</span><span class="s2">&quot;any.failover&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} threw an error when running failover method&quot;</span><span class="s0">,</span><span class="s2">&quot;any.invalid&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} contains an invalid value&quot;</span><span class="s0">,</span><span class="s2">&quot;any.only&quot;</span><span class="s0">:</span><span class="s2">'{{#label}} must be {if(#valids.length == 1, &quot;&quot;, &quot;one of &quot;)}{{#valids}}'</span><span class="s0">,</span><span class="s2">&quot;any.ref&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}&quot;</span><span class="s0">,</span><span class="s2">&quot;any.required&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} is required&quot;</span><span class="s0">,</span><span class="s2">&quot;any.unknown&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} is not allowed&quot;</span><span class="s0">}})},</span><span class="s3">546</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">9474</span><span class="s0">),a=r(</span><span class="s3">9621</span><span class="s0">),i=r(</span><span class="s3">8068</span><span class="s0">),o=r(</span><span class="s3">8160</span><span class="s0">),l=r(</span><span class="s3">3292</span><span class="s0">),c={};e.exports=i.extend({type:</span><span class="s2">&quot;array&quot;</span><span class="s0">,flags:{single:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">},sparse:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">}},terms:{items:{init:[],manifest:</span><span class="s2">&quot;schema&quot;</span><span class="s0">},ordered:{init:[],manifest:</span><span class="s2">&quot;schema&quot;</span><span class="s0">},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:</span><span class="s2">&quot;object&quot;</span><span class="s0">,method(e,t){let{schema:r,state:s,prefs:n}=t;</span><span class="s1">if</span><span class="s0">(!Array.isArray(e))</span><span class="s1">return</span><span class="s0">;const a=r.$_getRule(</span><span class="s2">&quot;sort&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">a?c.sort(r,e,a.args.options,s,n):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}},validate(e,t){let{schema:r,error:s}=t;</span><span class="s1">if</span><span class="s0">(!Array.isArray(e)){</span><span class="s1">if</span><span class="s0">(r._flags.single){const t=[e];</span><span class="s1">return </span><span class="s0">t[o.symbols.arraySingle]=!</span><span class="s3">0</span><span class="s0">,{value:t}}</span><span class="s1">return</span><span class="s0">{errors:s(</span><span class="s2">&quot;array.base&quot;</span><span class="s0">)}}</span><span class="s1">if</span><span class="s0">(r.$_getRule(</span><span class="s2">&quot;items&quot;</span><span class="s0">)||r.$_terms.externals)</span><span class="s1">return</span><span class="s0">{value:e.slice()}},rules:{has:{method(e){e=</span><span class="s1">this</span><span class="s0">.$_compile(e,{appendPath:!</span><span class="s3">0</span><span class="s0">});const t=</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;has&quot;</span><span class="s0">,args:{schema:e}});</span><span class="s1">return </span><span class="s0">t.$_mutateRegister(e),t},validate(e,t,r){let{state:s,prefs:n,error:a}=t,{schema:i}=r;const o=[e,...s.ancestors];</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;e.length;++t){const r=s.localize([...s.path,t],o,i);</span><span class="s1">if</span><span class="s0">(i.$_match(e[t],r,n))</span><span class="s1">return </span><span class="s0">e}const l=i._flags.label;</span><span class="s1">return </span><span class="s0">l?a(</span><span class="s2">&quot;array.hasKnown&quot;</span><span class="s0">,{patternLabel:l}):a(</span><span class="s2">&quot;array.hasUnknown&quot;</span><span class="s0">,</span><span class="s1">null</span><span class="s0">)},multi:!</span><span class="s3">0</span><span class="s0">},items:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];o.verifyFlat(t,</span><span class="s2">&quot;items&quot;</span><span class="s0">);const s=</span><span class="s1">this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;items&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;++e){const r=o.tryWithPath((()=&gt;</span><span class="s1">this</span><span class="s0">.$_compile(t[e])),e,{append:!</span><span class="s3">0</span><span class="s0">});s.$_terms.items.push(r)}</span><span class="s1">return </span><span class="s0">s.$_mutateRebuild()},validate(e,t){let{schema:r,error:s,state:n,prefs:a,errorsArray:i}=t;const l=r.$_terms._requireds.slice(),u=r.$_terms.ordered.slice(),f=[...r.$_terms._inclusions,...l],h=!e[o.symbols.arraySingle];</span><span class="s1">delete </span><span class="s0">e[o.symbols.arraySingle];const m=i();let d=e.length;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;d;++t){const i=e[t];let o=!</span><span class="s3">1</span><span class="s0">,p=!</span><span class="s3">1</span><span class="s0">;const g=h?t:</span><span class="s1">new </span><span class="s0">Number(t),y=[...n.path,g];</span><span class="s1">if</span><span class="s0">(!r._flags.sparse&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===i){</span><span class="s1">if</span><span class="s0">(m.push(s(</span><span class="s2">&quot;array.sparse&quot;</span><span class="s0">,{key:g,path:y,pos:t,value:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">},n.localize(y))),a.abortEarly)</span><span class="s1">return </span><span class="s0">m;u.shift();</span><span class="s1">continue</span><span class="s0">}const b=[e,...n.ancestors];</span><span class="s1">for</span><span class="s0">(const e of r.$_terms._exclusions)</span><span class="s1">if</span><span class="s0">(e.$_match(i,n.localize(y,b,e),a,{presence:</span><span class="s2">&quot;ignore&quot;</span><span class="s0">})){</span><span class="s1">if</span><span class="s0">(m.push(s(</span><span class="s2">&quot;array.excludes&quot;</span><span class="s0">,{pos:t,value:i},n.localize(y))),a.abortEarly)</span><span class="s1">return </span><span class="s0">m;o=!</span><span class="s3">0</span><span class="s0">,u.shift();</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(o)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r.$_terms.ordered.length){</span><span class="s1">if</span><span class="s0">(u.length){const o=u.shift(),l=o.$_validate(i,n.localize(y,b,o),a);</span><span class="s1">if</span><span class="s0">(l.errors){</span><span class="s1">if</span><span class="s0">(m.push(...l.errors),a.abortEarly)</span><span class="s1">return </span><span class="s0">m}</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">&quot;strip&quot;</span><span class="s0">===o._flags.result)c.fastSplice(e,t),--t,--d;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!r._flags.sparse&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===l.value){</span><span class="s1">if</span><span class="s0">(m.push(s(</span><span class="s2">&quot;array.sparse&quot;</span><span class="s0">,{key:g,path:y,pos:t,value:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">},n.localize(y))),a.abortEarly)</span><span class="s1">return </span><span class="s0">m;</span><span class="s1">continue</span><span class="s0">}e[t]=l.value}</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(!r.$_terms.items.length){</span><span class="s1">if</span><span class="s0">(m.push(s(</span><span class="s2">&quot;array.orderedLength&quot;</span><span class="s0">,{pos:t,limit:r.$_terms.ordered.length})),a.abortEarly)</span><span class="s1">return </span><span class="s0">m;</span><span class="s1">break</span><span class="s0">}}const v=[];let _=l.length;</span><span class="s1">for</span><span class="s0">(let o=</span><span class="s3">0</span><span class="s0">;o&lt;_;++o){const u=n.localize(y,b,l[o]);u.snapshot();const f=l[o].$_validate(i,u,a);</span><span class="s1">if</span><span class="s0">(v[o]=f,!f.errors){</span><span class="s1">if</span><span class="s0">(u.commit(),e[t]=f.value,p=!</span><span class="s3">0</span><span class="s0">,c.fastSplice(l,o),--o,--_,!r._flags.sparse&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===f.value&amp;&amp;(m.push(s(</span><span class="s2">&quot;array.sparse&quot;</span><span class="s0">,{key:g,path:y,pos:t,value:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">},n.localize(y))),a.abortEarly))</span><span class="s1">return </span><span class="s0">m;</span><span class="s1">break</span><span class="s0">}u.restore()}</span><span class="s1">if</span><span class="s0">(p)</span><span class="s1">continue</span><span class="s0">;const w=a.stripUnknown&amp;&amp;!!a.stripUnknown.arrays||!</span><span class="s3">1</span><span class="s0">;_=f.length;</span><span class="s1">for</span><span class="s0">(const u of f){let f;const h=l.indexOf(u);</span><span class="s1">if</span><span class="s0">(-</span><span class="s3">1</span><span class="s0">!==h)f=v[h];</span><span class="s1">else</span><span class="s0">{const l=n.localize(y,b,u);</span><span class="s1">if</span><span class="s0">(l.snapshot(),f=u.$_validate(i,l,a),!f.errors){l.commit(),</span><span class="s2">&quot;strip&quot;</span><span class="s0">===u._flags.result?(c.fastSplice(e,t),--t,--d):r._flags.sparse||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==f.value?e[t]=f.value:(m.push(s(</span><span class="s2">&quot;array.sparse&quot;</span><span class="s0">,{key:g,path:y,pos:t,value:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">},n.localize(y))),o=!</span><span class="s3">0</span><span class="s0">),p=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}l.restore()}</span><span class="s1">if</span><span class="s0">(</span><span class="s3">1</span><span class="s0">===_){</span><span class="s1">if</span><span class="s0">(w){c.fastSplice(e,t),--t,--d,p=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(m.push(...f.errors),a.abortEarly)</span><span class="s1">return </span><span class="s0">m;o=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(!o&amp;&amp;(r.$_terms._inclusions.length||r.$_terms._requireds.length)&amp;&amp;!p){</span><span class="s1">if</span><span class="s0">(w){c.fastSplice(e,t),--t,--d;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(m.push(s(</span><span class="s2">&quot;array.includes&quot;</span><span class="s0">,{pos:t,value:i},n.localize(y))),a.abortEarly)</span><span class="s1">return </span><span class="s0">m}}</span><span class="s1">return </span><span class="s0">l.length&amp;&amp;c.fillMissedErrors(r,m,l,e,n,a),u.length&amp;&amp;(c.fillOrderedErrors(r,m,u,e,n,a),m.length||c.fillDefault(u,e,n,a)),m.length?m:e},priority:!</span><span class="s3">0</span><span class="s0">,manifest:!</span><span class="s3">1</span><span class="s0">},length:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;length&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;=&quot;</span><span class="s0">})},validate(e,t,r,s){let{limit:n}=r,{name:a,operator:i,args:l}=s;</span><span class="s1">return </span><span class="s0">o.compare(e.length,n,i)?e:t.error(</span><span class="s2">&quot;array.&quot;</span><span class="s0">+a,{limit:l.limit,value:e})},args:[{name:</span><span class="s2">&quot;limit&quot;</span><span class="s0">,ref:!</span><span class="s3">0</span><span class="s0">,assert:o.limit,message:</span><span class="s2">&quot;must be a positive integer&quot;</span><span class="s0">}]},max:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;max&quot;</span><span class="s0">,method:</span><span class="s2">&quot;length&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">})}},min:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;min&quot;</span><span class="s0">,method:</span><span class="s2">&quot;length&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">})}},ordered:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];o.verifyFlat(t,</span><span class="s2">&quot;ordered&quot;</span><span class="s0">);const s=</span><span class="s1">this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;items&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;++e){const r=o.tryWithPath((()=&gt;</span><span class="s1">this</span><span class="s0">.$_compile(t[e])),e,{append:!</span><span class="s3">0</span><span class="s0">});c.validateSingle(r,s),s.$_mutateRegister(r),s.$_terms.ordered.push(r)}</span><span class="s1">return </span><span class="s0">s.$_mutateRebuild()}},single:{method(e){const t=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e||!!e;</span><span class="s1">return </span><span class="s0">s(!t||!</span><span class="s1">this</span><span class="s0">._flags._arrayItems,</span><span class="s2">&quot;Cannot specify single rule when array has array items&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;single&quot;</span><span class="s0">,t)}},sort:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};o.assertOptions(e,[</span><span class="s2">&quot;by&quot;</span><span class="s0">,</span><span class="s2">&quot;order&quot;</span><span class="s0">]);const t={order:e.order||</span><span class="s2">&quot;ascending&quot;</span><span class="s0">};</span><span class="s1">return </span><span class="s0">e.by&amp;&amp;(t.by=l.ref(e.by,{ancestor:</span><span class="s3">0</span><span class="s0">}),s(!t.by.ancestor,</span><span class="s2">&quot;Cannot sort by ancestor&quot;</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;sort&quot;</span><span class="s0">,args:{options:t}})},validate(e,t,r){let{error:s,state:n,prefs:a,schema:i}=t,{options:o}=r;const{value:l,errors:u}=c.sort(i,e,o,n,a);</span><span class="s1">if</span><span class="s0">(u)</span><span class="s1">return </span><span class="s0">u;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;e.length;++t)</span><span class="s1">if</span><span class="s0">(e[t]!==l[t])</span><span class="s1">return </span><span class="s0">s(</span><span class="s2">&quot;array.sort&quot;</span><span class="s0">,{order:o.order,by:o.by?o.by.key:</span><span class="s2">&quot;value&quot;</span><span class="s0">});</span><span class="s1">return </span><span class="s0">e},convert:!</span><span class="s3">0</span><span class="s0">},sparse:{method(e){const t=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e||!!e;</span><span class="s1">return this</span><span class="s0">._flags.sparse===t?</span><span class="s1">this</span><span class="s0">:(t?</span><span class="s1">this</span><span class="s0">.clone():</span><span class="s1">this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;items&quot;</span><span class="s0">)).$_setFlag(</span><span class="s2">&quot;sparse&quot;</span><span class="s0">,t,{clone:!</span><span class="s3">1</span><span class="s0">})}},unique:{method(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};s(!e||</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;comparator must be a function or a string&quot;</span><span class="s0">),o.assertOptions(t,[</span><span class="s2">&quot;ignoreUndefined&quot;</span><span class="s0">,</span><span class="s2">&quot;separator&quot;</span><span class="s0">]);const r={name:</span><span class="s2">&quot;unique&quot;</span><span class="s0">,args:{options:t,comparator:e}};</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){const s=o.</span><span class="s1">default</span><span class="s0">(t.separator,</span><span class="s2">&quot;.&quot;</span><span class="s0">);r.path=s?e.split(s):[e]}</span><span class="s1">else </span><span class="s0">r.comparator=e;</span><span class="s1">return this</span><span class="s0">.$_addRule(r)},validate(e,t,r,i){let{state:o,error:l,schema:c}=t,{comparator:u,options:f}=r,{comparator:h,path:m}=i;const d={string:Object.create(</span><span class="s1">null</span><span class="s0">),number:Object.create(</span><span class="s1">null</span><span class="s0">),undefined:Object.create(</span><span class="s1">null</span><span class="s0">),boolean:Object.create(</span><span class="s1">null</span><span class="s0">),object:</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">function</span><span class="s0">:</span><span class="s1">new </span><span class="s0">Map,custom:</span><span class="s1">new </span><span class="s0">Map},p=h||n,g=f.ignoreUndefined;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;e.length;++t){const r=m?a(e[t],m):e[t],n=h?d.custom:d[</span><span class="s1">typeof </span><span class="s0">r];</span><span class="s1">if</span><span class="s0">(s(n,</span><span class="s2">&quot;Failed to find unique map container for type&quot;</span><span class="s0">,</span><span class="s1">typeof </span><span class="s0">r),n </span><span class="s1">instanceof </span><span class="s0">Map){const s=n.entries();let a;</span><span class="s1">for</span><span class="s0">(;!(a=s.next()).done;)</span><span class="s1">if</span><span class="s0">(p(a.value[</span><span class="s3">0</span><span class="s0">],r)){const r=o.localize([...o.path,t],[e,...o.ancestors]),s={pos:t,value:e[t],dupePos:a.value[</span><span class="s3">1</span><span class="s0">],dupeValue:e[a.value[</span><span class="s3">1</span><span class="s0">]]};</span><span class="s1">return </span><span class="s0">m&amp;&amp;(s.path=u),l(</span><span class="s2">&quot;array.unique&quot;</span><span class="s0">,s,r)}n.set(r,t)}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">((!g||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r)&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n[r]){const s={pos:t,value:e[t],dupePos:n[r],dupeValue:e[n[r]]};</span><span class="s1">return </span><span class="s0">m&amp;&amp;(s.path=u),l(</span><span class="s2">&quot;array.unique&quot;</span><span class="s0">,s,o.localize([...o.path,t],[e,...o.ancestors]))}n[r]=t}}</span><span class="s1">return </span><span class="s0">e},args:[</span><span class="s2">&quot;comparator&quot;</span><span class="s0">,</span><span class="s2">&quot;options&quot;</span><span class="s0">],multi:!</span><span class="s3">0</span><span class="s0">}},cast:{set:{from:Array.isArray,to:(e,t)=&gt;</span><span class="s1">new </span><span class="s0">Set(e)}},rebuild(e){e.$_terms._inclusions=[],e.$_terms._exclusions=[],e.$_terms._requireds=[];</span><span class="s1">for</span><span class="s0">(const t of e.$_terms.items)c.validateSingle(t,e),</span><span class="s2">&quot;required&quot;</span><span class="s0">===t._flags.presence?e.$_terms._requireds.push(t):</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">===t._flags.presence?e.$_terms._exclusions.push(t):e.$_terms._inclusions.push(t);</span><span class="s1">for</span><span class="s0">(const t of e.$_terms.ordered)c.validateSingle(t,e)},manifest:{build:(e,t)=&gt;(t.items&amp;&amp;(e=e.items(...t.items)),t.ordered&amp;&amp;(e=e.ordered(...t.ordered)),e)},messages:{</span><span class="s2">&quot;array.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be an array&quot;</span><span class="s0">,</span><span class="s2">&quot;array.excludes&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} contains an excluded value&quot;</span><span class="s0">,</span><span class="s2">&quot;array.hasKnown&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not contain at least one required match for type {:#patternLabel}&quot;</span><span class="s0">,</span><span class="s2">&quot;array.hasUnknown&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not contain at least one required match&quot;</span><span class="s0">,</span><span class="s2">&quot;array.includes&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not match any of the allowed types&quot;</span><span class="s0">,</span><span class="s2">&quot;array.includesRequiredBoth&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)&quot;</span><span class="s0">,</span><span class="s2">&quot;array.includesRequiredKnowns&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not contain {{#knownMisses}}&quot;</span><span class="s0">,</span><span class="s2">&quot;array.includesRequiredUnknowns&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} does not contain {{#unknownMisses}} required value(s)&quot;</span><span class="s0">,</span><span class="s2">&quot;array.length&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must contain {{#limit}} items&quot;</span><span class="s0">,</span><span class="s2">&quot;array.max&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must contain less than or equal to {{#limit}} items&quot;</span><span class="s0">,</span><span class="s2">&quot;array.min&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must contain at least {{#limit}} items&quot;</span><span class="s0">,</span><span class="s2">&quot;array.orderedLength&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must contain at most {{#limit}} items&quot;</span><span class="s0">,</span><span class="s2">&quot;array.sort&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be sorted in {#order} order by {{#by}}&quot;</span><span class="s0">,</span><span class="s2">&quot;array.sort.mismatching&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} cannot be sorted due to mismatching types&quot;</span><span class="s0">,</span><span class="s2">&quot;array.sort.unsupported&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} cannot be sorted due to unsupported type {#type}&quot;</span><span class="s0">,</span><span class="s2">&quot;array.sparse&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must not be a sparse array item&quot;</span><span class="s0">,</span><span class="s2">&quot;array.unique&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} contains a duplicate value&quot;</span><span class="s0">}}),c.fillMissedErrors=</span><span class="s1">function</span><span class="s0">(e,t,r,s,n,a){const i=[];let o=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const e of r){const t=e._flags.label;t?i.push(t):++o}i.length?o?t.push(e.$_createError(</span><span class="s2">&quot;array.includesRequiredBoth&quot;</span><span class="s0">,s,{knownMisses:i,unknownMisses:o},n,a)):t.push(e.$_createError(</span><span class="s2">&quot;array.includesRequiredKnowns&quot;</span><span class="s0">,s,{knownMisses:i},n,a)):t.push(e.$_createError(</span><span class="s2">&quot;array.includesRequiredUnknowns&quot;</span><span class="s0">,s,{unknownMisses:o},n,a))},c.fillOrderedErrors=</span><span class="s1">function</span><span class="s0">(e,t,r,s,n,a){const i=[];</span><span class="s1">for</span><span class="s0">(const e of r)</span><span class="s2">&quot;required&quot;</span><span class="s0">===e._flags.presence&amp;&amp;i.push(e);i.length&amp;&amp;c.fillMissedErrors(e,t,i,s,n,a)},c.fillDefault=</span><span class="s1">function</span><span class="s0">(e,t,r,s){const n=[];let a=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let i=e.length-1;i&gt;=</span><span class="s3">0</span><span class="s0">;--i){const o=e[i],l=[t,...r.ancestors],c=o.$_validate(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,r.localize(r.path,l,o),s).value;</span><span class="s1">if</span><span class="s0">(a){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===c)</span><span class="s1">continue</span><span class="s0">;a=!</span><span class="s3">1</span><span class="s0">}n.unshift(c)}n.length&amp;&amp;t.push(...n)},c.fastSplice=</span><span class="s1">function</span><span class="s0">(e,t){let r=t;</span><span class="s1">for</span><span class="s0">(;r&lt;e.length;)e[r++]=e[r];--e.length},c.validateSingle=</span><span class="s1">function</span><span class="s0">(e,t){(</span><span class="s2">&quot;array&quot;</span><span class="s0">===e.type||e._flags._arrayItems)&amp;&amp;(s(!t._flags.single,</span><span class="s2">&quot;Cannot specify array item with single rule enabled&quot;</span><span class="s0">),t.$_setFlag(</span><span class="s2">&quot;_arrayItems&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,{clone:!</span><span class="s3">1</span><span class="s0">}))},c.sort=</span><span class="s1">function</span><span class="s0">(e,t,r,s,n){const a=</span><span class="s2">&quot;ascending&quot;</span><span class="s0">===r.order?</span><span class="s3">1</span><span class="s0">:-</span><span class="s3">1</span><span class="s0">,i=-</span><span class="s3">1</span><span class="s0">*a,o=a,l=(l,u)=&gt;{let f=c.compare(l,u,i,o);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!==f)</span><span class="s1">return </span><span class="s0">f;</span><span class="s1">if</span><span class="s0">(r.by&amp;&amp;(l=r.by.resolve(l,s,n),u=r.by.resolve(u,s,n)),f=c.compare(l,u,i,o),</span><span class="s1">null</span><span class="s0">!==f)</span><span class="s1">return </span><span class="s0">f;const h=</span><span class="s1">typeof </span><span class="s0">l;</span><span class="s1">if</span><span class="s0">(h!==</span><span class="s1">typeof </span><span class="s0">u)</span><span class="s1">throw </span><span class="s0">e.$_createError(</span><span class="s2">&quot;array.sort.mismatching&quot;</span><span class="s0">,t,</span><span class="s1">null</span><span class="s0">,s,n);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;number&quot;</span><span class="s0">!==h&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">!==h)</span><span class="s1">throw </span><span class="s0">e.$_createError(</span><span class="s2">&quot;array.sort.unsupported&quot;</span><span class="s0">,t,{type:h},s,n);</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">===h?(l-u)*a:l&lt;u?i:o};</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return</span><span class="s0">{value:t.slice().sort(l)}}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">{errors:e}}},c.compare=</span><span class="s1">function</span><span class="s0">(e,t,r,s){</span><span class="s1">return </span><span class="s0">e===t?</span><span class="s3">0</span><span class="s0">:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e?</span><span class="s3">1</span><span class="s0">:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t?-</span><span class="s3">1</span><span class="s0">:</span><span class="s1">null</span><span class="s0">===e?s:</span><span class="s1">null</span><span class="s0">===t?r:</span><span class="s1">null</span><span class="s0">}},</span><span class="s3">4937</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8068</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i=r(</span><span class="s3">2036</span><span class="s0">),o={isBool:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e}};e.exports=n.extend({type:</span><span class="s2">&quot;boolean&quot;</span><span class="s0">,flags:{sensitive:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">}},terms:{falsy:{init:</span><span class="s1">null</span><span class="s0">,manifest:</span><span class="s2">&quot;values&quot;</span><span class="s0">},truthy:{init:</span><span class="s1">null</span><span class="s0">,manifest:</span><span class="s2">&quot;values&quot;</span><span class="s0">}},coerce(e,t){let{schema:r}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){const t=r._flags.sensitive?e:e.toLowerCase();e=</span><span class="s2">&quot;true&quot;</span><span class="s0">===t||</span><span class="s2">&quot;false&quot;</span><span class="s0">!==t&amp;&amp;e}</span><span class="s1">return</span><span class="s2">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(e=r.$_terms.truthy&amp;&amp;r.$_terms.truthy.has(e,</span><span class="s1">null</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,!r._flags.sensitive)||(!r.$_terms.falsy||!r.$_terms.falsy.has(e,</span><span class="s1">null</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,!r._flags.sensitive))&amp;&amp;e),{value:e}}},validate(e,t){let{error:r}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{value:e,errors:r(</span><span class="s2">&quot;boolean.base&quot;</span><span class="s0">)}},rules:{truthy:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];a.verifyFlat(t,</span><span class="s2">&quot;truthy&quot;</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.clone();n.$_terms.truthy=n.$_terms.truthy||</span><span class="s1">new </span><span class="s0">i;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;++e){const r=t[e];s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r,</span><span class="s2">&quot;Cannot call truthy with undefined&quot;</span><span class="s0">),n.$_terms.truthy.add(r)}</span><span class="s1">return </span><span class="s0">n}},falsy:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];a.verifyFlat(t,</span><span class="s2">&quot;falsy&quot;</span><span class="s0">);const n=</span><span class="s1">this</span><span class="s0">.clone();n.$_terms.falsy=n.$_terms.falsy||</span><span class="s1">new </span><span class="s0">i;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;++e){const r=t[e];s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r,</span><span class="s2">&quot;Cannot call falsy with undefined&quot;</span><span class="s0">),n.$_terms.falsy.add(r)}</span><span class="s1">return </span><span class="s0">n}},sensitive:{method(){let e=!(arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">])||arguments[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;sensitive&quot;</span><span class="s0">,e)}}},cast:{number:{from:o.isBool,to:(e,t)=&gt;e?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">},string:{from:o.isBool,to:(e,t)=&gt;e?</span><span class="s2">&quot;true&quot;</span><span class="s0">:</span><span class="s2">&quot;false&quot;</span><span class="s0">}},manifest:{build:(e,t)=&gt;(t.truthy&amp;&amp;(e=e.truthy(...t.truthy)),t.falsy&amp;&amp;(e=e.falsy(...t.falsy)),e)},messages:{</span><span class="s2">&quot;boolean.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a boolean&quot;</span><span class="s0">}})},</span><span class="s3">7500</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8068</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i=r(</span><span class="s3">3328</span><span class="s0">),o={isDate:</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e </span><span class="s1">instanceof </span><span class="s0">Date}};e.exports=n.extend({type:</span><span class="s2">&quot;date&quot;</span><span class="s0">,coerce:{from:[</span><span class="s2">&quot;number&quot;</span><span class="s0">,</span><span class="s2">&quot;string&quot;</span><span class="s0">],method(e,t){let{schema:r}=t;</span><span class="s1">return</span><span class="s0">{value:o.parse(e,r._flags.format)||e}}},validate(e,t){let{schema:r,error:s,prefs:n}=t;</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">Date&amp;&amp;!isNaN(e.getTime()))</span><span class="s1">return</span><span class="s0">;const a=r._flags.format;</span><span class="s1">return </span><span class="s0">n.convert&amp;&amp;a&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?{value:e,errors:s(</span><span class="s2">&quot;date.format&quot;</span><span class="s0">,{format:a})}:{value:e,errors:s(</span><span class="s2">&quot;date.base&quot;</span><span class="s0">)}},rules:{compare:{method:!</span><span class="s3">1</span><span class="s0">,validate(e,t,r,s){let{date:n}=r,{name:i,operator:o,args:l}=s;const c=</span><span class="s2">&quot;now&quot;</span><span class="s0">===n?Date.now():n.getTime();</span><span class="s1">return </span><span class="s0">a.compare(e.getTime(),c,o)?e:t.error(</span><span class="s2">&quot;date.&quot;</span><span class="s0">+i,{limit:l.date,value:e})},args:[{name:</span><span class="s2">&quot;date&quot;</span><span class="s0">,ref:!</span><span class="s3">0</span><span class="s0">,normalize:e=&gt;</span><span class="s2">&quot;now&quot;</span><span class="s0">===e?e:o.parse(e),assert:e=&gt;</span><span class="s1">null</span><span class="s0">!==e,message:</span><span class="s2">&quot;must have a valid date format&quot;</span><span class="s0">}]},format:{method(e){</span><span class="s1">return </span><span class="s0">s([</span><span class="s2">&quot;iso&quot;</span><span class="s0">,</span><span class="s2">&quot;javascript&quot;</span><span class="s0">,</span><span class="s2">&quot;unix&quot;</span><span class="s0">].includes(e),</span><span class="s2">&quot;Unknown date format&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;format&quot;</span><span class="s0">,e)}},greater:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;greater&quot;</span><span class="s0">,method:</span><span class="s2">&quot;compare&quot;</span><span class="s0">,args:{date:e},operator:</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">})}},iso:{method(){</span><span class="s1">return this</span><span class="s0">.format(</span><span class="s2">&quot;iso&quot;</span><span class="s0">)}},less:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;less&quot;</span><span class="s0">,method:</span><span class="s2">&quot;compare&quot;</span><span class="s0">,args:{date:e},operator:</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">})}},max:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;max&quot;</span><span class="s0">,method:</span><span class="s2">&quot;compare&quot;</span><span class="s0">,args:{date:e},operator:</span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">})}},min:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;min&quot;</span><span class="s0">,method:</span><span class="s2">&quot;compare&quot;</span><span class="s0">,args:{date:e},operator:</span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">})}},timestamp:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:</span><span class="s2">&quot;javascript&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">s([</span><span class="s2">&quot;javascript&quot;</span><span class="s0">,</span><span class="s2">&quot;unix&quot;</span><span class="s0">].includes(e),</span><span class="s2">'&quot;type&quot; must be one of &quot;javascript, unix&quot;'</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.format(e)}}},cast:{number:{from:o.isDate,to:(e,t)=&gt;e.getTime()},string:{from:o.isDate,to(e,t){let{prefs:r}=t;</span><span class="s1">return </span><span class="s0">i.date(e,r)}}},messages:{</span><span class="s2">&quot;date.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid date&quot;</span><span class="s0">,</span><span class="s2">&quot;date.format&quot;</span><span class="s0">:</span><span class="s2">'{{#label}} must be in {msg(&quot;date.format.&quot; + #format) || #format} format'</span><span class="s0">,</span><span class="s2">&quot;date.greater&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be greater than {{:#limit}}&quot;</span><span class="s0">,</span><span class="s2">&quot;date.less&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be less than {{:#limit}}&quot;</span><span class="s0">,</span><span class="s2">&quot;date.max&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be less than or equal to {{:#limit}}&quot;</span><span class="s0">,</span><span class="s2">&quot;date.min&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be greater than or equal to {{:#limit}}&quot;</span><span class="s0">,</span><span class="s2">&quot;date.format.iso&quot;</span><span class="s0">:</span><span class="s2">&quot;ISO 8601 date&quot;</span><span class="s0">,</span><span class="s2">&quot;date.format.javascript&quot;</span><span class="s0">:</span><span class="s2">&quot;timestamp or number of milliseconds&quot;</span><span class="s0">,</span><span class="s2">&quot;date.format.unix&quot;</span><span class="s0">:</span><span class="s2">&quot;timestamp or number of seconds&quot;</span><span class="s0">}}),o.parse=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">Date)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(isNaN(e)||!isFinite(e)))</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(/^\s*$/.test(e))</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;iso&quot;</span><span class="s0">===t)</span><span class="s1">return </span><span class="s0">a.isIsoDate(e)?o.date(e.toString()):</span><span class="s1">null</span><span class="s0">;const r=e;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;/^[+-]?\d+(\.\d+)?$/.test(e)&amp;&amp;(e=parseFloat(e)),t){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;javascript&quot;</span><span class="s0">===t)</span><span class="s1">return </span><span class="s0">o.date(</span><span class="s3">1</span><span class="s0">*e);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;unix&quot;</span><span class="s0">===t)</span><span class="s1">return </span><span class="s0">o.date(</span><span class="s3">1</span><span class="s0">e3*e);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r)</span><span class="s1">return null</span><span class="s0">}</span><span class="s1">return </span><span class="s0">o.date(e)},o.date=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">new </span><span class="s0">Date(e);</span><span class="s1">return </span><span class="s0">isNaN(t.getTime())?</span><span class="s1">null</span><span class="s0">:t}},</span><span class="s3">390</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">7824</span><span class="s0">);e.exports=n.extend({type:</span><span class="s2">&quot;function&quot;</span><span class="s0">,properties:{</span><span class="s1">typeof</span><span class="s0">:</span><span class="s2">&quot;function&quot;</span><span class="s0">},rules:{arity:{method(e){</span><span class="s1">return </span><span class="s0">s(Number.isSafeInteger(e)&amp;&amp;e&gt;=</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;n must be a positive integer&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;arity&quot;</span><span class="s0">,args:{n:e}})},validate(e,t,r){let{n:s}=r;</span><span class="s1">return </span><span class="s0">e.length===s?e:t.error(</span><span class="s2">&quot;function.arity&quot;</span><span class="s0">,{n:s})}},class:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;class&quot;</span><span class="s0">)},validate:(e,t)=&gt;/^\s*class\s/.test(e.toString())?e:t.error(</span><span class="s2">&quot;function.class&quot;</span><span class="s0">,{value:e})},minArity:{method(e){</span><span class="s1">return </span><span class="s0">s(Number.isSafeInteger(e)&amp;&amp;e&gt;</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;n must be a strict positive integer&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;minArity&quot;</span><span class="s0">,args:{n:e}})},validate(e,t,r){let{n:s}=r;</span><span class="s1">return </span><span class="s0">e.length&gt;=s?e:t.error(</span><span class="s2">&quot;function.minArity&quot;</span><span class="s0">,{n:s})}},maxArity:{method(e){</span><span class="s1">return </span><span class="s0">s(Number.isSafeInteger(e)&amp;&amp;e&gt;=</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;n must be a positive integer&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;maxArity&quot;</span><span class="s0">,args:{n:e}})},validate(e,t,r){let{n:s}=r;</span><span class="s1">return </span><span class="s0">e.length&lt;=s?e:t.error(</span><span class="s2">&quot;function.maxArity&quot;</span><span class="s0">,{n:s})}}},messages:{</span><span class="s2">&quot;function.arity&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must have an arity of {{#n}}&quot;</span><span class="s0">,</span><span class="s2">&quot;function.class&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a class&quot;</span><span class="s0">,</span><span class="s2">&quot;function.maxArity&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must have an arity lesser or equal to {{#n}}&quot;</span><span class="s0">,</span><span class="s2">&quot;function.minArity&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must have an arity greater or equal to {{#n}}&quot;</span><span class="s0">}})},</span><span class="s3">7824</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">978</span><span class="s0">),n=r(</span><span class="s3">375</span><span class="s0">),a=r(</span><span class="s3">8571</span><span class="s0">),i=r(</span><span class="s3">3652</span><span class="s0">),o=r(</span><span class="s3">8068</span><span class="s0">),l=r(</span><span class="s3">8160</span><span class="s0">),c=r(</span><span class="s3">3292</span><span class="s0">),u=r(</span><span class="s3">6354</span><span class="s0">),f=r(</span><span class="s3">6133</span><span class="s0">),h=r(</span><span class="s3">3328</span><span class="s0">),m={renameDefaults:{alias:!</span><span class="s3">1</span><span class="s0">,multiple:!</span><span class="s3">1</span><span class="s0">,override:!</span><span class="s3">1</span><span class="s0">}};e.exports=o.extend({type:</span><span class="s2">&quot;_keys&quot;</span><span class="s0">,properties:{</span><span class="s1">typeof</span><span class="s0">:</span><span class="s2">&quot;object&quot;</span><span class="s0">},flags:{unknown:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">}},terms:{dependencies:{init:</span><span class="s1">null</span><span class="s0">},keys:{init:</span><span class="s1">null</span><span class="s0">,manifest:{mapped:{from:</span><span class="s2">&quot;schema&quot;</span><span class="s0">,to:</span><span class="s2">&quot;key&quot;</span><span class="s0">}}},patterns:{init:</span><span class="s1">null</span><span class="s0">},renames:{init:</span><span class="s1">null</span><span class="s0">}},args:(e,t)=&gt;e.keys(t),validate(e,t){let{schema:r,error:s,state:n,prefs:a}=t;</span><span class="s1">if</span><span class="s0">(!e||</span><span class="s1">typeof </span><span class="s0">e!==r.$_property(</span><span class="s2">&quot;typeof&quot;</span><span class="s0">)||Array.isArray(e))</span><span class="s1">return</span><span class="s0">{value:e,errors:s(</span><span class="s2">&quot;object.base&quot;</span><span class="s0">,{type:r.$_property(</span><span class="s2">&quot;typeof&quot;</span><span class="s0">)})};</span><span class="s1">if</span><span class="s0">(!(r.$_terms.renames||r.$_terms.dependencies||r.$_terms.keys||r.$_terms.patterns||r.$_terms.externals))</span><span class="s1">return</span><span class="s0">;e=m.clone(e,a);const i=[];</span><span class="s1">if</span><span class="s0">(r.$_terms.renames&amp;&amp;!m.rename(r,e,n,a,i))</span><span class="s1">return</span><span class="s0">{value:e,errors:i};</span><span class="s1">if</span><span class="s0">(!r.$_terms.keys&amp;&amp;!r.$_terms.patterns&amp;&amp;!r.$_terms.dependencies)</span><span class="s1">return</span><span class="s0">{value:e,errors:i};const o=</span><span class="s1">new </span><span class="s0">Set(Object.keys(e));</span><span class="s1">if</span><span class="s0">(r.$_terms.keys){const t=[e,...n.ancestors];</span><span class="s1">for</span><span class="s0">(const s of r.$_terms.keys){const r=s.key,l=e[r];o.</span><span class="s1">delete</span><span class="s0">(r);const c=n.localize([...n.path,r],t,s),u=s.schema.$_validate(l,c,a);</span><span class="s1">if</span><span class="s0">(u.errors){</span><span class="s1">if</span><span class="s0">(a.abortEarly)</span><span class="s1">return</span><span class="s0">{value:e,errors:u.errors};</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==u.value&amp;&amp;(e[r]=u.value),i.push(...u.errors)}</span><span class="s1">else</span><span class="s2">&quot;strip&quot;</span><span class="s0">===s.schema._flags.result||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===u.value&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==l?</span><span class="s1">delete </span><span class="s0">e[r]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==u.value&amp;&amp;(e[r]=u.value)}}</span><span class="s1">if</span><span class="s0">(o.size||r._flags._hasPatternMatch){const t=m.unknown(r,e,o,i,n,a);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">if</span><span class="s0">(r.$_terms.dependencies)</span><span class="s1">for</span><span class="s0">(const t of r.$_terms.dependencies){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!==t.key&amp;&amp;!</span><span class="s3">1</span><span class="s0">===m.isPresent(t.options)(t.key.resolve(e,n,a,</span><span class="s1">null</span><span class="s0">,{shadow:!</span><span class="s3">1</span><span class="s0">})))</span><span class="s1">continue</span><span class="s0">;const s=m.dependencies[t.rel](r,t,e,n,a);</span><span class="s1">if</span><span class="s0">(s){const t=r.$_createError(s.code,e,s.context,n,a);</span><span class="s1">if</span><span class="s0">(a.abortEarly)</span><span class="s1">return</span><span class="s0">{value:e,errors:t};i.push(t)}}</span><span class="s1">return</span><span class="s0">{value:e,errors:i}},rules:{and:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return </span><span class="s0">l.verifyFlat(t,</span><span class="s2">&quot;and&quot;</span><span class="s0">),m.dependency(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;and&quot;</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,t)}},append:{method(e){</span><span class="s1">return null</span><span class="s0">==e||</span><span class="s3">0</span><span class="s0">===Object.keys(e).length?</span><span class="s1">this</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.keys(e)}},assert:{method(e,t,r){h.isTemplate(e)||(e=c.ref(e)),n(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r,</span><span class="s2">&quot;Message must be a string&quot;</span><span class="s0">),t=</span><span class="s1">this</span><span class="s0">.$_compile(t,{appendPath:!</span><span class="s3">0</span><span class="s0">});const s=</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;assert&quot;</span><span class="s0">,args:{subject:e,schema:t,message:r}});</span><span class="s1">return </span><span class="s0">s.$_mutateRegister(e),s.$_mutateRegister(t),s},validate(e,t,r){let{error:s,prefs:n,state:a}=t,{subject:i,schema:o,message:l}=r;const c=i.resolve(e,a,n),u=f.isRef(i)?i.absolute(a):[];</span><span class="s1">return </span><span class="s0">o.$_match(c,a.localize(u,[e,...a.ancestors],o),n)?e:s(</span><span class="s2">&quot;object.assert&quot;</span><span class="s0">,{subject:i,message:l})},args:[</span><span class="s2">&quot;subject&quot;</span><span class="s0">,</span><span class="s2">&quot;schema&quot;</span><span class="s0">,</span><span class="s2">&quot;message&quot;</span><span class="s0">],multi:!</span><span class="s3">0</span><span class="s0">},instance:{method(e,t){</span><span class="s1">return </span><span class="s0">n(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;constructor must be a function&quot;</span><span class="s0">),t=t||e.name,</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;instance&quot;</span><span class="s0">,args:{constructor:e,name:t}})},validate(e,t,r){let{constructor:s,name:n}=r;</span><span class="s1">return </span><span class="s0">e </span><span class="s1">instanceof </span><span class="s0">s?e:t.error(</span><span class="s2">&quot;object.instance&quot;</span><span class="s0">,{type:n,value:e})},args:[</span><span class="s2">&quot;constructor&quot;</span><span class="s0">,</span><span class="s2">&quot;name&quot;</span><span class="s0">]},keys:{method(e){n(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e||</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Object schema must be a valid object&quot;</span><span class="s0">),n(!l.isSchema(e),</span><span class="s2">&quot;Object schema cannot be a joi schema&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">if</span><span class="s0">(Object.keys(e).length){t.$_terms.keys=t.$_terms.keys?t.$_terms.keys.filter((t=&gt;!e.hasOwnProperty(t.key))):</span><span class="s1">new </span><span class="s0">m.Keys;</span><span class="s1">for</span><span class="s0">(const r </span><span class="s1">in </span><span class="s0">e)l.tryWithPath((()=&gt;t.$_terms.keys.push({key:r,schema:</span><span class="s1">this</span><span class="s0">.$_compile(e[r])})),r)}</span><span class="s1">else </span><span class="s0">t.$_terms.keys=</span><span class="s1">new </span><span class="s0">m.Keys;</span><span class="s1">else </span><span class="s0">t.$_terms.keys=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t.$_mutateRebuild()}},length:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;length&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;=&quot;</span><span class="s0">})},validate(e,t,r,s){let{limit:n}=r,{name:a,operator:i,args:o}=s;</span><span class="s1">return </span><span class="s0">l.compare(Object.keys(e).length,n,i)?e:t.error(</span><span class="s2">&quot;object.&quot;</span><span class="s0">+a,{limit:o.limit,value:e})},args:[{name:</span><span class="s2">&quot;limit&quot;</span><span class="s0">,ref:!</span><span class="s3">0</span><span class="s0">,assert:l.limit,message:</span><span class="s2">&quot;must be a positive integer&quot;</span><span class="s0">}]},max:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;max&quot;</span><span class="s0">,method:</span><span class="s2">&quot;length&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">})}},min:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;min&quot;</span><span class="s0">,method:</span><span class="s2">&quot;length&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">})}},nand:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return </span><span class="s0">l.verifyFlat(t,</span><span class="s2">&quot;nand&quot;</span><span class="s0">),m.dependency(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;nand&quot;</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,t)}},or:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return </span><span class="s0">l.verifyFlat(t,</span><span class="s2">&quot;or&quot;</span><span class="s0">),m.dependency(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;or&quot;</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,t)}},oxor:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return </span><span class="s0">m.dependency(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;oxor&quot;</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,t)}},pattern:{method(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};const s=e </span><span class="s1">instanceof </span><span class="s0">RegExp;s||(e=</span><span class="s1">this</span><span class="s0">.$_compile(e,{appendPath:!</span><span class="s3">0</span><span class="s0">})),n(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t,</span><span class="s2">&quot;Invalid rule&quot;</span><span class="s0">),l.assertOptions(r,[</span><span class="s2">&quot;fallthrough&quot;</span><span class="s0">,</span><span class="s2">&quot;matches&quot;</span><span class="s0">]),s&amp;&amp;n(!e.flags.includes(</span><span class="s2">&quot;g&quot;</span><span class="s0">)&amp;&amp;!e.flags.includes(</span><span class="s2">&quot;y&quot;</span><span class="s0">),</span><span class="s2">&quot;pattern should not use global or sticky mode&quot;</span><span class="s0">),t=</span><span class="s1">this</span><span class="s0">.$_compile(t,{appendPath:!</span><span class="s3">0</span><span class="s0">});const a=</span><span class="s1">this</span><span class="s0">.clone();a.$_terms.patterns=a.$_terms.patterns||[];const i={[s?</span><span class="s2">&quot;regex&quot;</span><span class="s0">:</span><span class="s2">&quot;schema&quot;</span><span class="s0">]:e,rule:t};</span><span class="s1">return </span><span class="s0">r.matches&amp;&amp;(i.matches=</span><span class="s1">this</span><span class="s0">.$_compile(r.matches),</span><span class="s2">&quot;array&quot;</span><span class="s0">!==i.matches.type&amp;&amp;(i.matches=i.matches.$_root.array().items(i.matches)),a.$_mutateRegister(i.matches),a.$_setFlag(</span><span class="s2">&quot;_hasPatternMatch&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,{clone:!</span><span class="s3">1</span><span class="s0">})),r.fallthrough&amp;&amp;(i.fallthrough=!</span><span class="s3">0</span><span class="s0">),a.$_terms.patterns.push(i),a.$_mutateRegister(t),a}},ref:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;ref&quot;</span><span class="s0">)},validate:(e,t)=&gt;f.isRef(e)?e:t.error(</span><span class="s2">&quot;object.refType&quot;</span><span class="s0">,{value:e})},regex:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;regex&quot;</span><span class="s0">)},validate:(e,t)=&gt;e </span><span class="s1">instanceof </span><span class="s0">RegExp?e:t.error(</span><span class="s2">&quot;object.regex&quot;</span><span class="s0">,{value:e})},rename:{method(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};n(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e||e </span><span class="s1">instanceof </span><span class="s0">RegExp,</span><span class="s2">&quot;Rename missing the from argument&quot;</span><span class="s0">),n(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t||t </span><span class="s1">instanceof </span><span class="s0">h,</span><span class="s2">&quot;Invalid rename to argument&quot;</span><span class="s0">),n(t!==e,</span><span class="s2">&quot;Cannot rename key to same name:&quot;</span><span class="s0">,e),l.assertOptions(r,[</span><span class="s2">&quot;alias&quot;</span><span class="s0">,</span><span class="s2">&quot;ignoreUndefined&quot;</span><span class="s0">,</span><span class="s2">&quot;override&quot;</span><span class="s0">,</span><span class="s2">&quot;multiple&quot;</span><span class="s0">]);const a=</span><span class="s1">this</span><span class="s0">.clone();a.$_terms.renames=a.$_terms.renames||[];</span><span class="s1">for</span><span class="s0">(const t of a.$_terms.renames)n(t.from!==e,</span><span class="s2">&quot;Cannot rename the same key multiple times&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t </span><span class="s1">instanceof </span><span class="s0">h&amp;&amp;a.$_mutateRegister(t),a.$_terms.renames.push({from:e,to:t,options:s(m.renameDefaults,r)}),a}},schema:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:</span><span class="s2">&quot;any&quot;</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;schema&quot;</span><span class="s0">,args:{type:e}})},validate(e,t,r){let{type:s}=r;</span><span class="s1">return</span><span class="s0">!l.isSchema(e)||</span><span class="s2">&quot;any&quot;</span><span class="s0">!==s&amp;&amp;e.type!==s?t.error(</span><span class="s2">&quot;object.schema&quot;</span><span class="s0">,{type:s}):e}},unknown:{method(e){</span><span class="s1">return this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;unknown&quot;</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">!==e)}},</span><span class="s1">with</span><span class="s0">:{method(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">m.dependency(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;with&quot;</span><span class="s0">,e,t,r)}},without:{method(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">m.dependency(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;without&quot;</span><span class="s0">,e,t,r)}},xor:{method(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">e=arguments.length,t=</span><span class="s1">new </span><span class="s0">Array(e),r=</span><span class="s3">0</span><span class="s0">;r&lt;e;r++)t[r]=arguments[r];</span><span class="s1">return </span><span class="s0">l.verifyFlat(t,</span><span class="s2">&quot;xor&quot;</span><span class="s0">),m.dependency(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;xor&quot;</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,t)}}},overrides:{</span><span class="s1">default</span><span class="s0">(e,t){</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">===e&amp;&amp;(e=l.symbols.deepDefault),</span><span class="s1">this</span><span class="s0">.$_parent(</span><span class="s2">&quot;default&quot;</span><span class="s0">,e,t)}},rebuild(e){</span><span class="s1">if</span><span class="s0">(e.$_terms.keys){const t=</span><span class="s1">new </span><span class="s0">i.Sorter;</span><span class="s1">for</span><span class="s0">(const r of e.$_terms.keys)l.tryWithPath((()=&gt;t.add(r,{after:r.schema.$_rootReferences(),group:r.key})),r.key);e.$_terms.keys=</span><span class="s1">new </span><span class="s0">m.Keys(...t.nodes)}},manifest:{build(e,t){</span><span class="s1">if</span><span class="s0">(t.keys&amp;&amp;(e=e.keys(t.keys)),t.dependencies)</span><span class="s1">for</span><span class="s0">(const{rel:r,key:s=</span><span class="s1">null</span><span class="s0">,peers:n,options:a}of t.dependencies)e=m.dependency(e,r,s,n,a);</span><span class="s1">if</span><span class="s0">(t.patterns)</span><span class="s1">for</span><span class="s0">(const{regex:r,schema:s,rule:n,fallthrough:a,matches:i}of t.patterns)e=e.pattern(r||s,n,{fallthrough:a,matches:i});</span><span class="s1">if</span><span class="s0">(t.renames)</span><span class="s1">for</span><span class="s0">(const{from:r,to:s,options:n}of t.renames)e=e.rename(r,s,n);</span><span class="s1">return </span><span class="s0">e}},messages:{</span><span class="s2">&quot;object.and&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.assert&quot;</span><span class="s0">:</span><span class="s2">'{{#label}} is invalid because {if(#subject.key, `&quot;` + #subject.key + `&quot; failed to ` + (#message || &quot;pass the assertion test&quot;), #message || &quot;the assertion failed&quot;)}'</span><span class="s0">,</span><span class="s2">&quot;object.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be of type {{#type}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.instance&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be an instance of {{:#type}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.length&quot;</span><span class="s0">:</span><span class="s2">'{{#label}} must have {{#limit}} key{if(#limit == 1, &quot;&quot;, &quot;s&quot;)}'</span><span class="s0">,</span><span class="s2">&quot;object.max&quot;</span><span class="s0">:</span><span class="s2">'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, &quot;&quot;, &quot;s&quot;)}'</span><span class="s0">,</span><span class="s2">&quot;object.min&quot;</span><span class="s0">:</span><span class="s2">'{{#label}} must have at least {{#limit}} key{if(#limit == 1, &quot;&quot;, &quot;s&quot;)}'</span><span class="s0">,</span><span class="s2">&quot;object.missing&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must contain at least one of {{#peersWithLabels}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.nand&quot;</span><span class="s0">:</span><span class="s2">&quot;{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.oxor&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.pattern.match&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} keys failed to match pattern requirements&quot;</span><span class="s0">,</span><span class="s2">&quot;object.refType&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a Joi reference&quot;</span><span class="s0">,</span><span class="s2">&quot;object.regex&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a RegExp object&quot;</span><span class="s0">,</span><span class="s2">&quot;object.rename.multiple&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.rename.override&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists&quot;</span><span class="s0">,</span><span class="s2">&quot;object.schema&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a Joi schema of {{#type}} type&quot;</span><span class="s0">,</span><span class="s2">&quot;object.unknown&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} is not allowed&quot;</span><span class="s0">,</span><span class="s2">&quot;object.with&quot;</span><span class="s0">:</span><span class="s2">&quot;{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.without&quot;</span><span class="s0">:</span><span class="s2">&quot;{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}&quot;</span><span class="s0">,</span><span class="s2">&quot;object.xor&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}&quot;</span><span class="s0">}}),m.clone=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){</span><span class="s1">if</span><span class="s0">(t.nonEnumerables)</span><span class="s1">return </span><span class="s0">a(e,{shallow:!</span><span class="s3">0</span><span class="s0">});const r=Object.create(Object.getPrototypeOf(e));</span><span class="s1">return </span><span class="s0">Object.assign(r,e),r}const r=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">t=arguments.length,r=</span><span class="s1">new </span><span class="s0">Array(t),s=</span><span class="s3">0</span><span class="s0">;s&lt;t;s++)r[s]=arguments[s];</span><span class="s1">return </span><span class="s0">e.apply(</span><span class="s1">this</span><span class="s0">,r)};</span><span class="s1">return </span><span class="s0">r.prototype=a(e.prototype),Object.defineProperty(r,</span><span class="s2">&quot;name&quot;</span><span class="s0">,{value:e.name,writable:!</span><span class="s3">1</span><span class="s0">}),Object.defineProperty(r,</span><span class="s2">&quot;length&quot;</span><span class="s0">,{value:e.length,writable:!</span><span class="s3">1</span><span class="s0">}),Object.assign(r,e),r},m.dependency=</span><span class="s1">function</span><span class="s0">(e,t,r,s,a){n(</span><span class="s1">null</span><span class="s0">===r||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r,t,</span><span class="s2">&quot;key must be a strings&quot;</span><span class="s0">),a||(a=s.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s[s.length-1]?s.pop():{}),l.assertOptions(a,[</span><span class="s2">&quot;separator&quot;</span><span class="s0">,</span><span class="s2">&quot;isPresent&quot;</span><span class="s0">]),s=[].concat(s);const i=l.</span><span class="s1">default</span><span class="s0">(a.separator,</span><span class="s2">&quot;.&quot;</span><span class="s0">),o=[];</span><span class="s1">for</span><span class="s0">(const e of s)n(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,t,</span><span class="s2">&quot;peers must be strings&quot;</span><span class="s0">),o.push(c.ref(e,{separator:i,ancestor:</span><span class="s3">0</span><span class="s0">,prefix:!</span><span class="s3">1</span><span class="s0">}));</span><span class="s1">null</span><span class="s0">!==r&amp;&amp;(r=c.ref(r,{separator:i,ancestor:</span><span class="s3">0</span><span class="s0">,prefix:!</span><span class="s3">1</span><span class="s0">}));const u=e.clone();</span><span class="s1">return </span><span class="s0">u.$_terms.dependencies=u.$_terms.dependencies||[],u.$_terms.dependencies.push(</span><span class="s1">new </span><span class="s0">m.Dependency(t,r,o,s,a)),u},m.dependencies={and(e,t,r,s,n){const a=[],i=[],o=t.peers.length,l=m.isPresent(t.options);</span><span class="s1">for</span><span class="s0">(const e of t.peers)!</span><span class="s3">1</span><span class="s0">===l(e.resolve(r,s,n,</span><span class="s1">null</span><span class="s0">,{shadow:!</span><span class="s3">1</span><span class="s0">}))?a.push(e.key):i.push(e.key);</span><span class="s1">if</span><span class="s0">(a.length!==o&amp;&amp;i.length!==o)</span><span class="s1">return</span><span class="s0">{code:</span><span class="s2">&quot;object.and&quot;</span><span class="s0">,context:{present:i,presentWithLabels:m.keysToLabels(e,i),missing:a,missingWithLabels:m.keysToLabels(e,a)}}},nand(e,t,r,s,n){const a=[],i=m.isPresent(t.options);</span><span class="s1">for</span><span class="s0">(const e of t.peers)i(e.resolve(r,s,n,</span><span class="s1">null</span><span class="s0">,{shadow:!</span><span class="s3">1</span><span class="s0">}))&amp;&amp;a.push(e.key);</span><span class="s1">if</span><span class="s0">(a.length!==t.peers.length)</span><span class="s1">return</span><span class="s0">;const o=t.paths[</span><span class="s3">0</span><span class="s0">],l=t.paths.slice(</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return</span><span class="s0">{code:</span><span class="s2">&quot;object.nand&quot;</span><span class="s0">,context:{main:o,mainWithLabel:m.keysToLabels(e,o),peers:l,peersWithLabels:m.keysToLabels(e,l)}}},or(e,t,r,s,n){const a=m.isPresent(t.options);</span><span class="s1">for</span><span class="s0">(const e of t.peers)</span><span class="s1">if</span><span class="s0">(a(e.resolve(r,s,n,</span><span class="s1">null</span><span class="s0">,{shadow:!</span><span class="s3">1</span><span class="s0">})))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return</span><span class="s0">{code:</span><span class="s2">&quot;object.missing&quot;</span><span class="s0">,context:{peers:t.paths,peersWithLabels:m.keysToLabels(e,t.paths)}}},oxor(e,t,r,s,n){const a=[],i=m.isPresent(t.options);</span><span class="s1">for</span><span class="s0">(const e of t.peers)i(e.resolve(r,s,n,</span><span class="s1">null</span><span class="s0">,{shadow:!</span><span class="s3">1</span><span class="s0">}))&amp;&amp;a.push(e.key);</span><span class="s1">if</span><span class="s0">(!a.length||</span><span class="s3">1</span><span class="s0">===a.length)</span><span class="s1">return</span><span class="s0">;const o={peers:t.paths,peersWithLabels:m.keysToLabels(e,t.paths)};</span><span class="s1">return </span><span class="s0">o.present=a,o.presentWithLabels=m.keysToLabels(e,a),{code:</span><span class="s2">&quot;object.oxor&quot;</span><span class="s0">,context:o}},</span><span class="s1">with</span><span class="s0">(e,t,r,s,n){const a=m.isPresent(t.options);</span><span class="s1">for</span><span class="s0">(const i of t.peers)</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">1</span><span class="s0">===a(i.resolve(r,s,n,</span><span class="s1">null</span><span class="s0">,{shadow:!</span><span class="s3">1</span><span class="s0">})))</span><span class="s1">return</span><span class="s0">{code:</span><span class="s2">&quot;object.with&quot;</span><span class="s0">,context:{main:t.key.key,mainWithLabel:m.keysToLabels(e,t.key.key),peer:i.key,peerWithLabel:m.keysToLabels(e,i.key)}}},without(e,t,r,s,n){const a=m.isPresent(t.options);</span><span class="s1">for</span><span class="s0">(const i of t.peers)</span><span class="s1">if</span><span class="s0">(a(i.resolve(r,s,n,</span><span class="s1">null</span><span class="s0">,{shadow:!</span><span class="s3">1</span><span class="s0">})))</span><span class="s1">return</span><span class="s0">{code:</span><span class="s2">&quot;object.without&quot;</span><span class="s0">,context:{main:t.key.key,mainWithLabel:m.keysToLabels(e,t.key.key),peer:i.key,peerWithLabel:m.keysToLabels(e,i.key)}}},xor(e,t,r,s,n){const a=[],i=m.isPresent(t.options);</span><span class="s1">for</span><span class="s0">(const e of t.peers)i(e.resolve(r,s,n,</span><span class="s1">null</span><span class="s0">,{shadow:!</span><span class="s3">1</span><span class="s0">}))&amp;&amp;a.push(e.key);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">1</span><span class="s0">===a.length)</span><span class="s1">return</span><span class="s0">;const o={peers:t.paths,peersWithLabels:m.keysToLabels(e,t.paths)};</span><span class="s1">return </span><span class="s3">0</span><span class="s0">===a.length?{code:</span><span class="s2">&quot;object.missing&quot;</span><span class="s0">,context:o}:(o.present=a,o.presentWithLabels=m.keysToLabels(e,a),{code:</span><span class="s2">&quot;object.xor&quot;</span><span class="s0">,context:o})}},m.keysToLabels=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">Array.isArray(t)?t.map((t=&gt;e.$_mapLabels(t))):e.$_mapLabels(t)},m.isPresent=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.isPresent?e.isPresent:e=&gt;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e},m.rename=</span><span class="s1">function</span><span class="s0">(e,t,r,s,n){const a={};</span><span class="s1">for</span><span class="s0">(const i of e.$_terms.renames){const o=[],l=</span><span class="s2">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">i.from;</span><span class="s1">if</span><span class="s0">(l)</span><span class="s1">for</span><span class="s0">(const e </span><span class="s1">in </span><span class="s0">t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t[e]&amp;&amp;i.options.ignoreUndefined)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e===i.to)</span><span class="s1">continue</span><span class="s0">;const r=i.from.exec(e);r&amp;&amp;o.push({from:e,to:i.to,match:r})}</span><span class="s1">else</span><span class="s0">!Object.prototype.hasOwnProperty.call(t,i.from)||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t[i.from]&amp;&amp;i.options.ignoreUndefined||o.push(i);</span><span class="s1">for</span><span class="s0">(const c of o){const o=c.from;let u=c.to;</span><span class="s1">if</span><span class="s0">(u </span><span class="s1">instanceof </span><span class="s0">h&amp;&amp;(u=u.render(t,r,s,c.match)),o!==u){</span><span class="s1">if</span><span class="s0">(!i.options.multiple&amp;&amp;a[u]&amp;&amp;(n.push(e.$_createError(</span><span class="s2">&quot;object.rename.multiple&quot;</span><span class="s0">,t,{from:o,to:u,pattern:l},r,s)),s.abortEarly))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(Object.prototype.hasOwnProperty.call(t,u)&amp;&amp;!i.options.override&amp;&amp;!a[u]&amp;&amp;(n.push(e.$_createError(</span><span class="s2">&quot;object.rename.override&quot;</span><span class="s0">,t,{from:o,to:u,pattern:l},r,s)),s.abortEarly))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t[o]?</span><span class="s1">delete </span><span class="s0">t[u]:t[u]=t[o],a[u]=!</span><span class="s3">0</span><span class="s0">,i.options.alias||</span><span class="s1">delete </span><span class="s0">t[o]}}}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">},m.unknown=</span><span class="s1">function</span><span class="s0">(e,t,r,s,n,a){</span><span class="s1">if</span><span class="s0">(e.$_terms.patterns){let i=!</span><span class="s3">1</span><span class="s0">;const o=e.$_terms.patterns.map((e=&gt;{</span><span class="s1">if</span><span class="s0">(e.matches)</span><span class="s1">return </span><span class="s0">i=!</span><span class="s3">0</span><span class="s0">,[]})),l=[t,...n.ancestors];</span><span class="s1">for</span><span class="s0">(const i of r){const c=t[i],u=[...n.path,i];</span><span class="s1">for</span><span class="s0">(let f=</span><span class="s3">0</span><span class="s0">;f&lt;e.$_terms.patterns.length;++f){const h=e.$_terms.patterns[f];</span><span class="s1">if</span><span class="s0">(h.regex){const e=h.regex.test(i);</span><span class="s1">if</span><span class="s0">(n.mainstay.tracer.debug(n,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,`pattern.${f}`,e?</span><span class="s2">&quot;pass&quot;</span><span class="s0">:</span><span class="s2">&quot;error&quot;</span><span class="s0">),!e)</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(!h.schema.$_match(i,n.nest(h.schema,`pattern.${f}`),a))</span><span class="s1">continue</span><span class="s0">;r.</span><span class="s1">delete</span><span class="s0">(i);const m=n.localize(u,l,{schema:h.rule,key:i}),d=h.rule.$_validate(c,m,a);</span><span class="s1">if</span><span class="s0">(d.errors){</span><span class="s1">if</span><span class="s0">(a.abortEarly)</span><span class="s1">return</span><span class="s0">{value:t,errors:d.errors};s.push(...d.errors)}</span><span class="s1">if</span><span class="s0">(h.matches&amp;&amp;o[f].push(i),t[i]=d.value,!h.fallthrough)</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">for</span><span class="s0">(let r=</span><span class="s3">0</span><span class="s0">;r&lt;o.length;++r){const i=o[r];</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">continue</span><span class="s0">;const c=e.$_terms.patterns[r].matches,f=n.localize(n.path,l,c),h=c.$_validate(i,f,a);</span><span class="s1">if</span><span class="s0">(h.errors){const r=u.details(h.errors,{override:!</span><span class="s3">1</span><span class="s0">});r.matches=i;const o=e.$_createError(</span><span class="s2">&quot;object.pattern.match&quot;</span><span class="s0">,t,r,n,a);</span><span class="s1">if</span><span class="s0">(a.abortEarly)</span><span class="s1">return</span><span class="s0">{value:t,errors:o};s.push(o)}}}</span><span class="s1">if</span><span class="s0">(r.size&amp;&amp;(e.$_terms.keys||e.$_terms.patterns)){</span><span class="s1">if</span><span class="s0">(a.stripUnknown&amp;&amp;!e._flags.unknown||a.skipFunctions){const e=!(!a.stripUnknown||!</span><span class="s3">0</span><span class="s0">!==a.stripUnknown&amp;&amp;!a.stripUnknown.objects);</span><span class="s1">for</span><span class="s0">(const s of r)e?(</span><span class="s1">delete </span><span class="s0">t[s],r.</span><span class="s1">delete</span><span class="s0">(s)):</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t[s]&amp;&amp;r.</span><span class="s1">delete</span><span class="s0">(s)}</span><span class="s1">if</span><span class="s0">(!l.</span><span class="s1">default</span><span class="s0">(e._flags.unknown,a.allowUnknown))</span><span class="s1">for</span><span class="s0">(const i of r){const r=n.localize([...n.path,i],[]),o=e.$_createError(</span><span class="s2">&quot;object.unknown&quot;</span><span class="s0">,t[i],{child:i},r,a,{flags:!</span><span class="s3">1</span><span class="s0">});</span><span class="s1">if</span><span class="s0">(a.abortEarly)</span><span class="s1">return</span><span class="s0">{value:t,errors:o};s.push(o)}}},m.Dependency=class{constructor(e,t,r,s,n){</span><span class="s1">this</span><span class="s0">.rel=e,</span><span class="s1">this</span><span class="s0">.key=t,</span><span class="s1">this</span><span class="s0">.peers=r,</span><span class="s1">this</span><span class="s0">.paths=s,</span><span class="s1">this</span><span class="s0">.options=n}describe(){const e={rel:</span><span class="s1">this</span><span class="s0">.rel,peers:</span><span class="s1">this</span><span class="s0">.paths};</span><span class="s1">return null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.key&amp;&amp;(e.key=</span><span class="s1">this</span><span class="s0">.key.key),</span><span class="s2">&quot;.&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.peers[</span><span class="s3">0</span><span class="s0">].separator&amp;&amp;(e.options={...e.options,separator:</span><span class="s1">this</span><span class="s0">.peers[</span><span class="s3">0</span><span class="s0">].separator}),</span><span class="s1">this</span><span class="s0">.options.isPresent&amp;&amp;(e.options={...e.options,isPresent:</span><span class="s1">this</span><span class="s0">.options.isPresent}),e}},m.Keys=class extends Array{concat(e){const t=</span><span class="s1">this</span><span class="s0">.slice(),r=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;++e)r.set(t[e].key,e);</span><span class="s1">for</span><span class="s0">(const s of e){const e=s.key,n=r.get(e);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n?t[n]={key:e,schema:t[n].schema.concat(s.schema)}:t.push(s)}</span><span class="s1">return </span><span class="s0">t}}},</span><span class="s3">8785</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8068</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i=r(</span><span class="s3">3292</span><span class="s0">),o=r(</span><span class="s3">6354</span><span class="s0">),l={};e.exports=n.extend({type:</span><span class="s2">&quot;link&quot;</span><span class="s0">,properties:{schemaChain:!</span><span class="s3">0</span><span class="s0">},terms:{link:{init:</span><span class="s1">null</span><span class="s0">,manifest:</span><span class="s2">&quot;single&quot;</span><span class="s0">,register:!</span><span class="s3">1</span><span class="s0">}},args:(e,t)=&gt;e.ref(t),validate(e,t){let{schema:r,state:n,prefs:a}=t;s(r.$_terms.link,</span><span class="s2">&quot;Uninitialized link schema&quot;</span><span class="s0">);const i=l.generate(r,e,n,a),o=r.$_terms.link[</span><span class="s3">0</span><span class="s0">].ref;</span><span class="s1">return </span><span class="s0">i.$_validate(e,n.nest(i,`link:${o.display}:${i.type}`),a)},generate:(e,t,r,s)=&gt;l.generate(e,t,r,s),rules:{ref:{method(e){s(!</span><span class="s1">this</span><span class="s0">.$_terms.link,</span><span class="s2">&quot;Cannot reinitialize schema&quot;</span><span class="s0">),e=i.ref(e),s(</span><span class="s2">&quot;value&quot;</span><span class="s0">===e.type||</span><span class="s2">&quot;local&quot;</span><span class="s0">===e.type,</span><span class="s2">&quot;Invalid reference type:&quot;</span><span class="s0">,e.type),s(</span><span class="s2">&quot;local&quot;</span><span class="s0">===e.type||</span><span class="s2">&quot;root&quot;</span><span class="s0">===e.ancestor||e.ancestor&gt;</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;Link cannot reference itself&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return </span><span class="s0">t.$_terms.link=[{ref:e}],t}},relative:{method(){let e=!(arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">])||arguments[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;relative&quot;</span><span class="s0">,e)}}},overrides:{concat(e){s(</span><span class="s1">this</span><span class="s0">.$_terms.link,</span><span class="s2">&quot;Uninitialized link schema&quot;</span><span class="s0">),s(a.isSchema(e),</span><span class="s2">&quot;Invalid schema object&quot;</span><span class="s0">),s(</span><span class="s2">&quot;link&quot;</span><span class="s0">!==e.type,</span><span class="s2">&quot;Cannot merge type link with another link&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return </span><span class="s0">t.$_terms.whens||(t.$_terms.whens=[]),t.$_terms.whens.push({concat:e}),t.$_mutateRebuild()}},manifest:{build:(e,t)=&gt;(s(t.link,</span><span class="s2">&quot;Invalid link description missing link&quot;</span><span class="s0">),e.ref(t.link))}}),l.generate=</span><span class="s1">function</span><span class="s0">(e,t,r,s){let n=r.mainstay.links.get(e);</span><span class="s1">if</span><span class="s0">(n)</span><span class="s1">return </span><span class="s0">n._generate(t,r,s).schema;const a=e.$_terms.link[</span><span class="s3">0</span><span class="s0">].ref,{perspective:i,path:o}=l.perspective(a,r);l.assert(i,</span><span class="s2">&quot;which is outside of schema boundaries&quot;</span><span class="s0">,a,e,r,s);</span><span class="s1">try</span><span class="s0">{n=o.length?i.$_reach(o):i}</span><span class="s1">catch</span><span class="s0">(t){l.assert(!</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;to non-existing schema&quot;</span><span class="s0">,a,e,r,s)}</span><span class="s1">return </span><span class="s0">l.assert(</span><span class="s2">&quot;link&quot;</span><span class="s0">!==n.type,</span><span class="s2">&quot;which is another link&quot;</span><span class="s0">,a,e,r,s),e._flags.relative||r.mainstay.links.set(e,n),n._generate(t,r,s).schema},l.perspective=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;local&quot;</span><span class="s0">===e.type){</span><span class="s1">for</span><span class="s0">(const{schema:r,key:s}of t.schemas){</span><span class="s1">if</span><span class="s0">((r._flags.id||s)===e.path[</span><span class="s3">0</span><span class="s0">])</span><span class="s1">return</span><span class="s0">{perspective:r,path:e.path.slice(</span><span class="s3">1</span><span class="s0">)};</span><span class="s1">if</span><span class="s0">(r.$_terms.shared)</span><span class="s1">for</span><span class="s0">(const t of r.$_terms.shared)</span><span class="s1">if</span><span class="s0">(t._flags.id===e.path[</span><span class="s3">0</span><span class="s0">])</span><span class="s1">return</span><span class="s0">{perspective:t,path:e.path.slice(</span><span class="s3">1</span><span class="s0">)}}</span><span class="s1">return</span><span class="s0">{perspective:</span><span class="s1">null</span><span class="s0">,path:</span><span class="s1">null</span><span class="s0">}}</span><span class="s1">return</span><span class="s2">&quot;root&quot;</span><span class="s0">===e.ancestor?{perspective:t.schemas[t.schemas.length-1].schema,path:e.path}:{perspective:t.schemas[e.ancestor]&amp;&amp;t.schemas[e.ancestor].schema,path:e.path}},l.assert=</span><span class="s1">function</span><span class="s0">(e,t,r,n,a,i){e||s(!</span><span class="s3">1</span><span class="s0">,`</span><span class="s2">&quot;${o.label(n._flags,a,i)}&quot; </span><span class="s0">contains link reference </span><span class="s2">&quot;${r.display}&quot; </span><span class="s0">${t}`)}},</span><span class="s3">3832</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8068</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i={numberRx:/^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,exponentialPartRegex:/[eE][+-]?\d+$/,leadingSignAndZerosRegex:/^[+-]?(</span><span class="s3">0</span><span class="s0">*)?/,dotRegex:/\./,trailingZerosRegex:/</span><span class="s3">0</span><span class="s0">+$/};e.exports=n.extend({type:</span><span class="s2">&quot;number&quot;</span><span class="s0">,flags:{unsafe:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">}},coerce:{from:</span><span class="s2">&quot;string&quot;</span><span class="s0">,method(e,t){let{schema:r,error:s}=t;</span><span class="s1">if</span><span class="s0">(!e.match(i.numberRx))</span><span class="s1">return</span><span class="s0">;e=e.trim();const n={value:parseFloat(e)};</span><span class="s1">if</span><span class="s0">(</span><span class="s3">0</span><span class="s0">===n.value&amp;&amp;(n.value=</span><span class="s3">0</span><span class="s0">),!r._flags.unsafe)</span><span class="s1">if</span><span class="s0">(e.match(/e/i)){</span><span class="s1">if</span><span class="s0">(i.extractSignificantDigits(e)!==i.extractSignificantDigits(String(n.value)))</span><span class="s1">return </span><span class="s0">n.errors=s(</span><span class="s2">&quot;number.unsafe&quot;</span><span class="s0">),n}</span><span class="s1">else</span><span class="s0">{const t=n.value.toString();</span><span class="s1">if</span><span class="s0">(t.match(/e/i))</span><span class="s1">return </span><span class="s0">n;</span><span class="s1">if</span><span class="s0">(t!==i.normalizeDecimal(e))</span><span class="s1">return </span><span class="s0">n.errors=s(</span><span class="s2">&quot;number.unsafe&quot;</span><span class="s0">),n}</span><span class="s1">return </span><span class="s0">n}},validate(e,t){let{schema:r,error:s,prefs:n}=t;</span><span class="s1">if</span><span class="s0">(e===</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">||e===-</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">)</span><span class="s1">return</span><span class="s0">{value:e,errors:s(</span><span class="s2">&quot;number.infinity&quot;</span><span class="s0">)};</span><span class="s1">if</span><span class="s0">(!a.isNumber(e))</span><span class="s1">return</span><span class="s0">{value:e,errors:s(</span><span class="s2">&quot;number.base&quot;</span><span class="s0">)};const i={value:e};</span><span class="s1">if</span><span class="s0">(n.convert){const e=r.$_getRule(</span><span class="s2">&quot;precision&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(e){const t=Math.pow(</span><span class="s3">10</span><span class="s0">,e.args.limit);i.value=Math.round(i.value*t)/t}}</span><span class="s1">return </span><span class="s3">0</span><span class="s0">===i.value&amp;&amp;(i.value=</span><span class="s3">0</span><span class="s0">),!r._flags.unsafe&amp;&amp;(e&gt;Number.MAX_SAFE_INTEGER||e&lt;Number.MIN_SAFE_INTEGER)&amp;&amp;(i.errors=s(</span><span class="s2">&quot;number.unsafe&quot;</span><span class="s0">)),i},rules:{compare:{method:!</span><span class="s3">1</span><span class="s0">,validate(e,t,r,s){let{limit:n}=r,{name:i,operator:o,args:l}=s;</span><span class="s1">return </span><span class="s0">a.compare(e,n,o)?e:t.error(</span><span class="s2">&quot;number.&quot;</span><span class="s0">+i,{limit:l.limit,value:e})},args:[{name:</span><span class="s2">&quot;limit&quot;</span><span class="s0">,ref:!</span><span class="s3">0</span><span class="s0">,assert:a.isNumber,message:</span><span class="s2">&quot;must be a number&quot;</span><span class="s0">}]},greater:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;greater&quot;</span><span class="s0">,method:</span><span class="s2">&quot;compare&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">})}},integer:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;integer&quot;</span><span class="s0">)},validate:(e,t)=&gt;Math.trunc(e)-e==</span><span class="s3">0</span><span class="s0">?e:t.error(</span><span class="s2">&quot;number.integer&quot;</span><span class="s0">)},less:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;less&quot;</span><span class="s0">,method:</span><span class="s2">&quot;compare&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">})}},max:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;max&quot;</span><span class="s0">,method:</span><span class="s2">&quot;compare&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">})}},min:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;min&quot;</span><span class="s0">,method:</span><span class="s2">&quot;compare&quot;</span><span class="s0">,args:{limit:e},operator:</span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">})}},multiple:{method(e){</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;multiple&quot;</span><span class="s0">,args:{base:e}})},validate(e,t,r,s){let{base:n}=r;</span><span class="s1">return </span><span class="s0">e*(</span><span class="s3">1</span><span class="s0">/n)%</span><span class="s3">1</span><span class="s0">==</span><span class="s3">0</span><span class="s0">?e:t.error(</span><span class="s2">&quot;number.multiple&quot;</span><span class="s0">,{multiple:s.args.base,value:e})},args:[{name:</span><span class="s2">&quot;base&quot;</span><span class="s0">,ref:!</span><span class="s3">0</span><span class="s0">,assert:e=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;isFinite(e)&amp;&amp;e&gt;</span><span class="s3">0</span><span class="s0">,message:</span><span class="s2">&quot;must be a positive number&quot;</span><span class="s0">}],multi:!</span><span class="s3">0</span><span class="s0">},negative:{method(){</span><span class="s1">return this</span><span class="s0">.sign(</span><span class="s2">&quot;negative&quot;</span><span class="s0">)}},port:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;port&quot;</span><span class="s0">)},validate:(e,t)=&gt;Number.isSafeInteger(e)&amp;&amp;e&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;e&lt;=</span><span class="s3">65535</span><span class="s0">?e:t.error(</span><span class="s2">&quot;number.port&quot;</span><span class="s0">)},positive:{method(){</span><span class="s1">return this</span><span class="s0">.sign(</span><span class="s2">&quot;positive&quot;</span><span class="s0">)}},precision:{method(e){</span><span class="s1">return </span><span class="s0">s(Number.isSafeInteger(e),</span><span class="s2">&quot;limit must be an integer&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;precision&quot;</span><span class="s0">,args:{limit:e}})},validate(e,t,r){let{limit:s}=r;const n=e.toString().match(i.precisionRx);</span><span class="s1">return </span><span class="s0">Math.max((n[</span><span class="s3">1</span><span class="s0">]?n[</span><span class="s3">1</span><span class="s0">].length:</span><span class="s3">0</span><span class="s0">)-(n[</span><span class="s3">2</span><span class="s0">]?parseInt(n[</span><span class="s3">2</span><span class="s0">],</span><span class="s3">10</span><span class="s0">):</span><span class="s3">0</span><span class="s0">),</span><span class="s3">0</span><span class="s0">)&lt;=s?e:t.error(</span><span class="s2">&quot;number.precision&quot;</span><span class="s0">,{limit:s,value:e})},convert:!</span><span class="s3">0</span><span class="s0">},sign:{method(e){</span><span class="s1">return </span><span class="s0">s([</span><span class="s2">&quot;negative&quot;</span><span class="s0">,</span><span class="s2">&quot;positive&quot;</span><span class="s0">].includes(e),</span><span class="s2">&quot;Invalid sign&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;sign&quot;</span><span class="s0">,args:{sign:e}})},validate(e,t,r){let{sign:s}=r;</span><span class="s1">return</span><span class="s2">&quot;negative&quot;</span><span class="s0">===s&amp;&amp;e&lt;</span><span class="s3">0</span><span class="s0">||</span><span class="s2">&quot;positive&quot;</span><span class="s0">===s&amp;&amp;e&gt;</span><span class="s3">0</span><span class="s0">?e:t.error(`number.${s}`)}},unsafe:{method(){let e=!(arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">])||arguments[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">s(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;enabled must be a boolean&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">,e)}}},cast:{string:{from:e=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,to:(e,t)=&gt;e.toString()}},messages:{</span><span class="s2">&quot;number.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a number&quot;</span><span class="s0">,</span><span class="s2">&quot;number.greater&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be greater than {{#limit}}&quot;</span><span class="s0">,</span><span class="s2">&quot;number.infinity&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} cannot be infinity&quot;</span><span class="s0">,</span><span class="s2">&quot;number.integer&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be an integer&quot;</span><span class="s0">,</span><span class="s2">&quot;number.less&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be less than {{#limit}}&quot;</span><span class="s0">,</span><span class="s2">&quot;number.max&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be less than or equal to {{#limit}}&quot;</span><span class="s0">,</span><span class="s2">&quot;number.min&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be greater than or equal to {{#limit}}&quot;</span><span class="s0">,</span><span class="s2">&quot;number.multiple&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a multiple of {{#multiple}}&quot;</span><span class="s0">,</span><span class="s2">&quot;number.negative&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a negative number&quot;</span><span class="s0">,</span><span class="s2">&quot;number.port&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid port&quot;</span><span class="s0">,</span><span class="s2">&quot;number.positive&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a positive number&quot;</span><span class="s0">,</span><span class="s2">&quot;number.precision&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must have no more than {{#limit}} decimal places&quot;</span><span class="s0">,</span><span class="s2">&quot;number.unsafe&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a safe number&quot;</span><span class="s0">}}),i.extractSignificantDigits=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e.replace(i.exponentialPartRegex,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(i.dotRegex,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(i.trailingZerosRegex,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(i.leadingSignAndZerosRegex,</span><span class="s2">&quot;&quot;</span><span class="s0">)},i.normalizeDecimal=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">(e=e.replace(/^\+/,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(/\.</span><span class="s3">0</span><span class="s0">*$/,</span><span class="s2">&quot;&quot;</span><span class="s0">).replace(/^(-?)\.([^\.]*)$/,</span><span class="s2">&quot;$10.$2&quot;</span><span class="s0">).replace(/^(-?)</span><span class="s3">0</span><span class="s0">+([</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">])/,</span><span class="s2">&quot;$1$2&quot;</span><span class="s0">)).includes(</span><span class="s2">&quot;.&quot;</span><span class="s0">)&amp;&amp;e.endsWith(</span><span class="s2">&quot;0&quot;</span><span class="s0">)&amp;&amp;(e=e.replace(/</span><span class="s3">0</span><span class="s0">+$/,</span><span class="s2">&quot;&quot;</span><span class="s0">)),</span><span class="s2">&quot;-0&quot;</span><span class="s0">===e?</span><span class="s2">&quot;0&quot;</span><span class="s0">:e}},</span><span class="s3">8966</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">7824</span><span class="s0">);e.exports=s.extend({type:</span><span class="s2">&quot;object&quot;</span><span class="s0">,cast:{map:{from:e=&gt;e&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,to:(e,t)=&gt;</span><span class="s1">new </span><span class="s0">Map(Object.entries(e))}}})},</span><span class="s3">7417</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">5380</span><span class="s0">),a=r(</span><span class="s3">1745</span><span class="s0">),i=r(</span><span class="s3">9959</span><span class="s0">),o=r(</span><span class="s3">6064</span><span class="s0">),l=r(</span><span class="s3">9926</span><span class="s0">),c=r(</span><span class="s3">5752</span><span class="s0">),u=r(</span><span class="s3">8068</span><span class="s0">),f=r(</span><span class="s3">8160</span><span class="s0">),h={tlds:l </span><span class="s1">instanceof </span><span class="s0">Set&amp;&amp;{tlds:{allow:l,deny:</span><span class="s1">null</span><span class="s0">}},base64Regex:{</span><span class="s1">true</span><span class="s0">:{</span><span class="s1">true</span><span class="s0">:/^(?:[\w\-]{</span><span class="s3">2</span><span class="s0">}[\w\-]{</span><span class="s3">2</span><span class="s0">})*(?:[\w\-]{</span><span class="s3">2</span><span class="s0">}==|[\w\-]{</span><span class="s3">3</span><span class="s0">}=)?$/,</span><span class="s1">false</span><span class="s0">:/^(?:[A-Za-z0-9+\/]{</span><span class="s3">2</span><span class="s0">}[A-Za-z0-9+\/]{</span><span class="s3">2</span><span class="s0">})*(?:[A-Za-z0-9+\/]{</span><span class="s3">2</span><span class="s0">}==|[A-Za-z0-9+\/]{</span><span class="s3">3</span><span class="s0">}=)?$/},</span><span class="s1">false</span><span class="s0">:{</span><span class="s1">true</span><span class="s0">:/^(?:[\w\-]{</span><span class="s3">2</span><span class="s0">}[\w\-]{</span><span class="s3">2</span><span class="s0">})*(?:[\w\-]{</span><span class="s3">2</span><span class="s0">}(==)?|[\w\-]{</span><span class="s3">3</span><span class="s0">}=?)?$/,</span><span class="s1">false</span><span class="s0">:/^(?:[A-Za-z0-9+\/]{</span><span class="s3">2</span><span class="s0">}[A-Za-z0-9+\/]{</span><span class="s3">2</span><span class="s0">})*(?:[A-Za-z0-9+\/]{</span><span class="s3">2</span><span class="s0">}(==)?|[A-Za-z0-9+\/]{</span><span class="s3">3</span><span class="s0">}=?)?$/}},dataUriRegex:/^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,hexRegex:/^[a-f0-9]+$/i,ipRegex:i.regex({cidr:</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">}).regex,isoDurationRegex:/^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,guidBrackets:{</span><span class="s2">&quot;{&quot;</span><span class="s0">:</span><span class="s2">&quot;}&quot;</span><span class="s0">,</span><span class="s2">&quot;[&quot;</span><span class="s0">:</span><span class="s2">&quot;]&quot;</span><span class="s0">,</span><span class="s2">&quot;(&quot;</span><span class="s0">:</span><span class="s2">&quot;)&quot;</span><span class="s0">,</span><span class="s2">&quot;&quot;</span><span class="s0">:</span><span class="s2">&quot;&quot;</span><span class="s0">},guidVersions:{uuidv1:</span><span class="s2">&quot;1&quot;</span><span class="s0">,uuidv2:</span><span class="s2">&quot;2&quot;</span><span class="s0">,uuidv3:</span><span class="s2">&quot;3&quot;</span><span class="s0">,uuidv4:</span><span class="s2">&quot;4&quot;</span><span class="s0">,uuidv5:</span><span class="s2">&quot;5&quot;</span><span class="s0">},guidSeparators:</span><span class="s1">new </span><span class="s0">Set([</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;-&quot;</span><span class="s0">,</span><span class="s2">&quot;:&quot;</span><span class="s0">]),normalizationForms:[</span><span class="s2">&quot;NFC&quot;</span><span class="s0">,</span><span class="s2">&quot;NFD&quot;</span><span class="s0">,</span><span class="s2">&quot;NFKC&quot;</span><span class="s0">,</span><span class="s2">&quot;NFKD&quot;</span><span class="s0">]};e.exports=u.extend({type:</span><span class="s2">&quot;string&quot;</span><span class="s0">,flags:{insensitive:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">},truncate:{</span><span class="s1">default</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">}},terms:{replacements:{init:</span><span class="s1">null</span><span class="s0">}},coerce:{from:</span><span class="s2">&quot;string&quot;</span><span class="s0">,method(e,t){let{schema:r,state:s,prefs:n}=t;const a=r.$_getRule(</span><span class="s2">&quot;normalize&quot;</span><span class="s0">);a&amp;&amp;(e=e.normalize(a.args.form));const i=r.$_getRule(</span><span class="s2">&quot;case&quot;</span><span class="s0">);i&amp;&amp;(e=</span><span class="s2">&quot;upper&quot;</span><span class="s0">===i.args.direction?e.toLocaleUpperCase():e.toLocaleLowerCase());const o=r.$_getRule(</span><span class="s2">&quot;trim&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(o&amp;&amp;o.args.enabled&amp;&amp;(e=e.trim()),r.$_terms.replacements)</span><span class="s1">for</span><span class="s0">(const t of r.$_terms.replacements)e=e.replace(t.pattern,t.replacement);const l=r.$_getRule(</span><span class="s2">&quot;hex&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(l&amp;&amp;l.args.options.byteAligned&amp;&amp;e.length%</span><span class="s3">2</span><span class="s0">!=</span><span class="s3">0</span><span class="s0">&amp;&amp;(e=`</span><span class="s3">0</span><span class="s0">${e}`),r.$_getRule(</span><span class="s2">&quot;isoDate&quot;</span><span class="s0">)){const t=h.isoDate(e);t&amp;&amp;(e=t)}</span><span class="s1">if</span><span class="s0">(r._flags.truncate){const t=r.$_getRule(</span><span class="s2">&quot;max&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t){let a=t.args.limit;</span><span class="s1">if</span><span class="s0">(f.isResolvable(a)&amp;&amp;(a=a.resolve(e,s,n),!f.limit(a)))</span><span class="s1">return</span><span class="s0">{value:e,errors:r.$_createError(</span><span class="s2">&quot;any.ref&quot;</span><span class="s0">,a,{ref:t.args.limit,arg:</span><span class="s2">&quot;limit&quot;</span><span class="s0">,reason:</span><span class="s2">&quot;must be a positive integer&quot;</span><span class="s0">},s,n)};e=e.slice(</span><span class="s3">0</span><span class="s0">,a)}}</span><span class="s1">return</span><span class="s0">{value:e}}},validate(e,t){let{schema:r,error:s}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{value:e,errors:s(</span><span class="s2">&quot;string.base&quot;</span><span class="s0">)};</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;&quot;</span><span class="s0">===e){const t=r.$_getRule(</span><span class="s2">&quot;min&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;</span><span class="s3">0</span><span class="s0">===t.args.limit)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">return</span><span class="s0">{value:e,errors:s(</span><span class="s2">&quot;string.empty&quot;</span><span class="s0">)}}},rules:{alphanum:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;alphanum&quot;</span><span class="s0">)},validate:(e,t)=&gt;/^[a-zA-Z0-9]+$/.test(e)?e:t.error(</span><span class="s2">&quot;string.alphanum&quot;</span><span class="s0">)},base64:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">f.assertOptions(e,[</span><span class="s2">&quot;paddingRequired&quot;</span><span class="s0">,</span><span class="s2">&quot;urlSafe&quot;</span><span class="s0">]),e={urlSafe:!</span><span class="s3">1</span><span class="s0">,paddingRequired:!</span><span class="s3">0</span><span class="s0">,...e},s(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.paddingRequired,</span><span class="s2">&quot;paddingRequired must be boolean&quot;</span><span class="s0">),s(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.urlSafe,</span><span class="s2">&quot;urlSafe must be boolean&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;base64&quot;</span><span class="s0">,args:{options:e}})},validate(e,t,r){let{options:s}=r;</span><span class="s1">return </span><span class="s0">h.base64Regex[s.paddingRequired][s.urlSafe].test(e)?e:t.error(</span><span class="s2">&quot;string.base64&quot;</span><span class="s0">)}},</span><span class="s1">case</span><span class="s0">:{method(e){</span><span class="s1">return </span><span class="s0">s([</span><span class="s2">&quot;lower&quot;</span><span class="s0">,</span><span class="s2">&quot;upper&quot;</span><span class="s0">].includes(e),</span><span class="s2">&quot;Invalid case:&quot;</span><span class="s0">,e),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;case&quot;</span><span class="s0">,args:{direction:e}})},validate(e,t,r){let{direction:s}=r;</span><span class="s1">return</span><span class="s2">&quot;lower&quot;</span><span class="s0">===s&amp;&amp;e===e.toLocaleLowerCase()||</span><span class="s2">&quot;upper&quot;</span><span class="s0">===s&amp;&amp;e===e.toLocaleUpperCase()?e:t.error(`string.${s}</span><span class="s1">case</span><span class="s0">`)},convert:!</span><span class="s3">0</span><span class="s0">},creditCard:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;creditCard&quot;</span><span class="s0">)},validate(e,t){let r=e.length,s=</span><span class="s3">0</span><span class="s0">,n=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;r--;){const t=e.charAt(r)*n;s+=t-9*(t&gt;</span><span class="s3">9</span><span class="s0">),n^=</span><span class="s3">3</span><span class="s0">}</span><span class="s1">return </span><span class="s0">s&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;s%</span><span class="s3">10</span><span class="s0">==</span><span class="s3">0</span><span class="s0">?e:t.error(</span><span class="s2">&quot;string.creditCard&quot;</span><span class="s0">)}},dataUri:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">f.assertOptions(e,[</span><span class="s2">&quot;paddingRequired&quot;</span><span class="s0">]),e={paddingRequired:!</span><span class="s3">0</span><span class="s0">,...e},s(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.paddingRequired,</span><span class="s2">&quot;paddingRequired must be boolean&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;dataUri&quot;</span><span class="s0">,args:{options:e}})},validate(e,t,r){let{options:s}=r;const n=e.match(h.dataUriRegex);</span><span class="s1">if</span><span class="s0">(n){</span><span class="s1">if</span><span class="s0">(!n[</span><span class="s3">2</span><span class="s0">])</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;base64&quot;</span><span class="s0">!==n[</span><span class="s3">2</span><span class="s0">])</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(h.base64Regex[s.paddingRequired].</span><span class="s1">false</span><span class="s0">.test(n[</span><span class="s3">3</span><span class="s0">]))</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">return </span><span class="s0">t.error(</span><span class="s2">&quot;string.dataUri&quot;</span><span class="s0">)}},domain:{method(e){e&amp;&amp;f.assertOptions(e,[</span><span class="s2">&quot;allowFullyQualified&quot;</span><span class="s0">,</span><span class="s2">&quot;allowUnicode&quot;</span><span class="s0">,</span><span class="s2">&quot;maxDomainSegments&quot;</span><span class="s0">,</span><span class="s2">&quot;minDomainSegments&quot;</span><span class="s0">,</span><span class="s2">&quot;tlds&quot;</span><span class="s0">]);const t=h.addressOptions(e);</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;domain&quot;</span><span class="s0">,args:{options:e},address:t})},validate(e,t,r,s){let{address:a}=s;</span><span class="s1">return </span><span class="s0">n.isValid(e,a)?e:t.error(</span><span class="s2">&quot;string.domain&quot;</span><span class="s0">)}},email:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};f.assertOptions(e,[</span><span class="s2">&quot;allowFullyQualified&quot;</span><span class="s0">,</span><span class="s2">&quot;allowUnicode&quot;</span><span class="s0">,</span><span class="s2">&quot;ignoreLength&quot;</span><span class="s0">,</span><span class="s2">&quot;maxDomainSegments&quot;</span><span class="s0">,</span><span class="s2">&quot;minDomainSegments&quot;</span><span class="s0">,</span><span class="s2">&quot;multiple&quot;</span><span class="s0">,</span><span class="s2">&quot;separator&quot;</span><span class="s0">,</span><span class="s2">&quot;tlds&quot;</span><span class="s0">]),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.multiple||</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.multiple,</span><span class="s2">&quot;multiple option must be an boolean&quot;</span><span class="s0">);const t=h.addressOptions(e),r=</span><span class="s1">new </span><span class="s0">RegExp(`\\s*[${e.separator?o(e.separator):</span><span class="s2">&quot;,&quot;</span><span class="s0">}]\\s*`);</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;email&quot;</span><span class="s0">,args:{options:e},regex:r,address:t})},validate(e,t,r,s){let{options:n}=r,{regex:i,address:o}=s;const l=n.multiple?e.split(i):[e],c=[];</span><span class="s1">for</span><span class="s0">(const e of l)a.isValid(e,o)||c.push(e);</span><span class="s1">return </span><span class="s0">c.length?t.error(</span><span class="s2">&quot;string.email&quot;</span><span class="s0">,{value:e,invalids:c}):e}},guid:{alias:</span><span class="s2">&quot;uuid&quot;</span><span class="s0">,method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};f.assertOptions(e,[</span><span class="s2">&quot;version&quot;</span><span class="s0">,</span><span class="s2">&quot;separator&quot;</span><span class="s0">]);let t=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.version){const r=[].concat(e.version);s(r.length&gt;=</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;version must have at least 1 valid version specified&quot;</span><span class="s0">);const n=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;r.length;++e){const a=r[e];s(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">a,</span><span class="s2">&quot;version at position &quot;</span><span class="s0">+e+</span><span class="s2">&quot; must be a string&quot;</span><span class="s0">);const i=h.guidVersions[a.toLowerCase()];s(i,</span><span class="s2">&quot;version at position &quot;</span><span class="s0">+e+</span><span class="s2">&quot; must be one of &quot;</span><span class="s0">+Object.keys(h.guidVersions).join(</span><span class="s2">&quot;, &quot;</span><span class="s0">)),s(!n.has(i),</span><span class="s2">&quot;version at position &quot;</span><span class="s0">+e+</span><span class="s2">&quot; must not be a duplicate&quot;</span><span class="s0">),t+=i,n.add(i)}}s(h.guidSeparators.has(e.separator),</span><span class="s2">'separator must be one of true, false, &quot;-&quot;, or &quot;:&quot;'</span><span class="s0">);const r=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.separator?</span><span class="s2">&quot;[:-]?&quot;</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">===e.separator?</span><span class="s2">&quot;[:-]&quot;</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">===e.separator?</span><span class="s2">&quot;[]?&quot;</span><span class="s0">:`\\${e.separator}`,n=</span><span class="s1">new </span><span class="s0">RegExp(`^([\\[{\\(]?)[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">A-F]{</span><span class="s3">8</span><span class="s0">}(${r})[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">A-F]{</span><span class="s3">4</span><span class="s0">}\\</span><span class="s3">2</span><span class="s0">?[${t||</span><span class="s2">&quot;0-9A-F&quot;</span><span class="s0">}][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">A-F]{</span><span class="s3">3</span><span class="s0">}\\</span><span class="s3">2</span><span class="s0">?[${t?</span><span class="s2">&quot;89AB&quot;</span><span class="s0">:</span><span class="s2">&quot;0-9A-F&quot;</span><span class="s0">}][</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">A-F]{</span><span class="s3">3</span><span class="s0">}\\</span><span class="s3">2</span><span class="s0">?[</span><span class="s3">0</span><span class="s0">-</span><span class="s3">9</span><span class="s0">A-F]{</span><span class="s3">12</span><span class="s0">}([\\]}\\)]?)$`,</span><span class="s2">&quot;i&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;guid&quot;</span><span class="s0">,args:{options:e},regex:n})},validate(e,t,r,s){let{regex:n}=s;const a=n.exec(e);</span><span class="s1">return </span><span class="s0">a?h.guidBrackets[a[</span><span class="s3">1</span><span class="s0">]]!==a[a.length-1]?t.error(</span><span class="s2">&quot;string.guid&quot;</span><span class="s0">):e:t.error(</span><span class="s2">&quot;string.guid&quot;</span><span class="s0">)}},hex:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};</span><span class="s1">return </span><span class="s0">f.assertOptions(e,[</span><span class="s2">&quot;byteAligned&quot;</span><span class="s0">]),e={byteAligned:!</span><span class="s3">1</span><span class="s0">,...e},s(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.byteAligned,</span><span class="s2">&quot;byteAligned must be boolean&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;hex&quot;</span><span class="s0">,args:{options:e}})},validate(e,t,r){let{options:s}=r;</span><span class="s1">return </span><span class="s0">h.hexRegex.test(e)?s.byteAligned&amp;&amp;e.length%</span><span class="s3">2</span><span class="s0">!=</span><span class="s3">0</span><span class="s0">?t.error(</span><span class="s2">&quot;string.hexAlign&quot;</span><span class="s0">):e:t.error(</span><span class="s2">&quot;string.hex&quot;</span><span class="s0">)}},hostname:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;hostname&quot;</span><span class="s0">)},validate:(e,t)=&gt;n.isValid(e,{minDomainSegments:</span><span class="s3">1</span><span class="s0">})||h.ipRegex.test(e)?e:t.error(</span><span class="s2">&quot;string.hostname&quot;</span><span class="s0">)},insensitive:{method(){</span><span class="s1">return this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;insensitive&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)}},ip:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};f.assertOptions(e,[</span><span class="s2">&quot;cidr&quot;</span><span class="s0">,</span><span class="s2">&quot;version&quot;</span><span class="s0">]);const{cidr:t,versions:r,regex:s}=i.regex(e),n=e.version?r:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;ip&quot;</span><span class="s0">,args:{options:{cidr:t,version:n}},regex:s})},validate(e,t,r,s){let{options:n}=r,{regex:a}=s;</span><span class="s1">return </span><span class="s0">a.test(e)?e:n.version?t.error(</span><span class="s2">&quot;string.ipVersion&quot;</span><span class="s0">,{value:e,cidr:n.cidr,version:n.version}):t.error(</span><span class="s2">&quot;string.ip&quot;</span><span class="s0">,{value:e,cidr:n.cidr})}},isoDate:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;isoDate&quot;</span><span class="s0">)},validate(e,t){let{error:r}=t;</span><span class="s1">return </span><span class="s0">h.isoDate(e)?e:r(</span><span class="s2">&quot;string.isoDate&quot;</span><span class="s0">)}},isoDuration:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;isoDuration&quot;</span><span class="s0">)},validate:(e,t)=&gt;h.isoDurationRegex.test(e)?e:t.error(</span><span class="s2">&quot;string.isoDuration&quot;</span><span class="s0">)},length:{method(e,t){</span><span class="s1">return </span><span class="s0">h.length(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;length&quot;</span><span class="s0">,e,</span><span class="s2">&quot;=&quot;</span><span class="s0">,t)},validate(e,t,r,s){let{limit:n,encoding:a}=r,{name:i,operator:o,args:l}=s;const c=!a&amp;&amp;e.length;</span><span class="s1">return </span><span class="s0">f.compare(c,n,o)?e:t.error(</span><span class="s2">&quot;string.&quot;</span><span class="s0">+i,{limit:l.limit,value:e,encoding:a})},args:[{name:</span><span class="s2">&quot;limit&quot;</span><span class="s0">,ref:!</span><span class="s3">0</span><span class="s0">,assert:f.limit,message:</span><span class="s2">&quot;must be a positive integer&quot;</span><span class="s0">},</span><span class="s2">&quot;encoding&quot;</span><span class="s0">]},lowercase:{method(){</span><span class="s1">return this</span><span class="s0">.</span><span class="s1">case</span><span class="s0">(</span><span class="s2">&quot;lower&quot;</span><span class="s0">)}},max:{method(e,t){</span><span class="s1">return </span><span class="s0">h.length(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;max&quot;</span><span class="s0">,e,</span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">,t)},args:[</span><span class="s2">&quot;limit&quot;</span><span class="s0">,</span><span class="s2">&quot;encoding&quot;</span><span class="s0">]},min:{method(e,t){</span><span class="s1">return </span><span class="s0">h.length(</span><span class="s1">this</span><span class="s0">,</span><span class="s2">&quot;min&quot;</span><span class="s0">,e,</span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">,t)},args:[</span><span class="s2">&quot;limit&quot;</span><span class="s0">,</span><span class="s2">&quot;encoding&quot;</span><span class="s0">]},normalize:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:</span><span class="s2">&quot;NFC&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">s(h.normalizationForms.includes(e),</span><span class="s2">&quot;normalization form must be one of &quot;</span><span class="s0">+h.normalizationForms.join(</span><span class="s2">&quot;, &quot;</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;normalize&quot;</span><span class="s0">,args:{form:e}})},validate(e,t,r){let{error:s}=t,{form:n}=r;</span><span class="s1">return </span><span class="s0">e===e.normalize(n)?e:s(</span><span class="s2">&quot;string.normalize&quot;</span><span class="s0">,{value:e,form:n})},convert:!</span><span class="s3">0</span><span class="s0">},pattern:{alias:</span><span class="s2">&quot;regex&quot;</span><span class="s0">,method(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{};s(e </span><span class="s1">instanceof </span><span class="s0">RegExp,</span><span class="s2">&quot;regex must be a RegExp&quot;</span><span class="s0">),s(!e.flags.includes(</span><span class="s2">&quot;g&quot;</span><span class="s0">)&amp;&amp;!e.flags.includes(</span><span class="s2">&quot;y&quot;</span><span class="s0">),</span><span class="s2">&quot;regex should not use global or sticky mode&quot;</span><span class="s0">),</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;(t={name:t}),f.assertOptions(t,[</span><span class="s2">&quot;invert&quot;</span><span class="s0">,</span><span class="s2">&quot;name&quot;</span><span class="s0">]);const r=[</span><span class="s2">&quot;string.pattern&quot;</span><span class="s0">,t.invert?</span><span class="s2">&quot;.invert&quot;</span><span class="s0">:</span><span class="s2">&quot;&quot;</span><span class="s0">,t.name?</span><span class="s2">&quot;.name&quot;</span><span class="s0">:</span><span class="s2">&quot;.base&quot;</span><span class="s0">].join(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;pattern&quot;</span><span class="s0">,args:{regex:e,options:t},errorCode:r})},validate(e,t,r,s){let{regex:n,options:a}=r,{errorCode:i}=s;</span><span class="s1">return </span><span class="s0">n.test(e)^a.invert?e:t.error(i,{name:a.name,regex:n,value:e})},args:[</span><span class="s2">&quot;regex&quot;</span><span class="s0">,</span><span class="s2">&quot;options&quot;</span><span class="s0">],multi:!</span><span class="s3">0</span><span class="s0">},replace:{method(e,t){</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(e=</span><span class="s1">new </span><span class="s0">RegExp(o(e),</span><span class="s2">&quot;g&quot;</span><span class="s0">)),s(e </span><span class="s1">instanceof </span><span class="s0">RegExp,</span><span class="s2">&quot;pattern must be a RegExp&quot;</span><span class="s0">),s(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,</span><span class="s2">&quot;replacement must be a String&quot;</span><span class="s0">);const r=</span><span class="s1">this</span><span class="s0">.clone();</span><span class="s1">return </span><span class="s0">r.$_terms.replacements||(r.$_terms.replacements=[]),r.$_terms.replacements.push({pattern:e,replacement:t}),r}},token:{method(){</span><span class="s1">return this</span><span class="s0">.$_addRule(</span><span class="s2">&quot;token&quot;</span><span class="s0">)},validate:(e,t)=&gt;/^\w+$/.test(e)?e:t.error(</span><span class="s2">&quot;string.token&quot;</span><span class="s0">)},trim:{method(){let e=!(arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">])||arguments[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">s(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;enabled must be a boolean&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;trim&quot;</span><span class="s0">,args:{enabled:e}})},validate(e,t,r){let{enabled:s}=r;</span><span class="s1">return </span><span class="s0">s&amp;&amp;e!==e.trim()?t.error(</span><span class="s2">&quot;string.trim&quot;</span><span class="s0">):e},convert:!</span><span class="s3">0</span><span class="s0">},truncate:{method(){let e=!(arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">])||arguments[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">s(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;enabled must be a boolean&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.$_setFlag(</span><span class="s2">&quot;truncate&quot;</span><span class="s0">,e)}},uppercase:{method(){</span><span class="s1">return this</span><span class="s0">.</span><span class="s1">case</span><span class="s0">(</span><span class="s2">&quot;upper&quot;</span><span class="s0">)}},uri:{method(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};f.assertOptions(e,[</span><span class="s2">&quot;allowRelative&quot;</span><span class="s0">,</span><span class="s2">&quot;allowQuerySquareBrackets&quot;</span><span class="s0">,</span><span class="s2">&quot;domain&quot;</span><span class="s0">,</span><span class="s2">&quot;relativeOnly&quot;</span><span class="s0">,</span><span class="s2">&quot;scheme&quot;</span><span class="s0">]),e.domain&amp;&amp;f.assertOptions(e.domain,[</span><span class="s2">&quot;allowFullyQualified&quot;</span><span class="s0">,</span><span class="s2">&quot;allowUnicode&quot;</span><span class="s0">,</span><span class="s2">&quot;maxDomainSegments&quot;</span><span class="s0">,</span><span class="s2">&quot;minDomainSegments&quot;</span><span class="s0">,</span><span class="s2">&quot;tlds&quot;</span><span class="s0">]);const{regex:t,scheme:r}=c.regex(e),s=e.domain?h.addressOptions(e.domain):</span><span class="s1">null</span><span class="s0">;</span><span class="s1">return this</span><span class="s0">.$_addRule({name:</span><span class="s2">&quot;uri&quot;</span><span class="s0">,args:{options:e},regex:t,domain:s,scheme:r})},validate(e,t,r,s){let{options:a}=r,{regex:i,domain:o,scheme:l}=s;</span><span class="s1">if</span><span class="s0">([</span><span class="s2">&quot;http:/&quot;</span><span class="s0">,</span><span class="s2">&quot;https:/&quot;</span><span class="s0">].includes(e))</span><span class="s1">return </span><span class="s0">t.error(</span><span class="s2">&quot;string.uri&quot;</span><span class="s0">);const c=i.exec(e);</span><span class="s1">if</span><span class="s0">(c){const r=c[</span><span class="s3">1</span><span class="s0">]||c[</span><span class="s3">2</span><span class="s0">];</span><span class="s1">return</span><span class="s0">!o||a.allowRelative&amp;&amp;!r||n.isValid(r,o)?e:t.error(</span><span class="s2">&quot;string.domain&quot;</span><span class="s0">,{value:r})}</span><span class="s1">return </span><span class="s0">a.relativeOnly?t.error(</span><span class="s2">&quot;string.uriRelativeOnly&quot;</span><span class="s0">):a.scheme?t.error(</span><span class="s2">&quot;string.uriCustomScheme&quot;</span><span class="s0">,{scheme:l,value:e}):t.error(</span><span class="s2">&quot;string.uri&quot;</span><span class="s0">)}}},manifest:{build(e,t){</span><span class="s1">if</span><span class="s0">(t.replacements)</span><span class="s1">for</span><span class="s0">(const{pattern:r,replacement:s}of t.replacements)e=e.replace(r,s);</span><span class="s1">return </span><span class="s0">e}},messages:{</span><span class="s2">&quot;string.alphanum&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must only contain alpha-numeric characters&quot;</span><span class="s0">,</span><span class="s2">&quot;string.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a string&quot;</span><span class="s0">,</span><span class="s2">&quot;string.base64&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid base64 string&quot;</span><span class="s0">,</span><span class="s2">&quot;string.creditCard&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a credit card&quot;</span><span class="s0">,</span><span class="s2">&quot;string.dataUri&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid dataUri string&quot;</span><span class="s0">,</span><span class="s2">&quot;string.domain&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must contain a valid domain name&quot;</span><span class="s0">,</span><span class="s2">&quot;string.email&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid email&quot;</span><span class="s0">,</span><span class="s2">&quot;string.empty&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} is not allowed to be empty&quot;</span><span class="s0">,</span><span class="s2">&quot;string.guid&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid GUID&quot;</span><span class="s0">,</span><span class="s2">&quot;string.hex&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must only contain hexadecimal characters&quot;</span><span class="s0">,</span><span class="s2">&quot;string.hexAlign&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} hex decoded representation must be byte aligned&quot;</span><span class="s0">,</span><span class="s2">&quot;string.hostname&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid hostname&quot;</span><span class="s0">,</span><span class="s2">&quot;string.ip&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid ip address with a {{#cidr}} CIDR&quot;</span><span class="s0">,</span><span class="s2">&quot;string.ipVersion&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR&quot;</span><span class="s0">,</span><span class="s2">&quot;string.isoDate&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be in iso format&quot;</span><span class="s0">,</span><span class="s2">&quot;string.isoDuration&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid ISO 8601 duration&quot;</span><span class="s0">,</span><span class="s2">&quot;string.length&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} length must be {{#limit}} characters long&quot;</span><span class="s0">,</span><span class="s2">&quot;string.lowercase&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must only contain lowercase characters&quot;</span><span class="s0">,</span><span class="s2">&quot;string.max&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} length must be less than or equal to {{#limit}} characters long&quot;</span><span class="s0">,</span><span class="s2">&quot;string.min&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} length must be at least {{#limit}} characters long&quot;</span><span class="s0">,</span><span class="s2">&quot;string.normalize&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be unicode normalized in the {{#form}} form&quot;</span><span class="s0">,</span><span class="s2">&quot;string.token&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must only contain alpha-numeric and underscore characters&quot;</span><span class="s0">,</span><span class="s2">&quot;string.pattern.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}&quot;</span><span class="s0">,</span><span class="s2">&quot;string.pattern.name&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} with value {:[.]} fails to match the {{#name}} pattern&quot;</span><span class="s0">,</span><span class="s2">&quot;string.pattern.invert.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}&quot;</span><span class="s0">,</span><span class="s2">&quot;string.pattern.invert.name&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} with value {:[.]} matches the inverted {{#name}} pattern&quot;</span><span class="s0">,</span><span class="s2">&quot;string.trim&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must not have leading or trailing whitespace&quot;</span><span class="s0">,</span><span class="s2">&quot;string.uri&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid uri&quot;</span><span class="s0">,</span><span class="s2">&quot;string.uriCustomScheme&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern&quot;</span><span class="s0">,</span><span class="s2">&quot;string.uriRelativeOnly&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a valid relative uri&quot;</span><span class="s0">,</span><span class="s2">&quot;string.uppercase&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must only contain uppercase characters&quot;</span><span class="s0">}}),h.addressOptions=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.minDomainSegments||Number.isSafeInteger(e.minDomainSegments)&amp;&amp;e.minDomainSegments&gt;</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;minDomainSegments must be a positive integer&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.maxDomainSegments||Number.isSafeInteger(e.maxDomainSegments)&amp;&amp;e.maxDomainSegments&gt;</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;maxDomainSegments must be a positive integer&quot;</span><span class="s0">),!</span><span class="s3">1</span><span class="s0">===e.tlds)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">0</span><span class="s0">===e.tlds||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.tlds)</span><span class="s1">return </span><span class="s0">s(h.tlds,</span><span class="s2">&quot;Built-in TLD list disabled&quot;</span><span class="s0">),Object.assign({},e,h.tlds);s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.tlds,</span><span class="s2">&quot;tlds must be true, false, or an object&quot;</span><span class="s0">);const t=e.tlds.deny;</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">Array.isArray(t)&amp;&amp;(e=Object.assign({},e,{tlds:{deny:</span><span class="s1">new </span><span class="s0">Set(t)}})),s(e.tlds.deny </span><span class="s1">instanceof </span><span class="s0">Set,</span><span class="s2">&quot;tlds.deny must be an array, Set, or boolean&quot;</span><span class="s0">),s(!e.tlds.allow,</span><span class="s2">&quot;Cannot specify both tlds.allow and tlds.deny lists&quot;</span><span class="s0">),h.validateTlds(e.tlds.deny,</span><span class="s2">&quot;tlds.deny&quot;</span><span class="s0">),e;const r=e.tlds.allow;</span><span class="s1">return </span><span class="s0">r?!</span><span class="s3">0</span><span class="s0">===r?(s(h.tlds,</span><span class="s2">&quot;Built-in TLD list disabled&quot;</span><span class="s0">),Object.assign({},e,h.tlds)):(Array.isArray(r)&amp;&amp;(e=Object.assign({},e,{tlds:{allow:</span><span class="s1">new </span><span class="s0">Set(r)}})),s(e.tlds.allow </span><span class="s1">instanceof </span><span class="s0">Set,</span><span class="s2">&quot;tlds.allow must be an array, Set, or boolean&quot;</span><span class="s0">),h.validateTlds(e.tlds.allow,</span><span class="s2">&quot;tlds.allow&quot;</span><span class="s0">),e):e},h.validateTlds=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">for</span><span class="s0">(const r of e)s(n.isValid(r,{minDomainSegments:</span><span class="s3">1</span><span class="s0">,maxDomainSegments:</span><span class="s3">1</span><span class="s0">}),`${t} must contain valid top level domain names`)},h.isoDate=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!f.isIsoDate(e))</span><span class="s1">return null</span><span class="s0">;/.*T.*[+-]\d\d$/.test(e)&amp;&amp;(e+=</span><span class="s2">&quot;00&quot;</span><span class="s0">);const t=</span><span class="s1">new </span><span class="s0">Date(e);</span><span class="s1">return </span><span class="s0">isNaN(t.getTime())?</span><span class="s1">null</span><span class="s0">:t.toISOString()},h.length=</span><span class="s1">function</span><span class="s0">(e,t,r,n,a){</span><span class="s1">return </span><span class="s0">s(!a||!</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;Invalid encoding:&quot;</span><span class="s0">,a),e.$_addRule({name:t,method:</span><span class="s2">&quot;length&quot;</span><span class="s0">,args:{limit:r,encoding:a},operator:n})}},</span><span class="s3">8826</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8068</span><span class="s0">),a={};a.Map=class extends Map{slice(){</span><span class="s1">return new </span><span class="s0">a.Map(</span><span class="s1">this</span><span class="s0">)}},e.exports=n.extend({type:</span><span class="s2">&quot;symbol&quot;</span><span class="s0">,terms:{map:{init:</span><span class="s1">new </span><span class="s0">a.Map}},coerce:{method(e,t){let{schema:r,error:s}=t;const n=r.$_terms.map.get(e);</span><span class="s1">return </span><span class="s0">n&amp;&amp;(e=n),r._flags.only&amp;&amp;</span><span class="s2">&quot;symbol&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e?{value:e,errors:s(</span><span class="s2">&quot;symbol.map&quot;</span><span class="s0">,{map:r.$_terms.map})}:{value:e}}},validate(e,t){let{error:r}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;symbol&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">{value:e,errors:r(</span><span class="s2">&quot;symbol.base&quot;</span><span class="s0">)}},rules:{map:{method(e){e&amp;&amp;!e[Symbol.iterator]&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(e=Object.entries(e)),s(e&amp;&amp;e[Symbol.iterator],</span><span class="s2">&quot;Iterable must be an iterable or object&quot;</span><span class="s0">);const t=</span><span class="s1">this</span><span class="s0">.clone(),r=[];</span><span class="s1">for</span><span class="s0">(const n of e){s(n&amp;&amp;n[Symbol.iterator],</span><span class="s2">&quot;Entry must be an iterable&quot;</span><span class="s0">);const[e,a]=n;s(</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s2">&quot;symbol&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Key must not be of type object, function, or Symbol&quot;</span><span class="s0">),s(</span><span class="s2">&quot;symbol&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">a,</span><span class="s2">&quot;Value must be a Symbol&quot;</span><span class="s0">),t.$_terms.map.set(e,a),r.push(a)}</span><span class="s1">return </span><span class="s0">t.valid(...r)}}},manifest:{build:(e,t)=&gt;(t.map&amp;&amp;(e=e.map(t.map)),e)},messages:{</span><span class="s2">&quot;symbol.base&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be a symbol&quot;</span><span class="s0">,</span><span class="s2">&quot;symbol.map&quot;</span><span class="s0">:</span><span class="s2">&quot;{{#label}} must be one of {{#map}}&quot;</span><span class="s0">}})},</span><span class="s3">8863</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">738</span><span class="s0">),i=r(</span><span class="s3">9621</span><span class="s0">),o=r(</span><span class="s3">8160</span><span class="s0">),l=r(</span><span class="s3">6354</span><span class="s0">),c=r(</span><span class="s3">493</span><span class="s0">),u={result:Symbol(</span><span class="s2">&quot;result&quot;</span><span class="s0">)};t.entry=</span><span class="s1">function</span><span class="s0">(e,t,r){let n=o.defaults;r&amp;&amp;(s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r.warnings,</span><span class="s2">&quot;Cannot override warnings preference in synchronous validation&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r.artifacts,</span><span class="s2">&quot;Cannot override artifacts preference in synchronous validation&quot;</span><span class="s0">),n=o.preferences(o.defaults,r));const a=u.entry(e,t,n);s(!a.mainstay.externals.length,</span><span class="s2">&quot;Schema with external rules must use validateAsync()&quot;</span><span class="s0">);const i={value:a.value};</span><span class="s1">return </span><span class="s0">a.error&amp;&amp;(i.error=a.error),a.mainstay.warnings.length&amp;&amp;(i.warning=l.details(a.mainstay.warnings)),a.mainstay.debug&amp;&amp;(i.debug=a.mainstay.debug),a.mainstay.artifacts&amp;&amp;(i.artifacts=a.mainstay.artifacts),i},t.entryAsync=async </span><span class="s1">function</span><span class="s0">(e,t,r){let s=o.defaults;r&amp;&amp;(s=o.preferences(o.defaults,r));const n=u.entry(e,t,s),a=n.mainstay;</span><span class="s1">if</span><span class="s0">(n.error)</span><span class="s1">throw </span><span class="s0">a.debug&amp;&amp;(n.error.debug=a.debug),n.error;</span><span class="s1">if</span><span class="s0">(a.externals.length){let t=n.value;const c=[];</span><span class="s1">for</span><span class="s0">(const n of a.externals){const f=n.state.path,h=</span><span class="s2">&quot;link&quot;</span><span class="s0">===n.schema.type?a.links.get(n.schema):</span><span class="s1">null</span><span class="s0">;let m,d,p=t;const g=f.length?[t]:[],y=f.length?i(e,f):e;</span><span class="s1">if</span><span class="s0">(f.length){m=f[f.length-1];let e=t;</span><span class="s1">for</span><span class="s0">(const t of f.slice(</span><span class="s3">0</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">))e=e[t],g.unshift(e);d=g[</span><span class="s3">0</span><span class="s0">],p=d[m]}</span><span class="s1">try</span><span class="s0">{const e=(e,t)=&gt;(h||n.schema).$_createError(e,p,t,n.state,s),i=await n.method(p,{schema:n.schema,linked:h,state:n.state,prefs:r,original:y,error:e,errorsArray:u.errorsArray,warn:(e,t)=&gt;a.warnings.push((h||n.schema).$_createError(e,p,t,n.state,s)),message:(e,t)=&gt;(h||n.schema).$_createError(</span><span class="s2">&quot;external&quot;</span><span class="s0">,p,t,n.state,s,{messages:e})});</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===i||i===p)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(i </span><span class="s1">instanceof </span><span class="s0">l.Report){</span><span class="s1">if</span><span class="s0">(a.tracer.log(n.schema,n.state,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,</span><span class="s2">&quot;external&quot;</span><span class="s0">,</span><span class="s2">&quot;error&quot;</span><span class="s0">),c.push(i),s.abortEarly)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(Array.isArray(i)&amp;&amp;i[o.symbols.errors]){</span><span class="s1">if</span><span class="s0">(a.tracer.log(n.schema,n.state,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,</span><span class="s2">&quot;external&quot;</span><span class="s0">,</span><span class="s2">&quot;error&quot;</span><span class="s0">),c.push(...i),s.abortEarly)</span><span class="s1">break</span><span class="s0">;</span><span class="s1">continue</span><span class="s0">}d?(a.tracer.value(n.state,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,p,i,</span><span class="s2">&quot;external&quot;</span><span class="s0">),d[m]=i):(a.tracer.value(n.state,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,t,i,</span><span class="s2">&quot;external&quot;</span><span class="s0">),t=i)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">throw </span><span class="s0">s.errors.label&amp;&amp;(e.message+=` (${n.label})`),e}}</span><span class="s1">if</span><span class="s0">(n.value=t,c.length)</span><span class="s1">throw </span><span class="s0">n.error=l.process(c,e,s),a.debug&amp;&amp;(n.error.debug=a.debug),n.error}</span><span class="s1">if</span><span class="s0">(!s.warnings&amp;&amp;!s.debug&amp;&amp;!s.artifacts)</span><span class="s1">return </span><span class="s0">n.value;const c={value:n.value};</span><span class="s1">return </span><span class="s0">a.warnings.length&amp;&amp;(c.warning=l.details(a.warnings)),a.debug&amp;&amp;(c.debug=a.debug),a.artifacts&amp;&amp;(c.artifacts=a.artifacts),c},u.Mainstay=class{constructor(e,t,r){</span><span class="s1">this</span><span class="s0">.externals=[],</span><span class="s1">this</span><span class="s0">.warnings=[],</span><span class="s1">this</span><span class="s0">.tracer=e,</span><span class="s1">this</span><span class="s0">.debug=t,</span><span class="s1">this</span><span class="s0">.links=r,</span><span class="s1">this</span><span class="s0">.shadow=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.artifacts=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">._snapshots=[]}snapshot(){</span><span class="s1">this</span><span class="s0">._snapshots.push({externals:</span><span class="s1">this</span><span class="s0">.externals.slice(),warnings:</span><span class="s1">this</span><span class="s0">.warnings.slice()})}restore(){const e=</span><span class="s1">this</span><span class="s0">._snapshots.pop();</span><span class="s1">this</span><span class="s0">.externals=e.externals,</span><span class="s1">this</span><span class="s0">.warnings=e.warnings}commit(){</span><span class="s1">this</span><span class="s0">._snapshots.pop()}},u.entry=</span><span class="s1">function</span><span class="s0">(e,r,s){const{tracer:n,cleanup:a}=u.tracer(r,s),i=s.debug?[]:</span><span class="s1">null</span><span class="s0">,o=r._ids._schemaChain?</span><span class="s1">new </span><span class="s0">Map:</span><span class="s1">null</span><span class="s0">,f=</span><span class="s1">new </span><span class="s0">u.Mainstay(n,i,o),h=r._ids._schemaChain?[{schema:r}]:</span><span class="s1">null</span><span class="s0">,m=</span><span class="s1">new </span><span class="s0">c([],[],{mainstay:f,schemas:h}),d=t.validate(e,r,m,s);a&amp;&amp;r.$_root.untrace();const p=l.process(d.errors,e,s);</span><span class="s1">return</span><span class="s0">{value:d.value,error:p,mainstay:f}},u.tracer=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">e.$_root._tracer?{tracer:e.$_root._tracer._register(e)}:t.debug?(s(e.$_root.trace,</span><span class="s2">&quot;Debug mode not supported&quot;</span><span class="s0">),{tracer:e.$_root.trace()._register(e),cleanup:!</span><span class="s3">0</span><span class="s0">}):{tracer:u.ignore}},t.validate=</span><span class="s1">function</span><span class="s0">(e,t,r,s){let n=arguments.length&gt;</span><span class="s3">4</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">4</span><span class="s0">]?arguments[</span><span class="s3">4</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">(t.$_terms.whens&amp;&amp;(t=t._generate(e,r,s).schema),t._preferences&amp;&amp;(s=u.prefs(t,s)),t._cache&amp;&amp;s.cache){const s=t._cache.get(e);</span><span class="s1">if</span><span class="s0">(r.mainstay.tracer.debug(r,</span><span class="s2">&quot;validate&quot;</span><span class="s0">,</span><span class="s2">&quot;cached&quot;</span><span class="s0">,!!s),s)</span><span class="s1">return </span><span class="s0">s}const a=(n,a,i)=&gt;t.$_createError(n,e,a,i||r,s),i={original:e,prefs:s,schema:t,state:r,error:a,errorsArray:u.errorsArray,warn:(e,t,s)=&gt;r.mainstay.warnings.push(a(e,t,s)),message:(n,a)=&gt;t.$_createError(</span><span class="s2">&quot;custom&quot;</span><span class="s0">,e,a,r,s,{messages:n})};r.mainstay.tracer.entry(t,r);const l=t._definition;</span><span class="s1">if</span><span class="s0">(l.prepare&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;s.convert){const t=l.prepare(e,i);</span><span class="s1">if</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(r.mainstay.tracer.value(r,</span><span class="s2">&quot;prepare&quot;</span><span class="s0">,e,t.value),t.errors)</span><span class="s1">return </span><span class="s0">u.finalize(t.value,[].concat(t.errors),i);e=t.value}}</span><span class="s1">if</span><span class="s0">(l.coerce&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;s.convert&amp;&amp;(!l.coerce.from||l.coerce.from.includes(</span><span class="s1">typeof </span><span class="s0">e))){const t=l.coerce.method(e,i);</span><span class="s1">if</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(r.mainstay.tracer.value(r,</span><span class="s2">&quot;coerced&quot;</span><span class="s0">,e,t.value),t.errors)</span><span class="s1">return </span><span class="s0">u.finalize(t.value,[].concat(t.errors),i);e=t.value}}const c=t._flags.empty;c&amp;&amp;c.$_match(u.trim(e,t),r.nest(c),o.defaults)&amp;&amp;(r.mainstay.tracer.value(r,</span><span class="s2">&quot;empty&quot;</span><span class="s0">,e,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),e=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">);const f=n.presence||t._flags.presence||(t._flags._endedSwitch?</span><span class="s1">null</span><span class="s0">:s.presence);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">===f)</span><span class="s1">return </span><span class="s0">u.finalize(e,</span><span class="s1">null</span><span class="s0">,i);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;required&quot;</span><span class="s0">===f)</span><span class="s1">return </span><span class="s0">u.finalize(e,[t.$_createError(</span><span class="s2">&quot;any.required&quot;</span><span class="s0">,e,</span><span class="s1">null</span><span class="s0">,r,s)],i);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;optional&quot;</span><span class="s0">===f){</span><span class="s1">if</span><span class="s0">(t._flags.</span><span class="s1">default</span><span class="s0">!==o.symbols.deepDefault)</span><span class="s1">return </span><span class="s0">u.finalize(e,</span><span class="s1">null</span><span class="s0">,i);r.mainstay.tracer.value(r,</span><span class="s2">&quot;default&quot;</span><span class="s0">,e,{}),e={}}}</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">===f)</span><span class="s1">return </span><span class="s0">u.finalize(e,[t.$_createError(</span><span class="s2">&quot;any.unknown&quot;</span><span class="s0">,e,</span><span class="s1">null</span><span class="s0">,r,s)],i);const h=[];</span><span class="s1">if</span><span class="s0">(t._valids){const n=t._valids.get(e,r,s,t._flags.insensitive);</span><span class="s1">if</span><span class="s0">(n)</span><span class="s1">return </span><span class="s0">s.convert&amp;&amp;(r.mainstay.tracer.value(r,</span><span class="s2">&quot;valids&quot;</span><span class="s0">,e,n.value),e=n.value),r.mainstay.tracer.filter(t,r,</span><span class="s2">&quot;valid&quot;</span><span class="s0">,n),u.finalize(e,</span><span class="s1">null</span><span class="s0">,i);</span><span class="s1">if</span><span class="s0">(t._flags.only){const n=t.$_createError(</span><span class="s2">&quot;any.only&quot;</span><span class="s0">,e,{valids:t._valids.values({display:!</span><span class="s3">0</span><span class="s0">})},r,s);</span><span class="s1">if</span><span class="s0">(s.abortEarly)</span><span class="s1">return </span><span class="s0">u.finalize(e,[n],i);h.push(n)}}</span><span class="s1">if</span><span class="s0">(t._invalids){const n=t._invalids.get(e,r,s,t._flags.insensitive);</span><span class="s1">if</span><span class="s0">(n){r.mainstay.tracer.filter(t,r,</span><span class="s2">&quot;invalid&quot;</span><span class="s0">,n);const a=t.$_createError(</span><span class="s2">&quot;any.invalid&quot;</span><span class="s0">,e,{invalids:t._invalids.values({display:!</span><span class="s3">0</span><span class="s0">})},r,s);</span><span class="s1">if</span><span class="s0">(s.abortEarly)</span><span class="s1">return </span><span class="s0">u.finalize(e,[a],i);h.push(a)}}</span><span class="s1">if</span><span class="s0">(l.validate){const t=l.validate(e,i);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;(r.mainstay.tracer.value(r,</span><span class="s2">&quot;base&quot;</span><span class="s0">,e,t.value),e=t.value,t.errors)){</span><span class="s1">if</span><span class="s0">(!Array.isArray(t.errors))</span><span class="s1">return </span><span class="s0">h.push(t.errors),u.finalize(e,h,i);</span><span class="s1">if</span><span class="s0">(t.errors.length)</span><span class="s1">return </span><span class="s0">h.push(...t.errors),u.finalize(e,h,i)}}</span><span class="s1">return </span><span class="s0">t._rules.length?u.rules(e,h,i):u.finalize(e,h,i)},u.rules=</span><span class="s1">function</span><span class="s0">(e,t,r){const{schema:s,state:n,prefs:a}=r;</span><span class="s1">for</span><span class="s0">(const i of s._rules){const l=s._definition.rules[i.method];</span><span class="s1">if</span><span class="s0">(l.convert&amp;&amp;a.convert){n.mainstay.tracer.log(s,n,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,i.name,</span><span class="s2">&quot;full&quot;</span><span class="s0">);</span><span class="s1">continue</span><span class="s0">}let c,f=i.args;</span><span class="s1">if</span><span class="s0">(i._resolve.length){f=Object.assign({},f);</span><span class="s1">for</span><span class="s0">(const t of i._resolve){const r=l.argsByName.get(t),i=f[t].resolve(e,n,a),u=r.normalize?r.normalize(i):i,h=o.validateArg(u,</span><span class="s1">null</span><span class="s0">,r);</span><span class="s1">if</span><span class="s0">(h){c=s.$_createError(</span><span class="s2">&quot;any.ref&quot;</span><span class="s0">,i,{arg:t,ref:f[t],reason:h},n,a);</span><span class="s1">break</span><span class="s0">}f[t]=u}}c=c||l.validate(e,r,f,i);const h=u.rule(c,i);</span><span class="s1">if</span><span class="s0">(h.errors){</span><span class="s1">if</span><span class="s0">(n.mainstay.tracer.log(s,n,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,i.name,</span><span class="s2">&quot;error&quot;</span><span class="s0">),i.warn){n.mainstay.warnings.push(...h.errors);</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(a.abortEarly)</span><span class="s1">return </span><span class="s0">u.finalize(e,h.errors,r);t.push(...h.errors)}</span><span class="s1">else </span><span class="s0">n.mainstay.tracer.log(s,n,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,i.name,</span><span class="s2">&quot;pass&quot;</span><span class="s0">),n.mainstay.tracer.value(n,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,e,h.value,i.name),e=h.value}</span><span class="s1">return </span><span class="s0">u.finalize(e,t,r)},u.rule=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">e </span><span class="s1">instanceof </span><span class="s0">l.Report?(u.error(e,t),{errors:[e],value:</span><span class="s1">null</span><span class="s0">}):Array.isArray(e)&amp;&amp;e[o.symbols.errors]?(e.forEach((e=&gt;u.error(e,t))),{errors:e,value:</span><span class="s1">null</span><span class="s0">}):{errors:</span><span class="s1">null</span><span class="s0">,value:e}},u.error=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">t.message&amp;&amp;e._setTemplate(t.message),e},u.finalize=</span><span class="s1">function</span><span class="s0">(e,t,r){t=t||[];const{schema:n,state:a,prefs:i}=r;</span><span class="s1">if</span><span class="s0">(t.length){const s=u.</span><span class="s1">default</span><span class="s0">(</span><span class="s2">&quot;failover&quot;</span><span class="s0">,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,t,r);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==s&amp;&amp;(a.mainstay.tracer.value(a,</span><span class="s2">&quot;failover&quot;</span><span class="s0">,e,s),e=s,t=[])}</span><span class="s1">if</span><span class="s0">(t.length&amp;&amp;n._flags.error)</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n._flags.error){t=n._flags.error(t),Array.isArray(t)||(t=[t]);</span><span class="s1">for</span><span class="s0">(const e of t)s(e </span><span class="s1">instanceof </span><span class="s0">Error||e </span><span class="s1">instanceof </span><span class="s0">l.Report,</span><span class="s2">&quot;error() must return an Error object&quot;</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">t=[n._flags.error];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e){const s=u.</span><span class="s1">default</span><span class="s0">(</span><span class="s2">&quot;default&quot;</span><span class="s0">,e,t,r);a.mainstay.tracer.value(a,</span><span class="s2">&quot;default&quot;</span><span class="s0">,e,s),e=s}</span><span class="s1">if</span><span class="s0">(n._flags.cast&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e){const t=n._definition.cast[n._flags.cast];</span><span class="s1">if</span><span class="s0">(t.from(e)){const s=t.to(e,r);a.mainstay.tracer.value(a,</span><span class="s2">&quot;cast&quot;</span><span class="s0">,e,s,n._flags.cast),e=s}}</span><span class="s1">if</span><span class="s0">(n.$_terms.externals&amp;&amp;i.externals&amp;&amp;!</span><span class="s3">1</span><span class="s0">!==i._externals)</span><span class="s1">for</span><span class="s0">(const{method:e}of n.$_terms.externals)a.mainstay.externals.push({method:e,schema:n,state:a,label:l.label(n._flags,a,i)});const o={value:e,errors:t.length?t:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">return </span><span class="s0">n._flags.result&amp;&amp;(o.value=</span><span class="s2">&quot;strip&quot;</span><span class="s0">===n._flags.result?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:r.original,a.mainstay.tracer.value(a,n._flags.result,e,o.value),a.shadow(e,n._flags.result)),n._cache&amp;&amp;!</span><span class="s3">1</span><span class="s0">!==i.cache&amp;&amp;!n._refs.length&amp;&amp;n._cache.set(r.original,o),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e||o.errors||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===n._flags.artifact||(a.mainstay.artifacts=a.mainstay.artifacts||</span><span class="s1">new </span><span class="s0">Map,a.mainstay.artifacts.has(n._flags.artifact)||a.mainstay.artifacts.set(n._flags.artifact,[]),a.mainstay.artifacts.get(n._flags.artifact).push(a.path)),o},u.prefs=</span><span class="s1">function</span><span class="s0">(e,t){const r=t===o.defaults;</span><span class="s1">return </span><span class="s0">r&amp;&amp;e._preferences[o.symbols.prefs]?e._preferences[o.symbols.prefs]:(t=o.preferences(t,e._preferences),r&amp;&amp;(e._preferences[o.symbols.prefs]=t),t)},u.</span><span class="s1">default</span><span class="s0">=</span><span class="s1">function</span><span class="s0">(e,t,r,s){const{schema:a,state:i,prefs:l}=s,c=a._flags[e];</span><span class="s1">if</span><span class="s0">(l.noDefaults||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===c)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">if</span><span class="s0">(i.mainstay.tracer.log(a,i,</span><span class="s2">&quot;rule&quot;</span><span class="s0">,e,</span><span class="s2">&quot;full&quot;</span><span class="s0">),!c)</span><span class="s1">return </span><span class="s0">c;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">c){const t=c.length?[n(i.ancestors[</span><span class="s3">0</span><span class="s0">]),s]:[];</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">c(...t)}</span><span class="s1">catch</span><span class="s0">(t){</span><span class="s1">return void </span><span class="s0">r.push(a.$_createError(`any.${e}`,</span><span class="s1">null</span><span class="s0">,{error:t},i,l))}}</span><span class="s1">return</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">c?c:c[o.symbols.literal]?c.literal:o.isResolvable(c)?c.resolve(t,i,l):n(c)},u.trim=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return </span><span class="s0">e;const r=t.$_getRule(</span><span class="s2">&quot;trim&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r&amp;&amp;r.args.enabled?e.trim():e},u.ignore={active:!</span><span class="s3">1</span><span class="s0">,debug:a,entry:a,filter:a,log:a,resolve:a,value:a},u.errorsArray=</span><span class="s1">function</span><span class="s0">(){const e=[];</span><span class="s1">return </span><span class="s0">e[o.symbols.errors]=!</span><span class="s3">0</span><span class="s0">,e}},</span><span class="s3">2036</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">9474</span><span class="s0">),a=r(</span><span class="s3">8160</span><span class="s0">),i={};e.exports=i.Values=class{constructor(e,t){</span><span class="s1">this</span><span class="s0">._values=</span><span class="s1">new </span><span class="s0">Set(e),</span><span class="s1">this</span><span class="s0">._refs=</span><span class="s1">new </span><span class="s0">Set(t),</span><span class="s1">this</span><span class="s0">._lowercase=i.lowercases(e),</span><span class="s1">this</span><span class="s0">._override=!</span><span class="s3">1</span><span class="s0">}get length(){</span><span class="s1">return this</span><span class="s0">._values.size+</span><span class="s1">this</span><span class="s0">._refs.size}add(e,t){a.isResolvable(e)?</span><span class="s1">this</span><span class="s0">._refs.has(e)||(</span><span class="s1">this</span><span class="s0">._refs.add(e),t&amp;&amp;t.register(e)):</span><span class="s1">this</span><span class="s0">.has(e,</span><span class="s1">null</span><span class="s0">,</span><span class="s1">null</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">)||(</span><span class="s1">this</span><span class="s0">._values.add(e),</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s1">this</span><span class="s0">._lowercase.set(e.toLowerCase(),e))}static merge(e,t,r){</span><span class="s1">if</span><span class="s0">(e=e||</span><span class="s1">new </span><span class="s0">i.Values,t){</span><span class="s1">if</span><span class="s0">(t._override)</span><span class="s1">return </span><span class="s0">t.clone();</span><span class="s1">for</span><span class="s0">(const r of[...t._values,...t._refs])e.add(r)}</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">for</span><span class="s0">(const t of[...r._values,...r._refs])e.remove(t);</span><span class="s1">return </span><span class="s0">e.length?e:</span><span class="s1">null</span><span class="s0">}remove(e){a.isResolvable(e)?</span><span class="s1">this</span><span class="s0">._refs.</span><span class="s1">delete</span><span class="s0">(e):(</span><span class="s1">this</span><span class="s0">._values.</span><span class="s1">delete</span><span class="s0">(e),</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s1">this</span><span class="s0">._lowercase.</span><span class="s1">delete</span><span class="s0">(e.toLowerCase()))}has(e,t,r,s){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.get(e,t,r,s)}get(e,t,r,s){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.length)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">._values.has(e))</span><span class="s1">return</span><span class="s0">{value:e};</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;e&amp;&amp;s){const t=</span><span class="s1">this</span><span class="s0">._lowercase.get(e.toLowerCase());</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return</span><span class="s0">{value:t}}</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._refs.size&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">for</span><span class="s0">(const t of </span><span class="s1">this</span><span class="s0">._values)</span><span class="s1">if</span><span class="s0">(n(t,e))</span><span class="s1">return</span><span class="s0">{value:t};</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">for</span><span class="s0">(const a of </span><span class="s1">this</span><span class="s0">._refs){const i=a.resolve(e,t,r,</span><span class="s1">null</span><span class="s0">,{</span><span class="s1">in</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">});</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===i)</span><span class="s1">continue</span><span class="s0">;const o=a.</span><span class="s1">in</span><span class="s0">&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i?Array.isArray(i)?i:Object.keys(i):[i];</span><span class="s1">for</span><span class="s0">(const t of o)</span><span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">t==</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">if</span><span class="s0">(s&amp;&amp;e&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){</span><span class="s1">if</span><span class="s0">(t.toLowerCase()===e.toLowerCase())</span><span class="s1">return</span><span class="s0">{value:t,ref:a}}</span><span class="s1">else if</span><span class="s0">(n(t,e))</span><span class="s1">return</span><span class="s0">{value:t,ref:a}}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}override(){</span><span class="s1">this</span><span class="s0">._override=!</span><span class="s3">0</span><span class="s0">}values(e){</span><span class="s1">if</span><span class="s0">(e&amp;&amp;e.display){const e=[];</span><span class="s1">for</span><span class="s0">(const t of[...</span><span class="s1">this</span><span class="s0">._values,...</span><span class="s1">this</span><span class="s0">._refs])</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t&amp;&amp;e.push(t);</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">return </span><span class="s0">Array.from([...</span><span class="s1">this</span><span class="s0">._values,...</span><span class="s1">this</span><span class="s0">._refs])}clone(){const e=</span><span class="s1">new </span><span class="s0">i.Values(</span><span class="s1">this</span><span class="s0">._values,</span><span class="s1">this</span><span class="s0">._refs);</span><span class="s1">return </span><span class="s0">e._override=</span><span class="s1">this</span><span class="s0">._override,e}concat(e){s(!e._override,</span><span class="s2">&quot;Cannot concat override set of values&quot;</span><span class="s0">);const t=</span><span class="s1">new </span><span class="s0">i.Values([...</span><span class="s1">this</span><span class="s0">._values,...e._values],[...</span><span class="s1">this</span><span class="s0">._refs,...e._refs]);</span><span class="s1">return </span><span class="s0">t._override=</span><span class="s1">this</span><span class="s0">._override,t}describe(){const e=[];</span><span class="s1">this</span><span class="s0">._override&amp;&amp;e.push({override:!</span><span class="s3">0</span><span class="s0">});</span><span class="s1">for</span><span class="s0">(const t of </span><span class="s1">this</span><span class="s0">._values.values())e.push(t&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?{value:t}:t);</span><span class="s1">for</span><span class="s0">(const t of </span><span class="s1">this</span><span class="s0">._refs.values())e.push(t.describe());</span><span class="s1">return </span><span class="s0">e}},i.Values.prototype[a.symbols.values]=!</span><span class="s3">0</span><span class="s0">,i.Values.prototype.slice=i.Values.prototype.clone,i.lowercases=</span><span class="s1">function</span><span class="s0">(e){const t=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">for</span><span class="s0">(const r of e)</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;t.set(r.toLowerCase(),r);</span><span class="s1">return </span><span class="s0">t}},</span><span class="s3">978</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">1687</span><span class="s0">),i=r(</span><span class="s3">9621</span><span class="s0">),o={};e.exports=</span><span class="s1">function</span><span class="s0">(e,t){let r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:{};</span><span class="s1">if</span><span class="s0">(s(e&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid defaults value: must be an object&quot;</span><span class="s0">),s(!t||!</span><span class="s3">0</span><span class="s0">===t||</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,</span><span class="s2">&quot;Invalid source value: must be true, falsy or an object&quot;</span><span class="s0">),s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r,</span><span class="s2">&quot;Invalid options: must be an object&quot;</span><span class="s0">),!t)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(r.shallow)</span><span class="s1">return </span><span class="s0">o.applyToDefaultsWithShallow(e,t,r);const i=n(e);</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">0</span><span class="s0">===t)</span><span class="s1">return </span><span class="s0">i;const l=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r.nullOverride&amp;&amp;r.nullOverride;</span><span class="s1">return </span><span class="s0">a(i,t,{nullOverride:l,mergeArrays:!</span><span class="s3">1</span><span class="s0">})},o.applyToDefaultsWithShallow=</span><span class="s1">function</span><span class="s0">(e,t,r){const l=r.shallow;s(Array.isArray(l),</span><span class="s2">&quot;Invalid keys&quot;</span><span class="s0">);const c=</span><span class="s1">new </span><span class="s0">Map,u=!</span><span class="s3">0</span><span class="s0">===t?</span><span class="s1">null</span><span class="s0">:</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">for</span><span class="s0">(let r of l){r=Array.isArray(r)?r:r.split(</span><span class="s2">&quot;.&quot;</span><span class="s0">);const s=i(e,r);s&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s?c.set(s,u&amp;&amp;i(t,r)||s):u&amp;&amp;u.add(r)}const f=n(e,{},c);</span><span class="s1">if</span><span class="s0">(!u)</span><span class="s1">return </span><span class="s0">f;</span><span class="s1">for</span><span class="s0">(const e of u)o.reachCopy(f,t,e);const h=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r.nullOverride&amp;&amp;r.nullOverride;</span><span class="s1">return </span><span class="s0">a(f,t,{nullOverride:h,mergeArrays:!</span><span class="s3">1</span><span class="s0">})},o.reachCopy=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">for</span><span class="s0">(const e of r){</span><span class="s1">if</span><span class="s0">(!(e </span><span class="s1">in </span><span class="s0">t))</span><span class="s1">return</span><span class="s0">;const r=t[e];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r||</span><span class="s1">null</span><span class="s0">===r)</span><span class="s1">return</span><span class="s0">;t=r}const s=t;let n=e;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;r.length-1;++e){const t=r[e];</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">n[t]&amp;&amp;(n[t]={}),n=n[t]}n[r[r.length-1]]=s}},</span><span class="s3">375</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">7916</span><span class="s0">);e.exports=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">t=arguments.length,r=</span><span class="s1">new </span><span class="s0">Array(t&gt;</span><span class="s3">1</span><span class="s0">?t-1:</span><span class="s3">0</span><span class="s0">),n=</span><span class="s3">1</span><span class="s0">;n&lt;t;n++)r[n-1]=arguments[n];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">1</span><span class="s0">===r.length&amp;&amp;r[</span><span class="s3">0</span><span class="s0">]</span><span class="s1">instanceof </span><span class="s0">Error)</span><span class="s1">throw </span><span class="s0">r[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">throw new </span><span class="s0">s(r)}}},</span><span class="s3">8571</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">9621</span><span class="s0">),n=r(</span><span class="s3">4277</span><span class="s0">),a=r(</span><span class="s3">7043</span><span class="s0">),i={needsProtoHack:</span><span class="s1">new </span><span class="s0">Set([n.set,n.map,n.weakSet,n.weakMap])};e.exports=i.clone=</span><span class="s1">function</span><span class="s0">(e){let t=arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{},r=arguments.length&gt;</span><span class="s3">2</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">2</span><span class="s0">]?arguments[</span><span class="s3">2</span><span class="s0">]:</span><span class="s1">null</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e||</span><span class="s1">null</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">e;let s=i.clone,o=r;</span><span class="s1">if</span><span class="s0">(t.shallow){</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">0</span><span class="s0">!==t.shallow)</span><span class="s1">return </span><span class="s0">i.cloneWithShallow(e,t);s=e=&gt;e}</span><span class="s1">else if</span><span class="s0">(o){const t=o.get(e);</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">else </span><span class="s0">o=</span><span class="s1">new </span><span class="s0">Map;const l=n.getInternalProto(e);</span><span class="s1">if</span><span class="s0">(l===n.buffer)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(l===n.date)</span><span class="s1">return new </span><span class="s0">Date(e.getTime());</span><span class="s1">if</span><span class="s0">(l===n.regex)</span><span class="s1">return new </span><span class="s0">RegExp(e);const c=i.base(e,l,t);</span><span class="s1">if</span><span class="s0">(c===e)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(o&amp;&amp;o.set(e,c),l===n.set)</span><span class="s1">for</span><span class="s0">(const r of e)c.add(s(r,t,o));</span><span class="s1">else if</span><span class="s0">(l===n.map)</span><span class="s1">for</span><span class="s0">(const[r,n]of e)c.set(r,s(n,t,o));const u=a.keys(e,t);</span><span class="s1">for</span><span class="s0">(const r of u){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;__proto__&quot;</span><span class="s0">===r)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(l===n.array&amp;&amp;</span><span class="s2">&quot;length&quot;</span><span class="s0">===r){c.length=e.length;</span><span class="s1">continue</span><span class="s0">}const a=Object.getOwnPropertyDescriptor(e,r);a?a.get||a.set?Object.defineProperty(c,r,a):a.enumerable?c[r]=s(e[r],t,o):Object.defineProperty(c,r,{enumerable:!</span><span class="s3">1</span><span class="s0">,writable:!</span><span class="s3">0</span><span class="s0">,configurable:!</span><span class="s3">0</span><span class="s0">,value:s(e[r],t,o)}):Object.defineProperty(c,r,{enumerable:!</span><span class="s3">0</span><span class="s0">,writable:!</span><span class="s3">0</span><span class="s0">,configurable:!</span><span class="s3">0</span><span class="s0">,value:s(e[r],t,o)})}</span><span class="s1">return </span><span class="s0">c},i.cloneWithShallow=</span><span class="s1">function</span><span class="s0">(e,t){const r=t.shallow;(t=Object.assign({},t)).shallow=!</span><span class="s3">1</span><span class="s0">;const n=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">for</span><span class="s0">(const t of r){const r=s(e,t);</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r||n.set(r,r)}</span><span class="s1">return </span><span class="s0">i.clone(e,t,n)},i.base=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">1</span><span class="s0">===r.prototype)</span><span class="s1">return </span><span class="s0">i.needsProtoHack.has(t)?</span><span class="s1">new </span><span class="s0">t.constructor:t===n.array?[]:{};const s=Object.getPrototypeOf(e);</span><span class="s1">if</span><span class="s0">(s&amp;&amp;s.isImmutable)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(t===n.array){const e=[];</span><span class="s1">return </span><span class="s0">s!==t&amp;&amp;Object.setPrototypeOf(e,s),e}</span><span class="s1">if</span><span class="s0">(i.needsProtoHack.has(t)){const e=</span><span class="s1">new </span><span class="s0">s.constructor;</span><span class="s1">return </span><span class="s0">s!==t&amp;&amp;Object.setPrototypeOf(e,s),e}</span><span class="s1">return </span><span class="s0">Object.create(s)}},</span><span class="s3">9474</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">4277</span><span class="s0">),n={mismatched:</span><span class="s1">null</span><span class="s0">};e.exports=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">return </span><span class="s0">r=Object.assign({prototype:!</span><span class="s3">0</span><span class="s0">},r),!!n.isDeepEqual(e,t,r,[])},n.isDeepEqual=</span><span class="s1">function</span><span class="s0">(e,t,r,a){</span><span class="s1">if</span><span class="s0">(e===t)</span><span class="s1">return </span><span class="s3">0</span><span class="s0">!==e||</span><span class="s3">1</span><span class="s0">/e==</span><span class="s3">1</span><span class="s0">/t;const i=</span><span class="s1">typeof </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(i!==</span><span class="s1">typeof </span><span class="s0">t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===e||</span><span class="s1">null</span><span class="s0">===t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">===i){</span><span class="s1">if</span><span class="s0">(!r.deepFunction||e.toString()!==t.toString())</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">&quot;object&quot;</span><span class="s0">!==i)</span><span class="s1">return </span><span class="s0">e!=e&amp;&amp;t!=t;const o=n.getSharedType(e,t,!!r.prototype);</span><span class="s1">switch</span><span class="s0">(o){</span><span class="s1">case </span><span class="s0">s.buffer:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">case </span><span class="s0">s.promise:</span><span class="s1">return </span><span class="s0">e===t;</span><span class="s1">case </span><span class="s0">s.regex:</span><span class="s1">return </span><span class="s0">e.toString()===t.toString();</span><span class="s1">case </span><span class="s0">n.mismatched:</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">for</span><span class="s0">(let r=a.length-1;r&gt;=</span><span class="s3">0</span><span class="s0">;--r)</span><span class="s1">if</span><span class="s0">(a[r].isSame(e,t))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;a.push(</span><span class="s1">new </span><span class="s0">n.SeenEntry(e,t));</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return</span><span class="s0">!!n.isDeepEqualObj(o,e,t,r,a)}</span><span class="s1">finally</span><span class="s0">{a.pop()}},n.getSharedType=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(r)</span><span class="s1">return </span><span class="s0">Object.getPrototypeOf(e)!==Object.getPrototypeOf(t)?n.mismatched:s.getInternalProto(e);const a=s.getInternalProto(e);</span><span class="s1">return </span><span class="s0">a!==s.getInternalProto(t)?n.mismatched:a},n.valueOf=</span><span class="s1">function</span><span class="s0">(e){const t=e.valueOf;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">t.call(e)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e}},n.hasOwnEnumerableProperty=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return </span><span class="s0">Object.prototype.propertyIsEnumerable.call(e,t)},n.isSetSimpleEqual=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">for</span><span class="s0">(const r of Set.prototype.values.call(e))</span><span class="s1">if</span><span class="s0">(!Set.prototype.has.call(t,r))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">},n.isDeepEqualObj=</span><span class="s1">function</span><span class="s0">(e,t,r,a,i){const{isDeepEqual:o,valueOf:l,hasOwnEnumerableProperty:c}=n,{keys:u,getOwnPropertySymbols:f}=Object;</span><span class="s1">if</span><span class="s0">(e===s.array){</span><span class="s1">if</span><span class="s0">(!a.part){</span><span class="s1">if</span><span class="s0">(t.length!==r.length)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;++e)</span><span class="s1">if</span><span class="s0">(!o(t[e],r[e],a,i))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">for</span><span class="s0">(const e of t)</span><span class="s1">for</span><span class="s0">(const t of r)</span><span class="s1">if</span><span class="s0">(o(e,t,a,i))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(e===s.set){</span><span class="s1">if</span><span class="s0">(t.size!==r.size)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!n.isSetSimpleEqual(t,r)){const e=</span><span class="s1">new </span><span class="s0">Set(Set.prototype.values.call(r));</span><span class="s1">for</span><span class="s0">(const r of Set.prototype.values.call(t)){</span><span class="s1">if</span><span class="s0">(e.</span><span class="s1">delete</span><span class="s0">(r))</span><span class="s1">continue</span><span class="s0">;let t=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const s of e)</span><span class="s1">if</span><span class="s0">(o(r,s,a,i)){e.</span><span class="s1">delete</span><span class="s0">(s),t=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}}</span><span class="s1">else if</span><span class="s0">(e===s.map){</span><span class="s1">if</span><span class="s0">(t.size!==r.size)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const[e,s]of Map.prototype.entries.call(t)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===s&amp;&amp;!Map.prototype.has.call(r,e))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!o(s,Map.prototype.get.call(r,e),a,i))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}}</span><span class="s1">else if</span><span class="s0">(e===s.error&amp;&amp;(t.name!==r.name||t.message!==r.message))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;const h=l(t),m=l(r);</span><span class="s1">if</span><span class="s0">((t!==h||r!==m)&amp;&amp;!o(h,m,a,i))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;const d=u(t);</span><span class="s1">if</span><span class="s0">(!a.part&amp;&amp;d.length!==u(r).length&amp;&amp;!a.skip)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;let p=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(const e of d)</span><span class="s1">if</span><span class="s0">(a.skip&amp;&amp;a.skip.includes(e))</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r[e]&amp;&amp;++p;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!c(r,e))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!o(t[e],r[e],a,i))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(!a.part&amp;&amp;d.length-p!==u(r).length)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">1</span><span class="s0">!==a.symbols){const e=f(t),s=</span><span class="s1">new </span><span class="s0">Set(f(r));</span><span class="s1">for</span><span class="s0">(const n of e){</span><span class="s1">if</span><span class="s0">(!a.skip||!a.skip.includes(n))</span><span class="s1">if</span><span class="s0">(c(t,n)){</span><span class="s1">if</span><span class="s0">(!c(r,n))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!o(t[n],r[n],a,i))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">else if</span><span class="s0">(c(r,n))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;s.</span><span class="s1">delete</span><span class="s0">(n)}</span><span class="s1">for</span><span class="s0">(const e of s)</span><span class="s1">if</span><span class="s0">(c(r,e))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">},n.SeenEntry=class{constructor(e,t){</span><span class="s1">this</span><span class="s0">.obj=e,</span><span class="s1">this</span><span class="s0">.ref=t}isSame(e,t){</span><span class="s1">return this</span><span class="s0">.obj===e&amp;&amp;</span><span class="s1">this</span><span class="s0">.ref===t}}},</span><span class="s3">7916</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">8761</span><span class="s0">);e.exports=class extends Error{constructor(e){super(e.filter((e=&gt;</span><span class="s2">&quot;&quot;</span><span class="s0">!==e)).map((e=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?e:e </span><span class="s1">instanceof </span><span class="s0">Error?e.message:s(e))).join(</span><span class="s2">&quot; &quot;</span><span class="s0">)||</span><span class="s2">&quot;Unknown error&quot;</span><span class="s0">),</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">Error.captureStackTrace&amp;&amp;Error.captureStackTrace(</span><span class="s1">this</span><span class="s0">,t.assert)}}},</span><span class="s3">5277</span><span class="s0">:e=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const t={};e.exports=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s2">&quot;&quot;</span><span class="s0">;let r=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">;s&lt;e.length;++s){const n=e.charCodeAt(s);t.isSafe(n)?r+=e[s]:r+=t.escapeHtmlChar(n)}</span><span class="s1">return </span><span class="s0">r},t.escapeHtmlChar=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">t.namedHtml.get(e)||(e&gt;=</span><span class="s3">256</span><span class="s0">?</span><span class="s2">&quot;&amp;#&quot;</span><span class="s0">+e+</span><span class="s2">&quot;;&quot;</span><span class="s0">:`&amp;#x${e.toString(</span><span class="s3">16</span><span class="s0">).padStart(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">&quot;0&quot;</span><span class="s0">)};`)},t.isSafe=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">t.safeCharCodes.has(e)},t.namedHtml=</span><span class="s1">new </span><span class="s0">Map([[</span><span class="s3">38</span><span class="s0">,</span><span class="s2">&quot;&amp;amp;&quot;</span><span class="s0">],[</span><span class="s3">60</span><span class="s0">,</span><span class="s2">&quot;&amp;lt;&quot;</span><span class="s0">],[</span><span class="s3">62</span><span class="s0">,</span><span class="s2">&quot;&amp;gt;&quot;</span><span class="s0">],[</span><span class="s3">34</span><span class="s0">,</span><span class="s2">&quot;&amp;quot;&quot;</span><span class="s0">],[</span><span class="s3">160</span><span class="s0">,</span><span class="s2">&quot;&amp;nbsp;&quot;</span><span class="s0">],[</span><span class="s3">162</span><span class="s0">,</span><span class="s2">&quot;&amp;cent;&quot;</span><span class="s0">],[</span><span class="s3">163</span><span class="s0">,</span><span class="s2">&quot;&amp;pound;&quot;</span><span class="s0">],[</span><span class="s3">164</span><span class="s0">,</span><span class="s2">&quot;&amp;curren;&quot;</span><span class="s0">],[</span><span class="s3">169</span><span class="s0">,</span><span class="s2">&quot;&amp;copy;&quot;</span><span class="s0">],[</span><span class="s3">174</span><span class="s0">,</span><span class="s2">&quot;&amp;reg;&quot;</span><span class="s0">]]),t.safeCharCodes=</span><span class="s1">function</span><span class="s0">(){const e=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">32</span><span class="s0">;t&lt;</span><span class="s3">123</span><span class="s0">;++t)(t&gt;=</span><span class="s3">97</span><span class="s0">||t&gt;=</span><span class="s3">65</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">90</span><span class="s0">||t&gt;=</span><span class="s3">48</span><span class="s0">&amp;&amp;t&lt;=</span><span class="s3">57</span><span class="s0">||</span><span class="s3">32</span><span class="s0">===t||</span><span class="s3">46</span><span class="s0">===t||</span><span class="s3">44</span><span class="s0">===t||</span><span class="s3">45</span><span class="s0">===t||</span><span class="s3">58</span><span class="s0">===t||</span><span class="s3">95</span><span class="s0">===t)&amp;&amp;e.add(t);</span><span class="s1">return </span><span class="s0">e}()},</span><span class="s3">6064</span><span class="s0">:e=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;e.exports=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">$&amp;&quot;</span><span class="s0">)}},</span><span class="s3">738</span><span class="s0">:e=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;e.exports=</span><span class="s1">function</span><span class="s0">(){}},</span><span class="s3">1687</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">8571</span><span class="s0">),a=r(</span><span class="s3">7043</span><span class="s0">),i={};e.exports=i.merge=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(s(e&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e,</span><span class="s2">&quot;Invalid target value: must be an object&quot;</span><span class="s0">),s(</span><span class="s1">null</span><span class="s0">==t||</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,</span><span class="s2">&quot;Invalid source value: must be null, undefined, or an object&quot;</span><span class="s0">),!t)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">if</span><span class="s0">(r=Object.assign({nullOverride:!</span><span class="s3">0</span><span class="s0">,mergeArrays:!</span><span class="s3">0</span><span class="s0">},r),Array.isArray(t)){s(Array.isArray(e),</span><span class="s2">&quot;Cannot merge array onto an object&quot;</span><span class="s0">),r.mergeArrays||(e.length=</span><span class="s3">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">;s&lt;t.length;++s)e.push(n(t[s],{symbols:r.symbols}));</span><span class="s1">return </span><span class="s0">e}const o=a.keys(t,r);</span><span class="s1">for</span><span class="s0">(let s=</span><span class="s3">0</span><span class="s0">;s&lt;o.length;++s){const a=o[s];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;__proto__&quot;</span><span class="s0">===a||!Object.prototype.propertyIsEnumerable.call(t,a))</span><span class="s1">continue</span><span class="s0">;const l=t[a];</span><span class="s1">if</span><span class="s0">(l&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">l){</span><span class="s1">if</span><span class="s0">(e[a]===l)</span><span class="s1">continue</span><span class="s0">;!e[a]||</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e[a]||Array.isArray(e[a])!==Array.isArray(l)||l </span><span class="s1">instanceof </span><span class="s0">Date||l </span><span class="s1">instanceof </span><span class="s0">RegExp?e[a]=n(l,{symbols:r.symbols}):i.merge(e[a],l,r)}</span><span class="s1">else</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!=l||r.nullOverride)&amp;&amp;(e[a]=l)}</span><span class="s1">return </span><span class="s0">e}},</span><span class="s3">9621</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n={};e.exports=</span><span class="s1">function</span><span class="s0">(e,t,r){</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">1</span><span class="s0">===t||</span><span class="s1">null</span><span class="s0">==t)</span><span class="s1">return </span><span class="s0">e;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof</span><span class="s0">(r=r||{})&amp;&amp;(r={separator:r});const a=Array.isArray(t);s(!a||!r.separator,</span><span class="s2">&quot;Separator option is not valid for array-based chain&quot;</span><span class="s0">);const i=a?t:t.split(r.separator||</span><span class="s2">&quot;.&quot;</span><span class="s0">);let o=e;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;i.length;++e){let a=i[e];const l=r.iterables&amp;&amp;n.iterables(o);</span><span class="s1">if</span><span class="s0">(Array.isArray(o)||</span><span class="s2">&quot;set&quot;</span><span class="s0">===l){const e=Number(a);Number.isInteger(e)&amp;&amp;(a=e&lt;</span><span class="s3">0</span><span class="s0">?o.length+e:e)}</span><span class="s1">if</span><span class="s0">(!o||</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o&amp;&amp;!</span><span class="s3">1</span><span class="s0">===r.functions||!l&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o[a]){s(!r.strict||e+</span><span class="s3">1</span><span class="s0">===i.length,</span><span class="s2">&quot;Missing segment&quot;</span><span class="s0">,a,</span><span class="s2">&quot;in reach path &quot;</span><span class="s0">,t),s(</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o||!</span><span class="s3">0</span><span class="s0">===r.functions||</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">o,</span><span class="s2">&quot;Invalid segment&quot;</span><span class="s0">,a,</span><span class="s2">&quot;in reach path &quot;</span><span class="s0">,t),o=r.</span><span class="s1">default</span><span class="s0">;</span><span class="s1">break</span><span class="s0">}o=l?</span><span class="s2">&quot;set&quot;</span><span class="s0">===l?[...o][a]:o.get(a):o[a]}</span><span class="s1">return </span><span class="s0">o},n.iterables=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return </span><span class="s0">e </span><span class="s1">instanceof </span><span class="s0">Set?</span><span class="s2">&quot;set&quot;</span><span class="s0">:e </span><span class="s1">instanceof </span><span class="s0">Map?</span><span class="s2">&quot;map&quot;</span><span class="s0">:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}},</span><span class="s3">8761</span><span class="s0">:e=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;e.exports=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">return </span><span class="s0">JSON.stringify(...arguments)}</span><span class="s1">catch</span><span class="s0">(e){</span><span class="s1">return</span><span class="s2">&quot;[Cannot display object: &quot;</span><span class="s0">+e.message+</span><span class="s2">&quot;]&quot;</span><span class="s0">}}},</span><span class="s3">4277</span><span class="s0">:(e,t)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const r={};t=e.exports={array:Array.prototype,buffer:!</span><span class="s3">1</span><span class="s0">,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},r.typeMap=</span><span class="s1">new </span><span class="s0">Map([[</span><span class="s2">&quot;[object Error]&quot;</span><span class="s0">,t.error],[</span><span class="s2">&quot;[object Map]&quot;</span><span class="s0">,t.map],[</span><span class="s2">&quot;[object Promise]&quot;</span><span class="s0">,t.promise],[</span><span class="s2">&quot;[object Set]&quot;</span><span class="s0">,t.set],[</span><span class="s2">&quot;[object WeakMap]&quot;</span><span class="s0">,t.weakMap],[</span><span class="s2">&quot;[object WeakSet]&quot;</span><span class="s0">,t.weakSet]]),t.getInternalProto=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">if</span><span class="s0">(Array.isArray(e))</span><span class="s1">return </span><span class="s0">t.array;</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">Date)</span><span class="s1">return </span><span class="s0">t.date;</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">RegExp)</span><span class="s1">return </span><span class="s0">t.regex;</span><span class="s1">if</span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">Error)</span><span class="s1">return </span><span class="s0">t.error;const s=Object.prototype.toString.call(e);</span><span class="s1">return </span><span class="s0">r.typeMap.get(s)||t.generic}},</span><span class="s3">7043</span><span class="s0">:(e,t)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;t.keys=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">!==(arguments.length&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">1</span><span class="s0">]?arguments[</span><span class="s3">1</span><span class="s0">]:{}).symbols?Reflect.ownKeys(e):Object.getOwnPropertyNames(e)}},</span><span class="s3">3652</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n={};t.Sorter=class{constructor(){</span><span class="s1">this</span><span class="s0">._items=[],</span><span class="s1">this</span><span class="s0">.nodes=[]}add(e,t){const r=[].concat((t=t||{}).before||[]),n=[].concat(t.after||[]),a=t.group||</span><span class="s2">&quot;?&quot;</span><span class="s0">,i=t.sort||</span><span class="s3">0</span><span class="s0">;s(!r.includes(a),`Item cannot come before itself: ${a}`),s(!r.includes(</span><span class="s2">&quot;?&quot;</span><span class="s0">),</span><span class="s2">&quot;Item cannot come before unassociated items&quot;</span><span class="s0">),s(!n.includes(a),`Item cannot come after itself: ${a}`),s(!n.includes(</span><span class="s2">&quot;?&quot;</span><span class="s0">),</span><span class="s2">&quot;Item cannot come after unassociated items&quot;</span><span class="s0">),Array.isArray(e)||(e=[e]);</span><span class="s1">for</span><span class="s0">(const t of e){const e={seq:</span><span class="s1">this</span><span class="s0">._items.length,sort:i,before:r,after:n,group:a,node:t};</span><span class="s1">this</span><span class="s0">._items.push(e)}</span><span class="s1">if</span><span class="s0">(!t.manual){const e=</span><span class="s1">this</span><span class="s0">._sort();s(e,</span><span class="s2">&quot;item&quot;</span><span class="s0">,</span><span class="s2">&quot;?&quot;</span><span class="s0">!==a?`added into group ${a}`:</span><span class="s2">&quot;&quot;</span><span class="s0">,</span><span class="s2">&quot;created a dependencies error&quot;</span><span class="s0">)}</span><span class="s1">return this</span><span class="s0">.nodes}merge(e){Array.isArray(e)||(e=[e]);</span><span class="s1">for</span><span class="s0">(const t of e)</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">for</span><span class="s0">(const e of t._items)</span><span class="s1">this</span><span class="s0">._items.push(Object.assign({},e));</span><span class="s1">this</span><span class="s0">._items.sort(n.mergeSort);</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;</span><span class="s1">this</span><span class="s0">._items.length;++e)</span><span class="s1">this</span><span class="s0">._items[e].seq=e;const t=</span><span class="s1">this</span><span class="s0">._sort();</span><span class="s1">return </span><span class="s0">s(t,</span><span class="s2">&quot;merge created a dependencies error&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.nodes}sort(){const e=</span><span class="s1">this</span><span class="s0">._sort();</span><span class="s1">return </span><span class="s0">s(e,</span><span class="s2">&quot;sort created a dependencies error&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.nodes}_sort(){const e={},t=Object.create(</span><span class="s1">null</span><span class="s0">),r=Object.create(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(const s of </span><span class="s1">this</span><span class="s0">._items){const n=s.seq,a=s.group;r[a]=r[a]||[],r[a].push(n),e[n]=s.before;</span><span class="s1">for</span><span class="s0">(const e of s.after)t[e]=t[e]||[],t[e].push(n)}</span><span class="s1">for</span><span class="s0">(const t </span><span class="s1">in </span><span class="s0">e){const s=[];</span><span class="s1">for</span><span class="s0">(const n </span><span class="s1">in </span><span class="s0">e[t]){const a=e[t][n];r[a]=r[a]||[],s.push(...r[a])}e[t]=s}</span><span class="s1">for</span><span class="s0">(const s </span><span class="s1">in </span><span class="s0">t)</span><span class="s1">if</span><span class="s0">(r[s])</span><span class="s1">for</span><span class="s0">(const n of r[s])e[n].push(...t[s]);const s={};</span><span class="s1">for</span><span class="s0">(const t </span><span class="s1">in </span><span class="s0">e){const r=e[t];</span><span class="s1">for</span><span class="s0">(const e of r)s[e]=s[e]||[],s[e].push(t)}const n={},a=[];</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;</span><span class="s1">this</span><span class="s0">._items.length;++e){let t=e;</span><span class="s1">if</span><span class="s0">(s[e]){t=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;</span><span class="s1">this</span><span class="s0">._items.length;++e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">0</span><span class="s0">===n[e])</span><span class="s1">continue</span><span class="s0">;s[e]||(s[e]=[]);const r=s[e].length;let a=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(let t=</span><span class="s3">0</span><span class="s0">;t&lt;r;++t)n[s[e][t]]&amp;&amp;++a;</span><span class="s1">if</span><span class="s0">(a===r){t=e;</span><span class="s1">break</span><span class="s0">}}}</span><span class="s1">null</span><span class="s0">!==t&amp;&amp;(n[t]=!</span><span class="s3">0</span><span class="s0">,a.push(t))}</span><span class="s1">if</span><span class="s0">(a.length!==</span><span class="s1">this</span><span class="s0">._items.length)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;const i={};</span><span class="s1">for</span><span class="s0">(const e of </span><span class="s1">this</span><span class="s0">._items)i[e.seq]=e;</span><span class="s1">this</span><span class="s0">._items=[],</span><span class="s1">this</span><span class="s0">.nodes=[];</span><span class="s1">for</span><span class="s0">(const e of a){const t=i[e];</span><span class="s1">this</span><span class="s0">.nodes.push(t.node),</span><span class="s1">this</span><span class="s0">._items.push(t)}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}},n.mergeSort=(e,t)=&gt;e.sort===t.sort?</span><span class="s3">0</span><span class="s0">:e.sort&lt;t.sort?-</span><span class="s3">1</span><span class="s0">:</span><span class="s3">1</span><span class="s0">},</span><span class="s3">5380</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">443</span><span class="s0">),n=r(</span><span class="s3">2178</span><span class="s0">),a={minDomainSegments:</span><span class="s3">2</span><span class="s0">,nonAsciiRx:/[^\x00-\x7f]/,domainControlRx:/[\x00-\x20@\:\/\\#!\$&amp;\</span><span class="s2">'</span><span class="s5">\(\)\*\+</span><span class="s2">,;=</span><span class="s5">\?</span><span class="s2">]/,tldSegmentRx:/^[a-zA-Z](?:[a-zA-Z0-9</span><span class="s5">\-</span><span class="s2">]*[a-zA-Z0-9])?$/,domainSegmentRx:/^[a-zA-Z0-9](?:[a-zA-Z0-9</span><span class="s5">\-</span><span class="s2">]*[a-zA-Z0-9])?$/,URL:s.URL||URL};t.analyze=function(e){let t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};if(!e)return n.code(&quot;DOMAIN_NON_EMPTY_STRING&quot;);if(&quot;string&quot;!=typeof e)throw new Error(&quot;Invalid input: domain must be a string&quot;);if(e.length&gt;256)return n.code(&quot;DOMAIN_TOO_LONG&quot;);if(a.nonAsciiRx.test(e)){if(!1===t.allowUnicode)return n.code(&quot;DOMAIN_INVALID_UNICODE_CHARS&quot;);e=e.normalize(&quot;NFC&quot;)}if(a.domainControlRx.test(e))return n.code(&quot;DOMAIN_INVALID_CHARS&quot;);e=a.punycode(e),t.allowFullyQualified&amp;&amp;&quot;.&quot;===e[e.length-1]&amp;&amp;(e=e.slice(0,-1));const r=t.minDomainSegments||a.minDomainSegments,s=e.split(&quot;.&quot;);if(s.length&lt;r)return n.code(&quot;DOMAIN_SEGMENTS_COUNT&quot;);if(t.maxDomainSegments&amp;&amp;s.length&gt;t.maxDomainSegments)return n.code(&quot;DOMAIN_SEGMENTS_COUNT_MAX&quot;);const i=t.tlds;if(i){const e=s[s.length-1].toLowerCase();if(i.deny&amp;&amp;i.deny.has(e)||i.allow&amp;&amp;!i.allow.has(e))return n.code(&quot;DOMAIN_FORBIDDEN_TLDS&quot;)}for(let e=0;e&lt;s.length;++e){const t=s[e];if(!t.length)return n.code(&quot;DOMAIN_EMPTY_SEGMENT&quot;);if(t.length&gt;63)return n.code(&quot;DOMAIN_LONG_SEGMENT&quot;);if(e&lt;s.length-1){if(!a.domainSegmentRx.test(t))return n.code(&quot;DOMAIN_INVALID_CHARS&quot;)}else if(!a.tldSegmentRx.test(t))return n.code(&quot;DOMAIN_INVALID_TLDS_CHARS&quot;)}return null},t.isValid=function(e,r){return!t.analyze(e,r)},a.punycode=function(e){e.includes(&quot;%&quot;)&amp;&amp;(e=e.replace(/%/g,&quot;%25&quot;));try{return new a.URL(`http://${e}`).host}catch(t){return e}}},1745:(e,t,r)=&gt;{&quot;use strict&quot;;const s=r(9848),n=r(5380),a=r(2178),i={nonAsciiRx:/[^</span><span class="s4">\x</span><span class="s2">00-</span><span class="s4">\x</span><span class="s2">7f]/,encoder:new(s.TextEncoder||TextEncoder)};t.analyze=function(e,t){return i.email(e,t)},t.isValid=function(e,t){return!i.email(e,t)},i.email=function(e){let t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};if(&quot;string&quot;!=typeof e)throw new Error(&quot;Invalid input: email must be a string&quot;);if(!e)return a.code(&quot;EMPTY_STRING&quot;);const r=!i.nonAsciiRx.test(e);if(!r){if(!1===t.allowUnicode)return a.code(&quot;FORBIDDEN_UNICODE&quot;);e=e.normalize(&quot;NFC&quot;)}const s=e.split(&quot;@&quot;);if(2!==s.length)return s.length&gt;2?a.code(&quot;MULTIPLE_AT_CHAR&quot;):a.code(&quot;MISSING_AT_CHAR&quot;);const[o,l]=s;if(!o)return a.code(&quot;EMPTY_LOCAL&quot;);if(!t.ignoreLength){if(e.length&gt;254)return a.code(&quot;ADDRESS_TOO_LONG&quot;);if(i.encoder.encode(o).length&gt;64)return a.code(&quot;LOCAL_TOO_LONG&quot;)}return i.local(o,r)||n.analyze(l,t)},i.local=function(e,t){const r=e.split(&quot;.&quot;);for(const e of r){if(!e.length)return a.code(&quot;EMPTY_LOCAL_SEGMENT&quot;);if(t){if(!i.atextRx.test(e))return a.code(&quot;INVALID_LOCAL_CHARS&quot;)}else for(const t of e){if(i.atextRx.test(t))continue;const e=i.binary(t);if(!i.atomRx.test(e))return a.code(&quot;INVALID_LOCAL_CHARS&quot;)}}},i.binary=function(e){return Array.from(i.encoder.encode(e)).map((e=&gt;String.fromCharCode(e))).join(&quot;&quot;)},i.atextRx=/^[</span><span class="s5">\w</span><span class="s2">!#</span><span class="s5">\$</span><span class="s2">%&amp;'</span><span class="s0">\*\+\-/=\?\^`\{\|\}~]+$/,i.atomRx=</span><span class="s1">new </span><span class="s0">RegExp([</span><span class="s2">&quot;(?:[</span><span class="s4">\\</span><span class="s2">xc2-</span><span class="s4">\\</span><span class="s2">xdf][</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">xbf])&quot;</span><span class="s0">,</span><span class="s2">&quot;(?:</span><span class="s4">\\</span><span class="s2">xe0[</span><span class="s4">\\</span><span class="s2">xa0-</span><span class="s4">\\</span><span class="s2">xbf][</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">xbf])|(?:[</span><span class="s4">\\</span><span class="s2">xe1-</span><span class="s4">\\</span><span class="s2">xec][</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">xbf]{2})|(?:</span><span class="s4">\\</span><span class="s2">xed[</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">x9f][</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">xbf])|(?:[</span><span class="s4">\\</span><span class="s2">xee-</span><span class="s4">\\</span><span class="s2">xef][</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">xbf]{2})&quot;</span><span class="s0">,</span><span class="s2">&quot;(?:</span><span class="s4">\\</span><span class="s2">xf0[</span><span class="s4">\\</span><span class="s2">x90-</span><span class="s4">\\</span><span class="s2">xbf][</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">xbf]{2})|(?:[</span><span class="s4">\\</span><span class="s2">xf1-</span><span class="s4">\\</span><span class="s2">xf3][</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">xbf]{3})|(?:</span><span class="s4">\\</span><span class="s2">xf4[</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">x8f][</span><span class="s4">\\</span><span class="s2">x80-</span><span class="s4">\\</span><span class="s2">xbf]{2})&quot;</span><span class="s0">].join(</span><span class="s2">&quot;|&quot;</span><span class="s0">))},</span><span class="s3">2178</span><span class="s0">:(e,t)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;t.codes={EMPTY_STRING:</span><span class="s2">&quot;Address must be a non-empty string&quot;</span><span class="s0">,FORBIDDEN_UNICODE:</span><span class="s2">&quot;Address contains forbidden Unicode characters&quot;</span><span class="s0">,MULTIPLE_AT_CHAR:</span><span class="s2">&quot;Address cannot contain more than one @ character&quot;</span><span class="s0">,MISSING_AT_CHAR:</span><span class="s2">&quot;Address must contain one @ character&quot;</span><span class="s0">,EMPTY_LOCAL:</span><span class="s2">&quot;Address local part cannot be empty&quot;</span><span class="s0">,ADDRESS_TOO_LONG:</span><span class="s2">&quot;Address too long&quot;</span><span class="s0">,LOCAL_TOO_LONG:</span><span class="s2">&quot;Address local part too long&quot;</span><span class="s0">,EMPTY_LOCAL_SEGMENT:</span><span class="s2">&quot;Address local part contains empty dot-separated segment&quot;</span><span class="s0">,INVALID_LOCAL_CHARS:</span><span class="s2">&quot;Address local part contains invalid character&quot;</span><span class="s0">,DOMAIN_NON_EMPTY_STRING:</span><span class="s2">&quot;Domain must be a non-empty string&quot;</span><span class="s0">,DOMAIN_TOO_LONG:</span><span class="s2">&quot;Domain too long&quot;</span><span class="s0">,DOMAIN_INVALID_UNICODE_CHARS:</span><span class="s2">&quot;Domain contains forbidden Unicode characters&quot;</span><span class="s0">,DOMAIN_INVALID_CHARS:</span><span class="s2">&quot;Domain contains invalid character&quot;</span><span class="s0">,DOMAIN_INVALID_TLDS_CHARS:</span><span class="s2">&quot;Domain contains invalid tld character&quot;</span><span class="s0">,DOMAIN_SEGMENTS_COUNT:</span><span class="s2">&quot;Domain lacks the minimum required number of segments&quot;</span><span class="s0">,DOMAIN_SEGMENTS_COUNT_MAX:</span><span class="s2">&quot;Domain contains too many segments&quot;</span><span class="s0">,DOMAIN_FORBIDDEN_TLDS:</span><span class="s2">&quot;Domain uses forbidden TLD&quot;</span><span class="s0">,DOMAIN_EMPTY_SEGMENT:</span><span class="s2">&quot;Domain contains empty dot-separated segment&quot;</span><span class="s0">,DOMAIN_LONG_SEGMENT:</span><span class="s2">&quot;Domain contains dot-separated segment that is too long&quot;</span><span class="s0">},t.code=</span><span class="s1">function</span><span class="s0">(e){</span><span class="s1">return</span><span class="s0">{code:e,error:t.codes[e]}}},</span><span class="s3">9959</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">5752</span><span class="s0">);t.regex=</span><span class="s1">function</span><span class="s0">(){let e=arguments.length&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==arguments[</span><span class="s3">0</span><span class="s0">]?arguments[</span><span class="s3">0</span><span class="s0">]:{};s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.cidr||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.cidr,</span><span class="s2">&quot;options.cidr must be a string&quot;</span><span class="s0">);const t=e.cidr?e.cidr.toLowerCase():</span><span class="s2">&quot;optional&quot;</span><span class="s0">;s([</span><span class="s2">&quot;required&quot;</span><span class="s0">,</span><span class="s2">&quot;optional&quot;</span><span class="s0">,</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">].includes(t),</span><span class="s2">&quot;options.cidr must be one of required, optional, forbidden&quot;</span><span class="s0">),s(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e.version||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.version||Array.isArray(e.version),</span><span class="s2">&quot;options.version must be a string or an array of string&quot;</span><span class="s0">);let r=e.version||[</span><span class="s2">&quot;ipv4&quot;</span><span class="s0">,</span><span class="s2">&quot;ipv6&quot;</span><span class="s0">,</span><span class="s2">&quot;ipvfuture&quot;</span><span class="s0">];Array.isArray(r)||(r=[r]),s(r.length&gt;=</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;options.version must have at least 1 version specified&quot;</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;r.length;++e)s(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r[e],</span><span class="s2">&quot;options.version must only contain strings&quot;</span><span class="s0">),r[e]=r[e].toLowerCase(),s([</span><span class="s2">&quot;ipv4&quot;</span><span class="s0">,</span><span class="s2">&quot;ipv6&quot;</span><span class="s0">,</span><span class="s2">&quot;ipvfuture&quot;</span><span class="s0">].includes(r[e]),</span><span class="s2">&quot;options.version contains unknown version &quot;</span><span class="s0">+r[e]+</span><span class="s2">&quot; - must be one of ipv4, ipv6, ipvfuture&quot;</span><span class="s0">);r=Array.from(</span><span class="s1">new </span><span class="s0">Set(r));const a=`(?:${r.map((e=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;forbidden&quot;</span><span class="s0">===t)</span><span class="s1">return </span><span class="s0">n.ip[e];const r=`\\/${</span><span class="s2">&quot;ipv4&quot;</span><span class="s0">===e?n.ip.v4Cidr:n.ip.v6Cidr}`;</span><span class="s1">return</span><span class="s2">&quot;required&quot;</span><span class="s0">===t?`${n.ip[e]}${r}`:`${n.ip[e]}(?:${r})?`})).join(</span><span class="s2">&quot;|&quot;</span><span class="s0">)})`,i=</span><span class="s1">new </span><span class="s0">RegExp(`^${a}$`);</span><span class="s1">return</span><span class="s0">{cidr:t,versions:r,regex:i,raw:a}}},</span><span class="s3">5752</span><span class="s0">:(e,t,r)=&gt;{</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;const s=r(</span><span class="s3">375</span><span class="s0">),n=r(</span><span class="s3">6064</span><span class="s0">),a={generate:</span><span class="s1">function</span><span class="s0">(){const e={},t=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">dA-Fa-f&quot;</span><span class="s0">,r=</span><span class="s2">&quot;[&quot;</span><span class="s0">+t+</span><span class="s2">&quot;]&quot;</span><span class="s0">,s=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">w-</span><span class="s4">\\</span><span class="s2">.~&quot;</span><span class="s0">,n=</span><span class="s2">&quot;!</span><span class="s4">\\</span><span class="s2">$&amp;'</span><span class="s4">\\</span><span class="s2">(</span><span class="s4">\\</span><span class="s2">)</span><span class="s4">\\</span><span class="s2">*</span><span class="s4">\\</span><span class="s2">+,;=&quot;</span><span class="s0">,a=</span><span class="s2">&quot;%&quot;</span><span class="s0">+t,i=s+a+n+</span><span class="s2">&quot;:@&quot;</span><span class="s0">,o=</span><span class="s2">&quot;[&quot;</span><span class="s0">+i+</span><span class="s2">&quot;]&quot;</span><span class="s0">,l=</span><span class="s2">&quot;(?:0{0,2}</span><span class="s4">\\</span><span class="s2">d|0?[1-9]</span><span class="s4">\\</span><span class="s2">d|1</span><span class="s4">\\</span><span class="s2">d</span><span class="s4">\\</span><span class="s2">d|2[0-4]</span><span class="s4">\\</span><span class="s2">d|25[0-5])&quot;</span><span class="s0">;e.ipv4address=</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+l+</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">.){3}&quot;</span><span class="s0">+l;const c=r+</span><span class="s2">&quot;{1,4}&quot;</span><span class="s0">,u=</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;|&quot;</span><span class="s0">+e.ipv4address+</span><span class="s2">&quot;)&quot;</span><span class="s0">,f=</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){6}&quot;</span><span class="s0">+u,h=</span><span class="s2">&quot;::(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){5}&quot;</span><span class="s0">+u,m=</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;)?::(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){4}&quot;</span><span class="s0">+u,d=</span><span class="s2">&quot;(?:(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){0,1}&quot;</span><span class="s0">+c+</span><span class="s2">&quot;)?::(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){3}&quot;</span><span class="s0">+u,p=</span><span class="s2">&quot;(?:(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){0,2}&quot;</span><span class="s0">+c+</span><span class="s2">&quot;)?::(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){2}&quot;</span><span class="s0">+u,g=</span><span class="s2">&quot;(?:(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){0,3}&quot;</span><span class="s0">+c+</span><span class="s2">&quot;)?::&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:&quot;</span><span class="s0">+u,y=</span><span class="s2">&quot;(?:(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){0,4}&quot;</span><span class="s0">+c+</span><span class="s2">&quot;)?::&quot;</span><span class="s0">+u,b=</span><span class="s2">&quot;(?:(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){0,5}&quot;</span><span class="s0">+c+</span><span class="s2">&quot;)?::&quot;</span><span class="s0">+c,v=</span><span class="s2">&quot;(?:(?:&quot;</span><span class="s0">+c+</span><span class="s2">&quot;:){0,6}&quot;</span><span class="s0">+c+</span><span class="s2">&quot;)?::&quot;</span><span class="s0">;e.ipv4Cidr=</span><span class="s2">&quot;(?:</span><span class="s4">\\</span><span class="s2">d|[1-2]</span><span class="s4">\\</span><span class="s2">d|3[0-2])&quot;</span><span class="s0">,e.ipv6Cidr=</span><span class="s2">&quot;(?:0{0,2}</span><span class="s4">\\</span><span class="s2">d|0?[1-9]</span><span class="s4">\\</span><span class="s2">d|1[01]</span><span class="s4">\\</span><span class="s2">d|12[0-8])&quot;</span><span class="s0">,e.ipv6address=</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+f+</span><span class="s2">&quot;|&quot;</span><span class="s0">+h+</span><span class="s2">&quot;|&quot;</span><span class="s0">+m+</span><span class="s2">&quot;|&quot;</span><span class="s0">+d+</span><span class="s2">&quot;|&quot;</span><span class="s0">+p+</span><span class="s2">&quot;|&quot;</span><span class="s0">+g+</span><span class="s2">&quot;|&quot;</span><span class="s0">+y+</span><span class="s2">&quot;|&quot;</span><span class="s0">+b+</span><span class="s2">&quot;|&quot;</span><span class="s0">+v+</span><span class="s2">&quot;)&quot;</span><span class="s0">,e.ipvFuture=</span><span class="s2">&quot;v&quot;</span><span class="s0">+r+</span><span class="s2">&quot;+</span><span class="s4">\\</span><span class="s2">.[&quot;</span><span class="s0">+s+n+</span><span class="s2">&quot;:]+&quot;</span><span class="s0">,e.scheme=</span><span class="s2">&quot;[a-zA-Z][a-zA-Z</span><span class="s4">\\</span><span class="s2">d+-</span><span class="s4">\\</span><span class="s2">.]*&quot;</span><span class="s0">,e.schemeRegex=</span><span class="s1">new </span><span class="s0">RegExp(e.scheme);const _=</span><span class="s2">&quot;[&quot;</span><span class="s0">+s+a+n+</span><span class="s2">&quot;:]*&quot;</span><span class="s0">,w=</span><span class="s2">&quot;[&quot;</span><span class="s0">+s+a+n+</span><span class="s2">&quot;]{1,255}&quot;</span><span class="s0">,$=</span><span class="s2">&quot;(?:</span><span class="s4">\\</span><span class="s2">[(?:&quot;</span><span class="s0">+e.ipv6address+</span><span class="s2">&quot;|&quot;</span><span class="s0">+e.ipvFuture+</span><span class="s2">&quot;)</span><span class="s4">\\</span><span class="s2">]|&quot;</span><span class="s0">+e.ipv4address+</span><span class="s2">&quot;|&quot;</span><span class="s0">+w+</span><span class="s2">&quot;)&quot;</span><span class="s0">,x=</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+_+</span><span class="s2">&quot;@)?&quot;</span><span class="s0">+$+</span><span class="s2">&quot;(?::</span><span class="s4">\\</span><span class="s2">d*)?&quot;</span><span class="s0">,j=</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+_+</span><span class="s2">&quot;@)?(&quot;</span><span class="s0">+$+</span><span class="s2">&quot;)(?::</span><span class="s4">\\</span><span class="s2">d*)?&quot;</span><span class="s0">,k=o+</span><span class="s2">&quot;*&quot;</span><span class="s0">,R=o+</span><span class="s2">&quot;+&quot;</span><span class="s0">,A=</span><span class="s2">&quot;(?:</span><span class="s4">\\</span><span class="s2">/&quot;</span><span class="s0">+k+</span><span class="s2">&quot;)*&quot;</span><span class="s0">,S=</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">/(?:&quot;</span><span class="s0">+R+A+</span><span class="s2">&quot;)?&quot;</span><span class="s0">,O=R+A,E=</span><span class="s2">&quot;[&quot;</span><span class="s0">+s+a+n+</span><span class="s2">&quot;@]+&quot;</span><span class="s0">+A,D=</span><span class="s2">&quot;(?:</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">/&quot;</span><span class="s0">+k+A+</span><span class="s2">&quot;)&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">e.hierPart=</span><span class="s2">&quot;(?:(?:</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">/&quot;</span><span class="s0">+x+A+</span><span class="s2">&quot;)|&quot;</span><span class="s0">+S+</span><span class="s2">&quot;|&quot;</span><span class="s0">+O+</span><span class="s2">&quot;|&quot;</span><span class="s0">+D+</span><span class="s2">&quot;)&quot;</span><span class="s0">,e.hierPartCapture=</span><span class="s2">&quot;(?:(?:</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">/&quot;</span><span class="s0">+j+A+</span><span class="s2">&quot;)|&quot;</span><span class="s0">+S+</span><span class="s2">&quot;|&quot;</span><span class="s0">+O+</span><span class="s2">&quot;)&quot;</span><span class="s0">,e.relativeRef=</span><span class="s2">&quot;(?:(?:</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">/&quot;</span><span class="s0">+x+A+</span><span class="s2">&quot;)|&quot;</span><span class="s0">+S+</span><span class="s2">&quot;|&quot;</span><span class="s0">+E+</span><span class="s2">&quot;|)&quot;</span><span class="s0">,e.relativeRefCapture=</span><span class="s2">&quot;(?:(?:</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">/&quot;</span><span class="s0">+j+A+</span><span class="s2">&quot;)|&quot;</span><span class="s0">+S+</span><span class="s2">&quot;|&quot;</span><span class="s0">+E+</span><span class="s2">&quot;|)&quot;</span><span class="s0">,e.query=</span><span class="s2">&quot;[&quot;</span><span class="s0">+i+</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">?]*(?=#|$)&quot;</span><span class="s0">,e.queryWithSquareBrackets=</span><span class="s2">&quot;[&quot;</span><span class="s0">+i+</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">[</span><span class="s4">\\</span><span class="s2">]</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">?]*(?=#|$)&quot;</span><span class="s0">,e.fragment=</span><span class="s2">&quot;[&quot;</span><span class="s0">+i+</span><span class="s2">&quot;</span><span class="s4">\\</span><span class="s2">/</span><span class="s4">\\</span><span class="s2">?]*&quot;</span><span class="s0">,e}};a.rfc3986=a.generate(),t.ip={v4Cidr:a.rfc3986.ipv4Cidr,v6Cidr:a.rfc3986.ipv6Cidr,ipv4:a.rfc3986.ipv4address,ipv6:a.rfc3986.ipv6address,ipvfuture:a.rfc3986.ipvFuture},a.createRegex=</span><span class="s1">function</span><span class="s0">(e){const t=a.rfc3986,r=</span><span class="s2">&quot;(?:</span><span class="s4">\\</span><span class="s2">?&quot;</span><span class="s0">+(e.allowQuerySquareBrackets?t.queryWithSquareBrackets:t.query)+</span><span class="s2">&quot;)?(?:#&quot;</span><span class="s0">+t.fragment+</span><span class="s2">&quot;)?&quot;</span><span class="s0">,i=e.domain?t.relativeRefCapture:t.relativeRef;</span><span class="s1">if</span><span class="s0">(e.relativeOnly)</span><span class="s1">return </span><span class="s0">a.wrap(i+r);let o=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e.scheme){s(e.scheme </span><span class="s1">instanceof </span><span class="s0">RegExp||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e.scheme||Array.isArray(e.scheme),</span><span class="s2">&quot;scheme must be a RegExp, String, or Array&quot;</span><span class="s0">);const r=[].concat(e.scheme);s(r.length&gt;=</span><span class="s3">1</span><span class="s0">,</span><span class="s2">&quot;scheme must have at least 1 scheme specified&quot;</span><span class="s0">);const a=[];</span><span class="s1">for</span><span class="s0">(let e=</span><span class="s3">0</span><span class="s0">;e&lt;r.length;++e){const i=r[e];s(i </span><span class="s1">instanceof </span><span class="s0">RegExp||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i,</span><span class="s2">&quot;scheme at position &quot;</span><span class="s0">+e+</span><span class="s2">&quot; must be a RegExp or String&quot;</span><span class="s0">),i </span><span class="s1">instanceof </span><span class="s0">RegExp?a.push(i.source.toString()):(s(t.schemeRegex.test(i),</span><span class="s2">&quot;scheme at position &quot;</span><span class="s0">+e+</span><span class="s2">&quot; must be a valid scheme&quot;</span><span class="s0">),a.push(n(i)))}o=a.join(</span><span class="s2">&quot;|&quot;</span><span class="s0">)}const l=</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+(o?</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+o+</span><span class="s2">&quot;)&quot;</span><span class="s0">:t.scheme)+</span><span class="s2">&quot;:&quot;</span><span class="s0">+(e.domain?t.hierPartCapture:t.hierPart)+</span><span class="s2">&quot;)&quot;</span><span class="s0">,c=e.allowRelative?</span><span class="s2">&quot;(?:&quot;</span><span class="s0">+l+</span><span class="s2">&quot;|&quot;</span><span class="s0">+i+</span><span class="s2">&quot;)&quot;</span><span class="s0">:l;</span><span class="s1">return </span><span class="s0">a.wrap(c+r,o)},a.wrap=</span><span class="s1">function</span><span class="s0">(e,t){</span><span class="s1">return</span><span class="s0">{raw:e=`(?=.)(?!https?:/(?:$|[^/]))(?!https?:</span><span class="s6">///)(?!https?:[^/])${e}`,regex:new RegExp(`^${e}$`),scheme:t}},a.uriRegex=a.createRegex({}),t.regex=function(){let e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:{};return e.scheme||e.allowRelative||e.relativeOnly||e.allowQuerySquareBrackets||e.domain?a.createRegex(e):a.uriRegex}},1447:(e,t)=&gt;{&quot;use strict&quot;;const r={operators:[&quot;!&quot;,&quot;^&quot;,&quot;*&quot;,&quot;/&quot;,&quot;%&quot;,&quot;+&quot;,&quot;-&quot;,&quot;&lt;&quot;,&quot;&lt;=&quot;,&quot;&gt;&quot;,&quot;&gt;=&quot;,&quot;==&quot;,&quot;!=&quot;,&quot;&amp;&amp;&quot;,&quot;||&quot;,&quot;??&quot;],operatorCharacters:[&quot;!&quot;,&quot;^&quot;,&quot;*&quot;,&quot;/&quot;,&quot;%&quot;,&quot;+&quot;,&quot;-&quot;,&quot;&lt;&quot;,&quot;=&quot;,&quot;&gt;&quot;,&quot;&amp;&quot;,&quot;|&quot;,&quot;?&quot;],operatorsOrder:[[&quot;^&quot;],[&quot;*&quot;,&quot;/&quot;,&quot;%&quot;],[&quot;+&quot;,&quot;-&quot;],[&quot;&lt;&quot;,&quot;&lt;=&quot;,&quot;&gt;&quot;,&quot;&gt;=&quot;],[&quot;==&quot;,&quot;!=&quot;],[&quot;&amp;&amp;&quot;],[&quot;||&quot;,&quot;??&quot;]],operatorsPrefix:[&quot;!&quot;,&quot;n&quot;],literals:{'&quot;':'&quot;',&quot;`&quot;:&quot;`&quot;,&quot;'&quot;:&quot;'&quot;,&quot;[&quot;:&quot;]&quot;},numberRx:/^(?:[0-9]*(\.[0-9]*)?){1}$/,tokenRx:/^[\w\$\#\.\@\:\{\}]+$/,symbol:Symbol(&quot;formula&quot;),settings:Symbol(&quot;settings&quot;)};t.Parser=class{constructor(e){let t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};if(!t[r.settings]&amp;&amp;t.constants)for(const e in t.constants){const r=t.constants[e];if(null!==r&amp;&amp;![&quot;boolean&quot;,&quot;number&quot;,&quot;string&quot;].includes(typeof r))throw new Error(`Formula constant ${e} contains invalid ${typeof r} value type`)}this.settings=t[r.settings]?t:Object.assign({[r.settings]:!0,constants:{},functions:{}},t),this.single=null,this._parts=null,this._parse(e)}_parse(e){let s=[],n=&quot;&quot;,a=0,i=!1;const o=e=&gt;{if(a)throw new Error(&quot;Formula missing closing parenthesis&quot;);const o=s.length?s[s.length-1]:null;if(i||n||e){if(o&amp;&amp;&quot;reference&quot;===o.type&amp;&amp;&quot;)&quot;===e)return o.type=&quot;function&quot;,o.value=this._subFormula(n,o.value),void(n=&quot;&quot;);if(&quot;)&quot;===e){const e=new t.Parser(n,this.settings);s.push({type:&quot;segment&quot;,value:e})}else if(i){if(&quot;]&quot;===i)return s.push({type:&quot;reference&quot;,value:n}),void(n=&quot;&quot;);s.push({type:&quot;literal&quot;,value:n})}else if(r.operatorCharacters.includes(n))o&amp;&amp;&quot;operator&quot;===o.type&amp;&amp;r.operators.includes(o.value+n)?o.value+=n:s.push({type:&quot;operator&quot;,value:n});else if(n.match(r.numberRx))s.push({type:&quot;constant&quot;,value:parseFloat(n)});else if(void 0!==this.settings.constants[n])s.push({type:&quot;constant&quot;,value:this.settings.constants[n]});else{if(!n.match(r.tokenRx))throw new Error(`Formula contains invalid token: ${n}`);s.push({type:&quot;reference&quot;,value:n})}n=&quot;&quot;}};for(const t of e)i?t===i?(o(),i=!1):n+=t:a?&quot;(&quot;===t?(n+=t,++a):&quot;)&quot;===t?(--a,a?n+=t:o(t)):n+=t:t in r.literals?i=r.literals[t]:&quot;(&quot;===t?(o(),++a):r.operatorCharacters.includes(t)?(o(),n=t,o()):&quot; &quot;!==t?n+=t:o();o(),s=s.map(((e,t)=&gt;&quot;operator&quot;!==e.type||&quot;-&quot;!==e.value||t&amp;&amp;&quot;operator&quot;!==s[t-1].type?e:{type:&quot;operator&quot;,value:&quot;n&quot;}));let l=!1;for(const e of s){if(&quot;operator&quot;===e.type){if(r.operatorsPrefix.includes(e.value))continue;if(!l)throw new Error(&quot;Formula contains an operator in invalid position&quot;);if(!r.operators.includes(e.value))throw new Error(`Formula contains an unknown operator ${e.value}`)}else if(l)throw new Error(&quot;Formula missing expected operator&quot;);l=!l}if(!l)throw new Error(&quot;Formula contains invalid trailing operator&quot;);1===s.length&amp;&amp;[&quot;reference&quot;,&quot;literal&quot;,&quot;constant&quot;].includes(s[0].type)&amp;&amp;(this.single={type:&quot;reference&quot;===s[0].type?&quot;reference&quot;:&quot;value&quot;,value:s[0].value}),this._parts=s.map((e=&gt;{if(&quot;operator&quot;===e.type)return r.operatorsPrefix.includes(e.value)?e:e.value;if(&quot;reference&quot;!==e.type)return e.value;if(this.settings.tokenRx&amp;&amp;!this.settings.tokenRx.test(e.value))throw new Error(`Formula contains invalid reference ${e.value}`);return this.settings.reference?this.settings.reference(e.value):r.reference(e.value)}))}_subFormula(e,s){const n=this.settings.functions[s];if(&quot;function&quot;!=typeof n)throw new Error(`Formula contains unknown function ${s}`);let a=[];if(e){let t=&quot;&quot;,n=0,i=!1;const o=()=&gt;{if(!t)throw new Error(`Formula contains function ${s} with invalid arguments ${e}`);a.push(t),t=&quot;&quot;};for(let s=0;s&lt;e.length;++s){const a=e[s];i?(t+=a,a===i&amp;&amp;(i=!1)):a in r.literals&amp;&amp;!n?(t+=a,i=r.literals[a]):&quot;,&quot;!==a||n?(t+=a,&quot;(&quot;===a?++n:&quot;)&quot;===a&amp;&amp;--n):o()}o()}return a=a.map((e=&gt;new t.Parser(e,this.settings))),function(e){const t=[];for(const r of a)t.push(r.evaluate(e));return n.call(e,...t)}}evaluate(e){const t=this._parts.slice();for(let s=t.length-2;s&gt;=0;--s){const n=t[s];if(n&amp;&amp;&quot;operator&quot;===n.type){const a=t[s+1];t.splice(s+1,1);const i=r.evaluate(a,e);t[s]=r.single(n.value,i)}}return r.operatorsOrder.forEach((s=&gt;{for(let n=1;n&lt;t.length-1;)if(s.includes(t[n])){const s=t[n],a=r.evaluate(t[n-1],e),i=r.evaluate(t[n+1],e);t.splice(n,2);const o=r.calculate(s,a,i);t[n-1]=0===o?0:o}else n+=2})),r.evaluate(t[0],e)}},t.Parser.prototype[r.symbol]=!0,r.reference=function(e){return function(t){return t&amp;&amp;void 0!==t[e]?t[e]:null}},r.evaluate=function(e,t){return null===e?null:&quot;function&quot;==typeof e?e(t):e[r.symbol]?e.evaluate(t):e},r.single=function(e,t){if(&quot;!&quot;===e)return!t;const r=-t;return 0===r?0:r},r.calculate=function(e,t,s){if(&quot;??&quot;===e)return r.exists(t)?t:s;if(&quot;string&quot;==typeof t||&quot;string&quot;==typeof s){if(&quot;+&quot;===e)return(t=r.exists(t)?t:&quot;&quot;)+(r.exists(s)?s:&quot;&quot;)}else switch(e){case&quot;^&quot;:return Math.pow(t,s);case&quot;*&quot;:return t*s;case&quot;/&quot;:return t/s;case&quot;%&quot;:return t%s;case&quot;+&quot;:return t+s;case&quot;-&quot;:return t-s}switch(e){case&quot;&lt;&quot;:return t&lt;s;case&quot;&lt;=&quot;:return t&lt;=s;case&quot;&gt;&quot;:return t&gt;s;case&quot;&gt;=&quot;:return t&gt;=s;case&quot;==&quot;:return t===s;case&quot;!=&quot;:return t!==s;case&quot;&amp;&amp;&quot;:return t&amp;&amp;s;case&quot;||&quot;:return t||s}return null},r.exists=function(e){return null!=e}},9926:()=&gt;{},5688:()=&gt;{},9708:()=&gt;{},1152:()=&gt;{},443:()=&gt;{},9848:()=&gt;{},5934:e=&gt;{&quot;use strict&quot;;e.exports={version:&quot;17.9.2&quot;}}},t={},function r(s){var n=t[s];if(void 0!==n)return n.exports;var a=t[s]={exports:{}};return e[s](a,a.exports,r),a.exports}(5107);var e,t}));</span></pre>
</body>
</html>
<html>
<head>
<title>tls.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #9876aa; font-style: italic;}
.s6 { color: #ffc66d;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tls.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The `node:tls` module provides an implementation of the Transport Layer Security 
 * (TLS) and Secure Socket Layer (SSL) protocols that is built on top of OpenSSL. 
 * The module can be accessed using: 
 * 
 * ```js 
 * const tls = require('node:tls'); 
 * ``` 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/tls.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'tls' </span><span class="s3">{</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">X509Certificate </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'node:crypto'</span><span class="s3">;</span>
    <span class="s1">import </span><span class="s5">* </span><span class="s1">as </span><span class="s2">net </span><span class="s1">from </span><span class="s4">'node:net'</span><span class="s3">;</span>
    <span class="s1">import </span><span class="s5">* </span><span class="s1">as </span><span class="s2">stream </span><span class="s1">from </span><span class="s4">'stream'</span><span class="s3">;</span>
    <span class="s1">const </span><span class="s3">CLIENT_RENEG_LIMIT</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s1">const </span><span class="s3">CLIENT_RENEG_WINDOW</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">Certificate </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Country code. 
         */</span>
        <span class="s3">C</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Street. 
         */</span>
        <span class="s3">ST</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Locality. 
         */</span>
        <span class="s3">L</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Organization. 
         */</span>
        <span class="s3">O</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Organizational unit. 
         */</span>
        <span class="s3">OU</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Common name. 
         */</span>
        <span class="s3">CN</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">PeerCertificate </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* `true` if a Certificate Authority (CA), `false` otherwise. 
         * </span><span class="s1">@since </span><span class="s0">v18.13.0 
         */</span>
        <span class="s3">ca</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The DER encoded X.509 certificate data. 
         */</span>
        <span class="s3">raw</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The certificate subject. 
         */</span>
        <span class="s3">subject</span><span class="s1">: </span><span class="s2">Certificate</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The certificate issuer, described in the same terms as the `subject`. 
         */</span>
        <span class="s3">issuer</span><span class="s1">: </span><span class="s2">Certificate</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The date-time the certificate is valid from. 
         */</span>
        <span class="s3">valid_from</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The date-time the certificate is valid to. 
         */</span>
        <span class="s3">valid_to</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The certificate serial number, as a hex string. 
         */</span>
        <span class="s3">serialNumber</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The SHA-1 digest of the DER encoded certificate. 
         * It is returned as a `:` separated hexadecimal string. 
         */</span>
        <span class="s3">fingerprint</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The SHA-256 digest of the DER encoded certificate. 
         * It is returned as a `:` separated hexadecimal string. 
         */</span>
        <span class="s3">fingerprint256</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The SHA-512 digest of the DER encoded certificate. 
         * It is returned as a `:` separated hexadecimal string. 
         */</span>
        <span class="s3">fingerprint512</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The extended key usage, a set of OIDs. 
         */</span>
        <span class="s3">ext_key_usage</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* A string containing concatenated names for the subject, 
         * an alternative to the `subject` names. 
         */</span>
        <span class="s3">subjectaltname</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array describing the AuthorityInfoAccess, used with OCSP. 
         */</span>
        <span class="s3">infoAccess</span><span class="s1">?: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">Dict</span><span class="s3">&lt;</span><span class="s2">string</span><span class="s3">[]&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* For RSA keys: The RSA bit size. 
         * 
         * For EC keys: The key size in bits. 
         */</span>
        <span class="s3">bits</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The RSA exponent, as a string in hexadecimal number notation. 
         */</span>
        <span class="s3">exponent</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The RSA modulus, as a hexadecimal string. 
         */</span>
        <span class="s3">modulus</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The public key. 
         */</span>
        <span class="s3">pubkey</span><span class="s1">?: </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The ASN.1 name of the OID of the elliptic curve. 
         * Well-known curves are identified by an OID. 
         * While it is unusual, it is possible that the curve 
         * is identified by its mathematical properties, 
         * in which case it will not have an OID. 
         */</span>
        <span class="s3">asn1Curve</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The NIST name for the elliptic curve,if it has one 
         * (not all well-known curves have been assigned names by NIST). 
         */</span>
        <span class="s3">nistCurve</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">DetailedPeerCertificate </span><span class="s1">extends </span><span class="s2">PeerCertificate </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The issuer certificate object. 
         * For self-signed certificates, this may be a circular reference. 
         */</span>
        <span class="s3">issuerCertificate</span><span class="s1">: </span><span class="s2">DetailedPeerCertificate</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">CipherNameAndProtocol </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The cipher name. 
         */</span>
        <span class="s3">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* SSL/TLS protocol version. 
         */</span>
        <span class="s3">version</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* IETF name for the cipher suite. 
         */</span>
        <span class="s3">standardName</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">EphemeralKeyInfo </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The supported types are 'DH' and 'ECDH'. 
         */</span>
        <span class="s3">type</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The name property is available only when type is 'ECDH'. 
         */</span>
        <span class="s3">name</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The size of parameter of an ephemeral key exchange. 
         */</span>
        <span class="s3">size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">KeyObject </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Private keys in PEM format. 
         */</span>
        <span class="s3">pem</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional passphrase. 
         */</span>
        <span class="s3">passphrase</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">PxfObject </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* PFX or PKCS12 encoded private key and certificate chain. 
         */</span>
        <span class="s3">buf</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optional passphrase. 
         */</span>
        <span class="s3">passphrase</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">TLSSocketOptions </span><span class="s1">extends </span><span class="s2">SecureContextOptions</span><span class="s3">, </span><span class="s2">CommonConnectionOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If true the TLS socket will be instantiated in server-mode. 
         * Defaults to false. 
         */</span>
        <span class="s3">isServer</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional net.Server instance. 
         */</span>
        <span class="s3">server</span><span class="s1">?: </span><span class="s2">net</span><span class="s3">.</span><span class="s2">Server </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional Buffer instance containing a TLS session. 
         */</span>
        <span class="s3">session</span><span class="s1">?: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true, specifies that the OCSP status request extension will be 
         * added to the client hello and an 'OCSPResponse' event will be 
         * emitted on the socket before establishing a secure communication 
         */</span>
        <span class="s3">requestOCSP</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Performs transparent encryption of written data and all required TLS 
     * negotiation. 
     * 
     * Instances of `tls.TLSSocket` implement the duplex `Stream` interface. 
     * 
     * Methods that return TLS connection metadata (e.g.</span><span class="s2">{</span><span class="s1">@link </span><span class="s2">TLSSocket.getPeerCertificate}</span><span class="s0">) will only return data while the 
     * connection is open. 
     * </span><span class="s1">@since </span><span class="s0">v0.11.4 
     */</span>
    <span class="s1">class </span><span class="s2">TLSSocket </span><span class="s1">extends </span><span class="s2">net</span><span class="s3">.</span><span class="s2">Socket </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Construct a new tls.TLSSocket object from an existing TCP socket. 
         */</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">socket</span><span class="s1">: </span><span class="s2">net</span><span class="s3">.</span><span class="s2">Socket</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">TLSSocketOptions</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* This property is `true` if the peer certificate was signed by one of the CAs 
         * specified when creating the `tls.TLSSocket` instance, otherwise `false`. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.4 
         */</span>
        <span class="s3">authorized</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the reason why the peer's certificate was not been verified. This 
         * property is set only when `tlsSocket.authorized === false`. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.4 
         */</span>
        <span class="s3">authorizationError</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Always returns `true`. This may be used to distinguish TLS sockets from regular`net.Socket` instances. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.4 
         */</span>
        <span class="s3">encrypted</span><span class="s1">: </span><span class="s2">true</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* String containing the selected ALPN protocol. 
         * Before a handshake has completed, this value is always null. 
         * When a handshake is completed but not ALPN protocol was selected, tlsSocket.alpnProtocol equals false. 
         */</span>
        <span class="s3">alpnProtocol</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">false </span><span class="s1">| </span><span class="s2">null</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns an object representing the local certificate. The returned object has 
         * some properties corresponding to the fields of the certificate. 
         * 
         * See </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">TLSSocket.getPeerCertificate} </span><span class="s0">for an example of the certificate 
         * structure. 
         * 
         * If there is no local certificate, an empty object will be returned. If the 
         * socket has been destroyed, `null` will be returned. 
         * </span><span class="s1">@since </span><span class="s0">v11.2.0 
         */</span>
        <span class="s3">getCertificate()</span><span class="s1">: </span><span class="s2">PeerCertificate </span><span class="s1">| </span><span class="s2">object </span><span class="s1">| </span><span class="s2">null</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns an object containing information on the negotiated cipher suite. 
         * 
         * For example, a TLSv1.2 protocol with AES256-SHA cipher: 
         * 
         * ```json 
         * { 
         *     &quot;name&quot;: &quot;AES256-SHA&quot;, 
         *     &quot;standardName&quot;: &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;, 
         *     &quot;version&quot;: &quot;SSLv3&quot; 
         * } 
         * ``` 
         * 
         * See [SSL\_CIPHER\_get\_name](https://www.openssl.org/docs/man1.1.1/man3/SSL_CIPHER_get_name.html) for more information. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.4 
         */</span>
        <span class="s3">getCipher()</span><span class="s1">: </span><span class="s2">CipherNameAndProtocol</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns an object representing the type, name, and size of parameter of 
         * an ephemeral key exchange in `perfect forward secrecy` on a client 
         * connection. It returns an empty object when the key exchange is not 
         * ephemeral. As this is only supported on a client socket; `null` is returned 
         * if called on a server socket. The supported types are `'DH'` and `'ECDH'`. The`name` property is available only when type is `'ECDH'`. 
         * 
         * For example: `{ type: 'ECDH', name: 'prime256v1', size: 256 }`. 
         * </span><span class="s1">@since </span><span class="s0">v5.0.0 
         */</span>
        <span class="s3">getEphemeralKeyInfo()</span><span class="s1">: </span><span class="s2">EphemeralKeyInfo </span><span class="s1">| </span><span class="s2">object </span><span class="s1">| </span><span class="s2">null</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* As the `Finished` messages are message digests of the complete handshake 
         * (with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can 
         * be used for external authentication procedures when the authentication 
         * provided by SSL/TLS is not desired or is not enough. 
         * 
         * Corresponds to the `SSL_get_finished` routine in OpenSSL and may be used 
         * to implement the `tls-unique` channel binding from [RFC 5929](https://tools.ietf.org/html/rfc5929). 
         * </span><span class="s1">@since </span><span class="s0">v9.9.0 
         * </span><span class="s1">@return </span><span class="s0">The latest `Finished` message that has been sent to the socket as part of a SSL/TLS handshake, or `undefined` if no `Finished` message has been sent yet. 
         */</span>
        <span class="s3">getFinished()</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns an object representing the peer's certificate. If the peer does not 
         * provide a certificate, an empty object will be returned. If the socket has been 
         * destroyed, `null` will be returned. 
         * 
         * If the full certificate chain was requested, each certificate will include an`issuerCertificate` property containing an object representing its issuer's 
         * certificate. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.4 
         * </span><span class="s1">@param </span><span class="s2">detailed </span><span class="s0">Include the full certificate chain if `true`, otherwise include just the peer's certificate. 
         * </span><span class="s1">@return </span><span class="s0">A certificate object. 
         */</span>
        <span class="s3">getPeerCertificate(</span><span class="s2">detailed</span><span class="s1">: </span><span class="s2">true</span><span class="s3">)</span><span class="s1">: </span><span class="s2">DetailedPeerCertificate</span><span class="s3">;</span>
        <span class="s3">getPeerCertificate(</span><span class="s2">detailed</span><span class="s1">?: </span><span class="s2">false</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PeerCertificate</span><span class="s3">;</span>
        <span class="s3">getPeerCertificate(</span><span class="s2">detailed</span><span class="s1">?: </span><span class="s2">boolean</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PeerCertificate </span><span class="s1">| </span><span class="s2">DetailedPeerCertificate</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* As the `Finished` messages are message digests of the complete handshake 
         * (with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can 
         * be used for external authentication procedures when the authentication 
         * provided by SSL/TLS is not desired or is not enough. 
         * 
         * Corresponds to the `SSL_get_peer_finished` routine in OpenSSL and may be used 
         * to implement the `tls-unique` channel binding from [RFC 5929](https://tools.ietf.org/html/rfc5929). 
         * </span><span class="s1">@since </span><span class="s0">v9.9.0 
         * </span><span class="s1">@return </span><span class="s0">The latest `Finished` message that is expected or has actually been received from the socket as part of a SSL/TLS handshake, or `undefined` if there is no `Finished` message so 
         * far. 
         */</span>
        <span class="s3">getPeerFinished()</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a string containing the negotiated SSL/TLS protocol version of the 
         * current connection. The value `'unknown'` will be returned for connected 
         * sockets that have not completed the handshaking process. The value `null` will 
         * be returned for server sockets or disconnected client sockets. 
         * 
         * Protocol versions are: 
         * 
         * * `'SSLv3'` 
         * * `'TLSv1'` 
         * * `'TLSv1.1'` 
         * * `'TLSv1.2'` 
         * * `'TLSv1.3'` 
         * 
         * See the OpenSSL [`SSL_get_version`](https://www.openssl.org/docs/man1.1.1/man3/SSL_get_version.html) documentation for more information. 
         * </span><span class="s1">@since </span><span class="s0">v5.7.0 
         */</span>
        <span class="s3">getProtocol()</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">null</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the TLS session data or `undefined` if no session was 
         * negotiated. On the client, the data can be provided to the `session` option of </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">connect} </span><span class="s0">to resume the connection. On the server, it may be useful 
         * for debugging. 
         * 
         * See `Session Resumption` for more information. 
         * 
         * Note: `getSession()` works only for TLSv1.2 and below. For TLSv1.3, applications 
         * must use the `'session'` event (it also works for TLSv1.2 and below). 
         * </span><span class="s1">@since </span><span class="s0">v0.11.4 
         */</span>
        <span class="s3">getSession()</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* See [SSL\_get\_shared\_sigalgs](https://www.openssl.org/docs/man1.1.1/man3/SSL_get_shared_sigalgs.html) for more information. 
         * </span><span class="s1">@since </span><span class="s0">v12.11.0 
         * </span><span class="s1">@return </span><span class="s0">List of signature algorithms shared between the server and the client in the order of decreasing preference. 
         */</span>
        <span class="s3">getSharedSigalgs()</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* For a client, returns the TLS session ticket if one is available, or`undefined`. For a server, always returns `undefined`. 
         * 
         * It may be useful for debugging. 
         * 
         * See `Session Resumption` for more information. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.4 
         */</span>
        <span class="s3">getTLSTicket()</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* See `Session Resumption` for more information. 
         * </span><span class="s1">@since </span><span class="s0">v0.5.6 
         * </span><span class="s1">@return </span><span class="s0">`true` if the session was reused, `false` otherwise. 
         */</span>
        <span class="s3">isSessionReused()</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `tlsSocket.renegotiate()` method initiates a TLS renegotiation process. 
         * Upon completion, the `callback` function will be passed a single argument 
         * that is either an `Error` (if the request failed) or `null`. 
         * 
         * This method can be used to request a peer's certificate after the secure 
         * connection has been established. 
         * 
         * When running as the server, the socket will be destroyed with an error after`handshakeTimeout` timeout. 
         * 
         * For TLSv1.3, renegotiation cannot be initiated, it is not supported by the 
         * protocol. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.8 
         * </span><span class="s1">@param </span><span class="s2">callback </span><span class="s0">If `renegotiate()` returned `true`, callback is attached once to the `'secure'` event. If `renegotiate()` returned `false`, `callback` will be called in the next tick with 
         * an error, unless the `tlsSocket` has been destroyed, in which case `callback` will not be called at all. 
         * </span><span class="s1">@return </span><span class="s0">`true` if renegotiation was initiated, `false` otherwise. 
         */</span>
        <span class="s3">renegotiate(</span>
            <span class="s2">options</span><span class="s1">: </span><span class="s3">{</span>
                <span class="s3">rejectUnauthorized</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
                <span class="s3">requestCert</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
            <span class="s3">},</span>
            <span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span>
        <span class="s3">)</span><span class="s1">: </span><span class="s2">undefined </span><span class="s1">| </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `tlsSocket.setMaxSendFragment()` method sets the maximum TLS fragment size. 
         * Returns `true` if setting the limit succeeded; `false` otherwise. 
         * 
         * Smaller fragment sizes decrease the buffering latency on the client: larger 
         * fragments are buffered by the TLS layer until the entire fragment is received 
         * and its integrity is verified; large fragments can span multiple roundtrips 
         * and their processing can be delayed due to packet loss or reordering. However, 
         * smaller fragments add extra TLS framing bytes and CPU overhead, which may 
         * decrease overall server throughput. 
         * </span><span class="s1">@since </span><span class="s0">v0.11.11 
         * </span><span class="s1">@param </span><span class="s0">[size=16384] The maximum TLS fragment size. The maximum value is `16384`. 
         */</span>
        <span class="s3">setMaxSendFragment(</span><span class="s2">size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Disables TLS renegotiation for this `TLSSocket` instance. Once called, attempts 
         * to renegotiate will trigger an `'error'` event on the `TLSSocket`. 
         * </span><span class="s1">@since </span><span class="s0">v8.4.0 
         */</span>
        <span class="s3">disableRenegotiation()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* When enabled, TLS packet trace information is written to `stderr`. This can be 
         * used to debug TLS connection problems. 
         * 
         * The format of the output is identical to the output of`openssl s_client -trace` or `openssl s_server -trace`. While it is produced by 
         * OpenSSL's `SSL_trace()` function, the format is undocumented, can change 
         * without notice, and should not be relied on. 
         * </span><span class="s1">@since </span><span class="s0">v12.2.0 
         */</span>
        <span class="s3">enableTrace()</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the peer certificate as an `X509Certificate` object. 
         * 
         * If there is no peer certificate, or the socket has been destroyed,`undefined` will be returned. 
         * </span><span class="s1">@since </span><span class="s0">v15.9.0 
         */</span>
        <span class="s3">getPeerX509Certificate()</span><span class="s1">: </span><span class="s2">X509Certificate </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the local certificate as an `X509Certificate` object. 
         * 
         * If there is no local certificate, or the socket has been destroyed,`undefined` will be returned. 
         * </span><span class="s1">@since </span><span class="s0">v15.9.0 
         */</span>
        <span class="s3">getX509Certificate()</span><span class="s1">: </span><span class="s2">X509Certificate </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Keying material is used for validations to prevent different kind of attacks in 
         * network protocols, for example in the specifications of IEEE 802.1X. 
         * 
         * Example 
         * 
         * ```js 
         * const keyingMaterial = tlsSocket.exportKeyingMaterial( 
         *   128, 
         *   'client finished'); 
         * 
         * /* 
         *  Example return value of keyingMaterial: 
         *  &lt;Buffer 76 26 af 99 c5 56 8e 42 09 91 ef 9f 93 cb ad 6c 7b 65 f8 53 f1 d8 d9 
         *     12 5a 33 b8 b5 25 df 7b 37 9f e0 e2 4f b8 67 83 a3 2f cd 5d 41 42 4c 91 
         *     74 ef 2c ... 78 more bytes&gt; 
         * 
         * ``` 
         * 
         * See the OpenSSL [`SSL_export_keying_material`](https://www.openssl.org/docs/man1.1.1/man3/SSL_export_keying_material.html) documentation for more 
         * information. 
         * </span><span class="s1">@since </span><span class="s0">v13.10.0, v12.17.0 
         * </span><span class="s1">@param </span><span class="s2">length </span><span class="s0">number of bytes to retrieve from keying material 
         * </span><span class="s1">@param </span><span class="s2">label </span><span class="s0">an application specific label, typically this will be a value from the [IANA Exporter Label 
         * Registry](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels). 
         * </span><span class="s1">@param </span><span class="s2">context </span><span class="s0">Optionally provide a context. 
         * </span><span class="s1">@return </span><span class="s0">requested bytes of the keying material 
         */</span>
        <span class="s3">exportKeyingMaterial(</span><span class="s2">length</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">label</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">context</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPResponse'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">response</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'session'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">session</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[])</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPResponse'</span><span class="s3">, </span><span class="s2">response</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnect'</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'session'</span><span class="s3">, </span><span class="s2">session</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPResponse'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">response</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'session'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">session</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPResponse'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">response</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'session'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">session</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPResponse'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">response</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'session'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">session</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPResponse'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">response</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnect'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'session'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">session</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">CommonConnectionOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* An optional TLS context object from tls.createSecureContext() 
         */</span>
        <span class="s3">secureContext</span><span class="s1">?: </span><span class="s2">SecureContext </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* When enabled, TLS packet trace information is written to `stderr`. This can be 
         * used to debug TLS connection problems. 
         * </span><span class="s1">@default </span><span class="s2">false</span>
         <span class="s0">*/</span>
        <span class="s3">enableTrace</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true the server will request a certificate from clients that 
         * connect and attempt to verify that certificate. Defaults to 
         * false. 
         */</span>
        <span class="s3">requestCert</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of strings or a Buffer naming possible ALPN protocols. 
         * (Protocols should be ordered by their priority.) 
         */</span>
        <span class="s3">ALPNProtocols</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">[] </span><span class="s1">| </span><span class="s2">Uint8Array</span><span class="s3">[] </span><span class="s1">| </span><span class="s2">Uint8Array </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* SNICallback(servername, cb) &lt;Function&gt; A function that will be 
         * called if the client supports SNI TLS extension. Two arguments 
         * will be passed when called: servername and cb. SNICallback should 
         * invoke cb(null, ctx), where ctx is a SecureContext instance. 
         * (tls.createSecureContext(...) can be used to get a proper 
         * SecureContext.) If SNICallback wasn't provided the default callback 
         * with high-level API will be used (see below). 
         */</span>
        <span class="s3">SNICallback</span><span class="s1">?: </span><span class="s3">((</span><span class="s2">servername</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">cb</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">ctx</span><span class="s1">?: </span><span class="s2">SecureContext</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If true the server will reject any connection which is not 
         * authorized with the list of supplied CAs. This option only has an 
         * effect if requestCert is true. 
         * </span><span class="s1">@default </span><span class="s2">true</span>
         <span class="s0">*/</span>
        <span class="s3">rejectUnauthorized</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">TlsOptions </span><span class="s1">extends </span><span class="s2">SecureContextOptions</span><span class="s3">, </span><span class="s2">CommonConnectionOptions</span><span class="s3">, </span><span class="s2">net</span><span class="s3">.</span><span class="s2">ServerOpts </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Abort the connection if the SSL/TLS handshake does not finish in the 
         * specified number of milliseconds. A 'tlsClientError' is emitted on 
         * the tls.Server object whenever a handshake times out. Default: 
         * 120000 (120 seconds). 
         */</span>
        <span class="s3">handshakeTimeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of seconds after which a TLS session created by the 
         * server will no longer be resumable. See Session Resumption for more 
         * information. Default: 300. 
         */</span>
        <span class="s3">sessionTimeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* 48-bytes of cryptographically strong pseudo-random data. 
         */</span>
        <span class="s3">ticketKeys</span><span class="s1">?: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* 
         * </span><span class="s1">@param </span><span class="s2">socket</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s2">identity </span><span class="s0">identity parameter sent from the client. 
         * </span><span class="s1">@return </span><span class="s0">pre-shared key that must either be 
         * a buffer or `null` to stop the negotiation process. Returned PSK must be 
         * compatible with the selected cipher's digest. 
         * 
         * When negotiating TLS-PSK (pre-shared keys), this function is called 
         * with the identity provided by the client. 
         * If the return value is `null` the negotiation process will stop and an 
         * &quot;unknown_psk_identity&quot; alert message will be sent to the other party. 
         * If the server wishes to hide the fact that the PSK identity was not known, 
         * the callback must provide some random data as `psk` to make the connection 
         * fail with &quot;decrypt_error&quot; before negotiation is finished. 
         * PSK ciphers are disabled by default, and using TLS-PSK thus 
         * requires explicitly specifying a cipher suite with the `ciphers` option. 
         * More information can be found in the RFC 4279. 
         */</span>
        <span class="s3">pskCallback</span><span class="s1">?</span><span class="s3">(</span><span class="s2">socket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">, </span><span class="s2">identity</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">DataView </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">TypedArray </span><span class="s1">| </span><span class="s2">null</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* hint to send to a client to help 
         * with selecting the identity during TLS-PSK negotiation. Will be ignored 
         * in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be 
         * emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code. 
         */</span>
        <span class="s3">pskIdentityHint</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">PSKCallbackNegotation </span><span class="s3">{</span>
        <span class="s3">psk</span><span class="s1">: </span><span class="s2">DataView </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">TypedArray</span><span class="s3">;</span>
        <span class="s3">identity</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">ConnectionOptions </span><span class="s1">extends </span><span class="s2">SecureContextOptions</span><span class="s3">, </span><span class="s2">CommonConnectionOptions </span><span class="s3">{</span>
        <span class="s3">host</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">port</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">path</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">; </span><span class="s0">// Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.</span>
        <span class="s3">socket</span><span class="s1">?: </span><span class="s2">stream</span><span class="s3">.</span><span class="s2">Duplex </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">; </span><span class="s0">// Establish secure connection on a given socket rather than creating a new socket</span>
        <span class="s3">checkServerIdentity</span><span class="s1">?: typeof </span><span class="s2">checkServerIdentity </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">servername</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">; </span><span class="s0">// SNI TLS Extension</span>
        <span class="s3">session</span><span class="s1">?: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">minDHSize</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">lookup</span><span class="s1">?: </span><span class="s2">net</span><span class="s3">.</span><span class="s2">LookupFunction </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s3">timeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* When negotiating TLS-PSK (pre-shared keys), this function is called 
         * with optional identity `hint` provided by the server or `null` 
         * in case of TLS 1.3 where `hint` was removed. 
         * It will be necessary to provide a custom `tls.checkServerIdentity()` 
         * for the connection as the default one will try to check hostname/IP 
         * of the server against the certificate but that's not applicable for PSK 
         * because there won't be a certificate present. 
         * More information can be found in the RFC 4279. 
         * 
         * </span><span class="s1">@param </span><span class="s2">hint </span><span class="s0">message sent from the server to help client 
         * decide which identity to use during negotiation. 
         * Always `null` if TLS 1.3 is used. 
         * </span><span class="s1">@returns </span><span class="s0">Return `null` to stop the negotiation process. `psk` must be 
         * compatible with the selected cipher's digest. 
         * `identity` must use UTF-8 encoding. 
         */</span>
        <span class="s3">pskCallback</span><span class="s1">?</span><span class="s3">(</span><span class="s2">hint</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">null</span><span class="s3">)</span><span class="s1">: </span><span class="s2">PSKCallbackNegotation </span><span class="s1">| </span><span class="s2">null</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Accepts encrypted connections using TLS or SSL. 
     * </span><span class="s1">@since </span><span class="s0">v0.3.2 
     */</span>
    <span class="s1">class </span><span class="s2">Server </span><span class="s1">extends </span><span class="s2">net</span><span class="s3">.</span><span class="s2">Server </span><span class="s3">{</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s6">secureConnectionListener</span><span class="s1">?: </span><span class="s3">(</span><span class="s2">socket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">);</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">options</span><span class="s1">: </span><span class="s2">TlsOptions</span><span class="s3">, </span><span class="s6">secureConnectionListener</span><span class="s1">?: </span><span class="s3">(</span><span class="s2">socket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* The `server.addContext()` method adds a secure context that will be used if 
         * the client request's SNI name matches the supplied `hostname` (or wildcard). 
         * 
         * When there are multiple matching contexts, the most recently added one is 
         * used. 
         * </span><span class="s1">@since </span><span class="s0">v0.5.3 
         * </span><span class="s1">@param </span><span class="s2">hostname </span><span class="s0">A SNI host name or wildcard (e.g. `'*'`) 
         * </span><span class="s1">@param </span><span class="s2">context </span><span class="s0">An object containing any of the possible properties from the </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createSecureContext} </span><span class="s0">`options` arguments (e.g. `key`, `cert`, `ca`, etc), or a TLS context object created 
         * with </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createSecureContext} </span><span class="s0">itself. 
         */</span>
        <span class="s3">addContext(</span><span class="s2">hostname</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">context</span><span class="s1">: </span><span class="s2">SecureContextOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the session ticket keys. 
         * 
         * See `Session Resumption` for more information. 
         * </span><span class="s1">@since </span><span class="s0">v3.0.0 
         * </span><span class="s1">@return </span><span class="s0">A 48-byte buffer containing the session ticket keys. 
         */</span>
        <span class="s3">getTicketKeys()</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The `server.setSecureContext()` method replaces the secure context of an 
         * existing server. Existing connections to the server are not interrupted. 
         * </span><span class="s1">@since </span><span class="s0">v11.0.0 
         * </span><span class="s1">@param </span><span class="s2">options </span><span class="s0">An object containing any of the possible properties from the </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createSecureContext} </span><span class="s0">`options` arguments (e.g. `key`, `cert`, `ca`, etc). 
         */</span>
        <span class="s3">setSecureContext(</span><span class="s2">options</span><span class="s1">: </span><span class="s2">SecureContextOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets the session ticket keys. 
         * 
         * Changes to the ticket keys are effective only for future server connections. 
         * Existing or currently pending server connections will use the previous keys. 
         * 
         * See `Session Resumption` for more information. 
         * </span><span class="s1">@since </span><span class="s0">v3.0.0 
         * </span><span class="s1">@param </span><span class="s2">keys </span><span class="s0">A 48-byte buffer containing the session ticket keys. 
         */</span>
        <span class="s3">setTicketKeys(</span><span class="s2">keys</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">void</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* events.EventEmitter 
         * 1. tlsClientError 
         * 2. newSession 
         * 3. OCSPRequest 
         * 4. resumeSession 
         * 5. secureConnection 
         * 6. keylog 
         */</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'tlsClientError'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'newSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPRequest'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">certificate</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">issuer</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">resp</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resumeSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">null</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">addListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">symbol</span><span class="s3">, </span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[])</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'tlsClientError'</span><span class="s3">, </span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'newSession'</span><span class="s3">, </span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPRequest'</span><span class="s3">, </span><span class="s2">certificate</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">issuer</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">resp</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resumeSession'</span><span class="s3">, </span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">null</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnection'</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">emit(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'tlsClientError'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'newSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPRequest'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">certificate</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">issuer</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">resp</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resumeSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">null</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">on(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'tlsClientError'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'newSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPRequest'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">certificate</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">issuer</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">resp</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resumeSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">null</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">once(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'tlsClientError'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'newSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPRequest'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">certificate</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">issuer</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">resp</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resumeSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">null</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s1">...</span><span class="s2">args</span><span class="s1">: </span><span class="s2">any</span><span class="s3">[]) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'tlsClientError'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'newSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'OCSPRequest'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">certificate</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">issuer</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">resp</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'resumeSession'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">sessionId</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s6">callback</span><span class="s1">: </span><span class="s3">(</span><span class="s2">err</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">null</span><span class="s3">, </span><span class="s2">sessionData</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">null</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'secureConnection'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
        <span class="s3">prependOnceListener(</span><span class="s2">event</span><span class="s1">: </span><span class="s4">'keylog'</span><span class="s3">, </span><span class="s6">listener</span><span class="s1">: </span><span class="s3">(</span><span class="s2">line</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">tlsSocket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">since v0.11.3 Use `tls.TLSSocket` instead. 
     */</span>
    <span class="s1">interface </span><span class="s2">SecurePair </span><span class="s3">{</span>
        <span class="s3">encrypted</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">;</span>
        <span class="s3">cleartext</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">type </span><span class="s2">SecureVersion </span><span class="s1">= </span><span class="s4">'TLSv1.3' </span><span class="s1">| </span><span class="s4">'TLSv1.2' </span><span class="s1">| </span><span class="s4">'TLSv1.1' </span><span class="s1">| </span><span class="s4">'TLSv1'</span><span class="s3">;</span>
    <span class="s1">interface </span><span class="s2">SecureContextOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If set, this will be called when a client opens a connection using the ALPN extension. 
         * One argument will be passed to the callback: an object containing `servername` and `protocols` fields, 
         * respectively containing the server name from the SNI extension (if any) and an array of 
         * ALPN protocol name strings. The callback must return either one of the strings listed in `protocols`, 
         * which will be returned to the client as the selected ALPN protocol, or `undefined`, 
         * to reject the connection with a fatal alert. If a string is returned that does not match one of 
         * the client's ALPN protocols, an error will be thrown. 
         * This option cannot be used with the `ALPNProtocols` option, and setting both options will throw an error. 
         */</span>
        <span class="s3">ALPNCallback</span><span class="s1">?: </span><span class="s3">((</span><span class="s2">arg</span><span class="s1">: </span><span class="s3">{ servername</span><span class="s1">: </span><span class="s2">string</span><span class="s3">; protocols</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[] }) </span><span class="s1">=&gt; </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">) </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optionally override the trusted CA certificates. Default is to trust 
         * the well-known CAs curated by Mozilla. Mozilla's CAs are completely 
         * replaced when CAs are explicitly specified using this option. 
         */</span>
        <span class="s3">ca</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer</span><span class="s3">&gt; </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  Cert chains in PEM format. One cert chain should be provided per 
         *  private key. Each cert chain should consist of the PEM formatted 
         *  certificate for a provided private key, followed by the PEM 
         *  formatted intermediate certificates (if any), in order, and not 
         *  including the root CA (the root CA must be pre-known to the peer, 
         *  see ca). When providing multiple cert chains, they do not have to 
         *  be in the same order as their private keys in key. If the 
         *  intermediate certificates are not provided, the peer will not be 
         *  able to validate the certificate, and the handshake will fail. 
         */</span>
        <span class="s3">cert</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer</span><span class="s3">&gt; </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">*  Colon-separated list of supported signature algorithms. The list 
         *  can contain digest algorithms (SHA256, MD5 etc.), public key 
         *  algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g 
         *  'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512). 
         */</span>
        <span class="s3">sigalgs</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Cipher suite specification, replacing the default. For more 
         * information, see modifying the default cipher suite. Permitted 
         * ciphers can be obtained via tls.getCiphers(). Cipher names must be 
         * uppercased in order for OpenSSL to accept them. 
         */</span>
        <span class="s3">ciphers</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of an OpenSSL engine which can provide the client certificate. 
         */</span>
        <span class="s3">clientCertEngine</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* PEM formatted CRLs (Certificate Revocation Lists). 
         */</span>
        <span class="s3">crl</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer</span><span class="s3">&gt; </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* `'auto'` or custom Diffie-Hellman parameters, required for non-ECDHE perfect forward secrecy. 
         * If omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available. 
         * ECDHE-based perfect forward secrecy will still be available. 
         */</span>
        <span class="s3">dhparam</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A string describing a named curve or a colon separated list of curve 
         * NIDs or names, for example P-521:P-384:P-256, to use for ECDH key 
         * agreement. Set to auto to select the curve automatically. Use 
         * crypto.getCurves() to obtain a list of available curve names. On 
         * recent releases, openssl ecparam -list_curves will also display the 
         * name and description of each available elliptic curve. Default: 
         * tls.DEFAULT_ECDH_CURVE. 
         */</span>
        <span class="s3">ecdhCurve</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Attempt to use the server's cipher suite preferences instead of the 
         * client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be 
         * set in secureOptions 
         */</span>
        <span class="s3">honorCipherOrder</span><span class="s1">?: </span><span class="s2">boolean </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Private keys in PEM format. PEM allows the option of private keys 
         * being encrypted. Encrypted keys will be decrypted with 
         * options.passphrase. Multiple keys using different algorithms can be 
         * provided either as an array of unencrypted key strings or buffers, 
         * or an array of objects in the form {pem: &lt;string|buffer&gt;[, 
         * passphrase: &lt;string&gt;]}. The object form can only occur in an array. 
         * object.passphrase is optional. Encrypted keys will be decrypted with 
         * object.passphrase if provided, or options.passphrase if it is not. 
         */</span>
        <span class="s3">key</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">KeyObject</span><span class="s3">&gt; </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Name of an OpenSSL engine to get private key from. Should be used 
         * together with privateKeyIdentifier. 
         */</span>
        <span class="s3">privateKeyEngine</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Identifier of a private key managed by an OpenSSL engine. Should be 
         * used together with privateKeyEngine. Should not be set together with 
         * key, because both options define a private key in different ways. 
         */</span>
        <span class="s3">privateKeyIdentifier</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optionally set the maximum TLS version to allow. One 
         * of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the 
         * `secureProtocol` option, use one or the other. 
         * **Default:** `'TLSv1.3'`, unless changed using CLI options. Using 
         * `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to 
         * `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used. 
         */</span>
        <span class="s3">maxVersion</span><span class="s1">?: </span><span class="s2">SecureVersion </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optionally set the minimum TLS version to allow. One 
         * of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the 
         * `secureProtocol` option, use one or the other.  It is not recommended to use 
         * less than TLSv1.2, but it may be required for interoperability. 
         * **Default:** `'TLSv1.2'`, unless changed using CLI options. Using 
         * `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to 
         * `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to 
         * 'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used. 
         */</span>
        <span class="s3">minVersion</span><span class="s1">?: </span><span class="s2">SecureVersion </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shared passphrase used for a single private key and/or a PFX. 
         */</span>
        <span class="s3">passphrase</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* PFX or PKCS12 encoded private key and certificate chain. pfx is an 
         * alternative to providing key and cert individually. PFX is usually 
         * encrypted, if it is, passphrase will be used to decrypt it. Multiple 
         * PFX can be provided either as an array of unencrypted PFX buffers, 
         * or an array of objects in the form {buf: &lt;string|buffer&gt;[, 
         * passphrase: &lt;string&gt;]}. The object form can only occur in an array. 
         * object.passphrase is optional. Encrypted PFX will be decrypted with 
         * object.passphrase if provided, or options.passphrase if it is not. 
         */</span>
        <span class="s3">pfx</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">PxfObject</span><span class="s3">&gt; </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Optionally affect the OpenSSL protocol behavior, which is not 
         * usually necessary. This should be used carefully if at all! Value is 
         * a numeric bitmask of the SSL_OP_* options from OpenSSL Options 
         */</span>
        <span class="s3">secureOptions</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">; </span><span class="s0">// Value is a numeric bitmask of the `SSL_OP_*` options</span>
        <span class="s0">/**</span>
         <span class="s0">* Legacy mechanism to select the TLS protocol version to use, it does 
         * not support independent control of the minimum and maximum version, 
         * and does not support limiting the protocol to TLSv1.3. Use 
         * minVersion and maxVersion instead. The possible values are listed as 
         * SSL_METHODS, use the function names as strings. For example, use 
         * 'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow 
         * any TLS protocol version up to TLSv1.3. It is not recommended to use 
         * TLS versions less than 1.2, but it may be required for 
         * interoperability. Default: none, see minVersion. 
         */</span>
        <span class="s3">secureProtocol</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Opaque identifier used by servers to ensure session state is not 
         * shared between applications. Unused by clients. 
         */</span>
        <span class="s3">sessionIdContext</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* 48-bytes of cryptographically strong pseudo-random data. 
         * See Session Resumption for more information. 
         */</span>
        <span class="s3">ticketKeys</span><span class="s1">?: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of seconds after which a TLS session created by the 
         * server will no longer be resumable. See Session Resumption for more 
         * information. Default: 300. 
         */</span>
        <span class="s3">sessionTimeout</span><span class="s1">?: </span><span class="s2">number </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">interface </span><span class="s2">SecureContext </span><span class="s3">{</span>
        <span class="s3">context</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Verifies the certificate `cert` is issued to `hostname`. 
     * 
     * Returns [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object, populating it with `reason`, `host`, and `cert` on 
     * failure. On success, returns [undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type). 
     * 
     * This function is intended to be used in combination with the`checkServerIdentity` option that can be passed to </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">connect} </span><span class="s0">and as 
     * such operates on a `certificate object`. For other purposes, consider using `x509.checkHost()` instead. 
     * 
     * This function can be overwritten by providing an alternative function as the`options.checkServerIdentity` option that is passed to `tls.connect()`. The 
     * overwriting function can call `tls.checkServerIdentity()` of course, to augment 
     * the checks done with additional verification. 
     * 
     * This function is only called if the certificate passed all other checks, such as 
     * being issued by trusted CA (`options.ca`). 
     * 
     * Earlier versions of Node.js incorrectly accepted certificates for a given`hostname` if a matching `uniformResourceIdentifier` subject alternative name 
     * was present (see [CVE-2021-44531](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44531)). Applications that wish to accept`uniformResourceIdentifier` subject alternative names can use 
     * a custom`options.checkServerIdentity` function that implements the desired behavior. 
     * </span><span class="s1">@since </span><span class="s0">v0.8.4 
     * </span><span class="s1">@param </span><span class="s2">hostname </span><span class="s0">The host name or IP address to verify the certificate against. 
     * </span><span class="s1">@param </span><span class="s2">cert </span><span class="s0">A `certificate object` representing the peer's certificate. 
     */</span>
    <span class="s1">function </span><span class="s3">checkServerIdentity(</span><span class="s2">hostname</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">cert</span><span class="s1">: </span><span class="s2">PeerCertificate</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Error </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Server}</span><span class="s0">. The `secureConnectionListener`, if provided, is 
     * automatically set as a listener for the `'secureConnection'` event. 
     * 
     * The `ticketKeys` options is automatically shared between `node:cluster` module 
     * workers. 
     * 
     * The following illustrates a simple echo server: 
     * 
     * ```js 
     * const tls = require('node:tls'); 
     * const fs = require('node:fs'); 
     * 
     * const options = { 
     *   key: fs.readFileSync('server-key.pem'), 
     *   cert: fs.readFileSync('server-cert.pem'), 
     * 
     *   // This is necessary only if using client certificate authentication. 
     *   requestCert: true, 
     * 
     *   // This is necessary only if the client uses a self-signed certificate. 
     *   ca: [ fs.readFileSync('client-cert.pem') ], 
     * }; 
     * 
     * const server = tls.createServer(options, (socket) =&gt; { 
     *   console.log('server connected', 
     *               socket.authorized ? 'authorized' : 'unauthorized'); 
     *   socket.write('welcome!\n'); 
     *   socket.setEncoding('utf8'); 
     *   socket.pipe(socket); 
     * }); 
     * server.listen(8000, () =&gt; { 
     *   console.log('server bound'); 
     * }); 
     * ``` 
     * 
     * The server can be tested by connecting to it using the example client from </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">connect}</span><span class="s0">. 
     * </span><span class="s1">@since </span><span class="s0">v0.3.2 
     */</span>
    <span class="s1">function </span><span class="s3">createServer(</span><span class="s6">secureConnectionListener</span><span class="s1">?: </span><span class="s3">(</span><span class="s2">socket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Server</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">createServer(</span><span class="s2">options</span><span class="s1">: </span><span class="s2">TlsOptions</span><span class="s3">, </span><span class="s6">secureConnectionListener</span><span class="s1">?: </span><span class="s3">(</span><span class="s2">socket</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">) </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Server</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `callback` function, if specified, will be added as a listener for the `'secureConnect'` event. 
     * 
     * `tls.connect()` returns a </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">TLSSocket} </span><span class="s0">object. 
     * 
     * Unlike the `https` API, `tls.connect()` does not enable the 
     * SNI (Server Name Indication) extension by default, which may cause some 
     * servers to return an incorrect certificate or reject the connection 
     * altogether. To enable SNI, set the `servername` option in addition 
     * to `host`. 
     * 
     * The following illustrates a client for the echo server example from </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createServer}</span><span class="s0">: 
     * 
     * ```js 
     * // Assumes an echo server that is listening on port 8000. 
     * const tls = require('node:tls'); 
     * const fs = require('node:fs'); 
     * 
     * const options = { 
     *   // Necessary only if the server requires client certificate authentication. 
     *   key: fs.readFileSync('client-key.pem'), 
     *   cert: fs.readFileSync('client-cert.pem'), 
     * 
     *   // Necessary only if the server uses a self-signed certificate. 
     *   ca: [ fs.readFileSync('server-cert.pem') ], 
     * 
     *   // Necessary only if the server's cert isn't for &quot;localhost&quot;. 
     *   checkServerIdentity: () =&gt; { return null; }, 
     * }; 
     * 
     * const socket = tls.connect(8000, options, () =&gt; { 
     *   console.log('client connected', 
     *               socket.authorized ? 'authorized' : 'unauthorized'); 
     *   process.stdin.pipe(socket); 
     *   process.stdin.resume(); 
     * }); 
     * socket.setEncoding('utf8'); 
     * socket.on('data', (data) =&gt; { 
     *   console.log(data); 
     * }); 
     * socket.on('end', () =&gt; { 
     *   console.log('server ends connection'); 
     * }); 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v0.11.3 
     */</span>
    <span class="s1">function </span><span class="s3">connect(</span><span class="s2">options</span><span class="s1">: </span><span class="s2">ConnectionOptions</span><span class="s3">, </span><span class="s6">secureConnectListener</span><span class="s1">?: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">connect(</span><span class="s2">port</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">host</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">ConnectionOptions</span><span class="s3">, </span><span class="s6">secureConnectListener</span><span class="s1">?: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">;</span>
    <span class="s1">function </span><span class="s3">connect(</span><span class="s2">port</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">ConnectionOptions</span><span class="s3">, </span><span class="s6">secureConnectListener</span><span class="s1">?: </span><span class="s3">() </span><span class="s1">=&gt; </span><span class="s2">void</span><span class="s3">)</span><span class="s1">: </span><span class="s2">TLSSocket</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new secure pair object with two streams, one of which reads and writes 
     * the encrypted data and the other of which reads and writes the cleartext data. 
     * Generally, the encrypted stream is piped to/from an incoming encrypted data 
     * stream and the cleartext one is used as a replacement for the initial encrypted 
     * stream. 
     * 
     * `tls.createSecurePair()` returns a `tls.SecurePair` object with `cleartext` and`encrypted` stream properties. 
     * 
     * Using `cleartext` has the same API as </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">TLSSocket}</span><span class="s0">. 
     * 
     * The `tls.createSecurePair()` method is now deprecated in favor of`tls.TLSSocket()`. For example, the code: 
     * 
     * ```js 
     * pair = tls.createSecurePair(// ... ); 
     * pair.encrypted.pipe(socket); 
     * socket.pipe(pair.encrypted); 
     * ``` 
     * 
     * can be replaced by: 
     * 
     * ```js 
     * secureSocket = tls.TLSSocket(socket, options); 
     * ``` 
     * 
     * where `secureSocket` has the same API as `pair.cleartext`. 
     * </span><span class="s1">@since </span><span class="s0">v0.3.2 
     * </span><span class="s1">@deprecated </span><span class="s0">Since v0.11.3 - Use </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">TLSSocket} </span><span class="s0">instead. 
     * </span><span class="s1">@param </span><span class="s2">context </span><span class="s0">A secure context object as returned by `tls.createSecureContext()` 
     * </span><span class="s1">@param </span><span class="s2">isServer </span><span class="s0">`true` to specify that this TLS connection should be opened as a server. 
     * </span><span class="s1">@param </span><span class="s2">requestCert </span><span class="s0">`true` to specify whether a server should request a certificate from a connecting client. Only applies when `isServer` is `true`. 
     * </span><span class="s1">@param </span><span class="s2">rejectUnauthorized </span><span class="s0">If not `false` a server automatically reject clients with invalid certificates. Only applies when `isServer` is `true`. 
     */</span>
    <span class="s1">function </span><span class="s3">createSecurePair(</span><span class="s2">context</span><span class="s1">?: </span><span class="s2">SecureContext</span><span class="s3">, </span><span class="s2">isServer</span><span class="s1">?: </span><span class="s2">boolean</span><span class="s3">, </span><span class="s2">requestCert</span><span class="s1">?: </span><span class="s2">boolean</span><span class="s3">, </span><span class="s2">rejectUnauthorized</span><span class="s1">?: </span><span class="s2">boolean</span><span class="s3">)</span><span class="s1">: </span><span class="s2">SecurePair</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createServer} </span><span class="s0">sets the default value of the `honorCipherOrder` option 
     * to `true`, other APIs that create secure contexts leave it unset. 
     * 
     * </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createServer} </span><span class="s0">uses a 128 bit truncated SHA1 hash value generated 
     * from `process.argv` as the default value of the `sessionIdContext` option, other 
     * APIs that create secure contexts have no default value. 
     * 
     * The `tls.createSecureContext()` method creates a `SecureContext` object. It is 
     * usable as an argument to several `tls` APIs, such as `server.addContext()`, 
     * but has no public methods. The </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Server} </span><span class="s0">constructor and the </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createServer} </span><span class="s0">method do not support the `secureContext` option. 
     * 
     * A key is _required_ for ciphers that use certificates. Either `key` or`pfx` can be used to provide it. 
     * 
     * If the `ca` option is not given, then Node.js will default to using [Mozilla's publicly trusted list of 
     * CAs](https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt). 
     * 
     * Custom DHE parameters are discouraged in favor of the new `dhparam: 'auto'`option. When set to `'auto'`, well-known DHE parameters of sufficient strength 
     * will be selected automatically. Otherwise, if necessary, `openssl dhparam` can 
     * be used to create custom parameters. The key length must be greater than or 
     * equal to 1024 bits or else an error will be thrown. Although 1024 bits is 
     * permissible, use 2048 bits or larger for stronger security. 
     * </span><span class="s1">@since </span><span class="s0">v0.11.13 
     */</span>
    <span class="s1">function </span><span class="s3">createSecureContext(</span><span class="s2">options</span><span class="s1">?: </span><span class="s2">SecureContextOptions</span><span class="s3">)</span><span class="s1">: </span><span class="s2">SecureContext</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns an array with the names of the supported TLS ciphers. The names are 
     * lower-case for historical reasons, but must be uppercased to be used in 
     * the `ciphers` option of </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">createSecureContext}</span><span class="s0">. 
     * 
     * Not all supported ciphers are enabled by default. See `Modifying the default TLS cipher suite`. 
     * 
     * Cipher names that start with `'tls_'` are for TLSv1.3, all the others are for 
     * TLSv1.2 and below. 
     * 
     * ```js 
     * console.log(tls.getCiphers()); // ['aes128-gcm-sha256', 'aes128-sha', ...] 
     * ``` 
     * </span><span class="s1">@since </span><span class="s0">v0.10.2 
     */</span>
    <span class="s1">function </span><span class="s3">getCiphers()</span><span class="s1">: </span><span class="s2">string</span><span class="s3">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The default curve name to use for ECDH key agreement in a tls server. 
     * The default value is 'auto'. See tls.createSecureContext() for further 
     * information. 
     */</span>
    <span class="s1">let </span><span class="s3">DEFAULT_ECDH_CURVE</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The default value of the maxVersion option of 
     * tls.createSecureContext(). It can be assigned any of the supported TLS 
     * protocol versions, 'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default: 
     * 'TLSv1.3', unless changed using CLI options. Using --tls-max-v1.2 sets 
     * the default to 'TLSv1.2'. Using --tls-max-v1.3 sets the default to 
     * 'TLSv1.3'. If multiple of the options are provided, the highest maximum 
     * is used. 
     */</span>
    <span class="s1">let </span><span class="s3">DEFAULT_MAX_VERSION</span><span class="s1">: </span><span class="s2">SecureVersion</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The default value of the minVersion option of tls.createSecureContext(). 
     * It can be assigned any of the supported TLS protocol versions, 
     * 'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default: 'TLSv1.2', unless 
     * changed using CLI options. Using --tls-min-v1.0 sets the default to 
     * 'TLSv1'. Using --tls-min-v1.1 sets the default to 'TLSv1.1'. Using 
     * --tls-min-v1.3 sets the default to 'TLSv1.3'. If multiple of the options 
     * are provided, the lowest minimum is used. 
     */</span>
    <span class="s1">let </span><span class="s3">DEFAULT_MIN_VERSION</span><span class="s1">: </span><span class="s2">SecureVersion</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The default value of the ciphers option of tls.createSecureContext(). 
     * It can be assigned any of the supported OpenSSL ciphers. 
     * Defaults to the content of crypto.constants.defaultCoreCipherList, unless 
     * changed using CLI options using --tls-default-ciphers. 
     */</span>
    <span class="s1">let </span><span class="s3">DEFAULT_CIPHERS</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* An immutable array of strings representing the root certificates (in PEM 
     * format) used for verifying peer certificates. This is the default value 
     * of the ca option to tls.createSecureContext(). 
     */</span>
    <span class="s1">const </span><span class="s3">rootCertificates</span><span class="s1">: </span><span class="s2">ReadonlyArray</span><span class="s3">&lt;</span><span class="s2">string</span><span class="s3">&gt;;</span>
<span class="s3">}</span>
<span class="s1">declare module </span><span class="s4">'node:tls' </span><span class="s3">{</span>
    <span class="s1">export </span><span class="s5">* </span><span class="s1">from </span><span class="s4">'tls'</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>
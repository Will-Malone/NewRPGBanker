<html>
<head>
<title>buffer.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb; font-style: italic;}
.s6 { color: #9876aa; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
buffer.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* `Buffer` objects are used to represent a fixed-length sequence of bytes. Many 
 * Node.js APIs support `Buffer`s. 
 * 
 * The `Buffer` class is a subclass of JavaScript's [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) class and 
 * extends it with methods that cover additional use cases. Node.js APIs accept 
 * plain [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) s wherever `Buffer`s are supported as well. 
 * 
 * While the `Buffer` class is available within the global scope, it is still 
 * recommended to explicitly reference it via an import or require statement. 
 * 
 * ```js 
 * import { Buffer } from 'node:buffer'; 
 * 
 * // Creates a zero-filled Buffer of length 10. 
 * const buf1 = Buffer.alloc(10); 
 * 
 * // Creates a Buffer of length 10, 
 * // filled with bytes which all have the value `1`. 
 * const buf2 = Buffer.alloc(10, 1); 
 * 
 * // Creates an uninitialized buffer of length 10. 
 * // This is faster than calling Buffer.alloc() but the returned 
 * // Buffer instance might contain old data that needs to be 
 * // overwritten using fill(), write(), or other functions that fill the Buffer's 
 * // contents. 
 * const buf3 = Buffer.allocUnsafe(10); 
 * 
 * // Creates a Buffer containing the bytes [1, 2, 3]. 
 * const buf4 = Buffer.from([1, 2, 3]); 
 * 
 * // Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries 
 * // are all truncated using `(value &amp;#x26; 255)` to fit into the range 0–255. 
 * const buf5 = Buffer.from([257, 257.5, -255, '1']); 
 * 
 * // Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést': 
 * // [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation) 
 * // [116, 195, 169, 115, 116] (in decimal notation) 
 * const buf6 = Buffer.from('tést'); 
 * 
 * // Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74]. 
 * const buf7 = Buffer.from('tést', 'latin1'); 
 * ``` 
 * </span><span class="s1">@see </span><span class="s2">[source](https:</span><span class="s0">//github.com/nodejs/node/blob/v20.2.0/lib/buffer.js) 
 */</span>
<span class="s1">declare module </span><span class="s4">'buffer' </span><span class="s3">{</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">BinaryLike </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'node:crypto'</span><span class="s3">;</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">ReadableStream </span><span class="s1">as </span><span class="s2">WebReadableStream </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'node:stream/web'</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function returns `true` if `input` contains only valid UTF-8-encoded data, 
     * including the case in which `input` is empty. 
     * 
     * Throws if the `input` is a detached array buffer. 
     * </span><span class="s1">@since </span><span class="s0">v19.4.0, v18.14.0 
     * </span><span class="s1">@param </span><span class="s2">input </span><span class="s0">The input to validate. 
     */</span>
    <span class="s1">export function </span><span class="s3">isUtf8(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">ArrayBuffer </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">TypedArray</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function returns `true` if `input` contains only valid ASCII-encoded data, 
     * including the case in which `input` is empty. 
     * 
     * Throws if the `input` is a detached array buffer. 
     * </span><span class="s1">@since </span><span class="s0">v19.6.0, v18.15.0 
     * </span><span class="s1">@param </span><span class="s2">input </span><span class="s0">The input to validate. 
     */</span>
    <span class="s1">export function </span><span class="s3">isAscii(</span><span class="s2">input</span><span class="s1">: </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">ArrayBuffer </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">TypedArray</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
    <span class="s1">export const </span><span class="s3">INSPECT_MAX_BYTES</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s1">export const </span><span class="s3">kMaxLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s1">export const </span><span class="s3">kStringMaxLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s1">export const </span><span class="s3">constants</span><span class="s1">: </span><span class="s3">{</span>
        <span class="s3">MAX_LENGTH</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">MAX_STRING_LENGTH</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">};</span>
    <span class="s1">export type </span><span class="s2">TranscodeEncoding </span><span class="s1">= </span><span class="s4">'ascii' </span><span class="s1">| </span><span class="s4">'utf8' </span><span class="s1">| </span><span class="s4">'utf16le' </span><span class="s1">| </span><span class="s4">'ucs2' </span><span class="s1">| </span><span class="s4">'latin1' </span><span class="s1">| </span><span class="s4">'binary'</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Re-encodes the given `Buffer` or `Uint8Array` instance from one character 
     * encoding to another. Returns a new `Buffer` instance. 
     * 
     * Throws if the `fromEnc` or `toEnc` specify invalid character encodings or if 
     * conversion from `fromEnc` to `toEnc` is not permitted. 
     * 
     * Encodings supported by `buffer.transcode()` are: `'ascii'`, `'utf8'`,`'utf16le'`, `'ucs2'`, `'latin1'`, and `'binary'`. 
     * 
     * The transcoding process will use substitution characters if a given byte 
     * sequence cannot be adequately represented in the target encoding. For instance: 
     * 
     * ```js 
     * import { Buffer, transcode } from 'node:buffer'; 
     * 
     * const newBuf = transcode(Buffer.from('€'), 'utf8', 'ascii'); 
     * console.log(newBuf.toString('ascii')); 
     * // Prints: '?' 
     * ``` 
     * 
     * Because the Euro (`€`) sign is not representable in US-ASCII, it is replaced 
     * with `?` in the transcoded `Buffer`. 
     * </span><span class="s1">@since </span><span class="s0">v7.1.0 
     * </span><span class="s1">@param </span><span class="s2">source </span><span class="s0">A `Buffer` or `Uint8Array` instance. 
     * </span><span class="s1">@param </span><span class="s2">fromEnc </span><span class="s0">The current encoding. 
     * </span><span class="s1">@param </span><span class="s2">toEnc </span><span class="s0">To target encoding. 
     */</span>
    <span class="s1">export function </span><span class="s3">transcode(</span><span class="s2">source</span><span class="s1">: </span><span class="s2">Uint8Array</span><span class="s3">, </span><span class="s2">fromEnc</span><span class="s1">: </span><span class="s2">TranscodeEncoding</span><span class="s3">, </span><span class="s2">toEnc</span><span class="s1">: </span><span class="s2">TranscodeEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
    <span class="s1">export const </span><span class="s3">SlowBuffer</span><span class="s1">: </span><span class="s3">{</span>
        <span class="s0">/** </span><span class="s1">@deprecated </span><span class="s0">since v6.0.0, use `Buffer.allocUnsafeSlow()` */</span>
        <span class="s1">new </span><span class="s3">(</span><span class="s2">size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
        <span class="s3">prototype</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
    <span class="s3">};</span>
    <span class="s0">/**</span>
     <span class="s0">* Resolves a `'blob:nodedata:...'` an associated `Blob` object registered using 
     * a prior call to `URL.createObjectURL()`. 
     * </span><span class="s1">@since </span><span class="s0">v16.7.0 
     * </span><span class="s1">@experimental</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s2">id </span><span class="s0">A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`. 
     */</span>
    <span class="s1">export function </span><span class="s3">resolveObjectURL(</span><span class="s2">id</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Blob </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s1">export </span><span class="s3">{ </span><span class="s2">Buffer </span><span class="s3">};</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s1">export interface </span><span class="s2">BlobOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s2">'utf8'</span>
         <span class="s0">*/</span>
        <span class="s3">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The Blob content-type. The intent is for `type` to convey 
         * the MIME media type of the data, however no validation of the type format 
         * is performed. 
         */</span>
        <span class="s3">type</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">undefined</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) encapsulates immutable, raw data that can be safely shared across 
     * multiple worker threads. 
     * </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0 
     */</span>
    <span class="s1">export class </span><span class="s2">Blob </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The total size of the `Blob` in bytes. 
         * </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The content-type of the `Blob`. 
         * </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">type</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates a new `Blob` object containing a concatenation of the given sources. 
         * 
         * {ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied into 
         * the 'Blob' and can therefore be safely modified after the 'Blob' is created. 
         * 
         * String sources are also copied into the `Blob`. 
         */</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">sources</span><span class="s1">: </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">BinaryLike </span><span class="s1">| </span><span class="s2">Blob</span><span class="s3">&gt;, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">BlobOptions</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a promise that fulfills with an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing a copy of 
         * the `Blob` data. 
         * </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0 
         */</span>
        <span class="s3">arrayBuffer()</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">ArrayBuffer</span><span class="s3">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Creates and returns a new `Blob` containing a subset of this `Blob` objects 
         * data. The original `Blob` is not altered. 
         * </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0 
         * </span><span class="s1">@param </span><span class="s2">start </span><span class="s0">The starting index. 
         * </span><span class="s1">@param </span><span class="s2">end </span><span class="s0">The ending index. 
         * </span><span class="s1">@param </span><span class="s2">type </span><span class="s0">The content-type for the new `Blob` 
         */</span>
        <span class="s3">slice(</span><span class="s2">start</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">end</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">type</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Blob</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a promise that fulfills with the contents of the `Blob` decoded as a 
         * UTF-8 string. 
         * </span><span class="s1">@since </span><span class="s0">v15.7.0, v14.18.0 
         */</span>
        <span class="s3">text()</span><span class="s1">: </span><span class="s2">Promise</span><span class="s3">&lt;</span><span class="s2">string</span><span class="s3">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a new `ReadableStream` that allows the content of the `Blob` to be read. 
         * </span><span class="s1">@since </span><span class="s0">v16.7.0 
         */</span>
        <span class="s3">stream()</span><span class="s1">: </span><span class="s2">WebReadableStream</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">export interface </span><span class="s2">FileOptions </span><span class="s3">{</span>
        <span class="s0">/**</span>
         <span class="s0">* One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be 
         * converted to the platform native line-ending as specified by `require('node:os').EOL`. 
         */</span>
        <span class="s3">endings</span><span class="s1">?: </span><span class="s4">'native' </span><span class="s1">| </span><span class="s4">'transparent'</span><span class="s3">;</span>
        <span class="s0">/** The File content-type. */</span>
        <span class="s3">type</span><span class="s1">?: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/** The last modified date of the file. `Default`: Date.now(). */</span>
        <span class="s3">lastModified</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) provides information about files. 
     * </span><span class="s1">@since </span><span class="s0">v19.2.0, v18.13.0 
     */</span>
    <span class="s1">export class </span><span class="s2">File </span><span class="s1">extends </span><span class="s2">Blob </span><span class="s3">{</span>
        <span class="s1">constructor</span><span class="s3">(</span><span class="s2">sources</span><span class="s1">: </span><span class="s2">Array</span><span class="s3">&lt;</span><span class="s2">BinaryLike </span><span class="s1">| </span><span class="s2">Blob</span><span class="s3">&gt;, </span><span class="s2">fileName</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">options</span><span class="s1">?: </span><span class="s2">FileOptions</span><span class="s3">);</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the `File`. 
         * </span><span class="s1">@since </span><span class="s0">v19.2.0, v18.13.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">name</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The last modified date of the `File`. 
         * </span><span class="s1">@since </span><span class="s0">v19.2.0, v18.13.0 
         */</span>
        <span class="s1">readonly </span><span class="s3">lastModified</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s1">export import </span><span class="s2">atob </span><span class="s1">= </span><span class="s2">globalThis</span><span class="s3">.</span><span class="s2">atob</span><span class="s3">;</span>
    <span class="s1">export import </span><span class="s2">btoa </span><span class="s1">= </span><span class="s2">globalThis</span><span class="s3">.</span><span class="s2">btoa</span><span class="s3">;</span>
    <span class="s1">import </span><span class="s3">{ </span><span class="s2">Blob </span><span class="s1">as </span><span class="s2">NodeBlob </span><span class="s3">} </span><span class="s1">from </span><span class="s4">'buffer'</span><span class="s3">;</span>
    <span class="s0">// This conditional type will be the existing global Blob in a browser, or</span>
    <span class="s0">// the copy below in a Node environment.</span>
    <span class="s1">type </span><span class="s2">__Blob </span><span class="s1">= typeof </span><span class="s2">globalThis extends </span><span class="s3">{ onmessage</span><span class="s1">: </span><span class="s2">any</span><span class="s3">; Blob</span><span class="s1">: infer </span><span class="s2">T </span><span class="s3">} </span><span class="s1">? </span><span class="s2">T </span><span class="s1">: </span><span class="s2">NodeBlob</span><span class="s3">;</span>
    <span class="s2">global </span><span class="s3">{</span>
        <span class="s1">namespace </span><span class="s2">NodeJS </span><span class="s3">{</span>
            <span class="s1">export </span><span class="s3">{ </span><span class="s2">BufferEncoding </span><span class="s3">};</span>
        <span class="s3">}</span>
        <span class="s0">// Buffer class</span>
        <span class="s1">type </span><span class="s2">BufferEncoding </span><span class="s1">=</span>
            <span class="s1">| </span><span class="s4">'ascii'</span>
            <span class="s1">| </span><span class="s4">'utf8'</span>
            <span class="s1">| </span><span class="s4">'utf-8'</span>
            <span class="s1">| </span><span class="s4">'utf16le'</span>
            <span class="s1">| </span><span class="s4">'ucs2'</span>
            <span class="s1">| </span><span class="s4">'ucs-2'</span>
            <span class="s1">| </span><span class="s4">'base64'</span>
            <span class="s1">| </span><span class="s4">'base64url'</span>
            <span class="s1">| </span><span class="s4">'latin1'</span>
            <span class="s1">| </span><span class="s4">'binary'</span>
            <span class="s1">| </span><span class="s4">'hex'</span><span class="s3">;</span>
        <span class="s1">type </span><span class="s2">WithImplicitCoercion</span><span class="s3">&lt;</span><span class="s2">T</span><span class="s3">&gt; </span><span class="s1">=</span>
            <span class="s1">| </span><span class="s2">T</span>
            <span class="s1">| </span><span class="s3">{</span>
                  <span class="s3">valueOf()</span><span class="s1">: </span><span class="s2">T</span><span class="s3">;</span>
              <span class="s3">};</span>
        <span class="s0">/**</span>
         <span class="s0">* Raw data is stored in instances of the Buffer class. 
         * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized. 
         * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'base64url'|'binary'(deprecated)|'hex' 
         */</span>
        <span class="s1">interface </span><span class="s2">BufferConstructor </span><span class="s3">{</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new buffer containing the given {str}. 
             * 
             * </span><span class="s1">@param </span><span class="s2">str </span><span class="s0">String to store in buffer. 
             * </span><span class="s1">@param </span><span class="s2">encoding </span><span class="s0">encoding to use, optional.  Default is 'utf8' 
             * </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(string[, encoding])` instead. 
             */</span>
            <span class="s1">new </span><span class="s3">(</span><span class="s2">str</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new buffer of {size} octets. 
             * 
             * </span><span class="s1">@param </span><span class="s2">size </span><span class="s0">count of octets to allocate. 
             * </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`). 
             */</span>
            <span class="s1">new </span><span class="s3">(</span><span class="s2">size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new buffer containing the given {array} of octets. 
             * 
             * </span><span class="s1">@param </span><span class="s2">array </span><span class="s0">The octets to store. 
             * </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(array)` instead. 
             */</span>
            <span class="s1">new </span><span class="s3">(</span><span class="s2">array</span><span class="s1">: </span><span class="s2">Uint8Array</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Produces a Buffer backed by the same allocated memory as 
             * the given {ArrayBuffer}/{SharedArrayBuffer}. 
             * 
             * 
             * </span><span class="s1">@param </span><span class="s2">arrayBuffer </span><span class="s0">The ArrayBuffer with which to share memory. 
             * </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead. 
             */</span>
            <span class="s1">new </span><span class="s3">(</span><span class="s2">arrayBuffer</span><span class="s1">: </span><span class="s2">ArrayBuffer </span><span class="s1">| </span><span class="s2">SharedArrayBuffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new buffer containing the given {array} of octets. 
             * 
             * </span><span class="s1">@param </span><span class="s2">array </span><span class="s0">The octets to store. 
             * </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(array)` instead. 
             */</span>
            <span class="s1">new </span><span class="s3">(</span><span class="s2">array</span><span class="s1">: </span><span class="s2">ReadonlyArray</span><span class="s3">&lt;</span><span class="s2">any</span><span class="s3">&gt;)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Copies the passed {buffer} data onto a new {Buffer} instance. 
             * 
             * </span><span class="s1">@param </span><span class="s2">buffer </span><span class="s0">The buffer to copy. 
             * </span><span class="s1">@deprecated </span><span class="s0">since v10.0.0 - Use `Buffer.from(buffer)` instead. 
             */</span>
            <span class="s1">new </span><span class="s3">(</span><span class="s2">buffer</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new `Buffer` using an `array` of bytes in the range `0` – `255`. 
             * Array entries outside that range will be truncated to fit into it. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'. 
             * const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]); 
             * ``` 
             * 
             * If `array` is an `Array`\-like object (that is, one with a `length` property of 
             * type `number`), it is treated as if it is an array, unless it is a `Buffer` or 
             * a `Uint8Array`. This means all other `TypedArray` variants get treated as an`Array`. To create a `Buffer` from the bytes backing a `TypedArray`, use `Buffer.copyBytesFrom()`. 
             * 
             * A `TypeError` will be thrown if `array` is not an `Array` or another type 
             * appropriate for `Buffer.from()` variants. 
             * 
             * `Buffer.from(array)` and `Buffer.from(string)` may also use the internal`Buffer` pool like `Buffer.allocUnsafe()` does. 
             * </span><span class="s1">@since </span><span class="s0">v5.10.0 
             */</span>
            <span class="s3">from(</span>
                <span class="s2">arrayBuffer</span><span class="s1">: </span><span class="s2">WithImplicitCoercion</span><span class="s3">&lt;</span><span class="s2">ArrayBuffer </span><span class="s1">| </span><span class="s2">SharedArrayBuffer</span><span class="s3">&gt;,</span>
                <span class="s2">byteOffset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">,</span>
                <span class="s2">length</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">,</span>
            <span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates a new Buffer using the passed {data} 
             * </span><span class="s1">@param </span><span class="s2">data </span><span class="s0">data to create a new Buffer 
             */</span>
            <span class="s3">from(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">Uint8Array </span><span class="s1">| </span><span class="s2">ReadonlyArray</span><span class="s3">&lt;</span><span class="s2">number</span><span class="s3">&gt;)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s3">from(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">WithImplicitCoercion</span><span class="s3">&lt;</span><span class="s2">Uint8Array </span><span class="s1">| </span><span class="s2">ReadonlyArray</span><span class="s3">&lt;</span><span class="s2">number</span><span class="s3">&gt; </span><span class="s1">| </span><span class="s2">string</span><span class="s3">&gt;)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates a new Buffer containing the given JavaScript string {str}. 
             * If provided, the {encoding} parameter identifies the character encoding. 
             * If not provided, {encoding} defaults to 'utf8'. 
             */</span>
            <span class="s3">from(</span>
                <span class="s2">str</span><span class="s1">:</span>
                    <span class="s1">| </span><span class="s2">WithImplicitCoercion</span><span class="s3">&lt;</span><span class="s2">string</span><span class="s3">&gt;</span>
                    <span class="s1">| </span><span class="s3">{</span>
                          <span class="s3">[</span><span class="s2">Symbol</span><span class="s3">.</span><span class="s2">toPrimitive</span><span class="s3">](</span><span class="s2">hint</span><span class="s1">: </span><span class="s4">'string'</span><span class="s3">)</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
                      <span class="s3">},</span>
                <span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">,</span>
            <span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates a new Buffer using the passed {data} 
             * </span><span class="s1">@param </span><span class="s2">values </span><span class="s0">to create a new Buffer 
             */</span>
            <span class="s3">of(</span><span class="s1">...</span><span class="s2">items</span><span class="s1">: </span><span class="s2">number</span><span class="s3">[])</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns `true` if `obj` is a `Buffer`, `false` otherwise. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * Buffer.isBuffer(Buffer.alloc(10)); // true 
             * Buffer.isBuffer(Buffer.from('foo')); // true 
             * Buffer.isBuffer('a string'); // false 
             * Buffer.isBuffer([]); // false 
             * Buffer.isBuffer(new Uint8Array(1024)); // false 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.1.101 
             */</span>
            <span class="s3">isBuffer(</span><span class="s2">obj</span><span class="s1">: </span><span class="s2">any</span><span class="s3">)</span><span class="s1">: </span><span class="s2">obj </span><span class="s1">is </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns `true` if `encoding` is the name of a supported character encoding, 
             * or `false` otherwise. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * console.log(Buffer.isEncoding('utf8')); 
             * // Prints: true 
             * 
             * console.log(Buffer.isEncoding('hex')); 
             * // Prints: true 
             * 
             * console.log(Buffer.isEncoding('utf/8')); 
             * // Prints: false 
             * 
             * console.log(Buffer.isEncoding('')); 
             * // Prints: false 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.9.1 
             * </span><span class="s1">@param </span><span class="s2">encoding </span><span class="s0">A character encoding name to check. 
             */</span>
            <span class="s3">isEncoding(</span><span class="s2">encoding</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">encoding </span><span class="s1">is </span><span class="s2">BufferEncoding</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns the byte length of a string when encoded using `encoding`. 
             * This is not the same as [`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length), which does not account 
             * for the encoding that is used to convert the string into bytes. 
             * 
             * For `'base64'`, `'base64url'`, and `'hex'`, this function assumes valid input. 
             * For strings that contain non-base64/hex-encoded data (e.g. whitespace), the 
             * return value might be greater than the length of a `Buffer` created from the 
             * string. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const str = '\u00bd + \u00bc = \u00be'; 
             * 
             * console.log(`${str}: ${str.length} characters, ` + 
             *             `${Buffer.byteLength(str, 'utf8')} bytes`); 
             * // Prints: ½ + ¼ = ¾: 9 characters, 12 bytes 
             * ``` 
             * 
             * When `string` is a 
             * `Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/- 
             * Reference/Global_Objects/TypedArray)/[`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)/[`SharedArrayBuffer`](https://develop- 
             * er.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), the byte length as reported by `.byteLength`is returned. 
             * </span><span class="s1">@since </span><span class="s0">v0.1.90 
             * </span><span class="s1">@param </span><span class="s2">string </span><span class="s0">A value to calculate the length of. 
             * </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `string` is a string, this is its encoding. 
             * </span><span class="s1">@return </span><span class="s0">The number of bytes contained within `string`. 
             */</span>
            <span class="s3">byteLength(</span>
                <span class="s2">string</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">ArrayBufferView </span><span class="s1">| </span><span class="s2">ArrayBuffer </span><span class="s1">| </span><span class="s2">SharedArrayBuffer</span><span class="s3">,</span>
                <span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">,</span>
            <span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns a new `Buffer` which is the result of concatenating all the `Buffer`instances in the `list` together. 
             * 
             * If the list has no items, or if the `totalLength` is 0, then a new zero-length`Buffer` is returned. 
             * 
             * If `totalLength` is not provided, it is calculated from the `Buffer` instances 
             * in `list` by adding their lengths. 
             * 
             * If `totalLength` is provided, it is coerced to an unsigned integer. If the 
             * combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is 
             * truncated to `totalLength`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Create a single `Buffer` from a list of three `Buffer` instances. 
             * 
             * const buf1 = Buffer.alloc(10); 
             * const buf2 = Buffer.alloc(14); 
             * const buf3 = Buffer.alloc(18); 
             * const totalLength = buf1.length + buf2.length + buf3.length; 
             * 
             * console.log(totalLength); 
             * // Prints: 42 
             * 
             * const bufA = Buffer.concat([buf1, buf2, buf3], totalLength); 
             * 
             * console.log(bufA); 
             * // Prints: &lt;Buffer 00 00 00 00 ...&gt; 
             * console.log(bufA.length); 
             * // Prints: 42 
             * ``` 
             * 
             * `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does. 
             * </span><span class="s1">@since </span><span class="s0">v0.7.11 
             * </span><span class="s1">@param </span><span class="s2">list </span><span class="s0">List of `Buffer` or </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Uint8Array} </span><span class="s0">instances to concatenate. 
             * </span><span class="s1">@param </span><span class="s2">totalLength </span><span class="s0">Total length of the `Buffer` instances in `list` when concatenated. 
             */</span>
            <span class="s3">concat(</span><span class="s2">list</span><span class="s1">: </span><span class="s2">ReadonlyArray</span><span class="s3">&lt;</span><span class="s2">Uint8Array</span><span class="s3">&gt;, </span><span class="s2">totalLength</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Copies the underlying memory of `view` into a new `Buffer`. 
             * 
             * ```js 
             * const u16 = new Uint16Array([0, 0xffff]); 
             * const buf = Buffer.copyBytesFrom(u16, 1, 1); 
             * u16[1] = 0; 
             * console.log(buf.length); // 2 
             * console.log(buf[0]); // 255 
             * console.log(buf[1]); // 255 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v19.8.0 
             * </span><span class="s1">@param </span><span class="s2">view </span><span class="s0">The {TypedArray} to copy. 
             * </span><span class="s1">@param </span><span class="s0">[offset=': 0'] The starting offset within `view`. 
             * </span><span class="s1">@param </span><span class="s0">[length=view.length - offset] The number of elements from `view` to copy. 
             */</span>
            <span class="s3">copyBytesFrom(</span><span class="s2">view</span><span class="s1">: </span><span class="s2">NodeJS</span><span class="s3">.</span><span class="s2">TypedArray</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">length</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Compares `buf1` to `buf2`, typically for the purpose of sorting arrays of`Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf1 = Buffer.from('1234'); 
             * const buf2 = Buffer.from('0123'); 
             * const arr = [buf1, buf2]; 
             * 
             * console.log(arr.sort(Buffer.compare)); 
             * // Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ] 
             * // (This result is equal to: [buf2, buf1].) 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.13 
             * </span><span class="s1">@return </span><span class="s0">Either `-1`, `0`, or `1`, depending on the result of the comparison. See `compare` for details. 
             */</span>
            <span class="s3">compare(</span><span class="s2">buf1</span><span class="s1">: </span><span class="s2">Uint8Array</span><span class="s3">, </span><span class="s2">buf2</span><span class="s1">: </span><span class="s2">Uint8Array</span><span class="s3">)</span><span class="s1">: </span><span class="s3">-</span><span class="s5">1 </span><span class="s1">| </span><span class="s5">0 </span><span class="s1">| </span><span class="s5">1</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.alloc(5); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 00 00 00 00 00&gt; 
             * ``` 
             * 
             * If `size` is larger than </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">constants.MAX_LENGTH} </span><span class="s0">or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. 
             * 
             * If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.alloc(5, 'a'); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 61 61 61 61 61&gt; 
             * ``` 
             * 
             * If both `fill` and `encoding` are specified, the allocated `Buffer` will be 
             * initialized by calling `buf.fill(fill, encoding)`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64'); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt; 
             * ``` 
             * 
             * Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance 
             * contents will never contain sensitive data from previous allocations, including 
             * data that might not have been allocated for `Buffer`s. 
             * 
             * A `TypeError` will be thrown if `size` is not a number. 
             * </span><span class="s1">@since </span><span class="s0">v5.10.0 
             * </span><span class="s1">@param </span><span class="s2">size </span><span class="s0">The desired length of the new `Buffer`. 
             * </span><span class="s1">@param </span><span class="s0">[fill=0] A value to pre-fill the new `Buffer` with. 
             * </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `fill` is a string, this is its encoding. 
             */</span>
            <span class="s3">alloc(</span><span class="s2">size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">fill</span><span class="s1">?: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Buffer </span><span class="s1">| </span><span class="s2">number</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new `Buffer` of `size` bytes. If `size` is larger than </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">constants.MAX_LENGTH} </span><span class="s0">or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. 
             * 
             * The underlying memory for `Buffer` instances created in this way is _not_ 
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(10); 
             * 
             * console.log(buf); 
             * // Prints (contents may vary): &lt;Buffer a0 8b 28 3f 01 00 00 00 50 32&gt; 
             * 
             * buf.fill(0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt; 
             * ``` 
             * 
             * A `TypeError` will be thrown if `size` is not a number. 
             * 
             * The `Buffer` module pre-allocates an internal `Buffer` instance of 
             * size `Buffer.poolSize` that is used as a pool for the fast allocation of new`Buffer` instances created using `Buffer.allocUnsafe()`, `Buffer.from(array)`, 
             * and `Buffer.concat()` only when `size` is less than or equal to`Buffer.poolSize &gt;&gt; 1` (floor of `Buffer.poolSize` divided by two). 
             * 
             * Use of this pre-allocated internal memory pool is a key difference between 
             * calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`. 
             * Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less 
             * than or equal to half `Buffer.poolSize`. The 
             * difference is subtle but can be important when an application requires the 
             * additional performance that `Buffer.allocUnsafe()` provides. 
             * </span><span class="s1">@since </span><span class="s0">v5.10.0 
             * </span><span class="s1">@param </span><span class="s2">size </span><span class="s0">The desired length of the new `Buffer`. 
             */</span>
            <span class="s3">allocUnsafe(</span><span class="s2">size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Allocates a new `Buffer` of `size` bytes. If `size` is larger than </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">constants.MAX_LENGTH} </span><span class="s0">or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. A zero-length `Buffer` is created if 
             * `size` is 0. 
             * 
             * The underlying memory for `Buffer` instances created in this way is _not_ 
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `buf.fill(0)` to initialize 
             * such `Buffer` instances with zeroes. 
             * 
             * When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances, 
             * allocations under 4 KiB are sliced from a single pre-allocated `Buffer`. This 
             * allows applications to avoid the garbage collection overhead of creating many 
             * individually allocated `Buffer` instances. This approach improves both 
             * performance and memory usage by eliminating the need to track and clean up as 
             * many individual `ArrayBuffer` objects. 
             * 
             * However, in the case where a developer may need to retain a small chunk of 
             * memory from a pool for an indeterminate amount of time, it may be appropriate 
             * to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and 
             * then copying out the relevant bits. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Need to keep around a few small chunks of memory. 
             * const store = []; 
             * 
             * socket.on('readable', () =&gt; { 
             *   let data; 
             *   while (null !== (data = readable.read())) { 
             *     // Allocate for retained data. 
             *     const sb = Buffer.allocUnsafeSlow(10); 
             * 
             *     // Copy the data into the new allocation. 
             *     data.copy(sb, 0, 0, 10); 
             * 
             *     store.push(sb); 
             *   } 
             * }); 
             * ``` 
             * 
             * A `TypeError` will be thrown if `size` is not a number. 
             * </span><span class="s1">@since </span><span class="s0">v5.12.0 
             * </span><span class="s1">@param </span><span class="s2">size </span><span class="s0">The desired length of the new `Buffer`. 
             */</span>
            <span class="s3">allocUnsafeSlow(</span><span class="s2">size</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* This is the size (in bytes) of pre-allocated internal `Buffer` instances used 
             * for pooling. This value may be modified. 
             * </span><span class="s1">@since </span><span class="s0">v0.11.3 
             */</span>
            <span class="s3">poolSize</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
        <span class="s3">}</span>
        <span class="s1">interface </span><span class="s2">Buffer </span><span class="s1">extends </span><span class="s2">Uint8Array </span><span class="s3">{</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did 
             * not contain enough space to fit the entire string, only part of `string` will be 
             * written. However, partially encoded characters will not be written. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.alloc(256); 
             * 
             * const len = buf.write('\u00bd + \u00bc = \u00be', 0); 
             * 
             * console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`); 
             * // Prints: 12 bytes: ½ + ¼ = ¾ 
             * 
             * const buffer = Buffer.alloc(10); 
             * 
             * const length = buffer.write('abcd', 8); 
             * 
             * console.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`); 
             * // Prints: 2 bytes : ab 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.1.90 
             * </span><span class="s1">@param </span><span class="s2">string </span><span class="s0">String to write to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write `string`. 
             * </span><span class="s1">@param </span><span class="s0">[length=buf.length - offset] Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`). 
             * </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] The character encoding of `string`. 
             * </span><span class="s1">@return </span><span class="s0">Number of bytes written. 
             */</span>
            <span class="s3">write(</span><span class="s2">string</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s3">write(</span><span class="s2">string</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s3">write(</span><span class="s2">string</span><span class="s1">: </span><span class="s2">string</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">length</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`. 
             * 
             * If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8, 
             * then each invalid byte is replaced with the replacement character `U+FFFD`. 
             * 
             * The maximum length of a string instance (in UTF-16 code units) is available 
             * as </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">constants.MAX_STRING_LENGTH}</span><span class="s0">. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf1 = Buffer.allocUnsafe(26); 
             * 
             * for (let i = 0; i &lt; 26; i++) { 
             *   // 97 is the decimal ASCII value for 'a'. 
             *   buf1[i] = i + 97; 
             * } 
             * 
             * console.log(buf1.toString('utf8')); 
             * // Prints: abcdefghijklmnopqrstuvwxyz 
             * console.log(buf1.toString('utf8', 0, 5)); 
             * // Prints: abcde 
             * 
             * const buf2 = Buffer.from('tést'); 
             * 
             * console.log(buf2.toString('hex')); 
             * // Prints: 74c3a97374 
             * console.log(buf2.toString('utf8', 0, 3)); 
             * // Prints: té 
             * console.log(buf2.toString(undefined, 0, 3)); 
             * // Prints: té 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.1.90 
             * </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] The character encoding to use. 
             * </span><span class="s1">@param </span><span class="s0">[start=0] The byte offset to start decoding at. 
             * </span><span class="s1">@param </span><span class="s0">[end=buf.length] The byte offset to stop decoding at (not inclusive). 
             */</span>
            <span class="s3">toString(</span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">, </span><span class="s2">start</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">end</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls 
             * this function when stringifying a `Buffer` instance. 
             * 
             * `Buffer.from()` accepts objects in the format returned from this method. 
             * In particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]); 
             * const json = JSON.stringify(buf); 
             * 
             * console.log(json); 
             * // Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]} 
             * 
             * const copy = JSON.parse(json, (key, value) =&gt; { 
             *   return value &amp;#x26;&amp;#x26; value.type === 'Buffer' ? 
             *     Buffer.from(value) : 
             *     value; 
             * }); 
             * 
             * console.log(copy); 
             * // Prints: &lt;Buffer 01 02 03 04 05&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.9.2 
             */</span>
            <span class="s3">toJSON()</span><span class="s1">: </span><span class="s3">{</span>
                <span class="s3">type</span><span class="s1">: </span><span class="s4">'Buffer'</span><span class="s3">;</span>
                <span class="s3">data</span><span class="s1">: </span><span class="s2">number</span><span class="s3">[];</span>
            <span class="s3">};</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf1 = Buffer.from('ABC'); 
             * const buf2 = Buffer.from('414243', 'hex'); 
             * const buf3 = Buffer.from('ABCD'); 
             * 
             * console.log(buf1.equals(buf2)); 
             * // Prints: true 
             * console.log(buf1.equals(buf3)); 
             * // Prints: false 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.13 
             * </span><span class="s1">@param </span><span class="s2">otherBuffer </span><span class="s0">A `Buffer` or </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Uint8Array} </span><span class="s0">with which to compare `buf`. 
             */</span>
            <span class="s3">equals(</span><span class="s2">otherBuffer</span><span class="s1">: </span><span class="s2">Uint8Array</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order. 
             * Comparison is based on the actual sequence of bytes in each `Buffer`. 
             * 
             * * `0` is returned if `target` is the same as `buf` 
             * * `1` is returned if `target` should come _before_`buf` when sorted. 
             * * `-1` is returned if `target` should come _after_`buf` when sorted. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf1 = Buffer.from('ABC'); 
             * const buf2 = Buffer.from('BCD'); 
             * const buf3 = Buffer.from('ABCD'); 
             * 
             * console.log(buf1.compare(buf1)); 
             * // Prints: 0 
             * console.log(buf1.compare(buf2)); 
             * // Prints: -1 
             * console.log(buf1.compare(buf3)); 
             * // Prints: -1 
             * console.log(buf2.compare(buf1)); 
             * // Prints: 1 
             * console.log(buf2.compare(buf3)); 
             * // Prints: 1 
             * console.log([buf1, buf2, buf3].sort(Buffer.compare)); 
             * // Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ] 
             * // (This result is equal to: [buf1, buf3, buf2].) 
             * ``` 
             * 
             * The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd`arguments can be used to limit the comparison to specific ranges within `target`and `buf` respectively. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]); 
             * const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]); 
             * 
             * console.log(buf1.compare(buf2, 5, 9, 0, 4)); 
             * // Prints: 0 
             * console.log(buf1.compare(buf2, 0, 6, 4)); 
             * // Prints: -1 
             * console.log(buf1.compare(buf2, 5, 6, 5)); 
             * // Prints: 1 
             * ``` 
             * 
             * `ERR_OUT_OF_RANGE` is thrown if `targetStart &lt; 0`, `sourceStart &lt; 0`,`targetEnd &gt; target.byteLength`, or `sourceEnd &gt; source.byteLength`. 
             * </span><span class="s1">@since </span><span class="s0">v0.11.13 
             * </span><span class="s1">@param </span><span class="s2">target </span><span class="s0">A `Buffer` or </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Uint8Array} </span><span class="s0">with which to compare `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[targetStart=0] The offset within `target` at which to begin comparison. 
             * </span><span class="s1">@param </span><span class="s0">[targetEnd=target.length] The offset within `target` at which to end comparison (not inclusive). 
             * </span><span class="s1">@param </span><span class="s0">[sourceStart=0] The offset within `buf` at which to begin comparison. 
             * </span><span class="s1">@param </span><span class="s0">[sourceEnd=buf.length] The offset within `buf` at which to end comparison (not inclusive). 
             */</span>
            <span class="s3">compare(</span>
                <span class="s2">target</span><span class="s1">: </span><span class="s2">Uint8Array</span><span class="s3">,</span>
                <span class="s2">targetStart</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">,</span>
                <span class="s2">targetEnd</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">,</span>
                <span class="s2">sourceStart</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">,</span>
                <span class="s2">sourceEnd</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">,</span>
            <span class="s3">)</span><span class="s1">: </span><span class="s3">-</span><span class="s5">1 </span><span class="s1">| </span><span class="s5">0 </span><span class="s1">| </span><span class="s5">1</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`. 
             * 
             * [`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available 
             * for all TypedArrays, including Node.js `Buffer`s, although it takes 
             * different function arguments. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Create two `Buffer` instances. 
             * const buf1 = Buffer.allocUnsafe(26); 
             * const buf2 = Buffer.allocUnsafe(26).fill('!'); 
             * 
             * for (let i = 0; i &lt; 26; i++) { 
             *   // 97 is the decimal ASCII value for 'a'. 
             *   buf1[i] = i + 97; 
             * } 
             * 
             * // Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`. 
             * buf1.copy(buf2, 8, 16, 20); 
             * // This is equivalent to: 
             * // buf2.set(buf1.subarray(16, 20), 8); 
             * 
             * console.log(buf2.toString('ascii', 0, 25)); 
             * // Prints: !!!!!!!!qrst!!!!!!!!!!!!! 
             * ``` 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Create a `Buffer` and copy data from one region to an overlapping region 
             * // within the same `Buffer`. 
             * 
             * const buf = Buffer.allocUnsafe(26); 
             * 
             * for (let i = 0; i &lt; 26; i++) { 
             *   // 97 is the decimal ASCII value for 'a'. 
             *   buf[i] = i + 97; 
             * } 
             * 
             * buf.copy(buf, 0, 4, 10); 
             * 
             * console.log(buf.toString()); 
             * // Prints: efghijghijklmnopqrstuvwxyz 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.1.90 
             * </span><span class="s1">@param </span><span class="s2">target </span><span class="s0">A `Buffer` or </span><span class="s2">{</span><span class="s1">@link </span><span class="s2">Uint8Array} </span><span class="s0">to copy into. 
             * </span><span class="s1">@param </span><span class="s0">[targetStart=0] The offset within `target` at which to begin writing. 
             * </span><span class="s1">@param </span><span class="s0">[sourceStart=0] The offset within `buf` from which to begin copying. 
             * </span><span class="s1">@param </span><span class="s0">[sourceEnd=buf.length] The offset within `buf` at which to stop copying (not inclusive). 
             * </span><span class="s1">@return </span><span class="s0">The number of bytes copied. 
             */</span>
            <span class="s3">copy(</span><span class="s2">target</span><span class="s1">: </span><span class="s2">Uint8Array</span><span class="s3">, </span><span class="s2">targetStart</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">sourceStart</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">sourceEnd</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns a new `Buffer` that references the same memory as the original, but 
             * offset and cropped by the `start` and `end` indices. 
             * 
             * This method is not compatible with the `Uint8Array.prototype.slice()`, 
             * which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from('buffer'); 
             * 
             * const copiedBuf = Uint8Array.prototype.slice.call(buf); 
             * copiedBuf[0]++; 
             * console.log(copiedBuf.toString()); 
             * // Prints: cuffer 
             * 
             * console.log(buf.toString()); 
             * // Prints: buffer 
             * 
             * // With buf.slice(), the original buffer is modified. 
             * const notReallyCopiedBuf = buf.slice(); 
             * notReallyCopiedBuf[0]++; 
             * console.log(notReallyCopiedBuf.toString()); 
             * // Prints: cuffer 
             * console.log(buf.toString()); 
             * // Also prints: cuffer (!) 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.3.0 
             * </span><span class="s1">@deprecated </span><span class="s0">Use `subarray` instead. 
             * </span><span class="s1">@param </span><span class="s0">[start=0] Where the new `Buffer` will start. 
             * </span><span class="s1">@param </span><span class="s0">[end=buf.length] Where the new `Buffer` will end (not inclusive). 
             */</span>
            <span class="s3">slice(</span><span class="s2">start</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">end</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Returns a new `Buffer` that references the same memory as the original, but 
             * offset and cropped by the `start` and `end` indices. 
             * 
             * Specifying `end` greater than `buf.length` will return the same result as 
             * that of `end` equal to `buf.length`. 
             * 
             * This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray). 
             * 
             * Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte 
             * // from the original `Buffer`. 
             * 
             * const buf1 = Buffer.allocUnsafe(26); 
             * 
             * for (let i = 0; i &lt; 26; i++) { 
             *   // 97 is the decimal ASCII value for 'a'. 
             *   buf1[i] = i + 97; 
             * } 
             * 
             * const buf2 = buf1.subarray(0, 3); 
             * 
             * console.log(buf2.toString('ascii', 0, buf2.length)); 
             * // Prints: abc 
             * 
             * buf1[0] = 33; 
             * 
             * console.log(buf2.toString('ascii', 0, buf2.length)); 
             * // Prints: !bc 
             * ``` 
             * 
             * Specifying negative indexes causes the slice to be generated relative to the 
             * end of `buf` rather than the beginning. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from('buffer'); 
             * 
             * console.log(buf.subarray(-6, -1).toString()); 
             * // Prints: buffe 
             * // (Equivalent to buf.subarray(0, 5).) 
             * 
             * console.log(buf.subarray(-6, -2).toString()); 
             * // Prints: buff 
             * // (Equivalent to buf.subarray(0, 4).) 
             * 
             * console.log(buf.subarray(-5, -2).toString()); 
             * // Prints: uff 
             * // (Equivalent to buf.subarray(1, 4).) 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v3.0.0 
             * </span><span class="s1">@param </span><span class="s0">[start=0] Where the new `Buffer` will start. 
             * </span><span class="s1">@param </span><span class="s0">[end=buf.length] Where the new `Buffer` will end (not inclusive). 
             */</span>
            <span class="s3">subarray(</span><span class="s2">start</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">end</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. 
             * 
             * `value` is interpreted and written as a two's complement signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(8); 
             * 
             * buf.writeBigInt64BE(0x0102030405060708n, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeBigInt64BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. 
             * 
             * `value` is interpreted and written as a two's complement signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(8); 
             * 
             * buf.writeBigInt64LE(0x0102030405060708n, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeBigInt64LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. 
             * 
             * This function is also available under the `writeBigUint64BE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(8); 
             * 
             * buf.writeBigUInt64BE(0xdecafafecacefaden, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer de ca fa fe ca ce fa de&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeBigUInt64BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeBigUInt64BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0 
             */</span>
            <span class="s3">writeBigUint64BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(8); 
             * 
             * buf.writeBigUInt64LE(0xdecafafecacefaden, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer de fa ce ca fe fa ca de&gt; 
             * ``` 
             * 
             * This function is also available under the `writeBigUint64LE` alias. 
             * </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeBigUInt64LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeBigUInt64LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0 
             */</span>
            <span class="s3">writeBigUint64LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined 
             * when `value` is anything other than an unsigned integer. 
             * 
             * This function is also available under the `writeUintLE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(6); 
             * 
             * buf.writeUIntLE(0x1234567890ab, 0, 6); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer ab 90 78 56 34 12&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s2">offset </span><span class="s0">Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`. 
             * </span><span class="s1">@param </span><span class="s2">byteLength </span><span class="s0">Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeUIntLE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeUIntLE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">writeUintLE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined 
             * when `value` is anything other than an unsigned integer. 
             * 
             * This function is also available under the `writeUintBE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(6); 
             * 
             * buf.writeUIntBE(0x1234567890ab, 0, 6); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 12 34 56 78 90 ab&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s2">offset </span><span class="s0">Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`. 
             * </span><span class="s1">@param </span><span class="s2">byteLength </span><span class="s0">Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeUIntBE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeUIntBE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">writeUintBE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined 
             * when `value` is anything other than a signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(6); 
             * 
             * buf.writeIntLE(0x1234567890ab, 0, 6); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer ab 90 78 56 34 12&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s2">offset </span><span class="s0">Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`. 
             * </span><span class="s1">@param </span><span class="s2">byteLength </span><span class="s0">Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeIntLE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a 
             * signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(6); 
             * 
             * buf.writeIntBE(0x1234567890ab, 0, 6); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 12 34 56 78 90 ab&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s2">offset </span><span class="s0">Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`. 
             * </span><span class="s1">@param </span><span class="s2">byteLength </span><span class="s0">Number of bytes to write. Must satisfy `0 &lt; byteLength &lt;= 6`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeIntBE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`. 
             * 
             * This function is also available under the `readBigUint64BE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]); 
             * 
             * console.log(buf.readBigUInt64BE(0)); 
             * // Prints: 4294967295n 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`. 
             */</span>
            <span class="s3">readBigUInt64BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readBigUInt64BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0 
             */</span>
            <span class="s3">readBigUint64BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`. 
             * 
             * This function is also available under the `readBigUint64LE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]); 
             * 
             * console.log(buf.readBigUInt64LE(0)); 
             * // Prints: 18446744069414584320n 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`. 
             */</span>
            <span class="s3">readBigUInt64LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readBigUInt64LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.10.0, v12.19.0 
             */</span>
            <span class="s3">readBigUint64LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`. 
             * 
             * Integers read from a `Buffer` are interpreted as two's complement signed 
             * values. 
             * </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`. 
             */</span>
            <span class="s3">readBigInt64BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`. 
             * 
             * Integers read from a `Buffer` are interpreted as two's complement signed 
             * values. 
             * </span><span class="s1">@since </span><span class="s0">v12.0.0, v10.20.0 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 &lt;= offset &lt;= buf.length - 8`. 
             */</span>
            <span class="s3">readBigInt64LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">bigint</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned, little-endian integer supporting 
             * up to 48 bits of accuracy. 
             * 
             * This function is also available under the `readUintLE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]); 
             * 
             * console.log(buf.readUIntLE(0, 6).toString(16)); 
             * // Prints: ab9078563412 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">offset </span><span class="s0">Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`. 
             * </span><span class="s1">@param </span><span class="s2">byteLength </span><span class="s0">Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`. 
             */</span>
            <span class="s3">readUIntLE(</span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readUIntLE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">readUintLE(</span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned big-endian integer supporting 
             * up to 48 bits of accuracy. 
             * 
             * This function is also available under the `readUintBE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]); 
             * 
             * console.log(buf.readUIntBE(0, 6).toString(16)); 
             * // Prints: 1234567890ab 
             * console.log(buf.readUIntBE(1, 6).toString(16)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">offset </span><span class="s0">Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`. 
             * </span><span class="s1">@param </span><span class="s2">byteLength </span><span class="s0">Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`. 
             */</span>
            <span class="s3">readUIntBE(</span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readUIntBE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">readUintBE(</span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a little-endian, two's complement signed value 
             * supporting up to 48 bits of accuracy. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]); 
             * 
             * console.log(buf.readIntLE(0, 6).toString(16)); 
             * // Prints: -546f87a9cbee 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">offset </span><span class="s0">Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`. 
             * </span><span class="s1">@param </span><span class="s2">byteLength </span><span class="s0">Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`. 
             */</span>
            <span class="s3">readIntLE(</span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a big-endian, two's complement signed value 
             * supporting up to 48 bits of accuracy. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]); 
             * 
             * console.log(buf.readIntBE(0, 6).toString(16)); 
             * // Prints: 1234567890ab 
             * console.log(buf.readIntBE(1, 6).toString(16)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * console.log(buf.readIntBE(1, 0).toString(16)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">offset </span><span class="s0">Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - byteLength`. 
             * </span><span class="s1">@param </span><span class="s2">byteLength </span><span class="s0">Number of bytes to read. Must satisfy `0 &lt; byteLength &lt;= 6`. 
             */</span>
            <span class="s3">readIntBE(</span><span class="s2">offset</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">byteLength</span><span class="s1">: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned 8-bit integer from `buf` at the specified `offset`. 
             * 
             * This function is also available under the `readUint8` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([1, -2]); 
             * 
             * console.log(buf.readUInt8(0)); 
             * // Prints: 1 
             * console.log(buf.readUInt8(1)); 
             * // Prints: 254 
             * console.log(buf.readUInt8(2)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.0 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`. 
             */</span>
            <span class="s3">readUInt8(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readUInt8</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">readUint8(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, little-endian 16-bit integer from `buf` at the specified`offset`. 
             * 
             * This function is also available under the `readUint16LE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x12, 0x34, 0x56]); 
             * 
             * console.log(buf.readUInt16LE(0).toString(16)); 
             * // Prints: 3412 
             * console.log(buf.readUInt16LE(1).toString(16)); 
             * // Prints: 5634 
             * console.log(buf.readUInt16LE(2).toString(16)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`. 
             */</span>
            <span class="s3">readUInt16LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readUInt16LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">readUint16LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`. 
             * 
             * This function is also available under the `readUint16BE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x12, 0x34, 0x56]); 
             * 
             * console.log(buf.readUInt16BE(0).toString(16)); 
             * // Prints: 1234 
             * console.log(buf.readUInt16BE(1).toString(16)); 
             * // Prints: 3456 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`. 
             */</span>
            <span class="s3">readUInt16BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readUInt16BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">readUint16BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`. 
             * 
             * This function is also available under the `readUint32LE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]); 
             * 
             * console.log(buf.readUInt32LE(0).toString(16)); 
             * // Prints: 78563412 
             * console.log(buf.readUInt32LE(1).toString(16)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             */</span>
            <span class="s3">readUInt32LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readUInt32LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">readUint32LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`. 
             * 
             * This function is also available under the `readUint32BE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]); 
             * 
             * console.log(buf.readUInt32BE(0).toString(16)); 
             * // Prints: 12345678 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             */</span>
            <span class="s3">readUInt32BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.readUInt32BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">readUint32BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed 8-bit integer from `buf` at the specified `offset`. 
             * 
             * Integers read from a `Buffer` are interpreted as two's complement signed values. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([-1, 5]); 
             * 
             * console.log(buf.readInt8(0)); 
             * // Prints: -1 
             * console.log(buf.readInt8(1)); 
             * // Prints: 5 
             * console.log(buf.readInt8(2)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.0 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`. 
             */</span>
            <span class="s3">readInt8(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`. 
             * 
             * Integers read from a `Buffer` are interpreted as two's complement signed values. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0, 5]); 
             * 
             * console.log(buf.readInt16LE(0)); 
             * // Prints: 1280 
             * console.log(buf.readInt16LE(1)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`. 
             */</span>
            <span class="s3">readInt16LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`. 
             * 
             * Integers read from a `Buffer` are interpreted as two's complement signed values. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0, 5]); 
             * 
             * console.log(buf.readInt16BE(0)); 
             * // Prints: 5 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`. 
             */</span>
            <span class="s3">readInt16BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`. 
             * 
             * Integers read from a `Buffer` are interpreted as two's complement signed values. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0, 0, 0, 5]); 
             * 
             * console.log(buf.readInt32LE(0)); 
             * // Prints: 83886080 
             * console.log(buf.readInt32LE(1)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             */</span>
            <span class="s3">readInt32LE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`. 
             * 
             * Integers read from a `Buffer` are interpreted as two's complement signed values. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([0, 0, 0, 5]); 
             * 
             * console.log(buf.readInt32BE(0)); 
             * // Prints: 5 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             */</span>
            <span class="s3">readInt32BE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a 32-bit, little-endian float from `buf` at the specified `offset`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([1, 2, 3, 4]); 
             * 
             * console.log(buf.readFloatLE(0)); 
             * // Prints: 1.539989614439558e-36 
             * console.log(buf.readFloatLE(1)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             */</span>
            <span class="s3">readFloatLE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a 32-bit, big-endian float from `buf` at the specified `offset`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([1, 2, 3, 4]); 
             * 
             * console.log(buf.readFloatBE(0)); 
             * // Prints: 2.387939260590663e-38 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             */</span>
            <span class="s3">readFloatBE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a 64-bit, little-endian double from `buf` at the specified `offset`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]); 
             * 
             * console.log(buf.readDoubleLE(0)); 
             * // Prints: 5.447603722011605e-270 
             * console.log(buf.readDoubleLE(1)); 
             * // Throws ERR_OUT_OF_RANGE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`. 
             */</span>
            <span class="s3">readDoubleLE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Reads a 64-bit, big-endian double from `buf` at the specified `offset`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]); 
             * 
             * console.log(buf.readDoubleBE(0)); 
             * // Prints: 8.20788039913184e-304 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to read. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`. 
             */</span>
            <span class="s3">readDoubleBE(</span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s3">reverse()</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Interprets `buf` as an array of unsigned 16-bit integers and swaps the 
             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]); 
             * 
             * console.log(buf1); 
             * // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt; 
             * 
             * buf1.swap16(); 
             * 
             * console.log(buf1); 
             * // Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt; 
             * 
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]); 
             * 
             * buf2.swap16(); 
             * // Throws ERR_INVALID_BUFFER_SIZE. 
             * ``` 
             * 
             * One convenient use of `buf.swap16()` is to perform a fast in-place conversion 
             * between UTF-16 little-endian and UTF-16 big-endian: 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from('This is little-endian UTF-16', 'utf16le'); 
             * buf.swap16(); // Convert to big-endian UTF-16 text. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v5.10.0 
             * </span><span class="s1">@return </span><span class="s0">A reference to `buf`. 
             */</span>
            <span class="s3">swap16()</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Interprets `buf` as an array of unsigned 32-bit integers and swaps the 
             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]); 
             * 
             * console.log(buf1); 
             * // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt; 
             * 
             * buf1.swap32(); 
             * 
             * console.log(buf1); 
             * // Prints: &lt;Buffer 04 03 02 01 08 07 06 05&gt; 
             * 
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]); 
             * 
             * buf2.swap32(); 
             * // Throws ERR_INVALID_BUFFER_SIZE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v5.10.0 
             * </span><span class="s1">@return </span><span class="s0">A reference to `buf`. 
             */</span>
            <span class="s3">swap32()</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_. 
             * Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]); 
             * 
             * console.log(buf1); 
             * // Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt; 
             * 
             * buf1.swap64(); 
             * 
             * console.log(buf1); 
             * // Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt; 
             * 
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]); 
             * 
             * buf2.swap64(); 
             * // Throws ERR_INVALID_BUFFER_SIZE. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v6.3.0 
             * </span><span class="s1">@return </span><span class="s0">A reference to `buf`. 
             */</span>
            <span class="s3">swap64()</span><span class="s1">: </span><span class="s2">Buffer</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset`. `value` must be a 
             * valid unsigned 8-bit integer. Behavior is undefined when `value` is anything 
             * other than an unsigned 8-bit integer. 
             * 
             * This function is also available under the `writeUint8` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeUInt8(0x3, 0); 
             * buf.writeUInt8(0x4, 1); 
             * buf.writeUInt8(0x23, 2); 
             * buf.writeUInt8(0x42, 3); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 03 04 23 42&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeUInt8(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeUInt8</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">writeUint8(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is 
             * anything other than an unsigned 16-bit integer. 
             * 
             * This function is also available under the `writeUint16LE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeUInt16LE(0xdead, 0); 
             * buf.writeUInt16LE(0xbeef, 2); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer ad de ef be&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeUInt16LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeUInt16LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">writeUint16LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an 
             * unsigned 16-bit integer. 
             * 
             * This function is also available under the `writeUint16BE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeUInt16BE(0xdead, 0); 
             * buf.writeUInt16BE(0xbeef, 2); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer de ad be ef&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeUInt16BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeUInt16BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">writeUint16BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is 
             * anything other than an unsigned 32-bit integer. 
             * 
             * This function is also available under the `writeUint32LE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeUInt32LE(0xfeedface, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer ce fa ed fe&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeUInt32LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeUInt32LE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">writeUint32LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an 
             * unsigned 32-bit integer. 
             * 
             * This function is also available under the `writeUint32BE` alias. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeUInt32BE(0xfeedface, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer fe ed fa ce&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeUInt32BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@alias </span><span class="s2">Buffer.writeUInt32BE</span>
             <span class="s0">* </span><span class="s1">@since </span><span class="s0">v14.9.0, v12.19.0 
             */</span>
            <span class="s3">writeUint32BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset`. `value` must be a valid 
             * signed 8-bit integer. Behavior is undefined when `value` is anything other than 
             * a signed 8-bit integer. 
             * 
             * `value` is interpreted and written as a two's complement signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(2); 
             * 
             * buf.writeInt8(2, 0); 
             * buf.writeInt8(-2, 1); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 02 fe&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 1`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeInt8(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian.  The `value`must be a valid signed 16-bit integer. Behavior is undefined when `value` is 
             * anything other than a signed 16-bit integer. 
             * 
             * The `value` is interpreted and written as a two's complement signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(2); 
             * 
             * buf.writeInt16LE(0x0304, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 04 03&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeInt16LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian.  The `value`must be a valid signed 16-bit integer. Behavior is undefined when `value` is 
             * anything other than a signed 16-bit integer. 
             * 
             * The `value` is interpreted and written as a two's complement signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(2); 
             * 
             * buf.writeInt16BE(0x0102, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 01 02&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 2`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeInt16BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid signed 32-bit integer. Behavior is undefined when `value` is 
             * anything other than a signed 32-bit integer. 
             * 
             * The `value` is interpreted and written as a two's complement signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeInt32LE(0x05060708, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 08 07 06 05&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeInt32LE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid signed 32-bit integer. Behavior is undefined when `value` is 
             * anything other than a signed 32-bit integer. 
             * 
             * The `value` is interpreted and written as a two's complement signed integer. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeInt32BE(0x01020304, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 01 02 03 04&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.5 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeInt32BE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is 
             * undefined when `value` is anything other than a JavaScript number. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeFloatLE(0xcafebabe, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer bb fe 4a 4f&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeFloatLE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is 
             * undefined when `value` is anything other than a JavaScript number. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(4); 
             * 
             * buf.writeFloatBE(0xcafebabe, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 4f 4a fe bb&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 4`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeFloatBE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a JavaScript number. Behavior is undefined when `value` is anything 
             * other than a JavaScript number. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(8); 
             * 
             * buf.writeDoubleLE(123.456, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 77 be 9f 1a 2f dd 5e 40&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeDoubleLE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a JavaScript number. Behavior is undefined when `value` is anything 
             * other than a JavaScript number. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(8); 
             * 
             * buf.writeDoubleBE(123.456, 0); 
             * 
             * console.log(buf); 
             * // Prints: &lt;Buffer 40 5e dd 2f 1a 9f be 77&gt; 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.11.15 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">Number to be written to `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to write. Must satisfy `0 &lt;= offset &lt;= buf.length - 8`. 
             * </span><span class="s1">@return </span><span class="s0">`offset` plus the number of bytes written. 
             */</span>
            <span class="s3">writeDoubleBE(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Fills `buf` with the specified `value`. If the `offset` and `end` are not given, 
             * the entire `buf` will be filled: 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Fill a `Buffer` with the ASCII character 'h'. 
             * 
             * const b = Buffer.allocUnsafe(50).fill('h'); 
             * 
             * console.log(b.toString()); 
             * // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 
             * 
             * // Fill a buffer with empty string 
             * const c = Buffer.allocUnsafe(5).fill(''); 
             * 
             * console.log(c.fill('')); 
             * // Prints: &lt;Buffer 00 00 00 00 00&gt; 
             * ``` 
             * 
             * `value` is coerced to a `uint32` value if it is not a string, `Buffer`, or 
             * integer. If the resulting integer is greater than `255` (decimal), `buf` will be 
             * filled with `value &amp;#x26; 255`. 
             * 
             * If the final write of a `fill()` operation falls on a multi-byte character, 
             * then only the bytes of that character that fit into `buf` are written: 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Fill a `Buffer` with character that takes up two bytes in UTF-8. 
             * 
             * console.log(Buffer.allocUnsafe(5).fill('\u0222')); 
             * // Prints: &lt;Buffer c8 a2 c8 a2 c8&gt; 
             * ``` 
             * 
             * If `value` contains invalid characters, it is truncated; if no valid 
             * fill data remains, an exception is thrown: 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.allocUnsafe(5); 
             * 
             * console.log(buf.fill('a')); 
             * // Prints: &lt;Buffer 61 61 61 61 61&gt; 
             * console.log(buf.fill('aazz', 'hex')); 
             * // Prints: &lt;Buffer aa aa aa aa aa&gt; 
             * console.log(buf.fill('zz', 'hex')); 
             * // Throws an exception. 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v0.5.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`. 
             * </span><span class="s1">@param </span><span class="s0">[offset=0] Number of bytes to skip before starting to fill `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[end=buf.length] Where to stop filling `buf` (not inclusive). 
             * </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] The encoding for `value` if `value` is a string. 
             * </span><span class="s1">@return </span><span class="s0">A reference to `buf`. 
             */</span>
            <span class="s3">fill(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">Uint8Array </span><span class="s1">| </span><span class="s2">number</span><span class="s3">, </span><span class="s2">offset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">end</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">this</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* If `value` is: 
             * 
             * * a string, `value` is interpreted according to the character encoding in`encoding`. 
             * * a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety. 
             * To compare a partial `Buffer`, use `buf.subarray`. 
             * * a number, `value` will be interpreted as an unsigned 8-bit integer 
             * value between `0` and `255`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from('this is a buffer'); 
             * 
             * console.log(buf.indexOf('this')); 
             * // Prints: 0 
             * console.log(buf.indexOf('is')); 
             * // Prints: 2 
             * console.log(buf.indexOf(Buffer.from('a buffer'))); 
             * // Prints: 8 
             * console.log(buf.indexOf(97)); 
             * // Prints: 8 (97 is the decimal ASCII value for 'a') 
             * console.log(buf.indexOf(Buffer.from('a buffer example'))); 
             * // Prints: -1 
             * console.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8))); 
             * // Prints: 8 
             * 
             * const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le'); 
             * 
             * console.log(utf16Buffer.indexOf('\u03a3', 0, 'utf16le')); 
             * // Prints: 4 
             * console.log(utf16Buffer.indexOf('\u03a3', -4, 'utf16le')); 
             * // Prints: 6 
             * ``` 
             * 
             * If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value, 
             * an integer between 0 and 255. 
             * 
             * If `byteOffset` is not a number, it will be coerced to a number. If the result 
             * of coercion is `NaN` or `0`, then the entire buffer will be searched. This 
             * behavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf). 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const b = Buffer.from('abcdef'); 
             * 
             * // Passing a value that's a number, but not a valid byte. 
             * // Prints: 2, equivalent to searching for 99 or 'c'. 
             * console.log(b.indexOf(99.9)); 
             * console.log(b.indexOf(256 + 99)); 
             * 
             * // Passing a byteOffset that coerces to NaN or 0. 
             * // Prints: 1, searching the whole buffer. 
             * console.log(b.indexOf('b', undefined)); 
             * console.log(b.indexOf('b', {})); 
             * console.log(b.indexOf('b', null)); 
             * console.log(b.indexOf('b', [])); 
             * ``` 
             * 
             * If `value` is an empty string or empty `Buffer` and `byteOffset` is less 
             * than `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned. 
             * </span><span class="s1">@since </span><span class="s0">v1.5.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">What to search for. 
             * </span><span class="s1">@param </span><span class="s0">[byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`. 
             * </span><span class="s1">@return </span><span class="s0">The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`. 
             */</span>
            <span class="s3">indexOf(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">number </span><span class="s1">| </span><span class="s2">Uint8Array</span><span class="s3">, </span><span class="s2">byteOffset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Identical to `buf.indexOf()`, except the last occurrence of `value` is found 
             * rather than the first occurrence. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from('this buffer is a buffer'); 
             * 
             * console.log(buf.lastIndexOf('this')); 
             * // Prints: 0 
             * console.log(buf.lastIndexOf('buffer')); 
             * // Prints: 17 
             * console.log(buf.lastIndexOf(Buffer.from('buffer'))); 
             * // Prints: 17 
             * console.log(buf.lastIndexOf(97)); 
             * // Prints: 15 (97 is the decimal ASCII value for 'a') 
             * console.log(buf.lastIndexOf(Buffer.from('yolo'))); 
             * // Prints: -1 
             * console.log(buf.lastIndexOf('buffer', 5)); 
             * // Prints: 5 
             * console.log(buf.lastIndexOf('buffer', 4)); 
             * // Prints: -1 
             * 
             * const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le'); 
             * 
             * console.log(utf16Buffer.lastIndexOf('\u03a3', undefined, 'utf16le')); 
             * // Prints: 6 
             * console.log(utf16Buffer.lastIndexOf('\u03a3', -5, 'utf16le')); 
             * // Prints: 4 
             * ``` 
             * 
             * If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value, 
             * an integer between 0 and 255. 
             * 
             * If `byteOffset` is not a number, it will be coerced to a number. Any arguments 
             * that coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer. 
             * This behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf). 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const b = Buffer.from('abcdef'); 
             * 
             * // Passing a value that's a number, but not a valid byte. 
             * // Prints: 2, equivalent to searching for 99 or 'c'. 
             * console.log(b.lastIndexOf(99.9)); 
             * console.log(b.lastIndexOf(256 + 99)); 
             * 
             * // Passing a byteOffset that coerces to NaN. 
             * // Prints: 1, searching the whole buffer. 
             * console.log(b.lastIndexOf('b', undefined)); 
             * console.log(b.lastIndexOf('b', {})); 
             * 
             * // Passing a byteOffset that coerces to 0. 
             * // Prints: -1, equivalent to passing 0. 
             * console.log(b.lastIndexOf('b', null)); 
             * console.log(b.lastIndexOf('b', [])); 
             * ``` 
             * 
             * If `value` is an empty string or empty `Buffer`, `byteOffset` will be returned. 
             * </span><span class="s1">@since </span><span class="s0">v6.0.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">What to search for. 
             * </span><span class="s1">@param </span><span class="s0">[byteOffset=buf.length - 1] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`. 
             * </span><span class="s1">@return </span><span class="s0">The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`. 
             */</span>
            <span class="s3">lastIndexOf(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">number </span><span class="s1">| </span><span class="s2">Uint8Array</span><span class="s3">, </span><span class="s2">byteOffset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">number</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `[index, byte]` pairs from the contents 
             * of `buf`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * // Log the entire contents of a `Buffer`. 
             * 
             * const buf = Buffer.from('buffer'); 
             * 
             * for (const pair of buf.entries()) { 
             *   console.log(pair); 
             * } 
             * // Prints: 
             * //   [0, 98] 
             * //   [1, 117] 
             * //   [2, 102] 
             * //   [3, 102] 
             * //   [4, 101] 
             * //   [5, 114] 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v1.1.0 
             */</span>
            <span class="s3">entries()</span><span class="s1">: </span><span class="s2">IterableIterator</span><span class="s3">&lt;[</span><span class="s2">number</span><span class="s3">, </span><span class="s2">number</span><span class="s3">]&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Equivalent to `buf.indexOf() !== -1`. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from('this is a buffer'); 
             * 
             * console.log(buf.includes('this')); 
             * // Prints: true 
             * console.log(buf.includes('is')); 
             * // Prints: true 
             * console.log(buf.includes(Buffer.from('a buffer'))); 
             * // Prints: true 
             * console.log(buf.includes(97)); 
             * // Prints: true (97 is the decimal ASCII value for 'a') 
             * console.log(buf.includes(Buffer.from('a buffer example'))); 
             * // Prints: false 
             * console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8))); 
             * // Prints: true 
             * console.log(buf.includes('this', 4)); 
             * // Prints: false 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v5.3.0 
             * </span><span class="s1">@param </span><span class="s2">value </span><span class="s0">What to search for. 
             * </span><span class="s1">@param </span><span class="s0">[byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`. 
             * </span><span class="s1">@param </span><span class="s0">[encoding='utf8'] If `value` is a string, this is its encoding. 
             * </span><span class="s1">@return </span><span class="s0">`true` if `value` was found in `buf`, `false` otherwise. 
             */</span>
            <span class="s3">includes(</span><span class="s2">value</span><span class="s1">: </span><span class="s2">string </span><span class="s1">| </span><span class="s2">number </span><span class="s1">| </span><span class="s2">Buffer</span><span class="s3">, </span><span class="s2">byteOffset</span><span class="s1">?: </span><span class="s2">number</span><span class="s3">, </span><span class="s2">encoding</span><span class="s1">?: </span><span class="s2">BufferEncoding</span><span class="s3">)</span><span class="s1">: </span><span class="s2">boolean</span><span class="s3">;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `buf` keys (indices). 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from('buffer'); 
             * 
             * for (const key of buf.keys()) { 
             *   console.log(key); 
             * } 
             * // Prints: 
             * //   0 
             * //   1 
             * //   2 
             * //   3 
             * //   4 
             * //   5 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v1.1.0 
             */</span>
            <span class="s3">keys()</span><span class="s1">: </span><span class="s2">IterableIterator</span><span class="s3">&lt;</span><span class="s2">number</span><span class="s3">&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) for `buf` values (bytes). This function is 
             * called automatically when a `Buffer` is used in a `for..of` statement. 
             * 
             * ```js 
             * import { Buffer } from 'node:buffer'; 
             * 
             * const buf = Buffer.from('buffer'); 
             * 
             * for (const value of buf.values()) { 
             *   console.log(value); 
             * } 
             * // Prints: 
             * //   98 
             * //   117 
             * //   102 
             * //   102 
             * //   101 
             * //   114 
             * 
             * for (const value of buf) { 
             *   console.log(value); 
             * } 
             * // Prints: 
             * //   98 
             * //   117 
             * //   102 
             * //   102 
             * //   101 
             * //   114 
             * ``` 
             * </span><span class="s1">@since </span><span class="s0">v1.1.0 
             */</span>
            <span class="s3">values()</span><span class="s1">: </span><span class="s2">IterableIterator</span><span class="s3">&lt;</span><span class="s2">number</span><span class="s3">&gt;;</span>
        <span class="s3">}</span>
        <span class="s1">var </span><span class="s3">Buffer</span><span class="s1">: </span><span class="s2">BufferConstructor</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Decodes a string of Base64-encoded data into bytes, and encodes those bytes 
         * into a string using Latin-1 (ISO-8859-1). 
         * 
         * The `data` may be any JavaScript-value that can be coerced into a string. 
         * 
         * **This function is only provided for compatibility with legacy web platform APIs** 
         * **and should never be used in new code, because they use strings to represent** 
         * **binary data and predate the introduction of typed arrays in JavaScript.** 
         * **For code running using Node.js APIs, converting between base64-encoded strings** 
         * **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.** 
         * </span><span class="s1">@since </span><span class="s0">v15.13.0, v14.17.0 
         * </span><span class="s1">@legacy </span><span class="s0">Use `Buffer.from(data, 'base64')` instead. 
         * </span><span class="s1">@param </span><span class="s2">data </span><span class="s0">The Base64-encoded input string. 
         */</span>
        <span class="s1">function </span><span class="s3">atob(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes 
         * into a string using Base64. 
         * 
         * The `data` may be any JavaScript-value that can be coerced into a string. 
         * 
         * **This function is only provided for compatibility with legacy web platform APIs** 
         * **and should never be used in new code, because they use strings to represent** 
         * **binary data and predate the introduction of typed arrays in JavaScript.** 
         * **For code running using Node.js APIs, converting between base64-encoded strings** 
         * **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.** 
         * </span><span class="s1">@since </span><span class="s0">v15.13.0, v14.17.0 
         * </span><span class="s1">@legacy </span><span class="s0">Use `buf.toString('base64')` instead. 
         * </span><span class="s1">@param </span><span class="s2">data </span><span class="s0">An ASCII (Latin1) string. 
         */</span>
        <span class="s1">function </span><span class="s3">btoa(</span><span class="s2">data</span><span class="s1">: </span><span class="s2">string</span><span class="s3">)</span><span class="s1">: </span><span class="s2">string</span><span class="s3">;</span>
        <span class="s1">interface </span><span class="s2">Blob </span><span class="s1">extends </span><span class="s2">__Blob </span><span class="s3">{}</span>
        <span class="s0">/**</span>
         <span class="s0">* `Blob` class is a global reference for `require('node:buffer').Blob` 
         * https://nodejs.org/api/buffer.html#class-blob 
         * </span><span class="s1">@since </span><span class="s0">v18.0.0 
         */</span>
        <span class="s1">var </span><span class="s3">Blob</span><span class="s1">: typeof </span><span class="s2">globalThis extends </span><span class="s3">{</span>
            <span class="s3">onmessage</span><span class="s1">: </span><span class="s2">any</span><span class="s3">;</span>
            <span class="s3">Blob</span><span class="s1">: infer </span><span class="s2">T</span><span class="s3">;</span>
        <span class="s3">}</span>
            <span class="s1">? </span><span class="s2">T</span>
            <span class="s1">: typeof </span><span class="s2">NodeBlob</span><span class="s3">;</span>
    <span class="s3">}</span>
<span class="s3">}</span>
<span class="s1">declare module </span><span class="s4">'node:buffer' </span><span class="s3">{</span>
    <span class="s1">export </span><span class="s6">* </span><span class="s1">from </span><span class="s4">'buffer'</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>
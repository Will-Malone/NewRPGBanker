<html>
<head>
<title>applyDecs2203R.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
applyDecs2203R.js</font>
</center></td></tr></table>
<pre><span class="s0">import _typeof from </span><span class="s1">&quot;./typeof.js&quot;</span><span class="s0">;</span>
<span class="s2">function </span><span class="s0">applyDecs2203RFactory() {</span>
  <span class="s2">function </span><span class="s0">createAddInitializerMethod(initializers, decoratorFinishedRef) {</span>
    <span class="s2">return function </span><span class="s0">(initializer) {</span>
      <span class="s0">!</span><span class="s2">function </span><span class="s0">(decoratorFinishedRef, fnName) {</span>
        <span class="s2">if </span><span class="s0">(decoratorFinishedRef.v) </span><span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;attempted to call &quot; </span><span class="s0">+ fnName + </span><span class="s1">&quot; after decoration was finished&quot;</span><span class="s0">);</span>
      <span class="s0">}(decoratorFinishedRef, </span><span class="s1">&quot;addInitializer&quot;</span><span class="s0">), assertCallable(initializer, </span><span class="s1">&quot;An initializer&quot;</span><span class="s0">), initializers.push(initializer);</span>
    <span class="s0">};</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, value) {</span>
    <span class="s2">var </span><span class="s0">kindStr;</span>
    <span class="s2">switch </span><span class="s0">(kind) {</span>
      <span class="s2">case </span><span class="s3">1</span><span class="s0">:</span>
        <span class="s0">kindStr = </span><span class="s1">&quot;accessor&quot;</span><span class="s0">;</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">2</span><span class="s0">:</span>
        <span class="s0">kindStr = </span><span class="s1">&quot;method&quot;</span><span class="s0">;</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">3</span><span class="s0">:</span>
        <span class="s0">kindStr = </span><span class="s1">&quot;getter&quot;</span><span class="s0">;</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s2">case </span><span class="s3">4</span><span class="s0">:</span>
        <span class="s0">kindStr = </span><span class="s1">&quot;setter&quot;</span><span class="s0">;</span>
        <span class="s2">break</span><span class="s0">;</span>
      <span class="s2">default</span><span class="s0">:</span>
        <span class="s0">kindStr = </span><span class="s1">&quot;field&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">var </span><span class="s0">get,</span>
      <span class="s0">set,</span>
      <span class="s0">ctx = {</span>
        <span class="s0">kind: kindStr,</span>
        <span class="s0">name: isPrivate ? </span><span class="s1">&quot;#&quot; </span><span class="s0">+ name : name,</span>
        <span class="s1">&quot;static&quot;</span><span class="s0">: isStatic,</span>
        <span class="s1">&quot;private&quot;</span><span class="s0">: isPrivate</span>
      <span class="s0">},</span>
      <span class="s0">decoratorFinishedRef = {</span>
        <span class="s0">v: !</span><span class="s3">1</span>
      <span class="s0">};</span>
    <span class="s3">0 </span><span class="s0">!== kind &amp;&amp; (ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef)), </span><span class="s3">0 </span><span class="s0">=== kind ? isPrivate ? (get = desc.get, set = desc.set) : (get = </span><span class="s2">function </span><span class="s0">get() {</span>
      <span class="s2">return this</span><span class="s0">[name];</span>
    <span class="s0">}, set = </span><span class="s2">function </span><span class="s0">set(v) {</span>
      <span class="s2">this</span><span class="s0">[name] = v;</span>
    <span class="s0">}) : </span><span class="s3">2 </span><span class="s0">=== kind ? get = </span><span class="s2">function </span><span class="s0">get() {</span>
      <span class="s2">return </span><span class="s0">desc.value;</span>
    <span class="s0">} : (</span><span class="s3">1 </span><span class="s0">!== kind &amp;&amp; </span><span class="s3">3 </span><span class="s0">!== kind || (get = </span><span class="s2">function </span><span class="s0">get() {</span>
      <span class="s2">return </span><span class="s0">desc.get.call(</span><span class="s2">this</span><span class="s0">);</span>
    <span class="s0">}), </span><span class="s3">1 </span><span class="s0">!== kind &amp;&amp; </span><span class="s3">4 </span><span class="s0">!== kind || (set = </span><span class="s2">function </span><span class="s0">set(v) {</span>
      <span class="s0">desc.set.call(</span><span class="s2">this</span><span class="s0">, v);</span>
    <span class="s0">})), ctx.access = get &amp;&amp; set ? {</span>
      <span class="s0">get: get,</span>
      <span class="s0">set: set</span>
    <span class="s0">} : get ? {</span>
      <span class="s0">get: get</span>
    <span class="s0">} : {</span>
      <span class="s0">set: set</span>
    <span class="s0">};</span>
    <span class="s2">try </span><span class="s0">{</span>
      <span class="s2">return </span><span class="s0">dec(value, ctx);</span>
    <span class="s0">} </span><span class="s2">finally </span><span class="s0">{</span>
      <span class="s0">decoratorFinishedRef.v = !</span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">assertCallable(fn, hint) {</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;function&quot; </span><span class="s0">!= </span><span class="s2">typeof </span><span class="s0">fn) </span><span class="s2">throw new </span><span class="s0">TypeError(hint + </span><span class="s1">&quot; must be a function&quot;</span><span class="s0">);</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">assertValidReturnValue(kind, value) {</span>
    <span class="s2">var </span><span class="s0">type = _typeof(value);</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s3">1 </span><span class="s0">=== kind) {</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s1">&quot;object&quot; </span><span class="s0">!== type || </span><span class="s2">null </span><span class="s0">=== value) </span><span class="s2">throw new </span><span class="s0">TypeError(</span><span class="s1">&quot;accessor decorators must return an object with get, set, or init properties or void 0&quot;</span><span class="s0">);</span>
      <span class="s2">void </span><span class="s3">0 </span><span class="s0">!== value.get &amp;&amp; assertCallable(value.get, </span><span class="s1">&quot;accessor.get&quot;</span><span class="s0">), </span><span class="s2">void </span><span class="s3">0 </span><span class="s0">!== value.set &amp;&amp; assertCallable(value.set, </span><span class="s1">&quot;accessor.set&quot;</span><span class="s0">), </span><span class="s2">void </span><span class="s3">0 </span><span class="s0">!== value.init &amp;&amp; assertCallable(value.init, </span><span class="s1">&quot;accessor.init&quot;</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s2">else if </span><span class="s0">(</span><span class="s1">&quot;function&quot; </span><span class="s0">!== type) {</span>
      <span class="s2">var </span><span class="s0">hint;</span>
      <span class="s2">throw </span><span class="s0">hint = </span><span class="s3">0 </span><span class="s0">=== kind ? </span><span class="s1">&quot;field&quot; </span><span class="s0">: </span><span class="s3">10 </span><span class="s0">=== kind ? </span><span class="s1">&quot;class&quot; </span><span class="s0">: </span><span class="s1">&quot;method&quot;</span><span class="s0">, </span><span class="s2">new </span><span class="s0">TypeError(hint + </span><span class="s1">&quot; decorators must return a function or void 0&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers) {</span>
    <span class="s2">var </span><span class="s0">desc,</span>
      <span class="s0">init,</span>
      <span class="s0">value,</span>
      <span class="s0">newValue,</span>
      <span class="s0">get,</span>
      <span class="s0">set,</span>
      <span class="s0">decs = decInfo[</span><span class="s3">0</span><span class="s0">];</span>
    <span class="s2">if </span><span class="s0">(isPrivate ? desc = </span><span class="s3">0 </span><span class="s0">=== kind || </span><span class="s3">1 </span><span class="s0">=== kind ? {</span>
      <span class="s0">get: decInfo[</span><span class="s3">3</span><span class="s0">],</span>
      <span class="s0">set: decInfo[</span><span class="s3">4</span><span class="s0">]</span>
    <span class="s0">} : </span><span class="s3">3 </span><span class="s0">=== kind ? {</span>
      <span class="s0">get: decInfo[</span><span class="s3">3</span><span class="s0">]</span>
    <span class="s0">} : </span><span class="s3">4 </span><span class="s0">=== kind ? {</span>
      <span class="s0">set: decInfo[</span><span class="s3">3</span><span class="s0">]</span>
    <span class="s0">} : {</span>
      <span class="s0">value: decInfo[</span><span class="s3">3</span><span class="s0">]</span>
    <span class="s0">} : </span><span class="s3">0 </span><span class="s0">!== kind &amp;&amp; (desc = Object.getOwnPropertyDescriptor(base, name)), </span><span class="s3">1 </span><span class="s0">=== kind ? value = {</span>
      <span class="s0">get: desc.get,</span>
      <span class="s0">set: desc.set</span>
    <span class="s0">} : </span><span class="s3">2 </span><span class="s0">=== kind ? value = desc.value : </span><span class="s3">3 </span><span class="s0">=== kind ? value = desc.get : </span><span class="s3">4 </span><span class="s0">=== kind &amp;&amp; (value = desc.set), </span><span class="s1">&quot;function&quot; </span><span class="s0">== </span><span class="s2">typeof </span><span class="s0">decs) </span><span class="s2">void </span><span class="s3">0 </span><span class="s0">!== (newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, value)) &amp;&amp; (assertValidReturnValue(kind, newValue), </span><span class="s3">0 </span><span class="s0">=== kind ? init = newValue : </span><span class="s3">1 </span><span class="s0">=== kind ? (init = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {</span>
      <span class="s0">get: get,</span>
      <span class="s0">set: set</span>
    <span class="s0">}) : value = newValue);</span><span class="s2">else for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = decs.length - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--) {</span>
      <span class="s2">var </span><span class="s0">newInit;</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s2">void </span><span class="s3">0 </span><span class="s0">!== (newValue = memberDec(decs[i], name, desc, initializers, kind, isStatic, isPrivate, value))) assertValidReturnValue(kind, newValue), </span><span class="s3">0 </span><span class="s0">=== kind ? newInit = newValue : </span><span class="s3">1 </span><span class="s0">=== kind ? (newInit = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {</span>
        <span class="s0">get: get,</span>
        <span class="s0">set: set</span>
      <span class="s0">}) : value = newValue, </span><span class="s2">void </span><span class="s3">0 </span><span class="s0">!== newInit &amp;&amp; (</span><span class="s2">void </span><span class="s3">0 </span><span class="s0">=== init ? init = newInit : </span><span class="s1">&quot;function&quot; </span><span class="s0">== </span><span class="s2">typeof </span><span class="s0">init ? init = [init, newInit] : init.push(newInit));</span>
    <span class="s0">}</span>
    <span class="s2">if </span><span class="s0">(</span><span class="s3">0 </span><span class="s0">=== kind || </span><span class="s3">1 </span><span class="s0">=== kind) {</span>
      <span class="s2">if </span><span class="s0">(</span><span class="s2">void </span><span class="s3">0 </span><span class="s0">=== init) init = </span><span class="s2">function </span><span class="s0">init(instance, _init) {</span>
        <span class="s2">return </span><span class="s0">_init;</span>
      <span class="s0">};</span><span class="s2">else if </span><span class="s0">(</span><span class="s1">&quot;function&quot; </span><span class="s0">!= </span><span class="s2">typeof </span><span class="s0">init) {</span>
        <span class="s2">var </span><span class="s0">ownInitializers = init;</span>
        <span class="s0">init = </span><span class="s2">function </span><span class="s0">init(instance, _init2) {</span>
          <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">value = _init2, i = </span><span class="s3">0</span><span class="s0">; i &lt; ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);</span>
          <span class="s2">return </span><span class="s0">value;</span>
        <span class="s0">};</span>
      <span class="s0">} </span><span class="s2">else </span><span class="s0">{</span>
        <span class="s2">var </span><span class="s0">originalInitializer = init;</span>
        <span class="s0">init = </span><span class="s2">function </span><span class="s0">init(instance, _init3) {</span>
          <span class="s2">return </span><span class="s0">originalInitializer.call(instance, _init3);</span>
        <span class="s0">};</span>
      <span class="s0">}</span>
      <span class="s0">ret.push(init);</span>
    <span class="s0">}</span>
    <span class="s3">0 </span><span class="s0">!== kind &amp;&amp; (</span><span class="s3">1 </span><span class="s0">=== kind ? (desc.get = value.get, desc.set = value.set) : </span><span class="s3">2 </span><span class="s0">=== kind ? desc.value = value : </span><span class="s3">3 </span><span class="s0">=== kind ? desc.get = value : </span><span class="s3">4 </span><span class="s0">=== kind &amp;&amp; (desc.set = value), isPrivate ? </span><span class="s3">1 </span><span class="s0">=== kind ? (ret.push(</span><span class="s2">function </span><span class="s0">(instance, args) {</span>
      <span class="s2">return </span><span class="s0">value.get.call(instance, args);</span>
    <span class="s0">}), ret.push(</span><span class="s2">function </span><span class="s0">(instance, args) {</span>
      <span class="s2">return </span><span class="s0">value.set.call(instance, args);</span>
    <span class="s0">})) : </span><span class="s3">2 </span><span class="s0">=== kind ? ret.push(value) : ret.push(</span><span class="s2">function </span><span class="s0">(instance, args) {</span>
      <span class="s2">return </span><span class="s0">value.call(instance, args);</span>
    <span class="s0">}) : Object.defineProperty(base, name, desc));</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">applyMemberDecs(Class, decInfos) {</span>
    <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">protoInitializers, staticInitializers, ret = [], existingProtoNonFields = </span><span class="s2">new </span><span class="s0">Map(), existingStaticNonFields = </span><span class="s2">new </span><span class="s0">Map(), i = </span><span class="s3">0</span><span class="s0">; i &lt; decInfos.length; i++) {</span>
      <span class="s2">var </span><span class="s0">decInfo = decInfos[i];</span>
      <span class="s2">if </span><span class="s0">(Array.isArray(decInfo)) {</span>
        <span class="s2">var </span><span class="s0">base,</span>
          <span class="s0">initializers,</span>
          <span class="s0">kind = decInfo[</span><span class="s3">1</span><span class="s0">],</span>
          <span class="s0">name = decInfo[</span><span class="s3">2</span><span class="s0">],</span>
          <span class="s0">isPrivate = decInfo.length &gt; </span><span class="s3">3</span><span class="s0">,</span>
          <span class="s0">isStatic = kind &gt;= </span><span class="s3">5</span><span class="s0">;</span>
        <span class="s2">if </span><span class="s0">(isStatic ? (base = Class, </span><span class="s3">0 </span><span class="s0">!== (kind -= </span><span class="s3">5</span><span class="s0">) &amp;&amp; (initializers = staticInitializers = staticInitializers || [])) : (base = Class.prototype, </span><span class="s3">0 </span><span class="s0">!== kind &amp;&amp; (initializers = protoInitializers = protoInitializers || [])), </span><span class="s3">0 </span><span class="s0">!== kind &amp;&amp; !isPrivate) {</span>
          <span class="s2">var </span><span class="s0">existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,</span>
            <span class="s0">existingKind = existingNonFields.get(name) || </span><span class="s3">0</span><span class="s0">;</span>
          <span class="s2">if </span><span class="s0">(!</span><span class="s3">0 </span><span class="s0">=== existingKind || </span><span class="s3">3 </span><span class="s0">=== existingKind &amp;&amp; </span><span class="s3">4 </span><span class="s0">!== kind || </span><span class="s3">4 </span><span class="s0">=== existingKind &amp;&amp; </span><span class="s3">3 </span><span class="s0">!== kind) </span><span class="s2">throw new </span><span class="s0">Error(</span><span class="s1">&quot;Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: &quot; </span><span class="s0">+ name);</span>
          <span class="s0">!existingKind &amp;&amp; kind &gt; </span><span class="s3">2 </span><span class="s0">? existingNonFields.set(name, kind) : existingNonFields.set(name, !</span><span class="s3">0</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s2">return </span><span class="s0">pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers), ret;</span>
  <span class="s0">}</span>
  <span class="s2">function </span><span class="s0">pushInitializers(ret, initializers) {</span>
    <span class="s0">initializers &amp;&amp; ret.push(</span><span class="s2">function </span><span class="s0">(instance) {</span>
      <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; initializers.length; i++) initializers[i].call(instance);</span>
      <span class="s2">return </span><span class="s0">instance;</span>
    <span class="s0">});</span>
  <span class="s0">}</span>
  <span class="s2">return function </span><span class="s0">(targetClass, memberDecs, classDecs) {</span>
    <span class="s2">return </span><span class="s0">{</span>
      <span class="s0">e: applyMemberDecs(targetClass, memberDecs),</span>
      <span class="s0">get c() {</span>
        <span class="s2">return function </span><span class="s0">(targetClass, classDecs) {</span>
          <span class="s2">if </span><span class="s0">(classDecs.length &gt; </span><span class="s3">0</span><span class="s0">) {</span>
            <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - </span><span class="s3">1</span><span class="s0">; i &gt;= </span><span class="s3">0</span><span class="s0">; i--) {</span>
              <span class="s2">var </span><span class="s0">decoratorFinishedRef = {</span>
                <span class="s0">v: !</span><span class="s3">1</span>
              <span class="s0">};</span>
              <span class="s2">try </span><span class="s0">{</span>
                <span class="s2">var </span><span class="s0">nextNewClass = classDecs[i](newClass, {</span>
                  <span class="s0">kind: </span><span class="s1">&quot;class&quot;</span><span class="s0">,</span>
                  <span class="s0">name: name,</span>
                  <span class="s0">addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef)</span>
                <span class="s0">});</span>
              <span class="s0">} </span><span class="s2">finally </span><span class="s0">{</span>
                <span class="s0">decoratorFinishedRef.v = !</span><span class="s3">0</span><span class="s0">;</span>
              <span class="s0">}</span>
              <span class="s2">void </span><span class="s3">0 </span><span class="s0">!== nextNewClass &amp;&amp; (assertValidReturnValue(</span><span class="s3">10</span><span class="s0">, nextNewClass), newClass = nextNewClass);</span>
            <span class="s0">}</span>
            <span class="s2">return </span><span class="s0">[newClass, </span><span class="s2">function </span><span class="s0">() {</span>
              <span class="s2">for </span><span class="s0">(</span><span class="s2">var </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; initializers.length; i++) initializers[i].call(newClass);</span>
            <span class="s0">}];</span>
          <span class="s0">}</span>
        <span class="s0">}(targetClass, classDecs);</span>
      <span class="s0">}</span>
    <span class="s0">};</span>
  <span class="s0">};</span>
<span class="s0">}</span>
<span class="s0">export </span><span class="s2">default function </span><span class="s0">applyDecs2203R(targetClass, memberDecs, classDecs) {</span>
  <span class="s2">return </span><span class="s0">(applyDecs2203R = applyDecs2203RFactory())(targetClass, memberDecs, classDecs);</span>
<span class="s0">}</span></pre>
</body>
</html>
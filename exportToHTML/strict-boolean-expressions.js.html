<html>
<head>
<title>strict-boolean-expressions.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
strict-boolean-expressions.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">const tsutils = __importStar(require(</span><span class="s0">&quot;tsutils&quot;</span><span class="s1">));</span>
<span class="s1">const ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s1">const util = __importStar(require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">));</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= util.createRule({</span>
    <span class="s1">name: </span><span class="s0">'strict-boolean-expressions'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
        <span class="s1">hasSuggestions: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Disallow certain types in boolean expressions'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">requiresTypeChecking: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">allowString: { type: </span><span class="s0">'boolean' </span><span class="s1">},</span>
                    <span class="s1">allowNumber: { type: </span><span class="s0">'boolean' </span><span class="s1">},</span>
                    <span class="s1">allowNullableObject: { type: </span><span class="s0">'boolean' </span><span class="s1">},</span>
                    <span class="s1">allowNullableBoolean: { type: </span><span class="s0">'boolean' </span><span class="s1">},</span>
                    <span class="s1">allowNullableString: { type: </span><span class="s0">'boolean' </span><span class="s1">},</span>
                    <span class="s1">allowNullableNumber: { type: </span><span class="s0">'boolean' </span><span class="s1">},</span>
                    <span class="s1">allowNullableEnum: { type: </span><span class="s0">'boolean' </span><span class="s1">},</span>
                    <span class="s1">allowAny: { type: </span><span class="s0">'boolean' </span><span class="s1">},</span>
                    <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {</span>
                        <span class="s1">type: </span><span class="s0">'boolean'</span><span class="s1">,</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
        <span class="s1">messages: {</span>
            <span class="s1">conditionErrorOther: </span><span class="s0">'Unexpected value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'A boolean expression is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorAny: </span><span class="s0">'Unexpected any value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'An explicit comparison or type cast is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullish: </span><span class="s0">'Unexpected nullish value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'The condition is always false.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableBoolean: </span><span class="s0">'Unexpected nullable boolean value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'Please handle the nullish case explicitly.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorString: </span><span class="s0">'Unexpected string value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'An explicit empty string check is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableString: </span><span class="s0">'Unexpected nullable string value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'Please handle the nullish/empty cases explicitly.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNumber: </span><span class="s0">'Unexpected number value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'An explicit zero/NaN check is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableNumber: </span><span class="s0">'Unexpected nullable number value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'Please handle the nullish/zero/NaN cases explicitly.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorObject: </span><span class="s0">'Unexpected object value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'The condition is always true.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableObject: </span><span class="s0">'Unexpected nullable object value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'An explicit null check is required.'</span><span class="s1">,</span>
            <span class="s1">conditionErrorNullableEnum: </span><span class="s0">'Unexpected nullable enum value in conditional. ' </span><span class="s1">+</span>
                <span class="s0">'Please handle the nullish/zero/NaN cases explicitly.'</span><span class="s1">,</span>
            <span class="s1">noStrictNullCheck: </span><span class="s0">'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.'</span><span class="s1">,</span>
            <span class="s1">conditionFixDefaultFalse: </span><span class="s0">'Explicitly treat nullish value the same as false (`value ?? false`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixDefaultEmptyString: </span><span class="s0">'Explicitly treat nullish value the same as an empty string (`value ?? &quot;&quot;`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixDefaultZero: </span><span class="s0">'Explicitly treat nullish value the same as 0 (`value ?? 0`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareNullish: </span><span class="s0">'Change condition to check for null/undefined (`value != null`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCastBoolean: </span><span class="s0">'Explicitly cast value to a boolean (`Boolean(value)`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareTrue: </span><span class="s0">'Change condition to check if true (`value === true`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareFalse: </span><span class="s0">'Change condition to check if false (`value === false`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareStringLength: </span><span class="s0">&quot;Change condition to check string's length (`value.length !== 0`)&quot;</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareEmptyString: </span><span class="s0">'Change condition to check for empty string (`value !== &quot;&quot;`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareZero: </span><span class="s0">'Change condition to check for 0 (`value !== 0`)'</span><span class="s1">,</span>
            <span class="s1">conditionFixCompareNaN: </span><span class="s0">'Change condition to check for NaN (`!Number.isNaN(value)`)'</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s1">allowString: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowNumber: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowNullableObject: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowNullableBoolean: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowNullableString: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowNullableNumber: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowNullableEnum: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">allowAny: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [options]) {</span>
        <span class="s1">const parserServices = util.getParserServices(context);</span>
        <span class="s1">const typeChecker = parserServices.program.getTypeChecker();</span>
        <span class="s1">const compilerOptions = parserServices.program.getCompilerOptions();</span>
        <span class="s1">const sourceCode = context.getSourceCode();</span>
        <span class="s1">const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, </span><span class="s0">'strictNullChecks'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(!isStrictNullChecks &amp;&amp;</span>
            <span class="s1">options.allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">context.report({</span>
                <span class="s1">loc: {</span>
                    <span class="s1">start: { line: </span><span class="s3">0</span><span class="s1">, column: </span><span class="s3">0 </span><span class="s1">},</span>
                    <span class="s1">end: { line: </span><span class="s3">0</span><span class="s1">, column: </span><span class="s3">0 </span><span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">messageId: </span><span class="s0">'noStrictNullCheck'</span><span class="s1">,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">const traversedNodes = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">ConditionalExpression: traverseTestExpression,</span>
            <span class="s1">DoWhileStatement: traverseTestExpression,</span>
            <span class="s1">ForStatement: traverseTestExpression,</span>
            <span class="s1">IfStatement: traverseTestExpression,</span>
            <span class="s1">WhileStatement: traverseTestExpression,</span>
            <span class="s0">'LogicalExpression[operator!=&quot;??&quot;]'</span><span class="s1">: traverseLogicalExpression,</span>
            <span class="s0">'UnaryExpression[operator=&quot;!&quot;]'</span><span class="s1">: traverseUnaryLogicalExpression,</span>
        <span class="s1">};</span>
        <span class="s4">/** 
         * Inspects condition of a test expression. (`if`, `while`, `for`, etc.) 
         */</span>
        <span class="s2">function </span><span class="s1">traverseTestExpression(node) {</span>
            <span class="s2">if </span><span class="s1">(node.test == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">traverseNode(node.test, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Inspects the argument of a unary logical expression (`!`). 
         */</span>
        <span class="s2">function </span><span class="s1">traverseUnaryLogicalExpression(node) {</span>
            <span class="s1">traverseNode(node.argument, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Inspects the arguments of a logical expression (`&amp;&amp;`, `||`). 
         * 
         * If the logical expression is a descendant of a test expression, 
         * the `isCondition` flag should be set to true. 
         * Otherwise, if the logical expression is there on it's own, 
         * it's used for control flow and is not a condition itself. 
         */</span>
        <span class="s2">function </span><span class="s1">traverseLogicalExpression(node, isCondition = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s4">// left argument is always treated as a condition</span>
            <span class="s1">traverseNode(node.left, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s4">// if the logical expression is used for control flow,</span>
            <span class="s4">// then it's right argument is used for it's side effects only</span>
            <span class="s1">traverseNode(node.right, isCondition);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Inspects any node. 
         * 
         * If it's a logical expression then it recursively traverses its arguments. 
         * If it's any other kind of node then it's type is finally checked against the rule, 
         * unless `isCondition` flag is set to false, in which case 
         * it's assumed to be used for side effects only and is skipped. 
         */</span>
        <span class="s2">function </span><span class="s1">traverseNode(node, isCondition) {</span>
            <span class="s4">// prevent checking the same node multiple times</span>
            <span class="s2">if </span><span class="s1">(traversedNodes.has(node)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">traversedNodes.add(node);</span>
            <span class="s4">// for logical operator, we check its operands</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.LogicalExpression &amp;&amp;</span>
                <span class="s1">node.operator !== </span><span class="s0">'??'</span><span class="s1">) {</span>
                <span class="s1">traverseLogicalExpression(node, isCondition);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// skip if node is not a condition</span>
            <span class="s2">if </span><span class="s1">(!isCondition) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">checkNode(node);</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * This function does the actual type check on a node. 
         * It analyzes the type of a node and checks if it is allowed in a boolean context. 
         */</span>
        <span class="s2">function </span><span class="s1">checkNode(node) {</span>
            <span class="s1">const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);</span>
            <span class="s1">const type = util.getConstrainedTypeAtLocation(typeChecker, tsNode);</span>
            <span class="s1">const types = inspectVariantTypes(tsutils.unionTypeParts(type));</span>
            <span class="s1">const is = (...wantedTypes) =&gt; types.size === wantedTypes.length &amp;&amp;</span>
                <span class="s1">wantedTypes.every(type =&gt; types.has(type));</span>
            <span class="s4">// boolean</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'boolean'</span><span class="s1">) || is(</span><span class="s0">'truthy boolean'</span><span class="s1">)) {</span>
                <span class="s4">// boolean is always okay</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// never</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'never'</span><span class="s1">)) {</span>
                <span class="s4">// never is always okay</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// nullish</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">)) {</span>
                <span class="s4">// condition is always false</span>
                <span class="s1">context.report({ node, messageId: </span><span class="s0">'conditionErrorNullish' </span><span class="s1">});</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Known edge case: boolean `true` and nullish values are always valid boolean expressions</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy boolean'</span><span class="s1">)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable boolean</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'boolean'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!options.allowNullableBoolean) {</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!nullableBoolean)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableBoolean'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultFalse'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} ?? </span><span class="s2">false</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareFalse'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} === </span><span class="s2">false</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// if (nullableBoolean)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableBoolean'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultFalse'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} ?? </span><span class="s2">false</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareTrue'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} === </span><span class="s2">true</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Known edge case: truthy primitives and nullish values are always valid boolean expressions</span>
            <span class="s2">if </span><span class="s1">((options.allowNumber &amp;&amp; is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy number'</span><span class="s1">)) ||</span>
                <span class="s1">(options.allowString &amp;&amp; is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy string'</span><span class="s1">))) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// string</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'string'</span><span class="s1">) || is(</span><span class="s0">'truthy string'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!options.allowString) {</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!string)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorString'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareStringLength'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `${code}.length === </span><span class="s3">0</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareEmptyString'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} === </span><span class="s0">&quot;&quot;</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `!Boolean(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// if (string)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorString'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareStringLength'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code}.length &gt; </span><span class="s3">0</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareEmptyString'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} !== </span><span class="s0">&quot;&quot;</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `Boolean(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable string</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!options.allowNullableString) {</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!nullableString)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableString'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} == </span><span class="s2">null</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultEmptyString'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} ?? </span><span class="s0">&quot;&quot;</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `!Boolean(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// if (nullableString)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableString'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} != </span><span class="s2">null</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultEmptyString'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} ?? </span><span class="s0">&quot;&quot;</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `Boolean(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// number</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'number'</span><span class="s1">) || is(</span><span class="s0">'truthy number'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!options.allowNumber) {</span>
                    <span class="s2">if </span><span class="s1">(isArrayLengthExpression(node, typeChecker, parserServices)) {</span>
                        <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                            <span class="s4">// if (!array.length)</span>
                            <span class="s1">context.report({</span>
                                <span class="s1">node,</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionErrorNumber'</span><span class="s1">,</span>
                                <span class="s1">fix: util.getWrappingFixer({</span>
                                    <span class="s1">sourceCode,</span>
                                    <span class="s1">node: node.parent,</span>
                                    <span class="s1">innerNode: node,</span>
                                    <span class="s1">wrap: code =&gt; `${code} === </span><span class="s3">0</span><span class="s1">`,</span>
                                <span class="s1">}),</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// if (array.length)</span>
                            <span class="s1">context.report({</span>
                                <span class="s1">node,</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionErrorNumber'</span><span class="s1">,</span>
                                <span class="s1">fix: util.getWrappingFixer({</span>
                                    <span class="s1">sourceCode,</span>
                                    <span class="s1">node,</span>
                                    <span class="s1">wrap: code =&gt; `${code} &gt; </span><span class="s3">0</span><span class="s1">`,</span>
                                <span class="s1">}),</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!number)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNumber'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareZero'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s4">// TODO: we have to compare to 0n if the type is bigint</span>
                                        <span class="s1">wrap: code =&gt; `${code} === </span><span class="s3">0</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s4">// TODO: don't suggest this for bigint because it can't be NaN</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNaN'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `Number.isNaN(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `!Boolean(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// if (number)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNumber'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareZero'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} !== </span><span class="s3">0</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNaN'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `!Number.isNaN(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `Boolean(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable number</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!options.allowNullableNumber) {</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!nullableNumber)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableNumber'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} == </span><span class="s2">null</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultZero'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} ?? </span><span class="s3">0</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node: node.parent,</span>
                                        <span class="s1">innerNode: node,</span>
                                        <span class="s1">wrap: code =&gt; `!Boolean(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// if (nullableNumber)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableNumber'</span><span class="s1">,</span>
                            <span class="s1">suggest: [</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCompareNullish'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} != </span><span class="s2">null</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixDefaultZero'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `${code} ?? </span><span class="s3">0</span><span class="s1">`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                                <span class="s1">{</span>
                                    <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                    <span class="s1">fix: util.getWrappingFixer({</span>
                                        <span class="s1">sourceCode,</span>
                                        <span class="s1">node,</span>
                                        <span class="s1">wrap: code =&gt; `Boolean(${code})`,</span>
                                    <span class="s1">}),</span>
                                <span class="s1">},</span>
                            <span class="s1">],</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// object</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'object'</span><span class="s1">)) {</span>
                <span class="s4">// condition is always true</span>
                <span class="s1">context.report({ node, messageId: </span><span class="s0">'conditionErrorObject' </span><span class="s1">});</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable object</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'object'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!options.allowNullableObject) {</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s4">// if (!nullableObject)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableObject'</span><span class="s1">,</span>
                            <span class="s1">fix: util.getWrappingFixer({</span>
                                <span class="s1">sourceCode,</span>
                                <span class="s1">node: node.parent,</span>
                                <span class="s1">innerNode: node,</span>
                                <span class="s1">wrap: code =&gt; `${code} == </span><span class="s2">null</span><span class="s1">`,</span>
                            <span class="s1">}),</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s4">// if (nullableObject)</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableObject'</span><span class="s1">,</span>
                            <span class="s1">fix: util.getWrappingFixer({</span>
                                <span class="s1">sourceCode,</span>
                                <span class="s1">node,</span>
                                <span class="s1">wrap: code =&gt; `${code} != </span><span class="s2">null</span><span class="s1">`,</span>
                            <span class="s1">}),</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// nullable enum</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy number'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s4">// mixed enums</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy number'</span><span class="s1">, </span><span class="s0">'truthy string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy number'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'truthy string'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">) ||</span>
                <span class="s1">is(</span><span class="s0">'nullish'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'enum'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!options.allowNullableEnum) {</span>
                    <span class="s2">if </span><span class="s1">(isLogicalNegationExpression(node.parent)) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableEnum'</span><span class="s1">,</span>
                            <span class="s1">fix: util.getWrappingFixer({</span>
                                <span class="s1">sourceCode,</span>
                                <span class="s1">node: node.parent,</span>
                                <span class="s1">innerNode: node,</span>
                                <span class="s1">wrap: code =&gt; `${code} == </span><span class="s2">null</span><span class="s1">`,</span>
                            <span class="s1">}),</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node,</span>
                            <span class="s1">messageId: </span><span class="s0">'conditionErrorNullableEnum'</span><span class="s1">,</span>
                            <span class="s1">fix: util.getWrappingFixer({</span>
                                <span class="s1">sourceCode,</span>
                                <span class="s1">node,</span>
                                <span class="s1">wrap: code =&gt; `${code} != </span><span class="s2">null</span><span class="s1">`,</span>
                            <span class="s1">}),</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// any</span>
            <span class="s2">if </span><span class="s1">(is(</span><span class="s0">'any'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!options.allowAny) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node,</span>
                        <span class="s1">messageId: </span><span class="s0">'conditionErrorAny'</span><span class="s1">,</span>
                        <span class="s1">suggest: [</span>
                            <span class="s1">{</span>
                                <span class="s1">messageId: </span><span class="s0">'conditionFixCastBoolean'</span><span class="s1">,</span>
                                <span class="s1">fix: util.getWrappingFixer({</span>
                                    <span class="s1">sourceCode,</span>
                                    <span class="s1">node,</span>
                                    <span class="s1">wrap: code =&gt; `Boolean(${code})`,</span>
                                <span class="s1">}),</span>
                            <span class="s1">},</span>
                        <span class="s1">],</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// other</span>
            <span class="s1">context.report({ node, messageId: </span><span class="s0">'conditionErrorOther' </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Check union variants for the types we care about 
         */</span>
        <span class="s2">function </span><span class="s1">inspectVariantTypes(types) {</span>
            <span class="s1">const variantTypes = </span><span class="s2">new </span><span class="s1">Set();</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'nullish'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">const booleans = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.BooleanLike));</span>
            <span class="s4">// If incoming type is either &quot;true&quot; or &quot;false&quot;, there will be one type</span>
            <span class="s4">// object with intrinsicName set accordingly</span>
            <span class="s4">// If incoming type is boolean, there will be two type objects with</span>
            <span class="s4">// intrinsicName set &quot;true&quot; and &quot;false&quot; each because of tsutils.unionTypeParts()</span>
            <span class="s2">if </span><span class="s1">(booleans.length === </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">tsutils.isBooleanLiteralType(booleans[</span><span class="s3">0</span><span class="s1">], </span><span class="s2">true</span><span class="s1">)</span>
                    <span class="s1">? variantTypes.add(</span><span class="s0">'truthy boolean'</span><span class="s1">)</span>
                    <span class="s1">: variantTypes.add(</span><span class="s0">'boolean'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(booleans.length === </span><span class="s3">2</span><span class="s1">) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'boolean'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">const strings = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.StringLike));</span>
            <span class="s2">if </span><span class="s1">(strings.length) {</span>
                <span class="s2">if </span><span class="s1">(strings.every(type =&gt; type.isStringLiteral() &amp;&amp; type.value !== </span><span class="s0">''</span><span class="s1">)) {</span>
                    <span class="s1">variantTypes.add(</span><span class="s0">'truthy string'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">variantTypes.add(</span><span class="s0">'string'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">const numbers = types.filter(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike));</span>
            <span class="s2">if </span><span class="s1">(numbers.length) {</span>
                <span class="s2">if </span><span class="s1">(numbers.every(type =&gt; type.isNumberLiteral() &amp;&amp; type.value !== </span><span class="s3">0</span><span class="s1">)) {</span>
                    <span class="s1">variantTypes.add(</span><span class="s0">'truthy number'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">variantTypes.add(</span><span class="s0">'number'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLike))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'enum'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; !tsutils.isTypeFlagSet(type, ts.TypeFlags.Null |</span>
                <span class="s1">ts.TypeFlags.Undefined |</span>
                <span class="s1">ts.TypeFlags.VoidLike |</span>
                <span class="s1">ts.TypeFlags.BooleanLike |</span>
                <span class="s1">ts.TypeFlags.StringLike |</span>
                <span class="s1">ts.TypeFlags.NumberLike |</span>
                <span class="s1">ts.TypeFlags.BigIntLike |</span>
                <span class="s1">ts.TypeFlags.TypeParameter |</span>
                <span class="s1">ts.TypeFlags.Any |</span>
                <span class="s1">ts.TypeFlags.Unknown |</span>
                <span class="s1">ts.TypeFlags.Never))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'object'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; util.isTypeFlagSet(type, ts.TypeFlags.TypeParameter |</span>
                <span class="s1">ts.TypeFlags.Any |</span>
                <span class="s1">ts.TypeFlags.Unknown))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'any'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(types.some(type =&gt; tsutils.isTypeFlagSet(type, ts.TypeFlags.Never))) {</span>
                <span class="s1">variantTypes.add(</span><span class="s0">'never'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">variantTypes;</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">isLogicalNegationExpression(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp; node.operator === </span><span class="s0">'!'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isArrayLengthExpression(node, typeChecker, parserServices) {</span>
    <span class="s2">if </span><span class="s1">(node.type !== utils_1.AST_NODE_TYPES.MemberExpression) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.computed) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.property.name !== </span><span class="s0">'length'</span><span class="s1">) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const objectTsNode = parserServices.esTreeNodeToTSNodeMap.get(node.object);</span>
    <span class="s1">const objectType = util.getConstrainedTypeAtLocation(typeChecker, objectTsNode);</span>
    <span class="s2">return </span><span class="s1">util.isTypeArrayTypeOrUnionOfArrayTypes(objectType, typeChecker);</span>
<span class="s1">}</span>
<span class="s4">//# sourceMappingURL=strict-boolean-expressions.js.map</span></pre>
</body>
</html>
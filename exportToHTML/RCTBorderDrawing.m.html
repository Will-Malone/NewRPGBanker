<html>
<head>
<title>RCTBorderDrawing.m</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTBorderDrawing.m</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&quot;RCTBorderDrawing.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTLog.h&quot;</span>

<span class="s4">static const </span><span class="s1">CGFloat RCTViewBorderThreshold = </span><span class="s5">0.001</span><span class="s4">;</span>

<span class="s1">BOOL RCTBorderInsetsAreEqual(UIEdgeInsets borderInsets)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">ABS(borderInsets.left - borderInsets.right) &lt; RCTViewBorderThreshold &amp;&amp;</span>
      <span class="s1">ABS(borderInsets.left - borderInsets.bottom) &lt; RCTViewBorderThreshold &amp;&amp;</span>
      <span class="s1">ABS(borderInsets.left - borderInsets.top) &lt; RCTViewBorderThreshold</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">BOOL RCTCornerRadiiAreEqual(RCTCornerRadii cornerRadii)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">ABS(cornerRadii.topLeft - cornerRadii.topRight) &lt; RCTViewBorderThreshold &amp;&amp;</span>
      <span class="s1">ABS(cornerRadii.topLeft - cornerRadii.bottomLeft) &lt; RCTViewBorderThreshold &amp;&amp;</span>
      <span class="s1">ABS(cornerRadii.topLeft - cornerRadii.bottomRight) &lt; RCTViewBorderThreshold</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">BOOL RCTBorderColorsAreEqual(RCTBorderColors borderColors)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">CGColorEqualToColor(borderColors.left</span><span class="s4">, </span><span class="s1">borderColors.right) &amp;&amp;</span>
      <span class="s1">CGColorEqualToColor(borderColors.left</span><span class="s4">, </span><span class="s1">borderColors.top) &amp;&amp;</span>
      <span class="s1">CGColorEqualToColor(borderColors.left</span><span class="s4">, </span><span class="s1">borderColors.bottom)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCTCornerInsets RCTGetCornerInsets(RCTCornerRadii cornerRadii</span><span class="s4">, </span><span class="s1">UIEdgeInsets edgeInsets)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">(RCTCornerInsets){</span>
      <span class="s1">{</span>
          <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">cornerRadii.topLeft - edgeInsets.left)</span><span class="s4">,</span>
          <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">cornerRadii.topLeft - edgeInsets.top)</span><span class="s4">,</span>
      <span class="s1">}</span><span class="s4">,</span>
      <span class="s1">{</span>
          <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">cornerRadii.topRight - edgeInsets.right)</span><span class="s4">,</span>
          <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">cornerRadii.topRight - edgeInsets.top)</span><span class="s4">,</span>
      <span class="s1">}</span><span class="s4">,</span>
      <span class="s1">{</span>
          <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">cornerRadii.bottomLeft - edgeInsets.left)</span><span class="s4">,</span>
          <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">cornerRadii.bottomLeft - edgeInsets.bottom)</span><span class="s4">,</span>
      <span class="s1">}</span><span class="s4">,</span>
      <span class="s1">{</span>
          <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">cornerRadii.bottomRight - edgeInsets.right)</span><span class="s4">,</span>
          <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">cornerRadii.bottomRight - edgeInsets.bottom)</span><span class="s4">,</span>
      <span class="s1">}}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">UIEdgeInsets RCTRoundInsetsToPixel(UIEdgeInsets edgeInsets)</span>
<span class="s1">{</span>
  <span class="s1">edgeInsets.top = RCTRoundPixelValue(edgeInsets.top)</span><span class="s4">;</span>
  <span class="s1">edgeInsets.bottom = RCTRoundPixelValue(edgeInsets.bottom)</span><span class="s4">;</span>
  <span class="s1">edgeInsets.left = RCTRoundPixelValue(edgeInsets.left)</span><span class="s4">;</span>
  <span class="s1">edgeInsets.right = RCTRoundPixelValue(edgeInsets.right)</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">edgeInsets</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static void </span><span class="s1">RCTPathAddEllipticArc(</span>
    <span class="s1">CGMutablePathRef path</span><span class="s4">,</span>
    <span class="s4">const </span><span class="s1">CGAffineTransform *m</span><span class="s4">,</span>
    <span class="s1">CGPoint origin</span><span class="s4">,</span>
    <span class="s1">CGSize size</span><span class="s4">,</span>
    <span class="s1">CGFloat startAngle</span><span class="s4">,</span>
    <span class="s1">CGFloat endAngle</span><span class="s4">,</span>
    <span class="s1">BOOL clockwise)</span>
<span class="s1">{</span>
  <span class="s1">CGFloat xScale = </span><span class="s5">1</span><span class="s4">, </span><span class="s1">yScale = </span><span class="s5">1</span><span class="s4">, </span><span class="s1">radius = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(size.width != </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s1">xScale = </span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">yScale = size.height / size.width</span><span class="s4">;</span>
    <span class="s1">radius = size.width</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(size.height != </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s1">xScale = size.width / size.height</span><span class="s4">;</span>
    <span class="s1">yScale = </span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">radius = size.height</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">CGAffineTransform t = CGAffineTransformMakeTranslation(origin.x</span><span class="s4">, </span><span class="s1">origin.y)</span><span class="s4">;</span>
  <span class="s1">t = CGAffineTransformScale(t</span><span class="s4">, </span><span class="s1">xScale</span><span class="s4">, </span><span class="s1">yScale)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(m != NULL) {</span>
    <span class="s1">t = CGAffineTransformConcat(t</span><span class="s4">, </span><span class="s1">*m)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">CGPathAddArc(path</span><span class="s4">, </span><span class="s1">&amp;t</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">radius</span><span class="s4">, </span><span class="s1">startAngle</span><span class="s4">, </span><span class="s1">endAngle</span><span class="s4">, </span><span class="s1">clockwise)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">CGPathRef RCTPathCreateWithRoundedRect(CGRect bounds</span><span class="s4">, </span><span class="s1">RCTCornerInsets cornerInsets</span><span class="s4">, const </span><span class="s1">CGAffineTransform *transform)</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">CGFloat minX = CGRectGetMinX(bounds)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat minY = CGRectGetMinY(bounds)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat maxX = CGRectGetMaxX(bounds)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat maxY = CGRectGetMaxY(bounds)</span><span class="s4">;</span>

  <span class="s4">const </span><span class="s1">CGSize topLeft = {</span>
      <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">MIN(cornerInsets.topLeft.width</span><span class="s4">, </span><span class="s1">bounds.size.width - cornerInsets.topRight.width))</span><span class="s4">,</span>
      <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">MIN(cornerInsets.topLeft.height</span><span class="s4">, </span><span class="s1">bounds.size.height - cornerInsets.bottomLeft.height))</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGSize topRight = {</span>
      <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">MIN(cornerInsets.topRight.width</span><span class="s4">, </span><span class="s1">bounds.size.width - cornerInsets.topLeft.width))</span><span class="s4">,</span>
      <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">MIN(cornerInsets.topRight.height</span><span class="s4">, </span><span class="s1">bounds.size.height - cornerInsets.bottomRight.height))</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGSize bottomLeft = {</span>
      <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">MIN(cornerInsets.bottomLeft.width</span><span class="s4">, </span><span class="s1">bounds.size.width - cornerInsets.bottomRight.width))</span><span class="s4">,</span>
      <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">MIN(cornerInsets.bottomLeft.height</span><span class="s4">, </span><span class="s1">bounds.size.height - cornerInsets.topLeft.height))</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGSize bottomRight = {</span>
      <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">MIN(cornerInsets.bottomRight.width</span><span class="s4">, </span><span class="s1">bounds.size.width - cornerInsets.bottomLeft.width))</span><span class="s4">,</span>
      <span class="s1">MAX(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">MIN(cornerInsets.bottomRight.height</span><span class="s4">, </span><span class="s1">bounds.size.height - cornerInsets.topRight.height))</span><span class="s4">,</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s1">CGMutablePathRef path = CGPathCreateMutable()</span><span class="s4">;</span>
  <span class="s1">RCTPathAddEllipticArc(</span>
      <span class="s1">path</span><span class="s4">, </span><span class="s1">transform</span><span class="s4">, </span><span class="s1">(CGPoint){minX + topLeft.width</span><span class="s4">, </span><span class="s1">minY + topLeft.height}</span><span class="s4">, </span><span class="s1">topLeft</span><span class="s4">, </span><span class="s1">M_PI</span><span class="s4">, </span><span class="s5">3 </span><span class="s1">* M_PI_2</span><span class="s4">, </span><span class="s1">NO)</span><span class="s4">;</span>
  <span class="s1">RCTPathAddEllipticArc(</span>
      <span class="s1">path</span><span class="s4">, </span><span class="s1">transform</span><span class="s4">, </span><span class="s1">(CGPoint){maxX - topRight.width</span><span class="s4">, </span><span class="s1">minY + topRight.height}</span><span class="s4">, </span><span class="s1">topRight</span><span class="s4">, </span><span class="s5">3 </span><span class="s1">* M_PI_2</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">NO)</span><span class="s4">;</span>
  <span class="s1">RCTPathAddEllipticArc(</span>
      <span class="s1">path</span><span class="s4">, </span><span class="s1">transform</span><span class="s4">, </span><span class="s1">(CGPoint){maxX - bottomRight.width</span><span class="s4">, </span><span class="s1">maxY - bottomRight.height}</span><span class="s4">, </span><span class="s1">bottomRight</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">M_PI_2</span><span class="s4">, </span><span class="s1">NO)</span><span class="s4">;</span>
  <span class="s1">RCTPathAddEllipticArc(</span>
      <span class="s1">path</span><span class="s4">, </span><span class="s1">transform</span><span class="s4">, </span><span class="s1">(CGPoint){minX + bottomLeft.width</span><span class="s4">, </span><span class="s1">maxY - bottomLeft.height}</span><span class="s4">, </span><span class="s1">bottomLeft</span><span class="s4">, </span><span class="s1">M_PI_2</span><span class="s4">, </span><span class="s1">M_PI</span><span class="s4">, </span><span class="s1">NO)</span><span class="s4">;</span>
  <span class="s1">CGPathCloseSubpath(path)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">path</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static void</span>
<span class="s1">RCTEllipseGetIntersectionsWithLine(CGRect ellipseBounds</span><span class="s4">, </span><span class="s1">CGPoint lineStart</span><span class="s4">, </span><span class="s1">CGPoint lineEnd</span><span class="s4">, </span><span class="s1">CGPoint intersections[</span><span class="s5">2</span><span class="s1">])</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">CGPoint ellipseCenter = {CGRectGetMidX(ellipseBounds)</span><span class="s4">, </span><span class="s1">CGRectGetMidY(ellipseBounds)}</span><span class="s4">;</span>

  <span class="s1">lineStart.x -= ellipseCenter.x</span><span class="s4">;</span>
  <span class="s1">lineStart.y -= ellipseCenter.y</span><span class="s4">;</span>
  <span class="s1">lineEnd.x -= ellipseCenter.x</span><span class="s4">;</span>
  <span class="s1">lineEnd.y -= ellipseCenter.y</span><span class="s4">;</span>

  <span class="s4">const </span><span class="s1">CGFloat m = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat a = ellipseBounds.size.width / </span><span class="s5">2</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat b = ellipseBounds.size.height / </span><span class="s5">2</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat c = lineStart.y - m * lineStart.x</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat A = (b * b + a * a * m * m)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat B = </span><span class="s5">2 </span><span class="s1">* a * a * c * m</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat D = sqrt((a * a * (b * b - c * c)) / A + pow(B / (</span><span class="s5">2 </span><span class="s1">* A)</span><span class="s4">, </span><span class="s5">2</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s4">const </span><span class="s1">CGFloat x_ = -B / (</span><span class="s5">2 </span><span class="s1">* A)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat x1 = x_ + D</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat x2 = x_ - D</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat y1 = m * x1 + c</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">CGFloat y2 = m * x2 + c</span><span class="s4">;</span>

  <span class="s1">intersections[</span><span class="s5">0</span><span class="s1">] = (CGPoint){x1 + ellipseCenter.x</span><span class="s4">, </span><span class="s1">y1 + ellipseCenter.y}</span><span class="s4">;</span>
  <span class="s1">intersections[</span><span class="s5">1</span><span class="s1">] = (CGPoint){x2 + ellipseCenter.x</span><span class="s4">, </span><span class="s1">y2 + ellipseCenter.y}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">NS_INLINE BOOL RCTCornerRadiiAreAboveThreshold(RCTCornerRadii cornerRadii)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">(</span>
      <span class="s1">cornerRadii.topLeft &gt; RCTViewBorderThreshold || cornerRadii.topRight &gt; RCTViewBorderThreshold ||</span>
      <span class="s1">cornerRadii.bottomLeft &gt; RCTViewBorderThreshold || cornerRadii.bottomRight &gt; RCTViewBorderThreshold)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">CGPathRef RCTPathCreateOuterOutline(BOOL drawToEdge</span><span class="s4">, </span><span class="s1">CGRect rect</span><span class="s4">, </span><span class="s1">RCTCornerRadii cornerRadii)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(drawToEdge) {</span>
    <span class="s4">return </span><span class="s1">CGPathCreateWithRect(rect</span><span class="s4">, </span><span class="s1">NULL)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">RCTPathCreateWithRoundedRect(rect</span><span class="s4">, </span><span class="s1">RCTGetCornerInsets(cornerRadii</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)</span><span class="s4">, </span><span class="s1">NULL)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">UIGraphicsImageRenderer *</span>
<span class="s1">RCTUIGraphicsImageRenderer(CGSize size</span><span class="s4">, </span><span class="s1">CGColorRef backgroundColor</span><span class="s4">, </span><span class="s1">BOOL hasCornerRadii</span><span class="s4">, </span><span class="s1">BOOL drawToEdge)</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">CGFloat alpha = CGColorGetAlpha(backgroundColor)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">BOOL opaque = (drawToEdge || !hasCornerRadii) &amp;&amp; alpha == </span><span class="s5">1.0</span><span class="s4">;</span>
  <span class="s1">UIGraphicsImageRendererFormat *</span><span class="s4">const </span><span class="s1">rendererFormat = [UIGraphicsImageRendererFormat defaultFormat]</span><span class="s4">;</span>
  <span class="s1">rendererFormat.opaque = opaque</span><span class="s4">;</span>
  <span class="s1">UIGraphicsImageRenderer *</span><span class="s4">const </span><span class="s1">renderer = [[UIGraphicsImageRenderer alloc] initWithSize:size format:rendererFormat]</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">renderer</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">UIImage *RCTGetSolidBorderImage(</span>
    <span class="s1">RCTCornerRadii cornerRadii</span><span class="s4">,</span>
    <span class="s1">CGSize viewSize</span><span class="s4">,</span>
    <span class="s1">UIEdgeInsets borderInsets</span><span class="s4">,</span>
    <span class="s1">RCTBorderColors borderColors</span><span class="s4">,</span>
    <span class="s1">CGColorRef backgroundColor</span><span class="s4">,</span>
    <span class="s1">BOOL drawToEdge)</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">BOOL hasCornerRadii = RCTCornerRadiiAreAboveThreshold(cornerRadii)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">RCTCornerInsets cornerInsets = RCTGetCornerInsets(cornerRadii</span><span class="s4">, </span><span class="s1">borderInsets)</span><span class="s4">;</span>

  <span class="s0">// Incorrect render for borders that are not proportional to device pixel: borders get stretched and become</span>
  <span class="s0">// significantly bigger than expected.</span>
  <span class="s0">// Rdar: http://www.openradar.me/15959788</span>
  <span class="s1">borderInsets = RCTRoundInsetsToPixel(borderInsets)</span><span class="s4">;</span>

  <span class="s4">const </span><span class="s1">BOOL makeStretchable =</span>
      <span class="s1">(borderInsets.left + cornerInsets.topLeft.width + borderInsets.right + cornerInsets.bottomRight.width &lt;=</span>
       <span class="s1">viewSize.width) &amp;&amp;</span>
      <span class="s1">(borderInsets.left + cornerInsets.bottomLeft.width + borderInsets.right + cornerInsets.topRight.width &lt;=</span>
       <span class="s1">viewSize.width) &amp;&amp;</span>
      <span class="s1">(borderInsets.top + cornerInsets.topLeft.height + borderInsets.bottom + cornerInsets.bottomRight.height &lt;=</span>
       <span class="s1">viewSize.height) &amp;&amp;</span>
      <span class="s1">(borderInsets.top + cornerInsets.topRight.height + borderInsets.bottom + cornerInsets.bottomLeft.height &lt;=</span>
       <span class="s1">viewSize.height)</span><span class="s4">;</span>

  <span class="s1">UIEdgeInsets edgeInsets = (UIEdgeInsets){</span>
      <span class="s1">borderInsets.top + MAX(cornerInsets.topLeft.height</span><span class="s4">, </span><span class="s1">cornerInsets.topRight.height)</span><span class="s4">,</span>
      <span class="s1">borderInsets.left + MAX(cornerInsets.topLeft.width</span><span class="s4">, </span><span class="s1">cornerInsets.bottomLeft.width)</span><span class="s4">,</span>
      <span class="s1">borderInsets.bottom + MAX(cornerInsets.bottomLeft.height</span><span class="s4">, </span><span class="s1">cornerInsets.bottomRight.height)</span><span class="s4">,</span>
      <span class="s1">borderInsets.right + MAX(cornerInsets.bottomRight.width</span><span class="s4">, </span><span class="s1">cornerInsets.topRight.width)}</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(hasCornerRadii) {</span>
    <span class="s0">// Asymmetrical edgeInsets cause strange artifacting on iOS 10 and earlier.</span>
    <span class="s1">edgeInsets = (UIEdgeInsets){</span>
        <span class="s1">MAX(edgeInsets.top</span><span class="s4">, </span><span class="s1">edgeInsets.bottom)</span><span class="s4">,</span>
        <span class="s1">MAX(edgeInsets.left</span><span class="s4">, </span><span class="s1">edgeInsets.right)</span><span class="s4">,</span>
        <span class="s1">MAX(edgeInsets.top</span><span class="s4">, </span><span class="s1">edgeInsets.bottom)</span><span class="s4">,</span>
        <span class="s1">MAX(edgeInsets.left</span><span class="s4">, </span><span class="s1">edgeInsets.right)</span><span class="s4">,</span>
    <span class="s1">}</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">const </span><span class="s1">CGSize size = makeStretchable ? (CGSize){</span>
    <span class="s0">// 1pt for the middle stretchable area along each axis</span>
    <span class="s1">edgeInsets.left + </span><span class="s5">1 </span><span class="s1">+ edgeInsets.right</span><span class="s4">,</span>
    <span class="s1">edgeInsets.top + </span><span class="s5">1 </span><span class="s1">+ edgeInsets.bottom</span>
  <span class="s1">} : viewSize</span><span class="s4">;</span>

  <span class="s1">UIGraphicsImageRenderer *</span><span class="s4">const </span><span class="s1">imageRenderer =</span>
      <span class="s1">RCTUIGraphicsImageRenderer(size</span><span class="s4">, </span><span class="s1">backgroundColor</span><span class="s4">, </span><span class="s1">hasCornerRadii</span><span class="s4">, </span><span class="s1">drawToEdge)</span><span class="s4">;</span>
  <span class="s1">UIImage *image = [imageRenderer imageWithActions:^(UIGraphicsImageRendererContext *</span><span class="s4">_Nonnull </span><span class="s1">rendererContext) {</span>
    <span class="s4">const </span><span class="s1">CGContextRef context = rendererContext.CGContext</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGRect rect = {.size = size}</span><span class="s4">;</span>
    <span class="s1">CGPathRef path = RCTPathCreateOuterOutline(drawToEdge</span><span class="s4">, </span><span class="s1">rect</span><span class="s4">, </span><span class="s1">cornerRadii)</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(backgroundColor) {</span>
      <span class="s1">CGContextSetFillColorWithColor(context</span><span class="s4">, </span><span class="s1">backgroundColor)</span><span class="s4">;</span>
      <span class="s1">CGContextAddPath(context</span><span class="s4">, </span><span class="s1">path)</span><span class="s4">;</span>
      <span class="s1">CGContextFillPath(context)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">CGContextAddPath(context</span><span class="s4">, </span><span class="s1">path)</span><span class="s4">;</span>
    <span class="s1">CGPathRelease(path)</span><span class="s4">;</span>

    <span class="s1">CGPathRef insetPath = RCTPathCreateWithRoundedRect(UIEdgeInsetsInsetRect(rect</span><span class="s4">, </span><span class="s1">borderInsets)</span><span class="s4">, </span><span class="s1">cornerInsets</span><span class="s4">, </span><span class="s1">NULL)</span><span class="s4">;</span>

    <span class="s1">CGContextAddPath(context</span><span class="s4">, </span><span class="s1">insetPath)</span><span class="s4">;</span>
    <span class="s1">CGContextEOClip(context)</span><span class="s4">;</span>

    <span class="s1">BOOL hasEqualColors = RCTBorderColorsAreEqual(borderColors)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">((drawToEdge || !hasCornerRadii) &amp;&amp; hasEqualColors) {</span>
      <span class="s1">CGContextSetFillColorWithColor(context</span><span class="s4">, </span><span class="s1">borderColors.left)</span><span class="s4">;</span>
      <span class="s1">CGContextAddRect(context</span><span class="s4">, </span><span class="s1">rect)</span><span class="s4">;</span>
      <span class="s1">CGContextAddPath(context</span><span class="s4">, </span><span class="s1">insetPath)</span><span class="s4">;</span>
      <span class="s1">CGContextEOFillPath(context)</span><span class="s4">;</span>

    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">CGPoint topLeft = (CGPoint){borderInsets.left</span><span class="s4">, </span><span class="s1">borderInsets.top}</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(cornerInsets.topLeft.width &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; cornerInsets.topLeft.height &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">CGPoint points[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">RCTEllipseGetIntersectionsWithLine(</span>
            <span class="s1">(CGRect){topLeft</span><span class="s4">, </span><span class="s1">{</span><span class="s5">2 </span><span class="s1">* cornerInsets.topLeft.width</span><span class="s4">, </span><span class="s5">2 </span><span class="s1">* cornerInsets.topLeft.height}}</span><span class="s4">,</span>
            <span class="s1">CGPointZero</span><span class="s4">,</span>
            <span class="s1">topLeft</span><span class="s4">,</span>
            <span class="s1">points)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(!isnan(points[</span><span class="s5">1</span><span class="s1">].x) &amp;&amp; !isnan(points[</span><span class="s5">1</span><span class="s1">].y)) {</span>
          <span class="s1">topLeft = points[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">CGPoint bottomLeft = (CGPoint){borderInsets.left</span><span class="s4">, </span><span class="s1">size.height - borderInsets.bottom}</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(cornerInsets.bottomLeft.width &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; cornerInsets.bottomLeft.height &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">CGPoint points[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">RCTEllipseGetIntersectionsWithLine(</span>
            <span class="s1">(CGRect){</span>
                <span class="s1">{bottomLeft.x</span><span class="s4">, </span><span class="s1">bottomLeft.y - </span><span class="s5">2 </span><span class="s1">* cornerInsets.bottomLeft.height}</span><span class="s4">,</span>
                <span class="s1">{</span><span class="s5">2 </span><span class="s1">* cornerInsets.bottomLeft.width</span><span class="s4">, </span><span class="s5">2 </span><span class="s1">* cornerInsets.bottomLeft.height}}</span><span class="s4">,</span>
            <span class="s1">(CGPoint){</span><span class="s5">0</span><span class="s4">, </span><span class="s1">size.height}</span><span class="s4">,</span>
            <span class="s1">bottomLeft</span><span class="s4">,</span>
            <span class="s1">points)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(!isnan(points[</span><span class="s5">1</span><span class="s1">].x) &amp;&amp; !isnan(points[</span><span class="s5">1</span><span class="s1">].y)) {</span>
          <span class="s1">bottomLeft = points[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">CGPoint topRight = (CGPoint){size.width - borderInsets.right</span><span class="s4">, </span><span class="s1">borderInsets.top}</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(cornerInsets.topRight.width &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; cornerInsets.topRight.height &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">CGPoint points[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">RCTEllipseGetIntersectionsWithLine(</span>
            <span class="s1">(CGRect){</span>
                <span class="s1">{topRight.x - </span><span class="s5">2 </span><span class="s1">* cornerInsets.topRight.width</span><span class="s4">, </span><span class="s1">topRight.y}</span><span class="s4">,</span>
                <span class="s1">{</span><span class="s5">2 </span><span class="s1">* cornerInsets.topRight.width</span><span class="s4">, </span><span class="s5">2 </span><span class="s1">* cornerInsets.topRight.height}}</span><span class="s4">,</span>
            <span class="s1">(CGPoint){size.width</span><span class="s4">, </span><span class="s5">0</span><span class="s1">}</span><span class="s4">,</span>
            <span class="s1">topRight</span><span class="s4">,</span>
            <span class="s1">points)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(!isnan(points[</span><span class="s5">0</span><span class="s1">].x) &amp;&amp; !isnan(points[</span><span class="s5">0</span><span class="s1">].y)) {</span>
          <span class="s1">topRight = points[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">CGPoint bottomRight = (CGPoint){size.width - borderInsets.right</span><span class="s4">, </span><span class="s1">size.height - borderInsets.bottom}</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(cornerInsets.bottomRight.width &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; cornerInsets.bottomRight.height &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">CGPoint points[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">RCTEllipseGetIntersectionsWithLine(</span>
            <span class="s1">(CGRect){</span>
                <span class="s1">{bottomRight.x - </span><span class="s5">2 </span><span class="s1">* cornerInsets.bottomRight.width</span><span class="s4">,</span>
                 <span class="s1">bottomRight.y - </span><span class="s5">2 </span><span class="s1">* cornerInsets.bottomRight.height}</span><span class="s4">,</span>
                <span class="s1">{</span><span class="s5">2 </span><span class="s1">* cornerInsets.bottomRight.width</span><span class="s4">, </span><span class="s5">2 </span><span class="s1">* cornerInsets.bottomRight.height}}</span><span class="s4">,</span>
            <span class="s1">(CGPoint){size.width</span><span class="s4">, </span><span class="s1">size.height}</span><span class="s4">,</span>
            <span class="s1">bottomRight</span><span class="s4">,</span>
            <span class="s1">points)</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(!isnan(points[</span><span class="s5">0</span><span class="s1">].x) &amp;&amp; !isnan(points[</span><span class="s5">0</span><span class="s1">].y)) {</span>
          <span class="s1">bottomRight = points[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">CGColorRef currentColor = NULL</span><span class="s4">;</span>

      <span class="s0">// RIGHT</span>
      <span class="s4">if </span><span class="s1">(borderInsets.right &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s4">const </span><span class="s1">CGPoint points[] = {</span>
            <span class="s1">(CGPoint){size.width</span><span class="s4">, </span><span class="s5">0</span><span class="s1">}</span><span class="s4">,</span>
            <span class="s1">topRight</span><span class="s4">,</span>
            <span class="s1">bottomRight</span><span class="s4">,</span>
            <span class="s1">(CGPoint){size.width</span><span class="s4">, </span><span class="s1">size.height}</span><span class="s4">,</span>
        <span class="s1">}</span><span class="s4">;</span>

        <span class="s1">currentColor = borderColors.right</span><span class="s4">;</span>
        <span class="s1">CGContextAddLines(context</span><span class="s4">, </span><span class="s1">points</span><span class="s4">, sizeof</span><span class="s1">(points) / </span><span class="s4">sizeof</span><span class="s1">(*points))</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s0">// BOTTOM</span>
      <span class="s4">if </span><span class="s1">(borderInsets.bottom &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s4">const </span><span class="s1">CGPoint points[] = {</span>
            <span class="s1">(CGPoint){</span><span class="s5">0</span><span class="s4">, </span><span class="s1">size.height}</span><span class="s4">,</span>
            <span class="s1">bottomLeft</span><span class="s4">,</span>
            <span class="s1">bottomRight</span><span class="s4">,</span>
            <span class="s1">(CGPoint){size.width</span><span class="s4">, </span><span class="s1">size.height}</span><span class="s4">,</span>
        <span class="s1">}</span><span class="s4">;</span>

        <span class="s4">if </span><span class="s1">(!CGColorEqualToColor(currentColor</span><span class="s4">, </span><span class="s1">borderColors.bottom)) {</span>
          <span class="s1">CGContextSetFillColorWithColor(context</span><span class="s4">, </span><span class="s1">currentColor)</span><span class="s4">;</span>
          <span class="s1">CGContextFillPath(context)</span><span class="s4">;</span>
          <span class="s1">currentColor = borderColors.bottom</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s1">CGContextAddLines(context</span><span class="s4">, </span><span class="s1">points</span><span class="s4">, sizeof</span><span class="s1">(points) / </span><span class="s4">sizeof</span><span class="s1">(*points))</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s0">// LEFT</span>
      <span class="s4">if </span><span class="s1">(borderInsets.left &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s4">const </span><span class="s1">CGPoint points[] = {</span>
            <span class="s1">CGPointZero</span><span class="s4">,</span>
            <span class="s1">topLeft</span><span class="s4">,</span>
            <span class="s1">bottomLeft</span><span class="s4">,</span>
            <span class="s1">(CGPoint){</span><span class="s5">0</span><span class="s4">, </span><span class="s1">size.height}</span><span class="s4">,</span>
        <span class="s1">}</span><span class="s4">;</span>

        <span class="s4">if </span><span class="s1">(!CGColorEqualToColor(currentColor</span><span class="s4">, </span><span class="s1">borderColors.left)) {</span>
          <span class="s1">CGContextSetFillColorWithColor(context</span><span class="s4">, </span><span class="s1">currentColor)</span><span class="s4">;</span>
          <span class="s1">CGContextFillPath(context)</span><span class="s4">;</span>
          <span class="s1">currentColor = borderColors.left</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s1">CGContextAddLines(context</span><span class="s4">, </span><span class="s1">points</span><span class="s4">, sizeof</span><span class="s1">(points) / </span><span class="s4">sizeof</span><span class="s1">(*points))</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s0">// TOP</span>
      <span class="s4">if </span><span class="s1">(borderInsets.top &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s4">const </span><span class="s1">CGPoint points[] = {</span>
            <span class="s1">CGPointZero</span><span class="s4">,</span>
            <span class="s1">topLeft</span><span class="s4">,</span>
            <span class="s1">topRight</span><span class="s4">,</span>
            <span class="s1">(CGPoint){size.width</span><span class="s4">, </span><span class="s5">0</span><span class="s1">}</span><span class="s4">,</span>
        <span class="s1">}</span><span class="s4">;</span>

        <span class="s4">if </span><span class="s1">(!CGColorEqualToColor(currentColor</span><span class="s4">, </span><span class="s1">borderColors.top)) {</span>
          <span class="s1">CGContextSetFillColorWithColor(context</span><span class="s4">, </span><span class="s1">currentColor)</span><span class="s4">;</span>
          <span class="s1">CGContextFillPath(context)</span><span class="s4">;</span>
          <span class="s1">currentColor = borderColors.top</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s1">CGContextAddLines(context</span><span class="s4">, </span><span class="s1">points</span><span class="s4">, sizeof</span><span class="s1">(points) / </span><span class="s4">sizeof</span><span class="s1">(*points))</span><span class="s4">;</span>
      <span class="s1">}</span>

      <span class="s1">CGContextSetFillColorWithColor(context</span><span class="s4">, </span><span class="s1">currentColor)</span><span class="s4">;</span>
      <span class="s1">CGContextFillPath(context)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">CGPathRelease(insetPath)</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(makeStretchable) {</span>
    <span class="s1">image = [image resizableImageWithCapInsets:edgeInsets]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">image</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">// Currently, the dashed / dotted implementation only supports a single colour +</span>
<span class="s0">// single width, as that's currently required and supported on Android.</span>
<span class="s0">//</span>
<span class="s0">// Supporting individual widths + colours on each side is possible by modifying</span>
<span class="s0">// the current implementation. The idea is that we will draw four different lines</span>
<span class="s0">// and clip appropriately for each side (might require adjustment of phase so that</span>
<span class="s0">// they line up but even browsers don't do a good job at that).</span>
<span class="s0">//</span>
<span class="s0">// Firstly, create two paths for the outer and inner paths. The inner path is</span>
<span class="s0">// generated exactly the same way as the outer, just given an inset rect, derived</span>
<span class="s0">// from the insets on each side. Then clip using the odd-even rule</span>
<span class="s0">// (CGContextEOClip()). This will give us a nice rounded (possibly) clip mask.</span>
<span class="s0">//</span>
<span class="s0">// +----------------------------------+</span>
<span class="s0">// |@@@@@@@@  Clipped Space  @@@@@@@@@|</span>
<span class="s0">// |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|</span>
<span class="s0">// |@@+----------------------+@@@@@@@@|</span>
<span class="s0">// |@@|                      |@@@@@@@@|</span>
<span class="s0">// |@@|                      |@@@@@@@@|</span>
<span class="s0">// |@@|                      |@@@@@@@@|</span>
<span class="s0">// |@@+----------------------+@@@@@@@@|</span>
<span class="s0">// |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|</span>
<span class="s0">// +----------------------------------+</span>
<span class="s0">//</span>
<span class="s0">// Afterwards, we create a clip path for each border side (CGContextSaveGState()</span>
<span class="s0">// and CGContextRestoreGState() when drawing each side). The clip mask for each</span>
<span class="s0">// segment is a trapezoid connecting corresponding edges of the inner and outer</span>
<span class="s0">// rects. For example, in the case of the top edge, the points would be:</span>
<span class="s0">// - (MinX(outer), MinY(outer))</span>
<span class="s0">// - (MaxX(outer), MinY(outer))</span>
<span class="s0">// - (MinX(inner) + topLeftRadius, MinY(inner) + topLeftRadius)</span>
<span class="s0">// - (MaxX(inner) - topRightRadius, MinY(inner) + topRightRadius)</span>
<span class="s0">//</span>
<span class="s0">//         +------------------+</span>
<span class="s0">//         |\                /|</span>
<span class="s0">//         | \              / |</span>
<span class="s0">//         |  \    top     /  |</span>
<span class="s0">//         |   \          /   |</span>
<span class="s0">//         |    \        /    |</span>
<span class="s0">//         |     +------+     |</span>
<span class="s0">//         |     |      |     |</span>
<span class="s0">//         |     |      |     |</span>
<span class="s0">//         |     |      |     |</span>
<span class="s0">//         |left |      |right|</span>
<span class="s0">//         |     |      |     |</span>
<span class="s0">//         |     |      |     |</span>
<span class="s0">//         |     +------+     |</span>
<span class="s0">//         |    /        \    |</span>
<span class="s0">//         |   /          \   |</span>
<span class="s0">//         |  /            \  |</span>
<span class="s0">//         | /    bottom    \ |</span>
<span class="s0">//         |/                \|</span>
<span class="s0">//         +------------------+</span>
<span class="s0">//</span>
<span class="s0">//</span>
<span class="s0">// Note that this approach will produce discontinuous colour changes at the edge</span>
<span class="s0">// (which is okay). The reason is that Quartz does not currently support drawing</span>
<span class="s0">// of gradients _along_ a path (NB: clipping a path and drawing a linear gradient</span>
<span class="s0">// is _not_ equivalent).</span>

<span class="s4">static </span><span class="s1">UIImage *RCTGetDashedOrDottedBorderImage(</span>
    <span class="s1">RCTBorderStyle borderStyle</span><span class="s4">,</span>
    <span class="s1">RCTCornerRadii cornerRadii</span><span class="s4">,</span>
    <span class="s1">CGSize viewSize</span><span class="s4">,</span>
    <span class="s1">UIEdgeInsets borderInsets</span><span class="s4">,</span>
    <span class="s1">RCTBorderColors borderColors</span><span class="s4">,</span>
    <span class="s1">CGColorRef backgroundColor</span><span class="s4">,</span>
    <span class="s1">BOOL drawToEdge)</span>
<span class="s1">{</span>
  <span class="s1">NSCParameterAssert(borderStyle == RCTBorderStyleDashed || borderStyle == RCTBorderStyleDotted)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!RCTBorderColorsAreEqual(borderColors) || !RCTBorderInsetsAreEqual(borderInsets)) {</span>
    <span class="s1">RCTLogWarn(</span><span class="s4">@</span><span class="s3">&quot;Unsupported dashed / dotted border style&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">const </span><span class="s1">CGFloat lineWidth = borderInsets.top</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(lineWidth &lt;= </span><span class="s5">0.0</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">const </span><span class="s1">BOOL hasCornerRadii = RCTCornerRadiiAreAboveThreshold(cornerRadii)</span><span class="s4">;</span>
  <span class="s1">UIGraphicsImageRenderer *</span><span class="s4">const </span><span class="s1">imageRenderer =</span>
      <span class="s1">RCTUIGraphicsImageRenderer(viewSize</span><span class="s4">, </span><span class="s1">backgroundColor</span><span class="s4">, </span><span class="s1">hasCornerRadii</span><span class="s4">, </span><span class="s1">drawToEdge)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">[imageRenderer imageWithActions:^(UIGraphicsImageRendererContext *</span><span class="s4">_Nonnull </span><span class="s1">rendererContext) {</span>
    <span class="s4">const </span><span class="s1">CGContextRef context = rendererContext.CGContext</span><span class="s4">;</span>
    <span class="s4">const </span><span class="s1">CGRect rect = {.size = viewSize}</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(backgroundColor) {</span>
      <span class="s1">CGPathRef outerPath = RCTPathCreateOuterOutline(drawToEdge</span><span class="s4">, </span><span class="s1">rect</span><span class="s4">, </span><span class="s1">cornerRadii)</span><span class="s4">;</span>
      <span class="s1">CGContextAddPath(context</span><span class="s4">, </span><span class="s1">outerPath)</span><span class="s4">;</span>
      <span class="s1">CGPathRelease(outerPath)</span><span class="s4">;</span>

      <span class="s1">CGContextSetFillColorWithColor(context</span><span class="s4">, </span><span class="s1">backgroundColor)</span><span class="s4">;</span>
      <span class="s1">CGContextFillPath(context)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s0">// Stroking means that the width is divided in half and grows in both directions</span>
    <span class="s0">// perpendicular to the path, that's why we inset by half the width, so that it</span>
    <span class="s0">// reaches the edge of the rect.</span>
    <span class="s1">CGRect pathRect = CGRectInset(rect</span><span class="s4">, </span><span class="s1">lineWidth / </span><span class="s5">2.0</span><span class="s4">, </span><span class="s1">lineWidth / </span><span class="s5">2.0</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">CGPathRef path = RCTPathCreateWithRoundedRect(pathRect</span><span class="s4">, </span><span class="s1">RCTGetCornerInsets(cornerRadii</span><span class="s4">, </span><span class="s1">UIEdgeInsetsZero)</span><span class="s4">, </span><span class="s1">NULL)</span><span class="s4">;</span>

    <span class="s1">CGFloat dashLengths[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">dashLengths[</span><span class="s5">0</span><span class="s1">] = dashLengths[</span><span class="s5">1</span><span class="s1">] = (borderStyle == RCTBorderStyleDashed ? </span><span class="s5">3 </span><span class="s1">: </span><span class="s5">1</span><span class="s1">) * lineWidth</span><span class="s4">;</span>

    <span class="s1">CGContextSetLineWidth(context</span><span class="s4">, </span><span class="s1">lineWidth)</span><span class="s4">;</span>
    <span class="s1">CGContextSetLineDash(context</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">dashLengths</span><span class="s4">, sizeof</span><span class="s1">(dashLengths) / </span><span class="s4">sizeof</span><span class="s1">(*dashLengths))</span><span class="s4">;</span>

    <span class="s1">CGContextSetStrokeColorWithColor(context</span><span class="s4">, </span><span class="s1">[UIColor yellowColor].CGColor)</span><span class="s4">;</span>

    <span class="s1">CGContextAddPath(context</span><span class="s4">, </span><span class="s1">path)</span><span class="s4">;</span>
    <span class="s1">CGContextSetStrokeColorWithColor(context</span><span class="s4">, </span><span class="s1">borderColors.top)</span><span class="s4">;</span>
    <span class="s1">CGContextStrokePath(context)</span><span class="s4">;</span>

    <span class="s1">CGPathRelease(path)</span><span class="s4">;</span>
  <span class="s1">}]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">UIImage *RCTGetBorderImage(</span>
    <span class="s1">RCTBorderStyle borderStyle</span><span class="s4">,</span>
    <span class="s1">CGSize viewSize</span><span class="s4">,</span>
    <span class="s1">RCTCornerRadii cornerRadii</span><span class="s4">,</span>
    <span class="s1">UIEdgeInsets borderInsets</span><span class="s4">,</span>
    <span class="s1">RCTBorderColors borderColors</span><span class="s4">,</span>
    <span class="s1">CGColorRef backgroundColor</span><span class="s4">,</span>
    <span class="s1">BOOL drawToEdge)</span>
<span class="s1">{</span>
  <span class="s4">switch </span><span class="s1">(borderStyle) {</span>
    <span class="s4">case </span><span class="s1">RCTBorderStyleSolid:</span>
      <span class="s4">return </span><span class="s1">RCTGetSolidBorderImage(cornerRadii</span><span class="s4">, </span><span class="s1">viewSize</span><span class="s4">, </span><span class="s1">borderInsets</span><span class="s4">, </span><span class="s1">borderColors</span><span class="s4">, </span><span class="s1">backgroundColor</span><span class="s4">, </span><span class="s1">drawToEdge)</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">RCTBorderStyleDashed:</span>
    <span class="s4">case </span><span class="s1">RCTBorderStyleDotted:</span>
      <span class="s4">return </span><span class="s1">RCTGetDashedOrDottedBorderImage(</span>
          <span class="s1">borderStyle</span><span class="s4">, </span><span class="s1">cornerRadii</span><span class="s4">, </span><span class="s1">viewSize</span><span class="s4">, </span><span class="s1">borderInsets</span><span class="s4">, </span><span class="s1">borderColors</span><span class="s4">, </span><span class="s1">backgroundColor</span><span class="s4">, </span><span class="s1">drawToEdge)</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">RCTBorderStyleUnset:</span>
      <span class="s4">break;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
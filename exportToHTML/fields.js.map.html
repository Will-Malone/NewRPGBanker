<html>
<head>
<title>fields.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fields.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperEnvironmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperMemberExpressionToFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperOptimiseCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperAnnotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSkipTransparentExpressionWrappers&quot;</span><span class="s0">,</span><span class="s1">&quot;ts&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateNamesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNamesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivate&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;isProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;getId&quot;</span><span class="s0">,</span><span class="s1">&quot;setId&quot;</span><span class="s0">,</span><span class="s1">&quot;methodId&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateNamesNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;privateFieldsAsProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;privateFieldsAsSymbols&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;initNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;isAccessor&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;annotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameVisitorFactory&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;nestedVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Class&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;visiblePrivateNames&quot;</span><span class="s0">,</span><span class="s1">&quot;redeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;skipKey&quot;</span><span class="s0">,</span><span class="s1">&quot;PrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;noDocumentAll&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;handle&quot;</span><span class="s0">,</span><span class="s1">&quot;unshadow&quot;</span><span class="s0">,</span><span class="s1">&quot;innerBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;_scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifierEquals&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCheckInRHS&quot;</span><span class="s0">,</span><span class="s1">&quot;rhs&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;inRHSIsObject&quot;</span><span class="s0">,</span><span class="s1">&quot;availableHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;privateInVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;BinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;classRef&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameHandlerSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;memoise&quot;</span><span class="s0">,</span><span class="s1">&quot;member&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;memo&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeGenerateMemoised&quot;</span><span class="s0">,</span><span class="s1">&quot;memoiser&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;helperName&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;boundGet&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;destructureSet&quot;</span><span class="s0">,</span><span class="s1">&quot;helper&quot;</span><span class="s0">,</span><span class="s1">&quot;_unused&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;optimiseCall&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalCall&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameHandlerLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;BASE&quot;</span><span class="s0">,</span><span class="s1">&quot;REF&quot;</span><span class="s0">,</span><span class="s1">&quot;PROP&quot;</span><span class="s0">,</span><span class="s1">&quot;simpleSet&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;transformPrivateNamesUsage&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpressionToFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateFieldInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritPropComments&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateStaticFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;privateName&quot;</span><span class="s0">,</span><span class="s1">&quot;initAdded&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateMethodInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceMethodInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateAccessorInitialization&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceMethodInitialization&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPublicFieldInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPublicFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateStaticMethodInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateMethodDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;getterDeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;setterDeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;isGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;isSetter&quot;</span><span class="s0">,</span><span class="s1">&quot;declId&quot;</span><span class="s0">,</span><span class="s1">&quot;functionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;thisContextVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;UnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;skipTransparentExprWrapperNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;isThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;ThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;needsClassRef&quot;</span><span class="s0">,</span><span class="s1">&quot;MetaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;innerReferencesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceThisContext&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperRef&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;constantSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;innerBindingRef&quot;</span><span class="s0">,</span><span class="s1">&quot;_state$classRef&quot;</span><span class="s0">,</span><span class="s1">&quot;replacer&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;methodPath&quot;</span><span class="s0">,</span><span class="s1">&quot;refToPreserve&quot;</span><span class="s0">,</span><span class="s1">&quot;getObjectRef&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;isNameOrLength&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritLeadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;buildFieldsInitNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;superRef&quot;</span><span class="s0">,</span><span class="s1">&quot;setPublicClassFields&quot;</span><span class="s0">,</span><span class="s1">&quot;injectSuperRef&quot;</span><span class="s0">,</span><span class="s1">&quot;staticNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;instanceNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;pureStaticNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_injectSuperRef&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;assertFieldTransformed&quot;</span><span class="s0">,</span><span class="s1">&quot;isInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;isPublic&quot;</span><span class="s0">,</span><span class="s1">&quot;isField&quot;</span><span class="s0">,</span><span class="s1">&quot;replaced&quot;</span><span class="s0">,</span><span class="s1">&quot;blockBody&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritsComments&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapClass&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/fields.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, traverse, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { File } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor, Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ReplaceSupers from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-replace-supers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import environmentVisitor from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-environment-visitor</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import memberExpressionToFunctions from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-member-expression-to-functions</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Handler,</span><span class="s3">\n  </span><span class="s1">HandlerState,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-member-expression-to-functions</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import optimiseCall from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-optimise-call-expression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import annotateAsPure from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-annotate-as-pure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { skipTransparentExprWrapperNodes } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-skip-transparent-expression-wrappers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import * as ts from </span><span class="s3">\&quot;</span><span class="s1">./typescript</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">interface PrivateNameMetadata {</span><span class="s3">\n  </span><span class="s1">id: t.Identifier;</span><span class="s3">\n  </span><span class="s1">static: boolean;</span><span class="s3">\n  </span><span class="s1">method: boolean;</span><span class="s3">\n  </span><span class="s1">getId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">setId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">methodId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">initAdded?: boolean;</span><span class="s3">\n  </span><span class="s1">getterDeclared?: boolean;</span><span class="s3">\n  </span><span class="s1">setterDeclared?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PrivateNamesMap = Map&lt;string, PrivateNameMetadata&gt;;</span><span class="s3">\n\n</span><span class="s1">export function buildPrivateNamesMap(props: PropPath[]) {</span><span class="s3">\n  </span><span class="s1">const privateNamesMap: PrivateNamesMap = new Map();</span><span class="s3">\n  </span><span class="s1">for (const prop of props) {</span><span class="s3">\n    </span><span class="s1">if (prop.isPrivate()) {</span><span class="s3">\n      </span><span class="s1">const { name } = prop.node.key.id;</span><span class="s3">\n      </span><span class="s1">const update: PrivateNameMetadata = privateNamesMap.has(name)</span><span class="s3">\n        </span><span class="s1">? privateNamesMap.get(name)</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">id: prop.scope.generateUidIdentifier(name),</span><span class="s3">\n            </span><span class="s1">static: prop.node.static,</span><span class="s3">\n            </span><span class="s1">method: !prop.isProperty(),</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (prop.isClassPrivateMethod()) {</span><span class="s3">\n        </span><span class="s1">if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">update.getId = prop.scope.generateUidIdentifier(`get_${name}`);</span><span class="s3">\n        </span><span class="s1">} else if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">update.setId = prop.scope.generateUidIdentifier(`set_${name}`);</span><span class="s3">\n        </span><span class="s1">} else if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">update.methodId = prop.scope.generateUidIdentifier(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">privateNamesMap.set(name, update);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return privateNamesMap;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildPrivateNamesNodes(</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsProperties: boolean,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsSymbols: boolean,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const initNodes: t.Statement[] = [];</span><span class="s3">\n\n  </span><span class="s1">for (const [name, value] of privateNamesMap) {</span><span class="s3">\n    </span><span class="s1">// - When the privateFieldsAsProperties assumption is enabled,</span><span class="s3">\n    </span><span class="s1">//   both static and instance fields are transpiled using a</span><span class="s3">\n    </span><span class="s1">//   secret non-enumerable property. Hence, we also need to generate that</span><span class="s3">\n    </span><span class="s1">//   key (using the classPrivateFieldLooseKey helper).</span><span class="s3">\n    </span><span class="s1">// - When the privateFieldsAsSymbols assumption is enabled,</span><span class="s3">\n    </span><span class="s1">//   both static and instance fields are transpiled using a</span><span class="s3">\n    </span><span class="s1">//   unique Symbol to define a non-enumerable property.</span><span class="s3">\n    </span><span class="s1">// - In spec mode, only instance fields need a </span><span class="s3">\&quot;</span><span class="s1">private name</span><span class="s3">\&quot; </span><span class="s1">initializer</span><span class="s3">\n    </span><span class="s1">//   because static fields are directly assigned to a variable in the</span><span class="s3">\n    </span><span class="s1">//   buildPrivateStaticFieldInitSpec function.</span><span class="s3">\n    </span><span class="s1">const { static: isStatic, method: isMethod, getId, setId } = value;</span><span class="s3">\n    </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n    </span><span class="s1">const id = t.cloneNode(value.id);</span><span class="s3">\n\n    </span><span class="s1">let init: t.Expression;</span><span class="s3">\n\n    </span><span class="s1">if (privateFieldsAsProperties) {</span><span class="s3">\n      </span><span class="s1">init = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldLooseKey</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">t.stringLiteral(name),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">} else if (privateFieldsAsSymbols) {</span><span class="s3">\n      </span><span class="s1">init = t.callExpression(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">Symbol</span><span class="s3">\&quot;</span><span class="s1">), [t.stringLiteral(name)]);</span><span class="s3">\n    </span><span class="s1">} else if (!isStatic) {</span><span class="s3">\n      </span><span class="s1">init = t.newExpression(</span><span class="s3">\n        </span><span class="s1">t.identifier(!isMethod || isAccessor ? </span><span class="s3">\&quot;</span><span class="s1">WeakMap</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">WeakSet</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (init) {</span><span class="s3">\n      </span><span class="s1">annotateAsPure(init);</span><span class="s3">\n      </span><span class="s1">initNodes.push(template.statement.ast`var ${id} = ${init}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return initNodes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrivateNameVisitorState {</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap;</span><span class="s3">\n  </span><span class="s1">privateFieldsAsProperties: boolean;</span><span class="s3">\n  </span><span class="s1">redeclared?: string[];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Traverses the class scope, handling private name references. If an inner</span><span class="s3">\n</span><span class="s1">// class redeclares the same private name, it will hand off traversal to the</span><span class="s3">\n</span><span class="s1">// restricted visitor (which doesn't traverse the inner class's inner scope).</span><span class="s3">\n</span><span class="s1">function privateNameVisitorFactory&lt;S&gt;(</span><span class="s3">\n  </span><span class="s1">visitor: Visitor&lt;PrivateNameVisitorState &amp; S&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Traverses the outer portion of a class, without touching the class's inner</span><span class="s3">\n  </span><span class="s1">// scope, for private names.</span><span class="s3">\n  </span><span class="s1">const nestedVisitor = traverse.visitors.merge([</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">...visitor,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">environmentVisitor,</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n\n  </span><span class="s1">const privateNameVisitor: Visitor&lt;PrivateNameVisitorState &amp; S&gt; = {</span><span class="s3">\n    </span><span class="s1">...visitor,</span><span class="s3">\n\n    </span><span class="s1">Class(path) {</span><span class="s3">\n      </span><span class="s1">const { privateNamesMap } = this;</span><span class="s3">\n      </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const visiblePrivateNames = new Map(privateNamesMap);</span><span class="s3">\n      </span><span class="s1">const redeclared = [];</span><span class="s3">\n      </span><span class="s1">for (const prop of body) {</span><span class="s3">\n        </span><span class="s1">if (!prop.isPrivate()) continue;</span><span class="s3">\n        </span><span class="s1">const { name } = prop.node.key.id;</span><span class="s3">\n        </span><span class="s1">visiblePrivateNames.delete(name);</span><span class="s3">\n        </span><span class="s1">redeclared.push(name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If the class doesn't redeclare any private fields, we can continue with</span><span class="s3">\n      </span><span class="s1">// our overall traversal.</span><span class="s3">\n      </span><span class="s1">if (!redeclared.length) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// This class redeclares some private field. We need to process the outer</span><span class="s3">\n      </span><span class="s1">// environment with access to all the outer privates, then we can process</span><span class="s3">\n      </span><span class="s1">// the inner environment with only the still-visible outer privates.</span><span class="s3">\n      </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).traverse(nestedVisitor, {</span><span class="s3">\n        </span><span class="s1">...this,</span><span class="s3">\n        </span><span class="s1">redeclared,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">path.traverse(privateNameVisitor, {</span><span class="s3">\n        </span><span class="s1">...this,</span><span class="s3">\n        </span><span class="s1">privateNamesMap: visiblePrivateNames,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// We'll eventually hit this class node again with the overall Class</span><span class="s3">\n      </span><span class="s1">// Features visitor, which'll process the redeclared privates.</span><span class="s3">\n      </span><span class="s1">path.skipKey(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">return privateNameVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrivateNameState {</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap;</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n  </span><span class="s1">noDocumentAll: boolean;</span><span class="s3">\n  </span><span class="s1">innerBinding?: t.Identifier;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateNameVisitor = privateNameVisitorFactory&lt;</span><span class="s3">\n  </span><span class="s1">HandlerState&lt;PrivateNameState&gt; &amp; PrivateNameState</span><span class="s3">\n</span><span class="s1">&gt;({</span><span class="s3">\n  </span><span class="s1">PrivateName(path, { noDocumentAll }) {</span><span class="s3">\n    </span><span class="s1">const { privateNamesMap, redeclared } = this;</span><span class="s3">\n    </span><span class="s1">const { node, parentPath } = path;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!parentPath.isMemberExpression({ property: node }) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!parentPath.isOptionalMemberExpression({ property: node })</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { name } = node.id;</span><span class="s3">\n    </span><span class="s1">if (!privateNamesMap.has(name)) return;</span><span class="s3">\n    </span><span class="s1">if (redeclared &amp;&amp; redeclared.includes(name)) return;</span><span class="s3">\n\n    </span><span class="s1">this.handle(parentPath, noDocumentAll);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// rename all bindings that shadows innerBinding</span><span class="s3">\n</span><span class="s1">function unshadow(</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n  </span><span class="s1">innerBinding: t.Identifier | undefined,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// in some cases, scope.getBinding(name) === undefined</span><span class="s3">\n  </span><span class="s1">// so we check hasBinding to avoid keeping looping</span><span class="s3">\n  </span><span class="s1">// see: https://github.com/babel/babel/pull/13656#discussion_r686030715</span><span class="s3">\n  </span><span class="s1">while (</span><span class="s3">\n    </span><span class="s1">scope?.hasBinding(name) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!scope.bindingIdentifierEquals(name, innerBinding)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">scope.rename(name);</span><span class="s3">\n    </span><span class="s1">scope = scope.parent;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildCheckInRHS(</span><span class="s3">\n  </span><span class="s1">rhs: t.Expression,</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">inRHSIsObject?: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (inRHSIsObject || !file.availableHelper?.(</span><span class="s3">\&quot;</span><span class="s1">checkInRHS</span><span class="s3">\&quot;</span><span class="s1">)) return rhs;</span><span class="s3">\n  </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">checkInRHS</span><span class="s3">\&quot;</span><span class="s1">), [rhs]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateInVisitor = privateNameVisitorFactory&lt;{</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n  </span><span class="s1">innerBinding?: t.Identifier;</span><span class="s3">\n</span><span class="s1">}&gt;({</span><span class="s3">\n  </span><span class="s1">BinaryExpression(path, { file }) {</span><span class="s3">\n    </span><span class="s1">const { operator, left, right } = path.node;</span><span class="s3">\n    </span><span class="s1">if (operator !== </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n    </span><span class="s1">if (!t.isPrivateName(left)) return;</span><span class="s3">\n\n    </span><span class="s1">const { privateFieldsAsProperties, privateNamesMap, redeclared } = this;</span><span class="s3">\n\n    </span><span class="s1">const { name } = left.id;</span><span class="s3">\n\n    </span><span class="s1">if (!privateNamesMap.has(name)) return;</span><span class="s3">\n    </span><span class="s1">if (redeclared &amp;&amp; redeclared.includes(name)) return;</span><span class="s3">\n\n    </span><span class="s1">// if there are any local variable shadowing classRef, unshadow it</span><span class="s3">\n    </span><span class="s1">// see #12960</span><span class="s3">\n    </span><span class="s1">unshadow(this.classRef.name, path.scope, this.innerBinding);</span><span class="s3">\n\n    </span><span class="s1">if (privateFieldsAsProperties) {</span><span class="s3">\n      </span><span class="s1">const { id } = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">path.replaceWith(template.expression.ast`</span><span class="s3">\n        </span><span class="s1">Object.prototype.hasOwnProperty.call(${buildCheckInRHS(</span><span class="s3">\n          </span><span class="s1">right,</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">)}, ${t.cloneNode(id)})</span><span class="s3">\n      </span><span class="s1">`);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { id, static: isStatic } = privateNamesMap.get(name);</span><span class="s3">\n\n    </span><span class="s1">if (isStatic) {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(</span><span class="s3">\n        </span><span class="s1">template.expression.ast`${buildCheckInRHS(</span><span class="s3">\n          </span><span class="s1">right,</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">)} === ${t.cloneNode(this.classRef)}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">path.replaceWith(</span><span class="s3">\n      </span><span class="s1">template.expression.ast`${t.cloneNode(id)}.has(${buildCheckInRHS(</span><span class="s3">\n        </span><span class="s1">right,</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n      </span><span class="s1">)})`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">interface Receiver {</span><span class="s3">\n  </span><span class="s1">receiver(</span><span class="s3">\n    </span><span class="s1">this: HandlerState&lt;PrivateNameState&gt; &amp; PrivateNameState,</span><span class="s3">\n    </span><span class="s1">member: NodePath&lt;t.MemberExpression | t.OptionalMemberExpression&gt;,</span><span class="s3">\n  </span><span class="s1">): t.Expression;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateNameHandlerSpec: Handler&lt;PrivateNameState &amp; Receiver&gt; &amp; Receiver =</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">memoise(member, count) {</span><span class="s3">\n      </span><span class="s1">const { scope } = member;</span><span class="s3">\n      </span><span class="s1">const { object } = member.node as { object: t.Expression };</span><span class="s3">\n\n      </span><span class="s1">const memo = scope.maybeGenerateMemoised(object);</span><span class="s3">\n      </span><span class="s1">if (!memo) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.memoiser.set(object, memo, count);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">receiver(member) {</span><span class="s3">\n      </span><span class="s1">const { object } = member.node as { object: t.Expression };</span><span class="s3">\n\n      </span><span class="s1">if (this.memoiser.has(object)) {</span><span class="s3">\n        </span><span class="s1">return t.cloneNode(this.memoiser.get(object));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.cloneNode(object);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">get(member) {</span><span class="s3">\n      </span><span class="s1">const { classRef, privateNamesMap, file, innerBinding } = this;</span><span class="s3">\n      </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">static: isStatic,</span><span class="s3">\n        </span><span class="s1">method: isMethod,</span><span class="s3">\n        </span><span class="s1">methodId,</span><span class="s3">\n        </span><span class="s1">getId,</span><span class="s3">\n        </span><span class="s1">setId,</span><span class="s3">\n      </span><span class="s1">} = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n\n      </span><span class="s1">if (isStatic) {</span><span class="s3">\n        </span><span class="s1">// NOTE: This package has a peerDependency on @babel/core@^7.0.0, but these</span><span class="s3">\n        </span><span class="s1">// helpers have been introduced in @babel/helpers@7.1.0.</span><span class="s3">\n        </span><span class="s1">const helperName =</span><span class="s3">\n          </span><span class="s1">isMethod &amp;&amp; !isAccessor</span><span class="s3">\n            </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateMethodGet</span><span class="s3">\&quot;\n            </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateFieldSpecGet</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n        </span><span class="s1">// if there are any local variable shadowing classRef, unshadow it</span><span class="s3">\n        </span><span class="s1">// see #12960</span><span class="s3">\n        </span><span class="s1">unshadow(classRef.name, member.scope, innerBinding);</span><span class="s3">\n\n        </span><span class="s1">return t.callExpression(file.addHelper(helperName), [</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isMethod) {</span><span class="s3">\n        </span><span class="s1">if (isAccessor) {</span><span class="s3">\n          </span><span class="s1">if (!getId &amp;&amp; setId) {</span><span class="s3">\n            </span><span class="s1">if (file.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">writeOnlyError</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n              </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n                </span><span class="s1">this.receiver(member),</span><span class="s3">\n                </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">writeOnlyError</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n                  </span><span class="s1">t.stringLiteral(`#${name}`),</span><span class="s3">\n                </span><span class="s1">]),</span><span class="s3">\n              </span><span class="s1">]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">console.warn(</span><span class="s3">\n              </span><span class="s1">`@babel/helpers is outdated, update it to silence this warning.`,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateMethodGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(methodId),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">this.receiver(member),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">boundGet(member) {</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return t.callExpression(</span><span class="s3">\n        </span><span class="s1">t.memberExpression(this.get(member), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n        </span><span class="s1">[this.receiver(member)],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">set(member, value) {</span><span class="s3">\n      </span><span class="s1">const { classRef, privateNamesMap, file } = this;</span><span class="s3">\n      </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">static: isStatic,</span><span class="s3">\n        </span><span class="s1">method: isMethod,</span><span class="s3">\n        </span><span class="s1">setId,</span><span class="s3">\n        </span><span class="s1">getId,</span><span class="s3">\n      </span><span class="s1">} = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">const isAccessor = getId || setId;</span><span class="s3">\n\n      </span><span class="s1">if (isStatic) {</span><span class="s3">\n        </span><span class="s1">const helperName =</span><span class="s3">\n          </span><span class="s1">isMethod &amp;&amp; !isAccessor</span><span class="s3">\n            </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateMethodSet</span><span class="s3">\&quot;\n            </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateFieldSpecSet</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n        </span><span class="s1">return t.callExpression(file.addHelper(helperName), [</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (isMethod) {</span><span class="s3">\n        </span><span class="s1">if (setId) {</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">readOnlyError</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.stringLiteral(`#${name}`),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">this.receiver(member),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">destructureSet(member) {</span><span class="s3">\n      </span><span class="s1">const { classRef, privateNamesMap, file } = this;</span><span class="s3">\n      </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n      </span><span class="s1">const { id, static: isStatic } = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">if (isStatic) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// classStaticPrivateFieldDestructureSet was introduced in 7.13.10</span><span class="s3">\n          </span><span class="s1">// eslint-disable-next-line no-var</span><span class="s3">\n          </span><span class="s1">var helper = file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateFieldDestructureSet</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} catch {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            \&quot;</span><span class="s1">Babel can not transpile `[C.#p] = [0]` with @babel/helpers &lt; 7.13.10, </span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n              \&quot;</span><span class="s1">please update @babel/helpers to the latest version.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.callExpression(helper, [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.memberExpression(</span><span class="s3">\n        </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldDestructureSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">call(member, args: (t.Expression | t.SpreadElement)[]) {</span><span class="s3">\n      </span><span class="s1">// The first access (the get) should do the memo assignment.</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return optimiseCall(this.get(member), this.receiver(member), args, false);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">optionalCall(member, args: (t.Expression | t.SpreadElement)[]) {</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return optimiseCall(this.get(member), this.receiver(member), args, true);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">delete() {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        \&quot;</span><span class="s1">Internal Babel error: deleting private elements is a parsing error.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const privateNameHandlerLoose: Handler&lt;PrivateNameState&gt; = {</span><span class="s3">\n  </span><span class="s1">get(member) {</span><span class="s3">\n    </span><span class="s1">const { privateNamesMap, file } = this;</span><span class="s3">\n    </span><span class="s1">const { object } = member.node;</span><span class="s3">\n    </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n\n    </span><span class="s1">return template.expression`BASE(REF, PROP)[PROP]`({</span><span class="s3">\n      </span><span class="s1">BASE: file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldLooseBase</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">REF: t.cloneNode(object),</span><span class="s3">\n      </span><span class="s1">PROP: t.cloneNode(privateNamesMap.get(name).id),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">set() {</span><span class="s3">\n    </span><span class="s1">// noop</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">private name handler with loose = true don't need set()</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">boundGet(member) {</span><span class="s3">\n    </span><span class="s1">return t.callExpression(</span><span class="s3">\n      </span><span class="s1">t.memberExpression(this.get(member), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion</span><span class="s3">\n      </span><span class="s1">[t.cloneNode(member.node.object as t.Expression)],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">simpleSet(member) {</span><span class="s3">\n    </span><span class="s1">return this.get(member);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">destructureSet(member) {</span><span class="s3">\n    </span><span class="s1">return this.get(member);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">call(member, args) {</span><span class="s3">\n    </span><span class="s1">return t.callExpression(this.get(member), args);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">optionalCall(member, args) {</span><span class="s3">\n    </span><span class="s1">return t.optionalCallExpression(this.get(member), args, true);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">delete() {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Internal Babel error: deleting private elements is a parsing error.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function transformPrivateNamesUsage(</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier,\n  path: NodePath&lt;t.Class&gt;,\n  privateNamesMap: PrivateNamesMap,\n  {\n    privateFieldsAsProperties,\n    noDocumentAll,\n    innerBinding,\n  }: {\n    privateFieldsAsProperties: boolean;\n    noDocumentAll: boolean;\n    innerBinding: t.Identifier;\n  },\n  state: File,\n) {\n  if (!privateNamesMap.size) return;\n\n  const body = path.get(\&quot;body\&quot;);\n  const handler = privateFieldsAsProperties\n    ? privateNameHandlerLoose\n    : privateNameHandlerSpec;\n\n  memberExpressionToFunctions&lt;PrivateNameState&gt;(body, privateNameVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    ...handler,\n    noDocumentAll,\n    innerBinding,\n  });\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties,\n    innerBinding,\n  });\n}\n\nfunction buildPrivateFieldInitLoose(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassPrivateProperty&gt;,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const { id } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    template.statement.ast`\n      Object.defineProperty(${ref}, ${t.cloneNode(id)}, {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      });\n    `,\n    prop,\n  );\n}\n\nfunction buildPrivateInstanceFieldInitSpec(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassPrivateProperty&gt;,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const { id } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\&quot;classPrivateFieldInitSpec\&quot;)) {\n      return inheritPropComments(\n        template.statement.ast`${t.cloneNode(id)}.set(${ref}, {\n          // configurable is always false for private elements\n          // enumerable is always false for private elements\n          writable: true,\n          value: ${value},\n        })`,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\&quot;classPrivateFieldInitSpec\&quot;);\n  return inheritPropComments(\n    template.statement.ast`${helper}(\n      ${t.thisExpression()},\n      ${t.cloneNode(id)},\n      {\n        writable: true,\n        value: ${value}\n      },\n    )`,\n    prop,\n  );\n}\n\nfunction buildPrivateStaticFieldInitSpec(\n  prop: NodePath&lt;t.ClassPrivateProperty&gt;,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, getId, setId, initAdded } = privateName;\n  const isAccessor = getId || setId;\n\n  if (!prop.isProperty() &amp;&amp; (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return inheritPropComments(\n      template.statement.ast`\n        var ${t.cloneNode(id)} = {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        }\n      `,\n      prop,\n    );\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(\n    template.statement.ast`\n      var ${t.cloneNode(id)} = {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      };\n    `,\n    prop,\n  );\n}\n\nfunction buildPrivateMethodInitLoose(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassPrivateMethod&gt;,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { methodId, id, getId, setId, initAdded } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `,\n      prop,\n    );\n  }\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        });\n      `,\n      prop,\n    );\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassPrivateMethod&gt;,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { getId, setId, initAdded } = privateName;\n\n  if (initAdded) return;\n\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    return buildPrivateAccessorInitialization(\n      ref,\n      prop,\n      privateNamesMap,\n      state,\n    );\n  }\n\n  return buildPrivateInstanceMethodInitialization(\n    ref,\n    prop,\n    privateNamesMap,\n    state,\n  );\n}\n\nfunction buildPrivateAccessorInitialization(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassPrivateMethod&gt;,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, getId, setId } = privateName;\n\n  privateNamesMap.set(prop.node.key.id.name, {\n    ...privateName,\n    initAdded: true,\n  });\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\&quot;classPrivateFieldInitSpec\&quot;)) {\n      return inheritPropComments(\n        template.statement.ast`\n          ${id}.set(${ref}, {\n            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n          });\n        `,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\&quot;classPrivateFieldInitSpec\&quot;);\n  return inheritPropComments(\n    template.statement.ast`${helper}(\n      ${t.thisExpression()},\n      ${t.cloneNode(id)},\n      {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      },\n    )`,\n    prop,\n  );\n}\n\nfunction buildPrivateInstanceMethodInitialization(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassPrivateMethod&gt;,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id } = privateName;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\&quot;classPrivateMethodInitSpec\&quot;)) {\n      return inheritPropComments(\n        template.statement.ast`${id}.add(${ref})`,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\&quot;classPrivateMethodInitSpec\&quot;);\n  return inheritPropComments(\n    template.statement.ast`${helper}(\n      ${t.thisExpression()},\n      ${t.cloneNode(id)}\n    )`,\n    prop,\n  );\n}\n\nfunction buildPublicFieldInitLoose(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassProperty&gt;,\n) {\n  const { key, computed } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    t.expressionStatement(\n      t.assignmentExpression(\n        \&quot;=\&quot;,\n        t.memberExpression(ref, key, computed || t.isLiteral(key)),\n        value,\n      ),\n    ),\n    prop,\n  );\n}\n\nfunction buildPublicFieldInitSpec(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassProperty&gt;,\n  state: File,\n) {\n  const { key, computed } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    t.expressionStatement(\n      t.callExpression(state.addHelper(\&quot;defineProperty\&quot;), [\n        ref,\n        computed || t.isLiteral(key)\n          ? key\n          : t.stringLiteral((key as t.Identifier).name),\n        value,\n      ]),\n    ),\n    prop,\n  );\n}\n\nfunction buildPrivateStaticMethodInitLoose(\n  ref: t.Expression,\n  prop: NodePath&lt;t.ClassPrivateMethod&gt;,\n  state: File,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, methodId, getId, setId, initAdded } = privateName;\n\n  if (initAdded) return;\n\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        })\n      `,\n      prop,\n    );\n  }\n\n  return inheritPropComments(\n    template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        value: ${methodId.name}\n      });\n    `,\n    prop,\n  );\n}\n\nfunction buildPrivateMethodDeclaration(\n  prop: NodePath&lt;t.ClassPrivateMethod&gt;,\n  privateNamesMap: PrivateNamesMap,\n  privateFieldsAsProperties = false,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic,\n  } = privateName;\n  const { params, body, generator, async } = prop.node;\n  const isGetter = getId &amp;&amp; !getterDeclared &amp;&amp; params.length === 0;\n  const isSetter = setId &amp;&amp; !setterDeclared &amp;&amp; params.length &gt; 0;\n\n  let declId = methodId;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      getterDeclared: true,\n    });\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      setterDeclared: true,\n    });\n    declId = setId;\n  } else if (isStatic &amp;&amp; !privateFieldsAsProperties) {\n    declId = id;\n  }\n\n  return inheritPropComments(\n    t.functionDeclaration(\n      t.cloneNode(declId),\n      // @ts-expect-error params for ClassMethod has TSParameterProperty\n      params,\n      body,\n      generator,\n      async,\n    ),\n    prop,\n  );\n}\n\ntype ReplaceThisState = {\n  classRef: t.Identifier;\n  needsClassRef: boolean;\n  innerBinding: t.Identifier | null;\n};\n\nconst thisContextVisitor = traverse.visitors.merge&lt;ReplaceThisState&gt;([\n  {\n    UnaryExpression(path) {\n      // Replace `delete this` with `true`\n      const { node } = path;\n      if (node.operator === \&quot;delete\&quot;) {\n        const argument = skipTransparentExprWrapperNodes(node.argument);\n        if (t.isThisExpression(argument)) {\n          path.replaceWith(t.booleanLiteral(true));\n        }\n      }\n    },\n    ThisExpression(path, state) {\n      state.needsClassRef = true;\n      path.replaceWith(t.cloneNode(state.classRef));\n    },\n    MetaProperty(path) {\n      const { node, scope } = path;\n      // if there are `new.target` in static field\n      // we should replace it with `undefined`\n      if (node.meta.name === \&quot;new\&quot; &amp;&amp; node.property.name === \&quot;target\&quot;) {\n        path.replaceWith(scope.buildUndefinedNode());\n      }\n    },\n  },\n  environmentVisitor,\n]);\n\nconst innerReferencesVisitor: Visitor&lt;ReplaceThisState&gt; = {\n  ReferencedIdentifier(path, state) {\n    if (\n      path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)\n    ) {\n      state.needsClassRef = true;\n      path.node.name = state.classRef.name;\n    }\n  },\n};\n\nfunction replaceThisContext(\n  path: PropPath,\n  ref: t.Identifier,\n  getSuperRef: () =&gt; t.Identifier,\n  file: File,\n  isStaticBlock: boolean,\n  constantSuper: boolean,\n  innerBindingRef: t.Identifier | null,\n) {\n  const state: ReplaceThisState = {\n    classRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef,\n  };\n\n  const replacer = new ReplaceSupers({\n    methodPath: path,\n    constantSuper,\n    file,\n    refToPreserve: ref,\n    getSuperRef,\n    getObjectRef() {\n      state.needsClassRef = true;\n      // @ts-expect-error: TS doesn't infer that path.node is not a StaticBlock\n      return t.isStaticBlock?.(path.node) || path.node.static\n        ? ref\n        : t.memberExpression(ref, t.identifier(\&quot;prototype\&quot;));\n    },\n  });\n  replacer.replace();\n  if (isStaticBlock || path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  // todo: use innerBinding.referencePaths to avoid full traversal\n  if (\n    innerBindingRef != null &amp;&amp;\n    state.classRef?.name &amp;&amp;\n    state.classRef.name !== innerBindingRef?.name\n  ) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nexport type PropNode =\n  | t.ClassProperty\n  | t.ClassPrivateMethod\n  | t.ClassPrivateProperty\n  | t.StaticBlock;\nexport type PropPath = NodePath&lt;PropNode&gt;;\n\nfunction isNameOrLength({ key, computed }: t.ClassProperty) {\n  if (key.type === \&quot;Identifier\&quot;) {\n    return !computed &amp;&amp; (key.name === \&quot;name\&quot; || key.name === \&quot;length\&quot;);\n  }\n  if (key.type === \&quot;StringLiteral\&quot;) {\n    return key.value === \&quot;name\&quot; || key.value === \&quot;length\&quot;;\n  }\n  return false;\n}\n\n/**\n * Inherit comments from class members. This is a reduced version of\n * t.inheritsComments: the trailing comments are not inherited because\n * for most class members except the last one, their trailing comments are\n * the next sibling's leading comments.\n *\n * @template T transformed class member type\n * @param {T} node transformed class member\n * @param {PropPath} prop class member\n * @returns transformed class member type with comments inherited\n */\nfunction inheritPropComments&lt;T extends t.Node&gt;(node: T, prop: PropPath) {\n  t.inheritLeadingComments(node, prop.node);\n  t.inheritInnerComments(node, prop.node);\n  return node;\n}\n\nexport function buildFieldsInitNodes(\n  ref: t.Identifier,\n  superRef: t.Expression | undefined,\n  props: PropPath[],\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n  setPublicClassFields: boolean,\n  privateFieldsAsProperties: boolean,\n  constantSuper: boolean,\n  innerBindingRef: t.Identifier,\n) {\n  let needsClassRef = false;\n  let injectSuperRef: t.Identifier;\n  const staticNodes: t.Statement[] = [];\n  const instanceNodes: t.Statement[] = [];\n  // These nodes are pure and can be moved to the closest statement position\n  const pureStaticNodes: t.FunctionDeclaration[] = [];\n\n  const getSuperRef = t.isIdentifier(superRef)\n    ? () =&gt; superRef\n    : () =&gt; {\n        injectSuperRef ??=\n          props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n        return injectSuperRef;\n      };\n\n  for (const prop of props) {\n    prop.isClassProperty() &amp;&amp; ts.assertFieldTransformed(prop);\n\n    // @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock\n    const isStatic = !t.isStaticBlock?.(prop.node) &amp;&amp; prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock?.();\n\n    if (isStatic || (isMethod &amp;&amp; isPrivate) || isStaticBlock) {\n      const replaced = replaceThisContext(\n        prop,\n        ref,\n        getSuperRef,\n        state,\n        isStaticBlock,\n        constantSuper,\n        innerBindingRef,\n      );\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    // TODO(ts): there are so many `ts-expect-error` inside cases since\n    // ts can not infer type from pre-computed values (or a case test)\n    // even change `isStaticBlock` to `t.isStaticBlock(prop)` will not make prop\n    // a `NodePath&lt;t.StaticBlock&gt;`\n    // this maybe a bug for ts\n    switch (true) {\n      case isStaticBlock: {\n        const blockBody = (prop.node as t.StaticBlock).body;\n        // We special-case the single expression case to avoid the iife, since\n        // it's common.\n        if (blockBody.length === 1 &amp;&amp; t.isExpressionStatement(blockBody[0])) {\n          staticNodes.push(inheritPropComments(blockBody[0], prop));\n        } else {\n          staticNodes.push(\n            t.inheritsComments(\n              template.statement.ast`(() =&gt; { ${blockBody} })()`,\n              prop.node,\n            ),\n          );\n        }\n        break;\n      }\n      case isStatic &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateFieldInitLoose(t.cloneNode(ref), prop, privateNamesMap),\n        );\n        break;\n      case isStatic &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateStaticFieldInitSpec(prop, privateNamesMap),\n        );\n        break;\n      case isStatic &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; setPublicClassFields:\n        // Functions always have non-writable .name and .length properties,\n        // so we must always use [[Define]] for them.\n        // It might still be possible to a computed static fields whose resulting\n        // key is \&quot;name\&quot; or \&quot;length\&quot;, but the assumption is telling us that it's\n        // not going to happen.\n        // @ts-expect-error checked in switch\n        if (!isNameOrLength(prop.node)) {\n          needsClassRef = true;\n          // @ts-expect-error checked in switch\n          staticNodes.push(buildPublicFieldInitLoose(t.cloneNode(ref), prop));\n          break;\n        }\n      // falls through\n      case isStatic &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; !setPublicClassFields:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPublicFieldInitSpec(t.cloneNode(ref), prop, state),\n        );\n        break;\n      case isInstance &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; privateFieldsAsProperties:\n        instanceNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateFieldInitLoose(t.thisExpression(), prop, privateNamesMap),\n        );\n        break;\n      case isInstance &amp;&amp; isPrivate &amp;&amp; isField &amp;&amp; !privateFieldsAsProperties:\n        instanceNodes.push(\n          buildPrivateInstanceFieldInitSpec(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            state,\n          ),\n        );\n        break;\n      case isInstance &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; privateFieldsAsProperties:\n        instanceNodes.unshift(\n          buildPrivateMethodInitLoose(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isInstance &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; !privateFieldsAsProperties:\n        instanceNodes.unshift(\n          buildPrivateInstanceMethodInitSpec(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            state,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isStatic &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(\n          // @ts-expect-error checked in switch\n          buildPrivateStaticFieldInitSpec(prop, privateNamesMap),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isStatic &amp;&amp; isPrivate &amp;&amp; isMethod &amp;&amp; privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(\n          buildPrivateStaticMethodInitLoose(\n            t.cloneNode(ref),\n            // @ts-expect-error checked in switch\n            prop,\n            state,\n            privateNamesMap,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isInstance &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; setPublicClassFields:\n        // @ts-expect-error checked in switch\n        instanceNodes.push(buildPublicFieldInitLoose(t.thisExpression(), prop));\n        break;\n      case isInstance &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; !setPublicClassFields:\n        instanceNodes.push(\n          // @ts-expect-error checked in switch\n          buildPublicFieldInitSpec(t.thisExpression(), prop, state),\n        );\n        break;\n      default:\n        throw new Error(\&quot;Unreachable.\&quot;);\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n    wrapClass(path: NodePath&lt;t.Class&gt;) {\n      for (const prop of props) {\n        // Delete leading comments so that they don't get attached as\n        // trailing comments of the previous sibling.\n        // When transforming props, we explicitly attach their leading\n        // comments to the transformed node with `inheritPropComments`\n        // above.\n        prop.node.leadingComments = null;\n        prop.remove();\n      }\n\n      if (injectSuperRef) {\n        path.scope.push({ id: t.cloneNode(injectSuperRef) });\n        path.set(\n          \&quot;superClass\&quot;,\n          t.assignmentExpression(\&quot;=\&quot;, injectSuperRef, path.node.superClass),\n        );\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({ id: ref });\n        path.replaceWith(\n          t.assignmentExpression(\&quot;=\&quot;, t.cloneNode(ref), path.node),\n        );\n      } else if (!path.node.id) {\n        // Anonymous class declaration\n        path.node.id = ref;\n      }\n\n      return path;\n    },\n  };\n}\n&quot;],&quot;mappings&quot;:&quot;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&quot;}</span></pre>
</body>
</html>
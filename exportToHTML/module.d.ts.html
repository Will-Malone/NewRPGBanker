<html>
<head>
<title>module.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #6a8759;}
.s4 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
module.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.3.7 
 */</span>
<span class="s1">declare module </span><span class="s3">'module' </span><span class="s2">{</span>
    <span class="s1">import </span><span class="s2">{ </span><span class="s4">URL </span><span class="s2">} </span><span class="s1">from </span><span class="s3">'node:url'</span><span class="s2">;</span>
    <span class="s1">namespace </span><span class="s4">Module </span><span class="s2">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The `module.syncBuiltinESMExports()` method updates all the live bindings for 
         * builtin `ES Modules` to match the properties of the `CommonJS` exports. It 
         * does not add or remove exported names from the `ES Modules`. 
         * 
         * ```js 
         * const fs = require('node:fs'); 
         * const assert = require('node:assert'); 
         * const { syncBuiltinESMExports } = require('node:module'); 
         * 
         * fs.readFile = newAPI; 
         * 
         * delete fs.readFileSync; 
         * 
         * function newAPI() { 
         *   // ... 
         * } 
         * 
         * fs.newAPI = newAPI; 
         * 
         * syncBuiltinESMExports(); 
         * 
         * import('node:fs').then((esmFS) =&gt; { 
         *   // It syncs the existing readFile property with the new value 
         *   assert.strictEqual(esmFS.readFile, newAPI); 
         *   // readFileSync has been deleted from the required fs 
         *   assert.strictEqual('readFileSync' in fs, false); 
         *   // syncBuiltinESMExports() does not remove readFileSync from esmFS 
         *   assert.strictEqual('readFileSync' in esmFS, true); 
         *   // syncBuiltinESMExports() does not add names 
         *   assert.strictEqual(esmFS.newAPI, undefined); 
         * }); 
         * ``` 
         * </span><span class="s1">@since </span><span class="s0">v12.12.0 
         */</span>
        <span class="s1">function </span><span class="s2">syncBuiltinESMExports()</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* `path` is the resolved path for the file for which a corresponding source map 
         * should be fetched. 
         * </span><span class="s1">@since </span><span class="s0">v13.7.0, v12.17.0 
         * </span><span class="s1">@return </span><span class="s0">Returns `module.SourceMap` if a source map is found, `undefined` otherwise. 
         */</span>
        <span class="s1">function </span><span class="s2">findSourceMap(</span><span class="s4">path</span><span class="s1">: </span><span class="s4">string</span><span class="s2">, </span><span class="s4">error</span><span class="s1">?: </span><span class="s4">Error</span><span class="s2">)</span><span class="s1">: </span><span class="s4">SourceMap</span><span class="s2">;</span>
        <span class="s1">interface </span><span class="s4">SourceMapPayload </span><span class="s2">{</span>
            <span class="s2">file</span><span class="s1">: </span><span class="s4">string</span><span class="s2">;</span>
            <span class="s2">version</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
            <span class="s2">sources</span><span class="s1">: </span><span class="s4">string</span><span class="s2">[];</span>
            <span class="s2">sourcesContent</span><span class="s1">: </span><span class="s4">string</span><span class="s2">[];</span>
            <span class="s2">names</span><span class="s1">: </span><span class="s4">string</span><span class="s2">[];</span>
            <span class="s2">mappings</span><span class="s1">: </span><span class="s4">string</span><span class="s2">;</span>
            <span class="s2">sourceRoot</span><span class="s1">: </span><span class="s4">string</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s1">interface </span><span class="s4">SourceMapping </span><span class="s2">{</span>
            <span class="s2">generatedLine</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
            <span class="s2">generatedColumn</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
            <span class="s2">originalSource</span><span class="s1">: </span><span class="s4">string</span><span class="s2">;</span>
            <span class="s2">originalLine</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
            <span class="s2">originalColumn</span><span class="s1">: </span><span class="s4">number</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v13.7.0, v12.17.0 
         */</span>
        <span class="s1">class </span><span class="s4">SourceMap </span><span class="s2">{</span>
            <span class="s0">/**</span>
             <span class="s0">* Getter for the payload used to construct the `SourceMap` instance. 
             */</span>
            <span class="s1">readonly </span><span class="s2">payload</span><span class="s1">: </span><span class="s4">SourceMapPayload</span><span class="s2">;</span>
            <span class="s1">constructor</span><span class="s2">(</span><span class="s4">payload</span><span class="s1">: </span><span class="s4">SourceMapPayload</span><span class="s2">);</span>
            <span class="s0">/**</span>
             <span class="s0">* Given a line offset and column offset in the generated source 
             * file, returns an object representing the SourceMap range in the 
             * original file if found, or an empty object if not. 
             * 
             * The object returned contains the following keys: 
             * 
             * The returned value represents the raw range as it appears in the 
             * SourceMap, based on zero-indexed offsets, _not_ 1-indexed line and 
             * column numbers as they appear in Error messages and CallSite 
             * objects. 
             * 
             * To get the corresponding 1-indexed line and column numbers from a 
             * lineNumber and columnNumber as they are reported by Error stacks 
             * and CallSite objects, use `sourceMap.findOrigin(lineNumber, columnNumber)` 
             * </span><span class="s1">@param </span><span class="s4">lineOffset </span><span class="s0">The zero-indexed line number offset in the generated source 
             * </span><span class="s1">@param </span><span class="s4">columnOffset </span><span class="s0">The zero-indexed column number offset in the generated source 
             */</span>
            <span class="s2">findEntry(</span><span class="s4">lineOffset</span><span class="s1">: </span><span class="s4">number</span><span class="s2">, </span><span class="s4">columnOffset</span><span class="s1">: </span><span class="s4">number</span><span class="s2">)</span><span class="s1">: </span><span class="s4">SourceMapping</span><span class="s2">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">interface </span><span class="s4">Module </span><span class="s1">extends </span><span class="s4">NodeModule </span><span class="s2">{}</span>
    <span class="s1">class </span><span class="s4">Module </span><span class="s2">{</span>
        <span class="s1">static </span><span class="s2">runMain()</span><span class="s1">: </span><span class="s4">void</span><span class="s2">;</span>
        <span class="s1">static </span><span class="s2">wrap(</span><span class="s4">code</span><span class="s1">: </span><span class="s4">string</span><span class="s2">)</span><span class="s1">: </span><span class="s4">string</span><span class="s2">;</span>
        <span class="s1">static </span><span class="s2">createRequire(</span><span class="s4">path</span><span class="s1">: </span><span class="s4">string </span><span class="s1">| </span><span class="s4">URL</span><span class="s2">)</span><span class="s1">: </span><span class="s4">NodeRequire</span><span class="s2">;</span>
        <span class="s1">static </span><span class="s2">builtinModules</span><span class="s1">: </span><span class="s4">string</span><span class="s2">[];</span>
        <span class="s1">static </span><span class="s2">isBuiltin(</span><span class="s4">moduleName</span><span class="s1">: </span><span class="s4">string</span><span class="s2">)</span><span class="s1">: </span><span class="s4">boolean</span><span class="s2">;</span>
        <span class="s1">static </span><span class="s2">Module</span><span class="s1">: typeof </span><span class="s4">Module</span><span class="s2">;</span>
        <span class="s1">constructor</span><span class="s2">(</span><span class="s4">id</span><span class="s1">: </span><span class="s4">string</span><span class="s2">, </span><span class="s4">parent</span><span class="s1">?: </span><span class="s4">Module</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">global </span><span class="s2">{</span>
        <span class="s1">interface </span><span class="s4">ImportMeta </span><span class="s2">{</span>
            <span class="s2">url</span><span class="s1">: </span><span class="s4">string</span><span class="s2">;</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@experimental</span>
             <span class="s0">* This feature is only available with the `--experimental-import-meta-resolve` 
             * command flag enabled. 
             * 
             * Provides a module-relative resolution function scoped to each module, returning 
             * the URL string. 
             * 
             * </span><span class="s1">@param </span><span class="s4">specified </span><span class="s0">The module specifier to resolve relative to `parent`. 
             * </span><span class="s1">@param </span><span class="s4">parent </span><span class="s0">The absolute parent module URL to resolve from. If none 
             * is specified, the value of `import.meta.url` is used as the default. 
             */</span>
            <span class="s2">resolve</span><span class="s1">?</span><span class="s2">(</span><span class="s4">specified</span><span class="s1">: </span><span class="s4">string</span><span class="s2">, </span><span class="s4">parent</span><span class="s1">?: </span><span class="s4">string </span><span class="s1">| </span><span class="s4">URL</span><span class="s2">)</span><span class="s1">: </span><span class="s4">Promise</span><span class="s2">&lt;</span><span class="s4">string</span><span class="s2">&gt;;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">export = </span><span class="s4">Module</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare module </span><span class="s3">'node:module' </span><span class="s2">{</span>
    <span class="s1">import </span><span class="s4">module </span><span class="s1">= require</span><span class="s2">(</span><span class="s3">'module'</span><span class="s2">);</span>
    <span class="s1">export = </span><span class="s4">module</span><span class="s2">;</span>
<span class="s2">}</span>
</pre>
</body>
</html>